 HalpAcquireHighLevelLock  ,1
        pushfd
        pop     eax

ahll10: cli
        ACQUIRE_SPINLOCK    ecx, ahll20
        fstRET    HalpAcquireHighLevelLock

ahll20:
        push    eax
        popfd

        SPIN_ON_SPINLOCK    ecx, <ahll10>

fstENDP HalpAcquireHighLevelLock


;++
;
;  VOID
;  FASTCALL
;  HalpReleaseHighLevelLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN KIRQL       NewIrql
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock and lowers to the new irql.
;
; Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to a kernel spin lock.
;     (dl)  = NewIrql  - New irql value to set.
;
; Return Value:
;
;     None.
;
;--

cPublicFastCall HalpReleaseHighLevelLock  ,2

        RELEASE_SPINLOCK    ecx
        push    edx
        popfd
        fstRET    HalpReleaseHighLevelLock

fstENDP HalpReleaseHighLevelLock

;++
;
;  VOID
;  FASTCALL
;  ExAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquires ownership of the specified FastMutex.
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex.
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExAcquireFastMutex,1
cPublicFpo 0,0

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority (Vector)

if DBG
        ;
        ; Caller must already be at or below APC_LEVEL.
        ;

        cmp     eax, APC_VECTOR
        jg      short afm11             ; irql too high ==> fatal.
endif

        mov     dword ptr APIC[LU_TPR], APC_VECTOR ; Write New Priority to the TPR

   LOCK_DEC     dword ptr [ecx].FmCount         ; Get count
        jz      short afm_ret                   ; The owner? Yes, Done

        inc     dword ptr [ecx].FmContention

cPublicFpo 0,2
        push    ecx
        push    eax
        add     ecx, FmEvent                    ; Wait on Event
        stdCall _KeWaitForSingleObject,<ecx,WrExecutive,0,0,0>
        pop     eax                             ; (al) = OldTpr
        pop     ecx                             ; (ecx) = FAST_MUTEX

cPublicFpo 0,0
afm_ret:
        mov     byte ptr [ecx].FmOldIrql, al

        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov	dword ptr [ecx].FmOwner, esp
        fstRet  ExAcquireFastMutex

if DBG

cPublicFpo 0,1
afm11:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,033h,0>

endif

fstENDP ExAcquireFastMutex


;++
;
;  VOID
;  FASTCALL
;  ExReleaseFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function releases ownership of the FastMutex.
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex.
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExReleaseFastMutex,1
cPublicFpo 0,0

if DBG
        ;
        ; Caller must already be at APC_LEVEL or have APCs blocked.
        ;

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority (Vector)
        cmp     eax, APC_VECTOR
        je      short rfm04                     ; irql is ok.

if 0
        mov     eax, PCR[PcPrcb]
        mov     eax, [eax].PbCurrentThread      ; (eax) = Current Thread

        cmp     dword ptr [eax]+ThKernelApcDisable, 0
        jne     short rfm04                     ; APCs disabled, this is ok

        cmp     dword ptr [eax]+ThTeb, 0
        je      short rfm04             ; No TEB ==> system thread, this is ok

        test    dword ptr [eax]+ThTeb, 080000000h
        jnz     short rfm04             ; TEB in system space, this is ok
endif

        jmp     short rfm20
rfm04:
endif
        xor     eax, eax
        mov     al, byte ptr [ecx].FmOldIrql    ; (eax) = OldTpr

   LOCK_ADD     dword ptr [ecx].FmCount, 1      ; Remove our count
        js      short rfm05                     ; if < 0, set event
        jnz     short rfm10                     ; if != 0, don't set event

cPublicFpo 0,1
rfm05:  add     ecx, FmEvent
        push    eax                         ; save new tpr
        stdCall _KeSetEventBoostPriority, <ecx, 0>
        pop     eax                         ; restore tpr

cPublicFpo 0,0
rfm10:  mov     dword ptr APIC[LU_TPR], eax
        mov     ecx, dword ptr APIC[LU_TPR]
if DBG
        cmp     eax, ecx                        ; Verify TPR is what was
        je      short @f                        ; written
        int 3
@@:
endif
        fstRet  ExReleaseFastMutex

if DBG

cPublicFpo 0,1
rfm20:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,034h,0>

endif

fstENDP ExReleaseFastMutex


;++
;
;  BOOLEAN
;  FASTCALL
;  ExTryToAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquires ownership of the FastMutex.
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex.
;
;  Return Value:
;
;     Returns TRUE if the FAST_MUTEX was acquired; otherwise FALSE.
;
;--

cPublicFastCall ExTryToAcquireFastMutex,1
cPublicFpo 0,0

if DBG
        ;
        ; Caller must already be at or below APC_LEVEL.
        ;

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority (Vector)
        cmp     eax, APC_VECTOR
        jg      short tam11                     ; irql too high ==> fatal.
endif

        ;
        ; Try to acquire.
        ;

        cmp     dword ptr [ecx].FmCount, 1      ; Busy?
        jne     short tam25                     ; Yes, abort

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority (Vector)
        mov     dword ptr APIC[LU_TPR], APC_VECTOR ; Write New Priority to the TPR

cPublicFpo 0,1
        push    eax                             ; Save Old TPR

        mov     edx, 0                          ; Value to set
        mov     eax, 1                          ; Value to compare against
   LOCK_CMPXCHG dword ptr [ecx].FmCount, edx    ; Attempt to acquire
        jnz     short tam20                     ; got it?

cPublicFpo 0,0
        pop     edx                             ; (edx) = Old TPR
        mov     eax, 1                          ; return TRUE
        mov     byte ptr [ecx].FmOldIrql, dl    ; Store Old TPR
        fstRet  ExTryToAcquireFastMutex

tam20:  pop     ecx                             ; (ecx) = Old TPR
        mov     dword ptr APIC[LU_TPR], ecx
        mov     eax, dword ptr APIC[LU_TPR]

if DBG
        cmp     ecx, eax                        ; Verify TPR is what was
        je      short @f                        ; written
        int 3
@@:
endif

tam25:  xor     eax, eax                        ; return FALSE
        YIELD
        fstRet  ExTryToAcquireFastMutex         ; all done

if DBG

cPublicFpo 0,1
tam11:  stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,eax,033h,0>

endif

fstENDP ExTryToAcquireFastMutex


        page    ,132
        subttl  "Acquire Queued SpinLock Raise to Synch"

        ; compile time assert sizeof(KSPIN_LOCK_QUEUE) == 8

        .errnz  (LOCK_QUEUE_HEADER_SIZE - 8)

align 16

;++
;
; VOID
; KeAcquireInStackQueuedSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    KeAcquireInStackQueuedSpinLock...
;
;    The Kx versions use a LOCK_QUEUE_HANDLE structure rather than
;    LOCK_QUEUE structures in the PRCB.   Old IRQL is stored in the
;    LOCK_QUEUE_HANDLE.
;
; Arguments:
;
;    SpinLock   (ecx) Address of Actual Lock.
;    LockHandle (edx) Address of lock context.
;
; Return Value:
;
;   None.  Actually returns OldIrql because common code is used
;          for all implementations.
;
;--

cPublicFastCall KeAcquireInStackQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,0


ifdef NT_UP

        ; In the Uniprocessor case, just raise IRQL to SYNCH

        mov     eax, dword ptr APIC[LU_TPR]          ; (eax) = Old Priority
        shr     eax, 4
        mov     al, byte ptr _HalpVectorToIRQL[eax] ; (al) = OldIrql
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR
        mov     [edx].LqhOldIrql, al            ; save old IRQL in lock handle

        fstRET  KeAcquireInStackQueuedSpinLockRaiseToSynch

else

        ; MP case, use KeAcquireInStackQueuedSpinLock to get the lock and raise
        ; to SYNCH asap afterwards.

        call    @KeAcquireInStackQueuedSpinLock@8
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR

        fstRET  KeAcquireInStackQueuedSpinLockRaiseToSynch

endif

fstENDP KeAcquireInStackQueuedSpinLockRaiseToSynch





cPublicFastCall KeAcquireInStackQueuedSpinLock,2
cPublicFpo 0,0


        ; Raise IRQL to DISPATCH_LEVEL

        mov     eax, dword ptr APIC[LU_TPR]        ; (eax) = Old Priority
        shr     eax, 4
        mov     al, byte ptr _HalpVectorToIRQL[eax] ; (al) = OldIrql
        mov     dword ptr APIC[LU_TPR], DPC_VECTOR ; raise to DISPATCH level
        mov     [edx].LqhOldIrql, al            ; save old IRQL in lock handle

ifdef NT_UP

        fstRET  KeAcquireInStackQueuedSpinLock

else

        ; Save actual lock address in lock handle.

        mov     [edx].LqhLock, ecx
        mov     dword ptr [edx].LqhNext, 0


        ; ecx contains the address of the actual lock
        ; and edx the address of a queued lock structure.

cPublicFpo 0,1
        mov     eax, edx                        ; save Lock Queue entry address

if DBG

        test    ecx, LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT
        jnz     short iqsl98                    ; jiff lock already held (or
                                                ; this proc already waiting).
endif

        ; Exchange the value of the lock with the address of this
        ; Lock Queue entry.

        xchg    [ecx], edx

        cmp     edx, 0                          ; check if lock is held
        jnz     short iqsl40                    ; jiff held

        ; lock has been acquired.

cPublicFpo 0,0

        ; note: the actual lock address is word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [eax].LqLock, ecx

iqsl20:
        fstRET  KeAcquireInStackQueuedSpinLock

cPublicFpo 0,1

iqsl40:
        ; The lock is already held by another processor.  Set the wait
        ; bit in this processor's Lock Queue entry, then set the next
        ; field in the Lock Queue entry of the last processor to attempt
        ; to acquire the lock (this is the address returned by the xchg
        ; above) to point to THIS processor's lock queue entry.

        or      ecx, LOCK_QUEUE_WAIT            ; set waiting bit
        mov     [eax].LqLock, ecx

        mov     [edx].LqNext, eax               ; set previous acquirer's
                                                ; next field.
        ; Wait.
@@:
        test    [eax].LqLock, LOCK_QUEUE_WAIT   ; check if still waiting
        jz      short iqsl20                    ; jif lock acquired
        YIELD                                   ; fire avoidance.
        jmp     short @b                        ; else, continue waiting
        ; Wait.

if DBG

cPublicFpo 0,1
iqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,ecx,edx,0,0>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeAcquireInStackQueuedSpinLock


;++
;
; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and acquires the specified queued spinlock.
;
; Arguments:
;
;    Number (ecx) - Supplies the queued spinlock number.
;
; Return Value:
;
;    The previous IRQL is returned as the function value.
;
;--

cPublicFastCall KeAcquireQueuedSpinLockRaiseToSynch,1
cPublicFpo 0,0


ifdef NT_UP

        ; In the Uniprocessor case, just raise IRQL to SYNCH

        mov     eax, dword ptr APIC[LU_TPR]          ; (eax) = Old Priority
        shr     eax, 4
        movzx   eax, byte ptr _HalpVectorToIRQL[eax] ; (al) = OldIrql
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR

        fstRET  KeAcquireQueuedSpinLockRaiseToSynch

else

        ; MP case, use KeAcquireQueuedSpinLock to get the lock and raise
        ; to SYNCH asap afterwards.

        call    @KeAcquireQueuedSpinLock@4
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR

        fstRET  KeAcquireQueuedSpinLockRaiseToSynch

endif

fstENDP KeAcquireQueuedSpinLockRaiseToSynch


        page    ,132
        subttl  "Acquire Queued SpinLock"

;++
;
; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH level
;    and acquires the specified queued spinlock.
;
; Arguments:
;
;    Number (ecx) - Supplies the queued spinlock number.
;
; Return Value:
;
;    The previous IRQL is returned as the function value.
;
;--


cPublicFastCall KeAcquireQueuedSpinLock,1
cPublicFpo 0,0

        ; Get old priority (vector) from Local APIC's Task Priority
        ; Register and set the new priority.

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority
        shr     eax, 4
        movzx   eax, byte ptr _HalpVectorToIRQL[eax] ; (al) = OldIrql
        mov     dword ptr APIC[LU_TPR], DPC_VECTOR ; raise to DISPATCH level

ifdef NT_UP

        ; in the Uniprocessor version all we do is raise IRQL.


        fstRET  KeAcquireQueuedSpinLock

else

        ; Get address of Lock Queue entry

        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.
    
        mov     ecx, [edx].LqLock
aqsl10:
        push    eax                             ; save old IRQL
cPublicFpo 0,1
        mov     eax, edx                        ; save Lock Queue entry address

if DBG

        test    ecx, LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT
        jnz     short aqsl98                    ; jiff lock already held (or
                                                ; this proc already waiting).
endif

        ; Exchange the value of the lock with the address of this
        ; Lock Queue entry.

        xchg    [ecx], edx

        cmp     edx, 0                          ; check if lock is held
        jnz     short aqsl40                    ; jiff held

        ; lock has been acquired.

cPublicFpo 0,0

        ; note: the actual lock address is word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [eax].LqLock, ecx

aqsl20:
        pop     eax                             ; return old IRQL

        fstRET  KeAcquireQueuedSpinLock

cPublicFpo 0,1

aqsl40:
        ; The lock is already held by another processor.  Set the wait
        ; bit in this processor's Lock Queue entry, then set the next
        ; field in the Lock Queue entry of the last processor to attempt
        ; to acquire the lock (this is the address returned by the xchg
        ; above) to point to THIS processor's lock queue entry.

        or      ecx, LOCK_QUEUE_WAIT            ; set waiting bit
        mov     [eax].LqLock, ecx

        mov     [edx].LqNext, eax               ; set previous acquirer's
                                                ; next field.
cPublicFpo 0,0

        ; Wait.
@@:
        test    [eax].LqLock, LOCK_QUEUE_WAIT   ; check if still waiting
        jz      short aqsl20                    ; jif lock acquired
        YIELD                                   ; fire avoidance.
        jmp     short @b                        ; else, continue waiting

if DBG

cPublicFpo 0,1
aqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,ecx,edx,0,0>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeAcquireQueuedSpinLock


        page    ,132
        subttl  "Release Queued SpinLock"

;++
;
; VOID
; KeReleaseInStackQueuedSpinLock (
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
;    This differs from KeReleaseQueuedSpinLock in that this version
;    uses a caller supplied lock context where that one uses a
;    predefined lock context in the processor's PRCB.
;
;    This version sets up a compatible register context and uses
;    KeReleaseQueuedSpinLock to do the actual work.
;
; Arguments:
;
;    LockHandle (ecx) - Address of Lock Queue Handle structure.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseInStackQueuedSpinLock,1
cPublicFpo 0,0

        movzx   edx, byte ptr [ecx].LqhOldIrql  ; get old irql

ifndef NT_UP

        lea     eax, [ecx].LqhNext              ; get address of lock struct
        jmp     short rqsl10                    ; continue in common code

else

        ; Set the IO APIC's Task Priority Register to the value
        ; corresponding to the new IRQL.

        movzx   ecx, byte ptr _HalpIRQLtoTPR[edx]

        mov     dword ptr APIC[LU_TPR], ecx

        ; Ensure that the requested priority is set before returning,
        ; the caller is counting on it.

        mov     eax, dword ptr APIC[LU_TPR]
if DBG
        cmp     ecx, eax                ; Verify IRQL read back is same as
        je      short @f                ; set value
        int 3
@@:
endif
        fstRET  KeReleaseInStackQueuedSpinLock
endif


fstENDP KeReleaseInStackQueuedSpinLock


;++
;
; VOID
; KeReleaseQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number,
;     IN KIRQL                   OldIrql
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (dl)  - Supplies the IRQL value to lower to.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseQueuedSpinLock,2
cPublicFpo 0,0

.errnz (LOCK_QUEUE_OWNER - 2)                   ; error if not bit 1 for btr

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     eax, PCR[PcPrcb]                ; get address of PRCB

endif

        movzx   edx, dl                         ; Irql = 8 bits from edx

ifndef NT_UP

        lea     eax, [eax+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

rqsl10:
        push    ebx                             ; need another register
cPublicFpo 0,1

        ; Clear the lock field in the Lock Queue entry.

        mov     ebx, [eax].LqNext
        mov     ecx, [eax].LqLock

        ; Quick check: If Lock Queue entry's Next field is not NULL,
        ; there is another waiter.  Don't bother with ANY atomic ops
        ; in this case.
        ;
        ; Note: test clears CF and sets ZF appropriately, the following
        ; btr sets CF appropriately for the owner check.

        test    ebx, ebx

        ; clear the "I am owner" bit in the Lock entry.

        btr     ecx, 1                          ; clear owner bit.

if DBG

        jnc     short rqsl98                    ; bugcheck if was not set
                                                ; tests CF
endif

        mov     [eax].LqLock, ecx               ; clear lock bit in queue entry
        jnz     short rqsl40                    ; jif another processor waits
                                                ; tests ZF

        ; ebx contains zero here which will be used to set the new owner NULL

        push    eax                             ; save &PRCB->LockQueue[Number]
cPublicFpo 0,2

        ; Use compare exchange to attempt to clear the actual lock.
        ; If there are still no processors waiting for the lock when
        ; the compare exchange happens, the old contents of the lock
        ; should be the address of this lock entry (eax).

        lock cmpxchg [ecx], ebx                 ; store 0 if no waiters
        pop     eax                             ; restore lock queue address
cPublicFpo 0,1
        jnz     short rqsl60                    ; jif store failed

        ; The lock has been released.  Lower IRQL and return to caller.

endif

rqsl20:

        ; Set the IO APIC's Task Priority Register to the value
        ; corresponding to the new IRQL.

        movzx   ecx, byte ptr _HalpIRQLtoTPR[edx]

ifndef NT_UP

        pop     ebx                             ; restore ebx
cPublicFpo 0,0

endif

        mov     dword ptr APIC[LU_TPR], ecx

        ; Ensure that the requested priority is set before returning,
        ; the caller is counting on it.

        mov     eax, dword ptr APIC[LU_TPR]
if DBG
        cmp     ecx, eax                ; Verify IRQL read back is same as
        je      short @f                ; set value
        int 3
@@:
endif
        fstRET  KeReleaseQueuedSpinLock

ifndef NT_UP

cPublicFpo 0,1

        ; Another processor is waiting on this lock.   Hand the lock
        ; to that processor by getting the address of its LockQueue
        ; entry, turning ON its owner bit and OFF its wait bit.

rqsl40: xor     [ebx].LqLock, (LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT)

        ; Done, the other processor now owns the lock, clear the next
        ; field in my LockQueue entry (to preserve the order for entering
        ; the queue again) and proceed to lower IRQL and return.

        mov     [eax].LqNext, 0
        jmp     short rqsl20


        ; We get here if another processor is attempting to acquire
        ; the lock but had not yet updated the next field in this
        ; processor's Queued Lock Next field.   Wait for the next
        ; field to be updated.


rqsl60: mov     ebx, [eax].LqNext
        test    ebx, ebx                        ; check if still 0
        jnz     short rqsl40                    ; jif Next field now set.
        YIELD                                   ; wait a bit
        jmp     short rqsl60                    ; continue waiting

if DBG

cPublicFpo 0,1

rqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_NOT_OWNED,ecx,eax,0,1>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeReleaseQueuedSpinLock

        page    ,132
        subttl  "Try to Acquire Queued SpinLock"

;++
;
; LOGICAL
; KeTryToAcquireQueuedSpinLock (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; LOGICAL
; KeTryToAcquireQueuedSpinLockRaiseToSynch (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and attempts to acquire the specified queued spinlock.  If the
;    spinlock is already owned by another thread, IRQL is restored
;    to its previous value and FALSE is returned.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (edx) - A pointer to the variable to receive the old
;                    IRQL.
;
; Return Value:
;
;    TRUE if the lock was acquired, FALSE otherwise.
;    N.B. ZF is set if FALSE returned, clear otherwise.
;
;--


align 16
cPublicFastCall KeTryToAcquireQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,0

        push    APIC_SYNCH_VECTOR               ; raise to SYNCH
        jmp     short taqsl10                   ; continue in common code

fstENDP KeTryToAcquireQueuedSpinLockRaiseToSynch


cPublicFastCall KeTryToAcquireQueuedSpinLock,2
cPublicFpo 0,0

        push    DPC_VECTOR                      ; raise to DPC level

        ; Attempt to get the lock with interrupts disabled, raising
        ; the priority in the interrupt controller only if acquisition
        ; is successful.
taqsl10:

ifndef NT_UP

        push    edx                             ; save address of OldIrql
        pushfd                                  ; save interrupt state
cPublicFpo 0,3

        ; Get address of Lock Queue entry

        cli
        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

        mov     ecx, [edx].LqLock

if DBG

        test    ecx, LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT
        jnz     short taqsl98                   ; jiff lock already held (or
                                                ; this proc already waiting).
endif

        ; quick test, get out if already taken

        cmp     dword ptr [ecx], 0              ; check if already taken
        jnz     short taqsl60                   ; jif already taken
        xor     eax, eax                        ; comparison value (not locked)

        ; Store the Lock Queue entry address in the lock ONLY if the
        ; current lock value is 0.

        lock cmpxchg [ecx], edx
        jnz     short taqsl60

        ; Lock has been acquired.

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [edx].LqLock, ecx

        mov     eax, [esp+8]                    ; get new IRQL
        mov     edx, [esp+4]                    ; get addr to save OldIrql

else

        mov     eax, [esp]                      ; get new IRQL

endif

        ; Raise IRQL and return success.

        ; Get old priority (vector) from Local APIC's Task Priority
        ; Register and set the new priority.

        mov     ecx, dword ptr APIC[LU_TPR]     ; (ecx) = Old Priority
        mov     dword ptr APIC[LU_TPR], eax     ; Set New Priority

ifndef NT_UP

        popfd                                   ; restore interrupt state
        add     esp, 8                          ; free locals

else

        add     esp, 4                          ; free local
endif

cPublicFpo 0,0

        shr     ecx, 4
        movzx   eax, _HalpVectorToIRQL[ecx]     ; (al) = OldIrql
        mov     [edx], al                       ; save OldIrql
        xor     eax, eax                        ; return TRUE
        or      eax, 1

        fstRET  KeTryToAcquireQueuedSpinLock

ifndef NT_UP

taqsl60:
        ; The lock is already held by another processor.  Indicate
        ; failure to the caller.

        popfd                                   ; restore interrupt state
        add     esp, 8                          ; free locals
        xor     eax, eax                        ; return FALSE
        fstRET  KeTryToAcquireQueuedSpinLock

if DBG

cPublicFpo 0,2

taqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,ecx,edx,0,0>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeTryToAcquireQueuedSpinLock
_TEXT   ends

ENDIF   ; NT_INST

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpprofil.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    mpprofile.asm
;
; Abstract:
;
;    This module implements the code necessary to initialize,
;    field and process the profile interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;--

.586p
        .xlist
include hal386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
include i386\mp8254.inc

        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _KeProfileInterrupt,1,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpAcquireSystemHardwareSpinLock,0
        EXTRNP  _HalpReleaseSystemHardwareSpinLock,0
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        extrn   _HalpUse8254:BYTE

;
;   APIC Timer Constants
;

APIC_TIMER_DISABLED     equ      (INTERRUPT_MASKED OR PERIODIC_TIMER OR APIC_PROFILE_VECTOR)
APIC_TIMER_ENABLED      equ      (PERIODIC_TIMER OR APIC_PROFILE_VECTOR)

;
; number of 100ns intervals in one second
;
Num100nsIntervalsPerSec     equ     10000000

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

    ALIGN dword

public _HalpProfileRunning, _HalpPerfInterruptHandler
_HalpProfileRunning         dd  0
_HalpPerfInterruptHandler   dd  0

_DATA   ends


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
;   HalStartProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is set the interrupt rate to the value that's been set
;       by the KeSetProfileInterval routine. Then enable the APIC Timer interrupt.
;
;   This function gets called on every processor so the hal can enable
;   a profile interrupt on each processor.
;

;--

cPublicProc _HalStartProfileInterrupt    ,1

;
;   Set the interrupt rate to what is actually needed.
;

        mov     eax, PCR[PcHal.ProfileCountDown]
        mov     dword ptr APIC[LU_INITIAL_COUNT], eax

        mov     _HalpProfileRunning, 1    ; Indicate profiling
;
;   Set the Local APIC Timer to interrupt Periodically at APIC_PROFILE_VECTOR
;

        mov     dword ptr APIC[LU_TIMER_VECTOR], APIC_TIMER_ENABLED

        stdRET    _HalStartProfileInterrupt

stdENDP _HalStartProfileInterrupt

;++
;
;   HalStopProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;--

cPublicProc _HalStopProfileInterrupt    ,1

;
;   Turn off profiling
;

        mov     _HalpProfileRunning, 0    ; Indicate profiling is off
        mov     dword ptr APIC[LU_TIMER_VECTOR], APIC_TIMER_DISABLED
        stdRET    _HalStopProfileInterrupt

stdENDP _HalStopProfileInterrupt

;++
;   ULONG
;   HalSetProfileInterval (
;       ULONG Interval
;       );
;
;   Routine Description:
;
;       This procedure sets the interrupt rate (and thus the sampling
;       interval) for the profiling interrupt.
;
;   Arguments:
;
;       (TOS+4) - Interval in 100ns unit.
;                 (MINIMUM is 1221 or 122.1 uS) see ke\profobj.c
;
;   Return Value:
;
;       Interval actually used
;
;--

cPublicProc _HalSetProfileInterval    ,1

        mov     ecx, [esp+4]            ; ecx = interval in 100ns unit
        and     ecx, 7FFFFFFFh          ; Remove sign bit.

        ;
        ;   The only possible error is if we will cause a divide overflow
        ;   this can happen only if the (frequency * request count) is
        ;   greater than 2^32* Num100nsIntervalsPerSec.
        ;
        ;   To protect against that we just ensure that the request count
        ;   is less than (or equal to) Num100nsIntervalsPerSec
        ;
        cmp     ecx, Num100nsIntervalsPerSec
        jle     @f
        mov     ecx, Num100nsIntervalsPerSec
@@:

        ;
        ;   Save the interval we're using to return
        ;
        push    ecx

        ;
        ;   Compute the countdown value
        ;
        ;     let
        ;       R == caller's requested 100ns interval count
        ;       F == APIC Counter Freguency (hz)
        ;       N == Number of 100ns Intervals per sec
        ;
        ;     then
        ;       count = (R*F)/N
        ;
        ;   Get the previously computed APIC counter Freq
        ;   for this processor
        ;

        mov     eax, PCR[PcHal.ApicClockFreqHz]

        ;
        ;   eax <= F and ecx <= R
        ;

        ;
        ; Compute (request count) * (ApicClockFreqHz) == (R*F)
        ;

        xor     edx, edx
        mul     ecx

        ;
        ;   edx:eax contains 64Bits of (R*F)
        ;

        mov     ecx, Num100nsIntervalsPerSec
        div     ecx

        ;
        ; Compute (R*F) / Num100nsIntervalsPerSec == (R*F)/N
        ;

        mov     PCR[PcHal.ProfileCountDown], eax      ; Save the Computed Count Down
        mov     edx, dword ptr APIC[LU_CURRENT_COUNT]

        ;
        ;   Set the interrupt rate in the chip.
        ;

        mov     dword ptr APIC[LU_INITIAL_COUNT], eax

        pop     eax            ; Return Actual Interval Used

        stdRET    _HalSetProfileInterval

stdENDP _HalSetProfileInterval

        page ,132
        subttl  "System Profile Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a profile interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    HAL_PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = HAL_PROFILE_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hpi_a, Hpi_t

cPublicProc _HalpProfileInterrupt     ,0
;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hpi_a, Hpi_t

;
; (esp) - base of trap frame
;

        push    APIC_PROFILE_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <HAL_PROFILE_LEVEL,APIC_PROFILE_VECTOR,esp>

        cmp     _HalpProfileRunning, 0       ; Profiling?
        je      @f                          ; if not just exit

        stdCall _KeProfileInterrupt,<ebp>   ; (ebp) = TrapFrame address

@@:
        INTERRUPT_EXIT

stdENDP _HalpProfileInterrupt


        subttl  "System Perf Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a perf interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    HAL_PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = HAL_PROFILE_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hpf_a, Hpf_t

cPublicProc _HalpPerfInterrupt     ,0
;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hpf_a, Hpf_t

;
; (esp) - base of trap frame
;

        push    APIC_PERF_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <HAL_PROFILE_LEVEL,APIC_PERF_VECTOR,esp>

;
; Invoke perf interrupt handler
;

        mov     ecx, ebp                ; param1 = trap frame
        mov     eax, _HalpPerfInterruptHandler
        or      eax, eax
        jz      short hpf20

        call    eax

hpf10: 
;
; Starting with the Willamette processor, the perf interrupt gets masked on
; interrupting.  Needs to clear the mask before leaving the interrupt handler.
; Do this regardless of whether a valid interrupt handler exists or not.   
; 
        and     dword ptr APIC[LU_PERF_VECTOR], (NOT INTERRUPT_MASKED) 

        INTERRUPT_EXIT

hpf20:
if DBG
        int     3
endif
        jmp     short hpf10

stdENDP _HalpPerfInterrupt

_TEXT   ends

PAGELK  SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalCalibratePerformanceCounter (
;     IN LONG volatile *Number,
;     IN ULONGLONG NewCount
;     )
;
; /*++
;
; Routine Description:
;
;     This routine calibrates the performance counter value for a
;     multiprocessor system.  The calibration can be done by zeroing
;     the current performance counter, or by calculating a per-processor
;     skewing between each processors counter.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
;     NewCount - Supplies the value to synchronize the counter too
;
; Return Value:
;
;     None.
;--
NewCountLow     equ     [esp + 24]
NewCountHigh    equ     [esp + 28]

ifdef MMTIMER
cPublicProc _HalpAcpiTimerCalibratePerfCount,3
else
cPublicProc _HalCalibratePerformanceCounter,3
endif
cPublicFpo 3,0        
        push    esi
        push    edi
        push    ebx

        mov     esi, [esp+16]           ; pointer to Number

        pushfd                          ; save previous interrupt state
        cli                             ; disable interrupts

cPublicFpo 3,4        
        xor     eax, eax

        lock dec    dword ptr [esi]     ; count down
@@:     YIELD
        cmp     dword ptr [esi], 0      ; wait for all processors to signal
        jnz     short @b

        cpuid                           ; fence
        
        mov     ecx, MsrTSC             ; MSR of time stamp counter
        
        mov     eax, NewCountLow
        mov     edx, NewCountHigh
        mov     PCR[PcHal.PerfCounterLow], eax
        mov     PCR[PcHal.PerfCounterHigh], edx
        xor     eax,eax
        xor     edx,edx

        wrmsr                           ; zero the time stamp counter

        popfd                           ; restore interrupt flag
        pop     ebx
        pop     edi
        pop     esi
ifdef MMTIMER
        stdRET    _HalpAcpiTimerCalibratePerfCount

stdENDP _HalpAcpiTimerCalibratePerfCount
else
        stdRET    _HalCalibratePerformanceCounter

stdENDP _HalCalibratePerformanceCounter
endif

PAGELK  ends

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Scale Apic Timer"
;++
;
; VOID
; HalpScaleTimers (
;    IN VOID
;    )
;
; Routine Description:
;
;   Determines the frequency of the APIC timer.  This routine is run
;   during initialization
;
;
;--

cPublicProc _HalpScaleTimers ,0
        push    ebx
        push    esi
        push    edi

;
;   Don't let anyone in until we've finished here
;
        stdCall   _HalpAcquireCmosSpinLock

;
;   Protect us from interrupts
;
        pushfd
        cli

;
;   First set up the Local Apic Counter
;
;   The following code assumes the CPU clock will never
;   exceed 4Ghz.  For the short term this is probably OK
;

;
;   Configure the APIC timer
;

APIC_TIMER_DISABLED     equ      (INTERRUPT_MASKED OR PERIODIC_TIMER OR APIC_PROFILE_VECTOR)
TIMER_ROUNDING          equ      10000


        mov     dword ptr APIC[LU_TIMER_VECTOR], APIC_TIMER_DISABLED
        mov     dword ptr APIC[LU_DIVIDER_CONFIG], LU_DIVIDE_BY_1

;
;   We're going to do this twice & take the second results
;
        mov     esi, 2
hst10:

;
;   Make sure the write has occurred
;
        mov     eax, dword ptr APIC[LU_DIVIDER_CONFIG]

;
;   We don't care what the actual time is we are only interested
;   in seeing the UIP transition.  We are garenteed a 1 sec interval
;   if we wait for the UIP bit to complete an entire cycle.

;
;   We also don't much care which direction the transition we use is
;   as long as we wait for the same transition to read the APIC clock.
;   Just because it is most likely that when we begin the UIP bit will
;   be clear, we'll use the transition from !UIP to UIP.
;

;
;   Wait for the UIP bit to be cleared, this is our starting state
;

@@:
        mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jnz     short @b                ; if z, no, wait some more

;
;   Wait for the UIP bit to get set
;

@@:
        mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short @b                ; if z, no, wait some more

;
;   At this point we found the UIP bit set, now set the initial
;   count.  Once we write this register its value is copied to the
;   current count register and countdown starts or continues from
;   there
;

        xor     eax, eax
        mov     PCR[PcHal.PerfCounterLow], eax
        mov     PCR[PcHal.PerfCounterHigh], eax        

        cpuid                           ; fence

        mov     ecx, MsrTSC             ; MSR of RDTSC
        xor     edx, edx
        mov     eax, edx
        mov     dword ptr APIC[LU_INITIAL_COUNT], 0FFFFFFFFH
        wrmsr                           ; Clear TSC count

;
;   Wait for the UIP bit to be cleared again
;

@@:
        mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jnz     short @b                ; if z, no, wait some more

;
;   Wait for the UIP bit to get set
;

@@:
        mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short @b                ; if z, no, wait some more

;
;   The cycle is complete, we found the UIP bit set. Now read
;   the counters and compute the frequency.  The frequency is
;   just the ticks counted which is the initial value minus
;   the current value.
;

        xor     eax, eax
        cpuid                           ; fence

        rdtsc
        mov     ecx, dword ptr APIC[LU_CURRENT_COUNT]

        dec     esi                     ; if this is the first time
        jnz     hst10                   ; around, go loop

        mov     PCR[PcHal.TSCHz], eax

        mov     eax, 0FFFFFFFFH
        sub     eax, ecx

;
;  Round the Apic Timer Freq
;

        xor     edx, edx                ; (edx:eax) = dividend

        mov     ecx, TIMER_ROUNDING
        div     ecx                     ; now edx has remainder

        cmp     edx, TIMER_ROUNDING / 2
        jle     @f                      ; if less don't round
        inc     eax                     ; else round up
@@:

;
;   Multiply by the  Rounding factor to get the rounded Freq
;
        mov     ecx, TIMER_ROUNDING
        xor     edx, edx
        mul     ecx

        mov     dword ptr PCR[PcHal.ApicClockFreqHz], eax

;
; Round TSC freq
;

        mov     eax, PCR[PcHal.TSCHz]
        xor     edx, edx

        mov     ecx, TIMER_ROUNDING
        div     ecx                     ; now edx has remainder

        cmp     edx, TIMER_ROUNDING / 2
        jle     @f                      ; if less don't round
        inc     eax                     ; else round up
@@:
        mov     ecx, TIMER_ROUNDING
        xor     edx, edx
        mul     ecx

        mov     PCR[PcHal.TSCHz], eax

;
; Convert TSC to microseconds
;

        xor     edx, edx
        mov     ecx, 1000000
        div     ecx                     ; Convert to microseconds

        xor     ecx, ecx
        cmp     ecx, edx                ; any remainder?
        adc     eax, ecx                ; Yes, add one

        mov     PCR[PcStallScaleFactor], eax

        stdCall _HalpReleaseCmosSpinLock

;
;   Return Value is the timer frequency
;

        mov     eax, dword ptr PCR[PcHal.ApicClockFreqHz]
        mov     PCR[PcHal.ProfileCountDown], eax

;
;   Set the interrupt rate in the chip.
;

        mov     dword ptr APIC[LU_INITIAL_COUNT], eax

        popfd

        pop     edi
        pop     esi
        pop     ebx

        stdRET    _HalpScaleTimers
stdENDP _HalpScaleTimers


INIT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpsproca.asm ===
title "MP primitives for MP+AT Systems"

;++
;
;Copyright (c) 1991  Microsoft Corporation
;Copyright (c) 1992  Intel Corporation
;All rights reserved
;
;INTEL CORPORATION PROPRIETARY INFORMATION
;
;This software is supplied to Microsoft under the terms
;of a license agreement with Intel Corporation and may not be
;copied nor disclosed except in accordance with the terms
;of that agreement.
;
;
;Module Name:
;
;    mpsproca.asm
;
;Abstract:
;
;   PC+MP Start Next Processor assemble code
;
;   This module along with mpspro.c implement the code to start
;   processors on MP+AT Systems.
;
;Author:
;
;   Ken Reneris (kenr) 12-Jan-1992
;
;Revision History:
;
;    Ron Mosgrove (Intel) - Modified to support PC+MP Systems
;
;--



.386p
        .xlist
include i386\ixcmos.inc
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
include i386\ixslpctx.inc
        .list

ifndef NT_UP
    EXTRNP  _HalpBuildTiledCR3,1
    EXTRNP  _HalpFreeTiledCR3,0
    EXTRNP  _HalpStartProcessor,2
endif

    EXTRNP  _HalpAcquireCmosSpinLock
    EXTRNP  _HalpReleaseCmosSpinLock

    EXTRNP  _HalDisplayString,1

    EXTRNP  _HalpMarkProcessorStarted,2

    EXTRNP  _StartPx_BuildRealModeStart,1
    EXTRNP  _KeStallExecutionProcessor, 1
    
    extrn   _Halp1stPhysicalPageVaddr:DWORD
    extrn   _HalpLowStub:DWORD
    extrn   _HalpLowStubPhysicalAddress:DWORD
    extrn   _HalpHiberInProgress:BYTE
    extrn   _CurTiledCr3LowPart:DWORD

;
;   Internal defines and structures
;

WarmResetVector     equ     467h   ; warm reset vector in ROM data segment

PAGELK    SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; BOOLEAN
; HalStartNextProcessor (
;   IN PLOADER_BLOCK      pLoaderBlock,
;   IN PKPROCESSOR_STATE  pProcessorState
; )
;
; Routine Description:
;
;    This routine is called by the kernel durning kernel initialization
;    to obtain more processors.  It is called until no more processors
;    are available.
;
;    If another processor exists this function is to initialize it to
;    the passed in processorstate structure, and return TRUE.
;
;    If another processor does not exists or if the processor fails to
;    start, then a FALSE is returned.
;
;    Also note that the loader block has been setup for the next processor.
;    The new processor logical thread number can be obtained from it, if
;    required.
;
;    In order to use the Startup IPI the real mode startup code must be
;    page aligned.  The HalpLowStubPhysicalAddress has always been page
;    aligned but because the PxParamBlock was placed first in this
;    segment the real mode code has been something other than page aligned.
;    This has been changed by making the first entry in the PxParamBlock
;    a jump instruction to the real mode startup code.
;
; Arguments:
;    pLoaderBlock,  - Loader block which has been intialized for the
;             next processor.
;
;    pProcessorState    - The processor state which is to be loaded into
;             the next processor.
;
;
; Return Value:
;
;    TRUE  - ProcessorNumber was dispatched.
;    FALSE - A processor was not dispatched. no other processors exists.
;
;--

pLoaderBlock        equ dword ptr [ebp+8]   ; zero based
pProcessorState     equ dword ptr [ebp+12]

;
; Local variables
;

PxFrame             equ [ebp - size PxParamBlock]
LWarmResetVector    equ [ebp - size PxParamBlock - 4]
LStatusCode         equ [ebp - size PxParamBlock - 8]
LCmosValue          equ [ebp - size PxParamBlock - 12]
Prcb                equ [ebp - size PxParamBlock - 16]


cPublicProc _HalStartNextProcessor ,2
ifdef NT_UP
    xor     eax, eax                    ; up build of hal, no processors to
    stdRET  _HalStartNextProcessor      ; start
else
    push    ebp                         ; save ebp
    mov     ebp, esp                    ; Save Frame
    sub     esp, size PxParamBlock + 16 ; Make room for local vars

    push    esi                         ; Save required registers
    push    edi
    push    ebx
    pushfd

    xor     eax, eax
    mov     LStatusCode, eax

    mov     PxFrame.SPx_flag, eax       ; Initialize the MP Completion flag

    ;
    ;  Copy Processor state into the stack based Parameter Block
    ;
    lea     edi, PxFrame.SPx_PB         ; Destination on stack
    mov     esi, pProcessorState        ; Input parameter address
    mov     ecx, ProcessorStateLength   ; Structure length
    rep movsb

    ;
    ; Build a CR3 for the starting processor. If returning 
    ; from hibernation, then use setup tiled CR3 else
    ; create a new map
    ; 

    mov		al, _HalpHiberInProgress
    or		al, al
    jz		Hpsnp_Hiber

    mov		eax, _CurTiledCr3LowPart
    jmp		Hpsnp_TiledCr3_done

Hpsnp_Hiber:
    stdCall _HalpBuildTiledCR3, <pProcessorState>

Hpsnp_TiledCr3_done:
    ;
    ; Save the special registers
    ;
    mov     PxFrame.SPx_TiledCR3, eax    ; Newly contructed CR3
    mov     PxFrame.SPx_P0EBP, ebp       ; Stack pointer

    lea     eax, PxFrame
    stdCall _StartPx_BuildRealModeStart, <eax>
    
    ;
    ;  Set the BIOS warm reset vector to our routine in Low Memory
    ;
    mov     ebx, _Halp1stPhysicalPageVaddr
    add     ebx, WarmResetVector

    cli

    mov     eax, [ebx]                      ; Get current vector
    mov     LWarmResetVector, eax           ; Save it

    ;
    ;  Actually build the vector (Seg:Offset)
    ;
    mov     eax, _HalpLowStubPhysicalAddress
    shl     eax, 12                         ; seg:0
    mov     dword ptr [ebx], eax            ; start Px at Seg:0

    ;
    ;  Tell BIOS to Jump Via The Vector we gave it
    ;  By setting the Reset Code in CMOS
    ;

    stdCall _HalpAcquireCmosSpinLock
    mov     al, 0fh
    CMOS_READ
    mov     LCmosValue, eax

    mov     eax, 0a0fh
    CMOS_WRITE
    stdCall _HalpReleaseCmosSpinLock

    ;
    ;  Start the processor
    ;

    mov     eax, pLoaderBlock               ; lookup processor # we are
    mov     eax, [eax].LpbPrcb              ; starting
    mov     Prcb, eax                       ; save this away for later
    movzx   eax, byte ptr [eax].PbNumber

    stdCall _HalpStartProcessor < _HalpLowStubPhysicalAddress, eax >
    or      eax, eax
    jnz     short WaitTilPnOnline

    ;
    ;  Zero Return Value means couldn't kick start the processor
    ;  so there's no point in waiting for it.
    ;

    jmp     NotWaitingOnProcessor

WaitTilPnOnline:
    dec     eax                         ; Local APIC ID

    mov     ecx, Prcb
    mov     [ecx].PbHalReserved.PrcbPCMPApicId, al

    ;
    ;  We can't proceed until the started processor gives us the OK
    ;

    mov     edi, 200
    mov     esi, _HalpLowStub
    
WaitAbit:
    cmp     [esi].SPx_flag, 0               ; wait for Px to get it's
    jne     short ProcessorStarted          ; info

    stdCall _KeStallExecutionProcessor, <2000>
    
    dec     edi
    cmp     edi, 0
    jne     short WaitAbit
    jmp     short NotWaitingOnProcessor

ProcessorStarted:
    mov     LStatusCode, 1              ; Return TRUE

    mov     ecx, Prcb                   ; save this away for later
    movzx   ecx, byte ptr [ecx].PbNumber
    stdCall _HalpMarkProcessorStarted, <eax, ecx>

NotWaitingOnProcessor:
    mov		al, _HalpHiberInProgress
    or          al, al
    jnz		short Hpsnp_ResetVector

    stdCall _HalpFreeTiledCR3           ; free memory used for tiled CR3
                                        
Hpsnp_ResetVector:    
    mov     eax, LWarmResetVector
    mov     [ebx], eax                  ; Restore reset vector

    stdCall _HalpAcquireCmosSpinLock
    mov     eax, LCmosValue             ; Restore the Cmos setting
    shl     eax, 8
    mov     al, 0fh
    CMOS_WRITE
    stdCall _HalpReleaseCmosSpinLock

    mov     eax, LStatusCode

snp_exit:
    popfd
    pop     ebx
    pop     edi
    pop     esi
    mov     esp, ebp
    pop     ebp
    stdRET  _HalStartNextProcessor
endif

stdENDP _HalStartNextProcessor


PAGELK    ends                            ; end 32 bit code

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;Copyright (c) 1992  Intel Corporation
;All rights reserved
;
;INTEL CORPORATION PROPRIETARY INFORMATION
;
;This software is supplied to Microsoft under the terms
;of a license agreement with Intel Corporation and may not be
;copied nor disclosed except in accordance with the terms
;of that agreement.
;
;
;Module Name:
;
;    mpsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to begin/end
;    system interrupts for a PC+MP implementation
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;    Ron Mosgrove (Intel) Aug 1993
;        Modified for PC+MP Systems
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
        .list

        EXTRNP  _KeBugCheck,1,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT
        extrn  _HalpVectorToIRQL:byte
        extrn  _HalpIRQLtoTPR:byte

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "End System Interrupt"
;++
;
; VOID
; HalpEndSystemInterrupt
;    IN KIRQL NewIrql,
;    IN ULONG Vector
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Vector - Vector number of the interrupt
;
;    Note that esp+12 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HeiNewIrql      equ     [esp + 4]
HeiVector       equ     [esp + 8]

cPublicProc _HalEndSystemInterrupt  ,2
cPublicFpo 2, 0
        xor     ecx,ecx
        mov     cl, byte ptr HeiNewIrql         ; get new IRQL
        mov     cl, _HalpIRQLtoTPR[ecx]         ; get corresponding TPR value

        mov     dword ptr APIC[LU_EOI], 0       ; send EOI to APIC local unit
        APICFIX edx

        cmp     cl, DPC_VECTOR                  ; Is new irql < DPC?
        jc      short es10                      ; Yes, go check for pending DPC

es05:   mov     dword ptr APIC[LU_TPR], ecx     ; Set new Priority

;
; We have to ensure that the requested priority is set before
; we return.  The caller is counting on it.
;
        mov     edx, dword ptr APIC[LU_TPR]
        CHECKTPR   ecx, edx
        stdRET    _HalEndSystemInterrupt

es10:   cmp     PCR[PcHal.DpcPending], 0        ; Is a DPC pending?
        mov     PCR[PcHal.ShortDpc], 0          ; Clear short dpc flag
        jz      short es05                      ; No, eoi

        mov     dword ptr APIC[LU_TPR], DPC_VECTOR  ; lower to DPC level
        APICFIX edx

        push    ebx                             ; Save EBX (used by KiDispatchInterrupt)
        push    ecx                             ; Save OldIrql
cPublicFpo 2, 2

        sti

es20:   mov     PCR[PcHal.DpcPending], 0        ; Clear pending flag

        stdCall _KiDispatchInterrupt            ; Dispatch interrupt

        cli

        pop     ecx
        pop     ebx
        jmp     short es05

stdENDP _HalEndSystemInterrupt


;++
;
;BOOLEAN
;HalBeginSystemInterrupt(
;    IN KIRQL Irql
;    IN ULONG Vector,
;    OUT PKIRQL OldIrql
;    )
;
;Routine Description:
;
;   This routine raises the IRQL to the level of the specified
;   interrupt vector.  It is called by the hardware interrupt
;   handler before any other interrupt service routine code is
;   executed.  The CPU interrupt flag is set on exit.
;
;   On APIC-based systems we do not need to check for spurious
;   interrupts since they now have their own vector.  We also
;   no longer need to check whether or not the incoming priority
;   is higher than the current priority that is guaranteed by
;   the priority mechanism of the APIC.
;
;   SO
;
;   All BeginSystemInterrupt needs to do is set the APIC TPR
;   appropriate for the IRQL, and return TRUE.  Note that to
;   use the APIC ISR priority we are not going issue EOI until
;   EndSystemInterrupt is called.
;
; Arguments:
;
;    Irql   - Supplies the IRQL to raise to
;
;    Vector - Supplies the vector of the interrupt to be
;             handled
;
;    OldIrql- Location to return OldIrql
;
; Return Value:
;
;    TRUE -  Interrupt successfully dismissed and Irql raised.
;            This routine can not fail.
;
;--


align dword
HbsiIrql        equ     byte  ptr [esp+4]
HbsiVector      equ     byte  ptr [esp+8]
HbsiOldIrql     equ     dword ptr [esp+12]

cPublicProc _HalBeginSystemInterrupt ,3
cPublicFpo 3, 0

        xor     eax, eax
        mov     al, HbsiIrql            ; (eax) = New Vector
        mov     al, _HalpIRQLtoTPR[eax]     ; get corresponding TPR value

        ;
        ; Read the TPR for the Priority (Vector) in use,
        ; and convert it to an IRQL
        ;

        mov     ecx, dword ptr APIC[LU_TPR]   ; Get the Priority
        mov     dword ptr APIC[LU_TPR], eax
        APICFIX edx

        mov     eax, HbsiOldIrql        ; return the current IRQL as OldIrql
        shr     ecx, 4
        mov     cl, byte ptr _HalpVectorToIRQL[ecx]

        mov     byte ptr [eax], cl
        mov     eax, 1                  ; return TRUE
        sti

        ;
        ; If OldIrql < DISPATCH_LEVEL and new irql >= DISPATCH_LEVEL (which
        ; is assumed), then set
        ;

        cmp     cl, DISPATCH_LEVEL
        jnc     short bs10

if DBG
        cmp     PCR[PcHal.ShortDpc], 0
        je      short @f
        int 3
@@:
endif
        mov     PCR[PcHal.ShortDpc], DISPATCH_LEVEL

bs10:
        stdRET    _HalBeginSystemInterrupt
stdENDP _HalBeginSystemInterrupt

_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpsysbus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    mpsysbus.c

Abstract:

Author:

Environment:

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "apic.inc"
#include "pcmp_nt.inc"

ULONG HalpDefaultInterruptAffinity = 0;

#ifndef ACPI_HAL
ULONG
HalpGetEisaInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );
#else

#undef HalpGetEisaInterruptVector
#define HalpGetEisaInterruptVector HalpGetSystemInterruptVector

extern BUS_HANDLER HalpFakePciBusHandler;
#endif

extern UCHAR HalpVectorToIRQL[];
extern UCHAR HalpIRQLtoTPR[];
extern USHORT HalpVectorToINTI[];
extern KSPIN_LOCK HalpAccountingLock;
extern struct HalpMpInfo HalpMpInfoTable;
extern UCHAR HalpMaxProcsPerCluster;
extern INTERRUPT_DEST HalpIntDestMap[];

ULONG HalpINTItoVector[MAX_INTI];
UCHAR HalpPICINTToVector[16];

extern ULONG HalpMaxNode;
extern ULONG HalpNodeAffinity[MAX_NODES];

UCHAR HalpNodeBucket[MAX_NODES];

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpSetInternalVector)
#pragma alloc_text(PAGELK,HalpGetSystemInterruptVector)
#pragma alloc_text(PAGE, HalIrqTranslateResourceRequirementsRoot)
#pragma alloc_text(PAGE, HalTranslatorReference)
#pragma alloc_text(PAGE, HalTranslatorDereference)
#endif

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    )

/*++

Routine Description:

    This routine performs a very similar function to HalTranslateBusAddress
    except that InterfaceType and BusNumber are not known by the caller.
    This function will walk all busses known by the HAL looking for a
    valid translation for the input BusAddress of type AddressSpace.

    This function is recallable using the input/output Context parameter.
    On the first call to this routine for a given translation the ULONG_PTR
    Context should be NULL.  Note:  Not the address of it but the contents.

    If the caller decides the returned translation is not the desired
    translation, it calls this routine again passing Context in as it
    was returned on the previous call.  This allows this routine to
    traverse the bus structures until the correct translation is found
    and is provided because on multiple bus systems, it is possible for
    the same resource to exist in the independent address spaces of
    multiple busses.

Arguments:

    BusAddress          Address to be translated.
    AddressSpace        0 = Memory
                        1 = IO (There are other possibilities).
                        N.B. This argument is a pointer, the value
                        will be modified if the translated address
                        is of a different address space type from
                        the untranslated bus address.
    TranslatedAddress   Pointer to where the translated address
                        should be stored.
    Context             Pointer to a ULONG_PTR. On the initial call,
                        for a given BusAddress, it should contain
                        0.  It will be modified by this routine,
                        on subsequent calls for the same BusAddress
                        the value should be handed in again,
                        unmodified by the caller.
    NextBus             FALSE if we should attempt this translation
                        on the same bus as indicated by Context,
                        TRUE if we should be looking for another
                        bus.

Return Value:

    TRUE    if translation was successful,
    FALSE   otherwise.

--*/

{
    //
    // First, make sure the context parameter was supplied and is
    // being used correctly.  This also ensures that the caller
    // doesn't get stuck in a loop looking for subsequent translations
    // for the same thing.  We won't succeed the same translation twice
    // unless the caller reinits the context.
    //

    if ((!Context) || (*Context && (NextBus == TRUE))) {
        return FALSE;
    }
    *Context = 1;

    //
    // PC/AT (halx86) case is simplest, there is no translation.
    //

    *TranslatedAddress = BusAddress;
    return TRUE;
}

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    BOOLEAN             status;
    PSUPPORTED_RANGE    pRange;

    status = FALSE;

    switch (*AddressSpace) {
    case 0:
        if (BusHandler->InterfaceType != PCIBus) {

            // verify memory address is within buses memory limits

            pRange = &BusHandler->BusAddresses->Memory;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                        BusAddress.QuadPart <= pRange->Limit;
                pRange = pRange->Next;
            }

            pRange = &BusHandler->BusAddresses->PrefetchMemory;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                        BusAddress.QuadPart <= pRange->Limit;

                pRange = pRange->Next;
            }
        } else {
            //
            // This is a PCI bus and SystemBase is constant for all ranges
            //

            pRange = &BusHandler->BusAddresses->Memory;

            status = TRUE;
        }
        break;

    case 1:
        if (BusHandler->InterfaceType != PCIBus) {
            // verify IO address is within buses IO limits
            pRange = &BusHandler->BusAddresses->IO;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                         BusAddress.QuadPart <= pRange->Limit;

                pRange = pRange->Next;
            }
        } else {
            //
            // This is a PCI bus and SystemBase is constant for all ranges
            //

            pRange = &BusHandler->BusAddresses->IO;

            status = TRUE;
        }
        break;

    default:
        status = FALSE;
        break;
    }

    if (status) {
        *TranslatedAddress = BusAddress;
    } else {
        _asm { nop };       // good for debugging
    }

    return status;
}


#define MAX_SYSTEM_IRQL     31
#define MAX_FREE_IRQL       26
#define MIN_FREE_IRQL       4
#define MAX_FREE_IDTENTRY   0xbf
#define MIN_FREE_IDTENTRY   0x51
#define IDTENTRY_BASE       0x50
#define MAX_VBUCKET          7

#define AllocateVectorIn(index)     \
    vBucket[index]++;               \
    ASSERT (vBucket[index] < 16);

#define GetIDTEntryFrom(index)  \
    (UCHAR) ( index*16 + IDTENTRY_BASE + vBucket[index] )
    // note: device levels 50,60,70,80,90,A0,B0 are not allocatable

#define GetIrqlFrom(index)  (KIRQL) ( index + MIN_FREE_IRQL )

UCHAR   nPriority[MAX_NODES][MAX_VBUCKET];

ULONG
HalpGetSystemInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

    This function returns the system interrupt vector and IRQL
    corresponding to the specified bus interrupt level and/or
    vector.  The system interrupt vector and IRQL are suitable
    for use in a subsequent call to KeInitializeInterrupt.

Arguments:

    InterruptLevel - Supplies the bus specific interrupt level.

    InterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG           SystemVector;
    USHORT          ApicInti;
    UCHAR           IDTEntry;
    ULONG           Bucket, i, OldLevel;
    BOOLEAN         Found;
    PVOID           LockHandle;
    ULONG           Node;
    PUCHAR          vBucket;

    UNREFERENCED_PARAMETER( InterruptVector );
    //
    // TODO: Remove when Affinity becomes IN OUT.
    *Affinity = ~0;
    //
    // Restrict Affinity if required.
    if (HalpMaxProcsPerCluster == 0)  {
        *Affinity &= HalpDefaultInterruptAffinity;
    }

    //
    // Find closest child bus to this handler
    //

    if (RootHandler != BusHandler) {
        while (RootHandler->ParentHandler != BusHandler) {
            RootHandler = RootHandler->ParentHandler;
        }
    }

    //
    // Find Interrupt's APIC Inti connection
    //

    Found = HalpGetApicInterruptDesc (
                RootHandler->InterfaceType,
                RootHandler->BusNumber,
                InterruptLevel,
                &ApicInti
                );

    if (!Found) {
        return 0;
    }

    //
    // If device interrupt vector mapping is not already allocated,
    // then do it now
    //

    if (!HalpINTItoVector[ApicInti]) {

        //
        // Vector is not allocated - synchronize and check again
        //

        LockHandle = MmLockPagableCodeSection (&HalpGetSystemInterruptVector);
        OldLevel = HalpAcquireHighLevelLock (&HalpAccountingLock);
        if (!HalpINTItoVector[ApicInti]) {

            //
            // Still not allocated
            //

            //
            // Pick a node.  In the future, Affinity will be INOUT and
            // we will have to screen the node against the input affinity.
            if (HalpMaxNode == 1)  {
                Node = 1;
            } else {
                //
                // Find a node that meets the affinity requirements.
                // Nodes are numbered 1..n, so 0 means we are done.
                for (i = HalpMaxNode; i; i--) {
                    if ((*Affinity & HalpNodeAffinity[i-1]) == 0)
                        continue;
                    Node = i;
                    break;
                }
                ASSERT(Node != 0);
                //
                // Look for a "less busy" alternative.
                for (i = Node-1; i; i--) {
                    //
                    // Check input Affinity to see if this node is permitted.
                    if ((*Affinity & HalpNodeAffinity[i-1]) == 0)
                        continue;
                    //
                    // Take the least busy of the permitted nodes.
                    if (HalpNodeBucket[i-1] < HalpNodeBucket[Node-1]) {
                        Node = i;
                    }
                }
            }
            HalpNodeBucket[Node-1]++;
            *Affinity = HalpNodeAffinity[Node-1];
            vBucket = nPriority[Node-1];

            //
            // Choose the least busy priority on the node.
            Bucket = MAX_VBUCKET-1;
            for (i = Bucket-1; i; i--) {
                if (vBucket[i] < vBucket[Bucket]) {
                    Bucket = i;
                }
            }
            AllocateVectorIn (Bucket);

            //
            // Now form the vector for the kernel.
            IDTEntry = GetIDTEntryFrom (Bucket);
            SystemVector = HalpVector(Node, IDTEntry);
            ASSERT(IDTEntry <= MAX_FREE_IDTENTRY);
            ASSERT(IDTEntry >= MIN_FREE_IDTENTRY);

            *Irql = GetIrqlFrom (Bucket);
            ASSERT(*Irql <= MAX_FREE_IRQL);
            ASSERT((UCHAR) (HalpIRQLtoTPR[*Irql] & 0xf0) == (UCHAR) (IDTEntry & 0xf0) );

            HalpVectorToIRQL[IDTEntry >> 4] = (UCHAR)  *Irql;
            HalpVectorToINTI[SystemVector]  = (USHORT) ApicInti;
            HalpINTItoVector[ApicInti]      =          SystemVector;

            //
            // If this assigned interrupt is connected to the machines PIC,
            // then remember the PIC->SystemVector mapping.
            //

            if (RootHandler->BusNumber == 0  &&  InterruptLevel < 16  &&
                 RootHandler->InterfaceType == DEFAULT_PC_BUS) {
                HalpPICINTToVector[InterruptLevel] = (UCHAR) SystemVector;
            }

        }

        HalpReleaseHighLevelLock (&HalpAccountingLock, OldLevel);
        MmUnlockPagableImageSection (LockHandle);
    }

    //
    // Return this ApicInti's system vector & irql
    //

    SystemVector = HalpINTItoVector[ApicInti];
    *Irql = HalpVectorToIRQL[HalVectorToIDTEntry(SystemVector) >> 4];

    ASSERT(HalpVectorToINTI[SystemVector] == (USHORT) ApicInti);
    
    //
    // Find an appropriate affinity.
    //
    Node = HalpVectorToNode(SystemVector);
    *Affinity &= HalpNodeAffinity[Node-1];
    if (!*Affinity) {
        return 0;
    }

    return SystemVector;
}

VOID
HalpSetInternalVector (
    IN ULONG    InternalVector,
    IN VOID   (*HalInterruptServiceRoutine)(VOID)
    )
/*++

Routine Description:

    Used at init time to set IDT vectors for internal use.

--*/
{
    //
    // Remember this vector so it's reported as Hal internal usage
    //

//  HalpRegisterVector (
//      InternalUsage,
//      InternalVector,
//      InternalVector,
//      HalpVectorToIRQL[InternalVector >> 4]
//  );

    //
    // Connect the IDT
    //

    KiSetHandlerAddressToIDT(InternalVector, HalInterruptServiceRoutine);
}

//
// This section implements a "translator," which is the PnP-WDM way
// of doing the same thing that the first part of this file does.
//
VOID
HalTranslatorReference(
    PVOID Context
    )
{
    return;
}

VOID
HalTranslatorDereference(
    PVOID Context
    )
{
    return;
}

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function takes a CM_PARTIAL_RESOURCE_DESCRIPTOR and translates
    it to an IO-bus-relative from a Processor-bus-relative form, or the other
    way around.  In this x86-specific example, an IO-bus-relative form is the
    ISA IRQ and the Processor-bus-relative form is the IDT entry and the
    associated IRQL.

    N.B.  This funtion has an associated "Direction."  These are not exactly
          reciprocals.  This has to be the case because the output from
          HalIrqTranslateResourceRequirementsRoot will be used as the input
          for the ParentToChild case.

          ChildToParent:

            Level  (ISA IRQ)        -> IRQL
            Vector (ISA IRQ)        -> x86 IDT entry
            Affinity (not refereced)-> KAFFINITY

          ParentToChild:

            Level (not referenced)  -> (ISA IRQ)
            Vector (IDT entry)      -> (ISA IRQ)
            Affinity                -> 0xffffffff

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    Direction   - direction of translation (parent to child or child to parent)

    AlternativesCount   - unused

    Alternatives        - unused

    PhysicalDeviceObject- unused

    Target      - translated descriptor

Return Value:

    status

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PBUS_HANDLER    bus;
    KAFFINITY       affinity;
    KIRQL           irql;
    ULONG           vector;
    USHORT          inti;
#ifdef ACPI_HAL
    BUS_HANDLER     fakeIsaBus;
#endif

    PAGED_CODE();

    UNREFERENCED_PARAMETER(AlternativesCount);
    UNREFERENCED_PARAMETER(Alternatives);
    UNREFERENCED_PARAMETER(PhysicalDeviceObject);

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    switch (Direction) {
    case TranslateChildToParent:

#ifdef ACPI_HAL

        RtlCopyMemory(&fakeIsaBus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        fakeIsaBus.InterfaceType = Isa;
        fakeIsaBus.ParentHandler = &fakeIsaBus;
        bus = &fakeIsaBus;
#else

        if ((INTERFACE_TYPE)Context == InterfaceTypeUndefined) { // special "IDE" cookie

            ASSERT(Source->u.Interrupt.Level == Source->u.Interrupt.Vector);

            bus = HalpFindIdeBus(Source->u.Interrupt.Vector);

        } else {

            bus = HaliHandlerForBus((INTERFACE_TYPE)Context, 0);
        }

        if (!bus) {
            return STATUS_NOT_FOUND;
        }
#endif

        //
        // Copy everything
        //
        *Target = *Source;

        //
        // Translate the IRQ
        //

        vector = HalpGetEisaInterruptVector(bus,
                                            bus,
                                            Source->u.Interrupt.Level,
                                            Source->u.Interrupt.Vector,
                                            &irql,
                                            &affinity);

        if (vector == 0) {
            return STATUS_UNSUCCESSFUL;
        }

        Target->u.Interrupt.Level  = irql;
        Target->u.Interrupt.Vector = vector;
        Target->u.Interrupt.Affinity = affinity;

        if (NT_SUCCESS(status)) {
            status = STATUS_TRANSLATION_COMPLETE;
        }

        break;

    case TranslateParentToChild:

        //
        // Copy everything
        //
        *Target = *Source;

        //
        // There is no inverse to HalpGetSystemInterruptVector, so we
        // just do what that function would do.
        //

        inti = HalpVectorToINTI[Source->u.Interrupt.Vector];

        Target->u.Interrupt.Level = Target->u.Interrupt.Vector =
            HalpInti2BusInterruptLevel(inti);

        Target->u.Interrupt.Affinity = 0xFFFFFFFF;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes an IO_RESOURCE_DESCRIPTOR and translates
    it from an IO-bus-relative to a Processor-bus-relative form.  In this
    x86-specific example, an IO-bus-relative form is the ISA IRQ and the
    Processor-bus-relative form is the IDT entry and the associated IRQL.
    This is essentially a PnP form of HalGetInterruptVector.

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    PhysicalDeviceObject- unused

    TargetCount - 1

    Target      - translated descriptor

Return Value:

    status

--*/
{
    PBUS_HANDLER    bus;
    KAFFINITY       affinity;
    KIRQL           irql;
    ULONG           vector;
    BOOLEAN         success = TRUE;
#ifdef ACPI_HAL
    BUS_HANDLER     fakeIsaBus;
#endif

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

#ifdef ACPI_HAL

        RtlCopyMemory(&fakeIsaBus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        fakeIsaBus.InterfaceType = Isa;
        fakeIsaBus.ParentHandler = &fakeIsaBus;
        bus = &fakeIsaBus;
#else

    if ((INTERFACE_TYPE)Context == InterfaceTypeUndefined) { // special "IDE" cookie

        ASSERT(Source->u.Interrupt.MinimumVector == Source->u.Interrupt.MaximumVector);

        bus = HalpFindIdeBus(Source->u.Interrupt.MinimumVector);

    } else {

        bus = HaliHandlerForBus((INTERFACE_TYPE)Context, 0);
    }

    if (!bus) {
        
        //
        // There is no valid translation.
        //

        *TargetCount = 0;
        return STATUS_TRANSLATION_COMPLETE;
    }
#endif

    //
    // The interrupt requirements were obtained by calling HalAdjustResourceList
    // so we don't need to call it again.
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *TargetCount = 1;

    //
    // Copy the requirement unchanged
    //

    **Target = *Source;

    //
    // Perform the translation of the minimum & maximum
    //

    vector = HalpGetEisaInterruptVector(bus,
                                        bus,
                                        Source->u.Interrupt.MinimumVector,
                                        Source->u.Interrupt.MinimumVector,
                                        &irql,
                                        &affinity);

    if (!vector) {
        success = FALSE;
    }

    (*Target)->u.Interrupt.MinimumVector = vector;

    vector = HalpGetEisaInterruptVector(bus,
                                        bus,
                                        Source->u.Interrupt.MaximumVector,
                                        Source->u.Interrupt.MaximumVector,
                                        &irql,
                                        &affinity);

    if (!vector) {
        success = FALSE;
    }

    (*Target)->u.Interrupt.MaximumVector = vector;

    if (!success) {

        ExFreePool(*Target);
        *TargetCount = 0;
    }

    return STATUS_TRANSLATION_COMPLETE;
}

#if 0

// HALMPS doesn't provide this function.   It is left here as documentation
// for HALs which must provide translation.

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )

/*++

Routine Description:

    This routine translates memory and IO resource requirements.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt requirement to translate

    PhysicalDeviceObject - The device requesting the resource

    TargetCount - Pointer to where to return the number of descriptors this
        requirement translates into

    Target - Pointer to where a pointer to a callee allocated buffer containing
        the translated descriptors should be placed.

Return Value:

    STATUS_SUCCESS or an error status

Note:

    We do not perform any translation.

--*/

{
    ASSERT(Source);
    ASSERT(Target);
    ASSERT(TargetCount);
    ASSERT(Source->Type == CmResourceTypeMemory ||
           Source->Type == CmResourceTypePort);


    //
    // Allocate space for the target
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to target and update the fields that have changed
    //

    **Target = *Source;
    *TargetCount = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )

/*++

Routine Description:

    This routine translates memory and IO resources.   On generic x86
    machines, such as those that use this HAL, there isn't actually
    any translation.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt resource to translate

    Direction - The direction in relation to the Pnp device tree translation
        should occur in.

    AlternativesCount - The number of alternatives this resource was selected
        from.

    Alternatives - Array of alternatives this resource was selected from.

    PhysicalDeviceObject - The device requesting the resource

    Target - Pointer to a caller allocated buffer to hold the translted resource
        descriptor.

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    NTSTATUS status;

    //
    // Copy the target to the source
    //

    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Make sure PnP knows it doesn't have to walk up the tree
        // translating at each point.
        //

        status = STATUS_TRANSLATION_COMPLETE;
        break;

    case TranslateParentToChild:

        //
        // We do not translate requirements so do nothing...
        //

        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }
    return status;
}
#endif

NTSTATUS
HaliGetInterruptTranslator(
	IN INTERFACE_TYPE ParentInterfaceType,
	IN ULONG ParentBusNumber,
	IN INTERFACE_TYPE BridgeInterfaceType,
	IN USHORT Size,
	IN USHORT Version,
	OUT PTRANSLATOR_INTERFACE Translator,
	IN OUT PULONG BridgeBusNumber
	)
/*++

Routine Description:


Arguments:

	ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

	ParentBusNumber - The number of the bus the bridge lives on.

	BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

	ResourceType - The resource type we want to translate.

	Size - The size of the translator buffer.

	Version - The version of the translator interface requested.

	Translator - Pointer to the buffer where the translator should be returned

	BridgeBusNumber - Pointer the bus number of the bus that the bridge represents

Return Value:

    Returns the status of this operation.

--*/
#define BRIDGE_HEADER_BUFFER_SIZE (FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.SubordinateBus) + 1)
#define USE_INT_LINE_REGISTER_TOKEN  0xffffffff
#define DEFAULT_BRIDGE_TRANSLATOR 0x80000000
{
    PAGED_CODE();

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof(TRANSLATOR_INTERFACE));

    //
    // Fill in the common bits.
    //

    RtlZeroMemory(Translator, sizeof(TRANSLATOR_INTERFACE));

    Translator->Size = sizeof(TRANSLATOR_INTERFACE);
    Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
    Translator->Context = (PVOID)BridgeInterfaceType;
    Translator->InterfaceReference = HalTranslatorReference;
    Translator->InterfaceDereference = HalTranslatorDereference;

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
    case InterfaceTypeUndefined:  // special "IDE" cookie

        //
        // Set IRQ translator for (E)ISA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    case MicroChannel:

        //
        // Set IRQ translator for MCA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesRoot;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsRoot;

        return STATUS_SUCCESS;

    case PCIBus:

#ifndef ACPI_HAL
        //
        // Set of of two IRQ translators for PCI busses.
        //

        {
            UCHAR mpsBusNumber = 0;
            UCHAR pciBusNumber, parentPci, childPci;
            PCI_SLOT_NUMBER bridgeSlot;
            PCI_COMMON_CONFIG pciData;
            ULONG bytesRead, d, f, possibleContext;
            BOOLEAN describedByMps;
            NTSTATUS status;

            Translator->TranslateResources = HalpIrqTranslateResourcesPci;
            Translator->TranslateResourceRequirements =
                HalpIrqTranslateRequirementsPci;
        
            //
            // Look for this bus in the MPS tables.
            //

            status = HalpPci2MpsBusNumber((UCHAR)*BridgeBusNumber,
                                          &mpsBusNumber);

            if (NT_SUCCESS(status)) {

                //
                // This bus has corresponding entries for its PCI
                // devices in the MPS tables.  So eject the translator
                // that understands them.
                //

                if (HalpInterruptsDescribedByMpsTable(mpsBusNumber)) {

                    Translator->Context = (PVOID)mpsBusNumber;
                    return STATUS_SUCCESS;
                }
            }

            //
            // Do a quick check to see if we can avoid searching PCI
            // configuration space for a bridge.  This code is really
            // redundant, but it's worth trying to avoid touching
            // PCI space.
            //

            if (ParentInterfaceType != PCIBus) {

                //
                // This was a PCI bus that doesn't contain
                // mappings for PCI devices.
                //

                Translator->TranslateResources = 
                    HalpIrqTranslateResourcesPci;
                Translator->TranslateResourceRequirements =
                    HalpIrqTranslateRequirementsPci;
        
                Translator->Context = (PVOID)USE_INT_LINE_REGISTER_TOKEN;

                return STATUS_SUCCESS;

            }
            
            //
            // We didn't find this PCI bus in the MPS tables.  So there
            // are two cases.
            //
            // 1) This matters, because the parent bus is fully described
            //    in the MPS tables and we need to do translations on
            //    the vector as it passes through the bridges.
            //
            // 2) This doesn't matter, because the parent busses, while
            //    they may be in the MPS tables, they don't have any
            //    of their interrupts described.  So we just use the
            //    interrupt line register anyhow.
            //
            // At this point we need to find the PCI bridge that
            // generates this bus, either because we will eventually
            // need to know the slot number to fill in the context, or
            // because we will need to know the primary bus number to
            // look up the tree.
            //
            
            parentPci = (UCHAR)ParentBusNumber;
            childPci = (UCHAR)(*BridgeBusNumber);

            while (TRUE) {
                
                //
                // Find the bridge.
                //
    
                bridgeSlot.u.AsULONG = 0;
    
                for (d = 0; d < PCI_MAX_DEVICES; d++) {
                    for (f = 0; f < PCI_MAX_FUNCTION; f++) {
    
                        bridgeSlot.u.bits.DeviceNumber = d;
                        bridgeSlot.u.bits.FunctionNumber = f;
    
                        bytesRead = HalGetBusDataByOffset(PCIConfiguration,
                                                          parentPci,
                                                          bridgeSlot.u.AsULONG,
                                                          &pciData,
                                                          0,
                                                          BRIDGE_HEADER_BUFFER_SIZE);

                        if (bytesRead == (ULONG)BRIDGE_HEADER_BUFFER_SIZE) {
    
                            if ((pciData.VendorID != PCI_INVALID_VENDORID) &&
                                (PCI_CONFIGURATION_TYPE((&pciData)) != PCI_DEVICE_TYPE)) {
    
                                //
                                // This is a bridge of some sort.
                                //
    
                                if (pciData.u.type1.SecondaryBus == childPci) {
    
                                    //
                                    // And it is the bridge we are looking for.
                                    // Store information about
                                    //
    
                                    if (childPci == *BridgeBusNumber) {
                                    
                                        //
                                        // It is also the bridge that creates the 
                                        // PCI bus that the translator is describing.
                                        // 
                                        // N.B.  This should only happen the first time
                                        // we search through a bus.  (i.e. the first
                                        // trip through the outer while loop)
                                        //

                                        possibleContext = ((bridgeSlot.u.AsULONG & 0xffff) |
                                                           (ParentBusNumber << 16));
                                    
                                    }

                                    goto HGITFoundBridge1;
                                }
                            }
                        }
                    }
                }
                
                //
                // No bridge found.
                //

                if (parentPci == 0) {
                    return STATUS_NOT_FOUND;
                }

                parentPci--;
                continue;
                
HGITFoundBridge1:
                
                status = HalpPci2MpsBusNumber(parentPci, &mpsBusNumber);

                if (NT_SUCCESS(status)) {
    
                    if (HalpInterruptsDescribedByMpsTable(mpsBusNumber)) {
    
                        //
                        // Case 1 above.
                        //
    
                        Translator->TranslateResources = HalIrqTranslateResourcesPciBridge;
                        Translator->TranslateResourceRequirements =
                            HalIrqTranslateRequirementsPciBridge;

                        Translator->Context = (PVOID)possibleContext;
            
                        return STATUS_SUCCESS;
                    }

                    if (HalpMpsBusIsRootBus(mpsBusNumber)) {
                        
                        Translator->TranslateResources = 
                            HalpIrqTranslateResourcesPci;
                        Translator->TranslateResourceRequirements =
                            HalpIrqTranslateRequirementsPci;
                
                        Translator->Context = (PVOID)USE_INT_LINE_REGISTER_TOKEN;
        
                        return STATUS_SUCCESS;
                    }
                }

                //
                // Try again one bus higher.
                //

                childPci = parentPci;
                parentPci--;
            }
        }
#endif
        break;
    }


    //
    // If we got here, we don't have an interface.
    //

    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpswint.asm ===
title   "Software Interrupts"
;++
;
; Copyright (c) 1992  Microsoft Corporation
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
; Module Name:
;
;    mpswint.asm
;
; Abstract:
;
;    This module implements the software interrupt handlers for
;    APIC-based PC+MP multiprocessor systems.
;
; Author:
;
;    John Vert (jvert) 2-Jan-1992
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Ron Mosgrove (Intel) - Modified for PC+MP systems
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include apic.inc
include ntapic.inc
include i386\kimacro.inc
        .list

        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _KiDeliverApc,3,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT

        extrn  _HalpIRQLtoTPR:byte

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Request Software Interrupt"
;++
;
; VOID
; FASTCALL
; HalRequestSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to request a software interrupt of
;   the system.
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

; equates for accessing arguments
;

cPublicFastCall HalRequestSoftwareInterrupt ,1
cPublicFpo 0,0

        cmp     cl, PCR[PcHal.ShortDpc]
        je      short rsi10

        xor     eax, eax
        mov     al, cl                      ; get irql

;
; In an APIC based system the TPR is the IDTEntry
;

        xor     ecx, ecx
        mov     cl, _HalpIRQLtoTPR[eax]     ; get IDTEntry for IRQL

;
; Build the ICR Command - Fixed Delivery to Self, IDTEntry == al
;

        or      ecx, (DELIVER_FIXED OR ICR_SELF)

;
; Make sure the ICR is available
;

        pushfd                             ; save interrupt mode
        cli                                ; disable interrupt
        STALL_WHILE_APIC_BUSY

;
; Now write the command to the Memory Mapped Register
;

        mov     dword ptr APIC[LU_INT_CMD_LOW], ecx

;
;   We have to wait for the request to be delivered.
;   If we don't wait here, then we will return to the caller
;   before the request has been issued.
;
        STALL_WHILE_APIC_BUSY

        popfd                   ; restore original interrupt mode
        fstRET  HalRequestSoftwareInterrupt

;
; Requesting a DPC interrupt when ShortDpc is set.  Just set the
; DpcPending flag - whomever set ShortDpc will check the flag
; at the proper time
;

rsi10:  mov     PCR[PcHal.DpcPending], 1
        fstRET  HalRequestSoftwareInterrupt

fstENDP HalRequestSoftwareInterrupt

        page ,132
        subttl  "Clear Software Interrupt"

;++
;
; VOID
; HalClearSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to clear a possible pending software interrupt.
;   Support for this function is optional, and allows the kernel to
;   reduce the number of spurious software interrupts it receives/
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalClearSoftwareInterrupt ,1
        fstRET  HalClearSoftwareInterrupt
fstENDP HalClearSoftwareInterrupt


        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; VOID
; HalpDispatchInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is the interrupt handler for a software interrupt generated
;    at DISPATCH_LEVEL.  Its function is to save the machine state, raise
;    Irql to DISPATCH_LEVEL, dismiss the interrupt, and call the DPC
;    delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--


        ENTER_DR_ASSIST hdpi_a, hdpi_t

cPublicProc  _HalpDispatchInterrupt ,0

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT hdpi_a, hdpi_t

        mov     eax, DPC_VECTOR

        mov     esi, dword ptr APIC[LU_TPR]     ; get the old TPR
        mov     dword ptr APIC[LU_TPR], eax     ; set the TPR

        sti                                     ; and allow interrupts

        APICFIX edx

        mov     dword ptr APIC[LU_EOI], 0       ; send EOI to APIC local unit
        APICFIX edx

        ;
        ; Go do Dispatch Interrupt processing
        ;

di10:   stdCall _KiDispatchInterrupt

        cli
        mov     dword ptr APIC[LU_TPR], esi     ; reset the TPR

;
; We have to ensure that the requested priority is set before
; we return.  The caller is counting on it.
;
        mov     ecx, dword ptr APIC[LU_TPR]
        CHECKTPR    ecx, esi

        ;
        ; Do interrupt exit processing without EOI
        ;

        SPURIOUS_INTERRUPT_EXIT
stdENDP _HalpDispatchInterrupt

        page ,132
        subttl  "APC Interrupt"
;++
;
; HalpApcInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at APC_LEVEL. Its function is to save the machine state, raise Irql to
;    APC_LEVEL, dismiss the interrupt, and call the APC delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is Disabled
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST hapc_a, hapc_t

;
; Save machine state in trap frame
;

cPublicProc  _HalpApcInterrupt ,0

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT hapc_a, hapc_t


        mov     eax, APC_VECTOR

        mov     ecx, dword ptr APIC[LU_TPR]     ; get the old TPR
        push    ecx                             ; save it
        mov     dword ptr APIC[LU_TPR], eax     ; set the TPR

        APICFIX edx
        mov     dword ptr APIC[LU_EOI], 0       ; send EOI to APIC local unit
        APICFIX edx

        sti                                     ; and allow interrupts

        mov     eax, [ebp]+TsSegCs              ; get interrupted code's CS
        and     eax, MODE_MASK                  ; extract the mode

        ; call APC deliver routine
        ;       Previous mode
        ;       Null exception frame
        ;       Trap frame

        stdCall   _KiDeliverApc, <eax, 0,ebp>

        pop     eax

        cli
        mov     dword ptr APIC[LU_TPR], eax     ; reset the TPR

;
; We have to ensure that the requested priority is set before
; we return.  The caller is counting on it.
;
        mov     ecx, dword ptr APIC[LU_TPR]
        CHECKTPR    ecx, eax

        ;
        ; Do interrupt exit processing without EOI
        ;

        SPURIOUS_INTERRUPT_EXIT

stdENDP _HalpApcInterrupt


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpsproc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpsproc.c

Abstract:

    PC+MP Start Next Processor c code.

    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for a
    PC+MP System

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

    Ron Mosgrove (Intel) - Modified to support the PC+MP
    Jake Oshins (jakeo) - Modified for ACPI MP machines 22-Dec-1997

--*/

#if !defined(_HALPAE_)
#define _HALPAE_
#endif

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"
#include "stdio.h"
#ifdef ACPI_HAL
#include "acpitabl.h"
#endif

#ifdef DEBUGGING

void
HalpDisplayString(
    IN PVOID String
    );

#endif  // DEBUGGING

#if defined(ACPI_HAL)
#if !defined(NT_UP)
        const UCHAR HalName[] = "ACPI 1.0 - APIC platform MP";
        #define HalName        L"ACPI 1.0 - APIC platform MP"
        WCHAR HalHardwareIdString[] = L"acpiapic_mp\0";
#else
        const UCHAR HalName[] = "ACPI 1.0 - APIC platform UP";
        #define HalName        L"ACPI 1.0 - APIC platform UP"
        WCHAR MpHalHardwareIdString[] = L"acpiapic_mp\0";
        WCHAR HalHardwareIdString[] = L"acpiapic_up\0";
#endif
#else
#if !defined(NT_UP)
        const UCHAR HalName[] = "MPS 1.4 - APIC platform";
        #define HalName        L"MPS 1.4 - APIC platform"
        WCHAR HalHardwareIdString[] = L"mps_mp\0";
#else
        const UCHAR HalName[] = "UP MPS 1.4 - APIC platform";
        #define HalName        L"UP MPS 1.4 - APIC platform"
        WCHAR MpHalHardwareIdString[] = L"mps_mp\0";
        WCHAR HalHardwareIdString[] = L"mps_up\0";
#endif
#endif

#if !defined(NT_UP)
ULONG
HalpStartProcessor (
    IN PVOID InitCodePhysAddr,
    IN ULONG ProcessorNumber
    );
#endif

VOID
HalpBiosDisplayReset (
    VOID
    );

VOID
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitOtherBuses (
    VOID
    );

VOID
HalpInitializePciBus (
    VOID
    );

VOID
HalpInitializePciStubs (
    VOID
    );

VOID
HalpInheritBusAddressMapInfo (
    VOID
    );

VOID
HalpInitBusAddressMapInfo (
    VOID
    );

VOID
HalpResetThisProcessor (
    VOID
    );

VOID
HalpApicRebootService(
    VOID
    );

#ifdef ACPI_HAL
VOID
HalpInitMpInfo (
    IN PMAPIC ApicTable,
    IN ULONG  Phase
    );
extern PMAPIC  HalpApicTable;
#endif

extern VOID (*HalpRebootNow)(VOID);


volatile ULONG HalpProcessorsNotHalted = 0;

#define LOW_MEMORY          0x000100000

//
// From hal386.inc
//

#define IDT_NMI_VECTOR      2
#define D_INT032            0x8E00
#define KGDT_R0_CODE        0x8

//
// Defines to let us diddle the CMOS clock and the keyboard
//

#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71


#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64

extern USHORT HalpGlobal8259Mask;
extern PKPCR  HalpProcessorPCR[];
extern struct HalpMpInfo HalpMpInfoTable;

extern ULONG HalpIpiClock;
extern PVOID   HalpLowStubPhysicalAddress;   // pointer to low memory bootup stub
extern PUCHAR  HalpLowStub;                  // pointer to low memory bootup stub

PUCHAR  Halp1stPhysicalPageVaddr;   // pointer to physical memory 0:0
PUSHORT MppProcessorAvail;          // pointer to processavail flag
ULONG   HalpDontStartProcessors = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitMP)
#pragma alloc_text(INIT,HalAllProcessorsStarted)
#pragma alloc_text(INIT,HalReportResourceUsage)
#pragma alloc_text(INIT,HalpInitOtherBuses)
#if !defined(NT_UP)
#pragma alloc_text(PAGELK,HalpStartProcessor)
#endif
#endif



VOID
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:
    Allows MP initialization from HalInitSystem.

Arguments:
    Same as HalInitSystem

Return Value:
    None.

--*/
{
    PKPCR   pPCR;
    PHYSICAL_ADDRESS physicalAddress;


    pPCR = KeGetPcr();

    //
    //  Increment a count of the number of processors
    //  running NT, This could be different from the
    //  number of enabled processors, if one or more
    //  of the processor failed to start.
    //
    if (Phase == 1)
        HalpMpInfoTable.NtProcessors++;
#ifdef DEBUGGING
    sprintf(Cbuf, "HalpInitMP: Number of Processors = 0x%x\n",
        HalpMpInfoTable.NtProcessors);

    HalpDisplayString(Cbuf);
#endif

    if (Phase == 0) {

#if defined(NT_UP)

        //
        // On UP build - done
        //

        return ;
#endif

        //
        // Map the 1st Physical page of memory
        //
        physicalAddress.QuadPart = 0;
        Halp1stPhysicalPageVaddr = HalpMapPhysicalMemory (physicalAddress, 1);

        //
        //  Allocate some low memory for processor bootup stub
        //

        HalpLowStubPhysicalAddress = (PVOID)HalpAllocPhysicalMemory (LoaderBlock,
                                            LOW_MEMORY, 1, FALSE);

        if (!HalpLowStubPhysicalAddress) {
            //
            //  Can't get memory
            //

#if DBG
            DbgPrint("HAL: can't allocate memory to start processors\n");
#endif
            return;
        }

        physicalAddress.QuadPart = (ULONGLONG)HalpLowStubPhysicalAddress;
        HalpLowStub = (PCHAR) HalpMapPhysicalMemory (physicalAddress, 1);

    } else {

        //
        //  Phase 1 for another processor
        //
        if (pPCR->Prcb->Number != 0) {
            HalpIpiClock = 0xff;
        }

#ifdef ACPI_HAL
        HalpInitMpInfo(HalpApicTable, Phase);
#endif
    }
}



BOOLEAN
HalAllProcessorsStarted (
    VOID
    )
{
    if (KeGetPcr()->Number == 0) {

        if (HalpFeatureBits & HAL_PERF_EVENTS) {

            //
            // Enable local perf events on each processor
            //

            HalpGenericCall (
                HalpEnablePerfInterupt,
                (ULONG) NULL,
                HalpActiveProcessors
                );

        }

        if (HalpFeatureBits & HAL_NO_SPECULATION) {

            //
            // Processor doesn't perform speculative execeution,
            // remove fences in critical code paths
            //

            HalpRemoveFences ();
        }
    }

    return TRUE;
}

VOID
HalpInitOtherBuses (
    VOID
    )
{

    //
    // Registry is now intialized, see if there are any PCI buses
    //
}

VOID
HalReportResourceUsage (
    VOID
    )
/*++

Routine Description:
    The registery is now enabled - time to report resources which are
    used by the HAL.

Arguments:

Return Value:

--*/
{
    UNICODE_STRING  UHalName;
    INTERFACE_TYPE  interfacetype;

    //
    // Initialize phase 2
    //

    HalInitSystemPhase2 ();

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();
    HalpInitializePciStubs ();

#ifndef ACPI_HAL  // ACPI HALs don't deal with address maps
    //
    // Update supported address info with MPS bus address map
    //

    HalpInitBusAddressMapInfo ();

    //
    // Inherit any bus address mappings from MPS hierarchy descriptors
    //

    HalpInheritBusAddressMapInfo ();

#endif
    //
    // Set type
    //

    switch (HalpBusType) {
        case MACHINE_TYPE_ISA:  interfacetype = Isa;            break;
        case MACHINE_TYPE_EISA: interfacetype = Eisa;           break;
        case MACHINE_TYPE_MCA:  interfacetype = MicroChannel;   break;
        default:                interfacetype = PCIBus;         break;
    }

    //
    // Report HALs resource usage
    //

    RtlInitUnicodeString (&UHalName, HalName);

    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        interfacetype
    );

#ifndef ACPI_HAL  // ACPI HALs don't deal with address maps
    //
    // Register hibernate support
    //
    HalpRegisterHibernate();
#endif

    HalpRegisterPciDebuggingDeviceInfo();
}


VOID
HalpResetAllProcessors (
    VOID
    )
/*++

Routine Description:

    This procedure is called by the HalpReboot routine.  It is called in
    response to a system reset request.

    This routine generates a reboot request via the APIC's ICR.

    This routine will NOT return.

--*/
{
    ULONG j;
    PKGDTENTRY GdtPtr;
    ULONG TssAddr;
    PKPRCB  Prcb;

#ifndef NT_UP
    HalpProcessorsNotHalted = HalpMpInfoTable.NtProcessors;
#else
    //
    //  Only this processor needs to be halted
    //
    HalpProcessorsNotHalted = 1;
#endif

    //
    // Set all processors NMI handlers
    //

    for (j = 0; j < HalpMpInfoTable.NtProcessors; ++j)  {
        GdtPtr = &HalpProcessorPCR[j]->
                   GDT[HalpProcessorPCR[j]->IDT[IDT_NMI_VECTOR].Selector >> 3];
        TssAddr = (((GdtPtr->HighWord.Bits.BaseHi << 8) +
                   GdtPtr->HighWord.Bits.BaseMid) << 16) + GdtPtr->BaseLow;
        ((PKTSS)TssAddr)->Eip = (ULONG)HalpApicRebootService;
    }

    if (HalpProcessorsNotHalted > 1) {

        //
        //  Wait for the ICR to become free
        //

        if (HalpWaitForPending (0xFFFF, pLocalApic + LU_INT_CMD_LOW/4)) {

            //
            // For P54c or better processors, reboot by sending all processors
            // NMIs.  For pentiums we send interrupts, since there are some
            // pentium MP machines where the NMIs method does not work.
            //
            // The NMI method is better.
            //

            Prcb = KeGetCurrentPrcb();
            j = Prcb->CpuType << 16 | (Prcb->CpuStep & 0xff00);
            if (j > 0x50100) {

                //
                // Get other processors attention with an NMI
                //

                j = HalpActiveProcessors & ~Prcb->SetMember;
                j = j << DESTINATION_SHIFT;
                pLocalApic[LU_INT_CMD_HIGH/4] = j;
                pLocalApic[LU_INT_CMD_LOW/4] = (ICR_USE_DEST_FIELD | LOGICAL_DESTINATION | DELIVER_NMI);

                //
                // Wait 5ms and see if any processors took the NMI.  If not,
                // go do it the old way.
                //

                KeStallExecutionProcessor(5000);
                if (HalpProcessorsNotHalted != HalpMpInfoTable.NtProcessors) {

                    //
                    // Reboot local
                    //

                    HalpApicRebootService();
                }
            }

            //
            // Signal other processors which also may be waiting to
            // reboot the machine, that it's time to go
            //

            HalpRebootNow = HalpResetThisProcessor;

            //
            // Send a reboot interrupt
            //

            pLocalApic[LU_INT_CMD_LOW/4] = (ICR_ALL_INCL_SELF | APIC_REBOOT_VECTOR);

            //
            //  we're done - set TPR to zero so the reboot interrupt will happen
            //

            pLocalApic[LU_TPR/4] = 0;
            _asm sti ;
            for (; ;) ;
        }
    }


    //
    //  Reset the old fashion way
    //

    WRITE_PORT_UCHAR(KEYBPORT, RESET);
}

VOID
HalpResetThisProcessor (
    VOID
    )
/*++

Routine Description:

    This procedure is called by the HalpReboot routine.
    It is called in response to a system reset request.

    This routine is called by the reboot ISR (linked to
    APIC_REBOOT_VECTOR).  The HalpResetAllProcessors
    generates the reboot request via the APIC's ICR.

    The function of this routine is to perform any processor
    specific shutdown code needed and then reset the system
    (on the BSP==P0 only).

    This routine will NOT return.

--*/
{
    PUSHORT   Magic;
    ULONG ThisProcessor = 0;
    ULONG i, j, max, RedirEntry;
    ULONG AllProcessorsHalted;
    struct ApicIoUnit *IoUnitPtr;
    PHYSICAL_ADDRESS physicalAddress;

    ThisProcessor = KeGetPcr()->Prcb->Number;

    //
    //  Do whatever is needed to this processor to restore
    //  system to a bootable state
    //

    pLocalApic[LU_TPR/4] = 0xff;
    pLocalApic[LU_TIMER_VECTOR/4] =
        (APIC_SPURIOUS_VECTOR |PERIODIC_TIMER | INTERRUPT_MASKED);
    pLocalApic[LU_INT_VECTOR_0/4] =
        (APIC_SPURIOUS_VECTOR | INTERRUPT_MASKED);
    pLocalApic[LU_INT_VECTOR_1/4] =
        ( LEVEL_TRIGGERED | ACTIVE_HIGH | DELIVER_NMI |
                 INTERRUPT_MASKED | NMI_VECTOR);
    if (HalpMpInfoTable.ApicVersion != APIC_82489DX) {
        pLocalApic[LU_FAULT_VECTOR/4] =
            APIC_FAULT_VECTOR | INTERRUPT_MASKED;
    }

    if (ThisProcessor == 0) {
        _asm {
            lock dec HalpProcessorsNotHalted
        }
        //
        //  we are running on the BSP, wait for everyone to
        //  complete the re-initialization code above
        //
        AllProcessorsHalted = 0;
        while(!AllProcessorsHalted) {
            _asm {
                lock    and HalpProcessorsNotHalted,0xffffffff
                jnz     EveryOneNotDone
                inc     AllProcessorsHalted
EveryOneNotDone:
            }  // asm block
        }  // NOT AllProcessorsHalted

        KeStallExecutionProcessor(100);
        
        //
        //  Write the Shutdown reason code, so the BIOS knows
        //  this is a reboot
        //

        WRITE_PORT_UCHAR(CMOS_CTRL, 0x0f);  // CMOS Addr 0f

        WRITE_PORT_UCHAR(CMOS_DATA, 0x00);  // Reason Code Reset

        physicalAddress.QuadPart = 0;
        Magic = HalpMapPhysicalMemory(physicalAddress, 1);
        Magic[0x472 / sizeof(USHORT)] = 0x1234;     // warm boot

        //
        // If required, disable APIC mode
        //

        if (HalpMpInfoTable.IMCRPresent)
        {
            _asm {
                mov al, ImcrPort
                out ImcrRegPortAddr, al
            }

            KeStallExecutionProcessor(100);
            _asm {
                mov al, ImcrDisableApic
                out ImcrDataPortAddr, al
            }
        }

        KeStallExecutionProcessor(100);

        for (j=0; j<HalpMpInfoTable.IOApicCount; j++) {
            IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoTable.IoApicBase[j];

            //
            //  Disable all interrupts on IO Unit
            //

            IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
            max = ((IoUnitPtr->RegisterWindow >> 16) & 0xff) * 2;
            for (i=0; i <= max; i += 2) {
                IoUnitPtr->RegisterSelect  = IO_REDIR_00_LOW + i;
                IoUnitPtr->RegisterWindow |= INT_VECTOR_MASK | INTERRUPT_MASKED;

                //
                // Clear any set Remote IRR bits by programming the entry to
                // edge and then back to level. Otherwise there will be
                // no further interrupts from this source.
                //

                IoUnitPtr->RegisterSelect  = IO_REDIR_00_LOW + i;
                RedirEntry = IoUnitPtr->RegisterWindow;
                if ( (RedirEntry & LEVEL_TRIGGERED)  &&  (RedirEntry & REMOTE_IRR))  {
                    RedirEntry &= ~LEVEL_TRIGGERED;
                    IoUnitPtr->RegisterWindow = RedirEntry;
                    RedirEntry = IoUnitPtr->RegisterWindow;
                    RedirEntry |= LEVEL_TRIGGERED;
                    IoUnitPtr->RegisterWindow = RedirEntry;
                }
            }
        } // for all Io Apics

        //
        //  Disable the Local Apic
        //
        pLocalApic[LU_SPURIOUS_VECTOR/4] =
            (APIC_SPURIOUS_VECTOR | LU_UNIT_DISABLED);


        KeStallExecutionProcessor(100);

        _asm {
            cli
        };

        //
        //  Enable Pic interrupts
        //
        HalpGlobal8259Mask = 0;
        HalpSet8259Mask ((USHORT) HalpGlobal8259Mask);

        KeStallExecutionProcessor(1000);

        //
        //  Finally, reset the system through
        //  the keyboard controller
        //
        WRITE_PORT_UCHAR(KEYBPORT, RESET);

    } else {
        //
        // We're running on a processor other than the BSP
        //

        //
        //  Disable the Local Apic
        //

        pLocalApic[LU_SPURIOUS_VECTOR/4] =
            (APIC_SPURIOUS_VECTOR | LU_UNIT_DISABLED);

        KeStallExecutionProcessor(100);

        //
        //  Now we are done, tell the BSP
        //

        _asm {
            lock dec HalpProcessorsNotHalted
        }
    }   // Not BSP


    //
    //  Everyone stops here until reset
    //
    _asm {
        cli
StayHalted:
        hlt
        jmp StayHalted
    }
}

#if !defined(NT_UP)
ULONG
HalpStartProcessor (
    IN PVOID InitCodePhysAddr,
    IN ULONG ProcessorNumber
    )
/*++

Routine Description:

    Actually Start the Processor in question.  This routine
    assumes the init code is setup and ready to run.  The real
    mode init code must begin on a page boundry.

    NOTE: This assumes the BSP is entry 0 in the MP table.

    This routine cannot fail.

Arguments:
    InitCodePhysAddr - execution address of init code

Return Value:
    0    - Something prevented us from issuing the reset.

    n    - Processor's PCMP Local APICID + 1
--*/
{
    NTSTATUS status;
    UCHAR ApicID;
    PVULONG LuDestAddress = (PVULONG) (LOCALAPIC + LU_INT_CMD_HIGH);
    PVULONG LuICR = (PVULONG) (LOCALAPIC + LU_INT_CMD_LOW);
#define DEFAULT_DELAY   100
    ULONG DelayCount = DEFAULT_DELAY;
    ULONG ICRCommand,i;

    ASSERT((((ULONG) InitCodePhysAddr) & 0xfff00fff) == 0);

    if (ProcessorNumber >= HalpMpInfoTable.ProcessorCount)  {
        return(0);
    }

    //
    //  Get the APIC ID of the processor to start.
    //

    status = HalpGetNextProcessorApicId(ProcessorNumber,
                                        &ApicID);

    if (!NT_SUCCESS(status)) {
#ifdef DEBUGGING
        HalpDisplayString("HAL: HalpStartProcessor: No Processor Available\n");
#endif
        return(0);
    }

    if (HalpDontStartProcessors)
        return ApicID+1;

    //
    //  Make sure we can get to the Apic Bus
    //

    KeStallExecutionProcessor(200);
    if (HalpWaitForPending (DEFAULT_DELAY, LuICR) == 0) {
        //
        //  We couldn't find a processor to start
        //
#ifdef DEBUGGING
        HalpDisplayString("HAL: HalpStartProcessor: can't access APIC Bus\n");
#endif
        return 0;
    }

    // For a P54 C/CM system, it is possible that the BSP is the P54CM and the
    // P54C is the Application processor. The P54C needs an INIT (reset)
    // to restart,  so we issue a reset regardless of whether we a 82489DX
    // or an integrated APIC.

    //
    //  This system is based on the original 82489DX's.
    //  These devices do not support the Startup IPI's.
    //  The mechanism used is the ASSERT/DEASSERT INIT
    //  feature of the local APIC.  This resets the
    //  processor.
    //

#ifdef DEBUGGING
    sprintf(Cbuf, "HAL: HalpStartProcessor: Reset IPI to ApicId %d (0x%x)\n",
                ApicID,((ULONG) ApicID) << DESTINATION_SHIFT );
    HalpDisplayString(Cbuf);
#endif

    //
    //  We use a Physical Destination
    //

    *LuDestAddress = ((ULONG) ApicID) << DESTINATION_SHIFT;

    //
    //  Now Assert reset and drop it
    //

    *LuICR = LU_RESET_ASSERT;
    KeStallExecutionProcessor(10);
    *LuICR = LU_RESET_DEASSERT;
    KeStallExecutionProcessor(200);

    if (HalpMpInfoTable.ApicVersion == APIC_82489DX) {
        return ApicID+1;
    }

    //
    //  Set the Startup Address as a vector and combine with the
    //  ICR bits
    //
    ICRCommand = (((ULONG) InitCodePhysAddr & 0x000ff000) >> 12)
                | LU_STARTUP_IPI;

#ifdef DEBUGGING
    sprintf(Cbuf, "HAL: HalpStartProcessor: Startup IPI (0x%x) to ApicId %d (0x%x)\n",
                    ICRCommand, ApicID, ((ULONG) ApicID) << DESTINATION_SHIFT );
    HalpDisplayString(Cbuf);
#endif

    //
    //  Set the Address of the APIC again, this may not be needed
    //  but it can't hurt.
    //
    *LuDestAddress = (ApicID << DESTINATION_SHIFT);
    //
    //  Issue the request
    //
    *LuICR = ICRCommand;
    KeStallExecutionProcessor(200);

    //
    //  Repeat the Startup IPI.  This is because the second processor may
    //  have been issued an INIT request.  This is generated by some BIOSs.
    //
    //  On older processors (286) BIOS's use a mechanism called triple
    //  fault reset to transition from protected mode to real mode.
    //  This mechanism causes the processor to generate a shutdown cycle.
    //  The shutdown is typically issued by the BIOS building an invalid
    //  IDT and then generating an interrupt.  Newer processors have an
    //  INIT line that the chipset jerks when it sees a shutdown cycle
    //  issued by the processor.  The Phoenix BIOS, for example, has
    //  integrated support for triple fault reset as part of their POST
    //  (Power On Self Test) code.
    //
    //  When the P54CM powers on it is held in a tight microcode loop
    //  waiting for a Startup IPI to be issued and queuing other requests.
    //  When the POST code executes the triple fault reset test the INIT
    //  cycle is queued by the processor. Later, when a Startup IPI is
    //  issued to the CM, the CM starts and immediately gets a INIT cycle.
    //  The effect from a software standpoint is that the processor is
    //  never started.
    //
    //  The work around implemented here is to issue two Startup IPI's.
    //  The first allows the INIT to be processed and the second performs
    //  the actual startup.
    //

    //
    //  Make sure we can get to the Apic Bus
    //


    if (HalpWaitForPending (DEFAULT_DELAY, LuICR) == 0) {
        //
        //  We're toast, can't gain access to the APIC Bus
        //
#ifdef DEBUGGING
        HalpDisplayString("HAL: HalpStartProcessor: can't access APIC Bus\n");
#endif
        return 0;
    }

    //
    //  Allow Time for any Init request to be processed
    //
    KeStallExecutionProcessor(100);

    //
    //  Set the Address of the APIC again, this may not be needed
    //  but it can't hurt.
    //
    *LuDestAddress = (ApicID << DESTINATION_SHIFT);
    //
    //  Issue the request
    //
    *LuICR = ICRCommand;

    KeStallExecutionProcessor(200);
    return ApicID+1;
}
#endif  // !NT_UP


ULONG
FASTCALL
HalSystemVectorDispatchEntry (
    IN ULONG Vector,
    OUT PKINTERRUPT_ROUTINE **FlatDispatch,
    OUT PKINTERRUPT_ROUTINE *NoConnection
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\xxbiosa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\xxbiosa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\pmpcisup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\pmpcisup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpsys.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpsys.c

Abstract:


    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for a
    PC+MP system.

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode only.

Revision History:


*/

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"

#define STATIC  // functions used internal to this module

VOID
HalpApicSpuriousService(
    VOID
    );

VOID
HalpLocalApicErrorService(
    VOID
    );

VOID
HalpInitializeLocalUnit (
    VOID
    );

STATIC UCHAR
HalpPcMpIoApicById (
    IN UCHAR IoApicId
    );

UCHAR
HalpAddInterruptDest(
    IN UCHAR CurrentDest,
    IN UCHAR ThisCpu
    );

UCHAR
HalpRemoveInterruptDest(
    IN UCHAR CurrentDest,
    IN UCHAR ThisCpu
    );

UCHAR
HalpMapNtToHwProcessorId(
    IN UCHAR Number
    );

VOID
HalpRestoreIoApicRedirTable (
    VOID
    );

ULONG HalpNodeAffinity[MAX_NODES];
ULONG HalpMaxNode = 1;

//
//  Counters used to determine the number of interrupt enables that
//  require the Local APIC Lint0 Extint enabled
//

UCHAR Halp8259Counts[16]    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};

//
//  All possible I/O APIC Sources, arranged linearly from first I/O APIC to
//  last.  Divisions between I/O APICs are implied by HalpMaxApicInti[N]
//
INTI_INFO   HalpIntiInfo[MAX_INTI];

//
//  Number of sources in I/O APIC [n]
//
USHORT      HalpMaxApicInti[MAX_IOAPICS];


INTERRUPT_DEST HalpIntDestMap[MAX_PROCESSORS];

extern BOOLEAN HalpHiberInProgress;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpCheckELCR)
#pragma alloc_text(PAGELK, HalpInitializeIOUnits)
#pragma alloc_text(PAGELK, HalpInitializeLocalUnit)
#pragma alloc_text(PAGELK, HalpEnableNMI)
#pragma alloc_text(PAGELK, HalpEnablePerfInterupt)
#pragma alloc_text(PAGELK, HalpRestoreIoApicRedirTable)
#pragma alloc_text(PAGELK, HalpUnMapIOApics)
#pragma alloc_text(PAGELK, HalpPostSleepMP)
#endif

//
// BEWARE -- this has to match the structure ADDRESS_USAGE.
#pragma pack(push, 1)
struct {
    struct _HalAddressUsage *Next;
    CM_RESOURCE_TYPE        Type;
    UCHAR                   Flags;
    struct {
        ULONG   Start;
        ULONG   Length;
    }                       Element[MAX_IOAPICS+2];
} HalpApicUsage;
#pragma pack(pop)

VOID
HalpCheckELCR (
    VOID
    )
{
    USHORT      elcr;
    ULONG       IsaIrq;
    USHORT      Inti;

    if (HalpELCRChecked) {
        return ;
    }

    HalpELCRChecked = TRUE;


    //
    // It turns out interrupts which are fed through the ELCR before
    // going to the IOAPIC get inverted.  So...  here we *assume*
    // the polarity of any ELCR level inti not declared in the MPS linti
    // table as being active_high instead of what they should be (which
    // is active_low).  Any system which correctly delivers these intis
    // to an IOAPIC will need to declared the correct polarity in the
    // MPS table.
    //

    elcr = READ_PORT_UCHAR ((PUCHAR) 0x4d1) << 8 | READ_PORT_UCHAR((PUCHAR) 0x4d0);
    if (elcr == 0xffff) {
        return ;
    }

    for (IsaIrq = 0; elcr; IsaIrq++, elcr >>= 1) {
        if (!(elcr & 1)) {
            continue;
        }

        if (HalpGetApicInterruptDesc (Eisa, 0, IsaIrq, &Inti)) {

            //
            // If the MPS passed Polarity for this Inti
            // is "bus default" change it to be "active high".
            //

            if (HalpIntiInfo[Inti].Polarity == 0) {
                HalpIntiInfo[Inti].Polarity = 1;
            }
        }
    }
}


STATIC VOID
HalpSetRedirEntry (
    IN USHORT InterruptInput,
    IN ULONG  Entry,
    IN ULONG  Destination
    )
/*++

Routine Description:

    This procedure sets a IO Unit Redirection Table Entry

Arguments:

    IoUnit - The IO Unit to modify (zero Based)

    InterruptInput - The input line we're interested in

    Entry - the lower 32 bits of the redir table

    Destination - the upper 32 bits on the entry

Return Value:

    None.

--*/
{
    struct ApicIoUnit *IoUnitPtr;
    ULONG  RedirRegister;
    UCHAR  IoUnit;

    for (IoUnit=0; IoUnit < MAX_IOAPICS; IoUnit++) {
        if (InterruptInput+1 <= HalpMaxApicInti[IoUnit]) {
            break;
        }
        InterruptInput -= HalpMaxApicInti[IoUnit];
    }

    ASSERT (IoUnit < MAX_IOAPICS);

    IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoTable.IoApicBase[IoUnit];

    RedirRegister = InterruptInput*2 + IO_REDIR_00_LOW;

    IoUnitPtr->RegisterSelect = RedirRegister+1;
    IoUnitPtr->RegisterWindow = Destination;

    IoUnitPtr->RegisterSelect = RedirRegister;
    IoUnitPtr->RegisterWindow = Entry;

}

STATIC VOID
HalpGetRedirEntry (
    IN USHORT InterruptInput,
    IN PULONG Entry,
    IN PULONG Destination
    )
/*++

Routine Description:

    This procedure sets a IO Unit Redirection Table Entry

Arguments:

    IoUnit - The IO Unit to modify (zero Based)

    InterruptInput - The input line we're interested in

    Entry - the lower 32 bits of the redir table

    Destination - the upper 32 bits on the entry

Return Value:

    None.

--*/
{
    struct ApicIoUnit *IoUnitPtr;
    ULONG  RedirRegister;
    UCHAR  IoUnit;

    for (IoUnit=0; IoUnit < MAX_IOAPICS; IoUnit++) {
        if (InterruptInput+1 <= HalpMaxApicInti[IoUnit]) {
            break;
        }
        InterruptInput -= HalpMaxApicInti[IoUnit];
    }

    ASSERT (IoUnit < MAX_IOAPICS);

    IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoTable.IoApicBase[IoUnit];

    RedirRegister = InterruptInput*2 + IO_REDIR_00_LOW;

    IoUnitPtr->RegisterSelect = RedirRegister+1;
    *Destination = IoUnitPtr->RegisterWindow;

    IoUnitPtr->RegisterSelect = RedirRegister;
    *Entry = IoUnitPtr->RegisterWindow;

}


STATIC VOID
HalpEnableRedirEntry(
    IN USHORT InterruptInput,
    IN ULONG  Entry,
    IN UCHAR  Cpu
    )
/*++

Routine Description:

    This procedure enables an interrupt via IO Unit
    Redirection Table Entry

Arguments:

    InterruptInput - The input line we're interested in

    Entry - the lower 32 bits of the redir table

    Destination - the upper 32 bits of the entry

Return Value:

    None.

--*/
{
    ULONG Destination;

    //
    // bump Enable Count for this INTI
    //

    HalpIntiInfo[InterruptInput].Entry = (USHORT) Entry;
    HalpIntiInfo[InterruptInput].Destinations = (UCHAR)HalpAddInterruptDest(
        HalpIntiInfo[InterruptInput].Destinations, Cpu);
    Destination = HalpIntiInfo[InterruptInput].Destinations;
    Destination = (Destination << DESTINATION_SHIFT);

    HalpSetRedirEntry (
        InterruptInput,
        Entry,
        Destination
    );

}


VOID
HalpRestoreIoApicRedirTable (
    VOID
    )
/*++

Routine Description:

    This procedure resets any IoApic inti that is enabled for
    any processor.   This is used during the system wake procedure.


Arguments:

    None.

Return Value:

    None.

--*/
{
    USHORT       InterruptInput;
    KIRQL        OldIrql;

    for(InterruptInput=0; InterruptInput  < MAX_INTI; InterruptInput++) {
        if (HalpIntiInfo[InterruptInput].Destinations) {
            HalpSetRedirEntry (
                InterruptInput,
                HalpIntiInfo[InterruptInput].Entry,
                HalpIntiInfo[InterruptInput].Destinations << DESTINATION_SHIFT
            );
        }
    }
}


STATIC VOID
HalpDisableRedirEntry(
    IN USHORT InterruptInput,
    IN UCHAR  Cpu
    )
/*++

Routine Description:

    This procedure disables a IO Unit Redirection Table Entry
    by setting the mask bit in the Redir Entry.

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    ULONG Entry;
    ULONG Destination;

    //
    // Turn of the Destination bit for this Cpu
    //
    HalpIntiInfo[InterruptInput].Destinations =  HalpRemoveInterruptDest(
        HalpIntiInfo[InterruptInput].Destinations, Cpu);

    //
    //  Get the old entry, the only thing we want is the Entry field
    //

    HalpGetRedirEntry (
        InterruptInput,
        &Entry,
        &Destination
    );

    //
    // Only perform the disable if we've transitioned to zero enables
    //
    if ( HalpIntiInfo[InterruptInput].Destinations == 0) {
        //
        //  Disable the interrupt if no Cpu has it enabled
        //
        Entry |= INTERRUPT_MASKED;

    } else {
        //
        //  Create the new destination field sans this Cpu
        //
        Destination = HalpIntiInfo[InterruptInput].Destinations;
        Destination = (Destination << DESTINATION_SHIFT);
    }

    HalpSetRedirEntry (
        InterruptInput,
        Entry,
        Destination
    );
}

VOID
HalpSet8259Mask (
    IN USHORT Mask
    )
/*++

Routine Description:

    This procedure sets the 8259 Mask to the value passed in

Arguments:

    Mask - The mask bits to set

Return Value:

    None.

--*/
{
    _asm {
        mov     ax, Mask
        out     PIC1_PORT1, al
        shr     eax, 8
        out     PIC2_PORT1, al
    }
}

#define PIC1_BASE 0x30

STATIC VOID
SetPicInterruptHandler(
    IN USHORT InterruptInput
    )

/*++

Routine Description:

    This procedure sets a handler for a PIC inti

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{

    extern VOID (*PicExtintIntiHandlers[])(VOID);

    VOID (*Hp)(VOID) = PicExtintIntiHandlers[InterruptInput];

    KiSetHandlerAddressToIDT(PIC1_BASE + InterruptInput, Hp);
}

STATIC VOID
ResetPicInterruptHandler(
    IN USHORT InterruptInput
    )

/*++

Routine Description:

    This procedure sets a handler for a PIC inti to a NOP handler

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{

    extern VOID (*PicNopIntiHandlers[])(VOID);

    VOID (*Hp)(VOID) = PicNopIntiHandlers[InterruptInput];

    KiSetHandlerAddressToIDT(PIC1_BASE + InterruptInput, Hp);
}

STATIC VOID
HalpEnablePicInti (
    IN USHORT InterruptInput
    )

/*++

Routine Description:

    This procedure enables a PIC interrupt

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    USHORT PicMask;

    ASSERT(InterruptInput < 16);

    //
    // bump Enable Count for this INTI
    //
    Halp8259Counts[InterruptInput]++;

    //
    // Only actually perform the enable if we've transitioned
    // from zero to one enables
    //
    if ( Halp8259Counts[InterruptInput] == 1) {

        //
        // Set the Interrupt Handler for PIC inti,  this is
        // the routine that fields the EXTINT vector and issues
        // an APIC vector
        //

        SetPicInterruptHandler(InterruptInput);

        PicMask = HalpGlobal8259Mask;
        PicMask &= (USHORT) ~(1 << InterruptInput);
        if (InterruptInput > 7)
            PicMask &= (USHORT) ~(1 << PIC_SLAVE_IRQ);

        HalpGlobal8259Mask = PicMask;
        HalpSet8259Mask ((USHORT) PicMask);

    }
}

STATIC VOID
HalpDisablePicInti(
    IN USHORT InterruptInput
    )

/*++

Routine Description:

    This procedure enables a PIC interrupt

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    USHORT PicMask;

    ASSERT(InterruptInput < 16);

    //
    // decrement Enable Count for this INTI
    //

    Halp8259Counts[InterruptInput]--;

    //
    // Only disable if we have zero enables
    //
    if ( Halp8259Counts[InterruptInput] == 0) {

        //
        // Disable the Interrupt Handler for PIC inti
        //

        ResetPicInterruptHandler(InterruptInput);

        PicMask = HalpGlobal8259Mask;
        PicMask |= (1 << InterruptInput);
        if (InterruptInput > 7) {
            //
            //  This inti is on the slave, see if any other
            //  inti's are enabled.  If none are then disable the
            //  slave
            //
            if ((PicMask & 0xff00) == 0xff00)
                //
                //  All inti's on the slave are disabled
                //
                PicMask |= PIC_SLAVE_IRQ;
        }

        HalpSet8259Mask ((USHORT) PicMask);
        HalpGlobal8259Mask = PicMask;

    }
}

BOOLEAN
HalEnableSystemInterrupt(
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This procedure enables a system interrupt

    Some early implementations using the 82489DX only allow a processor
    to access the IO Unit on it's own 82489DX.  Since we use a single IO
    Unit (P0's) to distribute all interrupts, we have a problem when Pn
    wants to enable an interrupt on these type of systems.

    In order to get around this problem we can take advantage of the fact
    that the kernel calls Enable/Disable on each processor which has a bit
    set in the Affinity mask for the interrupt.  Since we have only one IO
    Unit in use and that Unit is addressable from P0 only, we must set the
    P0 affinity bit for all interrupts.  We can then ignore Enable/Disable
    requests from processors other than P0 since we will always get called
    for P0.

    The right way to do this assuming a single IO Unit accessable to all
    processors, would be to use global counters to determine if the
    interrupt has not been enabled on the IO Unit.  Then enable the IO Unit
    when we transition from no processors to one processor that have the
    interrupt enabled.

Arguments:

    Vector - vector of the interrupt to be enabled

    Irql   - interrupt level of the interrupt to be enabled.

Return Value:

    None.

--*/
{
    PKPCR           pPCR;
    UCHAR           ThisCpu, DevLevel;
    USHORT          InterruptInput;
    ULONG           Entry;
    ULONG           OldLevel;
    INTI_INFO       Inti;

    ASSERT(Vector < (1+MAX_NODES)*0x100-1);
    ASSERT(Irql <= HIGH_LEVEL);

    if ( (InterruptInput = HalpVectorToINTI[Vector]) == 0xffff ) {
        //
        // There is no external device associated with this interrupt
        //

        return(FALSE);
    }

    Inti = HalpIntiInfo[InterruptInput];

    DevLevel = HalpDevLevel
            [InterruptMode == LevelSensitive ? CFG_LEVEL : CFG_EDGE]
            [Inti.Level];

    if (DevLevel & CFG_ERROR) {
        DBGMSG ("HAL: Warning device interrupt mode overridden\n");
    }

    //
    // Block interrupts & synchronize until we're done
    //

    OldLevel = HalpAcquireHighLevelLock (&HalpAccountingLock);

    pPCR = KeGetPcr();
    ThisCpu = pPCR->Prcb->Number;

    switch (Inti.Type) {

        case INT_TYPE_INTR: {
            //
            // enable the interrupt in the I/O unit redirection table
            //
            switch (Vector) {
                case APIC_CLOCK_VECTOR:
                    ASSERT(ThisCpu == 0);
                    Entry = APIC_CLOCK_VECTOR | DELIVER_FIXED | LOGICAL_DESTINATION;
                    break;
                case NMI_VECTOR:
                    return FALSE;
                default:
                    Entry = HalVectorToIDTEntry(Vector) | DELIVER_LOW_PRIORITY | LOGICAL_DESTINATION;
                    break;
            }  // switch (Vector)

            Entry |= CFG_TYPE(DevLevel) == CFG_EDGE ? EDGE_TRIGGERED : LEVEL_TRIGGERED;
            Entry |= HalpDevPolarity[Inti.Polarity][CFG_TYPE(DevLevel)] ==
                         CFG_LOW ? ACTIVE_LOW : ACTIVE_HIGH;

            HalpEnableRedirEntry (
                    InterruptInput,
                    Entry,
                    (UCHAR) ThisCpu
                    );

            break;

        }  // case INT_TYPE_INTR:

        case INT_TYPE_EXTINT: {
            //
            // This is an interrupt that uses the IO APIC to route PIC
            // events.  In this case the IO unit has to be enabled and
            // the PIC must be enabled.
            //

            HalpEnableRedirEntry (
                0,                      // WARNING: kenr - assuming 0
                DELIVER_EXTINT | LOGICAL_DESTINATION,
                (UCHAR) ThisCpu
                );
            HalpEnablePicInti(InterruptInput);
            break;
        }  // case INT_TYPE_EXTINT

        default:
            DBGMSG ("HalEnableSystemInterrupt: Unkown Inti Type\n");
            break;
    }  //     switch (IntiType)

    HalpReleaseHighLevelLock (&HalpAccountingLock, OldLevel);
    return TRUE;
}


VOID
HalDisableSystemInterrupt(
    IN ULONG Vector,
    IN KIRQL Irql
    )

/*++


Routine Description:

    Disables a system interrupt.

    Some early implementations using the 82489DX only allow a processor
    to access the IO Unit on it's own 82489DX.  Since we use a single IO
    Unit (P0's) to distribute all interrupts, we have a problem when Pn
    wants to enable an interrupt on these type of systems.

    In order to get around this problem we can take advantage of the fact
    that the kernel calls Enable/Disable on each processor which has a bit
    set in the Affinity mask for the interrupt.  Since we have only one IO
    Unit in use and that Unit is addressable from P0 only, we must set the
    P0 affinity bit for all interrupts.  We can then ignore Enable/Disable
    requests from processors other than P0 since we will always get called
    for P0.

    The right way to do this assuming a single IO Unit accessable to all
    processors, would be to use global counters to determine if the
    interrupt has not been enabled on the IO Unit.  Then enable the IO Unit
    when we transition from no processors to one processor that have the
    interrupt enabled.

Arguments:

    Vector - Supplies the vector of the interrupt to be disabled

    Irql   - Supplies the interrupt level of the interrupt to be disabled

Return Value:

    None.

--*/
{
    PKPCR       pPCR;
    USHORT      InterruptInput;
    UCHAR       ThisCpu;
    ULONG       OldLevel;

    ASSERT(Vector < (1+MAX_NODES)*0x100-1);
    ASSERT(Irql <= HIGH_LEVEL);

    if ( (InterruptInput = HalpVectorToINTI[Vector]) == 0xffff ) {
        //
        // There is no external device associated with this interrupt
        //
        return;
    }

    //
    // Block interrupts & synchronize until we're done
    //

    OldLevel = HalpAcquireHighLevelLock (&HalpAccountingLock);

    pPCR = KeGetPcr();
    ThisCpu = pPCR->Prcb->Number;

    switch (HalpIntiInfo[InterruptInput].Type) {

        case INT_TYPE_INTR: {
            //
            // enable the interrupt in the I/O unit redirection table
            //

            HalpDisableRedirEntry( InterruptInput, ThisCpu );
            break;

        }  // case INT_TYPE_INTR:

        case INT_TYPE_EXTINT: {
            //
            // This is an interrupt that uses the IO APIC to route PIC
            // events.  In this case the IO unit has to be enabled and
            // the PIC must be enabled.
            //
            //
            //  WARNING: The PIC is assumed to be routed only through
            //  IoApic[0]Inti[0]
            //
            HalpDisablePicInti(InterruptInput);
            break;
        }

        default:
            DBGMSG ("HalDisableSystemInterrupt: Unkown Inti Type\n");
            break;

    }


    HalpReleaseHighLevelLock (&HalpAccountingLock, OldLevel);
    return;

}

VOID
HalpInitializeIOUnits (
    VOID
    )
/*

 Routine Description:

    This routine initializes the IO APIC.  It only programs the APIC ID Register.

    HalEnableSystemInterrupt programs the Redirection table.

 Arguments:

    None

 Return Value:

    None.

*/

{
    ULONG IoApicId;
    struct ApicIoUnit *IoUnitPtr;
    ULONG i, j, max, regVal;

    for(i=0; i < HalpMpInfoTable.IOApicCount; i++) {

        IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoTable.IoApicBase[i];

        //
        //  write the I/O unit APIC-ID - Since we are using the Processor
        //  Numbers for the local unit ID's we need to set the IO unit
        //  to a high (out of Processor Number range) value.
        //
        IoUnitPtr->RegisterSelect = IO_ID_REGISTER;
        IoApicId = HalpGetIoApicId(i);
        regVal = IoUnitPtr->RegisterWindow;
        regVal &= ~APIC_ID_MASK;
        IoUnitPtr->RegisterWindow = (IoApicId << APIC_ID_SHIFT) | regVal;

        //
        //  mask all vectors on the ioapic
        //

        IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
        max = ((IoUnitPtr->RegisterWindow >> 16) & 0xff) * 2;
        for (j=0; j <= max; j += 2) {
            IoUnitPtr->RegisterSelect  = IO_REDIR_00_LOW + j;
            IoUnitPtr->RegisterWindow |= INT_VECTOR_MASK | INTERRUPT_MASKED;
        }
    }

    if (HalpHiberInProgress)  {
        return;
    }

    //
    // Add resources consumed by APICs
    //

    HalpApicUsage.Next  = NULL;
    HalpApicUsage.Type  = CmResourceTypeMemory;
    HalpApicUsage.Flags = DeviceUsage;

    HalpApicUsage.Element[0].Start = HalpMpInfoTable.LocalApicBase;
    HalpApicUsage.Element[0].Length = 0x400;
    
    ASSERT (HalpMpInfoTable.IOApicCount <= MAX_IOAPICS);
    for (i=0; i < HalpMpInfoTable.IOApicCount; i++) {
        HalpApicUsage.Element[i+1].Start = (ULONG)HalpMpInfoTable.IoApicPhys[i];
        HalpApicUsage.Element[i+1].Length = 0x400;
    }

    HalpApicUsage.Element[i+1].Start = 0;
    HalpApicUsage.Element[i+1].Length = 0;
    HalpRegisterAddressUsage ((ADDRESS_USAGE*)&HalpApicUsage);
}

VOID
HalpEnableNMI (
    VOID
    )
/*

 Routine Description:

    Enable & connect NMI sources for the calling processor.

*/
{
    PKPCR       pPCR;
    USHORT      InterruptInput;
    UCHAR       ThisCpu;
    ULONG       OldLevel;
    ULONG       Entry;

    pPCR = KeGetPcr();
    ThisCpu = pPCR->Prcb->Number;

    OldLevel = HalpAcquireHighLevelLock (&HalpAccountingLock);

    HalpEnableLocalNmiSources();

    //
    // Enable any NMI sources found on IOAPICs
    //

    for (InterruptInput=0; InterruptInput < MAX_INTI; InterruptInput++) {
        if (HalpIntiInfo[InterruptInput].Type == INT_TYPE_NMI) {

            Entry = NMI_VECTOR | DELIVER_NMI | LOGICAL_DESTINATION;

            //
            // Halmps has had a bug in it for a long time.  It always connects
            // NMI signals on I/O APICs as level-triggered, active-high.  This
            // hack preserves that behavior for halmps and actually fixes the bug
            // on halacpi.
            //

#ifdef ACPI_HAL
#define POLARITY_HIGH               1
#define POLARITY_LOW                3
#define POLARITY_CONFORMS_WITH_BUS  0

            Entry |= ((HalpIntiInfo[InterruptInput].Level == CFG_EDGE) ? EDGE_TRIGGERED : LEVEL_TRIGGERED);
            Entry |= (((HalpIntiInfo[InterruptInput].Polarity == POLARITY_CONFORMS_WITH_BUS) ||
                       (HalpIntiInfo[InterruptInput].Polarity == POLARITY_HIGH))
                         ? ACTIVE_HIGH : ACTIVE_LOW);
#else
            Entry |= LEVEL_TRIGGERED;
#endif

            HalpEnableRedirEntry (
                InterruptInput,
                Entry,
                (UCHAR) ThisCpu
                );
        }
    }

    HalpReleaseHighLevelLock (&HalpAccountingLock, OldLevel);

    return;
}

VOID
HalpEnablePerfInterupt (
    ULONG Context
    )
{
    //
    // Enable local processor perf interrupt source
    //

    pLocalApic[LU_PERF_VECTOR/4] = (LEVEL_TRIGGERED | APIC_PERF_VECTOR |
            DELIVER_FIXED | ACTIVE_LOW);
}

UCHAR
HalpAddInterruptDest(
    IN UCHAR CurrentDest,
    IN UCHAR ThisCpu
    )
/*++

Routine Description:

    This routine adds a CPU to the destination processor set of device
    interrupts.

Arguments:

    CurrentDest - The present processor destination set for the interrupt

    ThisCpu - The logical NT processor number which has to be added to the
              interrupt destination mask

Return Value:

    The bitmask corresponding to the new destiantion. This bitmask is suitable
    to be written into the hardware.

--*/
{

    PINTERRUPT_DEST Destination;


    if (HalpMaxProcsPerCluster == 0)  {
        return(HalpIntDestMap[ThisCpu].LogicalId | CurrentDest);
    } else  {
        //
        // The current destination is a hardware cluster & destination ID
        //
        Destination = (PINTERRUPT_DEST)&CurrentDest;

        if (HalpIntDestMap[ThisCpu].Cluster.Hw.ClusterId ==
            Destination->Cluster.Hw.ClusterId)  {
            Destination->Cluster.Hw.DestId |=
                HalpIntDestMap[ThisCpu].Cluster.Hw.DestId;
            return(Destination->Cluster.AsUchar);
        } else  {
            //
            // In cluster mode, each interrupt can be routed only to a single
            // cluster. Replace the existing destination cluster with this one.
            //
            return(HalpIntDestMap[ThisCpu].Cluster.AsUchar);
        }
    }
}


UCHAR
HalpRemoveInterruptDest(
    IN UCHAR CurrentDest,
    IN UCHAR ThisCpu
    )
/*++

Routine Description:

    This routine removes a CPU from the destination processor set of device
    interrupts.

Arguments:

    CurrentDest - The present processor destination set for the interrupt

    ThisCpu - The logical NT processor number which has to be removed from the
              interrupt destination mask

Return Value:

    The bitmask corresponding to the new destiantion. This bitmask is suitable
    to be written into the hardware.

--*/

{
    PINTERRUPT_DEST Destination;

    if (HalpMaxProcsPerCluster == 0)  {
        CurrentDest &= ~(HalpIntDestMap[ThisCpu].LogicalId);
        return(CurrentDest);
    } else  {
        Destination = (PINTERRUPT_DEST)&CurrentDest;
        if (HalpIntDestMap[ThisCpu].Cluster.Hw.ClusterId !=
            Destination->Cluster.Hw.ClusterId)  {
            //
            // We are being asked to remove a processor which is not part
            // of the destination processor set for this interrupt
            //
            return(CurrentDest);
        } else  {
            //
            // Remove this processor and check if it is the last processor
            // in the destination set
            //
            Destination->Cluster.Hw.DestId &=
                ~(HalpIntDestMap[ThisCpu].Cluster.Hw.DestId);
            if (Destination->Cluster.Hw.DestId)  {
                return(Destination->Cluster.AsUchar);
            } else  {
                //
                // There are no processors left in the destination mask.
                // Return 0 so the caller can disable the entry in the IO APIC
                //
                return(0);
            }
        }
    }
}

UCHAR
HalpMapNtToHwProcessorId(
    IN UCHAR Number
    )
/*

 Routine Description:

    This routine maps the logical NT processor number to the hardware cluster
    ID and processor ID for MPS systems.

 Arguments:

    Number: Logical NT processor number(zero based).

 Return Value:

    Bitmask representing the hardware cluster number and processor number for
    this processor. The return value is programmed into the hardware.

*/

{
    INTERRUPT_DEST IntDest;

    if (HalpMaxProcsPerCluster == 0)  {
        return(1 << Number);
    } else  {
        //
        // In systems with heirarchical APIC buses, the BIOS/MPS table has to
        // inform the OS of the underlying topology so we can do this mapping.
        // For now, just assign consecutive cluster IDs starting from 0.
        //
        IntDest.Cluster.Hw.ClusterId = (Number/HalpMaxProcsPerCluster);
        IntDest.Cluster.Hw.DestId = 1 << (Number % HalpMaxProcsPerCluster);
        return(IntDest.Cluster.AsUchar);
    }
}

VOID
HalpInitializeApicAddressing(
    IN UCHAR Number
    )
{
    if (HalpMaxProcsPerCluster == 0)  {
        pLocalApic[LU_DEST_FORMAT/4] = LU_DEST_FORMAT_FLAT;
    }  else  {
        ASSERT(Number <= (HalpMaxProcsPerCluster * MAX_CLUSTERS));
        pLocalApic[LU_DEST_FORMAT/4] = LU_DEST_FORMAT_CLUSTER;
    }

    HalpIntDestMap[Number].LogicalId =  HalpMapNtToHwProcessorId(Number);

    //
    // At this point the Logical ID is a bit map of the processor number
    // the actual ID is the upper byte of the logical destination register
    // Note that this is not strictly true of 82489's.  The 82489 has 32 bits
    // available for the logical ID, but since we want software compatability
    // between the two types of APICs we'll only use the upper byte.
    //
    // Shift the mask into the ID field and write it.
    //
    pLocalApic[LU_LOGICAL_DEST/4] = (ULONG)
        (HalpIntDestMap[Number].LogicalId << DESTINATION_SHIFT);

}


UCHAR
HalpNodeNumber(
    PKPCR pPCR
    )
/*

 Routine Description:

    This routine divines the Node number for the current CPU.
    Node numbers start at 1, and represent the granularity of interrupt
    routing decisions.

 Arguments:

    pPCR - A pointer to the PCR of the current processor.  (This implies
           the caller must have masked interrupts.)

 Return Value:

    None.

*/
{
    // One Node per cluster.
    if (HalpMaxProcsPerCluster != 0)  {
        // One Node per Cluster.
        return(pPCR->Prcb->Number/HalpMaxProcsPerCluster + 1);
    } else {
        // One Node per machine.
        return(1);
    }
#if 0
    ULONG   localApicId;

    // One Node per physical CPU package.
    localApicId = *(PVULONG)(LOCALAPIC + LU_ID_REGISTER);
    localApicId &= APIC_ID_MASK;
    localApicId >>= APIC_ID_SHIFT;

    // TODO: Implement cpuid stuff here to determine shift
    return((localApicId>>1) + 1);
#endif
}

VOID
HalpInitializeLocalUnit (
    VOID
    )
/*

 Routine Description:


    This routine initializes the interrupt structures for the local unit
    of the APIC.  This procedure is called by HalInitializeProcessor and
    is executed by each CPU.

 Arguments:

    None

 Return Value:

    None.

*/
{
    PKPCR pPCR;
    ULONG SavedFlags;
    UCHAR Node;

    _asm {
        pushfd
        pop eax
        mov SavedFlags, eax
        cli
    }

    pPCR = KeGetPcr();

    if (pPCR->Prcb->Number ==0) {
        //
        // enable APIC mode
        //
        //  PC+MP Spec has a port defined (IMCR - Interrupt Mode Control
        //  Port) That is used to enable APIC mode.  The APIC could already
        //  be enabled, but per the spec this is safe.
        //

        if (HalpMpInfoTable.IMCRPresent)
        {
#if defined(NEC_98)
            _asm {
                push    dx
                mov     dx, ImcrDataPortAddr
                mov     al, ImcrEnableApic
                out     dx, al
                pop     dx
            }
#else  // defined(NEC_98)
            _asm {
                mov al, ImcrPort
                out ImcrRegPortAddr, al

                mov al, ImcrEnableApic
                out ImcrDataPortAddr, al
            }
#endif // defined(NEC_98)
        }

        //
        // By default, use flat logical APIC addressing. If we have more
        // than 8 processors, we must use cluster mode APIC addressing
        //
        if( (HalpMaxProcsPerCluster > 4)        ||
            ((HalpMpInfoTable.ProcessorCount > 8) &&
             (HalpMaxProcsPerCluster == 0)) )  {
            HalpMaxProcsPerCluster = 4;
        }

        if (HalpMpInfoTable.ApicVersion == APIC_82489DX)   {
            //
            // Ignore user's attempt to force cluster mode if running
            // on 82489DX external APIC interrupt controller.
            //
            ASSERT(HalpMpInfoTable.ProcessorCount <= 8);
            HalpMaxProcsPerCluster = 0;
        }
    }

    //
    // Add the current processor to the Node tables.
    //
    Node = HalpNodeNumber(pPCR);
    if (HalpMaxNode < Node) {
        HalpMaxNode = Node;
    }
    HalpNodeAffinity[Node-1] |= 1 << pPCR->Prcb->Number;

    //
    // Program the TPR to mask all events
    //
    pLocalApic[LU_TPR/4] = 0xff;
    HalpInitializeApicAddressing(pPCR->Prcb->Number);

    //
    //  Initialize spurious interrupt handling
    //
    KiSetHandlerAddressToIDT(APIC_SPURIOUS_VECTOR, HalpApicSpuriousService);
    pLocalApic[LU_SPURIOUS_VECTOR/4] = (APIC_SPURIOUS_VECTOR | LU_UNIT_ENABLED);

    if (HalpMpInfoTable.ApicVersion != APIC_82489DX)  {
        //
        //  Initialize Local Apic Fault handling
        //
        KiSetHandlerAddressToIDT(APIC_FAULT_VECTOR, HalpLocalApicErrorService);
        pLocalApic[LU_FAULT_VECTOR/4] = APIC_FAULT_VECTOR;
    }

    //
    //  Disable APIC Timer Vector, will be enabled later if needed
    //  We have to program a valid vector otherwise we get an APIC
    //  error.
    //
    pLocalApic[LU_TIMER_VECTOR/4] = (APIC_PROFILE_VECTOR |PERIODIC_TIMER | INTERRUPT_MASKED);

    //
    //  Disable APIC PERF Vector, will be enabled later if needed.
    //  We have to program a valid vector otherwise we get an APIC
    //  error.
    //
    pLocalApic[LU_PERF_VECTOR/4] = (APIC_PERF_VECTOR | INTERRUPT_MASKED);

    //
    //  Disable LINT0, if we were in Virtual Wire mode then this will
    //  have been enabled on the BSP, it may be enabled later by the
    //  EnableSystemInterrupt code
    //
    pLocalApic[LU_INT_VECTOR_0/4] = (APIC_SPURIOUS_VECTOR | INTERRUPT_MASKED);

    //
    //  Program NMI Handling,  it will be enabled on P0 only
    //  RLM Enable System Interrupt should do this
    //

    pLocalApic[LU_INT_VECTOR_1/4] = ( LEVEL_TRIGGERED | ACTIVE_HIGH | DELIVER_NMI |
                     INTERRUPT_MASKED | ACTIVE_HIGH | NMI_VECTOR);

    //
    //  Synchronize Apic IDs - InitDeassertCommand is sent to all APIC
    //  local units to force synchronization of arbitration-IDs with APIC-IDs.
    //
    //  NOTE: we don't have to worry about synchronizing access to the ICR
    //  at this point.
    //

    pLocalApic[LU_INT_CMD_LOW/4] = (DELIVER_INIT | LEVEL_TRIGGERED |
                     ICR_ALL_INCL_SELF | ICR_LEVEL_DEASSERTED);

    //
    //  we're done - set TPR to a low value and return
    //
    pLocalApic[LU_TPR/4] = ZERO_VECTOR;

    _asm {
        mov  eax, SavedFlags
        push eax
        popfd
    }
}


VOID
HalpUnMapIOApics(
    VOID
    )
/*++
Routine Description:

    This routine unmaps the IOAPIC's and is primarily used
    to prevent loss of VA space during hibernation

Arguments:

    None:

 Return Value:

    None
*/
{
    UCHAR i;

    for(i=0; i < HalpMpInfoTable.IOApicCount; i++)  {
        if (HalpMpInfoTable.IoApicBase[i]) {
            HalpUnmapVirtualAddress(HalpMpInfoTable.IoApicBase[i],1);
        }
    }
}

VOID
HalpPostSleepMP(
    IN LONG           NumberProcessors,
    IN volatile PLONG Number
    )
/*++
Routine Description:

    This routine does the part of MP re-init that needs to
    happen after hibernation or sleeping.

Arguments:

    None:

 Return Value:

    None
*/
{
    volatile ULONG ThisProcessor;
    ULONG   localApicId;
    KIRQL   OldIrql;

    //
    // Boot processor and the newly woken processors come here
    //

    ThisProcessor = KeGetPcr()->Prcb->Number;

    if (ThisProcessor != 0)  {

        HalpInitializeLocalUnit ();
        KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    }

    //
    // Fill in this processor's Apic ID.
    //

    localApicId = *(PVULONG)(LOCALAPIC + LU_ID_REGISTER);

    localApicId &= APIC_ID_MASK;
    localApicId >>= APIC_ID_SHIFT;

    ((PHALPRCB)KeGetPcr()->Prcb->HalReserved)->PCMPApicID = (UCHAR)localApicId;

    //
    // Initialize the processor machine check registers
    //

    if ((HalpFeatureBits & HAL_MCE_PRESENT) ||
        (HalpFeatureBits & HAL_MCA_PRESENT)) {
        HalpMcaCurrentProcessorSetConfig();
    }

    //
    // Enable NMI vectors in the local APIC
    //

    HalpEnableNMI();

    //
    // Enable perf event in local APIC
    //

    if (HalpFeatureBits & HAL_PERF_EVENTS)  {
        HalpEnablePerfInterupt(0);
    }

    //
    // Wait for all processors to finish initialization.
    //

    InterlockedIncrement(Number);
    while (*Number != NumberProcessors);

    //
    // The following global hardware state needs to be set after all processors
    // have been woken up and initialized
    //

    if (KeGetPcr()->Prcb->Number == 0)  {

        //
        // Restore clock interrupt
        //

        HalpInitializeClock();

        HalpSet8259Mask(HalpGlobal8259Mask);

        HalpHiberInProgress = FALSE;

        //
        // We are now ready to send IPIs again if more than
        // one processor
        //

        if (NumberProcessors > 1) {
            HalpIpiClock = 0xff;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\xxbiosc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxbiosc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\xxmemory.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxmemory.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\xxioacc.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\xxioacc.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\xxdisp.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxdisp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\xxflshbf.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxflshbf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\xxtime.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxtime.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\xxstubs.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxstubs.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\pcip.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI 1

#include "..\..\halx86\i386\pcip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\pcmpdtct.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    pcmpdtct.c

Abstract:

    This module detects an MPS system.

Author:

    Ron Mosgrove (Intel) - Aug 1993.

Environment:

    Kernel mode or from textmode setup.

Revision History:
    Rajesh Shah (Intel) - Oct 1993. Added support for MPS table.

--*/

#ifndef _NTOS_
#include "halp.h"
#endif

#include "apic.inc"
#include "pcmp_nt.inc"
#include "stdio.h"

#if DEBUGGING
CHAR Cbuf[120];
VOID HalpDisplayConfigTable(VOID);
VOID HalpDisplayExtConfigTable(VOID);
VOID HalpDisplayBIOSSysCfg(struct SystemConfigTable *);
#define DBGMSG(a)   HalDisplayString(a)
#else
#define DBGMSG(a)
#endif

#define DEBUG_MSG(a)

//
// The floating pointer structure defined by the MPS spec can reside
// anywhere in BIOS extended data area. These defines are used to search for
// the floating structure starting from physical address 639K(9f000+c00)
//
#define PCMP_TABLE_PTR_BASE           0x09f000
#define PCMP_TABLE_PTR_OFFSET         0x00000c00

extern struct  HalpMpInfo HalpMpInfoTable;

UCHAR
ComputeCheckSum(
    IN PUCHAR SourcePtr,
    IN USHORT NumOfBytes
    );

VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );

struct FloatPtrStruct *
SearchFloatPtr (
    ULONG PhysicalAddress,
    ULONG ByteSize
    );

struct FloatPtrStruct *
PcMpGetFloatingPtr (
    VOID
    );

struct PcMpTable *
GetPcMpTable (
    VOID
    );


struct PcMpTable *
MPS10_GetPcMpTablePtr (
    VOID
    );

struct PcMpTable *
MPS10_GetPcMpTable (
    VOID
    );


struct PcMpTable *
GetDefaultConfig (
    IN ULONG Config
    );

#ifdef SETUP

//
// A dummy pointer to a default MPS table. For setup, we can conserve
// space by not building default tables in our data area.
#define DEFAULT_MPS_INDICATOR   0xfefefefe

#define HalpUnmapVirtualAddress(a, b)

#endif   //SETUP

#ifndef SETUP
#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,SearchFloatPtr)
#pragma alloc_text(PAGELK,PcMpGetFloatingPtr)
#pragma alloc_text(PAGELK,ComputeCheckSum)
#pragma alloc_text(PAGELK,GetPcMpTable)
#pragma alloc_text(PAGELK,MPS10_GetPcMpTablePtr)
#pragma alloc_text(PAGELK,MPS10_GetPcMpTable)
#pragma alloc_text(PAGELK,GetDefaultConfig)
#endif  // ALLOC_PRAGMA

extern struct PcMpTable *PcMpDefaultTablePtrs[];
extern BOOLEAN HalpUse8254;
#endif   // ndef SETUP


struct FloatPtrStruct *
SearchFloatPtr(
    ULONG PhysicalAddress,
    ULONG ByteSize
    )
{
    // Search for the MPS floating pointer structure starting from the
    // physical address given.

    USHORT Index, ParagraphLength;
    UCHAR CheckSum;
    struct FloatPtrStruct *VirtualAddress;
    BOOLEAN CheckSumError;
    PHYSICAL_ADDRESS physAddr = {0};

#ifdef DEBUGGING
    sprintf(Cbuf, "SearchFloatPtr: Will search at physical address 0x%lx\n",
        PhysicalAddress);
    HalDisplayString(Cbuf);
#endif // DEBUGGING

    // The MPS spec says that the floating pointer structure MUST be
    // aligned at 16 byte boundaries. We can use this fact to search for
    // the structure only at those boundaries. Assume that the input physical
    // address to start search from is 16 byte aligned.

    CheckSumError = FALSE;
    for(Index = 0; Index < (ByteSize/sizeof(struct FloatPtrStruct)); Index++) {
        
        physAddr.LowPart = PhysicalAddress + (Index * sizeof(struct FloatPtrStruct));

        VirtualAddress = (struct FloatPtrStruct *)HalpMapPhysicalMemory64(
                             physAddr,
                             1
                             );
        
        if (VirtualAddress == NULL) {
            DEBUG_MSG ("SearchFloatPtr: Cannot map Physical address\n");
            return (NULL);
        }
    
        if ( (*((PULONG)VirtualAddress) ) == MP_PTR_SIGNATURE)  {

            ParagraphLength =
                ((struct FloatPtrStruct *)VirtualAddress)->MpTableLength;
            
            //
            // Detected the floating structure signature. Check if the
            // floating pointer structure checksum is valid.
            //

            CheckSum = ComputeCheckSum((PUCHAR)VirtualAddress,
                                       (USHORT) (ParagraphLength*16) );
            
            if (CheckSum == 0 )  {
            
                // We have a valid floating pointer structure.
                // Return a pointer to it.
    
                DEBUG_MSG ("SearchFloatPtr: Found structure\n");
                return((struct FloatPtrStruct *) VirtualAddress);
            }

            // Invalid structure. Continue searching.
            CheckSumError = TRUE;
            DEBUG_MSG ("SearchFloatPtr: Valid MP_PTR signature, invalid checksum\n");
        }
        
        //
        // Give back the PTE.
        //

        HalpUnmapVirtualAddress(VirtualAddress, 1);
    }

    if (CheckSumError) {
        FAILMSG (rgzMPPTRCheck);
    }

    return(NULL);
}

struct FloatPtrStruct *
PcMpGetFloatingPtr(
    VOID)
{
    ULONG EbdaSegmentPtr, BaseMemPtr;
    ULONG EbdaPhysicalAdd = 0, ByteLength, BaseMemKb = 0;
    struct FloatPtrStruct *FloatPtr = NULL;
    PUCHAR zeroVirtual;
    PHYSICAL_ADDRESS zeroPhysical;

    // Search for the floating pointer structure in the order specified in
    // MPS spec version 1.1.

    // First, search for it in the first kilobyte in the Extended BIOS Data
    // Area. The EBDA segment address is available at physical address 40:0E

    zeroPhysical = HalpPtrToPhysicalAddress( (PVOID)0 );
    zeroVirtual = HalpMapPhysicalMemory64( zeroPhysical, 1);
    EbdaSegmentPtr = (ULONG)(zeroVirtual + EBDA_SEGMENT_PTR);
    EbdaPhysicalAdd = *((PUSHORT)EbdaSegmentPtr);
    EbdaPhysicalAdd = EbdaPhysicalAdd << 4;

    if (EbdaPhysicalAdd != 0)
        FloatPtr = SearchFloatPtr(EbdaPhysicalAdd, 1024);

    HalpUnmapVirtualAddress(zeroVirtual, 1);

    if (FloatPtr == NULL)  {

        // Did not find it in EBDA.
        // Look for it in the last KB of system memory.

        zeroVirtual = HalpMapPhysicalMemory64( zeroPhysical, 1);
        BaseMemPtr = (ULONG)(zeroVirtual + BASE_MEM_PTR);
        BaseMemKb = *((PUSHORT)BaseMemPtr);

        FloatPtr = SearchFloatPtr(BaseMemKb*1024, 1024);

        HalpUnmapVirtualAddress(zeroVirtual, 1);

        if (FloatPtr == NULL)  {

            // Finally, look for the floating Pointer Structure at physical
            // address F0000H to FFFFFH

            ByteLength = 0xfffff - 0xf0000;

            FloatPtr = SearchFloatPtr(0xf0000, ByteLength);
        }
    }

    // At this point, we have a pointer to the MPS floating structure.

    return(FloatPtr);
}


struct PcMpTable *
MPS10_GetPcMpTablePtr(
    VOID
    )
/*++

Routine Description:

    Gets the Address of the MPS configuration table built by BIOS.
    This routine looks for the floating pointer structure defined
    in the MPS spec. This structure points to the MPS configuration
    table built by an MP BIOS. The floating pointer structure can be
    located anywhere in the extended BIOS data area(physical address range
    639K to 640K), and must be aligned on a 16 byte boundary.

 Arguments:
    None

 Return Value:
    struct PcMpTable * - Virtual address pointer to the PcMpTable, if
    it exists, NULL otherwise

--*/

{
    PUCHAR TempPtr;
    ULONG LinearPtr;
    UCHAR CheckSum;
    struct PcMpTableLocator *PcMpPtrPtr;
    PULONG TraversePtr;
    PVOID  BasePtr;
    USHORT ParagraphLength;
    int i;
    PHYSICAL_ADDRESS physicalAddress;

    // Map the physical address of the BIOS extended data area to a virtual
    // address we can use.
    
    physicalAddress = HalpPtrToPhysicalAddress( (PVOID)PCMP_TABLE_PTR_BASE );
    BasePtr = (PUCHAR) HalpMapPhysicalMemory64(physicalAddress, 1);
    TempPtr = BasePtr;
    TraversePtr = (PULONG)((PUCHAR) TempPtr + PCMP_TABLE_PTR_OFFSET);

    // Look at 16 byte boundaries for the floating pointer structure
    // The structure is identified by its signature, and verified by its
    // checksum.
    for (i=0; i < (1024/16); ++i)
    {
        if (*(TraversePtr) == MP_PTR_SIGNATURE)
        {
            // Got a valid signature.
            PcMpPtrPtr = (struct PcMpTableLocator *)TraversePtr;

            // Length in 16 byte paragraphs of the floating structure.
            // Normally, this should be set to 1 by the BIOS.
            ParagraphLength = PcMpPtrPtr->MpTableLength;

            // Check if the floating pointer structure is valid.
            CheckSum = ComputeCheckSum((PUCHAR)PcMpPtrPtr,
                            (USHORT) (ParagraphLength*16));
            if (CheckSum != 0 ) {
                FAILMSG (rgzMPPTRCheck);
                // Invalid structure. Continue searching.
                TraversePtr += 4;
                continue;
            }

            // We have a valid floating pointer structure.
            // The value stored in the structure is a physical address of the
            // MPS table built by BIOS. Get the corresponding virtual
            // address.

            physicalAddress = HalpPtrToPhysicalAddress( PcMpPtrPtr->TablePtr );
            TempPtr =  HalpMapPhysicalMemory64(physicalAddress,2);
            
            //
            // Done with base pointer.
            //

            HalpUnmapVirtualAddress(BasePtr, 1);
            
            if (TempPtr == NULL) {
                DEBUG_MSG ("HAL: Cannot map BIOS created MPS table\n");
                return (NULL);
            }

            // Return the virtual address pointer to the MPS table.
            return((struct PcMpTable *) TempPtr);

        }
        TraversePtr += 4;
    }

    return(NULL);
}


UCHAR
ComputeCheckSum (
    IN PUCHAR SourcePtr,
    IN USHORT NumOfBytes
    )
/*++

Routine Description:
    This routine computes a checksum for NumOfBytes bytes, starting
    from SourcePtr. It is used to validate the tables built by BIOS.

Arguments:
    SourcePtr : Starting virtual address to compute checksum.
    NumOfBytes: Number of bytes to compute the checksum of.

 Return Value:
     The checksum value.

*/
{
    UCHAR Result = 0;
    USHORT Count;

    for(Count=0; Count < NumOfBytes; ++Count)
        Result += *SourcePtr++;

    return(Result);
}


struct PcMpTable *
MPS10_GetPcMpTable (
    VOID
    )
/*++
Routine Description:
    Detects an MPS 1.0 system only.

Arguments:
    None.

Return Value:
    Pointer to an MPS table.
--*/
{
    struct SystemConfigTable *SystemConfigPtr;

    UCHAR DefaultConfig, CheckSum;
    struct PcMpTable *MpTablePtr;
    UCHAR MpFeatureInfoByte1 = 0, MpFeatureInfoByte2 = 0;
    PHYSICAL_ADDRESS physicalAddress;

    // Get the virtual address of the system configuration table.
    physicalAddress = HalpPtrToPhysicalAddress( (PVOID)BIOS_BASE );
    SystemConfigPtr = (struct SystemConfigTable *)
        HalpMapPhysicalMemory64( physicalAddress, 16);

    if (SystemConfigPtr == NULL) {
        DEBUG_MSG ("GetPcMpTable: Cannot map system configuration table\n");
        return(NULL);
    }

    // HalpDisplayBIOSSysCfg(SystemConfigPtr);

    //  The system configuration table built by BIOS has 2 MP feature
    //  information bytes.

    MpFeatureInfoByte1 = SystemConfigPtr->MpFeatureInfoByte1;
    MpFeatureInfoByte2 = SystemConfigPtr->MpFeatureInfoByte2;

    // The second MP feature information byte tells us whether the system
    // has an IMCR(Interrupt Mode Control Register). We use this information
    // in the HAL, so we store this information in the OS specific private
    // area.

    if ((MpFeatureInfoByte2 & IMCR_MASK) == 0) {
        HalpMpInfoTable.IMCRPresent = 0;
    } else {
        HalpMpInfoTable.IMCRPresent = 1;
    }

#ifndef SETUP

    // The second MP feature information byte tells us whether Time
    // Stamp Counter should be used as a high-resolution timer on 
    // multiprocessor systems.

    if ((MpFeatureInfoByte2 & MULT_CLOCKS_MASK) != 0) {
        HalpUse8254 = 1;
    }
#endif

    // MP feature byte 1 indicates if the system is MPS compliant
    if (! (MpFeatureInfoByte1 & PCMP_IMPLEMENTED)) {
        // The MP feature information byte indicates that this
        // system is not MPS compliant.
        FAILMSG (rgzNoMpsTable);
        return(NULL);
    }

    // The system is MPS compliant. MP feature byte 2 indicates if the
    // system is a default configuration or not.
    DefaultConfig = (MpFeatureInfoByte1 & PCMP_CONFIG_MASK) >> 1;

    if (DefaultConfig) {
        return GetDefaultConfig(DefaultConfig);
    }

    // DefaultConfig == 0. This means that the BIOS has built a MP
    // config table for us. The BIOS will also build a floating pointer
    // structure that points to the MP config table. This floating pointer
    // structure resides in the BIOS extended data area.
    MpTablePtr = MPS10_GetPcMpTablePtr();

    if (MpTablePtr == NULL) {
        FAILMSG (rgzNoMPTable);     // Could not find BIOS created MPS table
        return(NULL);
    }

    // We have a pointer to the MP config table. Check if the table is valid.

    if ((MpTablePtr->Signature != PCMP_SIGNATURE) ||
        (MpTablePtr->TableLength < sizeof(struct PcMpTable)) ) {
        FAILMSG(rgzMPSBadSig);
        return(NULL);
    }

    CheckSum = ComputeCheckSum((PUCHAR)MpTablePtr, MpTablePtr->TableLength);
    if (CheckSum != 0) {
        FAILMSG(rgzMPSBadCheck);
        return(NULL);
    }

    return MpTablePtr;
}

struct PcMpTable *
GetPcMpTable(
    VOID
    )

/*++

Routine Description:
    This routine gets the MP table for a MPS compliant system.
    For a MPS compliant system, either the BIOS builds an MP table, or
    it indicates that the system is one of the default configurations
    defined in the MPS spec. The MP feature information bytes in the BIOS
    system configuration table indicate whether the system is one of the
    default systems, or has a BIOS created MP table. For a default system
    configuration, this routine uses a statically built default table.
    This routine copies the MPS table into private system memory, and
    returns a pointer to this table.

Arguments:
    None.

 Return Value:
     Pointer to the private copy of the MP table that has been copied in
     system memory.

*/
{

    struct FloatPtrStruct *FloatingPtr;
    UCHAR CheckSum;
    struct PcMpTable *MpTablePtr;
    UCHAR MpFeatureInfoByte1 = 0, MpFeatureInfoByte2 = 0;
    PUCHAR TempPtr;
    PHYSICAL_ADDRESS physicalAddress;
    ULONG tableLength;

    DEBUG_MSG("GetMpTable\n");

    FloatingPtr = PcMpGetFloatingPtr();

    if (FloatingPtr == NULL) {
        FAILMSG (rgzNoMPTable);
        return(NULL);
    }

    //  The floating structure has 2 MP feature information bytes.

    MpFeatureInfoByte1 = FloatingPtr->MpFeatureInfoByte1;
    MpFeatureInfoByte2 = FloatingPtr->MpFeatureInfoByte2;

    // The second MP feature information byte tells us whether the system
    // has an IMCR(Interrupt Mode Control Register). We use this information
    // in the HAL, so we store this information in the OS specific private
    // area.

    if ((MpFeatureInfoByte2 & IMCR_MASK) == 0)
        HalpMpInfoTable.IMCRPresent = 0;
    else
        HalpMpInfoTable.IMCRPresent = 1;

    if (MpFeatureInfoByte1 != 0)  {
        // The system configuration is one of the default
        // configurations defined in the MPS spec. Find out which
        // default configuration it is and get a pointer to the
        // corresponding default table.

        return GetDefaultConfig(MpFeatureInfoByte1);
    }


    // MpFeatureInfoByte1 == 0. This means that the BIOS has built a MP
    // config table for us. The address of the OEM created table is in
    // the MPS floating structure.

    physicalAddress = HalpPtrToPhysicalAddress( FloatingPtr->TablePtr );
    TempPtr =  HalpMapPhysicalMemory64(physicalAddress,2);

    HalpUnmapVirtualAddress(FloatingPtr, 1);
    
    if (TempPtr == NULL) {
        DEBUG_MSG ("HAL: Cannot map OEM MPS table [1]\n");
        return (NULL);
    }

    MpTablePtr = (struct PcMpTable *)TempPtr;

    // We have a pointer to the MP config table. Check if the table is valid.

    if ((MpTablePtr->Signature != PCMP_SIGNATURE) ||
    (MpTablePtr->TableLength < sizeof(struct PcMpTable)) ) {
        FAILMSG (rgzMPSBadSig);
        return(NULL);
    }

    //
    // Now re-map it, making sure that we have mapped enough pages.
    //

    tableLength = MpTablePtr->TableLength + MpTablePtr->ExtTableLength;

    HalpUnmapVirtualAddress(TempPtr, 2);

    MpTablePtr = (struct PcMpTable *)HalpMapPhysicalMemory64(
                    physicalAddress, 
                    (ULONG)(((physicalAddress.QuadPart + tableLength) / PAGE_SIZE) - 
                        (physicalAddress.QuadPart / PAGE_SIZE) + 1)
                    );
    
    if (MpTablePtr == NULL) {
        DEBUG_MSG ("HAL: Cannot map OEM MPS table [2]\n");
        return (NULL);
    }

    CheckSum = ComputeCheckSum((PUCHAR)MpTablePtr, MpTablePtr->TableLength);
    if (CheckSum != 0) {
        FAILMSG (rgzMPSBadCheck);
        return(NULL);
    }

    return MpTablePtr;
}


struct PcMpTable *
GetDefaultConfig (
    IN ULONG Config
    )
{
    Config -= 1;

    if (Config >= NUM_DEFAULT_CONFIGS)  {
        FAILMSG (rgzBadDefault);
        return NULL;
    }

#ifdef DEBUGGING
    HalDisplayString ("HALMPS: Using default table\n");
#endif

#ifdef SETUP
    return((struct PcMpTable *) DEFAULT_MPS_INDICATOR);
#else
    return PcMpDefaultTablePtrs[Config];
#endif  // SETUP
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpsyssup.c ===
/*++

Module Name:

    mpsyssup.c

Abstract:

    This file contains APIC-related funtions that are
    specific to halmps.  The functions that can be
    shared with the APIC version of the ACPI HAL are
    still in mpsys.c.

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode only.

Revision History:

    Jake Oshins - 10-20-97 - split off from mpsys.c
                             

*/

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"

VOID
HalpMpsPCIPhysicalWorkaround (
    VOID
    );

NTSTATUS
HalpSearchBusForVector(
    IN  INTERFACE_TYPE  BusType,
    IN  ULONG           BusNo,
    IN  ULONG           Vector,
    IN OUT PBUS_HANDLER *BusHandler
    );

BOOLEAN
HalpMPSBusId2NtBusId (
    IN UCHAR                ApicBusId,
    OUT PPCMPBUSTRANS       *ppBusType,
    OUT PULONG              BusNo
    );

//
// Packed, somewhat arbitrary representation of an interrupt source.
// This array, when taken with the next one, allows you to figure
// out which bus-relative source maps to which APIC-relative source.
// 
ULONG       HalpSourceIrqIds[MAX_SOURCE_IRQS];

//
//  Linear mapping of interrupt input on array of I/O APICs, where all the
//  APICs have an ordering.  (Used as index into HalpIntiInfo.  Paired with
//  HalpSourceIrqIds.)
//
USHORT        HalpSourceIrqMapping[MAX_SOURCE_IRQS];

//
// HalpLastEnumeratedActualProcessor - Number of the last processor
// enumerated and returned to the OS.   (Reset on resume from hibernate).
//
// This variable is incremented independently of the processor number
// NT uses.
//

UCHAR         HalpLastEnumeratedActualProcessor = 0;

extern USHORT HalpEisaIrqMask;
extern USHORT HalpEisaIrqIgnore;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitIntiInfo)
#pragma alloc_text(INIT,HalpMpsPCIPhysicalWorkaround)
#pragma alloc_text(PAGELK,HalpGetApicInterruptDesc)
#pragma alloc_text(PAGELK, HalpEnableLocalNmiSources)
#pragma alloc_text(PAGE, HalpMPSBusId2NtBusId)
#pragma alloc_text(PAGE, HalpFindIdeBus)
#pragma alloc_text(PAGE, HalpSearchBusForVector)
#pragma alloc_text(PAGE, HalpInterruptsDescribedByMpsTable)
#pragma alloc_text(PAGE, HalpPci2MpsBusNumber)
#endif

VOID
HalpInitIntiInfo (
    VOID
    )
/*++

Routine Description:

    This function is called at initialization time before any interrupts
    are connected.  It reads the PC+MP Inti table and builds internal
    information needed to route each Inti.

Return Value:

    The following structures are filled in:
        HalpIntiInfo
        HalpSourceIrqIds
        HalpSourceIrqMapping
        HalpISAIqpToVector

--*/
{
    ULONG           ApicNo, BusNo, InterruptInput, IdIndex;
    PPCMPINTI       pInti;
    PPCMPIOAPIC     pIoApic;
    PPCMPPROCESSOR  pProc;
    PPCMPBUSTRANS   pBusType;
    ULONG           i, id;
    UCHAR           Level, Polarity;

    //
    // Clear IntiInfo table
    //

    for (i=0; i < MAX_INTI; i++) {
        HalpIntiInfo[i].Type = 0xf;
        HalpIntiInfo[i].Level = 0;
        HalpIntiInfo[i].Polarity = 0;
    }

    //
    // Check for MPS bios work-around
    //

    HalpMpsPCIPhysicalWorkaround();

    //
    // Initialize HalpMaxApicInti table
    //

    for (pInti = HalpMpInfoTable.IntiEntryPtr;
         pInti->EntryType == ENTRY_INTI;
         pInti++) {


        //
        // Which IoApic number is this?
        //

        for (pIoApic = HalpMpInfoTable.IoApicEntryPtr, ApicNo = 0;
             pIoApic->EntryType == ENTRY_IOAPIC;
             pIoApic++, ApicNo++) {

            if ( (pInti->IoApicId == pIoApic->IoApicId) || 
                 (pInti->IoApicId == 0xff) )  {
                break;
            }
        }

        if ( (pInti->IoApicId != pIoApic->IoApicId) &&
                 (pInti->IoApicId != 0xff) )  {
            DBGMSG ("PCMP table corrupt - IoApic not found for Inti\n");
            continue;
        }

        if (!(pIoApic->IoApicFlag & IO_APIC_ENABLED)) {
            DBGMSG ("PCMP IoApic for Inti is disabled\n");
            continue;
        }

        //
        // Make sure we are below the max # of IOApic which
        // are supported
        //

        ASSERT (ApicNo < MAX_IOAPICS);

        //
        // Track Max Inti line per IOApic
        //

        if (pInti->IoApicInti >= HalpMaxApicInti[ApicNo]) {
            HalpMaxApicInti[ApicNo] = pInti->IoApicInti+1;
        }
    }

    //
    // Make sure there aren't more Inti lines then we can support
    //

    InterruptInput = 0;
    for (i=0; i < MAX_IOAPICS; i++) {
        InterruptInput += HalpMaxApicInti[i];
    }
    ASSERT (InterruptInput < MAX_INTI);

    //
    // Look at each Inti and record it's type in it's
    // corresponding array entry
    //

    IdIndex = 0;
    for (pInti = HalpMpInfoTable.IntiEntryPtr;
         pInti->EntryType == ENTRY_INTI;
         pInti++) {

        //
        // Which IoApic number is this?
        //

        for (pIoApic = HalpMpInfoTable.IoApicEntryPtr, ApicNo = 0;
             pIoApic->EntryType == ENTRY_IOAPIC;
             pIoApic++, ApicNo++) {

            if ( (pInti->IoApicId == pIoApic->IoApicId) || 
                 (pInti->IoApicId == 0xff) )  {
                break;
            }
        }

        if (!(pIoApic->IoApicFlag & IO_APIC_ENABLED)) {
            continue;
        }

        //
        // Determine the NT bus this INTI is on
        //

        if (!HalpMPSBusId2NtBusId (pInti->SourceBusId, &pBusType, &BusNo)) {
            DBGMSG ("HAL: Initialize INTI - unkown MPS bus type\n");
            continue;
        }

        //
        // Calulcate InterruptInput value for this APIC Inti
        //

        InterruptInput = pInti->IoApicInti;
        for (i = 0; i < ApicNo; i++) {
            InterruptInput += HalpMaxApicInti[i];
        }

        //
        // Get IntiInfo for this vector.
        //

        Polarity = (UCHAR) pInti->Signal.Polarity;
        Level = HalpInitLevel[pInti->Signal.Level][pBusType->Level];

        //
        // Verify Level & Polarity mappings made sense
        //

#if DBG
        if (!(pBusType->NtType == MicroChannel  ||  !(Level & CFG_ERROR))) {

            DbgPrint("\n\n\n  MPS BIOS problem!  WHQL, fail this machine!\n");
            DbgPrint("Intin:  BusType %s  BusNo: %x\n", 
                     pBusType->PcMpType, 
                     pInti->SourceBusId);
            DbgPrint("  SrcBusIRQ: %x   EL: %x  PO: %x\n",
                     pInti->SourceBusIrq,
                     pInti->Signal.Level,
                     pInti->Signal.Polarity);

            if (pBusType->NtType == PCIBus) {

                DbgPrint("This entry is for PCI device %x on bus %x, PIN %x\n",
                         pInti->SourceBusIrq >> 2,
                         pInti->SourceBusId,
                         (pInti->SourceBusIrq & 0x3) + 1);
            }
        }
#endif        
        Level &= ~CFG_ERROR;

        //
        // See if this inti should go into the mask of inti that
        // we won't assign to ISA devices.
        //
        // The last part of the test here guarantees that we are not
        // picky about any devices that are in the HalpEisaIrqIgnore
        // mask.  This keep the mouse (and possibly other weird devices
        // alive.)
        //

        if ((pBusType->NtType == Isa) && 
            ((Level & ~CFG_MUST_BE) == CFG_LEVEL) &&
            !((1 << pInti->SourceBusIrq) & HalpEisaIrqIgnore)) {
            
            HalpPciIrqMask |= (1 << pInti->SourceBusIrq);
        }

        if ((pBusType->NtType == Eisa) && 
            ((Level & ~CFG_MUST_BE) == CFG_LEVEL)) {
            
            HalpEisaIrqMask |= (1 << pInti->SourceBusIrq);

            if (HalpBusType != MACHINE_TYPE_EISA) {

                //
                // The BIOS thinks that this is an EISA 
                // inti.  But we don't think that this
                // is an EISA machine.  So put this on the 
                // list of PCI inti, too.
                //

                HalpPciIrqMask |= (1 << pInti->SourceBusIrq);
            }
        }

#if DBG
        if (HalpIntiInfo[InterruptInput].Type != 0xf) {
            //
            // Multiple irqs are connected to the Inti line.  Make
            // sure Type, Level, and Polarity are all the same.
            //

            ASSERT (HalpIntiInfo[InterruptInput].Type == pInti->IntType);
            ASSERT (HalpIntiInfo[InterruptInput].Level == Level);
            ASSERT (HalpIntiInfo[InterruptInput].Polarity == Polarity);
        }
#endif
        //
        // Remember this Inti's configuration info
        //

        HalpIntiInfo[InterruptInput].Type = pInti->IntType;
        HalpIntiInfo[InterruptInput].Level = Level;
        HalpIntiInfo[InterruptInput].Polarity = Polarity;

        //
        // Get IRQs encoding for translations
        //

        ASSERT (pBusType->NtType < 16);
        ASSERT (BusNo < 256);

        if ( (pBusType->NtType == PCIBus) &&
             (pInti->SourceBusIrq == 0) )  {
            id = BusIrq2Id(pBusType->NtType, BusNo, 0x80);
        }  else  {
            id = BusIrq2Id(pBusType->NtType, BusNo, pInti->SourceBusIrq);
        }

        //
        // Addinti mapping to translation table, do it now
        //

        HalpSourceIrqIds[IdIndex] = id;
        HalpSourceIrqMapping[IdIndex] = (USHORT) InterruptInput;
        IdIndex++;

        //
        // Lots of source IRQs are supported; however, the PC+MP table
        // allows for an aribtrary number even beyond the APIC limit.
        //

        if (IdIndex >= MAX_SOURCE_IRQS) {
            DBGMSG ("MAX_SOURCE_IRQS exceeded\n");
            break;
        }

    }

    //
    // Fill in the boot processors PCMP Apic ID.
    //

    pProc = HalpMpInfoTable.ProcessorEntryPtr;
    for (i=0; i < HalpMpInfoTable.ProcessorCount; i++, pProc++) {
        if (pProc->CpuFlags & BSP_CPU) {
            ((PHALPRCB)KeGetCurrentPrcb()->HalReserved)->PCMPApicID = pProc->LocalApicId;
        }
    }

    //
    // If this is an EISA machine check the ELCR
    //

    if (HalpBusType == MACHINE_TYPE_EISA) {
        HalpCheckELCR ();
    }
}

BOOLEAN
HalpMPSBusId2NtBusId (
    IN UCHAR                MPSBusId,
    OUT PPCMPBUSTRANS       *ppBusType,
    OUT PULONG              BusNo
    )
/*++

Routine Description:

    Lookup MPS Table BusId into PCMPBUSTRANS (NtType) and instance #.

Arguments:

    MPSBusId    - Bus ID # in MPS table
    ppBusType   - Returned pointer to PPCMPBUSTRANS for this bus type
    BusNo       - Returned instance # of given bus

Return Value:

    TRUE if MPSBusId was cross referenced into an NT id.

--*/
{
    PPCMPBUS        pBus, piBus;
    PPCMPBUSTRANS   pBusType;
    NTSTATUS        status;
    UCHAR           parentBusNo;
    BOOLEAN         foundFirstRootBus = FALSE;

    PAGED_CODE();
    
    //
    // What Bus is this?
    //

    for (pBus = HalpMpInfoTable.BusEntryPtr;
         pBus->EntryType == ENTRY_BUS;
         pBus++) {

        if (MPSBusId == pBus->BusId) {
            break;
        }
    }

    if (MPSBusId != pBus->BusId) {
        DBGMSG ("PCMP table corrupt - Bus not found for Inti\n");
        return FALSE;
    }

    //
    // What InterfaceType is this Bus?
    //

    for (pBusType = HalpTypeTranslation;
         pBusType->NtType != MaximumInterfaceType;
         pBusType++) {

        if (pBus->BusType[0] == pBusType->PcMpType[0]  &&
            pBus->BusType[1] == pBusType->PcMpType[1]  &&
            pBus->BusType[2] == pBusType->PcMpType[2]  &&
            pBus->BusType[3] == pBusType->PcMpType[3]  &&
            pBus->BusType[4] == pBusType->PcMpType[4]  &&
            pBus->BusType[5] == pBusType->PcMpType[5]) {
                break;
        }
    }

    //
    // Which instance of this BusType?
    //
    
    if (!pBusType->PhysicalInstance) {
        
        //
        // This algorithm originally just counted the number
        // of busses of this type.  The newer algorithm works
        // around bugs in the MPS tables.  The rules are listed.
        //
        // 1) The first PCI bus of a given type is always bus
        //    number 0.
        //
        // 2) For busses that are secondary root PCI busses, the
        //    bus number count is incremented to equal the MPS bus
        //    number.
        //
        // 3) For busses that are generated by PCI to PCI bridges,
        //    the bus number is incremented by one.
        //
        //    N.B.  Rule #3 implies that if one bus under a bridge
        //          is described, all must be.
        //
    
        for (piBus = HalpMpInfoTable.BusEntryPtr, *BusNo = 0;
             piBus < pBus;
             piBus++) {

            if (pBus->BusType[0] == piBus->BusType[0]  &&
                pBus->BusType[1] == piBus->BusType[1]  &&
                pBus->BusType[2] == piBus->BusType[2]  &&
                pBus->BusType[3] == piBus->BusType[3]  &&
                pBus->BusType[4] == piBus->BusType[4]  &&
                pBus->BusType[5] == piBus->BusType[5]) {
                    
                status = HalpMpsGetParentBus(piBus->BusId, 
                                             &parentBusNo);

                if (NT_SUCCESS(status)) {

                    //
                    // This is a child bus.
                    //

                    *BusNo += 1;

                } else {

                    //
                    // This is a root bus.
                    //

                    if (!foundFirstRootBus) {
                        
                        //
                        // This is the first root bus.
                        // To work around buggy MPS BIOSes, this
                        // root is always numbered 0.
                        //

                        *BusNo = 0;
                        foundFirstRootBus = TRUE;

                    } else {

                        //
                        // This is a secondary root of this type.  Believe 
                        // the MPS tables.
                        //

                        *BusNo = piBus->BusId;
                    }
                }
            }
        }
    } else {
        *BusNo = pBus->BusId;
    }

    if (pBusType->NtType == MaximumInterfaceType) {
        return FALSE;
    }

    *ppBusType = pBusType;
    return TRUE;
}

VOID
HalpMpsPCIPhysicalWorkaround (
    VOID
    )
{
    PPCMPBUS        pBus;
    PPCMPBUSTRANS   pBusType;

    //
    // The MPS specification has a subtle comment that PCI bus IDs are
    // suppose to match their physical PCI bus number.  Many BIOSes don't
    // do this, so unless there's a PCI bus #0 listed in the MPS table
    // assume that the BIOS is broken
    //

    //
    // Find the PCI interface type
    //

    for (pBusType = HalpTypeTranslation;
         pBusType->NtType != MaximumInterfaceType;
         pBusType++) {

        if (pBusType->PcMpType[0] == 'P'  &&
            pBusType->PcMpType[1] == 'C'    &&
            pBusType->PcMpType[2] == 'I'    &&
            pBusType->PcMpType[3] == ' '    &&
            pBusType->PcMpType[4] == ' '    &&
            pBusType->PcMpType[5] == ' '  ) {
                break;
        }
    }

    //
    // Find the bus with ID == 0
    //

    pBus = HalpMpInfoTable.BusEntryPtr;
    while (pBus->EntryType == ENTRY_BUS) {

        if (pBus->BusId == 0) {

            //
            // If it's a PCI bus, assume physical bus IDs
            //

            if (pBus->BusType[0] != 'P' ||
                pBus->BusType[1] != 'C' ||
                pBus->BusType[2] != 'I' ||
                pBus->BusType[3] != ' ' ||
                pBus->BusType[4] != ' ' ||
                pBus->BusType[5] != ' '  ) {

                //
                // Change default behaviour of PCI type
                // from physical to virtual
                //

                pBusType->PhysicalInstance = FALSE;
            }

            break;
        }

        pBus += 1;
    }
}



BOOLEAN
HalpGetApicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PUSHORT PcMpInti
    )
/*++

Routine Description:

    This procedure gets a "Inti" describing the requested interrupt

Arguments:

    BusType - The Bus type as known to the IO subsystem

    BusNumber - The number of the Bus we care for

    BusInterruptLevel - IRQ on the Bus

Return Value:

    TRUE if PcMpInti found; otherwise FALSE.

    PcMpInti - A number that describes the interrupt to the HAL.

--*/
{
    ULONG   i, id;

    if (BusType < 16  &&  BusNumber < 256  &&  BusInterruptLevel < 256) {

        //
        // get unique BusType,BusNumber,BusInterrupt ID
        //

        id = BusIrq2Id(BusType, BusNumber, BusInterruptLevel);

        //
        // Search for ID of Bus Irq mapping, and return the corresponding
        // InterruptLine.
        //

        for (i=0; i < MAX_SOURCE_IRQS; i++) {
            if (HalpSourceIrqIds[i] == id) {
                *PcMpInti = HalpSourceIrqMapping[i];
                return TRUE;
            }
        }
    }

    //
    // Not found or search out of range
    //

    return FALSE;
}

PBUS_HANDLER
HalpFindIdeBus(
    IN  ULONG   Vector
    )
{
    PBUS_HANDLER    ideBus;
    NTSTATUS        status;
    ULONG           pciNo;

    PAGED_CODE();
    
    status = HalpSearchBusForVector(Isa, 0, Vector, &ideBus);

    if (NT_SUCCESS(status)) {
        return ideBus;
    }

    status = HalpSearchBusForVector(Eisa, 0, Vector, &ideBus);

    if (NT_SUCCESS(status)) {
        return ideBus;
    }

    status = HalpSearchBusForVector(MicroChannel, 0, Vector, &ideBus);

    if (NT_SUCCESS(status)) {
        return ideBus;
    }

    for (pciNo = 0; pciNo <= 255; pciNo++) {
    
        status = HalpSearchBusForVector(PCIBus, pciNo, Vector, &ideBus);
    
        if (NT_SUCCESS(status)) {
            return ideBus;
        }

        if (status == STATUS_NO_SUCH_DEVICE) {
            break;
        }
    }

    return NULL;
}

NTSTATUS
HalpSearchBusForVector(
    IN  INTERFACE_TYPE  BusType,
    IN  ULONG           BusNo,
    IN  ULONG           Vector,
    IN OUT PBUS_HANDLER *BusHandler
    )
{
    PBUS_HANDLER    ideBus;
    NTSTATUS        status;
    BOOLEAN         found;
    USHORT          inti;

    PAGED_CODE();
    
    ideBus = HaliHandlerForBus(BusType, BusNo);
    
    if (!ideBus) {
        return STATUS_NO_SUCH_DEVICE;
    }
    
    found = HalpGetApicInterruptDesc(BusType,
                                     BusNo,
                                     Vector,
                                     &inti);

    if (!found) {
        return STATUS_NOT_FOUND;
    }

    *BusHandler = ideBus;

    return STATUS_SUCCESS;
}

ULONG
HalpGetIoApicId(
    ULONG   ApicNo
    )
{
    return (ULONG) HalpMpInfoTable.IoApicEntryPtr[ApicNo].IoApicId;
}

VOID
HalpMarkProcessorStarted(
    ULONG   ApicID,
    ULONG   NtNumber
    )
{
    return;
}

ULONG
HalpInti2BusInterruptLevel(
    ULONG   Inti
    )
/*++

Routine Description:

    This procedure does a lookup to find a bus-relative
    interrupt vector associated with an Inti.
    
    Note:  If two different devices are sharing an interrupt,
    this function will return the answer for the first one
    that it finds.  Fortunately, the only devices that use
    their bus-relative vectors for anything (ISA devices)
    can't share interrupts.

Arguments:

    Inti - Interrupt Input on an I/O APIC

Return Value:

    A bus-relative interrupt vector.

--*/
{
    ULONG   i;

    for (i=0; i < MAX_SOURCE_IRQS; i++) {
        
        if (HalpSourceIrqMapping[i] == Inti) {
            
            return Id2BusIrq(HalpSourceIrqIds[i]);
        }
    }
    
    //
    // We should never fail to find a mapping.
    //
    
#if DBG
    KeBugCheckEx(HAL_INITIALIZATION_FAILED, 5, Inti, 0, 0);
#endif

    return 0;
}

NTSTATUS
HalpGetNextProcessorApicId(
    IN ULONG         PrcbProcessorNumber,
    IN OUT UCHAR    *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID of a non-started processor,
    which will be started by HalpStartProcessor.

Arguments:

    PrcbProcessorNumber - The logical processor number that will
        be associated with this APIC ID.
        
    ApicId - pointer to a value to fill in with the APIC ID.        

Return Value:

    status

--*/
{
    PPCMPPROCESSOR ApPtr;
    ULONG ProcessorNumber;

    if (PrcbProcessorNumber == 0) {

        //
        // I don't believe anyone ever askes for 0 and I plan not
        // to handle it.  peterj 12/5/00.
        //

        KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                     6,
                     HalpLastEnumeratedActualProcessor,
                     0,
                     0);
    }

    if (HalpLastEnumeratedActualProcessor >= HalpMpInfoTable.ProcessorCount) {

        //
        // Sorry, no more processors.
        //

        return STATUS_NOT_FOUND;
    }

    ++HalpLastEnumeratedActualProcessor;
    ProcessorNumber = HalpLastEnumeratedActualProcessor;

    //
    //  Get the MP Table entry for this processor
    //

    ApPtr = HalpMpInfoTable.ProcessorEntryPtr;


#if 0
    if (ProcessorNumber == 0) {

        //
        // Return the ID of the boot processor (BSP).
        //

        while (ApPtr->EntryType == ENTRY_PROCESSOR) {
            if ((ApPtr->CpuFlags & CPU_ENABLED) &&
                (ApPtr->CpuFlags & BSP_CPU)) {
                *ApicId = (UCHAR)ApPtr->LocalApicId;
                return STATUS_SUCCESS;
            }
            ++ApPtr;
        }

        //
        // Boot processor not found.
        //

        return STATUS_NOT_FOUND;
    }
#endif

    //
    // Skip 'ProcessorNumber' enabled processors.  The next enabled
    // processor entry (after those) will be the "next" processor.
    //
    // Note: The BSP may not be amongst the first 'ProcessorNumber'
    // processors so we must skip 'ProcessorNumber' - 1, and check
    // for the and skip the BSP.
    //

    --ProcessorNumber;

    while ((ProcessorNumber) && (ApPtr->EntryType == ENTRY_PROCESSOR)) {
        if ((ApPtr->CpuFlags & CPU_ENABLED) &&
            !(ApPtr->CpuFlags & BSP_CPU)) {

            //
            // Account for this entry (we have already started it) if this
            // processor is enabled and not the BSP (we decremented for the
            // BSP before entering the loop).
            //
            --ProcessorNumber;
        }
        ++ApPtr;
    }

    //
    // Find the first remaining enabled processor.
    //

    while(ApPtr->EntryType == ENTRY_PROCESSOR) {
        if ((ApPtr->CpuFlags & CPU_ENABLED) &&
           !(ApPtr->CpuFlags & BSP_CPU)) {
            *ApicId = (UCHAR)ApPtr->LocalApicId;
            return STATUS_SUCCESS;
        }
        ++ApPtr;
    }

    //
    // We did not find another processor.
    //

    return STATUS_NOT_FOUND;
}

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID for a given processor.
    It is intended this routine be able to produce the same
    APIC ID order as HalpGetNextProcessorApicId.

    Note:  This won't actually work in the presence of skipped
    procesors.

Arguments:

    Processor - The logical processor number that is
        associated with this APIC ID.

    ApicId - pointer to a value to fill in with the APIC ID.

Return Value:

    status

--*/
{
    PPCMPPROCESSOR ApPtr;

    //
    //  Get the MP Table entry for this processor
    //

    ApPtr = HalpMpInfoTable.ProcessorEntryPtr;

    if (Processor == 0) {

        //
        // Return the ID of the boot processor (BSP).
        //

        while (ApPtr->EntryType == ENTRY_PROCESSOR) {
            if ((ApPtr->CpuFlags & CPU_ENABLED) &&
                (ApPtr->CpuFlags & BSP_CPU)) {
                *ApicId = (UCHAR)ApPtr->LocalApicId;
                return STATUS_SUCCESS;
            }
            ++ApPtr;
        }

        //
        // Boot processor not found.
        //

        return STATUS_NOT_FOUND;
    }

    for ( ; TRUE ; ApPtr++) {

        if (ApPtr->EntryType != ENTRY_PROCESSOR) {

            //
            // Out of processor entries, fail.
            //

            return STATUS_NOT_FOUND;
        }

        if (ApPtr->CpuFlags & BSP_CPU) {

            //
            // BSP is processor 0 and is not considered in the
            // search for processors other than 0.
            //

            continue;
        }

        if (ApPtr->CpuFlags & CPU_ENABLED) {

            //
            // Count this processor.
            //

            Processor--;

            if (Processor == 0) {
                break;
            }
        }
    }

    ASSERT(ApPtr->EntryType == ENTRY_PROCESSOR);

    *ApicId = ApPtr->LocalApicId;
    return STATUS_SUCCESS;
}

BOOLEAN
HalpInterruptsDescribedByMpsTable(
    IN UCHAR MpsBusNumber
    )
{
    PPCMPINTI busInterrupt;

    PAGED_CODE();

    for (busInterrupt = HalpMpInfoTable.IntiEntryPtr;
         busInterrupt->EntryType == ENTRY_INTI;
         busInterrupt++) {

        //
        // The MPS spec requires that, if one interrupt
        // on a bus is described, all interrupts on that
        // bus must be described.  So finding one match
        // is enough.
        //

        if (busInterrupt->SourceBusId == MpsBusNumber) {

            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
HalpPci2MpsBusNumber(
    IN UCHAR PciBusNumber,
    OUT UCHAR *MpsBusNumber
    )
{
    PPCMPBUSTRANS busType;
    ULONG mpsBusNumber = 0;
    ULONG busNumber;
    
    PAGED_CODE();
    
    for (mpsBusNumber = 0;
         mpsBusNumber < 0x100;
         mpsBusNumber++) {

        if (HalpMPSBusId2NtBusId((UCHAR)mpsBusNumber,
                                 &busType,
                                 &busNumber)) {

            if ((busType->NtType == PCIBus) &&
                (PciBusNumber == (UCHAR)busNumber)) {
    
                *MpsBusNumber = (UCHAR)mpsBusNumber;
                return STATUS_SUCCESS;
            }
        }
    }
    
    return STATUS_NOT_FOUND;
}

VOID
HalpEnableLocalNmiSources(
    VOID
    )
/*++

Routine Description:

    This routine parses the information from the MP table and 
    enables any NMI sources in the local APIC of the processor
    that it is running on.
    
    Callers of this function must be holding HalpAccountingLock.

Arguments:

Return Value:

--*/
{
    PKPCR       pPCR;
    UCHAR       ThisCpu;
    UCHAR       LocalApicId;
    PPCMPLINTI  pEntry;
    ULONG       NumEntries;

    pPCR = KeGetPcr();
    ThisCpu = pPCR->Prcb->Number;

    //
    //  Enable local processor NMI source
    //

    LocalApicId = ((PHALPRCB)pPCR->Prcb->HalReserved)->PCMPApicID;
    NumEntries = HalpMpInfoTable.LintiCount;

    for (pEntry = HalpMpInfoTable.LintiEntryPtr;
         ((pEntry) && (NumEntries > 0));
        pEntry++, --NumEntries) {

        if ( ( (pEntry->DestLocalApicId == LocalApicId) ||
               (pEntry->DestLocalApicId == 0xff))  &&
             (pEntry->IntType == INT_TYPE_NMI) ) {

            //
            // Found local NMI source, enable it
            //

            if (pEntry->DestLocalApicInti == 0) {
                pLocalApic[LU_INT_VECTOR_0/4] = ( LEVEL_TRIGGERED |
                    ACTIVE_HIGH | DELIVER_NMI | NMI_VECTOR);
            } else {
                pLocalApic[LU_INT_VECTOR_1/4] = ( LEVEL_TRIGGERED |
                    ACTIVE_HIGH | DELIVER_NMI | NMI_VECTOR);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\halnls.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\halnls.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\makefile.inc ===
$(_OBJ_DIR)\i386\hal.def: hal.src
    $(TARGET_CPP) /EP -Di386 $(C_DEFINES) hal.src > $(_OBJ_DIR)\i386\hal.def
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\pcmp_nt.inc ===
;/*
;++
;
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
;
;   Module Name:
;
;       pcmp_nt.inc
;
;   Abstract:
;
;       include file for PC+MP system.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       Ron Mosgrove (Intel) 30-July-1993
;
;--
;

if 0        ; Begin C only code         */

//
// Specific MPS 1.4 stuff
//
#include "pcmp.inc"

//
// Generic NT APIC HAL stuff
//
#include "ntapic.inc"

/*
endif
;
;  Begin assembly part of the definitions
;

include pcmp.inc
include ntapic.inc

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\halp.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\halp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ix8259.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\halx86\i386\ix8259.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixbusdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixbusdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixcmos.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\halx86\i386\ixcmos.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixcmos.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\halx86\i386\ixcmos.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixinfo.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixinfo.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixfirm.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixfirm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixenvirv.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixenvirv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixhwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixhwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixisa.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixisa.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixidle.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\halx86\i386\ixidle.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixisabus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixisabus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixmca.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixmca.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixpcibus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixpcibus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixmcaa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\halx86\i386\ixmcaa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixpcibrd.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixpcibrd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixmovnti.asm ===
;
; Include code from halx86
;

include ..\halx86\i386\ixmovnti.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixnmi.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixnmi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixisasup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixisasup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixpnpdrv.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixpnpdrv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixphwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixphwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixqspin.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "halx86\i386\ixqspin.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixpcisup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixpcisup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixpciint.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixpciint.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixsysbus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixsysbus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixreboot.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixreboot.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixstall.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\halx86\i386\ixstall.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\mpprocst.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halmps\i386\mpprocst.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\pmpcisup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\pmpcisup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixthunk.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixthunk.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\ixusage.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixusage.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spbeep.asm ===
title "Hal Beep"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    spbeep.asm
;
;Abstract:
;
;    HAL routine to make noise.  It needs to synchronize its access to the
;    8254, since we also use the 8254 for the profiling interrupt.
;
;
;Author:
;
;    John Vert (jvert) 31-Jul-1991
;
;Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include i386\spmp.inc

        .list

        extrn   _HalpSystemHardwareLock:DWORD
        extrn   _SpType:BYTE

;
; Defines used to program the i8254 for the speaker.
;

I8254_TIMER_CONTROL_PORT EQU    43h
I8254_TIMER_DATA_PORT    EQU    42h
I8254_TIMER_CLOCK_IN     EQU    1193167
I8254_TIMER_TONE_MAX     EQU    65536
I8254_TIMER_CONTROL_SELECT EQU  0B6h
SPEAKER_CONTROL_PORT     EQU    61h
SPEAKER_OFF_MASK         EQU    0FCh
SPEAKER_ON_MASK          EQU    03h


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "HalMakeBeep"
;++
;
; BOOLEAN
; HalMakeBeep(
;       IN ULONG Frequency
;       )
;
; Routine Description:
;
;     This function sets the frequency of the speaker, causing it to sound a
;     tone.  The tone will sound until the speaker is explicitly turned off,
;     so the driver is responsible for controlling the duration of the tone.
;
;Arguments:
;
;     Frequency - Supplies the frequency of the desired tone.  A frequency of
;                 0 means the speaker should be shut off.
;
;Return Value:
;
;     TRUE  - Operation was successful (frequency within range or zero)
;     FALSE - Operation was unsuccessful (frequency was out of range)
;             Current tone (if any) is unchanged.
;
;--

Frequency equ [ebp + 8]

cPublicProc _HalMakeBeep, 1

        push    ebp                     ; save ebp
        mov     ebp, esp                ;
        push    ebx                     ; save ebx

Hmb10Sp:pushfd                          ; save flags
        cli                             ; disable interrupts

        lea     eax, _HalpSystemHardwareLock
        ACQUIRE_SPINLOCK eax,Hmb99Sp

        cmp     _SpType, SMP_SYSPRO2            ; On SysPro2 do it differently
        je      HalMakeBeepSmp

        ;
        ; Stop the speaker.
        ;

        in       al, SPEAKER_CONTROL_PORT
        jmp      $+2
        and      al, SPEAKER_OFF_MASK
        out      SPEAKER_CONTROL_PORT, al
        jmp      $+2

        ;
        ; Calculate Tone:  Tone = 1.193MHz / Frequency.
        ; N.B.  Tone must fit in 16 bits.
        ;

        mov      ecx, DWORD PTR [Frequency]     ; ecx <- frequency
        or       ecx, ecx                       ; (ecx) == 0?
        je       SHORT Hmb30Sp                  ;     goto Hmb30Sp

        mov      eax, I8254_TIMER_CLOCK_IN      ; eax <- 1.193MHz, the clockin
                                                ;    for the speaker tone
        sub      edx, edx                       ; edx <- zero
        div      ecx                            ; eax <- 1.193MHz / frequency
        cmp      eax, I8254_TIMER_TONE_MAX      ; (eax) < 2**16?
        jb       SHORT Hmb20Sp                  ;     goto Hmb20Sp

        ;
        ; Invalid frequency.  Return FALSE.
        ;

        sub      al, al
        jmp      SHORT Hmb40Sp
Hmb20Sp:
        ;
        ; Program the 8254 with the calculated tone.
        ;

        push     eax                             ; save Tone
        mov      al, I8254_TIMER_CONTROL_SELECT
        out      I8254_TIMER_CONTROL_PORT, al    ; select timer control register
        jmp      $+2

        pop      eax                             ; restore Tone
        out      I8254_TIMER_DATA_PORT, al       ; program 8254 with Tone lsb
        jmp      $+2
        mov      al, ah
        out      I8254_TIMER_DATA_PORT, al       ; program 8254 with Tone msb
        jmp      $+2

        ;
        ; Turn the speaker on.
        ;

        in       al, SPEAKER_CONTROL_PORT
        jmp      $+2
        or       al, SPEAKER_ON_MASK
        out      SPEAKER_CONTROL_PORT, al
        jmp      $+2

Hmb30Sp:
        ;
        ; Return TRUE.
        ;

        mov      al, 1

Hmb40Sp:
        lea     ebx, _HalpSystemHardwareLock
        RELEASE_SPINLOCK ebx

        popfd
        pop    ebx                     ; restore ebx
        pop    ebp                     ; restore ebp
        stdRET    _HalMakeBeep

Hmb99Sp:popfd
        SPIN_ON_SPINLOCK        eax,<Hmb10Sp>


HalMakeBeepSmp:
;     A BELIZE/PHOENIX machine MUST always enable and disable the beep via
;     CPU 0 regardless of the originating CPU.  This is done through indexed
;     IO.
;
;     Note the indexed IO is serialized with the 8254 spinlock


        ;
        ; Stop the speaker.
        ;

        INDEXED_IO_READ 0,SPEAKER_CONTROL_PORT
        and      al, SPEAKER_OFF_MASK

        INDEXED_IO_WRITE 0,SPEAKER_CONTROL_PORT,al

        ;
        ; Calculate Tone:  Tone = 1.193MHz / Frequency.
        ; N.B.  Tone must fit in 16 bits.
        ;

        mov      ecx, DWORD PTR [Frequency]     ; ecx <- frequency
        or       ecx, ecx                       ; (ecx) == 0?
        je       Hmb30Sp                        ;     goto Hmb30

        mov      eax, I8254_TIMER_CLOCK_IN      ; eax <- 1.193MHz, the clockin
                                                ;    for the speaker tone
        sub      edx, edx                       ; edx <- zero
        div      ecx                            ; eax <- 1.193MHz / frequency
        cmp      eax, I8254_TIMER_TONE_MAX      ; (eax) < 2**16?
        jb       SHORT Hmb20                    ;     goto Hmb20

        ;
        ; Invalid frequency.  Return FALSE.
        ;

        sub      al, al
        jmp      Hmb40Sp
Hmb20:
        ;
        ; Program the 8254 with the calculated tone.
        ;

        push     eax                             ; save Tone
        mov      al, I8254_TIMER_CONTROL_SELECT

        INDEXED_IO_WRITE 0,I8254_TIMER_CONTROL_PORT,al

        pop      eax                             ; restore Tone

        INDEXED_IO_WRITE 0,I8254_TIMER_DATA_PORT,al
        mov      al, ah

        INDEXED_IO_WRITE 0,I8254_TIMER_DATA_PORT,al

        ;
        ; Turn the speaker on.
        ;

        INDEXED_IO_READ 0,SPEAKER_CONTROL_PORT
        or       al, SPEAKER_ON_MASK

        INDEXED_IO_WRITE 0,SPEAKER_CONTROL_PORT,al
        jmp      Hmb30Sp

stdENDP _HalMakeBeep
_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\pcip.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\pcip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spacer.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1993  ACER America Corporation

Module Name:

    acer.h

Abstract:

    This header file defines the unique interfaces, defines and structures
    for the ACER product line

Revision History:
    1.0b    - plm initial release
    1.1b    - acer.c: halpacereisa: handle scrabled eisa data gracefully.

--*/

#define ACER_HAL_VERSION_NUMBER   "Acer HAL Version 1.1b for October Windows NT Beta.\n"


/* ACER Special I/O Port defintions
 *  I/O Port Address   0xcc4h
 *			|
 *			0: cpu0 & cpu1
 *			c: cpu2 & cpu3
 *
 * bits < 7 6 5 4 3 2 1 0 > (WRITE-ONLY)
 *	  0 0 |	0 0 | 0	|
 *	      |	    |	BIOS Shadow Control
 *	      |	    |	0: ROM BIOS
 *	      |	    |	1: RAM BIOS
 *	      |	    |
 *	      |	    |
 *	      |	    Write-Back Cache Control
 *	      |	    0: write-thru ( write-back disabled)
 *	      |	    1: write-back enabled
 *	      |
 *	      15Mb to 16Mb Memory Setup
 *	      0: Ram
 *	      1: EISA
 *
 */


// where do i find the CSR which controls the write-back enabling?
#define	ACER_PORT_CPU01	 0xcc4	 // write only - setup reg. cpu 0,1
#define	ACER_PORT_CPU23	 0xccc4	 // write onlY - setup reg. cpu 2,3

#define	WRITE_BALLOC_ON  0x04	 // bit<2> - enable write-back cache bit
#define WRITE_BALLOC_OFF 0x00	 // bit<2> - disable write-back cache bit

/* ACER RT/CMOS contents
 *
 * index 35h bit<1>: 15Mb to 16Mb Memory Setup
 *		 0: EISA
 *		 1: Ram
 *	     all other bits RESERVED
 *
 * index 39h bit<0>: BIOS Shadow Control
 *		 0: ROM BIOS
 *		 1: RAM BIOS
 *	     all other bits RESERVED
 *
 */

// RT/CMOS indexes where special Acer machine config info is kept
//  where is the information kept that tells me if bios shadowing is eabled?
#define ACER_SHADOW_IDX  0x39	// RT/CMOS index for shadow bios control

#define RAM_ROM_MASK	 0x01	// bit<0>, 0:RAM BIOS 1:ROM BIOS

// where is the information kept that tells me if 15M-16M is EISA or RAM?
#define ACER_15M_16M_IDX 0x35	// RT/CMOS index for 15Mb-16Mb mem cntrl

#define	DRAM_EISA_MASK	 0x02	// bit<1>, 0:EISA 1:RAM

// EISA ID base addresses for cpu0
#define ACER_CPU0_EISA_ID0      0x0c80  /* 1 digit + part of digit 2 */
#define ACER_CPU0_EISA_ID1      0x0c81  /* rest of digit 2 + digit 3 */
#define ACER_CPU0_EISA_ID2      0x0c82  /* msw id                    */
#define ACER_CPU0_EISA_ID3      0x0c83  /* msw id                    */

// ACER EISA ID's
#define ACER_ID0                0x04    /* acr32xx */
#define ACER_ID1                0x72
#define ACER_ID2                0x32

// ALTOS EISA ID's
#define ALTOS_ID0               0x04    /* acs32xx */
#define ALTOS_ID1               0x73
#define ALTOS_ID2               0x32

// ICL EISA ID's
#define ICL_ID0                 0x24    /* icl00xx */
#define ICL_ID1                 0x6c
#define ICL_ID2                 0x00


// EISA IDs of ACER/ALTOS machines which support a write-back secondary cache
#define ACER_EISA_ID_WB_CPU0	0x61

// EISA IDs of ICL machine (acer oem) which supports write-back scndry cache
// NOTE: THESE IDS ARE STILL TBD!!!
#define ICL_EISA_ID_WB_CPU0	0x61

// EISA constants
#define  MAX_IRQS_PER_EISABUS	16  // how many irq to search for
#define  MAX_EISA_SLOTS 	16  // number of eisa slots

// magic number for kefindconfigurationentry
//#define  EISA_DATA_OFFSET	24  // offset to data portion of eisa pointer

// cpu0's i/o address space for cpu1's pic's
//
//  NOTE: These defines MUST MATCH EXACTLY the equ's found in spirql.asm
//
#define CPU1_PIC1_PORT0		0xc024
#define CPU1_PIC1_PORT1 	0xc0a4
#define CPU1_PIC2_PORT0		0xc025
#define CPU1_PIC2_PORT1		0xc0a5

#define CPU0_PIC1_PORT0		0x020
#define CPU0_PIC1_PORT1 	0x0a0

// cpu0's eisa level/edge register
#define EISA_LEVEL_EDGE_PIC1	0x04d0
#define EISA_LEVEL_EDGE_PIC2	0x04d1

#define SET_TO_EDGE		((UCHAR) 0x0000)
#define SET_TO_LEVEL		((UCHAR) -1)

// eisa level/edge register bit which MUST BE edges
#define EISA_LEVEL_EDGE_PIC1_INIT   0xb8
#define EISA_LEVEL_EDGE_PIC2_INIT   0xde

// eisa 8259
#define READ_IRR    0x0a
#define READ_ISR    0x0b

// a safe eisa i/o location that can be read to force any caches
// to flush any pending i/o writes.  This just happens to be
// the eisa manufacturer i.d. location
#define EISA_FLUSH_ADDR 	0x0c80

// This define MUST EXACTLY MATCH asm equ located in file spmp.inc
#define  SMP_ACER		 3

#define MAX_ACER_CPUS	4	// maximum number of cpus a acer can hold

//
//  acer_irq_distribution callback data structure
//
typedef struct _ACER_IRQ_DISTRIBUTION {

    BOOLEAN distribte_irqs;    // shall i try to distribute irqs across cpus

    // cpu x pics can handle level irqs?
    BOOLEAN px_set_to_level_irqs[ MAX_ACER_CPUS ];

    // number of irqs which have been assigned, used for load balancing
    SHORT   px_numb_irqs_assigned[ MAX_ACER_CPUS ];

    // only a certain number of irqs per pic pair can handle level triggerring
    BOOLEAN eisa_level_compatable[ MAX_IRQS_PER_EISABUS ];

} ACER_IRQ_DISTRIBUTION, *PACER_IRQ_DISTRIBUTION;

// default number of irq's assinged
#define ACER_IRQS_ASSIGED_CPU0	1	// stay away from 0 for init case
#define ACER_IRQS_ASSIGED_CPU1	0
#define ACER_IRQS_ASSIGED_CPU2	0
#define ACER_IRQS_ASSIGED_CPU3	0


// what irqs can be level distriubted?
#define ACER_DISTRIBUTE_LEVEL_IRQ0   FALSE
#define ACER_DISTRIBUTE_LEVEL_IRQ1   FALSE
#define ACER_DISTRIBUTE_LEVEL_IRQ2   FALSE
#define ACER_DISTRIBUTE_LEVEL_IRQ3   TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ4   TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ5   TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ6   FALSE
#define ACER_DISTRIBUTE_LEVEL_IRQ7   TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ8   FALSE
#define ACER_DISTRIBUTE_LEVEL_IRQ9   TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ10  TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ11  TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ12  TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ13  FALSE
#define ACER_DISTRIBUTE_LEVEL_IRQ14  TRUE
#define ACER_DISTRIBUTE_LEVEL_IRQ15  TRUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spacer.c ===
/*++

Copyright (c) 1993  ACER America Corporation

Module Name:

    acer.c

Abstract:

    ACER Write-back Secondary Cache Control c code.

    This module implements the code which detects and enables the
    secondary write-back cache on ACER products (ICL also).

Environment:

    Kernel mode only.

--*/

#include "halp.h"
#include "spacer.h"             // i/o addresses & bit definitions


ULONG HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );


VOID HalpAcerInitializeCache ( VOID );		// externally used
BOOLEAN has_write_back_cache( VOID );           // local only


// ************************  routines  ****************************

BOOLEAN has_write_back_cache( VOID )
/*++

Routine Description:

    This routine checks to see if this machine supports a secondary
    write-back cache.

    This routine checks if the machine is an ACER, ALTOS, or ICL product.

      eisa id:        acr32xx    - acer  product
      eisa id:        acs32xx    - altos product
      eisa id:        icl00xx    - icl   product

    The only thing that tells us whether or not the CPU has a secondary
    write-back cache is the least significant byte of the EISA id.

        xx = 61h for cpu0 indicates the presence of a write-back cache


Arguments:

    None

Return Value:

    TRUE  machine supports a secondary write-back cache.
    FALSE machine is not known to support a write-back cache.

--*/

{
    UCHAR id0, id1, id2, id3;

    // grab cpu0's eisa id information
    id0 = READ_PORT_UCHAR( (PUCHAR) ACER_CPU0_EISA_ID0 );
    id1 = READ_PORT_UCHAR( (PUCHAR) ACER_CPU0_EISA_ID1 );
    id2 = READ_PORT_UCHAR( (PUCHAR) ACER_CPU0_EISA_ID2 );


    // are we a acer or altos machine?
    if ( (id0 == (UCHAR) ACER_ID0  &&
	  id1 == (UCHAR) ACER_ID1  &&
	  id2 == (UCHAR) ACER_ID2    ) ||
	 (id0 == (UCHAR) ALTOS_ID0 &&
	  id1 == (UCHAR) ALTOS_ID1 &&
	  id2 == (UCHAR) ALTOS_ID2   )	 ) {

        // check the lsw id cpu to see if it has a write back cache
        // All acer/altos/icl machines can only have 1 cpu type, so if the
        // first cpu supports a write-back cache then all of them do.
	id3 = READ_PORT_UCHAR( (PUCHAR) ACER_CPU0_EISA_ID3 );

	if ( id3 == (UCHAR) ACER_EISA_ID_WB_CPU0 )
	    return TRUE;   // gotcha

    }


    // are we an icl mx machine?
    if ( (id0 == (UCHAR) ICL_ID0 &&
	  id1 == (UCHAR) ICL_ID1 &&
	  id2 == (UCHAR) ICL_ID2   ) ) {

        // check the lsw id cpu to see if it has a write back cache
        // All acer/altos/icl machines can only have 1 cpu type, so if the
        // first cpu supports a write-back cache then all of them do.
	id3 = READ_PORT_UCHAR( (PUCHAR) ACER_CPU0_EISA_ID3 );

	if ( id3 == (UCHAR) ICL_EISA_ID_WB_CPU0 )
	    return TRUE;   // gotcha

    }

    return FALSE;   // when in doubt be safe
}


VOID
HalpAcerInitializeCache (
    VOID
    )
/*++

Routine Description:

    This routine enables the write-back cache available on certain
    ACER product.  If the write-back cache is supported then it enables
    it.

    NOTE:  1) This routine assumes that the caller has provided any required
        synchronization to query the realtime clock information. Or that
        the HAL code which is calling this routine has serialized access.
	   2) For CSR bit definitions see the acer.h file


    You cannot call dbgprint to talk to the debugger since the port is not
    initialized yet.

Arguments:

    None

Return Value:

    None.

SideEffects:

    NMI mask is enabled.

--*/

{

 	UCHAR	shadow_ram_setup;	// tmp var for current shadow stat
 	UCHAR	high_ram_setup;		// tmp var for current ram setup


	// say hello to the outside world
	//HalDisplayString(ACER_HAL_VERSION_NUMBER);
	//HalDisplayString("Acer HAL: Searching for secondary write-back cache\n");


        // check to see if this particular ACER model even has a
	//     write-back cache
	if ( !has_write_back_cache() ) {
	    //HalDisplayString("Acer HAL: No write-back cache found\n");
	    return;
	}


	//  retrieve BIOS setup shadow ram status
	// read in byte, mask off bit 0 - 1-RAM BIOS 0-ROM BIOS
	HalpGetCmosData((ULONG) 0, (ULONG) ACER_SHADOW_IDX,
			(PVOID) &shadow_ram_setup, (ULONG) 1 );


	// Set up shadow_ram_setup:
	//     bit 0 - 1-BIOS Shadow 0=No Shadowing

	shadow_ram_setup &= RAM_ROM_MASK;

	if ( shadow_ram_setup == 0 ) {
	    //HalDisplayString("Acer HAL: NO BIOS RAM Shadowing\n");
 	} else {
	    //HalDisplayString("Acer HAL: BIOS RAM Shadowing\n");
 	}

	//  retrieve BIOS setup 15MB-16MB ram status
	//	mask off bit 1 -
	//	    1-(15MB-16MB) RAM	0-(15MB-16MB) EISA

	HalpGetCmosData((ULONG) 0, (ULONG) ACER_15M_16M_IDX,
			(PVOID) &high_ram_setup, (ULONG) 1 );


	// 15MB-16MB memory setup (high_ram_setup):
	//     bit 5 1=EISA 0=System RAM
	// note: the polarity is opposite from what getcmosdata read

	high_ram_setup &= DRAM_EISA_MASK;	// just grab bit 1
	high_ram_setup ^= DRAM_EISA_MASK;	// invert polarity
	high_ram_setup <<= 4;			// place at bit<4>

	if ( high_ram_setup == 0) {
	    //HalDisplayString("Acer HAL: 15Mb to 16Mb Allocated to System RAM\n");
 	} else {
	    //HalDisplayString("Acer HAL: 15Mb to 16Mb Allocated to I/O Space\n");
 	}

	// Enable write-back secondary cache on cpus 0 & 1
	//  by setting bit<2>
	WRITE_PORT_UCHAR( (PUCHAR) ACER_PORT_CPU01,
	    (UCHAR) (WRITE_BALLOC_ON | shadow_ram_setup | high_ram_setup));


	// always set write-back secondary cache on cpus 2 & 3
	//   even if system does not have cpus 2 & 3
	WRITE_PORT_UCHAR( (PUCHAR) ACER_PORT_CPU23,
	    (UCHAR) (WRITE_BALLOC_ON | shadow_ram_setup | high_ram_setup));

	// flush the last pending i/o write by reading a safe io location
	READ_PORT_UCHAR( (PUCHAR) EISA_FLUSH_ADDR );

	// that's all folks
	//HalDisplayString("Acer HAL: Write-back cache enabled!\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spdetect.asm ===
;++
;
; Copyright (c) 1991  Microsoft Corporation
;
; Module Name:
;
;     spdetect.asm
;
; Abstract:
;
;     This modules detects a SystemPro or compatible.  It is INCLUDED
;     by SPIPI and other binaries whom need to know how to detect a
;     SystemPro type MP machine (ie, setup).  It must assemble more or
;     less standalone and run in protect mode.
;
; Author:
;
;     Ken Reneris (kenr) 13-Jan-1992
;
; Revision History:
;
;--

include halsp\i386\spmp.inc
include callconv.inc                    ; calling convention macros


_TEXT   SEGMENT  DWORD PUBLIC 'DATA'


; spSystemType: SystemType is read from 0c80-0c83h.
;   0c80-0c81: 0e11:    Compressed CPQ (5 bit encoding).
;   0c82:               System Board type.
;   0c83:               System Board revision level.

spSystemCpuTable        dd  0e1101h         ; CPQ01xx 386 ASP
                        dd  0e1111h         ; CPQ11xx 486 ASP
                        dd  0e1150h         ; CPQ50xx plug in processor
                        dd  0e1159h         ; CPQ59xx plug in processor
                        dd  0e115bh         ; CPQffxx plug in processor
                        dd  0e1115h         ; CPQ15xx       (smp version)
                        dd  0e1152h         ; CPQ15xx       (smp version)
                        dd  0e1108h         ; CPQ15xx
                        dd  0592a0h         ; ALRa0xx PowerPro
                        dd  0592b0h         ; ALRb0xx PowerPro plug in processor
                        dd  047232h         ; Acer SP clone (4p version)
                        dd  246c00h         ; ICL MX
                        dd  246c02h         ; ICL (acer 700xx)
                        dd  352310h         ; Micronycs MPro motherboard
                        dd  352311h         ; Micronycs MPro
                        dd  0592a1h         ; ALRa1xx PowerPro (DX2-66 mobo)
                        dd  0592a2h         ; ALRa2xx PowerPro (reserved mobos)
                        dd  0592b1h         ; ALRb1xx PowerPro (reserved p2's)
                        dd  4dc901h         ; Siemens Nixdorf PCE-4T/33
                        dd  4dc950h         ; Siemens Nixdorf PCE-4T/33
                        dd  047219h         ; AcerFrame 700
                        dd  047232h         ; AcerFrame 3000MP560
                        dd  0h
CPUTABLE_SIZE           equ ($-spSystemCpuTable)/4

; Types match up to CpuTable.
spSystemTypeTable       db  SMP_SYSPRO1     ; CPQ01xx 386 ASP
                        db  SMP_SYSPRO1     ; CPQ11xx 486 ASP
                        db  SMP_SYSPRO1     ; CPQ50xx plug in processor
                        db  SMP_SYSPRO1     ; CPQ59xx plug in processor
                        db  SMP_SYSPRO1     ; CPQffxx plug in processor
                        db  SMP_SYSPRO2     ; CPQ15xx       (smp version)
                        db  SMP_SYSPRO2     ; CPQ15xx       (smp version)
                        db  SMP_SYSPRO1     ; CPQ15xx
                        db  SMP_SYSPRO1     ; ALRa0xx PowerPro
                        db  SMP_SYSPRO1     ; ALRb0xx PowerPro
                        db  SMP_ACER        ; Acer SP clone (4p version)
                        db  SMP_ACER        ; ICL MX
                        db  SMP_ACER        ; ICL (acer 700xx)
                        db  SMP_SYSPRO1     ; Micronycs MPro motherboard
                        db  SMP_SYSPRO1     ; Micronycs MPro
                        db  SMP_SYSPRO1     ; ALRa1xx PowerPro (DX2-66 mobo)
                        db  SMP_SYSPRO1     ; ALRa2xx PowerPro (reserved mobos)
                        db  SMP_SYSPRO1     ; ALRb1xx PowerPro (reserved p2's)
                        db  SMP_SYSPRO1     ; Siemens Nixdorf PCE-4T/33
                        db  SMP_SYSPRO1     ; Siemens Nixdorf PCE-4T/33
                        db  SMP_ACER        ; AcerFrame 700
                        db  SMP_ACER        ; AcerFrame 3000MP560

TYPETABLE_SIZE          equ ($-spSystemTypeTable)
.errnz (CPUTABLE_SIZE - TYPETABLE_SIZE - 1)

;
; Order to check eisa ports in..
;
SpPortOrder                 dw  0000, 0F000h, 0C000h, 0D000h, -1

SpCOMPAQ                    db  'COMPAQ'
SpEISA                      db  'EISA'
Sp80386                     db  '80386'
Sp80486                     db  '80486'

_TEXT   ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        public _SpType, _SpCpuCount, _SpProcessorControlPort
_SpType                     db  -1          ; Lowest SMP_SYSPRO type found
_SpCpuCount                 db  0           ; # of Cpus found
_SpProcessorControlPort     dw  00000h+PCR_OFFSET
                            dw  0F000h+PCR_OFFSET
                            dw  0C000h+PCR_OFFSET
                            dw  0D000h+PCR_OFFSET
RestoreESP                  dd  0
RestoreESP1                 dd  0

_DATA   ends

        page ,132
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
; BOOLEAN
; DetectSystemPro (
;       OUT PBOOLEAN IsConfiguredMp
;       );
;
; Routine Description:
;   This function is only called on EISA machines
;
;   Determines the type of system (specifically for eisa machines).
;
; Arguments:
;   IsConfiguredMp - If the machine is a SystemPro, then this value is
;                    set to TRUE if it's an MP SystemPro, else FALSE.
;
; Return Value:
;   FALSE - not a supported machine for this HAL
;   TRUE  - is SystemPro
;   etc...
;
;--
cPublicProc _DetectSystemPro ,1

        push    edi
        push    esi
        push    ebx                         ; Save C Runtime

        movzx   edx, SpPortOrder[0]         ; Check system board for
        call    CheckEisaCard               ; SystemPro belize ID
if 0
        or      eax, eax
        jz      dsp_idnotknown
endif
        cmp     al, SMP_SYSPRO2
        je      dsp_belize                  ; if belize, go count belize style

        xor     ebx, ebx                    ; CpuCount
        xor     esi, esi                    ; Base EisaCard address

dsp10:  movzx   edx, SpPortOrder[esi*2]
        cmp     dx, -1                      ; End of list?
        je      short dsp30                 ; Yes, done

        call    CheckEisaCard               ; Check Eisa card for cpu
        or      eax, eax                    ; If not cpu, then skip it
        jz      short dsp20

        cmp     _SpType, al
        jc      @f
        mov     _SpType, al                 ; SpType = min(SpType, eax)
@@:
        cmp     ebx, 4                      ; MaxSupported CPUs already found?
        jae     dsp20                       ; Yes, then skip this one

        movzx   edx, SpPortOrder[esi*2]
        add     edx, PCR_OFFSET
        mov     _SpProcessorControlPort[ebx*2], dx

        inc     ebx                         ; CpuCount += 1

dsp20:  inc     esi                         ; Next EisaCard I/O addr to check
        jmp     short dsp10

dsp30:  xor     eax, eax                    ; Assume FALSE
ifdef SETUP
        cmp     bl, 2                       ; Did we find at least 2 CPUs?
else
        cmp     bl, 1                       ; Did we find at least 1 CPU?
endif
        jc      short SpExit                ; No, then exit

        mov     _SpCpuCount, bl
        mov     al, 1                       ; return non-zero

        mov     ebx, dword ptr [esp+16]
        mov     byte ptr [ebx], al          ; *IsConfiguredMp = TRUE

SpExit: pop     ebx
        pop     esi
        pop     edi
        stdRET  _DetectSystemPro

;-----

dsp_belize:
        mov     _SpType, al                 ; SpType = SYSPRO2

    ;
    ; Put Belize SystemPro into Symmetric mode
    ;

        mov     dx, SMP_MODE_PORT
        mov     al, SMP_SYMMETRICAL_MODE
        out     dx, al

    ;
    ; Count CPUs, belize style. And assign logcal IDs to CPUs
    ;
        xor     ecx,ecx     ;physical cpu
        xor     ebx,ebx     ;logical cpu

dsp50:
        mov     dx,SMP_INDEX_PORT
        mov     al,cl                   ; al = physical CPU slot number
        out     dx, al                  ; select physical CPU slot in al
        mov     dx,SMP_ASSIGNMENT_PORT
        in      al,dx                   ; read CPU number
        cmp     al,SMP_MAX_PROCESSORS   ; Q:Valid CPU?
        jae     short dsp60             ; n:Check next physical CPU slot
        mov     al,bl                   ; y:Make physical CPU a logical CPU
        out     dx,al
        inc     ebx                     ; next logical CPU to assign
dsp60:
        inc     ecx                     ; next physical CPU slot to check
        cmp     ecx,SMP_MAX_PROCESSORS
        jb      short dsp50             ; look in next cpu slot

        jmp     short dsp30             ; ebx = number of cpus found

;-----
if 0    ; Note: this code is not fully working  (did not pass hct's)
public dsp_idnotknown
dsp_idnotknown:
;
; The eisa ID was not recongonized - attempt to use the protect mode
; int-15 interface to determine if this is a SystemPro compatible
; computer.  Any SystemPro detected in this manner is assumed to
; be of type SMP_SYSPRO1 which only has 2 processors.
;
; Note: There is a fair amount of paranoia in the following code
; becuase we trust the rom as little as possible.
;

        xor     eax, eax
        xor     ecx, ecx
        mov     cx, ss                  ; Verify SS value is what it is
        cmp     ecx, KGDT_R0_DATA       ; expect it to be; otherwise this code
        jne     short SpExit            ; can't work

        pushf                           ; Save current DF & EF

        sub     esp, 15*8
        sidt    fword ptr [esp]         ; get IDT address
        mov     esi, dword ptr [esp+2]  ; (esi) = IDT
        mov     edi, esp                ; (edi) = address to copy vectors to

        push    es                      ; Save selectors in case rom
        push    ds                      ; trashes state
        push    fs
        push    gs
        push    esi
        push    ebp
        cld
        cli
        pushf

    ;
    ; Save and hook some IDT vectors.  If we get some type of trap
    ; here or in the rom, then we will restore the state and return
    ; back that a systempro was not detected
    ;

        mov     eax, esi
        mov     ecx, 15*8/4
        rep     movsd                   ; Save IDT vectors

        mov     RestoreESP, esp         ; Save current ESP for restore

        mov     ecx, offset FLAT:dsp_handlefault
        mov     dx, cs
        shl     edx, 16
        mov     dx, cx
        mov     cx, 08E00h              ; Install int32 gate for vectors

        mov     [eax+0*8+0] , edx
        mov     [eax+0*8+4] , ecx       ; Trap IDT  0   Divide Error
        mov     [eax+4*8+0] , edx
        mov     [eax+4*8+4] , ecx       ; Trap IDT  4   INTO
        mov     [eax+5*8+0] , edx
        mov     [eax+5*8+4] , ecx       ; Trap IDT  5   BOUND
        mov     [eax+6*8+0] , edx
        mov     [eax+6*8+4] , ecx       ; Trap IDT  6   Invalid OpCode
        mov     [eax+11*8+0], edx
        mov     [eax+11*8+4], ecx       ; Trap IDT 11   Segment not present
        mov     [eax+12*8+0], edx
        mov     [eax+12*8+4], ecx       ; Trap IDT 12   Stack fault
        mov     [eax+13*8+0], edx
        mov     [eax+13*8+4], ecx       ; Trap IDT 13   GP fault
        mov     [eax+14*8+0], edx
        mov     [eax+14*8+4], ecx       ; Trap IDT 14   Page fault

    ;
    ; Map in 64K of the ROM in order to use protect mode int-15 interface.
    ; (see Compaq eisa spec)
    ;
        stdCall _HalpMapPhysicalMemory, <0f0000h, 16>   ; map 64K of ROM
        mov     ebp, eax                ; save ROM starting address

    ;
    ; Verify there is a ROM, search for the word 'COMPAQ' in the ROM
    ; addresses FE000-FE0FF.    (see Compaq eisa spec)
    ;
        lea     esi, SpCOMPAQ           ; 'COMPAQ'
        mov     ebx, 6                  ; strlen ('COMPAQ')
        lea     edi, [ebp+0e000h]       ; address to scan
        mov     ecx, 0ffh               ; length of scan
        call    SpScanForString
        jne     dsp_handlefault         ; if not found then abort

    ;
    ; Also verify the 'EISA' work at rom address FFFD0-FFFFF
    ; (see Compaq eisa spec)
    ;
        lea     esi, SpEISA             ; 'EISA'
        mov     ebx, 4                  ; strlen ('EISA')
        lea     edi, [ebp+0ffd0h]       ; address to scan
        mov     ecx, 02fh               ; length of scan
        call    SpScanForString
        jne     dsp_handlefault         ; if not found then abort

    ;
    ; Look in slot 11 and slot 15 for processors
    ;
        sub     esp, 400                ; make space for Config Data Block
        mov     ecx, 11                 ; check slot 11 first
        xor     ebx, ebx                ; assume no processors found

dsp_95:
        push    ebp                     ; save virtual rom address
        push    ecx                     ; save current slot #
        push    ebx                     ; save # processors found

        xor     eax, eax
        lea     edi, [esp+12]
        mov     ecx, 300/4
        rep     stosd                   ; clear destionation buffer

        mov     ax, 0D881h              ; Read Config Info, 32bit
        lea     esi, [esp+12]           ; destionation address

        mov     RestoreESP1, esp        ; Some roms don't iret correctly
        sub     esp, 10h                ; Some roms clobber some stack
        pushf
        push    cs
        lea     ebx, [ebp+0f859h]       ; 'industry standard' int-15 address
        call    ebx                     ; INT-15    (trashes most registers)
        mov     esp, RestoreESP1        ; restore ESP
        jc      short dsp_110           ; Not valid, check next slot

    ;
    ; Check type field
    ;
        lea     edi, [esp+12+23h]       ; address of type string
        lea     esi, Sp80386            ; '80386'
        mov     ebx, 5                  ; strlen ('80386')
        mov     ecx, 80
        call    SpScanForString
        je      short dsp_105

        lea     edi, [esp+12+23h]       ; address of type string
        lea     esi, Sp80486            ; '80486'
        mov     ebx, 5                  ; strlen ('80486')
        mov     ecx, 80
        call    SpScanForString
        jne     short dsp_110

dsp_105:
    ; string was either 80386 or 80486
        inc     dword ptr [esp]         ; count one more processor

dsp_110:
        pop     ebx                     ; (ebx) = number processors found
        pop     ecx                     ; (ecx) = slot #
        pop     ebp                     ; (ebp) = virtual rom address

        or      ebx, ebx                ; if a processor is not in the first
        jz      short dsp_handlefault   ; slot, then don't look in second

        cmp     ebx, 2                  ; if # of processors is trash
        ja      short dsp_handlefault   ; then abort

        mov     eax, ecx
        cmp     eax, 11                 ; Did we just test slot 11?
        mov     ecx, 15
        je      dsp_95                  ; Yes, now test 15
        cmp     eax, 15                 ; Did we just test slot 15?
        je      short dsp_cleanup       ; Yes, then we are done

    ; slot # isn't 11 or 15, abort

dsp_handlefault:                        ; Sometype of fault, or abort
        mov     eax, KGDT_R0_DATA       ; make sure ss has the correct value
        mov     ss, ax
        xor     ebx, ebx                ; No processors found

dsp_cleanup:
; (ebx) = # of processors
        mov     esp, SS:RestoreESP      ; Make sure esp is correct

        popf
        pop     ebp
        pop     edi                     ; (edi) = IDT address
        pop     gs                      ; restore selectors
        pop     fs
        pop     ds
        pop     es
        mov     esi, esp                ; (esi) = original IDT vectors
        mov     ecx, 15*8/4
        rep     movsd                   ; restore IDT vectors
        add     esp, 15*8               ; cleanup stack
        popf

        mov     _SpType, SMP_SYSPRO1    ; assume original systempro

        cmp     ebx, 2                  ; at least 2 processors found?
        jc      short dsp_150           ; no, continue
;
; Verify that the second processor board is enabled
;
        movzx   edx, SpPortOrder[1*2]
        add     edx, EBC_OFFSET         ; (edx) = 0zC84
        in      al, dx                  ; Read control bits
        test    al, 1                   ; Is Eisa CPU board enabled?
        jnz     short dsp_150           ; Yes, continue
        dec     ebx                     ; don't count it

dsp_150:
        jmp     dsp30                   ; exit
endif

stdENDP _DetectSystemPro

;++
; SpScanForString
;
; Routine Description:
;   Scans address range looking for matching string
;
; Arguments:
;   (edi) = Start of address range to scan
;   (ecx) = Length of address range
;   (esi) = String to scan for
;   (ebx) = Length of string
;
; Returns:
;   ZR  - String found
;   NZ  - String not found
;
;--
SpScanForString proc
        sub     ecx, ebx            ; don't go past end
        inc     ecx

        mov     al, [esi]           ; (al) = first char to scan for
        inc     esi                 ; skip past first char
        dec     ebx

ss10:   repne   scasb               ; look for first byte
        jecxz   short ss20          ; byte found?  No, exit

        push    ecx
        push    edi
        push    esi
        mov     ecx, ebx            ; length of string to compare
        repe    cmpsb               ; is string at this location?
        or      ecx, ecx            ; ZF if strings match
        pop     esi
        pop     edi
        pop     ecx

        jnz     short ss10          ; continue looking
        ret                         ; ZR

ss20:   inc     ecx                 ; NZ
        ret

SpScanForString endp


;++
; CheckEisaCard
;
; Routine Description:
;   Used only by DetectSystemPro.
;
; Arguments:
;   (edx) = Eisa ID port to check
;
; Returns:
;   (eax) = 0 card was not a valid cpu
;           non-zero Cpu type
;
;--
CheckEisaCard proc
        push    edi
        push    esi
        push    ebx

        mov     esi, edx
        add     edx, PRODUCT_ID_OFFSET      ; Product ID port

        xor     eax, eax
        in      al, dx                      ; 0zC80
        test    al, 80h                     ; if bit 8 off?
        jnz     short NoMatch               ; no, then not an Eisa card

        shl     eax, 8
        inc     edx
        in      al, dx                      ; 0zC81
        shl     eax, 8
        inc     edx
        in      al, dx                      ; (eax)=dword of ports 0zC80-0zC82

        mov     ecx, CPUTABLE_SIZE          ; Scan CPU table looking for
        lea     edi, spSystemCpuTable       ; matching board ID
        repne   scasd
        jecxz   short NoMatch               ; Was it found?

        sub     ecx, CPUTABLE_SIZE-1
        neg     ecx                         ; (ecx) = index CPU was found at
        movzx   ecx, byte ptr spSystemTypeTable[ecx]

        or      esi, esi                    ; SystemBoard?
        jz      short @f                    ;  Yes, then it is assumed enabled

        cmp     cl, SMP_ACER                ; If acer, assume it's enabled
        je      short @f                    ; (machine incorrectly reports
                                            ; 'disable' on every other proc)
        mov     edx, esi
        add     edx, EBC_OFFSET             ; (edx) = 0zC84
        in      al, dx                      ; Read control bits
        test    al, 1                       ; Is Eisa CPU board enabled?
        jz      short NoMatch               ;  No, then skip it
@@:
        mov     eax, ecx
        jmp     short cei_exit
NoMatch:
        xor     eax, eax
cei_exit:
        pop     ebx
        pop     esi
        pop     edi
        ret

CheckEisaCard endp

_TEXT   ENDS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    spclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.  It works on UP and SystemPro.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;
;--

.386p
        .xlist
include callconv.inc
include hal386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include i386\kimacro.inc
include mac386.inc
include i386\spmp.inc
        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        extrn   KiI8259MaskTable:DWORD
        EXTRNP  _KeUpdateSystemTime,0
        EXTRNP  _KeUpdateRunTime,1,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalRequestIpi,1
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRNP  _KeStallExecutionProcessor, 1
        extrn   _HalpProcessorPCR:DWORD
        extrn   _HalpSystemHardwareLock:DWORD
        extrn   _HalpFindFirstSetRight:BYTE
        extrn   _Sp8259PerProcessorMode:BYTE
        EXTRNP  _KeSetTimeIncrement,2,IMPORT
        EXTRNP  _HalpMcaQueueDpc, 0
        extrn   _SpType:BYTE

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port
TIMER1_IRQ              EQU     0       ; Irq 0 for timer1 interrupt

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

PERFORMANCE_FREQUENCY   EQU     1193182

;
; ==== Values used for System Clock ====
;

;
; Convert the interval to rollover count for 8254 Timer1 device.
; Timer1 counts down a 16 bit value at a rate of 1.193181667M counts-per-sec.
;
;
; The best fit value closest to 10ms (but not below) is 10.0144012689ms:
;   ROLLOVER_COUNT      11949
;   TIME_INCREMENT      100144
;   Calculated error is -.0109472 s/day
;
; The best fit value closest to 15ms (but not above) is 14.9952019ms:
;   ROLLOVER_COUNT      17892
;   TIME_INCREMENT      149952
;   Calculated error is -.0109472 s/day
;
; On 486 class machines or better we use a 10ms tick, on 386
; class machines we use a 15ms tick
;

ROLLOVER_COUNT_10MS     EQU     11949
TIME_INCREMENT_10MS     EQU     100144

;
; Value for KeQueryPerf retries.
;

MAX_PERF_RETRY          equ     3  ; Odly enough 3 is plenty.

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; The following array stores the per microsecond loop count for each
; central processor.
;

        public  _HalpIpiClock
_HalpIpiClock   dd      0       ; Processors to IPI clock pulse to

        public HalpPerfCounterLow
        public HalpPerfCounterHigh
HalpPerfCounterLow      dd      0
HalpPerfCounterHigh     dd      0
HalpPerfP0Value         dd      0
HalpCalibrateFlag       db      0
                        db      0
                        dw      0

HalpRollOverCount       dd      0

        public _HalpClockWork, _HalpClockSetMSRate, _HalpClockMcaQueueDpc
_HalpClockWork label dword
    _HalpClockSetMSRate     db  0
    _HalpClockMcaQueueDpc   db  0
    _bReserved1             db  0
    _bReserved2             db  0

;
; Storage for variable to ensure that queries are always
; greater than the last.
;

HalpLastQueryLowValue   dd      0
HalpLastQueryHighValue  dd      0
HalpForceDataLock       dd      0

; endmod

_DATA   ends


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;    This routine initialize system time clock using 8254 timer1 counter 0
;    to generate an interrupt at every 15ms interval at 8259 irq0
;
;    See the definition of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
;    needs to be changed.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

;
; Use 15ms or 10ms clock tick?
;

        mov     edx, TIME_INCREMENT_10MS        ; yes, use 10ms clock
        mov     ecx, ROLLOVER_COUNT_10MS
;
; Fill in PCR value with TIME_INCREMENT
; (edx) = TIME_INCREMENT
; (ecx) = ROLLOVER_COUNT
;
        cmp     byte ptr PCR[PcHal.PcrNumber], 0
        jne     short icl_10

        push    ecx
        stdCall _KeSetTimeIncrement, <edx, edx>
        pop     ecx

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

;
; Set clock rate
; (ecx) = RollOverCount
;

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        popfd                           ; restore caller's eflag
        mov     HalpRollOverCount, ecx  ; Set RollOverCount & initialized
        stdRET    _HalpInitializeClock


icl_10:
        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled
;
; initialize clock, non-p0
; (ecx) = ROLLOVER_COUNT
;

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        popfd                           ; restore caller's eflag
        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

;++
;
; VOID
; HalCalibratePerformanceCounter (
;     IN LONG volatile *Number,
;     IN ULONGLONG NewCount
;     )
;
; /*++
;
; Routine Description:
;
;     This routine calibrates the performance counter value for a
;     multiprocessor system.  The calibration can be done by zeroing
;     the current performance counter, or by calculating a per-processor
;     skewing between each processors counter.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
;     NewCount - Supplies the value to synchronize the counter too
;
; Return Value:
;
;     None.
;--
cPublicProc _HalCalibratePerformanceCounter,3

        mov     eax, [esp+4]            ; ponter to Number
        pushfd                          ; save previous interrupt state
        cli                             ; disable interrupts (go to high_level)

    lock dec    dword ptr [eax]         ; count down

@@:     cmp     dword ptr [eax], 0      ; wait for all processors to signal
        jnz     short @b

        test    _Sp8259PerProcessorMode, SP_SMPCLOCK
        jz      short cal_exit          ; 8254 per processor?

        xor     ecx, ecx
        mov     al, COMMAND_8254_LATCH_READ+COMMAND_8254_COUNTER0
                                        ; Latch PIT Ctr 0 command.
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, LSByte.
        IODelay
        movzx   ecx, al
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, MSByte.
        mov     ch, al                  ; (CX) = PIT Ctr 0 count.

        cmp     byte ptr PCR[PcHal.PcrNumber], 0    ; is this the processor
        jz      short cal_p0            ; which updates HalpPerfCounter?

@@:     cmp     HalpCalibrateFlag, 0    ; wait for P0 to post it's counter
        jz      short @b

        sub     ecx, HalpPerfP0Value    ; compute difference
        neg     ecx
        mov     PCR[PcHal.PcrPerfSkew], ecx

cal_exit:
        popfd
        stdRET  _HalCalibratePerformanceCounter

cal_p0: mov     HalpPerfP0Value, ecx    ; post our timer value
        mov     HalpCalibrateFlag, 1    ; signal we are done
        jmp     short cal_exit

stdENDP _HalCalibratePerformanceCounter

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceCounter (
;    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
;    )
;
; Routine Description:
;
;    This routine returns current 64-bit performance counter and,
;    optionally, the Performance Frequency.
;
;    Note this routine can NOT be called at Profiling interrupt
;    service routine.  Because this routine depends on IRR0 to determine
;    the actual count.
;
;    Also note that the performace counter returned by this routine
;    is not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    PerformanceFrequency [TOS+4] - optionally, supplies the address
;        of a variable to receive the performance counter frequency.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--

;
; Parameter definitions
;

KqpcFrequency   EQU     [esp+20]        ; User supplied Performance Frequence
RetryPerfCount  EQU     [esp]           ; Local retry variable


cPublicProc _KeQueryPerformanceCounter      ,1

        push    ebx
        push    esi
        push    edi
        push    0                       ; make space for RetryPerfCount

;
; First check to see if the performance counter has been initialized yet.
; Since the kernel debugger calls KeQueryPerformanceCounter to support the
; !timer command, we need to return something reasonable before 8254
; initialization has occured.  Reading garbage off the 8254 is not reasonable.
;
        cmp     HalpRollOverCount, 0
        jne     short Kqpc11            ; ok, perf counter has been initialized

;
; Initialization hasn't occured yet, so just return zeroes.
;
        mov     eax, 0
        mov     edx, 0
        jmp     Kqpc50

Kqpc11: pushfd
        cli

Kqpc20:
        lea     eax, _HalpSystemHardwareLock
        ACQUIRE_SPINLOCK eax, Kqpc198

;
; Fetch the base value.  Note that interrupts are off.
;
; NOTE:
;   Need to watch for Px reading the 'CounterLow', P0 updates both
;   then Px finishes reading 'CounterHigh' [getting the wrong value].
;   After reading both, make sure that 'CounterLow' didn't change.
;   If it did, read it again. This way, we won't have to use a spinlock.


@@:
        mov     ebx, HalpPerfCounterLow
        mov     esi, HalpPerfCounterHigh    ; [esi:ebx] = Performance counter

        cmp     ebx, HalpPerfCounterLow     ;
        jne     short @b


;
; Fetch the current counter value from the hardware
;

;
; Background: Belize style systems have an 8254 per Processor.
;
; In short the original implementation kinda assumes that each
; timer on each processor will be in perfect sycnh with each other.
; This is a bad assumption, and the reason why we have attempted
; to use only the timer on P0.
;
; There is an existing window where the return value may not be accurate.
; The window will occur when multiple queries are made back to back
; in an MP environment, and there are a lot of IPIs going on.  Intuitive,
; right.  The problem is that this routine may return a value with the
; the hardware system timer on P0 that has already generated an interrupt
; and reset its rollover, but the software has yet to process the interrupt
; to update the performance counter value.  When this occurs, the second
; querry will seem to have a lower value than the first.
;
; So, why don't I just fix it.  Well the cause of the problem is the
; overhead associated with handling the interrupt, and the fact that
; the IPI has a higher IRQL.  In addition, a busy system could be
; issueing multiple IPIs back to back, which could extend this window
; even further.
;
; I have managed to close the window most of the way for most normal
; conditions.  It takes several minutes on a busy system, with
; multiple applications running with back to back queries to get
; an invalid value.  It can happen though. 
;
; A retry implementation has been instrumented on top off the
; Indexed IO implementation to finally close the window.  
; It seems to work OK.  
;
; In reality, I think the fix is sufficient.  The performance counter
; is not designed propperly (via only software) to yield very accurate
; values on sub timer tic (10-15msec) ranges on multiprocessor systems.
;
; Problems with this design:
;
; On an idle system threads executing from P0 will always
; use less overhead than threads executing on P1.
; On a ProLiant 2000 with 2 P5-66s the difference in 2
; consecutive KeQueryPerformanceCounter calls from P0
; is about 14, while from P1 is about 22.  Unfortunately
; on a busy system P0 performs about the same, but P1
; is much slower due to the overhead involved in performing
; an Indexed_IO.  This means the busyier your system gets
; the less accurate your performance values will become.
;
; The solution:
;
; A system wide hardware timer needs to be used.  This is about the
; only way to get accurate performance numbers from multiple
; processors without causing unnecessary software overhead.
;
; Supposedly there is a 48 bit counter that we may be able to use
; with SystemPro XL, and ProLiant systems, unfortunately it does
; not appear that any OS is currently using this feature, so
; its dependability may be suspect.
;
; JSL
;

;
; Essentially all we are doing is always using the timer value on P0.
; The indexed_io is a mechanism for one processor to access IOSPACE
; on another processor's IOSPACE.  I suspect this will have a greater
; impact on performance than just reading the timer locally.
; By using the indexed_io you are gauranteed of going out on the bus.
;
; But, hey if the user understands anything about performance, they
; know that there will be some amount of overhead each time you make
; this KeQueryPerformanceCounter call.
;

;
; Increment the Retry counter now for convenience
;

        inc     dword ptr RetryPerfCount+4

;
; This is Belize specific.
;

        cmp     _SpType, SMP_SYSPRO2
        jne     timer_p0


 ;
 ; Only use Indexed_IO on a nonP0 processor
 ;

        cmp     byte ptr PCR[PcHal.PcrNumber], 0    ; is this the processor
        je      timer_p0                ; which updates HalpPerfCounter?

 ;
 ; So read the timer of P0.
 ;

        push    ebx
        mov     bl, 0
        mov     al, COMMAND_8254_LATCH_READ+COMMAND_8254_COUNTER0
                                        ; Latch PIT Ctr 0 command.
        INDEXED_IO_WRITE bl,TIMER1_CONTROL_PORT0,al
        IODelay
        INDEXED_IO_READ bl,TIMER1_DATA_PORT0   ; Read PIT Ctr 0, LSByte.
        movzx   ecx, al
        INDEXED_IO_READ bl,TIMER1_DATA_PORT0   ; Read PIT Ctr 0, MSByte.
        IODelay
        mov     ch,al                  ; (CX) = PIT Ctr 0 count.
        pop     ebx

        lea     eax, _HalpSystemHardwareLock
        RELEASE_SPINLOCK eax
        jmp     short TimerValDone

timer_p0:


        mov     al, COMMAND_8254_LATCH_READ+COMMAND_8254_COUNTER0
                                        ;Latch PIT Ctr 0 command.
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ;Read PIT Ctr 0, LSByte.
        IODelay
        movzx   ecx,al                  ;Zero upper bytes of (ECX).
        in      al, TIMER1_DATA_PORT0   ;Read PIT Ctr 0, MSByte.
        mov     ch, al                  ;(CX) = PIT Ctr 0 count.

        lea     eax, _HalpSystemHardwareLock
        RELEASE_SPINLOCK eax



TimerValDone:

        mov     al, PCR[PcHal.PcrNumber]    ; get current processor #

;
; This is Belize specific.
;

        cmp     _SpType, SMP_SYSPRO2
        je      NoCPU0Update

;
; If not on P0 then make sure P0 isn't in the process of
; of updating its timer.  Do this by checking the status
; of the PIC using indexed_io.
; Make sure that only one thread at time reads P0 PIC.
;

        cmp     al, 0                       ; Are we p0
        je      NoCPU0Update

;
; Check IRQL at PO before going any further
;

        push    edx
        mov     edx, _HalpProcessorPCR[0]      ; PCR of processor 0
        cmp byte ptr ds:[edx].PcIrql,CLOCK2_LEVEL
        pop     edx
        jb      short NoCPU0Update
        push    ebx

Kqpc11p: 
;
; Check P0 PIC and confirm Timer Interrupt status.
; Perform Spin Lock before reading P0 PIC.
;

        pushfd
        cli
        lea     ebx, _HalpSystemHardwareLock
        ACQUIRE_SPINLOCK ebx, Kqpc198p      ; Spin if another thread is here
        INDEXED_IO_READ 0,PIC1_PORT1        ; read CPU 0 port 21 for masks
        RELEASE_SPINLOCK ebx
        popfd
        pop     ebx
        test    al, 1h                      ; check for IRQ 0 masked off
        mov     al, PCR[PcHal.PcrNumber]    ; get current processor #
        jz      short NoCPU0Update

;
; Try ReadAgain if below retry count.
;

        cmp     RetryPerfCount+4, MAX_PERF_RETRY
        ja      short NoCPU0Update

ReadAgain:
;
; This readagain is only executed when P0 is
; at CLOCK2_LEVEL or greater.
; AND when Timer IRQ is active (ie interrupt in progress).
; This is done to close the window of an interrupt
; occuring and the irql hasn't been raised yet.
;

        popfd
        jmp     Kqpc11                         ; go back and read again

NoCPU0Update:


;
; Now enable interrupts such that if timer interrupt is pending, it can
; be serviced and update the PerformanceCounter.  Note that there could
; be a long time between the sti and cli because ANY interrupt could come
; in in between.
;

        popfd                           ; don't re-enable interrupts if
        nop                             ; the caller had them off!

        jmp     $+2                     ; allow interrupt in case counter
                                        ; has wrapped

        pushfd
        cli

;
; In Belize mode we do not care about this since we use the P0 clock.
;

        cmp     _SpType, SMP_SYSPRO2
        je      short Kqpc35
        
;
; If we moved processors while interrupts were enabled, start over
;

        cmp     al, PCR[PcHal.PcrNumber]
        jne     Kqpc20
Kqpc35:        


;
; Fetch the base value again.
;

@@:     mov     eax, HalpPerfCounterLow
        mov     edx, HalpPerfCounterHigh ; [edx:eax] = new counter value
        cmp     eax, HalpPerfCounterLow  ; did it move?
        jne     short @b                 ; re-read


;
; Compare the two reads of Performance counter.  If they are different,
; start over
;

        cmp     eax, ebx
        jne     Kqpc20
        cmp     edx, esi
        jne     Kqpc20

        neg     ecx                     ; PIT counts down from 0h
        add     ecx, HalpRollOverCount

;
; In Belize mode we do not care about this since we use the P0 clock.
;

        cmp     _SpType, SMP_SYSPRO2
        je      short Kqpc37
        
        add     ecx, PCR[PcHal.PcrPerfSkew]
Kqpc37:        

        popfd                           ; restore interrupt flag

        xchg    ecx, eax
        mov     ebx, edx
        cdq

        add     eax, ecx
        adc     edx, ebx                 ; [edx:eax] = Final result

;
; We only want to execute this code In Belize mode.
;

        cmp     _SpType, SMP_SYSPRO2
        jne      Kqpc50

 ;
 ; Ok compare this result with the last result.
 ; We will force the value to be greater than the last value,
 ; after we have used up all of our retry counts.
 ;
 ; This should slam shut that annoying Window that causes
 ; applications to recieve a 2nd query less then the first.
 ;
 ; This is not an most elegant solution, but fortunately
 ; this situation is hit only on a rare occasions.
 ;
 ; Yeah, I know that this value can roll over
 ; if someone runs some perf tests, and comes back in a
 ; few weeks and wants to run some more.  In this situation
 ; the the very first call to this function will yield an
 ; invalid value.  This is the price of the fix.
 ;

 ;
 ; Protect the global data with a spinlock
 ;

        push    ebx
Kqpc42: pushfd
        cli
        lea     ebx, HalpForceDataLock
        ACQUIRE_SPINLOCK ebx, Kqpc199      ; Spin if another thread is here

;
; Compare this value to the last value, if less then
; fix it up.
;

        cmp     edx,  HalpLastQueryHighValue
        ja      short Kqpc44

        cmp     eax,  HalpLastQueryLowValue
        ja      short Kqpc44

;
; Release the spinlock.
;

        RELEASE_SPINLOCK ebx
        popfd
        pop     ebx

;
; Try Again if below count.
;

        cmp     RetryPerfCount, MAX_PERF_RETRY
        jbe     Kqpc11                         ; go back and read again

;
; Exhausted retry count so Fix up the values and leave.
;

        mov     eax, HalpLastQueryLowValue
        inc     eax
        mov     edx, HalpLastQueryHighValue

        jmp     short Kqpc50

Kqpc44:
;
; Save off the perf values for next time.
;

        mov     HalpLastQueryLowValue,  eax
        mov     HalpLastQueryHighValue, edx

;
; Release the spinlock.
;

        RELEASE_SPINLOCK ebx
        popfd
        pop     ebx


;
;   Return the counter
;

Kqpc50:
        ; return value is in edx:eax

;
;   Return the freq. if caller wants it.
;

        or      dword ptr KqpcFrequency, 0 ; is it a NULL variable?
        jz      short Kqpc99            ; if z, yes, go exit

        mov     ecx, KqpcFrequency      ; (ecx)-> Frequency variable
        mov     DWORD PTR [ecx], PERFORMANCE_FREQUENCY ; Set frequency
        mov     DWORD PTR [ecx+4], 0

Kqpc99:
        pop     edi                     ; remove locals
        pop     edi                     ; restore regs
        pop     esi
        pop     ebx

        stdRET    _KeQueryPerformanceCounter

Kqpc198: popfd
        SPIN_ON_SPINLOCK    eax,<Kqpc11>

;
; This is just where we are spinning while we are waiting to read the PIC
;
Kqpc198p: popfd
        SPIN_ON_SPINLOCK    ebx,<Kqpc11p>
;
; This is just where we are spinning while waiting global last perf data
;
Kqpc199:  popfd
        SPIN_ON_SPINLOCK    ebx,<Kqpc42>

stdENDP _KeQueryPerformanceCounter
; endmod

        page ,132
        subttl  "System Clock Interrupt"
;++
;
; Routine Description:
;
;
;    This routine is entered as the result of an interrupt generated by CLOCK2.
;    Its function is to dismiss the interrupt, raise system Irql to
;    CLOCK2_LEVEL, update performance counter and transfer control to the
;    standard system routine to update the system time and the execution
;    time of the current thread
;    and process.
;
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;    Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hci_a, Hci_t

cPublicProc _HalpClockInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hci_a, Hci_t
;
; (esp) - base of trap frame
;

;
; dismiss interrupt and raise Irql
;

Hci10:
        push    CLOCK_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL,CLOCK_VECTOR,esp>
        or      al,al                           ; check for spurious interrupt
        jz      Hci100

;
; Update performance counter
;

        mov     eax, HalpRollOverCount
        xor     ebx, ebx
        add     HalpPerfCounterLow, eax         ; update performace counter
        adc     HalpPerfCounterHigh, ebx

        cmp     _HalpClockWork, ebx
        jz      short Hci20

        cmp     _HalpClockMcaQueueDpc, bl
        jz      short Hci20

        mov     _HalpClockMcaQueueDpc, bl

;
; Queue MCA Dpc
;
        stdCall _HalpMcaQueueDpc

Hci20:
;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; (ebp)   = address of trap frame
; (eax)   = time increment
;
        mov     eax, TIME_INCREMENT_10MS

        mov     ebx, _HalpIpiClock      ; Emulate clock ticks to any processors?
        or      ebx, ebx
        jz      _KeUpdateSystemTime@0

;
; On the SystemPro we know the processor which needs an emulated clock tick.
; Just set that processors bit and IPI him
;

@@:
        movzx   ecx, _HalpFindFirstSetRight[ebx] ; lookup first processor
        btr     ebx, ecx
        mov     ecx, _HalpProcessorPCR[ecx*4]   ; PCR of processor
        mov     [ecx].PcHal.PcrIpiClockTick, 1  ; Set internal IPI event
        or      ebx, ebx                        ; any other processors?
        jnz     short @b                        ; yes, loop

        stdCall   _HalRequestIpi, <_HalpIpiClock>  ; IPI the processor(s)

        mov     eax, TIME_INCREMENT_10MS
        jmp     _KeUpdateSystemTime@0

Hci100:
        add     esp, 8
        SPURIOUS_INTERRUPT_EXIT

stdENDP _HalpClockInterrupt


        page ,132
        subttl  "NonPrimaryClockTick"
;++
;
; VOID
; HalpNonPrimaryClockInterrupt (
;    );
;
; Routine Description:
;   ISR for clock interrupts for every processor except one.
;
; Arguments:
;
;    None.
;    Interrupt is dismissed
;
; Return Value:
;
;    None.
;
;--
        ENTER_DR_ASSIST Hni_a, Hni_t
cPublicProc _HalpNonPrimaryClockInterrupt     ,0
        ENTER_INTERRUPT Hni_a, Hni_t

; Dismiss interrupt and raise irql

        push    CLOCK_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL,CLOCK_VECTOR,esp>
        or      al,al                   ; check for spurious interrupt
        jz      Hni100

        ; TOS const PreviousIrql
        stdCall _KeUpdateRunTime,<dword ptr [esp]>

        INTERRUPT_EXIT                  ; will do an iret

Hni100:
        add     esp, 8
        SPURIOUS_INTERRUPT_EXIT

stdENDP _HalpNonPrimaryClockInterrupt

        page ,132
        subttl  "Emulate NonPrimaryClockTick"
;++
;
; VOID
; HalpSWNonPrimaryClockTick (
;    );
;
; Routine Description:
;   On the SystemPro the second processor does not get it's own clock
;   ticks.  The HAL emulates them by sending an IPI which sets an overloaded
;   software interrupt level of SWCLOCK_LEVEL.  When the processor attempts
;   to lower it's irql level below SWCLOCK_LEVEL the soft interrupt code
;   lands us here as if an interrupt occured.
;
; Arguments:
;
;    None.
;    Interrupt is dismissed
;
; Return Value:
;
;    None.
;
        ENTER_DR_ASSIST Hsi_a, Hsi_t

        public _HalpSWNonPrimaryClockTick
_HalpSWNonPrimaryClockTick proc
;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax
;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hsi_a, Hsi_t

        public  _HalpSWNonPrimaryClockTick2ndEntry
_HalpSWNonPrimaryClockTick2ndEntry:

; Save previous IRQL and set new priority level

        push    fs:PcIrql                         ; save previous IRQL
        mov     byte ptr fs:PcIrql, SWCLOCK_LEVEL ; set new irql
        btr     dword ptr fs:PcIRR, SWCLOCK_LEVEL ; clear the pending bit in IRR

        sti

        ; TOS const PreviousIrql
        stdCall _KeUpdateRunTime,<dword ptr [esp]>

        SOFT_INTERRUPT_EXIT                 ; will do an iret


_HalpSWNonPrimaryClockTick endp

;++
;
; ULONG
; HalSetTimeIncrement (
;     IN ULONG DesiredIncrement
;     )
;
; /*++
;
; Routine Description:
;
;    This routine initialize system time clock to generate an
;    interrupt at every DesiredIncrement interval.
;
; Arguments:
;
;     DesiredIncrement - desired interval between every timer tick (in
;                        100ns unit.)
;
; Return Value:
;
;     The *REAL* time increment set.
;--
cPublicProc _HalSetTimeIncrement,1

        mov     eax, TIME_INCREMENT_10MS        ; yes, use 10ms clock
        stdRET  _HalSetTimeIncrement

stdENDP _HalSetTimeIncrement

_TEXT   ends
        end

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spipi.asm ===
title "Interprocessor Interrupt"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    spipi.asm
;
;Abstract:
;
;    SystemPro IPI code.
;    Provides the HAL support for Interprocessor Interrupts for hte
;    MP SystemPro implementation.
;
;Author:
;
;    Ken Reneris (kenr) 13-Jan-1992
;
;Revision History:
;
;--
.386p
;        .xlist

;
; Include SystemPro detection code
;

include i386\spdetect.asm

;
; Normal includes
;

include hal386.inc
include i386\kimacro.inc
include i386\ix8259.inc
include callconv.inc                ; calling convention macros

        EXTRNP  _KiCoprocessorError,0,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _KeRaiseIrql,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _KiIpiServiceRoutine,2,IMPORT
        EXTRNP  _HalEnableSystemInterrupt,3
        EXTRNP  _HalpInitializePICs,1
        EXTRNP  _HalDisplayString,1
        EXTRNP  _HalEnableSystemInterrupt,3
        EXTRNP  _HalDisableSystemInterrupt,2
        EXTRNP  _HalpAcerInitializeCache,0
        extrn   _HalpDefaultInterruptAffinity:DWORD
        extrn   _HalpActiveProcessors:DWORD
        extrn   _HalpCpuCount:DWORD

_TEXT   SEGMENT  DWORD PUBLIC 'CODE'

        public  _HalpFindFirstSetRight
_HalpFindFirstSetRight  db  0, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0

_TEXT ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        public  _Sp8259PerProcessorMode
_Sp8259PerProcessorMode db  0

align 4
        public  _HalpProcessorPCR
_HalpProcessorPCR       dd  MAXIMUM_PROCESSORS dup (?) ; PCR pointer for each processor

_DATA ends

_TEXT   SEGMENT  DWORD PUBLIC 'CODE'

_HalpPINTAddrTable  label word
                dw      SMP_MPINT0
                dw      SMP_MPINT1
                dw      SMP_MPINT3
                dw      SMP_MPINT4
                dw      SMP_MPINT5
                dw      SMP_MPINT6
                dw      SMP_MPINT7
                dw      SMP_MPINT8
                dw      SMP_MPINT9
                dw      SMP_MPINT10
                dw      SMP_MPINT11
                dw      SMP_MPINT12
                dw      SMP_MPINT13
                dw      SMP_MPINT14
                dw      SMP_MPINT15

HALPPINTADDRTABLESIZE equ ($-_HalpPINTAddrTable)/TYPE(_HalpPINTAddrTable)

BadHalString    db 'HAL: SystemPro HAL.DLL cannot be run on non SystemPro'
                db '/compatible', cr,lf
                db '     Replace the hal.dll with the correct hal', cr, lf
                db '     System is HALTING *********', 0

_TEXT   ends

        page ,132
        subttl  "Post InterProcessor Interrupt"
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;
; VOID
; HalInitializeProcessor(
;       ULONG   Number
;       );
;
;Routine Description:
;
;    Initialize hal pcr values for current processor (if any)
;    (called shortly after processor reaches kernel, before
;    HalInitSystem if P0)
;
;    IPI's and KeReadir/LowerIrq's must be available once this function
;    returns.  (IPI's are only used once two or more processors are
;    available)
;
;   . Enable IPI interrupt (makes sense for P1, P2, ...).
;   . Save Processor Number in PCR.
;   . if (P0)
;       . determine what kind of system is it,
;       . if (NotSysProCompatible) Halt;
;       . program VECTOR_PORT to accept IPI at IRQ13.
;       . InitializePICs.
;   . if (P1)
;   . Save ProcesserControlPort (PCR) to PCRegion, per processor.
;   . Enable PINTs on CPU.
;
;Arguments:
;
;    Number - Logical processor number of calling processor
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalInitializeProcessor ,2
    ;
    ; Initialize various PCR values
    ;     PcIDR in PCR - enable slave IRQ
    ;     PcStallScaleFactor - bogusly large value for now
    ;     PcHal.PcrNumber - logical processor #
    ;     PcHal.PcrPic - Set if processor has it's own pics.
    ;           The SystemPro only defines one pic set on P0, but some clones
    ;           put more pics on each other processor.  This isn't vastly
    ;           better, but it is better then processor.  This isn't vastly 'em
    ;     PcHal.PcrIpiType - Address to jmp to once ipi is verified.
    ;           This is done to optimize how to deal with a varity of 'work-
    ;           arounds' due to non-smp nature of SP clones
    ;

        cli
        mov     fs:PcIDR, 0fffffffbh
        movzx   eax, byte ptr [esp+4]
        mov     fs:PcHal.PcrNumber, al          ; Save processor # in PCR
        lock bts _HalpActiveProcessors, eax
        lock inc _HalpCpuCount
        mov     dword ptr fs:PcStallScaleFactor, INITIAL_STALL_COUNT
        mov     dword ptr fs:PcHal.PcrPerfSkew, 0
        mov     fs:PcHal.PcrIpiSecondLevelDispatch, offset _HalpNo2ndDispatch

    ;
    ; Initialize IDT vector for IPI interrupts
    ;  KiSetHandlerAddressToIDT(I386_80387_VECTOR, HalpIrq13Handler);
    ;
        mov     ebx, fs:PcIDT
        lea     ecx, _HalpIrq13Handler
        add     ebx, (PRIMARY_VECTOR_BASE + 13) * 8
        mov     word ptr [ebx+0], cx
        shr     ecx, 16
        mov     word ptr [ebx+6], cx

    ;
    ; Save away flat address of our PCR - (used in emulating clock ticks
    ; on systempro p1 which doesn't have it's own clock tick)
    ;
        mov     ecx, fs:PcSelfPcr               ; Flat address of this PCR
        mov     _HalpProcessorPCR[eax*4], ecx   ; Save it away


        or      eax, eax
        jnz     ipi_10                          ; If !p0 then ipi_10

        mov     fs:PcHal.PcrPic, 1              ; P0 has a pic
        mov     fs:PcHal.PcrIpiType, offset P0Ipi

    ; Run on P0 only

        sub     esp, 4
        stdCall  _DetectSystemPro,<esp>          ; Which type of SystemPro
        add     esp,4

        or      eax, eax
        jz      NotSystemPro

        lock or _HalpDefaultInterruptAffinity, 1

        cmp     _SpType, SMP_SYSPRO2            ; Belize SystemPro?
        je      short ipi_belize

    ;
    ; Set all processors IPI to irq13
    ;

        mov     al, PRIMARY_VECTOR_BASE + 13
        mov     dx, 0FC68h                      ; Set SystemPro P1 Interrupt
        out     dx, al                          ; Vector to irq13

        cmp     _SpType, SMP_ACER               ; Acer?  Then set other acer
        jne     short ipi_notacer               ; processor ports as well

        mov     dx, 0C028h
        out     dx, al                          ; set P2 Interrupt Vector
        mov     dx, 0C02Ch
        out     dx, al                          ; set P3 Interrupt Vector

        stdCall _HalpAcerInitializeCache

        mov     dx, 0C06h                       ; Check for ASMP or SMP mode
        in      al, dx
        test    al, 10h                         ; SMP mode bit set?
        jz      short @f                        ;  No, then ASMP mode

        cmp     al, 0ffh                        ; Ambra doesn't implement
        je      short @f                        ; this port...


        mov     _Sp8259PerProcessorMode, SP_M8259  ; Set to use multiple pic
@@:     jmp     short ipi_05                       ; implementation

ipi_belize:
    ;
    ; Machine is Belize SystemPro
    ; Set for multiple 8259s, statically distribute device interrupts, and
    ; use symmetric clock interrupt.
    ;

        mov     _Sp8259PerProcessorMode, SP_M8259 + SP_SMPDEVINTS + SP_SMPCLOCK

        stdCall HalpInitializeBelizeIC

ipi_notacer:
ipi_05:
    ; enable IPI vector
        stdCall _HalEnableSystemInterrupt,<PRIMARY_VECTOR_BASE+13,IPI_LEVEL,0>

    ; Other P0 initialization would go here

        jmp     short ipi_30

ipi_10:
        mov     fs:PcHal.PcrIpiType, offset IpiWithNoPic    ; default it

        test    _Sp8259PerProcessorMode, SP_M8259   ; 8259 on this processor?
        jz      short ipi_20

    ;
    ; SP machine is set for SMP mode - which has 2 8259s per processor
    ;
        mov     fs:PcHal.PcrPic, 1              ; Set to use pic on this proc

        cmp     _SpType, SMP_ACER
        jne     short ipi_notacer2
    ;
    ; Machine is in ACER "SMP" mode - well, this fine SMP mode happens
    ; to have an asymmetric clock interrupt, so we need to emulate non-
    ; P0 clock interrupts to it just like we do on the standard SystemPro
    ;
        mov     fs:PcHal.PcrIpiType, offset IpiWithPicButNoClock
        stdCall _HalpInitializePICs, <1>        ; Init this processors PICs

ipi_notacer2:
        cmp     _SpType, SMP_SYSPRO2
        jne     short ipi_notbelize2

    ;
    ; Machine is Belize SystemPro
    ;
        stdCall HalpInitializeBelizeIC

ipi_notbelize2:
    ;
    ; Enable IPI vector for non-P0 cpu
    ;
        stdCall _HalEnableSystemInterrupt,<PRIMARY_VECTOR_BASE+13, IPI_LEVEL,0>

ipi_20:

    ; Specific non-P0 initialization would go here

ipi_30:
        movzx   eax, byte ptr [esp+4]           ; cpu number
        mov     dx, _SpProcessorControlPort[eax*2] ; Port value for this processor

        mov     fs:PcHal.PcrControlPort, dx     ; Save port value
        mov     fs:PcHal.PcrIpiClockTick, 0     ; Set to not signaled

        cmp     _SpType, SMP_SYSPRO2
        je      short @f

        in      al, dx                          ; remove disabled & signaled
        and     al, not (INTDIS or PINT)        ; bits
        out     dx, al
@@:
        stdRET    _HalInitializeProcessor

NotSystemPro:
; on a non system pro. Display message and HALT system.
        stdCall   _HalDisplayString, <offset BadHalString>
        hlt

stdENDP _HalInitializeProcessor


;++
;
; VOID
; HalpInitializeBelizeIC(
;       VOID
;       );
;
;Routine Description:
;
;   Initialize interrupt control for the Belize SystemPro
;
;Return Value:
;
;    None.
;
;--
cPublicProc HalpInitializeBelizeIC, 0
        push    ebx

    ;
    ; Belize IPIs go to Belize Irq13 handler
    ;
        mov     ebx, fs:PcIDT
        lea     ecx, _HalpBelizeIrq13Handler
        add     ebx, (PRIMARY_VECTOR_BASE + 13) * 8
        mov     word ptr [ebx+0], cx
        shr     ecx, 16
        mov     word ptr [ebx+6], cx

    ;
    ; Disable irq13 sources
    ;

        mov     dx, SMP_MPINT13PORT
        mov     al, (SMP_DSBL_NCPERR + SMP_DSBL_DMACHAIN + SMP_DSBL_MCERR)
        out     dx, al

    ;
    ; Disable ipi ports
    ;

        mov     ecx, HALPPINTADDRTABLESIZE
        xor     ebx, ebx
        mov     al,  SMP_INTx_DISABLE
@@:
        mov     dx, _HalpPINTAddrTable[ ebx ]
        out     dx, al
        add     ebx, 2
        loopnz  short @b

        stdCall _HalpInitializePICs, <1>       ; Init this processors PICs

    ;
    ; Enable PINT
    ;

        mov     dx, SMP_IPI_MPINTx_PORT
        mov     al, SMP_INTx_ENABLE + SMP_INTx_CLR_PINT
        out     dx, al

        pop     ebx
        stdRet  HalpInitializeBelizeIC
stdENDP HalpInitializeBelizeIC


;++
;
; VOID
; HalRequestIpi(
;       IN ULONG Mask
;       );
;
;Routine Description:
;
;    Requests an interprocessor interrupt
;
;Arguments:
;
;    Mask - Supplies a mask of the processors to be interrupted
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalRequestIpi  ,1

        cmp     _SpType, SMP_SYSPRO2
        jne     short ripi_10
        
        mov     eax, dword ptr [esp+4]      ; (eax) = Processor bitmask
if DBG
        or      eax, eax                    ; must ipi somebody
        jz      short ipibad

        movzx   ecx, byte ptr fs:PcHal.PcrNumber
        bt      eax, ecx                    ; cannot ipi yourself
        jc      short ipibad
endif

        mov     dx, SMP_IPI_MASKPORT
        or      eax, (SMP_IPI_VECTOR shl 24)
        out     dx, eax
        stdRET  _HalRequestIpi


ALIGN 4
ripi_10:
        mov     ecx, dword ptr [esp+4]      ; (ecx)  = Processor bitmask

if DBG
        or      ecx, ecx                    ; must ipi somebody
        jz      short ipibad

        movzx   eax, byte ptr fs:PcHal.PcrNumber
        bt      ecx, eax                    ; cannot ipi yourself
        jc      short ipibad
endif
@@:
        movzx   eax, _HalpFindFirstSetRight[ecx] ; lookup first processor to ipi
        btr     ecx, eax
        mov     dx, _SpProcessorControlPort[eax*2]
        in      al, dx                      ; (al) = original content of PCP
        or      al, PINT                    ; generate Ipi on target
        out     dx, al
        or      ecx, ecx                    ; ipi any other processors?
        jnz     @b                          ; yes, loop

        stdRET    _HalRequestIpi

if DBG
ipibad: int 3
        stdRET    _HalRequestIpi
endif

stdENDP _HalRequestIpi


        page ,132
        subttl  "SystemPro Irq13 Interrupt Handler"
;++
;
; VOID
; HalpIrq13Handler (
;    );
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by inter
;    processor communication or coprocessor error.
;    Its function is to determine the sources of the interrupts and to
;    call its handler.
;
;    If the interrupt is determined to be generated by coprocessor error,
;    this routine will lower irql to its original level, and finally invoke
;    coprocessor error handler.  By doing this, the coprocessor
;    error will be handled at Irql 0 as it should be.
;
;    N.B. This routine is specific to Compaq SystemPro.  On SystemPro, the
;    IRQ13 of P0 is also used by DMA buffer chaining interrupt.  Currently,
;    NO NT driver uses the DMA buffer chaining capability.  For now, this
;    routine simply ignores it.
;
; Arguments:
;
;    None.
;    Interrupt is dismissed
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST Hi13_a, Hi13_t

cPublicProc _HalpIrq13Handler       ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hi13_a, Hi13_t  ; (ebp) -> Trap frame
;
; Save previous IRQL
;
        push    13 + PRIMARY_VECTOR_BASE    ; Vector
        sub     esp, 4                      ; space for OldIrql
;
; Dismiss interrupt.
;
        mov     dx, fs:PcHal.PcrControlPort

        in      al, dx
        test    al, PINT
        jz      Hi100                       ; if not a PINT, then go Hi100

;
; The interrupt has been identified to be Inter-Processor Interrupt
; We now dismiss the interprocessor interrupt and call its handler
;

        and     al, not (PINT or INTDIS)
        out     dx, al                      ; clear PINT

        jmp     fs:[PcHal.PcrIpiType]       ; Go handle ipi accordingly

align 4
IpiWithNoPic:
;
; This processor doesn't have a PIC
;
        cmp     byte ptr fs:PcIrql, IPI_LEVEL   ; is preview IRQL level
        jnc     short Ksi20                     ; >= IPI_LEVEL?


    ; WARNING: Some SystemPro's actually don't complete the OUT to the
    ; ProcessorControlRegister by the return of the OUT instruction.  This
    ; code path can do a 'sti' before the pending interrupt bit is cleared
    ; on these machines.  To get around this problem we do an IN from the
    ; ProcessorControlPort again which will cause the last OUT to complete
    ; before the IN can.
        in      al, dx

        stdCall   _KeRaiseIrql, <IPI_LEVEL,esp>

;
; It also doesn't have it's own clock interrupt, see if clock interrupt
; emulation is requested - if so raise a software interrupt to go emulate
; it when we reach a lower IRQL
;
        cmp     fs:PcHal.PcrIpiClockTick, 0     ; Emulate ClockTick?
        jz      short Ksi30                         ; No, just go service ipi

        mov     fs:PcHal.PcrIpiClockTick, 0     ; yes, reset trigger
        or      dword ptr fs:PcIRR, SWClockTick ; Set SW ClockTick bit
        jmp     short Ksi30                     ; go process ipi

Ksi20:
;
; This processor is >= IPI_LEVEL, this IPI should not be here.
;
        in      al, dx
        or      al, PINT                        ; re-post this IPI
        out     dx, al
                                                ; clear IF bit in return EFLAGS
        add     esp, 8
        and     dword ptr [esp].TsEflags, NOT 200h
        SPURIOUS_INTERRUPT_EXIT

align 4
IpiWithPicButNoClock:
        cmp     fs:PcHal.PcrIpiClockTick, 0     ; Emulate ClockTick?
        jz      short SymmetricIpi

        mov     fs:PcHal.PcrIpiClockTick, 0
        or      dword ptr fs:PcIRR, SWClockTick ; Set SW ClockTick bit

align 4
P0Ipi:
SymmetricIpi:
        stdCall _HalBeginSystemInterrupt,<IPI_LEVEL,13 + PRIMARY_VECTOR_BASE,esp>
;       or      eax, eax            NOTNOW: To add lazy irql support, this
;       jz      short KsiSpuripus   needs to be added - and IpiWithNoPic
;                                   would need fixed as well

Ksi30:
; Pass Null ExceptionFrame
; Pass TrapFrame to Ipi service rtn
        stdCall _KiIpiServiceRoutine, <ebp,0>

Hi90:   call    fs:[PcHal.PcrIpiSecondLevelDispatch]

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT                          ; will return to caller

Hi100:
        mov     esi, eax                        ; save control register
        mov     edi, edx                        ; save control port

        cmp     byte ptr fs:PcHal.PcrPic, 0     ; A pic on this processor?
        je      short Hi120

        stdCall _HalBeginSystemInterrupt, <IPI_LEVEL,13 + PRIMARY_VECTOR_BASE,esp>
        jmp     short Hi130
Hi120:
        stdCall   _KeRaiseIrql, <IPI_LEVEL,esp>
Hi130:
        test    esi, ERR387                     ; Interrupt from 387?
        jz      short Hi90                      ; No, then unkown exit

        xor     al,al
        out     I386_80387_BUSY_PORT, al

        mov     eax, esi
        and     eax, NOT ERR387
        mov     edx, edi
        out     dx, al                          ; clear ERR387

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbCpuType, 4     ; Is this a 386?
        jc      short Hi40                      ; Yes, then don't check CR0_NE

        mov     eax, cr0                        ; Is CR0_NE set?  If so, then
        test    eax, CR0_NE                     ; we shouldn't be getting NPX
        jnz     short Hi50                      ; interrupts.
Hi40:
        stdCall   _KiCoprocessorError           ; call CoprocessorError handler
Hi50:

;
; We did an out to the ProcessorControl port which might have cleared a
; pending interrupt (PINT) bit.  Go process ipi handler just in case.
;
        jmp     Ksi30

stdENDP _HalpIrq13Handler


;++
;
; VOID
; HalpBelizeIrq13Handler (
;    );
;
; Routine Description:
;
;    Same as HalpIrql13Handler, expect specific to the Belize SyetemPro
;
; Arguments:
;
;    None.
;    Interrupt is dismissed
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST Hib13_a, Hib13_t

cPublicProc _HalpBelizeIrq13Handler       ,0
        ENTER_INTERRUPT Hib13_a, Hib13_t    ; (ebp) -> Trap frame

        push    13 + PRIMARY_VECTOR_BASE    ; Vector
        sub     esp, 4                      ; space for OldIrql

        stdCall _HalBeginSystemInterrupt,<IPI_LEVEL,13 + PRIMARY_VECTOR_BASE,esp>

        mov     dx, SMP_IPI_MPINTx_PORT
        in      al, dx                      ; read clears pending int

        stdCall _KiIpiServiceRoutine, <ebp,0>

        call    fs:[PcHal.PcrIpiSecondLevelDispatch]


;
; Do interrupt exit processing
;

        INTERRUPT_EXIT                          ; will return to caller


stdENDP _HalpBelizeIrq13Handler

;++
;
; VOID
; HalpNoSecondDispatch (
;     VOID
;     )
;
; Routine Description:
;
;   Does nothing
;--
cPublicProc _HalpNo2ndDispatch,0
        stdRET  _HalpNo2ndDispatch
stdENDP _HalpNo2ndDispatch



;++
;
; ULONG
; FASTCALL
; HalSystemVectorDispatchEntry (
;     IN ULONG Vector,
;     OUT PKINTERRUPT_ROUTINE **FlatDispatch,
;     OUT PKINTERRUPT_ROUTINE *NoConnection
;     )
;
; Routine Description:
;
;   If TRUE, returns dispatch address for vector; otherwise, IDT dispatch is
;   assumed
;
; Arguments:
;
;   Vector          - System Vector to get dispatch address of
;   FlatDispatch    - Returned dispatched address for system vector
;   NoConnection    - Returned "no connection" dispatch value for system vector
;
;--

cPublicFastCall HalSystemVectorDispatchEntry,3

        xor     eax, eax                ; reutrn FALSE

        cmp     ecx, PRIMARY_VECTOR_BASE + SECOND_IPI_DISPATCH
        jne     short hsvexit

        inc     eax                     ; return TRUE

        mov     ecx, PCR[PcSelfPcr]     ; return FlatDispatch
        add     ecx, PcHal.PcrIpiSecondLevelDispatch
        mov     [edx], ecx

        mov     ecx, [esp+4]            ; return NoConnection
        mov     [ecx], offset _HalpNo2ndDispatch

hsvexit:
        fstRET  HalSystemVectorDispatchEntry
fstENDP HalSystemVectorDispatchEntry


_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    spirql.asm
;
; Abstract:
;
;    SystemPro IRQL
;
;    This module implements the code necessary to raise and lower i386
;    Irql and dispatch software interrupts with the 8259 PIC.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    John Vert (jvert) 27-Nov-1991
;       Moved from kernel into HAL
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include i386\spmp.inc
        .list


        EXTRNP  _KeBugCheck,1,IMPORT

        extrn   _HalpApcInterrupt:near
        extrn   _HalpDispatchInterrupt:near
        extrn   _HalpSWNonPrimaryClockTick:near
        extrn   _HalpApcInterrupt2ndEntry:NEAR
        extrn   _HalpDispatchInterrupt2ndEntry:NEAR
        extrn   _HalpSWNonPrimaryClockTick2ndEntry:NEAR
        extrn   _KiUnexpectedInterrupt:near

;
; Initialization control words equates for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

OCW2_NON_SPECIFIC_EOI           equ     020H
OCW2_SPECIFIC_EOI               equ     060H
OCW2_SET_PRIORITY               equ     0c0H

PIC_SLAVE_IRQ                   equ     2
PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

;
; Define the constants of Edge level Pic control.
;
; Background: Compaq Belize systems have an 8259 per processor and
; their own private Edge Level control registers (4d0,4d1).
;

EDGELEVEL_CONTROL_1             equ     4D0H
EDGELEVEL_CONTROL_2             equ     4D1H

;

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

;
; PICsInitializationString - Master PIC initialization command string
;

PICsInitializationString   dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string

PS2PICsInitializationString        dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string


            align   4
            public  KiI8259MaskTable
KiI8259MaskTable    label   dword
                dd      00000000000000000000000000000000B ; irql 0
                dd      00000000000000000000000000000000B ; irql 1
                dd      00000000000000000000000000000000B ; irql 2
                dd      00000000000000000000000000000000B ; irql 3
                dd      00000000000000000000000000000000B ; irql 4
                dd      11111111110000000000000000000000B ; irql 5
                dd      11111111111000000000000000000000B ; irql 6
                dd      11111111111100000000000000000000B ; irql 7
                dd      11111111111110000000000000000000B ; irql 8
                dd      11111111111111000000000000000000B ; irql 9
                dd      11111111111111100000000000000000B ; irql 10
                dd      11111111111111110000000000000000B ; irql 11
                dd      11111111111111111000000000000000B ; irql 12
                dd      11111111111111111100000000000000B ; irql 13
                dd      11111111111111111100000000000000B ; irql 14
                dd      11111111111111111101000000000000B ; irql 15
                dd      11111111111111111101100000000000B ; irql 16
                dd      11111111111111111101110000000000B ; irql 17
                dd      11111111111111111101111000000000B ; irql 18
                dd      11111111111111111101111000000000B ; irql 19
                dd      11111111111111111101111010000000B ; irql 20
                dd      11111111111111111101111011000000B ; irql 21
                dd      11111111111111111101111011100000B ; irql 22
                dd      11111111111111111101111011110000B ; irql 23
                dd      11111111111111111101111011111000B ; irql 24
                dd      11111111111111111101111011111000B ; irql 25
                dd      11111111111111111101111011111010B ; irql 26
                dd      11111111111111111101111111111010B ; irql 27
                dd      11111111111111111101111111111011B ; irql 28
                dd      11111111111111111111111111111011B ; irql 29
                dd      11111111111111111111111111111011B ; irql 30
                dd      11111111111111111111111111111011B ; irql 31
;                                         |
;                                         32109876543210
;                                         |
;                                         + - Raise SystemPros IPI vector (13)
;                                             to IPI_LEVEL
        align   4
;
; The following tables define the addresses of software interrupt routers
;

;
; Use this table if there is NO machine state frame on stack already
;

        public  SWInterruptHandlerTable
SWInterruptHandlerTable label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt           ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt      ; irql 2
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 3
        dd      offset FLAT:_HalpSWNonPrimaryClockTick  ; irql 4

;
; Use this table if there is a machine state frame on stack already
;

        public  SWInterruptHandlerTable2
SWInterruptHandlerTable2 label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt2ndEntry   ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2ndEntry ; irql 2
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 3
        dd      offset FLAT:_HalpSWNonPrimaryClockTick2ndEntry ; irql 4

;
; The following table picks up the highest pending software irq level
; from software irr
;

        public  SWInterruptLookUpTable
SWInterruptLookUpTable label byte
        db      0               ; SWIRR=0, so highest pending SW irql= 0
        db      0               ; SWIRR=1, so highest pending SW irql= 0
        db      1               ; SWIRR=2, so highest pending SW irql= 1
        db      1               ; SWIRR=3, so highest pending SW irql= 1
        db      2               ; SWIRR=4, so highest pending SW irql= 2
        db      2               ; SWIRR=5, so highest pending SW irql= 2
        db      2               ; SWIRR=6, so highest pending SW irql= 2
        db      2               ; SWIRR=7, so highest pending SW irql= 2
        db      3               ; SWIRR=8, so highest pending SW irql= 3
        db      3               ; SWIRR=9, so highest pending SW irql= 3
        db      3               ; SWIRR=A, so highest pending SW irql= 3
        db      3               ; SWIRR=B, so highest pending SW irql= 3
        db      3               ; SWIRR=C, so highest pending SW irql= 3
        db      3               ; SWIRR=D, so highest pending SW irql= 3
        db      3               ; SWIRR=E, so highest pending SW irql= 3
        db      3               ; SWIRR=F, so highest pending SW irql= 3

        db      4               ; SWIRR=10, so highest pending SW irql= 4
        db      4               ; SWIRR=11, so highest pending SW irql= 4
        db      4               ; SWIRR=12, so highest pending SW irql= 4
        db      4               ; SWIRR=13, so highest pending SW irql= 4
        db      4               ; SWIRR=14, so highest pending SW irql= 4
        db      4               ; SWIRR=15, so highest pending SW irql= 4
        db      4               ; SWIRR=16, so highest pending SW irql= 4
        db      4               ; SWIRR=17, so highest pending SW irql= 4
        db      4               ; SWIRR=18, so highest pending SW irql= 4
        db      4               ; SWIRR=19, so highest pending SW irql= 4
        db      4               ; SWIRR=1A, so highest pending SW irql= 4
        db      4               ; SWIRR=1B, so highest pending SW irql= 4
        db      4               ; SWIRR=1C, so highest pending SW irql= 4
        db      4               ; SWIRR=1D, so highest pending SW irql= 4
        db      4               ; SWIRR=1E, so highest pending SW irql= 4
        db      4               ; SWIRR=1F, so highest pending SW irql= 4


_TEXT ends

_DATA   SEGMENT DWORD PUBLIC 'DATA'

;
; Only P0 has its Edge Level masks on port 4d0 and port 4d1 setup
; correctly.  We hold the P0 values here for the other processors.
;
                align   4
                public  _SpP0EdgeLevelValue
_SpP0EdgeLevelValue dw  0

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        PAGE
        SUBTTL  "Raise Irql"
;++
;
; KIRQL
; FASTCALL
; KfRaiseIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    Also, a mask will be used to mask off all the lower lever 8259
;    interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0,0

        xor     eax, eax                ; avoid partial stall
        mov     al, fs:PcIrql           ; get current irql
        pushfd                          ; save caller's eflags
cPublicFpo 0,1

if DBG
        cmp     al,cl                    ; old > new?
        jbe     short Kri99              ; no, we're OK
        movzx   eax, al
        movzx   ecx, cl
        push    ecx                      ; put new irql where we can find it
        push    eax                      ; put old irql where we can find it
        mov     byte ptr fs:PcIrql,0     ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>
align 4
Kri99:
endif
        cli                             ; disable interrupt

        cmp     byte ptr fs:PcHal.PcrPic, 0
        je      PxRaiseIrql              ; dispatch according to processor

@@:
; P0RaiseIrql
        cmp     cl,DISPATCH_LEVEL       ; software level?
        mov     fs:PcIrql, cl           ; set the new irql
        jbe     short kri10             ; go skip setting 8259 hardware

        movzx   ecx, cl
        mov     dl, al                  ; Save OldIrql
        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, fs:PcIDR           ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks
        mov     al, dl                  ; Restore OldIrql

kri10:  popfd                           ; restore flags (including interrupts)
        fstRET    KfRaiseIrql


align 4
PxRaiseIrql:
;
; Even though SystemPro P2 cannot touch 8259 ports, we still need to
; make sure interrupts are off when requested to raise to IPI_LEVEL or
; above.
;
        cmp     cl, IPI_LEVEL           ; If raise to IPI_LEVEL?
        jb      short @f                ; if ne, don't edit flag

        and     dword ptr [esp], NOT EFLAGS_IF ; clear IF bit in return EFLAGS
align 4
@@:
        mov     fs:PcIrql, cl           ; set the new irql
        popfd                           ; restore flags (including interrupts)
        fstRET  KfRaiseIrql


fstENDP KfRaiseIrql


;++
;
; VOID
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;    The APIC TPR is used to block all lower-priority HW interrupts.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        mov     ecx, DISPATCH_LEVEL
        jmp     @KfRaiseIrql

stdENDP _KeRaiseIrqlToDpcLevel


;++
;
; VOID
; KIRQL
; KeRaiseIrqlToSynchLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;    The APIC TPR is used to block all lower-priority HW interrupts.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0

        mov     ecx, SYNCH_LEVEL
        jmp     @KfRaiseIrql

stdENDP _KeRaiseIrqlToSynchLevel


        page ,132
        subttl  "Lower irql"

;++
;
; VOID
; FASTCALL
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KfLowerIrql,1

        pushfd                          ; save caller's eflags
if DBG
        cmp     cl,fs:PcIrql
        jbe     short Kli99
        movzx   ecx, cl
        push    ecx                     ; new irql for debugging
        push    fs:PcIrql               ; old irql for debugging
        mov     byte ptr fs:PcIrql,HIGH_LEVEL   ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_LESS_OR_EQUAL>
align 4
Kli99:
endif
        cli

        cmp     byte ptr fs:PcHal.PcrPic, 0
        je      PxLowerIrql              ; dispatch according to processor

@@:
; P1LowerIrql:
        cmp     byte ptr fs:PcIrql,DISPATCH_LEVEL ; Software level?
        jbe     short kli02             ; yes, go skip setting 8259 hw

        movzx   ecx, cl
        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, fs:PcIDR           ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

kli02:  mov     fs:PcIrql, cl           ; set the new irql
        mov     eax, fs:PcIRR           ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short Kli10             ; yes, go simulate interrupt

        popfd                           ; restore flags, including ints
        fstRET  KfLowerIrql

;   When we come to Kli10, (eax) = soft interrupt index

align 4
Kli10:
        call     SWInterruptHandlerTable[eax*4] ; SIMULATE INTERRUPT
                                                ; to the appropriate handler
        popfd
        fstRET    KfLowerIrql

PxLowerIrql:
        cmp     cl, IPI_LEVEL           ; If lower to IPI_LEVEL?
                                        ; cy = yes
        sbb     edx, edx                ; edx = 0 (nc), -1 (cy)
        and     edx, EFLAGS_IF
        or      dword ptr [esp], edx    ; set EFLAG_IF if irql<IPI_LEVEL

        mov     fs:PcIrql, cl           ; set the new irql
        mov     eax, fs:PcIRR           ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short Kli10             ; yes, go simulate interrupt

        popfd                           ; restore flags, including ints
        fstRET  KfLowerIrql

fstENDP KfLowerIrql

;++
;
; VOID
; HalpEndSystemInterrupt
;    IN KIRQL NewIrql,
;    IN ULONG Vector
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Vector - Vector number of the interrupt
;
;    Note that esp+8 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HeiNewIrql      equ     [esp + 4]

cPublicProc _HalEndSystemInterrupt  ,2

        xor     ecx, ecx
        mov     cl, byte ptr HeiNewIrql ; get new irql value

        cmp     byte ptr fs:PcHal.PcrPic, 0
        je      short Hei02

; P1LowerIrql:
        cmp     byte ptr fs:PcIrql, DISPATCH_LEVEL ; Software level?
        jbe     short Hei02             ; yes, go skip setting 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, fs:PcIDR           ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

;
; Unlike KeLowerIrql, we don't check if the the irql is lowered to
; below IPI level and enable interrupt for second processor.  This is because
; the correct interrupt flag is already stored in the TsEflags of Trap frame.
;

align 4
Hei02:  mov     fs:PcIrql, cl           ; set the new irql
        mov     eax, fs:PcIRR           ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short Hei10             ; yes, go simulate interrupt

        stdRET    _HalEndSystemInterrupt                             ; cRetURN

;   When we come to Kli10, (eax) = soft interrupt index
align 4
Hei10:  add     esp, 12
        jmp     SWInterruptHandlerTable2[eax*4] ; SIMULATE INTERRUPT
                                               ; to the appropriate handler
stdENDP _HalEndSystemInterrupt

;++
;
; VOID
; HalpEndSoftwareInterrupt
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL from software interrupt
;    level to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+8 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HesNewIrql      equ     [esp + 4]

cPublicProc     _HalpEndSoftwareInterrupt,1
cPublicFpo  1,0
        mov     ecx, [esp+4]
        fstCall KfLowerIrql
        cli
        stdRet  _HalpEndSoftwareInterrupt
stdENDP _HalpEndSoftwareInterrupt

        page ,132
        subttl  "Get current irql"

;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0
        movzx   eax,byte ptr fs:PcIrql         ; Current irql is in the PCR
        stdRET    _KeGetCurrentIrql
stdENDP _KeGetCurrentIrql


;++
;
; KIRQL
; HalpDisableAllInterrupts (VOID)
;
; Routine Description:
;
;   This routine is called during a system crash.  The hal needs all
;   interrupts disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None - all interrupts are masked off
;
;--

cPublicProc _HalpDisableAllInterrupts,0

    ;
    ; Raising to HIGH_LEVEL disables interrupts for the SystemPro HAL
    ;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql
        stdRET  _HalpDisableAllInterrupts

stdENDP _HalpDisableAllInterrupts

;++
;
; VOID
; HalpReenableInterrupts (
;     IN KIRQL Irql
;     )
;
; Routine Description:
;
;   Restores irql level.
;
; Arguments:
;
;    Irql - Irql state to restore to.
;
; Return Value:
;
;    None
;
;--

HriNewIrql      equ     [esp + 4]

cPublicProc _HalpReenableInterrupts,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HriNewIrql
        fstCall KfLowerIrql

        stdRET  _HalpReenableInterrupts

stdENDP _HalpReenableInterrupts


        page ,132
        subttl  "Interrupt Controller Chip Initialization"
;++
;
; VOID
; HalpInitializePICs (
;    )
;
; Routine Description:
;
;    This routine sends the 8259 PIC initialization commands and
;    masks all the interrupts on 8259s.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializePICs       ,1

        pushfd
        push    esi                             ; save caller's esi
        cli                                     ; disable interrupt
        lea     esi, PICsInitializationString

        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        mov     al, 0FFH                        ; mask all 8259 irqs
        out     dx,al                           ; write mask to PIC
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

    ;
    ; If P0 then squirrel away 4d0 and 4d1 for the other processor to use.
    ;

        cmp     byte ptr fs:PcHal.PcrNumber, 0   ; Is this processor 0
        jne     short Hip16

        mov     dx, EDGELEVEL_CONTROL_2          ; Yes then save 4d0-4d1
        in      al, dx
        shl     eax, 8
        mov     dx, EDGELEVEL_CONTROL_1
        in      al, dx
        mov     _SpP0EdgeLevelValue, ax

        jmp     short Hip18

    ;
    ; If not P0 then program 4d0 and 4d1 to the values P0 used for them!
    ;
Hip16:
        mov     ax, _SpP0EdgeLevelValue
        mov     dx, EDGELEVEL_CONTROL_1
        out     dx, al
        inc     edx
        shr     eax, 8
        mov     dx, EDGELEVEL_CONTROL_2
        out     dx, al

Hip18:

        pop     esi                             ; restore caller's esi
        popfd                                   ; restore interrupts
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spreboot.asm ===
title "SystemPro reboot"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    spreboot.asm
;
;Abstract:
;
;    SystemPro reboot code.
;
;Author:
;
;    Ken Reneris (kenr) 13-Jan-1992
;
;Revision History:
;
;--
.386p
        .xlist

include hal386.inc
include i386\kimacro.inc
include i386\ix8259.inc
include callconv.inc                ; calling convention macros
include i386\spmp.inc

        EXTRNP  _HalRequestIpi,1
        EXTRNP  _KeStallExecutionProcessor,1

        extrn   _SpProcessorControlPort:WORD
        extrn   _SpCpuCount:BYTE
        extrn   _SpType:BYTE
        extrn   _HalpProcessorPCR:DWORD


;
; Defines to let us diddle the CMOS clock and the keyboard
;

CMOS_CTRL   equ     70h
CMOS_DATA   equ     71h

KEYB_RESET  equ     0feh
KEYB_PORT   equ     64h


_TEXT   SEGMENT DWORD PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpResetAllProcessors (
;       VOID
;       );
;
;Routine Description:
;
;   Called at last phase of reboot code.
;
;   Some SystemPro clones do not reboot properly by having the keyboard
;   issue a reset.  (The bootup roms do not reset the other processors
;   properly).
;
;   To work around this, we attempt to use P0 to halt all the other
;   processors before reseting the computer.
;
;   Note: P0 may not respond to an IPI if it's stuck or in the debugger.
;   In this case we will just use the current processor to reset the
;   computer.  This will not work on every machine, but the machine
;   was in some sort of crashed state to begin with.  (it does work
;   on all compaq SystemPros).
;
;   N.B.
;
;       will not return
;
;--

cPublicProc _HalpResetAllProcessors, 0

;
; Belize SystemPros can not halt processors in the same manner; however
; simply resetting the machine via the keyboard controller works - so
; skip this code on a belize.
;
        cmp     _SpType, SMP_SYSPRO2
        je      rb20                        ; Belize, just reset

        cmp     byte ptr fs:PcHal.PcrNumber, 0      ; boot processor?
        je      HalpRebootNow                       ; Yes, reset everyone

;
; Try signal the boot processor to perform the reboot
;
        mov     ecx, offset FLAT:HalpRebootNow      ; Zap P0's IPI handler
        mov     eax, _HalpProcessorPCR[0]           ; be reboot function
        xchg    [eax].PcHal.PcrIpiType, ecx

        stdCall _HalRequestIpi,<1>                  ; Send P0 an IPI
        stdCall _KeStallExecutionProcessor,<50000>  ; Let P0 reboot us

;
; P0 didn't reboot the machine - just do it with the current processor
;

HalpRebootNow:
        xor     ecx, ecx

rb10:   cmp     cl, _SpCpuCount             ; halt each processor
        jae     short rb20


        mov     dx, _SpProcessorControlPort[ecx*2]
        in      al, dx                      ; (al) = original content of PCP
        or      al, INTDIS                  ; Disable IPI interrupt

        cmp     cl, fs:PcHal.PcrNumber      ; cl == currentprocessor?
        je      short @f                    ; don't halt ourselves
        or      al, SLEEP

        cmp     _SpType, SMP_ACER           ; On acer MP machines
        jne     short @f                    ; reset other processors
        or      al, RESET                   ; (not tested to work on other
                                            ;  other machines)
@@:     out     dx, al

        inc     ecx
        jmp     short rb10

rb20:
        xor     eax, eax

;
; Send the reset command to the keyboard controller
;

        mov     edx, KEYB_PORT
        mov     al,  KEYB_RESET
        out     dx, al

@@:     hlt
        jmp     @b

stdENDP _HalpResetAllProcessors

_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spspin.asm ===
if NT_INST

else
        TITLE   "Spin Locks"
;++
;
;  Copyright (c) 1989  Microsoft Corporation
;
;  Module Name:
;
;     spinlock.asm
;
;  Abstract:
;
;     This module implements stubbed x86 spinlock functions for
;     any HAL.  Some HALs may implement these function directly
;     to minimize the amount of code required to perform a spinlock.
;     (ie, out Raise & Lower irql in the fall through path)
;
;  Author:
;
;     Bryan Willman (bryanwi) 13 Dec 89
;
;  Environment:
;
;     Kernel mode only.
;
;  Revision History:
;
;   Ken Reneris (kenr) 22-Jan-1991
;--

        PAGE

.486p

include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include hal386.inc
include mac386.inc

        EXTRNP  KfRaiseIrql,1,,FASTCALL
        EXTRNP  KfLowerIrql,1,,FASTCALL
        EXTRNP  _KeBugCheck,1,IMPORT
        EXTRNP _KeSetEventBoostPriority, 2, IMPORT
        EXTRNP _KeWaitForSingleObject,5, IMPORT

ifdef NT_UP
    LOCK_ADD  equ   add
    LOCK_DEC  equ   dec
else
    LOCK_ADD  equ   lock add
    LOCK_DEC  equ   lock dec
endif


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        PAGE
        SUBTTL "Acquire Kernel Spin Lock"
;++
;
;  KIRQL
;  FASTCALL
;  KfAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function raises to DISPATCH_LEVEL and then acquires a the
;     kernel spin lock.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql  - pointer to place old irql
;
;--

align 16
cPublicFastCall KfAcquireSpinLock  ,1
cPublicFpo 0,0


;
; On a MP build we raise to dispatch_level
; and then acquire the spinlock
;

        push    ecx                 ; Save address of spinlock

        mov     ecx, DISPATCH_LEVEL
        fstCall KfRaiseIrql         ; (al) = OldIrql

        pop     ecx                 ; (ecx) -> spinlock

;
;   Attempt to assert the lock
;

sl10:   ACQUIRE_SPINLOCK    ecx,<short sl20>

        fstRET    KfAcquireSpinLock

;
;   Lock is owned, spin till it looks free, then go get it again.
;

sl20:   SPIN_ON_SPINLOCK    ecx,sl10


fstENDP KfAcquireSpinLock

        PAGE
        SUBTTL "Acquire Synch Kernel Spin Lock"
;++
;
;  KIRQL
;  FASTCALL
;  KeAcquireSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function acquires the SpinLock at SYNCH_LEVEL.  The function
;     is optmized for hoter locks (the lock is tested before acquired,
;     any spin should occur at OldIrql)
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql  - pointer to place old irql
;
;--

align 16
cPublicFastCall KeAcquireSpinLockRaiseToSynch,1
cPublicFpo 0,0

;
; Disable interrupts
;

sls10:  cli

;
; Try to obtain spinlock.  Use non-lock operation first
;
        TEST_SPINLOCK       ecx,<short sls20>
        ACQUIRE_SPINLOCK    ecx,<short sls20>


;
; Got the lock, raise to SYNCH_LEVEL
;

        mov     ecx, SYNCH_LEVEL
        fstCall KfRaiseIrql         ; (al) = OldIrql

;
; Enable interrupts and return
;

        sti
        fstRET  KeAcquireSpinLockRaiseToSynch


;
;   Lock is owned, spin till it looks free, then go get it again.
;

sls20:  sti
        SPIN_ON_SPINLOCK    ecx,sls10

fstENDP KeAcquireSpinLockRaiseToSynch


        PAGE
        SUBTTL "Release Kernel Spin Lock"

;++
;
;  VOID
;  FASTCALL
;  KfReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN KIRQL       NewIrql
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock and lowers to the new irql
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to an executive spin lock.
;     (dl)  = NewIrql  - New irql value to set
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KfReleaseSpinLock ,2
cPublicFpo 0,0

ifndef NT_UP
        RELEASE_SPINLOCK    ecx     ; release it
endif
        mov     ecx, edx            ; (ecx) = NewIrql
        jmp     @KfLowerIrql@4      ; to KeLowerIrql

fstENDP KfReleaseSpinLock

;++
;
;  VOID
;  FASTCALL
;  ExAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquire ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExAcquireFastMutex,1
cPublicFpo 0,1

        push    ecx                             ; Push FAST_MUTEX addr
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql

        pop     ecx                             ; (ecx) = Fast Mutex

cPublicFpo 0,0
   LOCK_DEC     dword ptr [ecx].FmCount         ; Get count
        jz      short afm_ret                   ; The owner? Yes, Done

        inc     dword ptr [ecx].FmContention

cPublicFpo 0,1
        push    ecx
        push    eax
        add     ecx, FmEvent                    ; Wait on Event
        stdCall _KeWaitForSingleObject,<ecx,WrExecutive,0,0,0>
        pop     eax
        pop     ecx

cPublicFpo 0,0
afm_ret:
        mov     byte ptr [ecx].FmOldIrql, al
        fstRet  ExAcquireFastMutex

fstENDP ExAcquireFastMutex

;++
;
;  BOOLEAN
;  FASTCALL
;  ExTryToAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquire ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex  - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     Returns TRUE if the FAST_MUTEX was acquired; otherwise false
;
;--

cPublicFastCall ExTryToAcquireFastMutex,1
cPublicFpo 0,0

;
; Try to acquire
;
        cmp     dword ptr [ecx].FmCount, 1      ; Busy?
        jne     short tam25                     ; Yes, abort

cPublicFpo 0,1
        push    ecx                             ; Push FAST_MUTEX
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql                     ; (al) = OldIrql

        mov     ecx, [esp]                      ; Restore FAST_MUTEX
        mov     [esp], eax                      ; Save OldIrql

        mov     eax, 1                          ; Value to compare against
        mov     edx, 0                          ; Value to set
   lock cmpxchg dword ptr [ecx].FmCount, edx    ; Attempt to acquire
        jnz     short tam20                     ; got it?

cPublicFpo 0,0
        pop     edx                             ; (edx) = OldIrql
        mov     eax, 1                          ; return TRUE
        mov     byte ptr [ecx].FmOldIrql, dl    ; Store OldIrql
        fstRet  ExTryToAcquireFastMutex

tam20:  pop     ecx                             ; (ecx) = OldIrql
        fstCall KfLowerIrql                     ; restore OldIrql
tam25:  xor     eax, eax                        ; return FALSE
        fstRet  ExTryToAcquireFastMutex         ; all done

fstENDP ExTryToAcquireFastMutex


;++
;
;  VOID
;  FASTCALL
;  ExReleaseFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function releases ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExReleaseFastMutex,1

cPublicFpo 0,0
        mov     al, byte ptr [ecx].FmOldIrql    ; (cl) = OldIrql

   LOCK_ADD     dword ptr [ecx].FmCount, 1  ; Remove our count
        xchg    ecx, eax                        ; (cl) = OldIrql
        js      short rfm05                     ; if < 0, set event
        jnz     @KfLowerIrql@4                  ; if != 0, don't set event

rfm05:  add     eax, FmEvent
        push    ecx
        stdCall _KeSetEventBoostPriority, <eax, 0>
        pop     ecx
        jmp     @KfLowerIrql@4


fstENDP ExReleaseFastMutex


_TEXT   ends

ENDIF   ; NT_INST

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spsproca.asm ===
title "MP primitives for Compaq SystemPro"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    spsproca.asm
;
;Abstract:
;
;   SystemPro Start Next Processor assemble code
;
;   This module along with mpspro.c implement the code to start
;   off the second processor on the Compaq SystemPro.
;
;Author:
;
;   Ken Reneris (kenr) 12-Jan-1992
;
;Revision History:
;
;--



.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include i386\spmp.inc
        .list

        EXTRNP  _HalpBuildTiledCR3,1
        EXTRNP  _HalpFreeTiledCR3,0

        extrn   _MppIDT:DWORD
        extrn   _MpLowStub:DWORD
        extrn   _MpLowStubPhysicalAddress:DWORD
        extrn   _MpCount:DWORD
        extrn   _SpProcessorControlPort:WORD
        extrn   _SpType:BYTE


;
;   Internal defines and structures
;

PxParamBlock struc
    SPx_flag        dd  ?
    SPx_TiledCR3    dd  ?
    SPx_P0EBP       dd  ?
    SPx_ControlPort dd  ?
    SPx_PB          db  processorstatelength dup (?)
PxParamBlock ends


_TEXT   SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; BOOLEAN
; HalStartNextProcessor (
;   IN PLOADER_BLOCK      pLoaderBlock,
;   IN PKPROCESSOR_STATE  pProcessorState
; )
;
; Routine Description:
;
;    This routine is called by the kernel durning kernel initialization
;    to obtain more processors.  It is called until no more processors
;    are available.
;
;    If another processor exists this function is to initialize it to
;    the passed in processorstate structure, and return TRUE.
;
;    If another processor does not exists, then a FALSE is returned.
;
;    Also note that the loader block has been setup for the next processor.
;    The new processor logical thread number can be obtained from it, if
;    required.
;
; Arguments:
;    pLoaderBlock,      - Loader block which has been intialized for the
;                         next processor.
;
;    pProcessorState    - The processor state which is to be loaded into
;                         the next processor.
;
;
; Return Value:
;
;    TRUE  - ProcessorNumber was dispatched.
;    FALSE - A processor was not dispatched. no other processors exists.
;
;--

pLoaderBlock            equ     dword ptr [ebp+8]       ; zero based
pProcessorState         equ     dword ptr [ebp+12]

;
; Local variables
;

PxFrame                 equ     [ebp - size PxParamBlock]


cPublicProc _HalStartNextProcessor ,2
        push    ebp                             ; save ebp
        mov     ebp, esp                        ;

        sub     esp, size PxParamBlock          ; Make room for local vars


        push    esi
        push    edi
        push    ebx

        xor     eax, eax
        mov     PxFrame.SPx_flag, eax

        cmp     _MpCount, eax
        jbe     snp_exit                        ; exit FALSE

        mov     esi, OFFSET FLAT:StartPx_RMStub
        mov     ecx, StartPx_RMStub_Len
        mov     edi, _MpLowStub                 ; Copy RMStub to low memory
        add     edi, size PxParamBlock
        rep     movsb

        lea     edi, PxFrame.SPx_PB
        mov     esi, pProcessorState
        mov     ecx, processorstatelength       ; Copy processorstate
        rep     movsb                           ; to PxFrame

        stdCall   _HalpBuildTiledCR3, <pProcessorState>

        mov     PxFrame.SPx_TiledCR3, eax
        mov     PxFrame.SPx_P0EBP, ebp

        mov     eax, pLoaderBlock               ; lookup processor # we are
        mov     eax, [eax].LpbPrcb              ; starting
        movzx   eax, byte ptr [eax].PbNumber
        movzx   edx, _SpProcessorControlPort[eax*2] ; Get processor's control port
        mov     PxFrame.SPx_ControlPort, edx    ; Pass it along

        mov     ecx, size PxParamBlock          ; copy param block
        lea     esi, PxFrame                    ; to low memory stub
        mov     edi, _MpLowStub
        mov     eax, edi
        rep     movsb

        add     eax, size PxParamBlock
        mov     ebx, OFFSET FLAT:StartPx_RMStub
        sub     eax, ebx                        ; (eax) = adjusted pointer
        mov     bx, word ptr [PxFrame.SPx_PB.PsContextFrame.CsSegCs]
        mov     [eax.SPrxFlatCS], bx            ; patch realmode stub with
        mov     [eax.SPrxPMStub], offset _StartPx_PMStub    ; valid long jump

        mov     ebx, _MppIDT
        add     ebx, WarmResetVector

        cli
        push    dword ptr [ebx]                 ; Save current vector

        mov     eax, _MpLowStubPhysicalAddress
        shl     eax, 12                         ; seg:0
        add     eax, size PxParamBlock
        mov     dword ptr [ebx], eax            ; start Px here

        cmp     _SpType, SMP_SYSPRO2            ; Belize?
        jne     short snp10                         ; no, reset normal

        mov     dx, SMP_INDEX_PORT

        mov     eax, pLoaderBlock               ; lookup processor # we are
        mov     eax, [eax].LpbPrcb              ; starting
        movzx   eax, byte ptr [eax].PbNumber
        or      eax, (SMP_RESET_CPU shl 24) + (SMP_CSR_PORT shl 8)

        out     dx, eax                         ; issue Belize reset to processor
        jmp     short snp20                         ; go wait

snp10:
        mov     edx, PxFrame.SPx_ControlPort    ; Control port of target
        in      al, dx                              ; processor
        or      al, RESET                       ; assert RESET
        and     al, NOT SLEEP                   ; wakeup P1
        out     dx, al                          ; reset P1

snp20:  cmp     PxFrame.SPx_flag, 0             ; wait for Px to get it's
        jz      snp20                           ; info

        pop     dword ptr [ebx]                 ; restore WarmResetVector
        sti

        stdCall   _HalpFreeTiledCR3             ; free memory used for tiled
                                                ; CR3

        dec     _MpCount                        ; one less
        mov     eax, 1                          ; return TRUE

snp_exit:
        pop     ebx
        pop     edi
        pop     esi
        mov     esp, ebp
        pop     ebp
        stdRET    _HalStartNextProcessor

stdENDP _HalStartNextProcessor


_TEXT   ends                                        ; end 32 bit code


_TEXT16 SEGMENT DWORD PUBLIC USE16 'CODE'           ; start 16 bit code


;++
;
; VOID
; StartPx_RMStub
;
; Routine Description:
;
;   When a new processor is started, it starts in real-mode and is
;   sent to a copy of this function which has been copied into low memory.
;   (below 1m and accessable from real-mode).
;
;   Once CR0 has been set, this function jmp's to a StartPx_PMStub
;
; Arguments:
;    none
;
; Return Value:
;    does not return, jumps to StartPx_PMStub
;
;--
cPublicProc StartPx_RMStub  ,0
        cli

        db      066h                            ; load the GDT
        lgdt    fword ptr cs:[SPx_PB.PsSpecialRegisters.SrGdtr]

        db      066h                            ; load the IDT
        lidt    fword ptr cs:[SPx_PB.PsSpecialRegisters.SrIdtr]

        mov     eax, cs:[SPx_TiledCR3]
        mov     cr3, eax

        mov     ebp, dword ptr cs:[SPx_P0EBP]
        mov     ecx, dword ptr cs:[SPx_PB.PsContextFrame.CsSegDs]
        mov     ebx, dword ptr cs:[SPx_PB.PsSpecialRegisters.SrCr3]
        mov     eax, dword ptr cs:[SPx_PB.PsSpecialRegisters.SrCr0]

        mov     cr0, eax                        ; into prot mode

        db      066h
        db      0eah                            ; reload cs:eip
SPrxPMStub      dd      0
SPrxFlatCS      dw      0

StartPx_RMStub_Len      equ     $ - StartPx_RMStub
stdENDP StartPx_RMStub


_TEXT16 ends                                    ; End 16 bit code

_TEXT   SEGMENT                                 ; Start 32 bit code


;++
;
; VOID
; StartPx_PMStub
;
; Routine Description:
;
;   This function completes the processor's state loading, and signals
;   the requesting processor that the state has been loaded.
;
; Arguments:
;    ebx    - requested CR3 for this processors_state
;    cx     - requested ds for this processors_state
;    ebp    - EBP of P0
;
; Return Value:
;    does not return - completes the loading of the processors_state
;
;--
    align   16          ; to make sure we don't cross a page boundry
                        ; before reloading CR3

cPublicProc _StartPx_PMStub  ,0

    ; process is now in the load image copy of this function.
    ; (ie, it's not the low memory copy)

        mov     cr3, ebx                        ; get real CR3
        mov     ds, cx                          ; set real ds

        lea     esi, PxFrame.SPx_PB.PsSpecialRegisters

        lldt    word ptr ds:[esi].SrLdtr        ; load ldtr
        ltr     word ptr ds:[esi].SrTr          ; load tss

        lea     edi, PxFrame.SPx_PB.PsContextFrame
        mov     es, word ptr ds:[edi].CsSegEs   ; Set other selectors
        mov     fs, word ptr ds:[edi].CsSegFs
        mov     gs, word ptr ds:[edi].CsSegGs
        mov     ss, word ptr ds:[edi].CsSegSs

        add     esi, SrKernelDr0
    .errnz  (SrKernelDr1 - SrKernelDr0 - 1 * 4)
    .errnz  (SrKernelDr2 - SrKernelDr0 - 2 * 4)
    .errnz  (SrKernelDr3 - SrKernelDr0 - 3 * 4)
    .errnz  (SrKernelDr6 - SrKernelDr0 - 4 * 4)
    .errnz  (SrKernelDr7 - SrKernelDr0 - 5 * 4)
        lodsd
        mov     dr0, eax                        ; load dr0-dr7
        lodsd
        mov     dr1, eax
        lodsd
        mov     dr2, eax
        lodsd
        mov     dr3, eax
        lodsd
        mov     dr6, eax
        lodsd
        mov     dr7, eax

        mov     esp, dword ptr ds:[edi].CsEsp
        mov     esi, dword ptr ds:[edi].CsEsi
        mov     ecx, dword ptr ds:[edi].CsEcx

        push    dword ptr ds:[edi].CsEflags
        popfd                                   ; load eflags

        push    dword ptr ds:[edi].CsEip        ; make a copy of remaining
        push    dword ptr ds:[edi].CsEax        ; registers which need
        push    dword ptr ds:[edi].CsEbx        ; loaded
        push    dword ptr ds:[edi].CsEdx
        push    dword ptr ds:[edi].CsEdi
        push    dword ptr ds:[edi].CsEbp

        cmp     _SpType, SMP_SYSPRO2            ; Don't send old SP
        je      short spxpm01                   ; style Cache on enable

    ; eax, ebx, edx are still free
        mov     edx, [PxFrame.SPx_ControlPort]  ; our control port
        in      al, dx                          ; Get register
        and     al, NOT INTDIS                  ; allow PINTs on this proc
        or      al, CACHEON                     ; turn cache on
        out     dx, al
spxpm01:
        inc     [PxFrame.SPx_flag]              ; Signal p0 that we are
                                                ; done with it's data
    ; Set remaining registers
        pop     ebp
        pop     edi
        pop     edx
        pop     ebx
        pop     eax
        stdRET    _StartPx_PMStub               ; Set eip

stdENDP _StartPx_PMStub

_TEXT   ends                                    ; end 32 bit code
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spmp.inc ===
;/*
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;	spmp.inc
;
;   Abstract:
;
;	SystemPro MP include file
;
;   Author:
;
;--

if 0  ; */

// ---------------------------------------------------
//                      C section
// ---------------------------------------------------

#ifndef SPMPC_INCLUDE
#define SPMPC_INCLUDE 1

//
// All Values in the C section must match with the assembly.
//

#define SMP_SYSPRO1   1   // Original SystemPro and Compatibles
#define SMP_SYSPRO2   2   // SystemPro XL and ProLiant 2000,4000,4500
#define SMP_ACER      3   // Acer SystemPro Style

#define SP_M8259      1   // Each processor has 8259 set
#define SP_SMPDEVINTS 2   // Distribute device ints amoung all processors
#define SP_SMPCLOCK   4   // Clock is broadcast to each processor

#define SECOND_IPI_DISPATCH     24      // Vector offset for second level ipi dispatch

#endif

/*
endif

; ---------------------------------------------------
;                      Assembly section
; ---------------------------------------------------

;*****************************
;	Compaq MP defines
;

RESET_WO_EOI        equ     00ah    ; Reset with out EOI
WarmResetVector     equ     467h    ; warm reset vector in ROM data segment

; Multi-Processor Control Register I/O Locations:
PRODUCT_ID_OFFSET   equ     0C80h
EBC_OFFSET          equ     0C84h
PCR_OFFSET          equ     0C6Ah

PROC_ID_PORT	    equ     0c70h  ; who am I

; Multi-Processor Control Register Bit Definitions:
INTDIS		    equ     080h   ; INTDIS bit in Processor control register
PINT		    equ     040h   ; PINT bit in Processor control register
ERR387		    equ     020h   ; 387ERR bit in Processor control register
FLUSH		    equ     010h   ; flushes the processor's cache
SLEEP		    equ     008h   ; puts processor in HOLD
CACHEON 	    equ     004h   ; enables cache
PRES387 	    equ     002h   ; 387PRES bit in Processor control register
RESET		    equ     001h   ; RESET processor

;*****************************
;	end of list


;
; The kernel leaves some space (64 byte) of the PCR for the HAL to use
; as it needs.	Currently this space is used for some efficiency in
; some of the MP specific code and is highly implementation
; dependant.
;


PcrE struc
    PcrNumber                   db  0   ; Processor's number
    PcrPic                      db  0   ; 1 if processor has an 8259s
    PcrIpiClockTick             db  0   ; Emulate a clock tick
                                db  0   ; (alignment)
    PcrIpiType                  dd  0   ; How to handle different IPI implementations
    PcrIpiSecondLevelDispatch   dd  0   ; To exit IPI interrupt
    PcrControlPort              dw  0   ; Processor's control port
    PcrPerfSkew                 dd  0   ; Skew to apply to this P perf counter
PcrE ends

SECOND_IPI_DISPATCH equ    24           ; Vector offset for second level ipi dispatch

SWClockTick         equ     10h         ; Software level of emulated clock tick
SWCLOCK_LEVEL       equ     4           ; Software level of emulated clock tick

cr                  equ 0ah
lf                  equ 0dh

SMP_SYSPRO1         equ     1
SMP_SYSPRO2         equ     2
SMP_ACER            equ     3

;
; 8259PerProcessorMode bit mask
;

SP_M8259            equ     1   ; Each processor has 8259 set
SP_SMPDEVINTS       equ     2   ; Distribute device ints amoung all processors
SP_SMPCLOCK         equ     4   ; Clock is broadcast to each processor



;*****************************
;   Compaq SMP defines
;

;+++EQU+++ Belize Specific defines (Symmetrical SystemProII).
;
; INT/MPx local registers, and their initial value. Registers are offseted
; by 2 (except INT13-INT14) and there is 15 registers (INT does not have one,
; it is used for cascade).
;

TIME_DELAY      equ     0ffffffh

SMP_MAX_PROCESSORS  equ 8   ;BELIZE/PHOENIX supports 8 cpus MAX

SMP_MPINT0              equ 0cb0h
SMP_MPINT1              equ 0cb2h
;SMP_MPINT2                            **** DOESNOT EXIST ****
SMP_MPINT3              equ 0cb4h
SMP_MPINT4              equ 0cb6h
SMP_MPINT5              equ 0cb8h
SMP_MPINT6              equ 0cbah
SMP_MPINT7              equ 0cbch
SMP_MPINT8              equ 0cbeh
SMP_MPINT9              equ 0cc0h
SMP_MPINT10             equ 0cc2h
SMP_MPINT11             equ 0cc4h
SMP_MPINT12             equ 0cc6h
SMP_MPINT13             equ 0cc8h
SMP_MPINT14             equ 0ccch
SMP_MPINT15             equ 0cceh

SMP_IPI_MASKPORT        equ 0cd0h           ; IntrMask and IntrPort..DWORD
SMP_IPI_PROG_INTRPORT   equ 0cd3h           ; IntrPort

; IRQ assigned to IPI_LEVEL. It could be any of the above IRQs.
;
SMP_IPI_VECTOR          equ 13              ; IRQ13 assigned to IPI
SMP_IPI_MPINTx_PORT     equ SMP_MPINT13     ; IRQ13


; SymmetricalMpMode registers  (belize mode).
;
SMP_MODE_PORT           equ 0c67h           ; Global: ModeSelectPort
SMP_CSR_PORT            equ 0c6ah           ; Local:  ControlStatusRegPort
SMP_WHOAMI_PORT         equ 0c70h           ; Local:  Whoami Port
SMP_INDEX_PORT          equ 0c74h           ; Global: Index Port
SMP_ASSIGNMENT_PORT     equ 0c71h           ; Global: cpu assignment port


; Supported Modes on Symmetrical SysPro ...
;
SMP_ASYMMETRICAL_MODE   equ 0               ; SysPro compatible mode
SMP_SYMMETRICAL_MODE    equ 1 shl 5         ; Belize mode


; PCR, ProcessorControl/StatusRegister Port bit pattern.
;
SMP_CTRL_SLEEP          equ 1 shl 0         ; 1: assert sleep to CPU
SMP_CTRL_AWAKE          equ 1 shl 1         ; 1: Awake processor
SMP_CTRL_CACHEON        equ 1 shl 2         ; 1: enable  intr/extr cache
SMP_CTRL_CACHEOFF       equ 1 shl 3         ; 1: disable intr/extr cache
SMP_CTRL_FLUSH          equ 1 shl 4         ; 1: flush 486 secondary cache
SMP_CTRL_RESET          equ 1 shl 5         ; 1: reset CPU

SMP_RESET_CPU       equ (SMP_CTRL_RESET+SMP_CTRL_AWAKE+SMP_CTRL_CACHEON)

SMP_STAT_NCPIN          equ 1 shl 1         ; NCP installed, always 1
SMP_STAT_CACHEON        equ 1 shl 2         ; 0: in/ex cache off, 1: on
SMP_STAT_SLEEP          equ 1 shl 3         ; 0: awake, 1: Sleeping
SMP_STAT_NCPERR         equ 1 shl 5         ; 0: no NCP error, 1:NCP error


SMP_INTx_SET_PINT       equ 1 shl 0
SMP_INTx_CLR_PINT       equ 1 shl 1
SMP_INTx_ENABLE         equ 1 shl 2
SMP_INTx_DISABLE        equ 1 shl 3


;* MP INT13 Extended Control/Status Port...
;
SMP_MPINT13PORT         equ 0cc9h

SMP_ENBL_NCPERR         equ 1 shl 0
SMP_DSBL_NCPERR         equ 1 shl 1
SMP_ENBL_DMACHAIN       equ 1 shl 2
SMP_DSBL_DMACHAIN       equ 1 shl 3
SMP_ENBL_MCERR          equ 1 shl 4
SMP_DSBL_MCERR          equ 1 shl 5


;
;   The following macro performs an indexed IO read to the specified
;   IO address on the specified processor.  The result of the read is
;   placed in the 'al' register.
;
;   Warning: Assumes 8254 lock is owned
;
INDEXED_IO_READ macro cpu,ioaddress
        push    edx
        push    eax
        mov     dx, SMP_INDEX_PORT

        mov     al, cpu
        out     dx, al      ;select cpu

        inc     dx
        mov     ax, ioaddress
        out     dx, ax      ;select cpu's IO address to read from

        add     dx, 2
        pop     eax
        in      al, dx      ;read from the target cpu's IO address
        pop     edx
        jmp     $+2
endm    ;INDEXED_IO_READ


;
;   The following macro performs an indexed IO write to the specified
;   IO address on the specified processor.
;
INDEXED_IO_WRITE macro cpu,ioaddress,data
        push    edx
        push    eax

        mov     dx, SMP_INDEX_PORT
        mov     al, data
        shl     eax, 16

        mov     ax, ioaddress
        shl     eax, 8

        mov     al, cpu
        out     dx, eax

        pop     eax
        pop     edx
        jmp     $+2
endm    ;INDEXED_IO_WRITE
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spsproc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    spsproc.c

Abstract:

    SystemPro Start Next Processor c code.

    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for an
    MP Compaq SystemPro

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

const UCHAR HalName[] = "SystemPro or compatible MP Hal"; // This is placed in .text for debugging
#define HalName        L"SystemPro or compatible MP Hal"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITCONST")
#endif // ALLOC_DATA_PRAGMA
WCHAR HalHardwareIdString[] = L"syspro_mp\0";

ADDRESS_USAGE HalpSystemProIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
        0xC70,  1,          // WhoAmI
        0xC6A,  1,          // P0 Processor control register
        0xFC6A, 1,          // P1 Processor control register
        0xFC67, 2,          // P1 cache control, interrupt vector
        0,0
    }
};

ADDRESS_USAGE HalpAcerIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
        0xCC67, 2,          // P2 cache control, interrupt vector
        0xCC6A, 1,          // P2 Processor control register
        0xDC67, 2,          // P3 cache control, interrupt vector
        0xDC6A, 1,          // P3 Processor control register
        0,0
    }
};

ADDRESS_USAGE HalpBelizeIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
        0xC67,  1,      // Mode Select
        0xC71,  6,      // CPU assignment, reserverd[2], CPU index, address, data
        0xCB0, 36,      // IRQx Control/Status
        0xCC9,  1,      // INT13 Extended control/status port
        0,0
    }
};
#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA


VOID
HalpNonPrimaryClockInterrupt(
    VOID
    );

BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID HalpInitOtherBuses (VOID);
VOID HalpInitializePciBus (VOID);
VOID HalpInitializePciStubs (VOID);

#define LOW_MEMORY          0x000100000
#define MAX_PT              8

extern  VOID StartPx_PMStub(VOID);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitMP)
#pragma alloc_text(INIT,HalAllProcessorsStarted)
#pragma alloc_text(INIT,HalReportResourceUsage)
#pragma alloc_text(INIT,HalReportResourceUsage)
#pragma alloc_text(INIT,HalpInitOtherBuses)
#endif


ULONG   MpCount;                    // zero based. 0 = 1, 1 = 2, ...
PUCHAR  MpLowStub;                  // pointer to low memory bootup stub
PVOID   MpLowStubPhysicalAddress;   // pointer to low memory bootup stub
PUCHAR  MppIDT;                     // pointer to physical memory 0:0

extern  ULONG   HalpIpiClock;       // bitmask of processors to ipi
extern  UCHAR   SpCpuCount;
extern  UCHAR   Sp8259PerProcessorMode;
extern  UCHAR   SpType;
extern  PKPCR   HalpProcessorPCR[];


BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:
    Allows MP initialization from HalInitSystem.

Arguments:
    Same as HalInitSystem

Return Value:
    none.

--*/
{
    ULONG   paddress;
    ULONG   adjust;
    PKPCR   pPCR;

    pPCR = KeGetPcr();

    if (Phase == 0) {

        //
        // Register the IO space used by the SystemPro
        //

        HalpRegisterAddressUsage (&HalpSystemProIoSpace);
        switch (SpType) {
            case 2:
                HalpRegisterAddressUsage (&HalpBelizeIoSpace);
                break;
            case 3:
                HalpRegisterAddressUsage (&HalpAcerIoSpace);
                break;
        }

#if 0
        //
        // Register IPI vector
        //

        HalpRegisterVector (
            DeviceUsage,
            13,
            13 + PRIMARY_VECTOR_BASE,
            IPI_LEVEL );
#endif


        //
        // Get pointer to real-mode idt table
        //

        MppIDT = HalpMapPhysicalMemory (0, 1);

        //
        //  Allocate some low memory for processor bootup stub
        //

        MpLowStubPhysicalAddress = (PVOID)HalpAllocPhysicalMemory (LoaderBlock,
                                            LOW_MEMORY, 1, FALSE);

        if (!MpLowStubPhysicalAddress)
            return TRUE;

        MpLowStub = (PCHAR) HalpMapPhysicalMemory (MpLowStubPhysicalAddress, 1);
        MpCount = SpCpuCount-1;
        return TRUE;

    } else {

        //
        //  Phase 1 for another processor
        //


        if (pPCR->Prcb->Number != 0) {
            if (Sp8259PerProcessorMode & 1) {
                //
                // Each processor has it's own pics - we broadcast profile
                // interrupts to each  processor by enabling it on each
                // processor
                //

                HalpInitializeStallExecution( pPCR->Prcb->Number );

                HalpEnableInterruptHandler (
                    DeviceUsage,                // Report as device vector
                    V2I (PROFILE_VECTOR),       // Bus interrupt level
                    PROFILE_VECTOR,             // System IDT
                    PROFILE_LEVEL,              // System Irql
                    HalpProfileInterrupt,       // ISR
                    Latched );

            } else {
                //
                // Without a profile interrupt we can not callibrate
                // KeStallExecutionProcessor, so we inherrit the value from P0.
                //

                pPCR->StallScaleFactor = HalpProcessorPCR[0]->StallScaleFactor;

            }

            if (Sp8259PerProcessorMode & 4) {
                //
                // Each processor can get it's own clock device - we
                // program each processor's 8254 and enable to interrupt
                // on each processor
                //

                HalpInitializeClock ();

                HalpEnableInterruptHandler (
                    DeviceUsage,                    // Report as device vector
                    V2I (CLOCK_VECTOR),             // Bus interrupt level
                    CLOCK_VECTOR,                   // System IDT
                    CLOCK2_LEVEL,                   // System Irql
                    HalpNonPrimaryClockInterrupt,   // ISR
                    Latched );

            } else {

                //
                // This processor doesn't have a clock, so we emulate it by
                // sending an ipi at clock intervals.
                //

                HalpIpiClock |= 1 << pPCR->Prcb->Number;
            }

        }
    }

    return TRUE;
}



BOOLEAN
HalAllProcessorsStarted (
    VOID
    )
{
    if (HalpFeatureBits & HAL_NO_SPECULATION) {

        //
        // Processor doesn't perform speculative execeution,
        // remove fences in critical code paths
        //

        HalpRemoveFences ();
    }

    return TRUE;
}



VOID
HalReportResourceUsage (
    VOID
    )
/*++

Routine Description:
    The registery is now enabled - time to report resources which are
    used by the HAL.

Arguments:

Return Value:

--*/
{
    UNICODE_STRING  UHalName;

    HalInitSystemPhase2();

    RtlInitUnicodeString (&UHalName, HalName);

    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        Eisa                // SystemPro's are Eisa machines
    );

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();
    HalpInitializePciStubs ();
}

VOID
HalpInitOtherBuses (
    VOID
    )
{
    // no other buses
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spprofil.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    spprofil.asm
;
; Abstract:
;
;    This module implements the code necessary to initialize,
;    field and process the profile interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _KeProfileInterrupt,1,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0

;
; Constants used to initialize CMOS/Real Time Clock
;

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate
REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

align 4
ProfileIntervalTable    dd      1221    ; unit = 100 ns
                        dd      2441
                        dd      4883
                        dd      9766
                        dd      19531
                        dd      39063
                        dd      78125
                        dd      156250
                        dd      312500
                        dd      625000
                        dd      1250000
                        dd      2500000
                        dd      5000000
                        dd      5000000 OR 80000000H

ProfileIntervalInitTable db     00100011B
                        db      00100100B
                        db      00100101B
                        db      00100110B
                        db      00100111B
                        db      00101000B
                        db      00101001B
                        db      00101010B
                        db      00101011B
                        db      00101100B
                        db      00101101B
                        db      00101110B
                        db      00101111B
                        db      00101111B

;
; HALs wishing to reuse the code in this module should set the HAL
; global variable IxProfileVector to their profile vector.
;
                public  _IxProfileVector
_IxProfileVector        dd      PROFILE_VECTOR

_TEXT   ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

RegisterAProfileValue   db      00101000B ; default interval = 3.90625 ms

;
; The following array stores the per microsecond loop count for each
; central processor.
;

HalpProfileInterval     dd      -1
HalpProfilingStopped    dd      1

_DATA   ends


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   HalStartProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the slowest thing we can get away with to the value
;       that's been KeSetProfileInterval
;
;   All processors will run this routine, but it doesn't hurt to have
;   each one reinitialize the CMOS, since none of them will be let go
;   from the stall until they all finish.
;
;--

cPublicProc _HalStartProfileInterrupt    ,1

;
; On the SystemPro there is only one profile device, so starting/stopping
; is only done from one processor.
;
; Note: This code uses PbNumber so it doesn't touch any SystemPro specific
; PCR value (so the code can be re-used by other hals)
;

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbNumber, 0
        jne     epi_exit


;   Mark profiling as active
;

        mov     HalpProfilingStopped, 0

;
;   Set the interrupt rate to what is actually needed
;
        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     al, RegisterAProfileValue
        shl     ax, 8
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock
epi_exit:
        stdRET    _HalStartProfileInterrupt

stdENDP _HalStartProfileInterrupt



;++
;
;   HalStopProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the high profiling rate to the slowest thing we
;       can get away with for PerformanceCounter rollover notification.
;
;--

cPublicProc _HalStopProfileInterrupt    ,1

;
; On the SystemPro there is only one profile device, so starting/stopping
; is only done from one processor.
;
; Note: This code uses PbNumber so it doesn't touch any SystemPro specific
; PCR value (so the code can be re-used by other hals)
;

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbNumber, 0
        jne     dpi_exit

;
;   Turn off profiling hit computation and profile interrupt
;

;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending profiling interrupt
        mov     HalpProfilingStopped, 1
        stdCall   _HalpReleaseCmosSpinLock
dpi_exit:
        stdRET    _HalStopProfileInterrupt

stdENDP _HalStopProfileInterrupt

;++
;   ULONG
;   HalSetProfileInterval (
;       ULONG Interval
;       );
;
;   Routine Description:
;
;       This procedure sets the interrupt rate (and thus the sampling
;       interval) for the profiling interrupt.
;
;       If profiling is active (KiProfilingStopped == 0) the actual
;       hardware interrupt rate will be set.  Otherwise, a simple
;       rate validation computation is done.
;
;   Arguments:
;
;       (TOS+4) - Interval in 100ns unit.
;
;   Return Value:
;
;       Interval actually used by system.
;--

cPublicProc _HalSetProfileInterval    ,1

        mov     edx, [esp+4]            ; [edx] = interval in 100ns unit
        and     edx, 7FFFFFFFh          ; Remove highest bit.
        mov     ecx, 0                  ; index = 0

Hspi00:
        mov     eax, ProfileIntervalTable[ecx * 4]
        cmp     edx, eax                ; if request interval < suport interval
        jbe     short Hspi10            ; if be, find supported interval
        inc     ecx
        jmp     short Hspi00

Hspi10:
        and     eax, 7FFFFFFFh          ; remove highest bit from supported interval
        jecxz   short Hspi20            ; If first entry then use it

        push    esi                     ; See which is closer to requested
        mov     esi, eax                ; rate - current entry, or preceeding
        sub     esi, edx

        sub     edx, ProfileIntervalTable[ecx * 4 - 4]
        cmp     esi, edx
        pop     esi
        jc      short Hspi20

        dec     ecx                     ; use preceeding entry
        mov     eax, ProfileIntervalTable[ecx * 4]

Hspi20:
        push    eax                     ; save interval value
        mov     al, ProfileIntervalInitTable[ecx]
        mov     RegisterAProfileValue, al
        test    HalpProfilingStopped,-1
        jnz     short Hspi90

        stdCall   _HalStartProfileInterrupt,<0> ; Re-start profile interrupt
                                        ; with the new interval

Hspi90: pop     eax
        stdRET    _HalSetProfileInterval    ; (eax) = cReturn interval

stdENDP _HalSetProfileInterval

        page ,132
        subttl  "System Profile Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a profile interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = PROFILE_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hpi_a, Hpi_t

cPublicProc _HalpProfileInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hpi_a, Hpi_t

;
; (esp) - base of trap frame
;
; HalBeginSystemInterrupt must be called before any sti's
;
;

        push    _IxProfileVector
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall _HalBeginSystemInterrupt, <PROFILE_LEVEL,_IxProfileVector,esp>

        or      al,al                   ; check for spurious interrupt
        jz      Hpi100

;
; If profiling not enabled, then don't ack device or count this interrupt.
; (this occurs during bootup when other processors sync PcStallScaleFactor)
;
        cmp     HalpProfilingStopped,0
        jne     short Hpi90

;
; On the SystemPro there is only one profile device, so the CMOS is only
; EOIed once.
;
; Note: This code uses PbNumber so it doesn't touch any SystemPro specific
; PCR value (so the code can be re-used by other hals)
;
        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbNumber, 0
        jne     short _HalpProfileInterrupt2ndEntry@0


;
; This is the RTC interrupt, so we have to clear the
; interrupt flag on the RTC.
;
        stdCall _HalpAcquireCmosSpinLock

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
if  DBG
Hpi10:  test    al, 80h
        jz      short Hpi15
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        jmp     short Hpi10
Hpi15:
endif   ; DBG

        stdCall _HalpReleaseCmosSpinLock

; This entry point is provided for symmetric multiprocessor HALs.
; Since it only makes sense for one processor to clear the CMOS,
; all other processors can instead jmp into this entry point.
;

        align 4
        public     _HalpProfileInterrupt2ndEntry@0
_HalpProfileInterrupt2ndEntry@0:

        stdCall _KeProfileInterrupt,<ebp>   ; (ebp) = trap frame

Hpi90:
        INTERRUPT_EXIT

Hpi100:
        add     esp, 8                  ; spurious, no EndOfInterrupt
        SPURIOUS_INTERRUPT_EXIT         ; exit interrupt without eoi

stdENDP _HalpProfileInterrupt


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spswint.asm ===
title   "Software Interrupts"

;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    ixswint.asm
;
; Abstract:
;
;    This module implements the software interrupt handlers
;    for x86 machines
;
; Author:
;
;    John Vert (jvert) 2-Jan-1992
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

        EXTRNP  _KiDeliverApc,3,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        extrn   SWInterruptHandlerTable:dword
        extrn   SWInterruptLookUpTable:byte
ifdef IRQL_METRICS
        extrn   HalApcSoftwareIntCount:dword
        extrn   HalDpcSoftwareIntCount:dword
endif

_TEXT$02   SEGMENT DWORD USE32 PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; FASTCALL
; HalRequestSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;    This routine is used to request a software interrupt to the
;    system. Also, this routine checks to see if any software
;    interrupt should be generated.
;    The following condition will cause software interrupt to
;    be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

; equates for accessing arguments
;

cPublicFastCall HalRequestSoftwareInterrupt ,1
cPublicFpo 0, 1
        mov     eax,1
        shl     eax, cl                 ; convert to mask
        pushfd                          ; save interrupt mode
        cli                             ; disable interrupt
        or      PCR[PcIRR], eax         ; set the request bit
        mov     cl, PCR[PcIrql]         ; get current IRQL

        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        jbe     KsiExit                 ; No, jmp ksiexit
        call    SWInterruptHandlerTable[eax*4] ; yes, simulate interrupt
                                        ; to the appropriate handler
KsiExit:
        popfd                           ; restore original interrupt mode
        fstRET    HalRequestSoftwareInterrupt

fstENDP HalRequestSoftwareInterrupt

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalClearSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to clear a possible pending software interrupt.
;   Support for this function is optional, and allows the kernel to
;   reduce the number of spurious software interrupts it receives/
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalClearSoftwareInterrupt ,1
cPublicFpo 0, 0

        mov     eax,1
        shl     eax, cl                 ; convert to mask

        not     eax
        and     PCR[PcIRR], eax         ; clear pending irr bit

        fstRET  HalClearSoftwareInterrupt

fstENDP HalClearSoftwareInterrupt

        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; VOID
; HalpDispatchInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is the interrupt handler for a software interrupt generated
;    at DISPATCH_LEVEL.  Its function is to save the machine state, raise
;    Irql to DISPATCH_LEVEL, dismiss the interrupt, and call the DPC
;    delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST hdpi_a, hdpi_t

        align dword
        public _HalpDispatchInterrupt
_HalpDispatchInterrupt proc
ifdef IRQL_METRICS
        lock inc HalDpcSoftwareIntCount
endif
;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT hdpi_a, hdpi_t
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )

        public  _HalpDispatchInterrupt2ndEntry
_HalpDispatchInterrupt2ndEntry:

; Save previous IRQL and set new priority level

        push    PCR[PcIrql]                       ; save previous IRQL
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL; set new irql
        btr     dword ptr PCR[PcIRR], DISPATCH_LEVEL; clear the pending bit in IRR

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; Go do Dispatch Interrupt processing
;
        stdCall   _KiDispatchInterrupt

;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                          ; will do an iret

_HalpDispatchInterrupt endp

        page ,132
        subttl  "APC Interrupt"
;++
;
; HalpApcInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at APC_LEVEL. Its function is to save the machine state, raise Irql to
;    APC_LEVEL, dismiss the interrupt, and call the APC delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is Disabled
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST hapc_a, hapc_t

        align dword
        public _HalpApcInterrupt
_HalpApcInterrupt proc
ifdef IRQL_METRICS
        lock inc HalApcSoftwareIntCount
endif
;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state in trap frame
;
        ENTER_INTERRUPT hapc_a, hapc_t
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )


        public     _HalpApcInterrupt2ndEntry
_HalpApcInterrupt2ndEntry:

;
; Save previous IRQL and set new priority level
;

        push    PCR[PcIrql]              ; save previous Irql
        mov     byte ptr PCR[PcIrql], APC_LEVEL   ; set new Irql
        btr     dword ptr PCR[PcIRR], APC_LEVEL   ; dismiss pending APC
;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; call the APC delivery routine.
;

        mov     eax, [ebp]+TsSegCs      ; get interrupted code's CS
        and     eax, MODE_MASK          ; extract the mode

        test    dword ptr [ebp]+TsEFlags, EFLAGS_V86_MASK
        jz      short @f

        or      eax, MODE_MASK          ; If v86 frame, then set user_mode
@@:

;
; call APC deliver routine
;       Previous mode
;       Null exception frame
;       Trap frame

        stdCall   _KiDeliverApc, <eax, 0,ebp>

;
;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                  ; will do an iret

_HalpApcInterrupt       endp

_TEXT$02   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxdisp.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\xxdisp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxbiosc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\xxbiosc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxflshbf.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\xxflshbf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    spsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to enable/disable system
;    interrupts, for the MP systempro implementation
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;--


.386p
        .xlist
include hal386.inc
include callconv.inc                ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\spmp.inc
        .list

        extrn   KiI8259MaskTable:DWORD
        EXTRNP  _KeBugCheck,1,IMPORT

;
; Constants used to initialize CMOS/Real Time Clock
;

CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port

;
; Macros to Read/Write/Reset CMOS to initialize RTC
;

; CMOS_READ
;
; Description: This macro read a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Return: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

_DATA   SEGMENT DWORD PUBLIC 'DATA'

align   dword
;
; HalDismissSystemInterrupt does an indirect jump through this table so it
; can quickly execute specific code for different interrupts.
;
        public  HalpSpecialDismissTable
HalpSpecialDismissTable label   dword
        dd      offset FLAT:HalpDismissNormal   ; irq 0
        dd      offset FLAT:HalpDismissNormal   ; irq 1
        dd      offset FLAT:HalpDismissNormal   ; irq 2
        dd      offset FLAT:HalpDismissNormal   ; irq 3
        dd      offset FLAT:HalpDismissNormal   ; irq 4
        dd      offset FLAT:HalpDismissNormal   ; irq 5
        dd      offset FLAT:HalpDismissNormal   ; irq 6
        dd      offset FLAT:HalpDismissIrq07    ; irq 7
        dd      offset FLAT:HalpDismissNormal   ; irq 8
        dd      offset FLAT:HalpDismissNormal   ; irq 9
        dd      offset FLAT:HalpDismissNormal   ; irq A
        dd      offset FLAT:HalpDismissNormal   ; irq B
        dd      offset FLAT:HalpDismissNormal   ; irq C
        dd      offset FLAT:HalpDismissNormal   ; irq D
        dd      offset FLAT:HalpDismissNormal   ; irq E
        dd      offset FLAT:HalpDismissIrq0f    ; irq F
        dd      offset FLAT:HalpDismissNormal   ; irq 10
        dd      offset FLAT:HalpDismissNormal   ; irq 11
        dd      offset FLAT:HalpDismissNormal   ; irq 12
        dd      offset FLAT:HalpDismissNormal   ; irq 13
        dd      offset FLAT:HalpDismissNormal   ; irq 14
        dd      offset FLAT:HalpDismissNormal   ; irq 15
        dd      offset FLAT:HalpDismissNormal   ; irq 16
        dd      offset FLAT:HalpDismissNormal   ; irq 17
        dd      offset FLAT:HalpDismissNormal   ; irq 18
        dd      offset FLAT:HalpDismissNormal   ; irq 19
        dd      offset FLAT:HalpDismissNormal   ; irq 1A
        dd      offset FLAT:HalpDismissNormal   ; irq 1B
        dd      offset FLAT:HalpDismissNormal   ; irq 1C
        dd      offset FLAT:HalpDismissNormal   ; irq 1D
        dd      offset FLAT:HalpDismissNormal   ; irq 1E
        dd      offset FLAT:HalpDismissNormal   ; irq 1F
        dd      offset FLAT:HalpDismissNormal   ; irq 20
        dd      offset FLAT:HalpDismissNormal   ; irq 21
        dd      offset FLAT:HalpDismissNormal   ; irq 22
        dd      offset FLAT:HalpDismissNormal   ; irq 23
        dd      offset FLAT:HalpDispatch        ; irq 24 - 2nd level dispatch from ipi

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;BOOLEAN
;HalBeginSystemInterrupt(
;    IN KIRQL Irql
;    IN CCHAR Vector,
;    OUT PKIRQL OldIrql
;    )
;
;
;
;Routine Description:
;
;    This routine is used to dismiss the specified vector number.  It is called
;    before any interrupt service routine code is executed.
;
;    N.B.  This routine does NOT preserve EAX or EBX
;
;    On the SystemPro, since all interrupt go to P0, HalBeing/EndSystem-
;    Interrupt are treated very much like the UP case.  All calls to this
;    function will occur from P0.
;
;Arguments:
;
;    Irql   - Supplies the IRQL to raise to
;
;    Vector - Supplies the vector of the interrupt to be dismissed
;
;    OldIrql- Location to return OldIrql
;
;
;Return Value:
;
;    FALSE - Interrupt is spurious and should be ignored
;
;    TRUE -  Interrupt successfully dismissed and Irql raised.
;
;--
align dword
HbsiIrql        equ     byte  ptr [esp+4]
HbsiVector      equ     byte  ptr [esp+8]
HbsiOldIrql     equ     dword ptr [esp+12]

cPublicProc _HalBeginSystemInterrupt ,3
        mov     ebx, dword ptr HbsiVector       ; (ebx) = System Vector
        sub     ebx, PRIMARY_VECTOR_BASE        ; (ebx) = 8259 IRQ #

        cmp     ebx, 25h                        ; Interrupt in table?
        jnc     hbsi00                          ; no go handle
        jmp     HalpSpecialDismissTable[ebx*4]

hbsi00:
;
; Interrupt is out of range.  There's no EOI here since it wouldn't
; have been out of range if it occured on either interrupt controller
; which is known about.
;
        xor     eax,eax                 ; return FALSE
        stdRET    _HalBeginSystemInterrupt

align 4
HalpDismissIrq0f:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff

;
; This is a spurious interrupt.
; Because the slave PIC is cascaded to irq2 of master PIC, we need to
; dismiss the interupt on master PIC's irq2.
;

        mov     al, PIC2_EOI            ; Specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        xor     eax,eax                 ; return FALSE
        stdRET    _HalBeginSystemInterrupt

align 4
HalpDismissIrq07:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, so this is NOT a spurious int
        xor     eax, eax                ; return FALSE
        stdRET    _HalBeginSystemInterrupt

align 4
HalpDismissNormal:
;
; Store OldIrql
;
        mov     eax, HbsiOldIrql
        mov     cl, fs:PcIrql
        mov     byte ptr [eax], cl

;
; Raise IRQL to requested level
;
        xor     eax, eax
        mov     al, HbsiIrql            ; (eax) = irql
                                        ; (ebx) = IRQ #

        mov     fs:PcIrql, al           ; set new Irql


        mov     eax, KiI8259MaskTable[eax*4]    ; get 8259's masks
        or      eax, fs:PcIDR           ; mask disabled irqs
        SET_8259_MASK                   ; send mask to 8259s

;
; Dismiss interrupt.  Current interrupt is already masked off.
;
        mov     eax, ebx                ; (eax) = IRQ #
        cmp     eax, 8                  ; EOI to master or slave?

        jae     short Hbsi100           ; EIO to both master and slave
        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt
        jmp     short Hbsi200           ; IO delay

align 4
Hbsi100:
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
align 4
Hbsi200:
        PIC1DELAY

HalpDispatch:
        sti
        mov     eax, 1                  ; return TRUE, interrupt dismissed
        stdRET    _HalBeginSystemInterrupt
stdENDP _HalBeginSystemInterrupt

;++
;VOID
;HalDisableSystemInterrupt(
;    IN CCHAR Vector,
;    IN KIRQL Irql
;    )
;
;
;
;Routine Description:
;
;    Disables a system interrupt.
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be disabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be disabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalDisableSystemInterrupt      ,2

;

        movzx   ecx, byte ptr [esp+4]           ; (ecx) = Vector
        sub     ecx, PRIMARY_VECTOR_BASE        ; (ecx) = 8259 irq #
        mov     edx, 1
        shl     edx, cl                         ; (ebx) = bit in IMR to disable
        cli
        or      fs:PcIDR, edx
        xor     eax, eax

;
; Get the current interrupt mask register from the 8259
;
        in      al, PIC2_PORT1
        shl     eax, 8
        in      al, PIC1_PORT1
;
; Mask off the interrupt to be disabled
;
        or      eax, edx
;
; Write the new interrupt mask register back to the 8259
;
        out     PIC1_PORT1, al
        shr     eax, 8
        out     PIC2_PORT1, al
        PIC2DELAY

        sti
        stdRET    _HalDisableSystemInterrupt

stdENDP _HalDisableSystemInterrupt

;++
;
;BOOLEAN
;HalEnableSystemInterrupt(
;    IN ULONG Vector,
;    IN KIRQL Irql,
;    IN KINTERRUPT_MODE InterruptMode
;    )
;
;
;Routine Description:
;
;    Enables a system interrupt
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be enabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be enabled.
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalEnableSystemInterrupt       ,3

        mov     ecx, dword ptr [esp+4]          ; (ecx) = vector
        sub     ecx, PRIMARY_VECTOR_BASE
        jc      hes_error
        cmp     ecx, CLOCK2_LEVEL
        jnc     hes_error

        mov     eax, 1
        shl     eax, cl                         ; (ebx) = bit in IMR to enable
        not     eax

        pushfd
        cli
        and     fs:PcIDR, eax

;
; Get the PIC masks for the current Irql
;
        movzx   eax, byte ptr fs:PcIrql
        mov     eax, KiI8259MaskTable[eax*4]
        or      eax, fs:PcIDR
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

        popfd
        mov     eax, 1                          ; return TRUE
        stdRET    _HalEnableSystemInterrupt

hes_error:
if DBG
        int 3
endif
        xor     eax, eax                        ; FALSE
        stdRET    _HalEnableSystemInterrupt

stdENDP _HalEnableSystemInterrupt


_TEXT   ENDS
        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxbiosa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\halx86\i386\xxbiosa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxhal.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\xxhal.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\spsysbus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    spsysbus.c

Abstract:

Author:

Environment:

Revision History:

--*/

#include "halp.h"
#include "spmp.inc"

ULONG HalpDefaultInterruptAffinity;
ULONG HalpCpuCount;

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetSystemInterruptVector)
#pragma alloc_text(PAGE,HalTranslatorReference)
#pragma alloc_text(PAGE,HalTranslatorDereference)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesRoot)
#pragma alloc_text(PAGE,HalIrqTranslateResourceRequirementsRoot)
#pragma alloc_text(PAGE,HalpTransMemIoResource)
#pragma alloc_text(PAGE,HalpTransMemIoResourceRequirement)
#endif

extern UCHAR SpCpuCount;
extern Sp8259PerProcessorMode;
extern UCHAR RegisteredProcessorCount;


BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    PSUPPORTED_RANGE    pRange;

    pRange = NULL;
    switch (*AddressSpace) {
        case 0:
            // verify memory address is within buses memory limits
            for (pRange = &BusHandler->BusAddresses->PrefetchMemory; pRange; pRange = pRange->Next) {
                if (BusAddress.QuadPart >= pRange->Base &&
                    BusAddress.QuadPart <= pRange->Limit) {
                        break;
                }
            }

            if (!pRange) {
                for (pRange = &BusHandler->BusAddresses->Memory; pRange; pRange = pRange->Next) {
                    if (BusAddress.QuadPart >= pRange->Base &&
                        BusAddress.QuadPart <= pRange->Limit) {
                            break;
                    }
                }
            }

            break;

        case 1:
            // verify IO address is within buses IO limits
            for (pRange = &BusHandler->BusAddresses->IO; pRange; pRange = pRange->Next) {
                if (BusAddress.QuadPart >= pRange->Base &&
                    BusAddress.QuadPart <= pRange->Limit) {
                        break;
                }
            }
            break;
    }
    
    if (pRange) {
        TranslatedAddress->QuadPart = BusAddress.QuadPart + pRange->SystemBase;
        *AddressSpace = pRange->SystemAddressSpace;
        return TRUE;
    }

    return FALSE;
}


ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL pIrql,
    OUT PKAFFINITY pAffinity
    )

/*++

Routine Description:

Arguments:

    BusInterruptLevel - Supplies the bus specific interrupt level.

    BusInterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG       SystemVector;
    ULONG       Cpu;
    ULONG       Affinity;
    KIRQL       Irql;

    UNREFERENCED_PARAMETER( BusHandler );
    UNREFERENCED_PARAMETER( RootHandler );
    UNREFERENCED_PARAMETER( BusInterruptVector );

    //
    // Set default SystemVector, IRQL & CPU
    //

    SystemVector = BusInterruptLevel + PRIMARY_VECTOR_BASE;
    Irql = (KIRQL)(HIGHEST_LEVEL_FOR_8259 + PRIMARY_VECTOR_BASE - SystemVector);
    Cpu = 0;


    if (SystemVector < PRIMARY_VECTOR_BASE                           ||
        SystemVector > PRIMARY_VECTOR_BASE + HIGHEST_LEVEL_FOR_8259  ||
        HalpIDTUsageFlags[SystemVector].Flags & IDTOwned ) {

        //
        // This is an illegal BusInterruptVector and cannot be connected.
        //

        return(0);
    }

    //
    // If this is machine has reported SMP Dev Ints then lets
    // use them in a static interrupt distribution method.
    // Notice some devices are kept on P0 for compatibility.
    // These interrupts and their devices are not generally used
    // for steady state operations.
    //
    
    if (Sp8259PerProcessorMode & SP_SMPDEVINTS) {

        //
        // This is for overriding some devices that belong on P0.
        //

        switch (BusInterruptLevel) {
            case 1:                         // keyboard
            case 3:                         // com2
            case 4:                         // com1
            case 5:                         // SysMgmt Modem
            case 6:                         // floppy
            case 12:                        // mouse
                // use first cpu
                break;

            case 13:                        // Health (IPIs on all)
                // use first cpu, as:
                Irql = IPI_LEVEL;
                SystemVector = PRIMARY_VECTOR_BASE + SECOND_IPI_DISPATCH;
                break;

            default:
                Cpu = SystemVector % HalpCpuCount;
                break;
        }
    }

    //
    // Get Affinity for Cpu
    //

    Affinity = 1 << Cpu;
    ASSERT (Affinity);

    //
    // Done
    //

    *pAffinity = Affinity;
    *pIrql = Irql;
    return SystemVector;
}

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes an IO_RESOURCE_DESCRIPTOR and translates
    it from an IO-bus-relative to a Processor-bus-relative form.  In this 
    x86-specific example, an IO-bus-relative form is the ISA IRQ and the 
    Processor-bus-relative form is the IDT entry and the associated IRQL.
    This is essentially a PnP form of HalGetInterruptVector.
    
Arguments:

    Context     - unused
    
    Source      - descriptor that we are translating
    
    PhysicalDeviceObject- unused
    
    TargetCount - 1
    
    Target      - translated descriptor

Return Value:

    status

--*/
{
    return STATUS_NOT_IMPLEMENTED;
}
NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
{
    return STATUS_NOT_IMPLEMENTED;
}

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )

/*++

Routine Description:

    This routine translates memory and IO resource requirements.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt requirement to translate

    PhysicalDeviceObject - The device requesting the resource

    TargetCount - Pointer to where to return the number of descriptors this
        requirement translates into

    Target - Pointer to where a pointer to a callee allocated buffer containing
        the translated descriptors should be placed.

Return Value:

    STATUS_SUCCESS or an error status

Note:

    We do not perform any translation.

--*/

{
    ASSERT(Source);
    ASSERT(Target);
    ASSERT(TargetCount);
    ASSERT(Source->Type == CmResourceTypeMemory ||
           Source->Type == CmResourceTypePort);


    //
    // Allocate space for the target
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    ' laH');

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to target and update the fields that have changed
    //

    **Target = *Source;
    *TargetCount = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )

/*++

Routine Description:

    This routine translates memory and IO resources.   On generic x86
    machines, such as those that use this HAL, there isn't actually
    any translation.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt resource to translate

    Direction - The direction in relation to the Pnp device tree translation
        should occur in.

    AlternativesCount - The number of alternatives this resource was selected
        from.

    Alternatives - Array of alternatives this resource was selected from.

    PhysicalDeviceObject - The device requesting the resource

    Target - Pointer to a caller allocated buffer to hold the translted resource
        descriptor.

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    NTSTATUS status;

    //
    // Copy the target to the source
    //

    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Make sure PnP knows it doesn't have to walk up the tree
        // translating at each point.
        //

        status = STATUS_TRANSLATION_COMPLETE;
        break;

    case TranslateParentToChild:

        //
        // We do not translate requirements so do nothing...
        //

        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }
    return status;
}
VOID 
HalTranslatorReference(
    PVOID Context
    )
{
    return;
}

VOID 
HalTranslatorDereference(
    PVOID Context
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxioacc.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\halx86\i386\xxioacc.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxmemory.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\xxmemory.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxstubs.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\xxstubs.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsp\i386\xxtime.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\xxtime.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\ixinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixinfo.c

Abstract:

Author:

    Ken Reneris (kenr)  08-Aug-1994

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"

VOID
HalInitSystemPhase2 (
    VOID
    );

#ifdef _PNP_POWER_
HAL_CALLBACKS   HalCallback;
extern WCHAR    rgzSuspendCallbackName[];

VOID
HalpLockSuspendCode (
    IN PVOID    CallbackContext,
    IN PVOID    Argument1,
    IN PVOID    Argument2
    );
#endif

NTSTATUS
HalpQueryInstalledBusInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HaliQuerySystemInformation)
#pragma alloc_text(PAGE,HaliSetSystemInformation)
#pragma alloc_text(INIT,HalInitSystemPhase2)

#ifdef _PNP_POWER_
#pragma alloc_text(PAGE,HalpLockSuspendCode)
#endif

#endif


VOID
HalInitSystemPhase2 (
    VOID
    )
{
#ifdef _PNP_POWER_
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    UNICODE_STRING                  unicodeString;
    PCALLBACK_OBJECT                CallbackObject;

    //
    // Create hal callbacks
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );


    ExCreateCallback (&HalCallback.SetSystemInformation, &ObjectAttributes, TRUE, TRUE);
    ExCreateCallback (&HalCallback.BusCheck, &ObjectAttributes, TRUE, TRUE);

    //
    // Connect to suspend callback to lock hal hibaration code
    //

    RtlInitUnicodeString(&unicodeString, rgzSuspendCallbackName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    Status = ExCreateCallback (&CallbackObject, &ObjectAttributes, FALSE, FALSE);

    if (NT_SUCCESS(Status)) {
        ExRegisterCallback (
            CallbackObject,
            HalpLockSuspendCode,
            NULL
            );

        ObDereferenceObject (CallbackObject);
    }
#endif
}


NTSTATUS
HaliQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    NTSTATUS    Status;
    PVOID       InternalBuffer;
    ULONG       Length;
    union {
        HAL_POWER_INFORMATION               PowerInf;
        HAL_PROCESSOR_SPEED_INFORMATION     ProcessorInf;
        HAL_DISPLAY_BIOS_INFORMATION        DisplayBiosInf;
    } U;

    BOOLEAN     bUseFrameBufferCaching;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    *ReturnedLength = 0;
    Length = 0;

    switch (InformationClass) {
        case HalInstalledBusInformation:
            Status = HalpQueryInstalledBusInformation (
                        Buffer,
                        BufferSize,
                        ReturnedLength
                        );
            break;

        case HalFrameBufferCachingInformation:

            // Note - we want to return TRUE here to enable USWC in all
            // cases except in a "Shared Memory Cluster" machine.
            bUseFrameBufferCaching = TRUE;
            InternalBuffer = &bUseFrameBufferCaching;
            Length = sizeof (BOOLEAN);
            break;


#ifdef _PNP_POWER_
        case HalPowerInformation:
            RtlZeroMemory (&U.PowerInf, sizeof(HAL_POWER_INFORMATION));

            InternalBuffer = &U.PowerInf;
            Length = sizeof (HAL_POWER_INFORMATION);
            break;


        case HalProcessorSpeedInformation:
            RtlZeroMemory (&U.ProcessorInf, sizeof(HAL_POWER_INFORMATION));

            U.ProcessorInf.MaximumProcessorSpeed = 100;
            U.ProcessorInf.CurrentAvailableSpeed = 100;
            U.ProcessorInf.ConfiguredSpeedLimit  = 100;

            InternalBuffer = &U.PowerInf;
            Length = sizeof (HAL_PROCESSOR_SPEED_INFORMATION);
            break;

        case HalCallbackInformation:
            InternalBuffer = &HalCallback;
            Length = sizeof (HAL_CALLBACKS);
            break;
#endif
        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    //
    // If non-zero Length copy data to callers buffer
    //

    if (Length) {
        if (BufferSize < Length) {
            Length = BufferSize;
        }

        *ReturnedLength = Length;
        RtlCopyMemory (Buffer, InternalBuffer, Length);
    }

    return Status;
}

NTSTATUS
HaliSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
{
    NTSTATUS    Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    switch (InformationClass) {

        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    return Status;
}



#ifdef _PNP_POWER_

VOID
HalpLockSuspendCode (
    IN PVOID    CallbackContext,
    IN PVOID    Argument1,
    IN PVOID    Argument2
    )
{
    static PVOID    CodeLock;

    switch ((ULONG) Argument1) {
        case 0:
            //
            // Lock code down which might be needed to perform a suspend
            //

            ASSERT (CodeLock == NULL);
            CodeLock = MmLockPagableCodeSection (&HaliSuspendHibernateSystem);
            break;

        case 1:
            //
            // Release the code lock
            //

            MmUnlockPagableImageSection (CodeLock);
            CodeLock = NULL;
            break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\halp.h ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/


#ifndef _HALP_H_
#define _HALP_H_

#include <nthal.h>
#include <hal.h>
#include <hali.h>
#include "ssc.h"
#include "..\..\inc\hali.h"

/*
 * Default clock and profile timer intervals (in 100ns-unit)
 */
#define DEFAULT_CLOCK_INTERVAL 100000         // 10  ms
#define MINIMUM_CLOCK_INTERVAL 10000          //  1  ms
#define MAXIMUM_CLOCK_INTERVAL 100000         // 10  ms



/*
 * Device IRQLs (must be in sync with the values defined in the header
 * files for the disk, keyboard, and mouse drivers.)
 */

#define DISK_IRQL       4
#define MOUSE_IRQL      5
#define KEYBOARD_IRQL   6
#define SERIAL_IRQL     7

/*
 * PCR address.
 * Temporary macros; should already be defined in ntddk.h for IA64
 */

#define PCR ((volatile KPCR * const)KIPCR)

#define MiGetPteAddress(va) ((PHARDWARE_PTE)(__thash((ULONG_PTR)(va))))


extern VOID
HalpInitializeInterrupts (
    VOID
    );

extern VOID
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

extern VOID
HalpProfileInterrupt (
    IN PKTRAP_FRAME TrapFrame
    );

extern VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

#endif /* _HALP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simbus.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simbus.c

Abstract:

    This module implements the routines to support the management
    of bus resources and translation of bus addresses.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"


BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    This function stores the value of argument BusAddress into the
    memory location referenced by argument TranslatedAddress.  The
    argument referenced by AddressSpace is always set to 0 because
    there is no I/O port space in IA64 architecture.

    In the simulation environment, this function may be called by
    the video miniport driver only to determine the frame buffer
    physical address.

Return Value:

    Returns TRUE.

--*/
{
    *AddressSpace = 0;
    *TranslatedAddress = BusAddress;
    return TRUE;
}

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function always returns zero.

--*/
{
    return 0;
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function always returns zero.

--*/
{
    return 0;
}

NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Not supported.  This function returns STATUS_NOT_SUPPORTED.

--*/
{
    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++

Routine Description:

    No resource to be processed.  The function always returns
	STATUS_SUCCESS.

--*/
{
    return STATUS_SUCCESS;
}

VOID
HalReportResourceUsage (
    VOID
    )
{
    return;
}

VOID
KeFlushWriteBuffer(
    VOID
    )

/*++

Routine Description:

    Flushes all write buffers and/or other data storing or reordering
    hardware on the current processor.  This ensures that all previous
    writes will occur before any new reads or writes are completed.

    In the simulation environment, there is no write buffer and nothing
    needs to be done.

Arguments:

    None

Return Value:

    None.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simio.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simio.c

Abstract:

    This module implements the I/O port access routines.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"



UCHAR
READ_PORT_UCHAR (
    PUCHAR Port
    )
{
    return (*(volatile UCHAR * const)(Port));
}

USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )
{
    return (*(volatile USHORT * const)(Port));
}

ULONG
READ_PORT_ULONG (
    PULONG Port
    )
{
    return (*(volatile ULONG * const)(Port));
}

VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR  Value
    )
{
    *(volatile UCHAR * const)(Port) = Value;
    KeFlushWriteBuffer();
}

VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT  Value
    )
{
    *(volatile USHORT * const)(Port) = Value;
    KeFlushWriteBuffer();
}

VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG  Value
    )
{
    *(volatile ULONG * const)(Port) = Value;
    KeFlushWriteBuffer();
}

VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )
{
    PUCHAR ReadBuffer = Buffer;
    ULONG ReadCount;

    for (ReadCount = 0; ReadCount < Count; ReadCount++, ReadBuffer++) {
        *ReadBuffer = *(volatile UCHAR * const)(Port);
    }
}

VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )
{
    PUSHORT ReadBuffer = Buffer;
    ULONG ReadCount;

    for (ReadCount = 0; ReadCount < Count; ReadCount++, ReadBuffer++) {
        *ReadBuffer = *(volatile USHORT * const)(Port);
    }
}

VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )
{
    PULONG ReadBuffer = Buffer;
    ULONG ReadCount;

    for (ReadCount = 0; ReadCount < Count; ReadCount++, ReadBuffer++) {
        *ReadBuffer = *(volatile ULONG * const)(Port);
    }
}

VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG   Count
    )
{
    PUCHAR WriteBuffer = Buffer;
    ULONG WriteCount;

    for (WriteCount = 0; WriteCount < Count; WriteCount++, WriteBuffer++) {
        *(volatile UCHAR * const)(Port) = *WriteBuffer;
        KeFlushWriteBuffer();
    }
}

VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    )
{
    PUSHORT WriteBuffer = Buffer;
    ULONG WriteCount;

    for (WriteCount = 0; WriteCount < Count; WriteCount++, WriteBuffer++) {
        *(volatile USHORT * const)(Port) = *WriteBuffer;
        KeFlushWriteBuffer();
    }
}

VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG   Count
    )
{
    PULONG WriteBuffer = Buffer;
    ULONG WriteCount;

    for (WriteCount = 0; WriteCount < Count; WriteCount++, WriteBuffer++) {
        *(volatile ULONG * const)(Port) = *WriteBuffer;
        KeFlushWriteBuffer();
    }
}

VOID
HalHandleNMI(
    IN OUT PVOID NmiInfo
    )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simfw.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simfw.c

Abstract:

    This module implements the routines that transfer control
    from the kernel to the TAL and SAL code.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "arc.h"
#include "arccodes.h"


VOID
HalReturnToFirmware(
    IN FIRMWARE_ENTRY Routine
    )

/*++

Routine Description:

    Returns control to the firmware routine specified.  Since the simulation
    does not provide TAL and SAL support, it just stops the system.

    System reboot can be done here.

Arguments:

    Routine - Supplies a value indicating which firmware routine to invoke.

Return Value:

    Does not return.

--*/

{
    switch (Routine) {
    case HalHaltRoutine:
    case HalPowerDownRoutine:
    case HalRestartRoutine:
    case HalRebootRoutine:
        SscExit(0);
        break;

    default:
        DbgPrint("HalReturnToFirmware called\n");
        DbgBreakPoint();
        break;
    }
}

ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    )

/*++

Routine Description:

    This function locates an environment variable and returns its value.

    The only environment variable this implementation supports is
    "LastKnownGood".  The returned value is always "FALSE".

Arguments:

    Variable - Supplies a pointer to a zero terminated environment variable
        name.

    Length - Supplies the length of the value buffer in bytes.

    Buffer - Supplies a pointer to a buffer that receives the variable value.

Return Value:

    ESUCCESS is returned if the enviroment variable is located. Otherwise,
    ENOENT is returned.

--*/

{
    if (_stricmp(Variable, "LastKnownGood") != 0) {
        return ENOENT;
    }

    strncpy(Buffer, "FALSE", Length);

    return ESUCCESS;
}

ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Value
    )

/*++

Routine Description:

    This function creates an environment variable with the specified value.

    The only environment variable this implementation supports is
    "LastKnownGood".

Arguments:

    Variable - Supplies a pointer to an environment variable name.

    Value - Supplies a pointer to the environment variable value.

Return Value:

    ESUCCESS is returned if the environment variable is created. Otherwise,
    ENOMEM is returned.

--*/

{
    if (_stricmp(Variable, "LastKnownGood") != 0) {
        return ENOMEM;
    }

    if (_stricmp(Value, "TRUE") == 0) {
        return(ENOMEM);
    } else if (_stricmp(Value, "FALSE") == 0) {
        return ESUCCESS;
    } else {
        return(ENOMEM);
    }
}

VOID
HalSweepIcache (
    )

/*++

Routine Description:

    This function sweeps the entire I cache on the processor which it runs.

Arguments:

    None.

Return Value:

    None.

--*/

{
    return;
}

VOID
HalSweepDcache (
    )

/*++

Routine Description:

    This function sweeps the entire D cache on ths processor which it runs.

    Arguments:

    None.

    Return Value:

    None.

--*/

{
    return;
}

VOID
HalSweepIcacheRange (
     IN PVOID BaseAddress,
     IN ULONG Length
    )

/*++

Routine Description:
    This function sweeps the range of address in the I cache throughout the system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the data cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the data cache.


Return Value:

    None.

--*/

{
    return;
}

VOID
HalSweepDcacheRange (
    IN PVOID BaseAddress,
    IN ULONG Length
    )

/*++


Routine Description:
    This function sweeps the range of address in the I cache throughout the system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the data cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the data cache.


Return Value:

    None.

--*/

{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simkd.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
//     without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simkd.c

Abstract:

    Kernel debug com support.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"

extern int sprintf(char *, const char *, ...);

// #define KDDBG 1

#define TIMEOUT_COUNT  100    // 1024 * 200 
#define GET_RETRY_COUNT  1024
#define MSG_DEBUG_ENABLE        "Kernel Debugger Using: COM%x (Port %p, Baud Rate %d)\n"
#define MSG2_DEBUG_ENABLE        "Kernel Debugger Using named pipe: COM%x (Port %p, Baud Rate %d)\n"

PUCHAR KdComPortInUse=NULL;


BOOLEAN
KdPortInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    BOOLEAN Initialize
    )

/*++

Routine Description:

    This routine initialize a com port to support kernel debug.

Arguments:

    DebugParameters - Supplies a pointer a structure which optionally
                      sepcified the debugging port information.

    LoaderBlock - supplies a pointer to the loader parameter block.

    Initialize - Specifies a boolean value that determines whether the
                 debug port is initialized or just the debug port parameters
                 are captured.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PUCHAR PortAddress = NULL;
    ULONG Com = 0;
    UCHAR DebugMessage[80];
    PHYSICAL_ADDRESS LPDebugParameters;


    if (Initialize) {
        LPDebugParameters = MmGetPhysicalAddress (DebugParameters);
        if ( !SscKdInitialize( (PVOID)LPDebugParameters.QuadPart, (SSC_BOOL)Initialize )) { 

           // SscKd initialized sucessfully

       Com = DebugParameters->CommunicationPort;

           if ( Com != 0 ) {     // initialize port struct if not named-pipe
                //
                // set port address to default value.
                //

                if (PortAddress == NULL) {
                    switch (Com) {
                    case 1:
                       PortAddress = (PUCHAR)(ULONG_PTR)0x3f8;
                       break;
                    case 2:
                       PortAddress = (PUCHAR)(ULONG_PTR)0x2f8;
                       break;
                    case 3:
                       PortAddress = (PUCHAR)(ULONG_PTR)0x3e8;
                       break;
                    case 4:
                       PortAddress = (PUCHAR)(ULONG_PTR)0x2e8;
                    }
                }

                KdComPortInUse= PortAddress;

                sprintf(DebugMessage, MSG_DEBUG_ENABLE,
                        Com, PortAddress, DebugParameters->BaudRate);
                HalDisplayString("\n");
                HalDisplayString(DebugMessage);
            }
            else {   // port=0, named-pipe
                sprintf(DebugMessage, MSG2_DEBUG_ENABLE,
                        Com, PortAddress, DebugParameters->BaudRate);
                HalDisplayString("\n");
                HalDisplayString(DebugMessage);
            }
            return(TRUE);
        }
        else {
            // SscKdinitialize() failed
            return(FALSE);
        }
    }
    else { //  By pass. do not initialize
        return(FALSE);
    }
}

ULONG
KdPortGetByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it.

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
         necessary multiprocessor synchronization has been performed before this
         routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
        kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    PHYSICAL_ADDRESS LPInput;
    UCHAR DebugMessage[80];
    ULONG   limitcount, status;

    LPInput = MmGetPhysicalAddress (Input);
    limitcount = GET_RETRY_COUNT;

    while (limitcount != 0) {
        limitcount--;

        status = SscKdPortGetByte((PVOID)LPInput.QuadPart);
        if (status == CP_GET_SUCCESS) {
#ifdef KDDBG
            sprintf(DebugMessage,"%02x ", *Input);
            HalDisplayString(DebugMessage);
#endif
            return(CP_GET_SUCCESS);
        }
#ifdef KDDBG
        else {
            HalDisplayString(".");
        }
#endif
    }
    return status;
}

ULONG
KdPortPollByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it if one is available.

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
    kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    PHYSICAL_ADDRESS LPInput;
    UCHAR DebugMessage[80];
    ULONG   limitcount, status;
    
    LPInput = MmGetPhysicalAddress (Input);
    limitcount = TIMEOUT_COUNT;

    while (limitcount != 0) {
        limitcount--;

        status = SscKdPortGetByte((PVOID)LPInput.QuadPart);
        if (status == CP_GET_ERROR)
            return(CP_GET_ERROR);
        if (status == CP_GET_SUCCESS) {
#ifdef KDDBG
            sprintf(DebugMessage, "%02x ", *Input);
            HalDisplayString(DebugMessage);
#endif
            return(CP_GET_SUCCESS);
        }
#ifdef KDDBG
        HalDisplayString(".");
#endif
    }
    return (CP_GET_NODATA);
}

VOID
KdPortPutByte (
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the debug port.  
    
    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
#ifdef KDDBG
    UCHAR DebugMessage[80];

    sprintf(DebugMessage, "%02x-", Output);
    HalDisplayString(DebugMessage);
#endif
    SscKdPortPutByte(Output);
}

VOID
KdPortRestore (
    VOID
    )

/*++

Routine Description:

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/

{

}

VOID
KdPortSave (
    VOID
    )

/*++

Routine Description:

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simclk.s ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

//      TITLE("Manipulate Interrupt Request Level")
//++
//
// Module Name:
//
//    emclk.s
//
// Abstract:
//
//    This module implements the code necessary to adjust the ITM for time slicing,
//    to calibrate the ITC to determine the Time Base fundamental unit value (the
//    closest value for an update of 100ns).    
//
//
// Author:
//
//    Edward G. Chron (echron) 29-Apr-1996
//
// Environment:
//
//    Kernel mode only.
//
// Revision History:
//
//    29-Apr-1996    Initial Version for EAS2.1
//
//--

#include "ksia64.h"

         .file    "emclk.s"
         
         .global  HalpPerformanceFrequency

//++
//
// VOID
// HalpCalibrateTB (
//    )
//
// Routine Description:
//
//    This function calibrates the time base by determining the frequency 
//    that the ITC is running at to determine the interval value for a
//    100 ns time increment (used by clock and profile).
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

          LEAF_ENTRY(HalpCalibrateTB)

          add       t2 = @gprel(HalpPerformanceFrequency), gp  
          add       t1 = 1, r0
          ;;
          st8       [t2] = t1

  (p0)    br.ret.sptk brp

          LEAF_EXIT(HalpCalibrateTB)
//++
//
// VOID
// HalpUpdateITM (
//    ULONGLONG HalpClockCount
//    )
//
// Routine Description:
//
//    This function updates the ITM based on the current value of the
//    ITC combined with the arguement supplied.
//
// Arguments:
//
//    HalpClockCount (a0) - Supplies the increment to be added to the current ITC value.
//
// Return Value:
//
//    None.
//
//--

          LEAF_ENTRY(HalpUpdateITM)

          mov       t1 = ar.itc                   // get the current clock value
          ;;
          add       t1 = t1, a0                   // current time plus interval
          ;;
          mov       cr.itm = t1                   // update the itm with the new target time 

  (p0)    br.ret.sptk brp

          LEAF_EXIT(HalpUpdateITM)


//++
//
// VOID
// HalpEnableInterrupts (
//    )
//
// Routine Description:
//
//    This function enables interrupts.
//
// Arguments:
//
//    None.
//
// Return Value:
//
//    None.
//
//--

          LEAF_ENTRY(HalpEnableInterrupts)

          FAST_ENABLE_INTERRUPTS

  (p0)    br.ret.sptk brp

          LEAF_EXIT(HalpEnableInterrupts)


          LEAF_ENTRY(HalProcessorIdle)

          FAST_ENABLE_INTERRUPTS
          nop.m 0
          br.ret.sptk b0

          LEAF_EXIT(HalProcessorIdle)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simperfc.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simperfc.c

Abstract:

    This module implements the routines to support performance counters.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"


LARGE_INTEGER
KeQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency.

    In the simulation environment, this support is not needed.
    However, the performance monitor of the architecture may be
    used to implement this feature.

Arguments:

    PerformanceFrequency - optionally, supplies the address
    of a variable to receive the performance counter frequency.

Return Value:

    Current value of the performance counter will be returned.

--*/
{
    LARGE_INTEGER Result;

    Result.QuadPart = __getReg(CV_IA64_ApITC);
    if (ARGUMENT_PRESENT(PerformanceFrequency)) {
        PerformanceFrequency->QuadPart = 10000000; // 100ns/10MHz clock
    }

    return Result;
}

VOID
HalCalibratePerformanceCounter (
    IN volatile PLONG Number,
    IN ULONGLONG NewCount
    )

/*++

Routine Description:

    This routine resets the performance counter value for the current
    processor to zero. The reset is done such that the resulting value
    is closely synchronized with other processors in the configuration.

    In the simulation environment, the performance counter feature is
    not supported.  This routine does nothing.

Arguments:

    Number - Supplies a pointer to count of the number of processors in
    the configuration.

Return Value:

    None.

--*/
{
    *Number = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simdma.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simdma.c

Abstract:

    This module implements the DMA support routines for the HAL DLL.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"


PADAPTER_OBJECT
HalGetAdapter(
    IN PDEVICE_DESCRIPTION DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )

/*++

Routine Description:

    This function returns the appropriate adapter object for the DMA 
    device. However, there is no DMA device in the simulation 
    environment.  Therefore, the function returns NULL to indicate
    failure.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
    may be allocated by the device driver.

Return Value:

    NULL

--*/

{
    return NULL;
}

NTSTATUS
HalAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    )
/*++

Routine Description:

    As there is no DMA device in the simulation environment, this function 
    is not supported.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
    driver.

    Wcb - Supplies a wait context block for saving the allocation parameters.
    The DeviceObject, CurrentIrp and DeviceContext should be initalized.

    NumberOfMapRegisters - The number of map registers that are to be allocated
    from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
    invoked once the adapter channel (and possibly map registers) have been
    allocated.

Return Value:

    Returns STATUS_NOT_SUPPORTED

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/
{
    return STATUS_NOT_SUPPORTED;
}

ULONG
HalReadDmaCounter(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    This function reads the DMA counter and returns the number of bytes left
    to be transfered.  As there is no DMA device, a value of zero is always
    returned.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object to be read.

Return Value:

    Returns the number of bytes still be be transfered.

--*/

{
    return 0;
}

PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function allocates the memory for a common buffer and maps so
    that it can be accessed by a master device and the CPU.  As there
    is no DMA support, a value of NULL is always returned.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
    device.

    Length - Supplies the length of the common buffer to be allocated.

    LogicalAddress - Returns the logical address of the common buffer.

    CacheEnable - Indicates whether the memeory is cached or not.

Return Value:

    Returns the virtual address of the common buffer.  If the buffer cannot
    be allocated then NULL is returned.

--*/

{
    return NULL;
}

BOOLEAN
HalFlushCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    This function is called to flush any hardware adapter buffers when the
    driver needs to read data written by an I/O master device to a common
    buffer.  As there is no DMA support, that implies no buffers to flush
    and TRUE is always returned.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
    device.

    Length - Supplies the length of the common buffer. This should be the same
    value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
    must be the same value return by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
    must be the same value return by HalAllocateCommonBuffer.

Return Value:

    Returns TRUE if no errors were detected; otherwise, FALSE is return.

--*/

{
    return TRUE;
}

VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function frees a common buffer and all of the resouces it uses.
    There is no buffer to be freed in the simulation environment. The
    function simply returns.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
    device.

    Length - Supplies the length of the common buffer. This should be the same
    value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
    must be the same value return by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
    must be the same value return by HalAllocateCommonBuffer.

    CacheEnable - Indicates whether the memeory is cached or not.

Return Value:

    None

--*/

{
    return;
}

PVOID
HalAllocateCrashDumpRegisters(
    IN PADAPTER_OBJECT AdapterObject,
    IN PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This routine is called during the crash dump disk driver's initialization
    to allocate a number map registers permanently.  It is not supported and
    NULL is always returned to indicate allocation failure.  The lack of this
    capability implies that the crash dump disk driver is not supported.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
    driver.
    NumberOfMapRegisters - Number of map registers requested. This field
    will be updated to reflect the actual number of registers allocated
    when the number is less than what was requested.

Return Value:

    Returns NULL.

--*/
{
    return NULL;
}

BOOLEAN
IoFlushAdapterBuffers(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine flushes the DMA adapter object buffers. In the simulation
    environment, nothing needs to be done and TRUE is always returned.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
    controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
    buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
    or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
    where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
    the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    return TRUE;
}

VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, then kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.
	
    In the simulation environment, this routine does nothing and returns.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{
    return;
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

    This routine deallocates the map registers for the adapter.  If there are
    any queued adapter waiting for an attempt is made to allocate the next
    entry.

    In the simulation environment, the routine does nothing and returns.

Arguments:

    AdapterObject - The adapter object to where the map register should be
    returned.

    MapRegisterBase - The map register base of the registers to be deallocated.

    NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

    None

--+*/
{
    return;
}

PHYSICAL_ADDRESS
IoMapTransfer(
    IN PADAPTER_OBJECT AdapterObject,
    IN PMDL Mdl,
    IN PVOID MapRegisterBase,
    IN PVOID CurrentVa,
    IN OUT PULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

    In the simulation environment, no map register is supported and a
    logical address of zero is always returned.


Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
    controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
    being read or written.

    MapRegisterBase - The address of the base map register that has been
    allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
    that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
    number of map registers that need to be written to map the transfer.
    Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
    to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    PHYSICAL_ADDRESS result;

    result.HighPart = 0;
    result.LowPart = 0;
    return (result);
}

ULONG
HalGetDmaAlignmentRequirement (
    VOID
    )

/*++

Routine Description:

    This function returns the alignment requirements for DMA transfers on
    host system.

Arguments:

    None.

Return Value:

    The DMA alignment requirement is returned as the fucntion value.

--*/

{

    return 8;
}

VOID
HalFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    )

/*++

Routine Description:

    This function flushes the I/O buffer specified by the memory descriptor
    list from the data cache on the current processor.

Arguments:

    Mdl - Supplies a pointer to a memory descriptor list that describes the
        I/O buffer location.

    ReadOperation - Supplies a boolean value that determines whether the I/O
        operation is a read into memory.

    DmaOperation - Supplies a boolean value that determines whether the I/O
        operation is a DMA operation.

Return Value:

    None.

--*/

{
    //
    // BUGBUG:  This still needs to be done
    //

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simswint.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simswint.c

Abstract:

    This module implements the routines to support software interrupts.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "ssc.h"


VOID
FASTCALL
HalRequestSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to request a software interrupt to the
    system. Also, this routine calls the SSC function 
    SscGenerateInterrupt() to request the simulator to deliver
    the specified interrupt.  As a result, the associated bit in
    the EIRR will be set.

Arguments:

    RequestIrql - Supplies the request IRQL value

Return Value:

    None.

--*/
{
    switch (RequestIrql) {

    case APC_LEVEL:
        SscGenerateInterrupt (SSC_APC_INTERRUPT);
        break;

    case DISPATCH_LEVEL:
        SscGenerateInterrupt (SSC_DPC_INTERRUPT);
        break;

    default:
        DbgPrint("HalRequestSoftwareInterrupt: Undefined Software Interrupt!\n");
        break;

    }
}

VOID
HalClearSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to clear a possible pending software interrupt.
    The kernel has already cleared the corresponding bit in the EIRR.
    The support for this function is optional, depending on the external
    interrupt control.
 
Arguments:

    RequestIrql - Supplies the request IRQL value

Return Value:

    None.

--*/
{
    switch (RequestIrql) {

    case APC_LEVEL:
    case DISPATCH_LEVEL:

        //
        // Nothing to do.
        //

        break;

    default:

        DbgPrint("HalClearSoftwareInterrupt: Undefined Software Interrupt!\n");
        break;

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simkrnl.c ===
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simkrnl.c

Abstract:

    This module implements the kernel support routines for the HAL DLL.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"

extern VOID  HalpCalibrateTB(); 
static short HalpOwnDisplay = TRUE;

ULONG
HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


BOOLEAN
HalAllProcessorsStarted (
    VOID
    )

/*++

Routine Description:

    This function returns TRUE if all the processors in the system started
    successfully.

Arguments:

    None.

Return Value:

    Returns TRUE.

--*/

{
    return TRUE;
}

BOOLEAN
HalStartNextProcessor (
    IN PLOADER_PARAMETER_BLOCK   pLoaderBlock,
    IN PKPROCESSOR_STATE         pProcessorState
    )

/*++

Routine Description:

    This function always returns FALSE on a uni-processor platform 
    because there is no second processor to be started.

Arguments:

    pLoaderBlock - Loader Block.

    pProcessorState - A description of the processor state.

Return Value:

    Returns TRUE.

--*/

{
    //
    // no other processors
    //

    return FALSE;
}

VOID
HalRequestIpi (
    IN ULONG Mask
    )

/*++

Routine Description:

    This function does nothing on a uni-processor platform.

Arguments:

    Mask - A mask that specifies the target processor(s) to which an
           IPI is to be sent.

Return Value:

    None.

--*/

{
    //
    // no other processors.
    //

    return;
}

BOOLEAN
HalMakeBeep (
    IN ULONG Frequency
    )

/*++

Routine Description:

    This function calls SSC function SscMakeBeep() to make a beep sound
    when the specified frequency has a non-zero value.

Arguments:

    Frequency - the frequency of the sound to be made.

Return Value:

    None.

--*/

{
    if (Frequency > 0) {
        SscMakeBeep(Frequency);
    }
    return TRUE;
}

BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This function calls the SSC function SscQueryRealTimeClock to
    get the real time clock data from the host.  This function always
    succeeds in the simulation environment and should return TRUE at
    all times.

Arguments:

    TimeFields - Real Time Clock Data

Return Value:

    Returns TRUE if successful; otherwise, FALSE.

--*/

{
    PMDL Mdl;
    SSC_TIME_FIELDS SscTimeFields;
    PHYSICAL_ADDRESS physicalAddress;

/*
    Mdl = MmCreateMdl (NULL, TimeFields, sizeof(TIME_FIELDS));
    MmProbeAndLockPages (Mdl, KernelMode, IoModifyAccess);
*/

    physicalAddress = MmGetPhysicalAddress (&SscTimeFields);
    SscQueryRealTimeClock((PVOID)physicalAddress.QuadPart);

    TimeFields->Year = (USHORT)SscTimeFields.Year;
    TimeFields->Month = (USHORT)SscTimeFields.Month;
    TimeFields->Day = (USHORT)SscTimeFields.Day;
    TimeFields->Hour = (USHORT)SscTimeFields.Hour;
    TimeFields->Minute = (USHORT)SscTimeFields.Minute;
    TimeFields->Second = (USHORT)SscTimeFields.Second;
    TimeFields->Milliseconds = (USHORT)SscTimeFields.Milliseconds;
    TimeFields->Weekday = (USHORT)SscTimeFields.WeekDay;

/*
    MmUnlockPages (Mdl);
*/

    return TRUE;
}

BOOLEAN
HalSetRealTimeClock (
    IN PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This function calls the SSC function SscQueryRealTimeClock to
    get the real time clock data from the host.

Arguments:

    TimeFields - Real Time Clock Data

Return Value:

    None.

--*/

{
    DbgPrint("HalSetRealTimeClock: Warning.\n");
    return TRUE;
}

VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    )

/*++

Routine Description:

    This function does nothing in the simulation environment.

Arguments:

    MicroSeconds - Number of microseconds to stall the processor. 

Return Value:

    None.

--*/

{
    return;
}

VOID
HalQueryDisplayParameters (
    OUT PULONG WidthInCharacters,
    OUT PULONG HeightInLines,
    OUT PULONG CursorColumn,
    OUT PULONG CursorRow
    )

/*++

Routine Description:

    This routine returns information about the display area and current
    cursor position.  In the simulation environment, the function does 
    nothing.  Therefore, the kernel should either ignore the returned
    results or not call the function at all.

Arguments:

    WidthInCharacter - Supplies a pointer to a varible that receives
        the width of the display area in characters.

    HeightInLines - Supplies a pointer to a variable that receives the
        height of the display area in lines.

    CursorColumn - Supplies a pointer to a variable that receives the
        current display column position.

    CursorRow - Supplies a pointer to a variable that receives the
        current display row position.

Return Value:

    None.

--*/

{
    return;
}

VOID
HalSetDisplayParameters (
    IN ULONG CursorColumn,
    IN ULONG CursorRow
    )
/*++

Routine Description:

    This routine does nothing in the simulation environment.

Arguments:

    CursorColumn - Supplies the new display column position.

    CursorRow - Supplies a the new display row position.

Return Value:

    None.

--*/

{
    return;
}

VOID
HalDisplayString (
    PUCHAR String
    )

/*++

Routine Description:

    This routine calls the SSC function SscDisplayString to display 
    the specified character string in a window.

Arguments:

    String - Supplies a pointer to the characters that are to be displayed.

Return Value:

    None.

    N.B. The string must be resident in memory or it must be paged in.

--*/

{
    PHYSICAL_ADDRESS StringBufferPtr;

    if (String) {
        StringBufferPtr = MmGetPhysicalAddress (String);
        if (StringBufferPtr.QuadPart != 0ULL) {
            SscDisplayString((PVOID)StringBufferPtr.QuadPart);
        }
    }
}

VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    )

/*++

Routine Description:

    This routine switches ownership of the display away from the HAL to
    the system display driver. It is called when the system has reached
    a point during bootstrap where it is self supporting and can output
    its own messages. Once ownership has passed to the system display
    driver any attempts to output messages using HalDisplayString must
    result in ownership of the display reverting to the HAL and the
    display hardware reinitialized for use by the HAL.

Arguments:

    ResetDisplayParameters - if non-NULL the address of a function
    the hal can call to reset the video card.

Return Value:

    None.

--*/

{
    HalpOwnDisplay = FALSE;
    return;
}

VOID
HalInitializeProcessor (
    IN ULONG Number,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function is called early in the initialization of the kernel
    to perform platform dependent initialization for each processor
    before the HAL Is fully functional.

    N.B. When this routine is called, the PCR is present but is not
         fully initialized.

Arguments:

    Number - Supplies the number of the processor to initialize.

Return Value:

    None.

--*/

{
    PCR->StallScaleFactor = 0;
    return;
}

BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for
    IA64/NT in the simulation environment.

Arguments:

    Phase - A number that specifies the initialization phase that the
            kernel is in.

    LoaderBlock - Loader Block Data.

Return Value:

    A value of TRUE is returned is the initialization was successfully
    complete. Otherwise a value of FALSE is returend.

--*/

{

    PKPRCB Prcb;

    Prcb = PCR->Prcb;

    if (Phase == 0) {
        
        //
        // If processor 0 is being initialized, then initialize various
        // variables.
        //

        if (Prcb->Number == 0) {

            //
            // Set the interval clock increment value.
            //

            HalpCalibrateTB();
            
            // *** TBD define these constants
            //KeSetTimeIncrement(MAXIMUM_CLOCK_INTERVAL, MINIMUM_CLOCK_INTERVAL);
            KeSetTimeIncrement(100000, 10000);
        }

        //
        // Initialize the interrupt structures
        //

        HalpInitializeInterrupts ();

        //
        // Fill in handlers for APIs which this hal supports
        //

        HalQuerySystemInformation = HaliQuerySystemInformation;
        HalSetSystemInformation = HaliSetSystemInformation;

    } else {

        //
        // Phase 1 initialization
        //

        if (Prcb->Number == 0) {

            //
            //  If P0, then setup global vectors
            //

            HalpRegisterInternalBusHandlers ();

        }
    }

    return TRUE;
}



VOID
HalChangeColorPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN ULONG PageFrame
    )
/*++

Routine Description:

   This function changes the color of a page if the old and new colors
   do not match.  

   BUGBUG:  For now this is a stub.  Needs to be filled in.

Arguments:

   NewColor - Supplies the page aligned virtual address of the
      new color of the page to change.

   OldColor - Supplies the page aligned virtual address of the
      old color of the page to change.

   pageFrame - Supplies the page frame number of the page that
      is changed.

Return Value:

   None.

--*/
{
    return;
}

PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusInterfaceType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    )
/*++

Routine Description:

    Stub function to map old style code into new HalRegisterBusHandler code.

    Note we can add our specific bus handler functions after this bus
    handler structure has been added since this is being done during
    hal initialization.

--*/
{
    PBUS_HANDLER     Bus;


    //
    // Create bus handler - new style
    //

    HaliRegisterBusHandler (
        InterfaceType,
        BusDataType,
        BusNumber,
        ParentBusInterfaceType,
        ParentBusNumber,
        BusSpecificData,
        NULL,
        &Bus
    );

    return Bus;
}

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

Arguments:

    BusInterruptLevel - Supplies the bus specific interrupt level.

    BusInterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{

    //
    // Just return the passed parameters.
    //

    *Irql = (KIRQL) BusInterruptLevel;
    *Affinity = 1;
    return( BusInterruptLevel << VECTOR_IRQL_SHIFT );
}

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/
{
    *TranslatedAddress = BusAddress;
    return TRUE;
}

BOOLEAN
HalpTranslateIsaBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/
{
    BOOLEAN     Status;

    //
    // Translated normally
    //

    Status = HalpTranslateSystemBusAddress (
                    BusHandler,
                    RootHandler,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                );

    return Status;
}



VOID
HalpRegisterInternalBusHandlers (
    VOID
    )
{
    PBUS_HANDLER    Bus;

    if (KeGetCurrentPrcb()->Number) {
        // only need to do this once
        return ;
    }

    //
    // Initalize BusHandler data before registering any handlers
    //

    HalpInitBusHandler ();

    //
    // Build internal-bus 0, or system level bus
    //

    Bus = HalpAllocateBusHandler (
            Internal,
            ConfigurationSpaceUndefined,
            0,                              // Internal BusNumber 0
            InterfaceTypeUndefined,         // no parent bus
            0,
            0                               // no bus specfic data
            );

    Bus->GetInterruptVector  = HalpGetSystemInterruptVector;
    Bus->TranslateBusAddress = HalpTranslateSystemBusAddress;

    //
    // Build Isa/Eisa bus #0
    //

#if 0
    Bus = HalpAllocateBusHandler (Eisa, EisaConfiguration, 0, Internal, 0, 0);
    Bus->GetBusData = HalpGetEisaData;
    Bus->GetInterruptVector = HalpGetEisaInterruptVector;
    Bus->AdjustResourceList = HalpAdjustEisaResourceList;
    Bus->TranslateBusAddress = HalpTranslateEisaBusAddress;
#endif

    Bus = HalpAllocateBusHandler (Isa, ConfigurationSpaceUndefined, 0, Internal, 0,
0);
    Bus->GetBusData = HalpNoBusData;
    Bus->TranslateBusAddress = HalpTranslateIsaBusAddress;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsym\halsym.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    halsym.c

--*/

#include "nthal.h"
#include "acpitabl.h"
#ifdef _X86_
#include "pcmp.inc"
#include "ntapic.inc"
#include "halp.h"
#include "ixisa.h"
#endif


#ifdef _X86_
ADAPTER_OBJECT                      a1;
#endif
CONTROLLER_OBJECT                   c1;
DESCRIPTION_HEADER                  descriptionheader;
FADT                                fadt;
RSDP                                rsdp;
FACS                                facs;
RSDT                                rsdt;
GEN_ADDR                            genaddr;
LARGE_INTEGER                       largeinteger;
MAPIC                               mapic;
PROCLOCALAPIC                       proclocalapic;
IOAPIC                              ioapic;
ISA_VECTOR                          isavector;
IO_NMISOURCE                        ionmisource;
LOCAL_NMISOURCE                     localnmisource;
PROCLOCALSAPIC                      proclocalsapic;
IOSAPIC                             iosapic;
PLATFORM_INTERRUPT                  platforminterrupt;

#ifdef _X86_
struct HalpMpInfo                   halpMpInfoTable;
#endif

int cdecl main() {
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsym\acpiuppic\makefile.inc ===
$(O)\halacpi.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simtimer.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simtimer.c

Abstract:

    This module implements the routines to provide timer (both
    interval and profile) interrupt support.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include <ssc.h>


ULONGLONG 
    HalpUpdateITM(
    IN ULONGLONG HalpClockCount
    );

ULONG
HalpSetTimeIncrement (
    IN ULONG DesiredIncrement
    );

__declspec(dllimport)
BOOLEAN
KdPollBreakIn(
    VOID
    );

ULONGLONG HalpPerformanceFrequency;

static ULONGLONG HalpClockCount;
static ULONG   HalpCurrentTimeIncrement = DEFAULT_CLOCK_INTERVAL;
static ULONG   HalpNextTimeIncrement = DEFAULT_CLOCK_INTERVAL;
static ULONG   HalpNewTimeIncrement  = DEFAULT_CLOCK_INTERVAL;
#define GAMBIT 1
#ifdef GAMBIT
ULONG   HalpKdPollDelayCount = 0;
#endif

static ULONG_PTR   HalpProfileInterval = (ULONG_PTR)DEFAULT_PROFILE_INTERVAL;
static BOOLEAN    HalpProfileStopped = TRUE;


ULONG
HalSetTimeIncrement (
    IN ULONG DesiredIncrement
    )

/*++

Routine Description:

    This routine initialize system time clock to generate an
    interrupt at every DesiredIncrement interval.  It calls the
    SSC function SscSetPeriodicInterruptInterval to set the new
    interval.  The new interval takes effect after the next timer
    interval interrupt is deliverd.

Arguments:

    DesiredIncrement - desired interval between every timer tick (in 100ns unit.)

Return Value:

    The time increment set.

--*/

{
    SscSetPeriodicInterruptInterval (
        SSC_CLOCK_TIMER_INTERRUPT,
        100 * DesiredIncrement
        );
    HalpNextTimeIncrement = DesiredIncrement;
    HalpSetTimeIncrement(DesiredIncrement);
    return DesiredIncrement;
}

VOID
HalStartProfileInterrupt(
    IN KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This routine calls SscSetPeriodicInterruptInterval to request
    the simulator to send profile timer interrupt to the OS at the
    interval specified by HalpProfileInterval.

    It also sets HalpProfileStopped to FALSE.

Arguments:

    Reserved

Return Value:

    Returns nothing.

--*/

{
    SscSetPeriodicInterruptInterval (
        SSC_PROFILE_TIMER_INTERRUPT,
        100 * (ULONG)HalpProfileInterval
        );
    HalpProfileStopped = FALSE;
}

VOID
HalStopProfileInterrupt(
    IN KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    What we do here is change the interrupt interval to 0. 
    Essentially, the simulator stop sending profile timer 
    interrupts to the OS.

    It also sets HalpProfileStopped to TRUE.

Arguments:

    Reserved

Return Value:

    Returns nothing.

--*/

{
    SscSetPeriodicInterruptInterval (SSC_PROFILE_TIMER_INTERRUPT, 0);
    HalpProfileStopped = TRUE;
}

ULONG_PTR
HalSetProfileInterval(
    IN ULONG_PTR Interval
    )

/*++

Routine Description:

    This procedure sets the interrupt rate (and thus the sampling
    interval) for the profiling interrupt.

    If profiling is active (HalpProfileStopped == FALSE), the SSC
    function SscSetPeriodicInterruptInterval is called to set the
    new profile timer interrupt interval.

    Otherwise, a simple rate validation computation is done.

Arguments:

    Interval - Time interval in 100ns units.

Return Value:

    Time interval actually used by the system.

--*/

{

    //
    // If the specified profile interval is less that the minimum profile
    // interval or greater than the maximum profile interval, then set the
    // profile interval to the minimum or maximum as appropriate.
    //

    //
    // Check to see if the Desired Interval is reasonable, if not adjust it.
    // We can probably remove this check once we've verified everything works
    // as anticipated.
    //
    
    if (Interval > MAXIMUM_PROFILE_INTERVAL) {
        HalpProfileInterval = MAXIMUM_PROFILE_INTERVAL;
    } else if (Interval < MINIMUM_PROFILE_INTERVAL) {   
        HalpProfileInterval = MINIMUM_PROFILE_INTERVAL;
    } else {
        HalpProfileInterval = Interval;
    }

    //
    // Profiling is active.  Make the new interrupt interval effective.
    //

    if (!HalpProfileStopped) {
        SscSetPeriodicInterruptInterval (
            SSC_PROFILE_TIMER_INTERRUPT, 
            100 * (ULONG)HalpProfileInterval
            );
    }

    return HalpProfileInterval;
}

VOID 
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Clock Interrupt Handler, for P0 processor only.
    
    N.B. Assumptions: Comes with IRQL set to CLOCK_LEVEL to disable
         interrupts. 

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
    //
    // Call the kernel to update system time.
    //  P0 updates System time and Run Time.
    //
    
    KeUpdateSystemTime(TrapFrame,HalpCurrentTimeIncrement);

    HalpCurrentTimeIncrement = HalpNextTimeIncrement;

    HalpNextTimeIncrement    = HalpNewTimeIncrement;

    //
    // Increment ITM, accounting for interrupt latency.
    //

    HalpUpdateITM(HalpClockCount);

#ifdef GAMBIT
    if (!HalpKdPollDelayCount) {
        HalpKdPollDelayCount = 4;
#endif
    if ( KdDebuggerEnabled && KdPollBreakIn() )
       KeBreakinBreakpoint();
#ifdef GAMBIT
    } else {
        HalpKdPollDelayCount--;
    }
#endif

}

VOID 
HalpClockInterruptPn (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Clock Interrupt Handler, for processors other than P0.
    
    N.B. Assumptions: Comes with IRQL set to CLOCK_LEVEL to disable
         interrupts. 

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
    //
    // Call the kernel to update run time.
    //  Pn updates only Run time. 
    //

    KeUpdateRunTime(TrapFrame);

    //
    // Increment ITM, accounting for interrupt latency.
    //

    HalpUpdateITM(HalpClockCount);

}

VOID 
HalpProfileInterrupt (
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Profile Interrupt Handler.

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
//    KeProfileInterrupt (TrapFrame);
}

ULONG
HalpSetTimeIncrement (
    IN ULONG DesiredIncrement
    )

/*++

Routine Description:

    This function is called to set the clock interrupt rate to the frequency
    required by the specified time increment value.

    N.B. This function is only executed on the processor that keeps the
         system time.
         
         This function should eventually become the HalSetTimeIncrement once 
         we actually start using the ITC/ITM. Not currently supported by the
         simulator.

Arguments:

    DesiredIncrement - Supplies desired number of 100ns units between clock
        interrupts.

Return Value:

    The actual time increment in 100ns units.

--*/

{
    ULONGLONG NextIntervalCount;
    KIRQL     OldIrql;

    //
    // DesiredIncrement must map within the acceptable range.
    //
    if (DesiredIncrement < MINIMUM_CLOCK_INTERVAL)
        DesiredIncrement = MINIMUM_CLOCK_INTERVAL;
    else if (DesiredIncrement > MAXIMUM_CLOCK_INTERVAL)    
             DesiredIncrement = MAXIMUM_CLOCK_INTERVAL;
    
    //
    // Raise IRQL to the highest level, set the new clock interrupt
    // parameters, lower IRQl, and return the new time increment value.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // Calculate the actual 64 bit time value which forms the target interval.
    // The resulting value is added to the ITC to form the new ITM value.
    // HalpPerformanceFrequency is the calibrated value for the ITC whose value
    // works out to be 100ns (or as close as we can come).
    //
        
    NextIntervalCount = HalpPerformanceFrequency * DesiredIncrement;

    //
    // Calculate the number of 100ns units to report to the kernel every
    // time the ITM matches the ITC with this new period.  Note, for small
    // values of DesiredIncrement (min being 10000, ie 1ms), truncation
    // in the above may result in a small decrement in the 5th decimal
    // place.  As we are effectively dealing with a 4 digit number, eg
    // 10000 becomes 9999.something, we really can't do any better than
    // the following.
    //

    HalpClockCount = NextIntervalCount;
    HalpNewTimeIncrement = DesiredIncrement;
    KeLowerIrql(OldIrql);
    return DesiredIncrement;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\x86bios.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1994  Microsoft Corporation

Module Name:

    x86bios.c

Abstract:


    This module implements the platform specific interface between a device
    driver and the execution of x86 ROM bios code for the device.

Author:

    William K. Cheung (wcheung) 20-Mar-1996

    based on the version by David N. Cutler (davec) 17-Jun-1994

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

//
// Define global data.
//

ULONG HalpX86BiosInitialized = FALSE;
ULONG HalpEnableInt10Calls = FALSE;

BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    )

/*++

Routine Description:

    This function provides the platform specific interface between a device
    driver and the execution of the x86 ROM bios code for the specified ROM
    bios command.

Arguments:

    BiosCommand - Supplies the ROM bios command to be emulated.

    Eax to Ebp - Supplies the x86 emulation context.

Return Value:

    A value of TRUE is returned if the specified function is executed.
    Otherwise, a value of FALSE is returned.

--*/

{

    CONTEXT86 Context;

    //
    // If the x86 BIOS Emulator has not been initialized, then return FALSE.
    //

    if (HalpX86BiosInitialized == FALSE) {
        return FALSE;
    }

    //
    // If the Video Adapter initialization failed and an Int10 command is
    // specified, then return FALSE.
    //

    if ((BiosCommand == 0x10) && (HalpEnableInt10Calls == FALSE)) {
        return FALSE;
    }

    //
    // Copy the x86 bios context and emulate the specified command.
    //

    Context.Eax = *Eax;
    Context.Ebx = *Ebx;
    Context.Ecx = *Ecx;
    Context.Edx = *Edx;
    Context.Esi = *Esi;
    Context.Edi = *Edi;
    Context.Ebp = *Ebp;

#if 0
    if (x86BiosExecuteInterrupt((UCHAR)BiosCommand,
                                &Context,
                                (PVOID)HalpIoControlBase,
                                (PVOID)HalpIoMemoryBase) != XM_SUCCESS) {
        return FALSE;
    }
#endif

    //
    // Copy the x86 bios context and return TRUE.
    //

    *Eax = Context.Eax;
    *Ebx = Context.Ebx;
    *Ecx = Context.Ecx;
    *Edx = Context.Edx;
    *Esi = Context.Esi;
    *Edi = Context.Edi;
    *Ebp = Context.Ebp;
    return TRUE;
}

VOID
HalpInitializeX86DisplayAdapter(
    VOID
    )

/*++

Routine Description:

    This function initializes a display adapter using the x86 bios emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{

#if 0
    //
    // If I/O Ports or I/O memory could not be mapped, then don't
    // attempt to initialize the display adapter.
    //

    if (HalpIoControlBase == NULL || HalpIoMemoryBase == NULL) {
        return;
    }

    //
    // Initialize the x86 bios emulator.
    //

    x86BiosInitializeBios(HalpIoControlBase, HalpIoMemoryBase);
    HalpX86BiosInitialized = TRUE;

    //
    // Attempt to initialize the display adapter by executing its ROM bios
    // code. The standard ROM bios code address for PC video adapters is
    // 0xC000:0000 on the ISA bus.
    //

    if (x86BiosInitializeAdapter(0xc0000,
                                 NULL,
                                 (PVOID)HalpIoControlBase,
                                 (PVOID)HalpIoMemoryBase) != XM_SUCCESS) {



        HalpEnableInt10Calls = FALSE;
        return;
    }
#endif

    HalpEnableInt10Calls = TRUE;
    return;
}

VOID
HalpResetX86DisplayAdapter(
    VOID
    )

/*++

Routine Description:

    This function resets a display adapter using the x86 bios emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{

    CONTEXT86 Context;

    //
    // Initialize the x86 bios context and make the INT 10 call to initialize
    // the display adapter to 80x25 color text mode.
    //

    Context.Eax = 0x0003;  // Function 0, Mode 3
    Context.Ebx = 0;
    Context.Ecx = 0;
    Context.Edx = 0;
    Context.Esi = 0;
    Context.Edi = 0;
    Context.Ebp = 0;

    HalCallBios(0x10,
                &Context.Eax,
                &Context.Ebx,
                &Context.Ecx,
                &Context.Edx,
                &Context.Esi,
                &Context.Edi,
                &Context.Ebp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsym\acpimpapic\makefile.inc ===
$(O)\halmacpi.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsym\sources.inc ===
TARGETTYPE=NOTARGET
TARGETPATH=obj

INCLUDES=\
    ..;\
    $(DDK_INC_PATH)\wdm; \
    $(PROJECT_ROOT)\ntos\inc;\
    $(PROJECT_ROOT)\hals\inc; \
    $(PROJECT_ROOT)\hals\halx86\i386; \
    $(DDK_INC_PATH);\
    $(HALKIT_INC_PATH)

SOURCES=..\halsym.c

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsym\acpiupapic\makefile.inc ===
$(O)\halaacpi.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halssc\ia64\simsxint.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    simsxint.c

Abstract:

    This module implements the routines to manage the 
    system interrupt and IRQL.

Author:

    William K. Cheung (wcheung) 14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"


PULONGLONG HalEOITable[256];


VOID
HalpInitEOITable(
    VOID
)
{
USHORT Index;

    for (Index=0; Index < 256; Index++) {
        HalEOITable[Index] = 0;
    }
}

VOID
HalpInitializeInterrupts (
    VOID 
    )
{
    ULONG Index;
    ULONG InterruptVector;

    //
    // Interrupt routine table initialization in KiInitializeKernel.
    //

    //
    // interval timer interrupt; 10ms by default
    //

    InterruptVector = CLOCK_LEVEL << VECTOR_IRQL_SHIFT;
    PCR->InterruptRoutine[InterruptVector] = (PKINTERRUPT_ROUTINE)HalpClockInterrupt;

    SscConnectInterrupt(SSC_CLOCK_TIMER_INTERRUPT, InterruptVector);
    SscSetPeriodicInterruptInterval(
        SSC_CLOCK_TIMER_INTERRUPT,
        DEFAULT_CLOCK_INTERVAL * 100
        );

    //
    // profile timer interrupt; turned off initially
    //

    InterruptVector = PROFILE_LEVEL << VECTOR_IRQL_SHIFT;
    PCR->InterruptRoutine[InterruptVector] = (PKINTERRUPT_ROUTINE)HalpProfileInterrupt;

    SscConnectInterrupt(SSC_PROFILE_TIMER_INTERRUPT, InterruptVector);
    SscSetPeriodicInterruptInterval (SSC_PROFILE_TIMER_INTERRUPT, 0);

    //
    // s/w interrupts; corresponding ISRs provided by kernel.
    //

    SscConnectInterrupt (SSC_APC_INTERRUPT, APC_VECTOR);
    SscConnectInterrupt (SSC_DPC_INTERRUPT, DISPATCH_VECTOR);
}

BOOLEAN
HalEnableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This routine enables the specified system interrupt.

    N.B. This routine assumes that the caller has provided any required
         synchronization to enable a system interrupt.

Arguments:

    Vector - Supplies the vector of the system interrupt that is enabled.

    Irql - Supplies the IRQL of the interrupting source.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or
                    Latched.

Return Value:

    TRUE if the system interrupt was enabled

--*/

{
    KIRQL OldIrql;
    BOOLEAN Result = TRUE;

    //
    // Raise IRQL to the highest level.
    //

    KeRaiseIrql (HIGH_LEVEL, &OldIrql);

    switch (Irql) {

    case DISK_IRQL:
        SscConnectInterrupt (SSC_DISK_INTERRUPT, Vector);
        break;

    case MOUSE_IRQL:
        SscConnectInterrupt (SSC_MOUSE_INTERRUPT, Vector);
        break;

    case KEYBOARD_IRQL:
        SscConnectInterrupt (SSC_KEYBOARD_INTERRUPT, Vector);
        break;

    case SERIAL_IRQL:
        SscConnectInterrupt (SSC_SERIAL_INTERRUPT, Vector);
        break;

    default:
        //
        // Invalid Device Interrupt Source; only three devices 
        // defined in the Gambit platform.
        //
        Result = FALSE;
        DbgPrint("HalEnableSystemInterrupt: Invalid Device Interrupt Source");
        break;
    }

    //
    // Restore the original IRQL
    //

    KeLowerIrql (OldIrql);
	
    return (Result);
}

VOID
HalDisableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine disables the specified system interrupt.

    In the simulation environment, this function does nothing and returns.

    N.B. This routine assumes that the caller has provided any required
        synchronization to disable a system interrupt.

Arguments:

    Vector - Supplies the vector of the system interrupt that is disabled.

    Irql - Supplies the IRQL of the interrupting source.

Return Value:

    None.

--*/

{
    return;
}

ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

    This function returns the system interrupt vector and IRQL level
    corresponding to the specified bus interrupt level and/or vector. The
    system interrupt vector and IRQL are suitable for use in a subsequent call
    to KeInitializeInterrupt.

    In the simulation environment, just return the parameters passed in 
    from the caller - the device driver.

Arguments:

    InterfaceType - Supplies the type of bus which the vector is for.

    BusNumber - Supplies the bus number for the device.

    BusInterruptLevel - Supplies the bus specific interrupt level.

    BusInterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the affinity for the requested vector

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/

{
    //
    // Just return the passed parameters.
    //

    *Irql = (KIRQL) BusInterruptLevel;
    *Affinity = 1;
    return( BusInterruptLevel << VECTOR_IRQL_SHIFT );

}

BOOLEAN
HalBeginSystemInterrupt(
    IN KIRQL Irql,
    IN CCHAR Vector,
    OUT PKIRQL OldIrql
    )

/*++

Routine Description:

    This routine raises the IRQL to the level of the specified
    interrupt vector.  It is called by the hardware interrupt
    handler before any other interrupt service routine code is
    executed.  The CPU interrupt flag is set on exit.

Arguments:

    Irql   - Supplies the IRQL to raise to

    Vector - Supplies the vector of the interrupt to be
             dismissed

    OldIrql- Location to return OldIrql

Return Value:

    TRUE - Interrupt successfully dismissed and Irql raised.
           This routine cannot fail.

--*/

{
    return (TRUE);
}

VOID
HalEndSystemInterrupt (
   IN KIRQL NewIrql,
   IN ULONG Vector
   )

/*++

Routine Description:

    This routine is used to lower IRQL to the specified value.
    The IRQL and PIRQL will be updated accordingly.

    NOTE: This routine simulates software interrupt as long as
          any pending SW interrupt level is higher than the current
          IRQL, even when interrupts are disabled.

Arguments:

    NewIrql - the new irql to be set.

    Vector - Vector number of the interrupt

Return Value:

    None.

--*/

{
    return;
}


//
// Almost all of the last 4MB of virtual memory address range are available
// to the HAL to map physical memory.   The kernel may use some of these
// PTEs for special purposes.
//
//
// The kernel now uses one PTE in this
// area to map the area from which interrupt messages are to be retrieved.
//


#define HAL_VA_START  0xffd00000

PVOID HalpHeapStart=(PVOID)(KADDRESS_BASE+HAL_VA_START);


PVOID
HalMapPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory
    reserved for the HAL.  It does this by directly inserting the PTE
    into the Page Table which the OS Loader has provided.

    N.B.  This routine does *NOT* update the MemoryDescriptorList.  The
          caller is responsible for either removing the appropriate
          physical memory from the list, or creating a new descriptor to
          describe it.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - Supplies the number of pages contained in the area of
                  physical memory to be mapped.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

    NULL - The requested block of physical memory could not be mapped.

--*/

{
    PHARDWARE_PTE PTE;
    ULONG PagesMapped;
    PVOID VirtualAddress;

    //
    // The OS Loader sets up hyperspace for us, so we know that the Page
    // Tables are magically mapped starting at V.A. 0xC0000000.
    //

    PagesMapped = 0;
    while (PagesMapped < NumberPages) {
        //
        // Look for enough consecutive free ptes to honor mapping
        //

        PagesMapped = 0;
        VirtualAddress = HalpHeapStart;

        while (PagesMapped < NumberPages) {
            PTE=MiGetPteAddress(VirtualAddress);
            if (*(PULONGLONG)PTE != 0) {

                //
                // Pte is not free, skip up to the next pte and start over
                //

                HalpHeapStart = (PVOID) ((ULONG_PTR)VirtualAddress + PAGE_SIZE);
                break;
            }
            VirtualAddress = (PVOID) ((ULONG_PTR)VirtualAddress + PAGE_SIZE);
            PagesMapped++;
        }

    }

    PagesMapped = 0;
    VirtualAddress = (PVOID) ((ULONG_PTR) HalpHeapStart | BYTE_OFFSET (PhysicalAddress.QuadPart));
    while (PagesMapped < NumberPages) {
        PTE=MiGetPteAddress(HalpHeapStart);

        PTE->PageFrameNumber = (PhysicalAddress.QuadPart >> PAGE_SHIFT);
        PTE->Valid = 1;
        PTE->Write = 1;

//  TBD    PTE->MemAttribute = 0;

        PhysicalAddress.QuadPart = PhysicalAddress.QuadPart + PAGE_SIZE;
        HalpHeapStart   = (PVOID)((ULONG_PTR)HalpHeapStart + PAGE_SIZE);

        ++PagesMapped;
    }

    return(VirtualAddress);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsym\mpsup\makefile.inc ===
$(O)\halapic.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsym\halia64\makefile.inc ===
$(O)\hal.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halsym\mpsmp\makefile.inc ===
$(O)\halmps.c : ..\halsym.c    
    $(CXX_COMPILER_NAME) @<<$(CL_RSP) /E $** > $@
$(CXX_COMPILER_FLAGS: =
)
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\halnls.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    halnls.h

Abstract:

    Strings which are used in the HAL

    English

--*/

#define MSG_HARDWARE_ERROR1     "\n*** Hardware Malfunction\n\n"
#define MSG_HARDWARE_ERROR2     "Call your hardware vendor for support\n\n"
#define MSG_HALT                "\n*** The system has halted ***\n"
#define MSG_NMI_PARITY          "NMI: Parity Check / Memory Parity Error\n"
#define MSG_NMI_CHANNEL_CHECK   "NMI: Channel Check / IOCHK\n"
#define MSG_NMI_FAIL_SAFE       "NMI: Fail-safe timer\n"
#define MSG_NMI_BUS_TIMEOUT     "NMI: Bus Timeout\n"
#define MSG_NMI_SOFTWARE_NMI    "NMI: Software NMI generated\n"
#define MSG_NMI_EISA_IOCHKERR   "NMI: Eisa IOCHKERR board %\n"

#define MSG_DEBUG_ENABLE        "Kernel Debugger Using: COM%x (Port 0x%x, Baud Rate %d)\n"
#define MSG_DEBUG_9600          "Switching debugger to 9600 baud\n"
#define MSG_MCE_PENDING         "Machine Check Exception pending, MCE exceptions not enabled\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\halp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    halp.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces, defines and structures.

Author:

    John Vert (jvert) 11-Feb-92


Revision History:

--*/

#ifndef _HALP_H_
#define _HALP_H_
#include "nthal.h"
#include "hal.h"
#include "halnls.h"

//
//Pickup the pnp guid definitions.
//
#include "wdmguid.h"


#if defined(NEC_98)
#include "nec98.h"
#else
#if MCA
#include "mca.h"
#else
#include "eisa.h"
#endif
#endif // NEC_98

#ifndef _HALI_
#include "hali.h"
#endif

#ifdef RtlMoveMemory
#undef RtlMoveMemory

//  #undef RtlCopyMemory
//  #undef RtlFillMemory
//  #undef RtlZeroMemory

//#define RtlCopyMemory(Destination,Source,Length) RtlMoveMemory((Destination),(Source),(Length))

VOID
RtlMoveMemory (
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

//  VOID
//  RtlFillMemory (
//     PVOID Destination,
//     ULONG Length,
//     UCHAR Fill
//     );
//  
//  VOID
//  RtlZeroMemory (
//     PVOID Destination,
//     ULONG Length
//     );
//  

#endif

#if defined(_AMD64_)

//
// A temporary macro used to indicate that a particular piece of code
// has never been executed on AMD64 before, and should be examined
// carefully for correct operation.
// 

#define AMD64_COVERAGE_TRAP() DbgBreakPoint()

//
// The following prototypes are not available from the standard HAL headers
// due to the fact that NO_LEGACY_DRIVERS is defined while compiling the
// HAL... however, they are used internally.
//

NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING RegistryPath,
    IN PUNICODE_STRING DriverClassName OPTIONAL,
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN OUT PCM_RESOURCE_LIST *AllocatedResources
    );

ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

//
// We are sharing code that was written for the x86.  There are some
// macros with identical meanings but different names in AMD64.  Following
// are some definitions to abstract those differences.
//

//
// CLOCK2_LEVEL on x86 is CLOCK_LEVEL on AMD64.
//

#define CLOCK2_LEVEL CLOCK_LEVEL

//
// X86 EFLAGS_INTERRUPT_MASK == AMD64 EFLAGS_IF_MASK
// 

#define EFLAGS_INTERRUPT_MASK EFLAGS_IF_MASK

//
// The PCR's pointer to the current prcb is named Prcb, while on AMD64
// it is named CurrentPrcb.
//
// The CurrentPrcb() macro is used to abstract this difference.
//

#define CurrentPrcb(x) (x)->CurrentPrcb

//
// The x86 KiReturnHandlerAddressFromIDT() is the equivalent of the AMD64's
// KeGetIdtHandlerAddress()
// 

#define KiReturnHandlerAddressFromIDT(v) (ULONG_PTR)KeGetIdtHandlerAddress(v)

//
// More macro and structure name differences
//

#define RDMSR(m)   ReadMSR(m)
#define WRMSR(m,d) WriteMSR(m,d)
#define KGDTENTRY  KGDTENTRY64
#define PKGDTENTRY PKGDTENTRY64

#define PIOPM_SIZE (sizeof(KIO_ACCESS_MAP) + sizeof(ULONG))

//
// The AMD64 in long mode uses 8-byte PTE entries, which have the same format
// as Pentium PAE page tables.
//

#if !defined(_HALPAE_)
#define _HALPAE_ 1
#endif

#define HARDWARE_PTE_X86PAE HARDWARE_PTE
#define HARDWARE_PTE_X86    HARDWARE_PTE

#define PHARDWARE_PTE_X86PAE PHARDWARE_PTE
#define PHARDWARE_PTE_X86    PHARDWARE_PTE

#define PDE_BASE_X86PAE PDE_BASE
#define PDE_BASE_X86    PDE_BASE

#define PDI_SHIFT_X86PAE PDI_SHIFT
#define PDI_SHIFT_X86    PDI_SHIFT

//
// Fence instruction.
// 

__forceinline
VOID
HalpProcessorFence (
    VOID
    )
{
    CPU_INFO cpuInfo;
    KiCpuId (0,&cpuInfo); 
}

#define PROCESSOR_FENCE HalpProcessorFence()

//
// On AMD64, HalpGetProcessorFlags() must reside in it's own asm
// function.  It cannot be done inline because there is no intrinsic, and
// there is no intrinsic because getting the value of EFLAGS involves stack
// manipulation outside of the prolog, which is not permitted.
//

ULONG
HalpGetProcessorFlags(
    VOID
    );

//
// While _enable() and _disable() are intrinsics in both the AMD64 and X86
// compilers, they are disabled on X86.  HalpDisableInterruptsNoFlags and
// HalpEnableInterrupts are macros used to abstract this difference.
// 

#define HalpDisableInterruptsNoFlags _disable
#define HalpEnableInterrupts _enable

//
// There is no intrinsic for the hlt instruction on AMD64.  HalpHalt()
// is a function call on AMD64, and inline asm on X86.
//

VOID
HalpHalt (
    VOID
    );


#if !defined(PICACPI)

//
// On x86, the variables HalpClockSetMSRate, HalpClockMcaQueueDpc and
// HalpClockWork are defined in an .asm module such that HalpClockWork
// is defined as a DWORD that overlapps HalpClockSetMSRate and
// HalpClockMcaQueueDpc.
//
// This is not directly representable in C, so instead HALP_CLOCKWORK_UNION
// is defined and the above variable names are instead redefined to reference
// elements of this union.
//

#define HalpClockSetMSRate   HalpClockWorkUnion.ClockSetMSRate
#define HalpClockMcaQueueDpc HalpClockWorkUnion.ClockMcaQueueDpc
#define HalpClockWork        HalpClockWorkUnion.ClockWork

typedef union {
    struct {
        UCHAR ClockMcaQueueDpc;
        UCHAR ClockSetMSRate;
        UCHAR bReserved1;
        UCHAR bReserved2;
    };
    ULONG ClockWork;
} HALP_CLOCKWORK_UNION;

extern HALP_CLOCKWORK_UNION HalpClockWorkUnion;

#endif

#else

//
// Following are X86 definitions that are used to help abstract differences
// between X86 and AMD64 platforms.
// 

#define AMD64_COVERAGE_TRAP()

//
// We are sharing code that was written for the x86.  There are some
// macros with identical meanings but different names in AMD64.  Following
// are some definitions to abstract those differences.
//

//
// The following _KPCR fields have different names but identical purposes.
// 

#define IdtBase IDT
#define GdtBase GDT
#define TssBase TSS

//
// The PCR's pointer to the current prcb is named Prcb, while on AMD64
// it is named CurrentPrcb.
//
// The CurrentPrcb() macro is used to abstract this difference.
//

#define CurrentPrcb(x) (x)->Prcb

//
// On X86, HalpGetProcessorFlags() can be implemented inline.
// 

__forceinline
ULONG
HalpGetProcessorFlags (
    VOID
    )

/*++

Routine Description:

    This procedure retrieves the contents of the EFLAGS register.

Arguments:

    None.

Return Value:

    The 32-bit contents of the EFLAGS register.

--*/

{
    ULONG flags;

    _asm {
        pushfd
        pop     eax
        mov     flags, eax
    }

    return flags;
}

//
// While _enable() and _disable() are intrinsics in both the AMD64 and X86
// compilers, they are disabled in the HAL on X86.
//
// HalpDisableInterruptsNoFlags and HalpEnableInterrupts are macros used
// to abstract this difference.
// 

#define HalpDisableInterruptsNoFlags() _asm cli
#define HalpEnableInterrupts() _asm sti

//
// There is no intrinsic for the hlt instruction on AMD64.  HalpHalt()
// is a function call on AMD64, and inline asm on X86.
//

#define HalpHalt() _asm hlt

#endif

__forceinline
ULONG
HalpDisableInterrupts(
    VOID
    )

/*++

Routine Description:

    This function saves the state of the processor flag register, clears the
    state of the interrupt flag (disables interrupts), and returns the
    previous contents of the processor flag register.

Arguments:

    None.

Return Value:

    The previous contents of the processor flag register.

--*/

{
    ULONG flags;

    flags = HalpGetProcessorFlags();
    HalpDisableInterruptsNoFlags();

    return flags;
}

__forceinline
VOID
HalpRestoreInterrupts(
    IN ULONG Flags
    )

/*++

Routine Description:

    This procedure restores the state of the interrupt flag based on a
    value returned by a previous call to HalpDisableInterrupts.

Arguments:

    Flags - Supplies the value returned by a previous call to
            HalpDisableInterrupts

Return Value:

    None.

--*/

{
    if ((Flags & EFLAGS_INTERRUPT_MASK) != 0) {
        HalpEnableInterrupts();
    }
}

#if defined(_WIN64)

//
// For AMD64 (and, ideally, all subsequent WIN64 platforms), interrupt
// service routines are C callable.
//

typedef PKSERVICE_ROUTINE PHAL_INTERRUPT_SERVICE_ROUTINE;

#define HAL_INTERRUPT_SERVICE_PROTOTYPE(RoutineName) \
BOOLEAN                                              \
RoutineName (                                        \
    IN PKINTERRUPT Interrupt,                        \
    IN PVOID ServiceContext                          \
)

#define PROCESSOR_CURRENT ((UCHAR)-1)

VOID
HalpSetHandlerAddressToIDTIrql (
    IN ULONG Vector,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE ServiceRoutine,
    IN PVOID Context,
    IN KIRQL Irql
    );

#define KiSetHandlerAddressToIDT Dont_Use_KiSetHandlerAddressToIdt

//
// On AMD64, the HAL does not connect directly to the IDT, rather the
// kernel handles the interrupt and calls a C-callable interrupt routine.
//
// Therefore, HalpSetHandlerAddressToIDT() must supply a context and an
// IRQL in addition to the vector number and interrupt routine.
//
// On X86, the context and IRQL are ignored, as the vector is inserted
// directly into the IDT, such that the service routine is responsible for
// raising IRQL.
// 

#define KiSetHandlerAddressToIDTIrql(v,a,c,i)   \
    HalpSetHandlerAddressToIDTIrql (v,a,c,i);

#else

//
// On X86, the last two parameters of KiSetHandlerAddressToIDTIrql()
// (Context and Irql) are ignored.  The interrupt handlers themselves
// are responsible for raising IRQL.
//

#define KiSetHandlerAddressToIDTIrql(v,a,c,i) KiSetHandlerAddressToIDT(v,a)

//
// For X86, interrupt service routines must be written in assembler because
// they are referenced directly in the IDT and trasferred to directly by
// the processor with a convention that is not C callable.
//
// For purposes of C code that references ISRs, then, the prototype is
// very simple.
//

typedef
VOID
(*PHAL_INTERRUPT_SERVICE_ROUTINE)(
    VOID
    );

#define HAL_INTERRUPT_SERVICE_PROTOTYPE(RoutineName) \
VOID                                                 \
RoutineName (                                        \
    VOID                                             \
)

#endif

typedef  
VOID
(*HALP_MOVE_MEMORY_ROUTINE)(
   PVOID Destination,
   CONST VOID *Source,
   SIZE_T Length
   );

VOID 
HalpMovntiCopyBuffer(
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

extern HALP_MOVE_MEMORY_ROUTINE HalpMoveMemory;

#if MCA

#include "ixmca.h"

#else

#include "ixisa.h"

#endif

#include "ix8259.inc"

#if DBG
extern ULONG HalDebug;

#define HalPrint(x)         \
    if (HalDebug) {         \
        DbgPrint("HAL: ");  \
        DbgPrint x;         \
        DbgPrint("\n");     \
    }
#else
#define HalPrint(x)
#endif

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern POBJECT_TYPE *IoAdapterObjectType;

extern BOOLEAN LessThan16Mb;

extern BOOLEAN HalpEisaDma;

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    );

//
// Work item to grow map buffers
//
typedef struct _BUFFER_GROW_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PADAPTER_OBJECT AdapterObject;
    ULONG MapRegisterCount;
} BUFFER_GROW_WORK_ITEM, *PBUFFER_GROW_WORK_ITEM;

//
// Map buffer prameters.  These are initialized in HalInitSystem
//

//
// PAE note:
//
// Previously, there was only one class of adapter that we had to double-buffer
// for: adapters with only 24 address lines that could access memory up to
// 16MB.
//
// The HAL tracked these map buffers with a single, global master adapter.
// Associated with this master adapter were three global variables:
//
// - MasterAdapterObject
// - HalpMapBufferSize
// - HalpMapBufferPhysicalAddress
//
// With PAE, we have another class of adapters that require double-buffering:
// specifically, adapters with only 32 address lines that can access memory
// up to 4G.
//
// This meant the introduction of another master adapter along with an
// associated set of variables.  For PAE-capable hals, this data has been
// reorganized into a MASTER_ADAPTER_OBJECT (see ixisa.h).
//
// So now we have two global MASTER_ADAPTER_OBJECT structures:
//
// MasterAdapter24
// MasterAdapter32
//
// The following macros are used in code that is included in PAE-capable
// hals.  It is important to note that in a non-PAE-capable HAL (i.e. one
// that does not have _HALPAE_ defined), the macros must resolve to the
// values that they replaced.
//

#if defined(_HALPAE_)

PADAPTER_OBJECT
HalpAllocateAdapterEx(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber,
    IN BOOLEAN Dma32Bit
    );

extern MASTER_ADAPTER_OBJECT MasterAdapter24;
extern MASTER_ADAPTER_OBJECT MasterAdapter32;

#define HalpMasterAdapterStruc( Dma32Bit )                       \
    ((HalPaeEnabled() && (Dma32Bit)) ? &MasterAdapter32 : &MasterAdapter24)

#define HalpMaximumMapBufferRegisters( Dma32Bit )           \
    (HalpMasterAdapterStruc( Dma32Bit )->MaxBufferPages)

#define HalpMaximumMapRegisters( Dma32Bit )                 \
    (Dma32Bit ? MAXIMUM_PCI_MAP_REGISTER : MAXIMUM_ISA_MAP_REGISTER)

#define HalpMapBufferSize( Dma32Bit )                       \
    (HalpMasterAdapterStruc( Dma32Bit )->MapBufferSize)

#define HalpMapBufferPhysicalAddress( Dma32Bit )     \
    (HalpMasterAdapterStruc( Dma32Bit )->MapBufferPhysicalAddress)

#define HalpMasterAdapter( Dma32Bit ) \
    HalpMasterAdapterStruc( Dma32Bit )->AdapterObject

#else

extern PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
extern ULONG HalpMapBufferSize;
extern PADAPTER_OBJECT MasterAdapterObject;

#define HalpAllocateAdapterEx( _m, _a, _c, _d ) \
    HalpAllocateAdapter( _m, _a, _c )

#define HalpMaximumMapBufferRegisters( Dma32Bit ) \
    (MAXIMUM_MAP_BUFFER_SIZE / PAGE_SIZE)

#define HalpMaximumMapRegisters( Dma32Bit ) \
    (MAXIMUM_ISA_MAP_REGISTER)

#define HalpMapBufferSize( Dma32Bit ) HalpMapBufferSize

#define HalpMapBufferPhysicalAddress( Dma32Bit ) \
    (HalpMapBufferPhysicalAddress)

#define HalpMasterAdapter( Dma32Bit ) MasterAdapterObject

#endif

extern ULONG HalpBusType;
extern ULONG HalpCpuType;
extern UCHAR HalpSerialLen;
extern UCHAR HalpSerialNumber[];

//
// The following macros are taken from mm\i386\mi386.h.  We need them here
// so the HAL can map its own memory before memory-management has been
// initialized, or during a BugCheck.
//
// MiGetPdeAddress returns the address of the PDE which maps the
// given virtual address.
//

#define MiGetPdeAddressX86(va)  ((PHARDWARE_PTE)(((((ULONG_PTR)(va)) >> 22) << 2) + PDE_BASE))

//
// MiGetPteAddress returns the address of the PTE which maps the
// given virtual address.
//

#define MiGetPteAddressX86(va) ((PHARDWARE_PTE)(((((ULONG_PTR)(va)) >> 12) << 2) + PTE_BASE))

//
// MiGetPteIndex returns the index within a page table of the PTE for the
// given virtual address
//

#define MiGetPteIndexX86(va) (((ULONG_PTR)(va) >> PAGE_SHIFT) & 0x3FF)
#define MiGetPteIndexPae(va) (((ULONG_PTR)(va) >> PAGE_SHIFT) & 0x1FF)

//
// The following macros are taken from mm\i386\mipae.h.  We need them here
// so the HAL can map its own memory before memory-management has been
// initialized, or during a BugCheck.
//
// MiGetPdeAddressPae returns the address of the PDE which maps the
// given virtual address.
//

#define MiGetPdeAddressPae(va)   ((PHARDWARE_PTE_X86PAE)(PDE_BASE_X86PAE + ((((ULONG_PTR)(va)) >> 21) << 3)))

//
// MiGetPteAddressPae returns the address of the PTE which maps the
// given virtual address.
//

#define MiGetPteAddressPae(va)   ((PHARDWARE_PTE_X86PAE)(PTE_BASE + ((((ULONG_PTR)(va)) >> 12) << 3)))

//
// Resource usage information
//

#pragma pack(1)
typedef struct {
    UCHAR   Flags;
} IDTUsageFlags;

typedef struct {
    KIRQL   Irql;
    UCHAR   BusReleativeVector;
} IDTUsage;

typedef struct _HalAddressUsage{
    struct _HalAddressUsage *Next;
    CM_RESOURCE_TYPE        Type;       // Port or Memory
    UCHAR                   Flags;      // same as IDTUsage.Flags
    struct {
        ULONG   Start;
        ULONG   Length;
    }                       Element[];
} ADDRESS_USAGE;
#pragma pack()

#define IDTOwned            0x01        // IDT is not available for others
#define InterruptLatched    0x02        // Level or Latched
#define RomResource         0x04        // ROM
#define InternalUsage       0x11        // Report usage on internal bus
#define DeviceUsage         0x21        // Report usage on device bus

extern IDTUsageFlags    HalpIDTUsageFlags[];
extern IDTUsage         HalpIDTUsage[];
extern ADDRESS_USAGE   *HalpAddressUsageList;

#define HalpRegisterAddressUsage(a) \
    (a)->Next = HalpAddressUsageList, HalpAddressUsageList = (a);

//
// Temp definitions to thunk into supporting new bus extension format
//

VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusDataType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    );

#define HalpHandlerForBus   HaliHandlerForBus
#define HalpSetBusHandlerParent(c,p)    (c)->ParentHandler = p;

//
// Define function prototypes.
//

VOID
HalInitSystemPhase2(
    VOID
    );

KIRQL
HaliRaiseIrqlToDpcLevel (
   VOID
   );

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpClockInterrupt);

KIRQL
HalpDisableAllInterrupts (
    VOID
    );

VOID
HalpReenableInterrupts (
    KIRQL NewIrql
    );

HAL_INTERRUPT_SERVICE_PROTOTYPE(HalpProfileInterrupt);

VOID
HalpInitializeClock(
    VOID
    );

VOID
HalpInitializeStallExecution(
    IN CCHAR ProcessorNumber
    );

VOID
HalpRemoveFences (
    VOID
    );

VOID
HalpInitializePICs(
    BOOLEAN EnableInterrupts
    );

VOID
HalpIrq13Handler (
    VOID
   );

VOID
HalpFlushTLB (
    VOID
    );

VOID
HalpSerialize (
    VOID
    );

PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );

PVOID
HalpMapPhysicalMemoryWriteThrough64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG  NumberPages
    );

ULONG
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    );

VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );

PVOID
HalpRemapVirtualAddress64 (
    IN PVOID VirtualAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN BOOLEAN WriteThrough
    );

PHYSICAL_ADDRESS
__inline
HalpPtrToPhysicalAddress(
    IN PVOID Address
    )

/*++

Routine Description:

    This routine converts a physical address expressed as a PVOID into
    a physical address expresses as PHYSICAL_ADDRESS.

Arguments:

    Address - PVOID representation of the physical address.

Return Value:

    PHYSICAL_ADDRESS representation of the physical address.

--*/

{
    PHYSICAL_ADDRESS physicalAddress;

    physicalAddress.QuadPart = (ULONG_PTR)Address;

    return physicalAddress;
}

#if defined(_HALPAE_)

//
// This hal is to be PAE compatible.  Therefore, physical addresses must
// be treated as 64-bit entitites instead of PVOID.
//

#define _PHYS64_
#endif

#if defined(_PHYS64_)

//
// HALs with _PHYS64_ defined pass physical addresses as PHYSICAL_ADDRESS,
// so call the 64-bit versions of these routines directly.
//

#define HalpMapPhysicalMemory               HalpMapPhysicalMemory64
#define HalpMapPhysicalMemoryWriteThrough   HalpMapPhysicalMemoryWriteThrough64
#define HalpRemapVirtualAddress             HalpRemapVirtualAddress64

#define HalpMapPhysicalRange(_addr_,_len_)      \
        HalpMapPhysicalMemory((_addr_),         \
                              HalpRangePages((_addr_).QuadPart,(_len_)))

#define HalpUnMapPhysicalRange(_addr_,_len_)      \
        HalpUnmapVirtualAddress((_addr_),         \
                              HalpRangePages((ULONG_PTR)(_addr_),(_len_)))

#else

//
// HALs without _PHYS64_ defined pass physical addresses as PVOIDs.  Convert
// such parameters to PHYSICAL_ADDRESS before passing to the 64-bit routines.
//

PVOID
__inline
HalpMapPhysicalMemory(
    IN PVOID PhysicalAddress,
    IN ULONG NumberPages
    )
{
    PHYSICAL_ADDRESS physicalAddress;

    physicalAddress = HalpPtrToPhysicalAddress( PhysicalAddress );
    return HalpMapPhysicalMemory64( physicalAddress, NumberPages );
}

PVOID
__inline
HalpMapPhysicalMemoryWriteThrough(
    IN PVOID PhysicalAddress,
    IN ULONG NumberPages
    )
{
    PHYSICAL_ADDRESS physicalAddress;

    physicalAddress = HalpPtrToPhysicalAddress( PhysicalAddress );
    return HalpMapPhysicalMemoryWriteThrough64( physicalAddress, NumberPages );
}

PVOID
__inline
HalpRemapVirtualAddress(
    IN PVOID VirtualAddress,
    IN PVOID PhysicalAddress,
    IN BOOLEAN WriteThrough
    )
{
    PHYSICAL_ADDRESS physicalAddress;

    physicalAddress = HalpPtrToPhysicalAddress( PhysicalAddress );
    return HalpRemapVirtualAddress64( VirtualAddress,
                                      physicalAddress,
                                      WriteThrough );
}

#define HalpMapPhysicalRange(_addr_,_len_)      \
        HalpMapPhysicalMemory((_addr_),         \
                              HalpRangePages((ULONG_PTR)(_addr_),(_len_)))

#define HalpUnMapPhysicalRange(_addr_,_len_)      \
        HalpUnmapVirtualAddress((_addr_),         \
                              HalpRangePages((ULONG_PTR)(_addr_),(_len_)))


#endif

ULONG
__inline
HalpRangePages(
    IN ULONGLONG Address,
    IN ULONG Length
    )
{
    ULONG startPage;
    ULONG endPage;

    startPage = (ULONG)(Address / PAGE_SIZE);
    endPage = (ULONG)((Address + Length + PAGE_SIZE - 1) / PAGE_SIZE);

    return endPage - startPage;
}



VOID
HalpBiosDisplayReset(
    IN VOID
    );

HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    );

VOID
HalpInitializeCmos (
   VOID
   );

VOID
HalpReadCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpWriteCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpAcquireCmosSpinLock (
    VOID
    );

VOID
HalpReleaseCmosSpinLock (
    VOID
    );

VOID
HalpResetAllProcessors (
    VOID
    );

VOID
HalpCpuID (
    ULONG   InEax,
    PULONG  OutEax,
    PULONG  OutEbx,
    PULONG  OutEcx,
    PULONG  OutEdx
    );

#if defined(_WIN64)
#define HalpYieldProcessor()

#else

VOID
HalpYieldProcessor (
    VOID
    );
#endif

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrAddress
    );

VOID
WRMSR (
    IN ULONG        MsrAddress,
    IN ULONGLONG    MsrValue
    );


NTSTATUS
HalpEnableInterruptHandler (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    );

VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    );

VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    );

VOID
HalpYearIs(
    IN ULONG Year
    );

VOID
HalpRecordEisaInterruptVectors(
    VOID
    );

VOID
HalpMcaCurrentProcessorSetConfig(
    VOID
    );

NTSTATUS
HalpGetNextProcessorApicId(
    IN ULONG ProcessorNumber,
    IN OUT UCHAR    *ApicId
    );

VOID
FASTCALL
HalpIoDelay (
   VOID
   );

//
// Defines for HalpFeatureBits
//

#define HAL_PERF_EVENTS     0x00000001
#define HAL_NO_SPECULATION  0x00000002
#define HAL_MCA_PRESENT     0x00000004  // Intel MCA Available
#define HAL_MCE_PRESENT     0x00000008  // ONLY Pentium style MCE available
#define HAL_CR4_PRESENT     0x00000010
#define HAL_WNI_PRESENT     0x00000020

extern ULONG HalpFeatureBits;

extern USHORT HalpPciIrqMask;

//
// Defines for Processor Features returned from CPUID instruction
//

#define CPUID_MCA_MASK  0x4000
#define CPUID_MCE_MASK  0x0080
#define CPUID_VME_MASK  0x0002
#define CPUID_WNI_MASK  0x04000000


NTSTATUS
HalpGetMcaLog(
    OUT PMCA_EXCEPTION  Exception,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO pMcaDriverInfo  // Info about registering driver
    );

VOID
HalpMcaInit(
    VOID
    );

//
// Disable the Local APIC on UP (PIC 8259) PentiumPro systems to work around
// spurious interrupt errata.
//
#define APIC_BASE_MSR       0x1B
#define APIC_ENABLED        0x0000000000000800

//
// PnP stuff
//

#define HAL_BUS_INTERFACE_STD_VERSION   1
#define HAL_IRQ_TRANSLATOR_VERSION      0
#define HAL_MEMIO_TRANSLATOR_VERSION    1

VOID
HalTranslatorReference(
    PVOID Context
    );

VOID
HalTranslatorDereference(
    PVOID Context
    );

NTSTATUS
HalIrqTranslateResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateRequirementsPciBridge(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourcesPciBridge(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalpIrqTranslateRequirementsPci(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalpIrqTranslateResourcesPci(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

ULONG
HalpGetIsaIrqState(
    ULONG   Vector
    );

extern INT_ROUTE_INTERFACE_STANDARD PciIrqRoutingInterface;

#if defined(_WIN64)
#define MM_HAL_RESERVED ((PVOID)HAL_VA_START)
#else
#define MM_HAL_RESERVED ((PVOID)0xffc00000)
#endif

#if defined(_HALPAE_)

#if defined(_AMD64_)

//
// For the purposes of the AMD64 HAL, "PAE" mode is always enabled, therefore
// no run-time PAE checks are necessary.
//

#define HalPaeEnabled() TRUE

#else   // _AMD64_

//
// This hal supports PAE mode.  Therefore checks need to be made at run-time
// to determine whether PAE is enabled or not.
//

BOOLEAN
__inline
HalPaeEnabled(
    VOID
    )
{
    return SharedUserData->ProcessorFeatures[PF_PAE_ENABLED] != FALSE;
}

#endif  // _AMD64_

#else

//
// This hal does not support PAE mode.  Therefore no run-time PAE checks
// are necessary.
//

#define HalPaeEnabled() FALSE

#endif

//
// The following inline functions and macros are used so that PHARDWARE_PTE
// can be used as a pointer to a four-byte legacy PTE or an eight-byte
// PAE PTE.
//
// With the exception of the PageFrameNumber field, all fields in these two
// different PTE formats are identical.  Therefore access to these fields
// can be made directly.
//
// However, code in a PAE-enabled HAL may not access the PageFrameNumber
// of a PTE directly, nor may it make any assumptions about the size of a
// PTE or the number of address bits decoded by the page directory pointer
// table, the page directory or the page table.  Instead, the following
// inline functions should be used.
//

ULONG
__inline
HalPteSize(
    VOID
    )

/*++

Routine Description:

    This routine returns the size, in bytes, of a PTE.

Arguments:

    None.

Return Value:

    The size, in bytes, of a PTE.

--*/

{
    if (HalPaeEnabled() != FALSE) {
        return sizeof(HARDWARE_PTE_X86PAE);
    } else {
        return sizeof(HARDWARE_PTE_X86);
    }
}

PHARDWARE_PTE
__inline
HalpIndexPteArray(
    IN PHARDWARE_PTE BasePte,
    IN ULONG Index
    )

/*++

Routine Description:

    This routine returns the address of a PTE within an array of PTEs.

Arguments:

    BasePte - Pointer to the PTE array.

    Index - Index within the PTE array.

Return Value:

    Address of BasePte[ Index ]

--*/

{
    PHARDWARE_PTE pointerPte;

    pointerPte = (PHARDWARE_PTE)((ULONG_PTR)BasePte + Index * HalPteSize());
    return pointerPte;
}

VOID
__inline
HalpAdvancePte(
    IN OUT PHARDWARE_PTE *PointerPte,
    IN     ULONG Count
    )

/*++

Routine Description:

    This routine advances the value of a PTE pointer by the specified number
    of PTEs.

Arguments:

    PointerPte - Pointer to the PTE pointer to increment.

    Count - Number of PTEs to advance the PTE pointer.

Return Value:

    None.

--*/

{
    *PointerPte = HalpIndexPteArray( *PointerPte, Count );
}

VOID
__inline
HalpIncrementPte(
    IN PHARDWARE_PTE *PointerPte
    )

/*++

Routine Description:

    This routine increments the value of a PTE pointer by one PTE.

Arguments:

    PointerPte - Pointer to the PTE pointer to increment.

Return Value:

    None.

--*/

{
    HalpAdvancePte( PointerPte, 1 );
}

VOID
__inline
HalpSetPageFrameNumber(
    IN OUT PHARDWARE_PTE PointerPte,
    IN ULONGLONG PageFrameNumber
    )

/*++

Routine Description:

    This routine sets the PageFrameNumber within a PTE.

Arguments:

    PointerPte - Pointer to the PTE to modify.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE_X86PAE pointerPtePae;

    if (HalPaeEnabled() != FALSE) {

        pointerPtePae = (PHARDWARE_PTE_X86PAE)PointerPte;
        pointerPtePae->PageFrameNumber = PageFrameNumber;

    } else {

        PointerPte->PageFrameNumber = (ULONG)PageFrameNumber;
    }
}

ULONGLONG
__inline
HalpGetPageFrameNumber(
    IN PHARDWARE_PTE PointerPte
    )

/*++

Routine Description:

    This routine retrieves PageFrameNumber from within a PTE.

Arguments:

    PointerPte - Pointer to the PTE to read.

Return Value:

    The page frame number within the PTE.

--*/

{
    PHARDWARE_PTE_X86PAE pointerPtePae;
    ULONGLONG pageFrameNumber;

    if (HalPaeEnabled() != FALSE) {

        pointerPtePae = (PHARDWARE_PTE_X86PAE)PointerPte;
        pageFrameNumber = pointerPtePae->PageFrameNumber;

    } else {

        pageFrameNumber = PointerPte->PageFrameNumber;
    }

    return pageFrameNumber;
}

VOID
__inline
HalpCopyPageFrameNumber(
    OUT PHARDWARE_PTE DestinationPte,
    IN  PHARDWARE_PTE SourcePte
    )

/*++

Routine Description:

    This routine copies the page frame number from one PTE to another PTE.

Arguments:

    DestinationPte - Pointer to the PTE in which the new page frame number
        will be stored.

    PointerPte - Pointer to the PTE from which the page frame number will be
        read.

Return Value:

    None.

--*/

{
    ULONGLONG pageFrameNumber;

    pageFrameNumber = HalpGetPageFrameNumber( SourcePte );
    HalpSetPageFrameNumber( DestinationPte, pageFrameNumber );
}

BOOLEAN
__inline
HalpIsPteFree(
    IN PHARDWARE_PTE PointerPte
    )

/*++

Routine Description:

    This routine determines whether a PTE is free or not.  A free PTE is defined
    here as one containing all zeros.

Arguments:

    PointerPte - Pointer to the PTE for which the detmination is desired.

Return Value:

    TRUE - The PTE is free.

    FALSE - The PTE is not free.

--*/

{
    ULONGLONG pteContents;

    if (HalPaeEnabled() != FALSE) {
        pteContents = *(PULONGLONG)PointerPte;
    } else {
        pteContents = *(PULONG)PointerPte;
    }

    if (pteContents == 0) {
        return TRUE;
    } else {
        return FALSE;
    }
}

VOID
__inline
HalpFreePte(
    IN PHARDWARE_PTE PointerPte
    )

/*++

Routine Description:

    This routine sets a PTE to the free state.  It does this by setting the
    entire PTE to zero.

Arguments:

    PointerPte - Pointer to the PTE to free.

Return Value:

    None.

--*/

{
    if (HalPaeEnabled() != FALSE) {

        *((PULONGLONG)PointerPte) = 0;

    } else {

        *((PULONG)PointerPte) = 0;
    }
}


PHARDWARE_PTE
__inline
MiGetPteAddress(
    IN PVOID Va
    )

/*++

Routine Description:

    Given a virtual address, this routine returns a pointer to the mapping PTE.

Arguments:

    Va - Virtual Address for which a PTE pointer is desired.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE pointerPte;

    if (HalPaeEnabled() != FALSE) {
        pointerPte = (PHARDWARE_PTE)MiGetPteAddressPae( Va );
    } else {
        pointerPte = MiGetPteAddressX86( Va );
    }

    return pointerPte;
}

PHARDWARE_PTE
__inline
MiGetPdeAddress(
    IN PVOID Va
    )

/*++

Routine Description:

    Given a virtual address, this routine returns a pointer to the mapping PDE.

Arguments:

    Va - Virtual Address for which a PDE pointer is desired.

Return Value:

    None.

--*/

{
    PHARDWARE_PTE pointerPte;

    if (HalPaeEnabled() != FALSE) {
        pointerPte = (PHARDWARE_PTE)MiGetPdeAddressPae( Va );
    } else {
        pointerPte = MiGetPdeAddressX86( Va );
    }

    return pointerPte;
}

ULONG
__inline
MiGetPteIndex(
    IN PVOID Va
    )

/*++

Routine Description:

    Given a virtual address, this routine returns the index of the mapping
    PTE within its page table.

Arguments:

    Va - Virtual Address for which the PTE index is desired.

Return Value:

    None.

--*/

{
    ULONG_PTR index;

    if (HalPaeEnabled() != FALSE) {
        index = MiGetPteIndexPae( Va );
    } else {
        index = MiGetPteIndexX86( Va );
    }

    return (ULONG)index;
}

ULONG
__inline
MiGetPdiShift(
    VOID
    )

/*++

Routine Description:

    Returns the number of bits that an address should be shifted right in order
    to right-justify the portion of the address mapped by a page directory
    entry.

Arguments:

    None.

Return Value:

    The number of bits to shift right.

--*/

{
    ULONG shift;

    if (HalPaeEnabled() != FALSE) {
        shift = PDI_SHIFT_X86PAE;
    } else {
        shift = PDI_SHIFT_X86;
    }

    return shift;
}

//
// ACPI specific stuff
//

NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
HalpAcpiFindRsdtPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HaliHaltSystem(
    VOID
    );

VOID
HalpCheckPowerButton(
    VOID
    );

VOID
HalpRegisterHibernate(
    VOID
    );

VOID
FASTCALL
HalProcessorThrottle (
    IN UCHAR    Throttle
    );

VOID
HalpSaveInterruptControllerState(
    VOID
    );

VOID
HalpSaveDmaControllerState(
    VOID
    );

VOID
HalpSaveTimerState(
    VOID
    );

VOID
HalpRestoreInterruptControllerState(
    VOID
    );

VOID
HalpSetInterruptControllerWakeupState(
    ULONG   Context
    );

VOID
HalpRestorePicEdgeLevelRegister(
    VOID
    );

VOID
HalpSetAcpiEdgeLevelRegister(
    VOID
    );

VOID
HalpRestoreDmaControllerState(
    VOID
    );

VOID
HalpRestoreTimerState(
    VOID
    );

NTSTATUS
HalacpiGetInterruptTranslator(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

VOID
HalpInitNonBusHandler (
    VOID
    );

VOID
HalpMapNvsArea(
    VOID
    );

VOID
HalpPreserveNvsArea(
    VOID
    );

VOID
HalpRestoreNvsArea(
    VOID
    );

VOID
HalpFreeNvsBuffers(
    VOID
    );

VOID
HalpPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

NTSTATUS
HalpBuildResumeStructures(
    VOID
    );

NTSTATUS
HalpFreeResumeStructures(
    VOID
    );

typedef struct {
    UCHAR   MasterMask;
    UCHAR   SlaveMask;
    UCHAR   MasterEdgeLevelControl;
    UCHAR   SlaveEdgeLevelControl;
} PIC_CONTEXT, *PPIC_CONTEXT;

#define EISA_DMA_CHANNELS 8

typedef struct {
    UCHAR           Dma1ExtendedModePort;
    UCHAR           Dma2ExtendedModePort;
    DMA1_CONTROL    Dma1Control;
    DMA2_CONTROL    Dma2Control;
} DMA_CONTEXT, *PDMA_CONTEXT;

typedef struct {
    UCHAR   nothing;
} TIMER_CONTEXT, *PTIMER_CONTEXT;

typedef struct {
    PIC_CONTEXT     PicState;
    DMA_CONTEXT     DmaState;
} MOTHERBOARD_CONTEXT, *PMOTHERBOARD_CONTEXT;

typedef struct {
    UCHAR                ChannelMode;
    UCHAR                ChannelExtendedMode;
    UCHAR                ChannelMask;
    BOOLEAN              ChannelProgrammed;  // Adapter created, mode set
#if DBG
    BOOLEAN           ChannelBusy;
#endif
} DMA_CHANNEL_CONTEXT;

extern MOTHERBOARD_CONTEXT  HalpMotherboardState;
extern PVOID                HalpSleepPageLock;
extern PVOID                HalpSleepPage16Lock;
extern DMA_CHANNEL_CONTEXT HalpDmaChannelState[];

ULONG 
HalpcGetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            SourceAddress,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    );

ULONG 
HalpcSetCmosDataByType(
    IN CMOS_DEVICE_TYPE CmosType,
    IN ULONG            SourceAddress,
    IN PUCHAR           DataBuffer,
    IN ULONG            ByteCount
    );


NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpInitIrqArbiter (
    IN PDEVICE_OBJECT   DeviceObject
    );

NTSTATUS
HalpFillInIrqArbiter (
    IN     PDEVICE_OBJECT   HalFdo,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

VOID
HalpIrqArbiterInterfaceReference(
    IN PVOID    Context
    );

VOID
HalpIrqArbiterInterfaceDereference(
    IN PVOID    Context
    );

#endif

//
// PnPBIOS specific stuff
//
VOID
HalpMarkChipsetDecode(
    BOOLEAN FullDecodeChipset
    );

ULONG
HalpPhase0SetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

ULONG
HalpPhase0GetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

NTSTATUS
HalpSetupPciDeviceForDebugging(
    IN     PLOADER_PARAMETER_BLOCK   LoaderBlock,   OPTIONAL    
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

NTSTATUS
HalpReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
);

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    );

#endif // _HALP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ix8259.inc ===
;/*
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       ix8259.inc
;
;   Abstract:
;
;       This module contains the definitions used by HAL to manipulate
;       8259 interrupt controller and 8259-specific constants.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       John Vert (jvert) 31-Dec-1991
;
;               (Moved from ke\i386\kimacro.inc)
;
;--
if 0        ; Begin C only code         */

//
// 8259 defines for C code
// BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
//

#define HIGHEST_LEVEL_FOR_8259  27          // Highest level for standard 8259
#define PRIMARY_VECTOR_BASE     0x30        // Vector base for standard 8259
#if defined(NEC_98)
#if defined(NT_UP_98)
#define PROFILE_VECTOR          (PRIMARY_VECTOR_BASE + 0)   // standard profile
#else 
#define PROFILE_VECTOR          (PRIMARY_VECTOR_BASE + 15)   // standard profile
#endif 
#else  // defined(NEC_98)
#define PROFILE_VECTOR          (PRIMARY_VECTOR_BASE + 8)   // standard profile
#endif // defined(NEC_98)
#define CLOCK_VECTOR            (PRIMARY_VECTOR_BASE + 0)   // standard clock
#define I386_80387_IRQ          0x0d                        // standard npx
#define I386_80387_IRQL         (HIGHEST_LEVEL_FOR_8259 - I386_80387_IRQ)
#define I386_80387_VECTOR       (PRIMARY_VECTOR_BASE + I386_80387_IRQ)
#define PIC_VECTORS             16
#define V2I(a)  (a-PRIMARY_VECTOR_BASE)     // Vector to interrupt macro
#define I386_80387_BUSY_PORT    (PUCHAR)0xF0

#ifndef NEC_98
#define PIC_SLAVE_IRQ           2
#define PIC_SLAVE_REDIRECT      9
#else
#define PIC_SLAVE_IRQ           7
#define PIC_SLAVE_REDIRECT      8
#endif


#define EISA_EDGE_LEVEL0        0x4D0
#define EISA_EDGE_LEVEL1        0x4D1


/*
endif

;
; Same 8259 defines for assemble code
; BE SURE TO CHANGE THESE VALUES IN BOTH TABLES!
;

HIGHEST_LEVEL_FOR_8259  equ 27
PRIMARY_VECTOR_BASE     equ 30h
ifdef NEC_98
ifdef NT_UP_98
PROFILE_VECTOR          equ (PRIMARY_VECTOR_BASE + 0)
else 
PROFILE_VECTOR          equ (PRIMARY_VECTOR_BASE + 15)
endif
else  ; NEC_98
PROFILE_VECTOR          equ (PRIMARY_VECTOR_BASE + 8)
endif ; NEC_98
CLOCK_VECTOR            equ (PRIMARY_VECTOR_BASE + 0)
I386_80387_IRQ          equ 0dh
I386_80387_IRQL         equ (HIGHEST_LEVEL_FOR_8259 - I386_80387_IRQ)
I386_80387_VECTOR       equ (PRIMARY_VECTOR_BASE + I386_80387_IRQ)
I386_80387_BUSY_PORT    equ 0f0h    ; port to dismiss busy error line

ifdef NEC_98
PIC_SLAVE_IRQ           equ 7
else
PIC_SLAVE_IRQ           equ 2
endif

;
; The rest of the file are macros used in assemble only.
;

;++
;
;   SET_8259_MASK
;
;   Macro Description:
;
;       This macro sets 8259 interrupt mask register with the mask
;       passed from eax register.
;
;       Note: Currently, only two 8259s are support.  As a result,
;       only ax contains valid mask.
;
;   Arguments:
;
;       (eax) = mask for setting 8259 interrupt mask register
;
;--

SET_8259_MASK   macro
local   a                               ; define local labels

        out     PIC1_PORT1, al          ; set master 8259 mask
        shr     eax, 8                  ; shift slave 8259 mask to al
        out     PIC2_PORT1, al          ; set slave 8259 mask
a:
endm

;
;  Interrupt controller register addresses
;

ifdef NEC_98
PIC1_PORT0 equ 00H
PIC1_PORT1 equ 02H
PIC2_PORT0 equ 08H
PIC2_PORT1 equ 0AH
else  ; NEC_98
PIC1_PORT0 equ 020H
PIC1_PORT1 equ 021H
PIC2_PORT0 equ 0A0H
PIC2_PORT1 equ 0A1H
endif ; NEC_98

EISA_EDGE_LEVEL0        EQU     4D0h
EISA_EDGE_LEVEL1        EQU     4D1h

;
;  Commands for Interrupt controller
;

PIC1_EOI_MASK equ 060H
ifdef NEC_98
PIC2_EOI equ 067H                       ; special EOI
else  ; NEC_98
PIC2_EOI equ 062H
endif ; NEC_98
OCW2_NON_SPECIFIC_EOI equ 020H
OCW2_SPECIFIC_EOI equ 060H
OCW3_READ_ISR equ 0BH
OCW3_READ_IRR equ 0AH


;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro simply does a jmp to next instruction to synchronize
;       IO port access.
;
;   Arguments:
;
;       None
;
;--

IODELAY         macro
ifdef NEC_98
        out     5fh,al              ; same effect with "stdcall IODelay8259"
else  ; NEC_98
        jmp     $+2
endif ; NEC_98
endm


;++
;
;   PICDELAY
;
;   Macro Description:
;
;       This macro does an inb on interrupt mask register to provide the
;       time for 8259 to get stabled.
;
;       Why do we need this?
;
;       This is because:
;       . The 80386 has a delayed write to memory and delayed output to IO
;         capability and
;       . 8259 needs some time to settle
;
;       It is possible for the actual output cycle to 8259 to occur after
;       the completion of instructions following the out instruction.  For
;       example, the STI instruction after SET_MASK and dismiss interrupt
;       macros may complete before 8259 actually drops the interrupt.  We don't
;       want this happen in MCA system.
;
;       You may argue that most OEMS add about 450ns delay to solve the
;       back-to-back IO (delay) problem.  But, remember that STI is not an IO
;       instruction.
;
;   Arguments:
;
;       None
;
;   NOTE: * The content of AL will be destroyed on return.
;
;--

PIC1DELAY       macro
        in      al, PIC1_PORT1
endm

PIC2DELAY       macro
        in      al, PIC2_PORT1
endm

;++
;
;   SOFT_INTERRUPT_EXIT
;
;   Macro Description:
;
;       This macro is executed on return from the soft interrupt
;       service routine.  Its function is to restore privileged processor
;       state, and continue thread execution.
;
;   Arguments:
;
;       (TOS) = previous irql
;       (TOS+4 ...) = machine_state frame
;
;--

SOFT_INTERRUPT_EXIT macro

        EXTRNP  _HalpEndSoftwareInterrupt,1
        cli
        call    _HalpEndSoftwareInterrupt@4     ; restore irql
        SPURIOUS_INTERRUPT_EXIT                 ; exit interrupt without EOI
endm
;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixbeep.asm ===
title "Hal Beep"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixbeep.asm
;
;Abstract:
;
;    HAL routine to make noise.  It needs to synchronize its access to the
;    8254, since we also use the 8254 for the profiling interrupt.
;
;
;Author:
;
;    John Vert (jvert) 31-Jul-1991
;
;Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
        .list

        EXTRNP  _HalpAcquireSystemHardwareSpinLock,0
        EXTRNP  _HalpReleaseSystemHardwareSpinLock,0

;
; Defines used to program the i8254 for the speaker.
;

ifdef NEC_98
I8254_TIMER_CONTROL_PORT    equ   3fdfh     ; write mode port (for N mode)
I8254_TIMER_DATA_PORT       equ   3fdbh     ; count port (for N mode)
I8254_TIMER_CLOCK_IN        equ 2457600
I8254_TIMER_TONE_MAX        equ   65536
I8254_TIMER_CONTROL_SELECT  equ     76h
SPEAKER_CONTROL_PORT        equ     37h     ; system port C, set command port
SPEAKER_OFF                 equ     07h
SPEAKER_ON                  equ     06h
else  ; NEC_98
I8254_TIMER_CONTROL_PORT EQU    43h
I8254_TIMER_DATA_PORT    EQU    42h
I8254_TIMER_CLOCK_IN     EQU    1193167
I8254_TIMER_TONE_MAX     EQU    65536
I8254_TIMER_CONTROL_SELECT EQU  0B6h
SPEAKER_CONTROL_PORT     EQU    61h
SPEAKER_OFF_MASK         EQU    0FCh
SPEAKER_ON_MASK          EQU    03h
endif ; NEC_98

_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "HalMakeBeep"
;++
;
; BOOLEAN
; HalMakeBeep(
;       IN ULONG Frequency
;       )
;
; Routine Description:
;
;     This function sets the frequency of the speaker, causing it to sound a
;     tone.  The tone will sound until the speaker is explicitly turned off,
;     so the driver is responsible for controlling the duration of the tone.
;
;Arguments:
;
;     Frequency - Supplies the frequency of the desired tone.  A frequency of
;                 0 means the speaker should be shut off.
;
;Return Value:
;
;     TRUE  - Operation was successful (frequency within range or zero)
;     FALSE - Operation was unsuccessful (frequency was out of range)
;             Current tone (if any) is unchanged.
;
;--

Frequency equ [ebp + 8]

cPublicProc _HalMakeBeep    , 1

        push    ebp                     ; save ebp
        mov     ebp, esp                ;

        stdCall   _HalpAcquireSystemHardwareSpinLock      ; intr disabled

        ;
        ; Stop the speaker.
        ;

ifdef NEC_98
        mov      al, SPEAKER_OFF
        out      SPEAKER_CONTROL_PORT, al
        out      5Fh, al                        ; IoDelay
else  ; NEC_98
        in       al, SPEAKER_CONTROL_PORT
        jmp      $+2
        and      al, SPEAKER_OFF_MASK
        out      SPEAKER_CONTROL_PORT, al
        jmp      $+2
endif ; NEC_98

        ;
        ; Calculate Tone:  Tone = 1.193MHz / Frequency.
        ; N.B.  Tone must fit in 16 bits.
        ;

        mov      ecx, DWORD PTR [Frequency]     ; ecx <- frequency
        or       ecx, ecx                       ; (ecx) == 0?
        je       SHORT Hmb30                    ;     goto Hmb30

        mov      eax, I8254_TIMER_CLOCK_IN      ; eax <- 1.193MHz, the clockin
                                                ;    for the speaker tone
        sub      edx, edx                       ; edx <- zero
        div      ecx                            ; eax <- 1.193MHz / frequency
        cmp      eax, I8254_TIMER_TONE_MAX      ; (eax) < 2**16?
        jb       SHORT Hmb20                    ;     goto Hmb20

        ;
        ; Invalid frequency.  Return FALSE.
        ;

        sub      al, al
        jmp      SHORT Hmb40
Hmb20:
        ;
        ; Program the 8254 with the calculated tone.
        ;

ifdef NEC_98
        mov      dx, I8254_TIMER_CONTROL_PORT      ; port address for N
        mov      cx, I8254_TIMER_DATA_PORT

        push     eax                             ; save Tone
        mov      al, I8254_TIMER_CONTROL_SELECT
        out      dx, al                          ; select timer control register
        out      5Fh, al                         ; IoDelay

        pop      eax                             ; restore Tone
        mov      dx, cx                          ; set 'write mode' port addr
        out      dx, al                          ; program 8254 with Tone lsb
        out      5Fh, al                         ; IoDelay
        mov      al, ah
        out      dx, al                          ; program 8254 with Tone msb
        out      5Fh, al                         ; IoDelay

        ;
        ; Turn the speaker on.
        ;

        mov      al,SPEAKER_ON
        out      SPEAKER_CONTROL_PORT, al
        out      5Fh, al                         ; IoDelay
else  ; NEC_98
        push     eax                             ; save Tone
        mov      al, I8254_TIMER_CONTROL_SELECT
        out      I8254_TIMER_CONTROL_PORT, al    ; select timer control register
        jmp      $+2

        pop      eax                             ; restore Tone
        out      I8254_TIMER_DATA_PORT, al       ; program 8254 with Tone lsb
        jmp      $+2
        mov      al, ah
        out      I8254_TIMER_DATA_PORT, al       ; program 8254 with Tone msb
        jmp      $+2

        ;
        ; Turn the speaker on.
        ;

        in       al, SPEAKER_CONTROL_PORT
        jmp      $+2
        or       al, SPEAKER_ON_MASK
        out      SPEAKER_CONTROL_PORT, al
        jmp      $+2
endif ; NEC_98

Hmb30:
        ;
        ; Return TRUE.
        ;

        mov      al, 1

Hmb40:
        stdCall   _HalpReleaseSystemHardwareSpinLock

        pop    ebp                     ; restore ebp
        stdRET    _HalMakeBeep

stdENDP _HalMakeBeep

_TEXT$03   ends
           end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixbusdat.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Ken Reneris (kenr) July-28-1994

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"

#define DMALIMIT 7

VOID HalpInitOtherBuses (VOID);


ULONG
HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG HalpcGetCmosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG HalpcSetCmosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG HalpSetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

HalpGetEisaData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


//
// Prototype for system bus handlers
//

NTSTATUS
HalpAdjustEisaResourceList (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

ULONG
HalpGetEisaInterruptVector (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

BOOLEAN
HalpTranslateIsaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpTranslateEisaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

NTSTATUS
HalpHibernateHal (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler
    );

NTSTATUS
HalpResumeHal (
    IN PBUS_HANDLER  BusHandler,
    IN PBUS_HANDLER  RootHandler
    );

#ifdef MCA
//
// Default functionality of MCA handlers is the same as the Eisa handlers,
// just use them
//

#define HalpGetMCAInterruptVector   HalpGetEisaInterruptVector
#define HalpAdjustMCAResourceList   HalpAdjustEisaResourceList;

HalpGetPosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


#endif


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpRegisterInternalBusHandlers)
#pragma alloc_text(INIT,HalpAllocateBusHandler)
#endif


VOID
HalpRegisterInternalBusHandlers (
    VOID
    )
{
    PBUS_HANDLER    Bus;

    if (KeGetCurrentPrcb()->Number) {
        // only need to do this once
        return ;
    }

    //
    // Initalize BusHandler data before registering any handlers
    //

    HalpInitBusHandler ();

    //
    // Build internal-bus 0, or system level bus
    //

    Bus = HalpAllocateBusHandler (
            Internal,
            ConfigurationSpaceUndefined,
            0,                              // Internal BusNumber 0
            InterfaceTypeUndefined,         // no parent bus
            0,
            0                               // no bus specfic data
            );

    if (!Bus) {
        return;
    }

    Bus->GetInterruptVector  = HalpGetSystemInterruptVector;
    Bus->TranslateBusAddress = HalpTranslateSystemBusAddress;

#if 0
    //
    // Hibernate and resume the hal by getting notifications
    // for when this bus is hibernated or resumed.  Since it's
    // the first bus to be added, it will be the last to hibernate
    // and the first to resume
    //

    Bus->HibernateBus        = HalpHibernateHal;
    Bus->ResumeBus           = HalpResumeHal;
#endif

#if defined(NEC_98)
    Bus = HalpAllocateBusHandler (Isa, ConfigurationSpaceUndefined, 0, Internal, 0, 0);  // isa as child of Internal
    Bus->GetBusData = HalpNoBusData;
    Bus->AdjustResourceList = HalpAdjustEisaResourceList;
    Bus->TranslateBusAddress = HalpTranslateEisaBusAddress;

#else  //defined(NEC_98)
    //
    // Add handlers for Cmos config space.
    //

    Bus = HalpAllocateBusHandler (InterfaceTypeUndefined, Cmos, 0, -1, 0, 0);
    Bus->GetBusData = HalpcGetCmosData;
    Bus->SetBusData = HalpcSetCmosData;

    Bus = HalpAllocateBusHandler (InterfaceTypeUndefined, Cmos, 1, -1, 0, 0);
    Bus->GetBusData = HalpcGetCmosData;
    Bus->SetBusData = HalpcSetCmosData;

#ifndef MCA
    //
    // Build Isa/Eisa bus #0
    //

    Bus = HalpAllocateBusHandler (Eisa, EisaConfiguration, 0, Internal, 0, 0);
    Bus->GetBusData = HalpGetEisaData;
    Bus->GetInterruptVector = HalpGetEisaInterruptVector;
    Bus->AdjustResourceList = HalpAdjustEisaResourceList;
    Bus->TranslateBusAddress = HalpTranslateEisaBusAddress;

    Bus = HalpAllocateBusHandler (Isa, ConfigurationSpaceUndefined, 0, Eisa, 0, 0);
    Bus->GetBusData = HalpNoBusData;
    Bus->BusAddresses->Memory.Limit = 0xFFFFFF;
    Bus->TranslateBusAddress = HalpTranslateIsaBusAddress;

#else

    //
    // Build MCA bus #0
    //

    Bus = HalpAllocateBusHandler (MicroChannel, Pos, 0, Internal, 0, 0);
    Bus->GetBusData = HalpGetPosData;
    Bus->GetInterruptVector = HalpGetMCAInterruptVector;
    Bus->AdjustResourceList = HalpAdjustMCAResourceList;

#endif
#endif // defined(NEC_98)

    HalpInitOtherBuses ();
}



PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusInterfaceType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    )
/*++

Routine Description:

    Stub function to map old style code into new HalRegisterBusHandler code.

    Note we can add our specific bus handler functions after this bus
    handler structure has been added since this is being done during
    hal initialization.

--*/
{
    PBUS_HANDLER     Bus = NULL;


    //
    // Create bus handler - new style
    //

    HaliRegisterBusHandler (
        InterfaceType,
        BusDataType,
        BusNumber,
        ParentBusInterfaceType,
        ParentBusNumber,
        BusSpecificData,
        NULL,
        &Bus
    );

    if (!Bus) {
        return NULL;
    }

    if (InterfaceType != InterfaceTypeUndefined) {
        Bus->BusAddresses = ExAllocatePoolWithTag(SPRANGEPOOL,
                                                  sizeof(SUPPORTED_RANGES),
                                                  HAL_POOL_TAG);
        RtlZeroMemory(Bus->BusAddresses, sizeof(SUPPORTED_RANGES));
        Bus->BusAddresses->Version      = BUS_SUPPORTED_RANGE_VERSION;
        Bus->BusAddresses->Dma.Limit    = DMALIMIT;
        Bus->BusAddresses->Memory.Limit = 0xFFFFFFFF;
        Bus->BusAddresses->IO.Limit     = 0xFFFF;
        Bus->BusAddresses->IO.SystemAddressSpace = 1;
        Bus->BusAddresses->PrefetchMemory.Base = 1;
    }

    return Bus;
}


//
// C to Asm thunks for CMos
//

ULONG HalpcGetCmosData (
    IN PBUS_HANDLER BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    // this interface should be rev'ed to support non-zero offsets
    if (Offset != 0) {
        return 0;
    }

    return HalpGetCmosData (BusHandler->BusNumber, SlotNumber, Buffer, Length);
}


ULONG HalpcSetCmosData (
    IN PBUS_HANDLER BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    // this interface should be rev'ed to support non-zero offsets
    if (Offset != 0) {
        return 0;
    }

    return HalpSetCmosData (BusHandler->BusNumber, SlotNumber, Buffer, Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixcmos.inc ===
;/*
;++
;
;   Copyright (c) 1989  Microsoft Corporation
;
;   Module Name:
;
;       ixcmos.inc
;
;   Abstract:
;
;       This module contains common definitions used by the CMOS.
;
;   Author:
;
;       Landy Wang (corollary!landy) 04-Dec-1992
;
;               (Moved from ixclock.asm)
;
;--

;
;	_HalpAcquireCmosSpinLock and _HalpReleaseCmosSpinLock
;	must be called before accessing the CMOS in both uniprocessor
;	and multiprocessor systems.

RTCIRQ                  EQU     8       ; IRQ number for RTC interrupt
CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port

REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B
REGISTER_B_ENABLE_ALARM_INTERRUPT     EQU    00100000B
REGISTER_B_DISABLE_ALARM_INTERRUPT    EQU    00000000B
REGISTER_B_24HOUR_MODE                EQU    00000010B

;
; CMOS_READ
;
; Description: This macro reads a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Returns: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,AL    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

;
; CMOS_WRITE
;
; Description: This macro reads a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
;            (AH) = data to be written
;
; Return: None
;

CMOS_WRITE      MACRO
        OUT     CMOS_CONTROL_PORT,AL    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        MOV     AL,AH                   ; (AL) = DATA
        OUT     CMOS_DATA_PORT,AL       ; PLACE IN REQUESTED CMOS LOCATION
        IODelay                         ; I/O DELAY
ENDM


CMOS_STATUS_BUSY        EQU     80H     ; Time update in progress
RTC_OFFSET_SECOND       EQU     0       ; second field of RTC memory
RTC_OFFSET_SECOND_ALARM EQU     1       ; second alarm field of RTC memory
RTC_OFFSET_MINUTE       EQU     2       ; minute field of RTC memory
RTC_OFFSET_MINUTE_ALARM EQU     3       ; minute alarm field of RTC memory
RTC_OFFSET_HOUR         EQU     4       ; hour field of RTC memory
RTC_OFFSET_HOUR_ALARM   EQU     5       ; hour alarm field of RTC memory
RTC_OFFSET_DAY_OF_WEEK  EQU     6       ; day-of-week field of RTC memory
RTC_OFFSET_DATE_OF_MONTH EQU    7       ; date-of-month field of RTC memory
RTC_OFFSET_MONTH        EQU     8       ; month field of RTC memory
RTC_OFFSET_YEAR         EQU     9       ; year field of RTC memory
RTC_OFFSET_CENTURY_MCA  EQU     37h     ; Century field of RTC memory for MCA
RTC_OFFSET_CENTURY      EQU     32h     ; Century field of RTC memory
RTC_OFFSET_CENTURY_DS   EQU    148h     ; Bank 1, 48. Century field for DS
BANK1                   EQU    100h

;
; BCD_TO_BIN
;
; Description: Convert BCD value to binary
;
; Parameter:
;     Input: (AL) = 2 digit BCD number to convert
;     Output: (AX) = Binary equivalent (all in AL)
;
; Return: None.
;

BCD_TO_BIN      macro

        xor     ah,ah
        rol     ax,4
        ror     al,4
        aad
endm

;
; BIN_TO_BCD
;
; Description: Convert binary value to BCD.
;
; Parameter:
;     Input: (AL) = binary value to be converted.
;     Output: (AX) = BCD (all in AL)
;
; Return: None.
;

BIN_TO_BCD      macro

        aam
        rol     al, 4
        ror     ax, 4
endm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixdat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixdat.c

Abstract:

    Declares various data which is initialize data, or pagable data.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

//
// The following data is only valid during system initialiation
// and the memory will be re-claimed by the system afterwards
//

ADDRESS_USAGE HalpDefaultPcIoSpace = {
    NULL, CmResourceTypePort, DeviceUsage,
    {
        0x000,  0x20,   // ISA DMA
        0x0C0,  0x20,   // ISA DMA

        0x080,  0x10,   // DMA

        0x020,  0x2,    // PIC
        0x0A0,  0x2,    // Cascaded PIC

        0x040,  0x4,    // Timer1, Referesh, Speaker, Control Word
        0x048,  0x4,    // Timer2, Failsafe

#if 0   // HACKHACK Remove for now since Intelille mouse software claims it.
        0x061,  0x1,    // NMI  (system control port B)
#endif
        0x092,  0x1,    // system control port A

#ifndef ACPI_HAL
        0x070,  0x2,    // Cmos/NMI enable
#endif
#ifdef MCA
        0x074,  0x3,    // Extended CMOS

        0x090,  0x2,    // Arbritration Control Port, Card Select Feedback
        0x093,  0x2,    // Reserved, System board setup
        0x096,  0x2,    // POS channel select
#endif
        0x0F0,  0x10,   // coprocessor ports
#ifndef ACPI_HAL
        0xCF8,  0x8,    // PCI Config Space Access Pair
#endif
        0,0
    }
};

ADDRESS_USAGE HalpEisaIoSpace = {
    NULL, CmResourceTypePort, DeviceUsage,
    {
        0x0D0,  0x10,   // DMA
        0x400,  0x10,   // DMA
        0x480,  0x10,   // DMA
        0x4C2,  0xE,    // DMA
        0x4D4,  0x2C,   // DMA

        0x461,  0x2,    // Extended NMI
        0x464,  0x2,    // Last Eisa Bus Muster granted

        0x4D0,  0x2,    // edge/level control registers

        0xC84,  0x1,    // System board enable
        0, 0
    }
};

#ifndef ACPI_HAL

ADDRESS_USAGE HalpDetectedROM = {
    NULL,
    CmResourceTypeMemory,
    InternalUsage | RomResource,
    {
        0,0,                // 32 ROM blocks, get initialized in ixusage.c
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0
    }
};

#endif

//
// Strings used for boot.ini options
// from mphal.c
//

UCHAR HalpSzBreak[]     = "BREAK";
UCHAR HalpSzPciLock[]   = "PCILOCK";

//
// From ixcmos.asm
//

UCHAR HalpSerialLen = 0;
UCHAR HalpSerialNumber[31] = {0};

//
// From usage.c
//

WCHAR HalpSzSystem[] = L"\\Registry\\Machine\\Hardware\\Description\\System";
WCHAR HalpSzSerialNumber[] = L"Serial Number";

ADDRESS_USAGE  *HalpAddressUsageList = NULL;

//
// Misc hal stuff in the registry
//

WCHAR rgzHalClassName[] = L"Hardware Abstraction Layer";


//
// From ixpcibus.c
//

WCHAR rgzMultiFunctionAdapter[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";
WCHAR rgzPCIIdentifier[] = L"PCI";
WCHAR rgzPCICardList[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\PnP\\PCI\\CardList";

//
// From ixpcibrd.c
//

WCHAR rgzReservedResources[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SystemResources\\ReservedResources";

//
// From ixinfo.c
//

WCHAR rgzSuspendCallbackName[] = L"\\Callback\\SuspendHibernateSystem";
UCHAR   HalpGenuineIntel[]= "GenuineIntel";

//
// From ixmca.c
//
UCHAR   MsgMCEPending[] = MSG_MCE_PENDING;
WCHAR   rgzSessionManager[] = L"Session Manager";
WCHAR   rgzEnableMCE[] = L"EnableMCE";
WCHAR   rgzEnableMCA[] = L"EnableMCA";

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

ULONG   HalpFeatureBits = 0;

//
// Stuff that we only need while we
// sleep or hibernate.
//

MOTHERBOARD_CONTEXT HalpMotherboardState = {0};

//
// PAGELK handle
//
PVOID   HalpSleepPageLock = NULL;
PVOID   HalpSleepPage16Lock = NULL;

USHORT  HalpPciIrqMask = 0;
USHORT  HalpEisaIrqMask = 0;
USHORT  HalpEisaIrqIgnore = 0x1000;
BOOLEAN HalpDisableHibernate = FALSE;

//
// Timer watchdog variables
//
ULONG   HalpTimerWatchdogEnabled = 0;
ULONG   HalpTimerWatchdogStorageOverflow = 0;
PVOID   HalpTimerWatchdogCurFrame = NULL;
PVOID   HalpTimerWatchdogLastFrame = NULL;
PCHAR   HalpTimerWatchdogStorage = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (corollary!landy) 04-Dec-92
;       Move much code into separate modules for easy inclusion by various
;       HAL builds.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _KeUpdateSystemTime,0
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _KeSetTimeIncrement,2,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRNP  _HalpMcaQueueDpc, 0
        extrn   _KdEnteredDebugger:DWORD
        extrn   _HalpTimerWatchdogEnabled:DWORD
        extrn   _HalpTimerWatchdogStorage:DWORD
        extrn   _HalpTimerWatchdogCurFrame:DWORD
        extrn   _HalpTimerWatchdogLastFrame:DWORD
        extrn   _HalpTimerWatchdogStorageOverflow:DWORD

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port
TIMER2_DATA_PORT0       EQU     48H     ; Timer1, channel 0 data port
TIMER2_CONTROL_PORT0    EQU     4BH     ; Timer1, channel 0 control port
TIMER1_IRQ              EQU     0       ; Irq 0 for timer1 interrupt

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

PERFORMANCE_FREQUENCY   EQU     1193182

COUNTER_TICKS_AVG_SHIFT EQU     4
COUNTER_TICKS_FOR_AVG   EQU     16
PAGE_SIZE               EQU     1000H
FRAME_COPY_SIZE         EQU     64

;
; ==== Values used for System Clock ====
;


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; The following array stores the per microsecond loop count for each
; central processor.
;

;
; 8254 performance counter.
;

        public HalpPerfCounterLow, HalpPerfCounterHigh
        public HalpLastPerfCounterLow, HalpLastPerfCounterHigh
HalpPerfCounterLow      dd      0
HalpPerfCounterHigh     dd      0
HalpLastPerfCounterLow  dd      0
HalpLastPerfCounterHigh dd      0

        public HalpCurrentRollOver, HalpCurrentTimeIncrement
HalpCurrentRollOver         dd      0
HalpCurrentTimeIncrement    dd      0

        public _HalpClockWork, _HalpClockSetMSRate, _HalpClockMcaQueueDpc
_HalpClockWork label dword
    _HalpClockSetMSRate     db  0
    _HalpClockMcaQueueDpc   db  0
    _bReserved1             db  0
    _bReserved2             db  0

;
; timer latency watchdog variables
;

        public  _HalpWatchdogAvgCounter, _HalpWatchdogCountLow, _HalpWatchdogCountHigh
        public  _HalpWatchdogTscLow, _HalpWatchdogTscHigh

    _HalpWatchdogAvgCounter dd  0
    _HalpWatchdogCountLow   dd  0
    _HalpWatchdogCountHigh  dd  0
    _HalpWatchdogTscLow     dd  0
    _HalpWatchdogTscHigh    dd  0

_DATA   ends

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

;
; Convert the interval to rollover count for 8254 Timer1 device.
; Timer1 counts down a 16 bit value at a rate of 1.193181667M counts-per-sec.
; (The main crystal freq is 14.31818, and this is a divide by 12)
;
; The best fit value closest to 10ms is 10.0144012689ms:
;   ROLLOVER_COUNT      11949
;   TIME_INCREMENT      100144
;   Calculated error is -.0109472 s/day
;
;
; The following table contains 8254 values timer values to use at
; any given ms setting from 1ms - 15ms.  All values work out to the
; same error per day (-.0109472 s/day).
;

        public HalpRollOverTable

        ;                    RollOver   Time
        ;                    Count      Increment   MS
HalpRollOverTable       dd      1197,   10032       ;  1 ms
                        dd      2394,   20064       ;  2 ms
                        dd      3591,   30096       ;  3 ms
                        dd      4767,   39952       ;  4 ms
                        dd      5964,   49984       ;  5 ms
                        dd      7161,   60016       ;  6 ms
                        dd      8358,   70048       ;  7 ms
                        dd      9555,   80080       ;  8 ms
                        dd     10731,   89936       ;  9 ms
                        dd     11949,  100144       ; 10 ms
                        dd     13125,  110000       ; 11 ms
                        dd     14322,  120032       ; 12 ms
                        dd     15519,  130064       ; 13 ms
                        dd     16695,  139920       ; 14 ms
                        dd     17892,  149952       ; 15 ms

TimeIncr equ    4
RollOver equ    0

_TEXT   ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        public HalpLargestClockMS, HalpNextMSRate, HalpPendingMSRate
HalpLargestClockMS      dd      15      ; Table goes to 15MS
HalpNextMSRate          dd      0
HalpPendingMSRate       dd      0

_DATA   ends


PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;    This routine initialize system time clock using 8254 timer1 counter 0
;    to generate an interrupt at every 15ms interval at 8259 irq0.
;
;    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
;    needs to be changed.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbCpuType, 4     ; 486 or better?
        jc      short @f                        ; no, skip

        mov     HalpLargestClockMS, 10          ; Limit 486's to 10MS
@@:
        mov     eax, HalpLargestClockMS
        mov     ecx, HalpRollOverTable.TimeIncr
        mov     edx, HalpRollOverTable[eax*8-8].TimeIncr
        mov     eax, HalpRollOverTable[eax*8-8].RollOver

        mov     HalpCurrentTimeIncrement, edx

;
; (ecx) = Min time_incr
; (edx) = Max time_incr
; (eax) = max roll over count
;

        push    eax
        stdCall _KeSetTimeIncrement, <edx, ecx>
        pop     ecx

;
; timer latency watchdog initialization
;
        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx
        xor     eax, eax
        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, eax
@@:    

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

;
; Set clock rate
; (ecx) = RollOverCount
;

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        popfd                             ; restore caller's eflag
        mov     HalpCurrentRollOver, ecx  ; Set RollOverCount & initialized

        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

PAGELK  ends


_TEXT$03  SEGMENT DWORD PUBLIC 'CODE'

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceCounter (
;    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
;    )
;
; Routine Description:
;
;    This routine returns current 64-bit performance counter and,
;    optionally, the Performance Frequency.
;
;    Note this routine can NOT be called at Profiling interrupt
;    service routine.  Because this routine depends on IRR0 to determine
;    the actual count.
;
;    Also note that the performace counter returned by this routine
;    is not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    PerformanceFrequency [TOS+4] - optionally, supplies the address
;        of a variable to receive the performance counter frequency.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--


;
; Parameter definitions
;

KqpcFrequency   EQU     [esp+12]        ; User supplied Performance Frequence

cPublicProc _KeQueryPerformanceCounter      ,1
;
; First check to see if the performance counter has been initialized yet.
; Since the kernel debugger calls KeQueryPerformanceCounter to support the
; !timer command, we need to return something reasonable before 8254
; initialization has occured.  Reading garbage off the 8254 is not reasonable.
;
        cmp     HalpCurrentRollOver, 0
        je      Kqpc50

        push    ebx
        push    esi

Kqpc01: pushfd
        cli
Kqpc20:

;
; Fetch the base value.  Note that interrupts are off.
;

        mov     ebx, HalpPerfCounterLow
        mov     esi, HalpPerfCounterHigh ; [esi:ebx] = Performance counter

;
; Fetch the current counter value from the hardware
;

        mov     al, COMMAND_8254_LATCH_READ+COMMAND_8254_COUNTER0
                                        ;Latch PIT Ctr 0 command.
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ;Read PIT Ctr 0, LSByte.
        IODelay
        movzx   ecx,al                  ;Zero upper bytes of (ECX).
        in      al, TIMER1_DATA_PORT0   ;Read PIT Ctr 0, MSByte.
        mov     ch, al                  ;(CX) = PIT Ctr 0 count.

;
; Now enable interrupts such that if timer interrupt is pending, it can
; be serviced and update the PerformanceCounter.  Note that there could
; be a long time between the sti and cli because ANY interrupt could come
; in in between.
;

        popfd                           ; don't re-enable interrupts if
        nop                             ; the caller had them off!
                                        ; (kernel debugger calls this function
                                        ; with interrupts disabled)

        jmp     $+2                     ; allow interrupt in case counter
                                        ; has wrapped

        pushfd
        cli

;
; Fetch the base value again.
;
; Note: it's possible that the counter wrapped before we read the value
; and that the timer tick interrupt did not occur during while interrupts
; where enabled.  (ie, there's a delay between when the device raises the
; interrupt and when the processor see it).
;
;
; note *2 -


        mov     eax, HalpPerfCounterLow
        mov     edx, HalpPerfCounterHigh ; [edx:eax] = new counter value

;
; Compare the two reads of Performance counter.  If they are different,
; start over
;

        cmp     eax, ebx
        jne     short Kqpc20
        cmp     edx, esi
        jne     short Kqpc20

        neg     ecx                     ; PIT counts down from 0h
        add     ecx, HalpCurrentRollOver
        jnc     short Kqpc60

Kqpc30:
        add     eax, ecx
        adc     edx, 0                  ; [edx:eax] = Final result

        cmp     edx, HalpLastPerfCounterHigh
        jc      short Kqpc70            ; jmp if edx < lastperfcounterhigh
        jne     short Kqpc35            ; jmp if edx > lastperfcounterhigh

        cmp     eax, HalpLastPerfCounterLow
        jc      short Kqpc70            ; jmp if eax < lastperfcounterlow

Kqpc35:
        mov     HalpLastPerfCounterLow, eax
        mov     HalpLastPerfCounterHigh, edx

        popfd                           ; restore interrupt flag

;
;   Return the freq. if caller wants it.
;

        cmp     dword ptr KqpcFrequency, 0 ; is it a NULL variable?
        jz      short Kqpc40            ; if z, yes, go exit

        mov     ecx, KqpcFrequency      ; (ecx)-> Frequency variable
        mov     DWORD PTR [ecx], PERFORMANCE_FREQUENCY ; Set frequency
        mov     DWORD PTR [ecx+4], 0

Kqpc40:
        pop     esi                     ; restore esi and ebx
        pop     ebx
        stdRET    _KeQueryPerformanceCounter


Kqpc50:
; Initialization hasn't occured yet, so just return zeroes.
        mov     eax, 0
        mov     edx, 0
        stdRET    _KeQueryPerformanceCounter

Kqpc60:
;
; The current count is larger then the HalpCurrentRollOver.  The only way
; that could happen is if there is an interrupt in route to the processor
; but it was not processed  while interrupts were enabled.
;
        mov     esi, [esp]                  ; (esi) = flags
        mov     ecx, HalpCurrentRollOver    ; (ecx) = max possible value
        popfd                               ; restore flags

        test    esi, EFLAGS_INTERRUPT_MASK
        jnz     Kqpc01                  ; ints are enabled, problem should go away

        pushfd                          ; fix stack
        jmp     short Kqpc30            ; ints are disabled, use max count (ecx)


Kqpc70:
;
; The current count is smaller then the last returned count.  The only way
; this should occur is if there is an interrupt in route to the processor
; which was not been processed.
;

        mov     ebx, HalpLastPerfCounterLow
        mov     esi, HalpLastPerfCounterHigh

        mov     ecx, ebx
        or      ecx, esi                ; is last returned value 0?
        jz      short Kqpc35            ; Yes, then just return what we have

        ; sanity check - make sure count is not off by bogus amount
        sub     ebx, eax
        sbb     esi, edx
        jnz     short Kqpc75            ; off by bogus amount
        cmp     ebx, HalpCurrentRollOver
        jg      short Kqpc75            ; off by bogus amount

        sub     eax, ebx
        sbb     edx, esi                ; (edx:eax) = last returned count

        mov     ecx, [esp]              ; (ecx) = flags
        popfd

        test    ecx, EFLAGS_INTERRUPT_MASK
        jnz     Kqpc01                  ; ints enabled, problem should go away

        pushfd                          ; fix stack
        jmp     Kqpc35                  ; ints disabled, just return last count

Kqpc75:
        popfd
        xor     eax, eax                ; reset bogus values
        mov     HalpLastPerfCounterLow, eax
        mov     HalpLastPerfCounterHigh, eax
        jmp     Kqpc01                  ; go try again

stdENDP _KeQueryPerformanceCounter

;++
;
; VOID
; HalCalibratePerformanceCounter (
;     IN LONG volatile *Number,
;     IN ULONGLONG NewCount
;     )
;
; /*++
;
; Routine Description:
;
;     This routine resets the performance counter value for the current
;     processor to zero. The reset is done such that the resulting value
;     is closely synchronized with other processors in the configuration.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
;     NewCount - Supplies the value to synchronize the counter too
;
;     Note: this hal does not currently set the counter
;
; Return Value:
;
;     None.
;--
cPublicProc _HalCalibratePerformanceCounter,3
        mov     eax, [esp+4]            ; ponter to Number
        pushfd                          ; save previous interrupt state
        cli                             ; disable interrupts (go to high_level)

    lock dec    dword ptr [eax]         ; count down

@@:     YIELD
        cmp     dword ptr [eax], 0      ; wait for all processors to signal
        jnz     short @b

    ;
    ; Nothing to calibrate on a UP machine...
    ;

        popfd                           ; restore interrupt flag
        stdRET    _HalCalibratePerformanceCounter

stdENDP _HalCalibratePerformanceCounter



        page ,132
        subttl  "System Clock Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by CLOCK.
;    Its function is to dismiss the interrupt, raise system Irql to
;    CLOCK2_LEVEL, update performance counter and transfer control to the
;    standard system routine to update the system time and the execution
;    time of the current thread
;    and process.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;    Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hci_a, Hci_t

cPublicProc _HalpClockInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hci_a, Hci_t

;
; (esp) - base of trap frame
;

;
; Dismiss interrupt and raise irq level to clock2 level
;

Hci10:
        push    CLOCK_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL, CLOCK_VECTOR, esp>

        or      al,al                           ; check for spurious interrupt
        jz      Hci100

;
; Update performance counter
;

        xor     ebx, ebx
        mov     eax, HalpCurrentRollOver
        add     HalpPerfCounterLow, eax         ; update performace counter
        adc     HalpPerfCounterHigh, ebx

;
; Timer latency watchdog
;

        cmp     _HalpTimerWatchdogEnabled, 0
        jz      Hci14

        .586p
        rdtsc
        .386p

;
; Compare difference to watchdog count, while storing a copy of the
; current counter.
;

        push    eax
        push    edx

        sub     eax, _HalpWatchdogTscLow
        sbb     edx, _HalpWatchdogTscHigh

        pop     _HalpWatchdogTscHigh
        pop     _HalpWatchdogTscLow
        js      Hci115                      ; Was this a bogus counter?
                                            ;   (e.g, negative delta)

        push    eax
        mov     ecx, dword ptr _KdEnteredDebugger
        xor     eax, eax
        xchg    eax, [ecx]
        or      al, al                      
        pop     eax
        jnz     Hci14

        cmp     HalpPendingMSRate, ebx      ; Was a new rate set during last
        jnz     Hci14                       ; tick?  Yes, skip this compare

;
; If we need to compute the average of the time-stamp counter for
; the current period, add the delta to the counter.
;

        cmp     _HalpWatchdogAvgCounter, ebx
        jnz     Hci12

        cmp     edx, _HalpWatchdogCountHigh
        ja      short Hci11
        jb      Hci14

        cmp     eax, _HalpWatchdogCountLow
        jbe     Hci14

Hci11:  
        cmp     dword ptr [_HalpTimerWatchdogStorageOverflow], 0
        jne     short Hci115


;
; copy FRAME_COPY_SIZE dwords from the stack, or to next page boundary,
; whichever is less
;       

        push    esi
        push    edi
        lea     esi, [esp+8]
        lea     ecx, [esi + PAGE_SIZE - 1]
        and     ecx, NOT(PAGE_SIZE - 1)
        sub     ecx, esi
        shr     ecx, 2
        cmp     ecx, FRAME_COPY_SIZE
        jbe     short Hci111
        mov     ecx, FRAME_COPY_SIZE
Hci111:
        mov     edi, dword ptr _HalpTimerWatchdogCurFrame
        rep     movsd
        add     _HalpTimerWatchdogCurFrame, (FRAME_COPY_SIZE*4)
;
; If we didn't copy an entire FRAME_COPY_SIZE dwords, zero fill.
;
        mov     ecx, dword ptr _HalpTimerWatchdogCurFrame
        sub     ecx, edi
        shr     ecx, 2
        xor     eax, eax
        rep     stosd
        cmp     edi, dword ptr _HalpTimerWatchdogLastFrame
        jbe     short Hci112
        mov     dword ptr [_HalpTimerWatchdogStorageOverflow], 1
Hci112:

        pop     edi
        pop     esi

Hci115:


;
; reset last time so that we're accurate after the trap
;
        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogTscHigh, edx
        mov     _HalpWatchdogTscLow, eax
        
        jmp     short Hci14

Hci12:
;
; Increment the total counter, perform average when the count is reached
;

        add     _HalpWatchdogCountLow, eax
        adc     _HalpWatchdogCountHigh, edx        
        dec     _HalpWatchdogAvgCounter
        jnz     short Hci14

        mov     edx, _HalpWatchdogCountHigh
        mov     eax, _HalpWatchdogCountLow

;
; compute the average * 2, this measures when we have missed 
; an interrupt at this rate.
;                 
        mov     ecx, COUNTER_TICKS_AVG_SHIFT - 1
Hci13:    
        shr     edx, 1
        rcr     eax, 1
        loop    short Hci13

        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, edx

Hci14:

;
; Check for any more work
;

        mov     eax, HalpCurrentTimeIncrement

        cmp     _HalpClockWork, ebx         ; Any clock interrupt work desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick

        cmp     _HalpClockMcaQueueDpc, bl
        je      short Hci20

        mov     _HalpClockMcaQueueDpc, bl

;
; Queue MCA Dpc
;

        push    eax
        stdCall _HalpMcaQueueDpc            ; Queue MCA Dpc
        pop     eax


Hci20:
;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment
; ebx = 0
;
        cmp     _HalpClockSetMSRate, bl     ; New clock rate desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick

;
; Time of clock frequency is being changed.  See if the 8254 was
; was reprogrammed for a new rate during last tick
;
        cmp     HalpPendingMSRate, ebx      ; Was a new rate set durning last
        jnz     short Hci50                 ; tick?  Yes, go update globals

Hci40:
; (eax) = time increment for current tick

;
; A new clock rate needs to be set.  Setting the rate here will
; cause the tick after the next tick to be at the new rate.
; (the next tick is already in progress by the 8254 and will occur
; at the same rate as this tick)
;
        mov     ebx, HalpNextMSRate
        mov     HalpPendingMSRate, ebx  ; pending rate

        mov     ecx, HalpRollOverTable[ebx*8-8].RollOver

;
; Set clock rate
; (ecx) = RollOverCount
;
        push    eax                     ; save current tick's rate

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        pop     eax

;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment
;
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

Hci50:
;
; The next tick will occur at the rate which was programmed during the last
; tick. Update globals for new rate which starts with the next tick.
;
; (eax) = time increment for current tick
;
        mov     ebx, HalpPendingMSRate
        mov     ecx, HalpRollOverTable[ebx*8-8].RollOver
        mov     edx, HalpRollOverTable[ebx*8-8].TimeIncr

        mov     HalpCurrentRollOver, ecx
        mov     HalpCurrentTimeIncrement, edx   ; next tick rate
        mov     HalpPendingMSRate, 0    ; no longer pending, clear it

        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

;
; Schedule to recalibrate watchdog counter
;
        push    eax
        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx

        xor     eax,eax
        mov     _HalpWatchdogCountHigh, eax
        mov     _HalpWatchdogCountLow, eax
        pop     eax
@@:


        cmp     ebx, HalpNextMSRate     ; new rate == NextRate?
        jne     Hci40                   ; no, go set new pending rate

        mov     _HalpClockSetMSRate, 0  ; all done setting new rate

        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

Hci100:
        add     esp, 8                  ; spurious, no EndOfInterrupt
        SPURIOUS_INTERRUPT_EXIT         ; exit interrupt without eoi

stdENDP _HalpClockInterrupt

;++
;
; ULONG
; HalSetTimeIncrement (
;     IN ULONG DesiredIncrement
;     )
;
; /*++
;
; Routine Description:
;
;    This routine initialize system time clock to generate an
;    interrupt at every DesiredIncrement interval.
;
; Arguments:
;
;     DesiredIncrement - desired interval between every timer tick (in
;                        100ns unit.)
;
; Return Value:
;
;     The *REAL* time increment set.
;--
cPublicProc _HalSetTimeIncrement,1

        mov     eax, [esp+4]                ; desired setting
        xor     edx, edx
        mov     ecx, 10000
        div     ecx                         ; round to MS

        cmp     eax, HalpLargestClockMS     ; MS > max?
        jc      short @f
        mov     eax, HalpLargestClockMS     ; yes, use max
@@:
        or      eax, eax                    ; MS < min?
        jnz     short @f
        inc     eax                         ; yes, use min
@@:
        mov     HalpNextMSRate, eax
        mov     _HalpClockSetMSRate, 1      ; New clock rate desired.

        mov     eax, HalpRollOverTable[eax*8-8].TimeIncr
        stdRET  _HalSetTimeIncrement

stdENDP _HalSetTimeIncrement
_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixcmos.asm ===
title  "Cmos Access Routines"
;++
;
; Module Name:
;
;    ixcmos.asm
;
; Abstract:
;
;    Procedures necessary to access CMOS/ECMOS information.
;
; Author:
;
;    David Risner (o-ncrdr) 20 Apr 1992
;
; Revision History:
;
;    Landy Wang (corollary!landy) 04 Dec 1992
;    - Move much code from ixclock.asm to here so different HALs
;      can reuse the common functionality.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        extrn   _HalpSystemHardwareLock:DWORD
        extrn   _HalpBusType:DWORD
        extrn   _HalpSerialLen:BYTE
        extrn   _HalpSerialNumber:BYTE

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; HalpRebootNow is a reboot vector.  Set in an MP system, to
; cause any processors which may be looping in HalpAcquireCmosSinLock
; to transfer control to the vector in HalpRebootNow
;

    public  _HalpRebootNow
_HalpRebootNow           dd      0

;
; Holds the value of the eflags register before a cmos spinlock is
; acquired (used in HalpAcquire/ReleaseCmosSpinLock().
;
_HalpHardwareLockFlags   dd      0

;
; Holds the offset to CMOS Century information.
;

    public _HalpCmosCenturyOffset
_HalpCmosCenturyOffset   dd      0

_DATA   ends

        subttl  "HalpGetCmosData"

;++
;
; CMOS space read and write functions.
;
;--

CmosAddressPort         equ     70H
CmosDataPort            equ     71H

ECmosAddressLsbPort     equ     74H
ECmosAddressMsbPort     equ     75H
ECmosDataPort           equ     76H


INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

ifndef ACPI_HAL
;++
;
;   VOID
;   HalpInitializeCmos(
;       VOID
;       )
;
;   This routine reads CMOS and initializes globals required for
;   CMOS access, such as the location of the century byte.
;
;--

cPublicProc _HalpInitializeCmos,0

        push    ebx
        push    esi
        push    edi

;
; Assume default
;

        mov     eax, RTC_OFFSET_CENTURY
        mov     _HalpCmosCenturyOffset, eax

        cmp     _HalpBusType, MACHINE_TYPE_ISA
        jne     icm40


;
; If control comes here, this is ISA machine.  We need to check if this is
; IBM PS/1 or Pc/ValuePoint machine and use RTC_CENTURY_OFFSET_MCA to get
; Century byte from CMOS.
;

;
; Check if the CMOS 2e and 2f contains memory checksum.  On PS/1 machine
; the check should fail.
;

icm20:  mov     ecx, 2dh                ; from 10h to 2dh
        mov     eax, 0                  ; clear ax
        mov     edx, 0

icm30:  mov     al, cl
        CMOS_READ
        add     edx, eax
        dec     ecx
        cmp     ecx, 0fh
        jne     short icm30

        mov     eax, 2eh
        CMOS_READ
        mov     ah, al
        mov     al, 2fh
        CMOS_READ
        cmp     eax, edx
        je      short icm50             ; NOT PS/1

        mov     eax, RTC_OFFSET_CENTURY_MCA
        mov     _HalpCmosCenturyOffset, eax
        jmp     icm90

icm40:  cmp     _HalpBusType, MACHINE_TYPE_MCA
        jne     short icm50

;
; See if this is a P700 MCA machine
;

        in      al, 07fh                        ; get PD700 ID byte
        and     al, 0F0h                        ; Mask high nibble
        cmp     al, 0A0h                        ; Is the ID Ax?
        jz      short icm50
        cmp     al, 090h                        ; Or an 9X?
        jz      short icm50                     ; Yes, it's a 700

        mov     eax, RTC_OFFSET_CENTURY_MCA
        mov     _HalpCmosCenturyOffset, eax

icm50:

if 0

    - Selecting BANK1 causes some devices to mess up their month value
    - For now, I'm removing this code until this problem can be solved

;
; See if this is a Dallas Semiconductor DS17285 or later
; Switch to BANK 1
;
        mov     al, 0Ah
        CMOS_READ

        and     al, 7fh                         ; Don't write UIP
        mov     ah, al
        mov     esi, eax                        ; save it for restore
        or      ah, 10h                         ; Set DV0 = 1

        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE

;
; Check for RTC serial # with matching crc
; (al)  = current byte
; (ah)  = scratch register
; (bl)  = current crc
; (bh)  = zero, non-zero, flag
; (ecx) = cmos offset
; (edx) = used by cmos_read macro
; (esi) = saved register 0A
;
        mov     ecx, 40h
        xor     ebx, ebx

icm60:  mov     al, cl
        CMOS_READ
        mov     byte ptr _HalpSerialNumber+2+-40h[ecx], al

        or      bh, al                  ; or to check for all zeros

        mov     ch, 8                   ; Bits per byte

icm65:  mov     ah, bl                  ; ah = crc
        xor     ah, al                  ; xor LSb
        shr     bl, 1                   ; shift crc
        shr     ah, 1                   ; mov LSb to carry
        sbb     ah, ah                  ; if carry set 1's else 0's
        and     ah, (118h shr 1)        ; crc polynomial
        xor     bl, ah                  ; apply it

        shr     al, 1                   ; next bit
        dec     ch                      ;
        jnz     short icm65             ; if ch non-zero, loop

        inc     cl                      ; next cmos location
        cmp     cl, 48h                 ; at end?
        jne     short icm60             ; no, loop
;
; (bh) = zero, non-zero flag
; (bl) = crc
;

        mov     eax, RTC_OFFSET_CENTURY_DS      ; Read century byte
        CMOS_READ

        BCD_TO_BIN
        movzx   ecx, ax                         ; save it

;
; Switch back to BANK 0
;

        mov     eax, esi
        mov     al, 0Ah
        CMOS_WRITE

;
; Check for valid DS data
;
        cmp     bh, 0                           ; Was data all zeros?
        je      short icm90

        cmp     bl, 0                           ; was CRC valid?
        jnz     short icm90

        cmp     ecx, 19                         ; Is century before 19?
        jb      short icm90

        cmp     ecx, 20                         ; Is century after 20?
        ja      short icm90

;
; Setup for DS century byte
;
        mov     byte ptr _HalpSerialNumber+0, 'D'
        mov     byte ptr _HalpSerialNumber+1, 'S'
        mov     _HalpSerialLen, 10

        mov     eax, RTC_OFFSET_CENTURY_DS
        mov     _HalpCmosCenturyOffset, eax
endif

icm90:  pop     edi
        pop     esi
        pop     ebx
        stdRET  _HalpInitializeCmos

stdENDP _HalpInitializeCmos

endif

INIT   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;
;   ULONG
;   HalpGetCmosData(
;       IN ULONG    SourceLocation
;       IN ULONG    SourceAddress
;       IN ULONG    ReturnBuffer
;       IN PUCHAR   ByteCount
;       )
;
;   This routine reads the requested number of bytes from CMOS/ECMOS and
;   stores the data read into the supplied buffer in system memory.  If
;   the requested data amount exceeds the allowable extent of the source
;   location, the return data is truncated.
;
;   Arguments:
;
;       SourceLocation  : where data is to be read from CMOS or ECMOS
;                           0 - CMOS, 1 - ECMOS
;
;       SourceAddress   : address in CMOS/ECMOS where data is to be read from
;
;       ReturnBuffer    : address in system memory for return data
;
;       ByteCount       : number of bytes to be read
;
;   Returns:
;
;       Number of byte actually read.
;
;--

SourceLocation  equ     2*4[ebp]
SourceAddress   equ     3*4[ebp]
ReturnBuffer    equ     4*4[ebp]
ByteCount       equ     5*4[ebp]

cPublicProc _HalpGetCmosData    ,4

        push    ebp
        mov     ebp, esp
        push    ebx
        push    edi

    ;
    ; NOTE: The spinlock is needed even in the UP case, because
    ;    the resource is also used in an interrupt handler (profiler).
    ;    If we own the spinlock in this routine, and we service
    ;    the profiler interrupt (which will wait for the spinlock forever),
    ;    then we have a hosed system.
    ;
        stdCall _HalpAcquireCmosSpinLock

        xor     edx, edx                ; initialize return data length
        mov     ecx, ByteCount

        or      ecx, ecx                ; validate requested byte count
        jz      HalpGetCmosDataExit     ; if no work to do, exit

        mov     edx, SourceAddress
        mov     edi, ReturnBuffer

        mov     eax, SourceLocation     ; cmos or extended cmos?
        cmp     eax, 1
        je      ECmosReadByte
        cmp     eax, 0
        jne     HalpGetCmosDataExit

CmosReadByte:
        cmp     edx, 0ffH               ; validate cmos source address
        ja      HalpGetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     CmosAddressPort, al
        in      al, CmosDataPort
        mov     [edi], al
        inc     edx
        inc     edi
        dec     ecx
        jnz     CmosReadByte
        jmp     SHORT HalpGetCmosDataExit

ECmosReadByte:
        cmp     edx,0ffffH              ; validate ecmos source address
        ja      HalpGetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     ECmosAddressLsbPort, al
        mov     al, dh
        out     ECmosAddressMsbPort, al
        in      al, ECmosDataPort
        mov     [edi], al
        inc     edx
        inc     edi
        dec     ecx
        jnz     ECmosReadByte

HalpGetCmosDataExit:
        stdCall _HalpReleaseCmosSpinLock

        mov     eax, edx                ; return bytes read
        sub     eax, SourceAddress      ; subtract the initial offset

        pop     edi
        pop     ebx
        pop     ebp

        stdRET    _HalpGetCmosData

stdENDP _HalpGetCmosData


;++
;
;   VOID
;   HalpSetCmosData(
;       IN ULONG    SourceLocation
;       IN ULONG    SourceAddress
;       IN ULONG    ReturnBuffer
;       IN PUCHAR   ByteCount
;       )
;
;   This routine writes the requested number of bytes to CMOS/ECMOS
;
;   Arguments:
;
;       SourceLocation  : where data is to be written to CMOS or ECMOS
;                           0 - CMOS, 1 - ECMOS
;
;       SourceAddress   : address in CMOS/ECMOS where data is to write to.
;
;       ReturnBuffer    : address in system memory for data to write
;
;       ByteCount       : number of bytes to be write
;
;   Returns:
;
;       Number of byte actually written.
;
;--

cPublicProc _HalpSetCmosData    ,4

        push    ebp
        mov     ebp, esp
        push    ebx
        push    edi

        stdCall _HalpAcquireCmosSpinLock

        xor     edx, edx                ; initialize return data length
        mov     ecx, ByteCount

        or      ecx, ecx                ; validate requested byte count
        jz      HalpSetCmosDataExit     ; if no work to do, exit

        mov     edx, SourceAddress
        mov     edi, ReturnBuffer

        mov     eax, SourceLocation     ; cmos or extended cmos?
        cmp     eax, 1
        je      ECmosWriteByte
        cmp     eax, 0
        jne     HalpSetCmosDataExit

CmosWriteByte:
        cmp     edx, 0ffH               ; validate cmos source address
        ja      HalpSetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     CmosAddressPort, al
        mov     al, [edi]
        out     CmosDataPort, al
        inc     edx
        inc     edi
        dec     ecx
        jnz     CmosWriteByte
        jmp     SHORT HalpSetCmosDataExit

ECmosWriteByte:
        cmp     edx,0ffffH              ; validate ecmos source address
        ja      HalpSetCmosDataExit     ; if out of range, exit
        mov     al, dl
        out     ECmosAddressLsbPort, al
        mov     al, dh
        out     ECmosAddressMsbPort, al
        mov     al, [edi]
        out     ECmosDataPort, al
        inc     edx
        inc     edi
        dec     ecx
        jnz     ECmosWriteByte

HalpSetCmosDataExit:
        stdCall _HalpReleaseCmosSpinLock

        mov     eax, edx                ; return bytes written
        sub     eax, SourceAddress      ; subtract the initial offset
        
        pop     edi
        pop     ebx
        pop     ebp

        stdRET    _HalpSetCmosData

stdENDP _HalpSetCmosData


        page ,132
        subttl  "Read System Time"
;++
;
; VOID
; HalpReadCmosTime (
;    PTIME_FIELDS TimeFields
;    )
;
; Routine Description:
;
;    This routine reads current time from CMOS memory and stores it
;    in the TIME_FIELDS structure passed in by caller.
;
; Arguments:
;
;    TimeFields - A pointer to the TIME_FIELDS structure.
;
; Return Value:
;
;    None.
;
;--

;
; Parameters:
;

KrctPTimeFields equ [esp+4]

cPublicProc _HalpReadCmosTime ,1

if DBG
krctwait0:
        mov     ecx, 100
krctwait:
        push    ecx
else
krctwait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
krct00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short krct10            ; if z, no, go read CMOS time
        loop    short krct00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short krctwait
        stdCall _DbgBreakPoint
        jmp     short krctwait0
else
        jmp     short krctwait
endif
        align   4
if DBG
krct10:
        pop     ecx
else
krct10:
endif
        mov     edx, KrctPTimeFields    ; (edx)-> TIME_FIELDS structure
        xor     eax, eax                ; (eax) = 0

        ;
        ; The RTC is only accurate within one second.  So
        ; add a half a second so that we are closer, on average,
        ; to the right answer.
        ;
        mov     word ptr [edx].TfMilliseconds, 500      ; add a half a second
        
        mov     al, RTC_OFFSET_SECOND
        CMOS_READ                       ; (al) = second in BCD form
        BCD_TO_BIN                      ; (ax) = second
        mov     [edx].TfSecond, ax      ; set second in TIME_FIELDS
        
        mov     al, RTC_OFFSET_MINUTE
        CMOS_READ                       ; (al) = minute in BCD form
        BCD_TO_BIN                      ; (ax) = Minute
        mov     [edx].TfMinute, ax      ; set minute in TIME_FIELDS

        mov     al, RTC_OFFSET_HOUR
        CMOS_READ                       ; (al) = hour in BCD form
        BCD_TO_BIN                      ; (ax) = Hour
        mov     [edx].TfHour, ax        ; set hour in TIME_FIELDS

        mov     al, RTC_OFFSET_DAY_OF_WEEK
        CMOS_READ                       ; (al) = day-of-week in BCD form
        BCD_TO_BIN                      ; (ax) = day-of-week
        mov     [edx].TfWeekday, ax     ; set Weekday in TIME_FIELDS

        mov     al, RTC_OFFSET_DATE_OF_MONTH
        CMOS_READ                       ; (al) = date-of-month in BCD form
        BCD_TO_BIN                      ; (ax) = date_of_month
        mov     [edx].TfDay, ax         ; set day in TIME_FIELDS

        mov     al, RTC_OFFSET_MONTH
        CMOS_READ                       ; (al) = month in BCD form
        BCD_TO_BIN                      ; (ax) = month
        mov     [edx].TfMonth, ax       ; set month in TIME_FIELDS

        mov     al, RTC_OFFSET_YEAR
        CMOS_READ                       ; (al) = year in BCD form
        BCD_TO_BIN                      ; (ax) = year
        push    eax                     ; save year in stack

        push    edx                     ; preserve edx
        call    _HalpGetCmosCenturyByte ; (al)= century byte in BCD form
        BCD_TO_BIN                      ; (ax) = century
        pop     edx

        mov     ah, 100
        mul     ah                      ; (ax) = century * 100
        pop     ecx                     ; (cx) = year
        add     ax, cx                  ; (ax)= year

        cmp     ax, 1900                ; Is year > 1900
        jb      short krct40
        cmp     ax, 1920                ; and < 1920
        jae     short krct40
        add     ax, 100                 ; Compensate for century field

krct40:
        mov     [edx].TfYear, ax        ; set year in TIME_FIELDS

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalpReadCmosTime

stdENDP _HalpReadCmosTime

        page ,132
        subttl  "Write System Time"
;++
;
; VOID
; HalpWriteCmosTime (
;    PTIME_FIELDS TimeFields
;    )
;
; Routine Description:
;
;    This routine writes current time from TIME_FILEDS structure
;    to CMOS memory.
;
; Arguments:
;
;    TimeFields - A pointer to the TIME_FIELDS structure.
;
; Return Value:
;
;    None.
;
;--

;
; Parameters:
;

KrctPTimeFields equ [esp+4]

cPublicProc _HalpWriteCmosTime ,1

if DBG
kwctwait0:
        mov     ecx, 100
kwctwait:
        push    ecx
else
kwctwait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
kwct00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short kwct10            ; if z, no, go write CMOS time
        loop    short kwct00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short kwctwait
        stdCall _DbgBreakPoint
        jmp     short kwctwait0
else
        jmp     short kwctwait
endif
        align   4
if DBG
kwct10:
        pop     ecx
else
kwct10:
endif
        mov     edx, KrctPTimeFields    ; (edx)-> TIME_FIELDS structure

        mov     al, [edx].TfSecond      ; Read second in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_SECOND
        CMOS_WRITE

        mov     al, [edx].TfMinute      ; Read minute in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MINUTE
        CMOS_WRITE

        mov     al, [edx].TfHour        ; Read Hour in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_HOUR
        CMOS_WRITE

        mov     al, [edx].TfWeekDay     ; Read WeekDay in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_DAY_OF_WEEK
        CMOS_WRITE

        mov     al, [edx].TfDay         ; Read day in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_DATE_OF_MONTH
        CMOS_WRITE

        mov     al, [edx].TfMonth       ; Read month in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MONTH
        CMOS_WRITE

        mov     ax, [edx].TfYear        ; Read Year in TIME_FIELDS
        cmp     ax, 9999
        jbe     short kwct15
        mov     ax, 9999

        align   4
kwct15:
        mov     cl, 100
        div     cl                      ; [ax]/[cl]->al=quo, ah=rem
        push    eax
        BIN_TO_BCD

        push    eax
        call    _HalpSetCmosCenturyByte

        pop     eax
        mov     al, ah                  ; [al] = Year
        BIN_TO_BCD
        mov     ah, al                  ; [ah] = year in BCD
        mov     al, RTC_OFFSET_YEAR
        CMOS_WRITE

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalpWriteCmosTime

stdENDP _HalpWriteCmosTime


;++
;
; Routine Description:
;
;   Acquires a spinlock to access the cmos chip. The cmos chip is
;   accessed at different irql levels, so to be safe, we 'cli'.
;   We could replace that to raise irql to PROFILE_LEVEL, but that's
;   a lot of code.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Interrupt is disabled.
;    Irql level not affected.
;    Flags saved in _HalpHardwareLockFlags.
;--

cPublicProc _HalpAcquireCmosSpinLock  ,0
public _HalpAcquireSystemHardwareSpinLock@0
_HalpAcquireSystemHardwareSpinLock@0:
        push    eax

Arsl10: pushfd
        cli
        lea     eax, _HalpSystemHardwareLock
        ACQUIRE_SPINLOCK    eax, Arsl20
        pop     _HalpHardwareLockFlags          ; save flags for release S.L.
        pop     eax
        stdRET    _HalpAcquireCmosSpinLock

Arsl20: popfd

Arsl30:
        YIELD
ifndef NT_UP
        cmp     _HalpRebootNow, 0
        jnz     short Arsl50
endif
        TEST_SPINLOCK       eax, <short Arsl30>
        jmp     short ARsl10

Arsl50:
ifndef NT_UP
        mov     eax, _HalpRebootNow
        call    eax
        int 3                                 ; should not return
endif

stdENDP _HalpAcquireCmosSpinLock


;++
;
; Routine Description:
;
;   Release spinlock, and restore flags to the state it was before
;   acquiring the spinlock.
;
; Arguments:
;
;   None
;
; Return Value:
;
;   Interrupts restored to their state before acquiring spinlock.
;   Irql level not affected.
;
;--

cPublicProc _HalpReleaseCmosSpinLock  ,0
public _HalpReleaseSystemHardwareSpinLock@0
_HalpReleaseSystemHardwareSpinLock@0:
        push    eax
        ;
        ; restore eflags as it was before acquiring spinlock. Put it on
        ; stack before releasing spinlock (so other cpus cannot overwrite
        ; it with their own eflags).
        ;
        push    _HalpHardwareLockFlags          ; old eflags on stack.
        lea     eax, _HalpSystemHardwareLock
        RELEASE_SPINLOCK    eax
        popfd                                   ; restore eflags.
        pop   eax
        stdRET    _HalpReleaseCmosSpinLock
stdENDP _HalpReleaseCmosSpinLock

;++
;
; UCHAR
; HalpGetCmosCenturyByte (
;    VOID
;    )
;
; Routine Description:
;
;    This routine gets Century byte from CMOS.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    (al) = Century byte in BCD form.
;
;--

cPublicProc _HalpGetCmosCenturyByte, 0

        mov     eax, _HalpCmosCenturyOffset

if DBG

;
; Make sure the HalpCmosCenturyOffset is initialized
;

        cmp     eax, 0
        jne     short @f

        int 3
@@:
endif
        test    eax, BANK1
        jnz     short rcb50

        CMOS_READ                       ; (al) = century in BCD form
        stdRET    _HalpGetCmosCenturyByte

rcb50:  mov     edx, eax

        mov     al, 0Ah
        CMOS_READ

        mov     dh, al                          ; save it for restore
        or      al, 10h                         ; Set DV0 = 1

        mov     ah, al
        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE

        mov     al, dl                          ; century offset
        CMOS_READ
        mov     dl, al                          ; save it

        mov     ah, dh                          ; Restore DV0
        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE

        mov     al, dl
        stdRET    _HalpGetCmosCenturyByte

stdENDP _HalpGetCmosCenturyByte


;++
;
; VOID
; HalpSetCmosCenturyByte (
;    UCHAR Century
;    )
;
; Routine Description:
;
;    This routine sets Century byte in CMOS.
;
; Arguments:
;
;    Century - Supplies the value for CMOS century byte
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpSetCmosCenturyByte, 1

        mov     eax, _HalpCmosCenturyOffset
if DBG

;
; Make sure the HalpCmosCenturyOffset is initialized
;

        cmp     eax, 0
        jne     short @f

        int 3
@@:
endif

        test    eax, BANK1
        jnz     short scb50

        mov     ah, [esp+4]             ; (ah) = Century in BCD form
        CMOS_WRITE
        stdRET    _HalpSetCmosCenturyByte


scb50:  mov     edx, eax

        mov     al, 0Ah
        CMOS_READ

        mov     dh, al                          ; save it for restore
        or      al, 10h                         ; Set DV0 = 1

        mov     ah, al
        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE

        mov     ah, [esp+4]                     ; (ah) = Century in BCD form
        mov     al, dl                          ; century offset
        CMOS_WRITE

        mov     ah, dh                          ; Restore DV0
        mov     al, 0Ah                         ; Write register A
        CMOS_WRITE
        stdRET    _HalpSetCmosCenturyByte

stdENDP _HalpSetCmosCenturyByte


;++
;
; VOID
; HalpCpuID (
;     ULONG   InEax,
;     PULONG  OutEax,
;     PULONG  OutEbx,
;     PULONG  OutEcx,
;     PULONG  OutEdx
;     );
;
; Routine Description:
;
;   Executes the CPUID instruction and returns the registers from it
;
;   Only available at INIT time
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _HalpCpuID,5

        push    ebx
        push    esi

        mov     eax, [esp+12]
        db      0fh, 0a2h       ; CPUID

        mov     esi, [esp+16]   ; return EAX
        mov     [esi], eax

        mov     esi, [esp+20]   ; return EBX
        mov     [esi], ebx

        mov     esi, [esp+24]   ; return ECX
        mov     [esi], ecx

        mov     esi, [esp+28]   ; return EDX
        mov     [esi], edx

        pop     esi
        pop     ebx

        stdRET  _HalpCpuID

stdENDP _HalpCpuID


;++
;
; VOID
; HalpFlushTLB (
;     VOID
;     );
;
; Routine Description:
;
;   Flush the current TLB.
;
; Arguments:
;
; Return Value:
;
;--
cPublicProc _HalpFlushTLB, 0
.586p
        pushfd
        push    ebx
        push    esi

        cli
        mov     esi, cr3

        mov     ecx, PCR[PcPrcb]
        cmp     byte ptr [ecx].PbCpuID, 0
        jz      short ftb50

        mov     eax, 1                  ; Get feature bits
        cpuid                           ; (note "cpuid" between CR3 reload fixes
                                        ; P6 B step errata #11)

        test    edx, 2000h              ; see if 'G' bit is supported
        jz      short ftb50

        mov     ecx, cr4                ; 'G' bit is supported, due global flush
        mov     edx, ecx                ; Save orginal cr4
        and     ecx, not CR4_PGE        ; Make sure global bit is disabled
        mov     cr4, ecx
        mov     cr3, esi                ; flush TLB
        mov     cr4, edx                ; restore cr4
        jmp     short ftp99

ftb50:  mov     cr3, esi

ftp99:  pop     esi
        pop     ebx
        popfd
        stdRET  _HalpFlushTLB

.486p
stdENDP _HalpFlushTLB

;++
;
; VOID
; HalpYieldProcessor (
;     VOID
;     );
;
; Routine Description:
;
; Arguments:
;
;       None
;
; Return Value:
;
;       None
;
;--
cPublicProc _HalpYieldProcessor
        YIELD
        stdRET  _HalpYieldProcessor
stdENDP _HalpYieldProcessor


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixfirm.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixreboot.c

Abstract:

    Provides the interface to the firmware for x86.  Since there is no
    firmware to speak of on x86, this is just reboot support.

Author:

    John Vert (jvert) 12-Aug-1991

Revision History:

--*/
#include "halp.h"
#include <inbv.h>

//
// Defines to let us diddle the CMOS clock and the keyboard
//

#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64

VOID  HalpVideoReboot(VOID);
VOID  HalpReboot(VOID);
#if defined(NEC_98)
BOOLEAN HalpPowerDownFlag;
#endif // defined(NEC_98)


VOID
HalReturnToFirmware(
    IN FIRMWARE_ENTRY Routine
    )

/*++

Routine Description:

    Returns control to the firmware routine specified.  Since the x86 has
    no useful firmware, it just stops the system.

Arguments:

    Routine - Supplies a value indicating which firmware routine to invoke.

Return Value:

    Does not return.

--*/

{
    switch (Routine) {
        case HalPowerDownRoutine:

#if defined(NEC_98)

            HalpPowerDownFlag = TRUE;

#endif // defined(NEC_98)

        case HalHaltRoutine:
        case HalRestartRoutine:
        case HalRebootRoutine:

            InbvAcquireDisplayOwnership();

            //
            // Never returns
            //

            HalpReboot();
            break;
        default:
            DbgPrint("HalReturnToFirmware called\n");
            DbgBreakPoint();
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixenvirv.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ixenvirv.c

Abstract:

    This module implements the HAL get and set environment variable routines
    for a x86 system.

    Note that this particular implementation only supports the LastKnownGood
    environment variable.  This is done by using the Daylight Savings Time
    bit in the Real Time Clock NVRAM.  (Not pretty, but it's all we've got)

    Attempts to read or write any environment variable other than
    LastKnownGood will fail.

Author:

    John Vert (jvert) 22-Apr-1992

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "arc.h"
#include "arccodes.h"
#include "string.h"

#define CMOS_CONTROL_PORT ((PUCHAR)0x70)
#define CMOS_DATA_PORT    ((PUCHAR)0x71)
#define CMOS_STATUS_B     0x0B
#define CMOS_DAYLIGHT_BIT 1

const UCHAR LastKnownGood[] = "LastKnownGood";
const UCHAR True[] = "TRUE";
const UCHAR False[] = "FALSE";


ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    )

/*++

Routine Description:

    This function locates an environment variable and returns its value.

    The only environment variable this implementation supports is
    "LastKnownGood"  It uses the Daylight Savings Time bit in the Real
    TimeClock to indicate the state (TRUE/FALSE only) of this environment
    variable.

Arguments:

    Variable - Supplies a pointer to a zero terminated environment variable
        name.

    Length - Supplies the length of the value buffer in bytes.

    Buffer - Supplies a pointer to a buffer that receives the variable value.

Return Value:

    ESUCCESS is returned if the enviroment variable is located. Otherwise,
    ENOENT is returned.

--*/

{
    UCHAR StatusByte;
    
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( Buffer );

    if (_stricmp(Variable, LastKnownGood) != 0) {
        return ENOENT;
    }

    //
    // Read the Daylight Savings Bit out of the RTC to determine whether
    // the LastKnownGood environment variable is TRUE or FALSE.
    //

    HalpAcquireCmosSpinLock();

    WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
    StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);

    
    HalpReleaseCmosSpinLock ();

    if (StatusByte & CMOS_DAYLIGHT_BIT) {
        strncpy(Buffer, True, Length);
    } else {
        strncpy(Buffer, False, Length);
    }

    return ESUCCESS;
}

ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Value
    )

/*++

Routine Description:

    This function creates an environment variable with the specified value.

    The only environment variable this implementation supports is
    "LastKnownGood"  It uses the Daylight Savings Time bit in the Real
    TimeClock to indicate the state (TRUE/FALSE only) of this environment
    variable.

Arguments:

    Variable - Supplies a pointer to an environment variable name.

    Value - Supplies a pointer to the environment variable value.

Return Value:

    ESUCCESS is returned if the environment variable is created. Otherwise,
    ENOMEM is returned.

--*/

{
    UCHAR StatusByte;
    
    if (_stricmp(Variable, LastKnownGood) != 0) {
        return ENOMEM;
    }

    if (_stricmp(Value, True) == 0) {

        HalpAcquireCmosSpinLock();

        //
        // Turn Daylight Savings Bit on.
        //
        WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
        StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);

        StatusByte |= CMOS_DAYLIGHT_BIT;

        WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
        WRITE_PORT_UCHAR(CMOS_DATA_PORT, StatusByte);

        
        HalpReleaseCmosSpinLock();

    } else if (_stricmp(Value, False) == 0) {

        HalpAcquireCmosSpinLock();

        //
        // Turn Daylight Savings Bit off.
        //

        WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
        StatusByte = READ_PORT_UCHAR(CMOS_DATA_PORT);

        StatusByte &= ~CMOS_DAYLIGHT_BIT;

        WRITE_PORT_UCHAR(CMOS_CONTROL_PORT, CMOS_STATUS_B);
        WRITE_PORT_UCHAR(CMOS_DATA_PORT, StatusByte);

        HalpReleaseCmosSpinLock();

    } else {
        return(ENOMEM);
    }

    return ESUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixhibrnt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixhibrnt.c

Abstract:

    This file provides the code that changes the system from
    the ACPI S0 (running) state to S4 (hibernated).

Author:

    Jake Oshins (jakeo) May 6, 1997

Revision History:

--*/
#include "halp.h"
#include "ntapm.h"
#include "ixsleep.h"

NTSTATUS
HalpRegisterPowerStateChange(
    PVOID   ApmSleepVectorArg,
    PVOID   ApmOffVectorArg
    );

NTSTATUS
HaliLegacyPowerStateChange(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

VOID
HalpPowerStateCallbackApm(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );

VOID (*ApmSleepVector)() = NULL;
VOID (*ApmOffVector)() = NULL;

extern BOOLEAN HalpDisableHibernate;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliInitPowerManagement)
#pragma alloc_text(PAGE, HalpRegisterHibernate)
#pragma alloc_text(PAGE, HalpPowerStateCallbackApm)
#pragma alloc_text(PAGE, HalpRegisterPowerStateChange)
#pragma alloc_text(PAGELK, HaliLegacyPowerStateChange)
#pragma alloc_text(PAGELK, HalpSaveInterruptControllerState)
#pragma alloc_text(PAGELK, HalpRestoreInterruptControllerState)
#endif


NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    )
{
    NTSTATUS    status = STATUS_SUCCESS;
    PVOID       ApmSleepVectorArg;
    PVOID       ApmOffVectorArg;

    if (PmDriverDispatchTable->Signature != HAL_APM_SIGNATURE) {
        return STATUS_INVALID_PARAMETER;
    }

    if (PmDriverDispatchTable->Version != HAL_APM_VERSION) {
        return STATUS_INVALID_PARAMETER;
    }

    ApmSleepVectorArg = PmDriverDispatchTable->Function[HAL_APM_SLEEP_VECTOR];
    ApmOffVectorArg = PmDriverDispatchTable->Function[HAL_APM_OFF_VECTOR];

    status = HalpRegisterPowerStateChange(
        ApmSleepVectorArg,
        ApmOffVectorArg
        );

    return status;
}

NTSTATUS
HalpRegisterPowerStateChange(
    PVOID   ApmSleepVectorArg,
    PVOID   ApmOffVectorArg
    )
/*++
Routine Description:

    This function registers HaliLegacyPowerStateChange for
    the S3, S4, and OFF vectors.

Arguments:

    PVOID   ApmSleepVectorArg - pointer to a function which
            when called invokes the APM suspend/sleep function.

    PVOID   ApmOffVectorArg - pointer to a function which
            when called invokes the APM code to shut off the machine.

--*/
{
    POWER_STATE_HANDLER powerState;
    OBJECT_ATTRIBUTES   objAttributes;
    PCALLBACK_OBJECT    callback;
    UNICODE_STRING      callbackName;
    NTSTATUS            status;

    PAGED_CODE();


    //
    // callbacks are set up for the hibernation case
    // at init, we just keep them.
    //


    //
    // Register the sleep3/suspend handler
    //
    if (ApmSleepVectorArg != NULL) {
        powerState.Type = PowerStateSleeping3;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliLegacyPowerStateChange;
        powerState.Context = (PVOID)PowerStateSleeping3;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);

        if (!NT_SUCCESS(status)) {
            return status;
        }
    }


    //
    // Register the OFF handler.
    //

    powerState.Type = PowerStateShutdownOff;
    powerState.RtcWake = FALSE;
    powerState.Handler = &HaliLegacyPowerStateChange;
    powerState.Context = (PVOID)PowerStateShutdownOff;

    status = ZwPowerInformation(SystemPowerStateHandler,
                                &powerState,
                                sizeof(POWER_STATE_HANDLER),
                                NULL,
                                0);

    if (!NT_SUCCESS(status)) {
        //
        // n.b. We will return here with two vectors (sleep & hibernate) left in place.
        //
        return status;
    }

    ApmSleepVector = ApmSleepVectorArg;
    ApmOffVector = ApmOffVectorArg;

    return status;
}

VOID
HalpRegisterHibernate(
    VOID
    )
/*++
Routine Description:

    This function registers a hibernation handler (for
    state S4) with the Policy Manager.

Arguments:

--*/
{
    POWER_STATE_HANDLER powerState;
    OBJECT_ATTRIBUTES   objAttributes;
    PCALLBACK_OBJECT    callback;
    UNICODE_STRING      callbackName;

    PAGED_CODE();


    //
    // Register callback that tells us to make
    // anything we need for sleeping non-pageable.
    //

    RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &objAttributes,
        &callbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );

    ExCreateCallback(&callback,
                     &objAttributes,
                     FALSE,
                     TRUE);

    ExRegisterCallback(callback,
                       (PCALLBACK_FUNCTION)&HalpPowerStateCallbackApm,
                       NULL);

    //
    // Register the hibernation handler.
    //

    if (HalpDisableHibernate == FALSE) {
        powerState.Type = PowerStateSleeping4;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliLegacyPowerStateChange;
        powerState.Context = (PVOID)PowerStateSleeping4;
    
        ZwPowerInformation(SystemPowerStateHandler,
                           &powerState,
                           sizeof(POWER_STATE_HANDLER),
                           NULL,
                           0);
    }

    return;
}

VOID
HalpPowerStateCallbackApm(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
{
    ULONG   action = (ULONG)Argument1;
    ULONG   state  = (ULONG)Argument2;

    if (action == PO_CB_SYSTEM_STATE_LOCK) {

        switch (state) {
        case 0:                 // lock down everything that can't page during sleep

            HalpSleepPageLock = MmLockPagableCodeSection((PVOID)HaliLegacyPowerStateChange);

            break;

        case 1:                 // unlock it all

            MmUnlockPagableImageSection(HalpSleepPageLock);
        }
    }
}

NTSTATUS
HaliLegacyPowerStateChange(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
/*++
Routine Description:

    This function calls out to code in a driver supplied
    wrapper function that will call off to APM to sleep==suspend,
    or power off (for either hibernate or system off)

    It is also called for hibernate when no driver supplied callout
    is available, in which case it makes the system ready so we
    can print a message and tell the user to manually power off the box.

Arguments:

--*/
{
    extern ULONG HalpProfilingStopped;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT( (Context == (PVOID)PowerStateSleeping3) ||
            (Context == (PVOID)PowerStateSleeping4) ||
            (Context == (PVOID)PowerStateShutdownOff));

    ASSERT ( (ApmOffVector != NULL) || (SystemHandler != NULL) );

    //
    // Save motherboard state.
    //
    HalpSaveInterruptControllerState();

    HalpSaveDmaControllerState();

    HalpSaveTimerState();

    if (SystemHandler) {

        status = SystemHandler(SystemContext);

        //
        // System handler is present.  If it return success,
        // then all out to APM bios
        //
        if ((status == STATUS_SUCCESS) ||
            (status == STATUS_DEVICE_DOES_NOT_EXIST)) {

            if (Context == (PVOID)PowerStateSleeping3) {
                if (ApmSleepVector) {
                    ApmSleepVector();
                } else {
                    //
                    // this is expected path for odd operation,
                    // caller will do something rational.
                    //
                    return STATUS_DEVICE_DOES_NOT_EXIST;
                }
            } else {

                //
                // The ApmOffVector provides the means to turn
                // off the machine.  If the hibernation handler
                // returned STATUS_DEVICE_DOES_NOT_EXIST, however,
                // we don't want to turn the machine off, we want
                // to reset it.
                //

                if (ApmOffVector &&
                    !(status == STATUS_DEVICE_DOES_NOT_EXIST)) {

                    //
                    // This function should never return.  The
                    // machine should be off.  But if this actually
                    // does return, just fall through, as the return
                    // code will cause the message to turn off the
                    // machine to be displayed.
                    //
                    ApmOffVector();
                }

                //
                // this is expected case for old non-apm machines,
                // caller will respond to this by putting up
                // message telling user to turn off the box.
                // (for either shutdown or hibernate)
                //
                return STATUS_DEVICE_DOES_NOT_EXIST;
            }
        }
    } else {

        //
        // there is no system handler, so just call out
        // to the bios
        //
        if (Context == (PVOID)PowerStateSleeping3) {
            if (ApmSleepVector) {
                ApmSleepVector();
            } else {
                //
                // we're whistling in the wind here, we're
                // really probably hosed if this happens, but
                // this return is better than randomly puking.
                //
                return STATUS_DEVICE_DOES_NOT_EXIST;
            }
        } else {
            if (ApmOffVector) {
                ApmOffVector();
                //
                // if we are right here, we have *returned*
                // from Off, which should never happen.
                // so report failure so the caller will tell the
                // user to turn the box off manually.
                //
                return STATUS_DEVICE_DOES_NOT_EXIST;

            } else {
                //
                // same as right above
                //
                return STATUS_DEVICE_DOES_NOT_EXIST;
            }
        }
    }

    //
    // Restore motherboard state.
    //
    HalpRestoreInterruptControllerState();

    HalpRestoreDmaControllerState();

    HalpRestoreTimerState();


    if (HalpProfilingStopped == 0) {
        HalStartProfileInterrupt(0);
    }

    return status;
}

VOID
HalpSaveInterruptControllerState(
    VOID
    )
{
    HalpSavePicState();
}
VOID
HalpRestoreInterruptControllerState(
    VOID
    )
{
    HalpRestorePicState();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixhwsup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "halpnpp.h"
#include "eisa.h"

#define COMMON_BUFFER_ALLOCATION_ATTEMPTS 5


#ifdef ACPI_HAL
//
// Interface to the F-type control methods
//
extern ISA_FTYPE_DMA_INTERFACE HalpFDMAInterface;
#endif

#define HAL_WCB_DRIVER_BUFFER    1

typedef struct _HAL_WAIT_CONTEXT_BLOCK {
    ULONG Flags;
    PMDL Mdl;
    PMDL DmaMdl;
    PVOID MapRegisterBase;
    PVOID CurrentVa;
    ULONG Length;
    ULONG NumberOfMapRegisters;
    union {
        struct {
            WAIT_CONTEXT_BLOCK Wcb;
            PDRIVER_LIST_CONTROL DriverExecutionRoutine;
            PVOID DriverContext;
            PIRP CurrentIrp;
            PADAPTER_OBJECT AdapterObject;
            BOOLEAN WriteToDevice;
        };

        SCATTER_GATHER_LIST ScatterGather;
    };
} HAL_WAIT_CONTEXT_BLOCK, *PHAL_WAIT_CONTEXT_BLOCK;

//
// Due to Intel chipset bugs, we can only do
// certain processor power management functions
// when there is no DMA traffic.  So we need to
// know.  The nature of the bug (in the PIIX4)
// chip is such that we really only care about
// transactions from the IDE controller in PIIX4.
// And it uses the scatter/gather functions.
//
// Only the UP acpi hals require this value to be
// tracked.
//

LONG HalpOutstandingScatterGatherCount = 0;

extern KSPIN_LOCK HalpDmaAdapterListLock;
extern LIST_ENTRY HalpDmaAdapterList;

HALP_MOVE_MEMORY_ROUTINE HalpMoveMemory = RtlMoveMemory;

#if defined(TRACK_SCATTER_GATHER_COUNT)

#define INCREMENT_SCATTER_GATHER_COUNT() \
        InterlockedIncrement(&HalpOutstandingScatterGatherCount)
#define DECREMENT_SCATTER_GATHER_COUNT() \
        InterlockedDecrement(&HalpOutstandingScatterGatherCount)

#else

#define INCREMENT_SCATTER_GATHER_COUNT()
#define DECREMENT_SCATTER_GATHER_COUNT()

#endif

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    );

IO_ALLOCATION_ACTION
HalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

static KSPIN_LOCK HalpReservedPageLock;
static PVOID      HalpReservedPages = NULL;
static PFN_NUMBER HalpReservedPageMdl[(sizeof(MDL)/sizeof(PFN_NUMBER)) + 2];


VOID
HalpInitReservedPages(
    VOID
    )
/*++

Routine Description:

    Initalize the data structures necessary to continue DMA
    during low memory conditions

Aruments:

    None

Reurn Value:

    None

--*/
{
    PMDL Mdl;

    HalpReservedPages = MmAllocateMappingAddress(PAGE_SIZE, HAL_POOL_TAG);

    ASSERT(HalpReservedPages);

    Mdl = (PMDL)&HalpReservedPageMdl;
    MmInitializeMdl(Mdl, NULL, PAGE_SIZE);
    Mdl->MdlFlags |= MDL_PAGES_LOCKED;

    KeInitializeSpinLock(&HalpReservedPageLock);
}


VOID
HalpCopyBufferMapSafe(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This routine copies the specific data between an unmapped user buffer
    and the map register buffer.  We will map and unmap each page of the
    transfer using our emergency reserved mapping

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
          being read or written.

    TranslationEntry - The address of the base map register that has been
                       allocated to the device driver for use in mapping
                       the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
                that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None

--*/
{
    PCCHAR bufferAddress;
    PCCHAR mapAddress;
    ULONG bytesLeft;
    ULONG bytesThisCopy;
    ULONG bufferPageOffset;
    PTRANSLATION_ENTRY translationEntry;
    KIRQL Irql;
    PMDL ReserveMdl;
    MEMORY_CACHING_TYPE MCFlavor;
    PPFN_NUMBER SrcPFrame;
    PPFN_NUMBER ReservePFrame;

    //
    // Synchronize access to our reserve page data structures
    //
    KeAcquireSpinLock(&HalpReservedPageLock, &Irql);

    //
    // Get local copies of Length and TranslationEntry as they will be
    // decremented/incremented respectively
    //
    bytesLeft = Length;
    translationEntry = TranslationEntry;

    //
    // Find the PFN in our caller's MDL that describes the first page in
    // physical memory that we need to access
    //
    SrcPFrame = MmGetMdlPfnArray(Mdl);
    SrcPFrame += ((ULONG_PTR)CurrentVa - (ULONG_PTR)MmGetMdlBaseVa(Mdl)) >>
        PAGE_SHIFT;

    //
    // Initialize our reserve MDL's StartVa and ByteOffset
    //
    ReserveMdl = (PMDL)&HalpReservedPageMdl;
    ReservePFrame = MmGetMdlPfnArray(ReserveMdl);
    ReserveMdl->StartVa = (PVOID)PAGE_ALIGN(CurrentVa);
    ReserveMdl->ByteOffset = BYTE_OFFSET(CurrentVa);
    ReserveMdl->ByteCount = PAGE_SIZE - ReserveMdl->ByteOffset;

    //
    // Copy the data one translation entry at a time
    //
    while (bytesLeft > 0) {

        //
        // Copy current source PFN into our reserve MDL
        //      
        *ReservePFrame = *SrcPFrame;

        //
        // Enumerate thru cache flavors until we get our reserve mapping
        //
        bufferAddress = NULL;
        for (MCFlavor = MmNonCached;
             MCFlavor < MmMaximumCacheType;
             MCFlavor++) {
            
            bufferAddress =
                MmMapLockedPagesWithReservedMapping(HalpReservedPages,
                                                    HAL_POOL_TAG,
                                                    ReserveMdl,
                                                    MCFlavor);
            if (bufferAddress != NULL) {
                break;
            }
        }
        
        //
        // Could not establish a reserve mapping, we're totally screwed!
        //
        if (bufferAddress == NULL) {
            KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                         PAGE_SIZE,
                         0xEF02,
                         (ULONG_PTR)__FILE__,
                         __LINE__
                         );
        }

        //
        // Find the buffer offset within the page
        //
        // N.B. bufferPageOffset can only be non-zero on the first iteration
        // 
        bufferPageOffset = BYTE_OFFSET(bufferAddress);

        //
        // Copy from bufferAddress up to the next page boundary...
        //
        bytesThisCopy = PAGE_SIZE - bufferPageOffset;

        //
        // ...but no more than bytesLeft
        //
        if (bytesThisCopy > bytesLeft) {
            bytesThisCopy = bytesLeft;
        }

        //
        // Calculate the base address of this translation entry and the
        // offset into it.
        //
        mapAddress = (PCCHAR) translationEntry->VirtualAddress +
            bufferPageOffset;

        //
        // Copy up to one page
        // 
        if (WriteToDevice) {
            HalpMoveMemory( mapAddress, bufferAddress, bytesThisCopy );

        } else {
            RtlCopyMemory( bufferAddress, mapAddress, bytesThisCopy );
        }

        //
        // Update locals and process the next translation entry.
        //
        bytesLeft -= bytesThisCopy;
        translationEntry += 1;
        MmUnmapReservedMapping(HalpReservedPages, HAL_POOL_TAG, ReserveMdl);
        SrcPFrame++;
        ReserveMdl->ByteOffset = 0;
        (PCCHAR)ReserveMdl->StartVa += PAGE_SIZE;
        ReserveMdl->ByteCount = (PAGE_SIZE > bytesLeft) ? bytesLeft: PAGE_SIZE;
    }
    
    KeReleaseSpinLock(&HalpReservedPageLock, Irql);
}


VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This routine copies the specific data between the user's buffer and the
    map register buffer.  First a the user buffer is mapped if necessary, then
    the data is copied.  Finally the user buffer will be unmapped if
    necessary.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    TranslationEntry - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None.

--*/
{
    PCCHAR bufferAddress;
    PCCHAR mapAddress;
    ULONG bytesLeft;
    ULONG bytesThisCopy;
    ULONG bufferPageOffset;
    PTRANSLATION_ENTRY translationEntry;
    NTSTATUS Status;

    //
    // Get the system address of the MDL, if we run out of PTEs try safe
    // method
    //
    bufferAddress = MmGetSystemAddressForMdlSafe(Mdl, HighPagePriority);
    
    if (bufferAddress == NULL) {
        
        //
        // Our caller's buffer is unmapped, and the memory manager is out
        // of PTEs, try to use reserve page method
        //
        if (HalpReservedPages != NULL) {
            HalpCopyBufferMapSafe(Mdl,
                                  TranslationEntry,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice);
            return;
        }

        //
        // The DMA transfer cannot be completed, the system is now unstable
        //
        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     PAGE_SIZE,
                     0xEF01,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    //
    // Calculate the actual start of the buffer based on the system VA and
    // the current VA.
    //

    bufferAddress += (PCCHAR) CurrentVa - (PCCHAR) MmGetMdlVirtualAddress(Mdl);

    //
    // Get local copies of Length and TranslationEntry as they will be
    // decremented/incremented respectively.
    //

    bytesLeft = Length;
    translationEntry = TranslationEntry;

    //
    // Copy the data one translation entry at a time.
    //

    while (bytesLeft > 0) {

        //
        // Find the buffer offset within the page.
        //
        // N.B. bufferPageOffset can only be non-zero on the first iteration.
        // 

        bufferPageOffset = BYTE_OFFSET(bufferAddress);

        //
        // Copy from bufferAddress up to the next page boundary...
        //

        bytesThisCopy = PAGE_SIZE - bufferPageOffset;

        //
        // ...but no more than bytesLeft.
        //

        if (bytesThisCopy > bytesLeft) {
            bytesThisCopy = bytesLeft;
        }

        //
        // Calculate the base address of this translation entry and the
        // offset into it.
        //

        mapAddress = (PCCHAR) translationEntry->VirtualAddress +
            bufferPageOffset;

        //
        // Copy up to one page.
        // 

        if (WriteToDevice) {

            HalpMoveMemory( mapAddress, bufferAddress, bytesThisCopy );

        } else {

            RtlCopyMemory( bufferAddress, mapAddress, bytesThisCopy );

        }

        //
        // Update locals and process the next translation entry.
        //

        bytesLeft -= bytesThisCopy;
        bufferAddress += bytesThisCopy;
        translationEntry += 1;
    }
}

PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function allocates the memory for a common buffer and maps it so that
    it can be accessed by a master device and the CPU.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
                    device.

    Length - Supplies the length of the common buffer to be allocated.

    LogicalAddress - Returns the logical address of the common buffer.

    CacheEnable - Indicates whether the memeory is cached or not.

Return Value:

    Returns the virtual address of the common buffer.  If the buffer cannot be
    allocated then NULL is returned.

--*/

{
    PSINGLE_LIST_ENTRY virtualAddress;
    PHYSICAL_ADDRESS minPhysicalAddress;
    PHYSICAL_ADDRESS maxPhysicalAddress;
    PHYSICAL_ADDRESS logicalAddress;
    PHYSICAL_ADDRESS boundaryPhysicalAddress;
    ULONGLONG boundaryMask;

    UNREFERENCED_PARAMETER( CacheEnabled );

    //
    // Determine the maximum physical address that this adapter can handle.
    //

    minPhysicalAddress.QuadPart = 0;
    maxPhysicalAddress = HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

    //
    // Determine the boundary mask for this adapter.
    //

    if (HalpBusType != MACHINE_TYPE_ISA ||
        AdapterObject->MasterDevice != FALSE) {

        //
        // This is not an ISA system.  The buffer must not cross a 4GB boundary.
        // It is predicted that most adapters are incapable of reliably
        // transferring across a 4GB boundary.
        //

        boundaryPhysicalAddress.QuadPart = 0x0000000100000000;
        boundaryMask = 0xFFFFFFFF00000000;

    } else {

        //
        // This is an ISA system the common buffer cannot cross a 64K boundary.
        //

        boundaryPhysicalAddress.QuadPart = 0x10000;
        boundaryMask = 0xFFFFFFFFFFFF0000;
    }

    //
    // Allocate a contiguous buffer.
    //

    virtualAddress = MmAllocateContiguousMemorySpecifyCache(
                        Length,
                        minPhysicalAddress,
                        maxPhysicalAddress,
                        boundaryPhysicalAddress,
                        MmCached );

    if (virtualAddress != NULL) {

        //
        // Got a buffer, get the physical/logical address and see if it
        // meets our conditions.
        //
    
        logicalAddress = MmGetPhysicalAddress( virtualAddress );

#if DBG
        ASSERT (((logicalAddress.QuadPart ^
             (logicalAddress.QuadPart + Length - 1)) & boundaryMask) == 0);
#endif
    
        *LogicalAddress = logicalAddress;
    }

    return virtualAddress;
}

BOOLEAN
HalFlushCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    This function is called to flush any hardware adapter buffers when the
    driver needs to read data written by an I/O master device to a common
    buffer.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

    Length - Supplies the length of the common buffer. This should be the same
        value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
        must be the same value return by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
        must be the same value return by HalAllocateCommonBuffer.

Return Value:

    Returns TRUE if no errors were detected.  Otherwise, FALSE is returned.

--*/

{
    UNREFERENCED_PARAMETER( AdapterObject );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LogicalAddress );
    UNREFERENCED_PARAMETER( VirtualAddress );

    return(TRUE);

}

VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function frees a common buffer and all of the resources it uses.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

    Length - Supplies the length of the common buffer. This should be the same
        value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
        must be the same value returned by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
        must be the same value returned by HalAllocateCommonBuffer.

    CacheEnable - Indicates whether the memory is cached or not.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( AdapterObject );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LogicalAddress );
    UNREFERENCED_PARAMETER( CacheEnabled );

    MmFreeContiguousMemory (VirtualAddress);

}

NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    )
/*++

Routine Description:

    This routine calculates the size of the scatter/gather list that
    needs to be allocated for a given virtual address range or MDL.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PMDL TempMdl;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    PUCHAR MdlVa;
    NTSTATUS Status;
    PULONG PageFrame;
    ULONG PageOffset;

    if (ARGUMENT_PRESENT(Mdl)) {
        MdlVa = MmGetMdlVirtualAddress(Mdl);

        //
        // Calculate the number of required map registers.
        //

        TempMdl = Mdl;
        TransferLength =
            TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
        MdlLength = TransferLength;

        PageOffset = BYTE_OFFSET(CurrentVa);
        NumberOfMapRegisters = 0;

        //
        // The virtual address should fit in the first MDL.
        //

        ASSERT((ULONG)((PUCHAR)CurrentVa - MdlVa) <= TempMdl->ByteCount);

        //
        // Loop through the any chained MDLs accumulating the the required
        // number of map registers.
        //

        while (TransferLength < Length && TempMdl->Next != NULL) {

            NumberOfMapRegisters += (PageOffset + MdlLength + PAGE_SIZE - 1) >>
                                        PAGE_SHIFT;

            TempMdl = TempMdl->Next;
            PageOffset = TempMdl->ByteOffset;
            MdlLength = TempMdl->ByteCount;
            TransferLength += MdlLength;
        }

        if ((TransferLength + PAGE_SIZE) < (Length + PageOffset )) {
            ASSERT(TransferLength >= Length);
            return(STATUS_BUFFER_TOO_SMALL);
        }

        //
        // Calculate the last number of map registers based on the requested
        // length not the length of the last MDL.
        //

        ASSERT( TransferLength <= MdlLength + Length );

        NumberOfMapRegisters += (PageOffset + Length + MdlLength - TransferLength +
                                 PAGE_SIZE - 1) >> PAGE_SHIFT;


        if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

    } else {

        //
        // Determine the number of pages required to map the buffer described
        // by CurrentVa and Length.
        //

        NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length);
    }

    //
    // Calculate how much memory is required for the context structure.
    //

    ContextSize = NumberOfMapRegisters * sizeof( SCATTER_GATHER_ELEMENT ) +
                  sizeof( SCATTER_GATHER_LIST );

    //
    // If the adapter does not need map registers then most of this code
    // can be bypassed.  Just build the scatter/gather list and give it
    // to the caller.
    //

    if (AdapterObject->NeedsMapRegisters) {

        ContextSize += FIELD_OFFSET( HAL_WAIT_CONTEXT_BLOCK, ScatterGather );
        if (ContextSize < sizeof( HAL_WAIT_CONTEXT_BLOCK )) {
            ContextSize = sizeof( HAL_WAIT_CONTEXT_BLOCK );
        }
    }

    //
    // Return the list size.
    //

    *ScatterGatherListSize = ContextSize;
    if (pNumberOfMapRegisters) {
        *pNumberOfMapRegisters = NumberOfMapRegisters;
    }

    return( STATUS_SUCCESS );
}


NTSTATUS
HalGetScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    )
{
    return (HalBuildScatterGatherList(AdapterObject,
                              DeviceObject,
                              Mdl,
                              CurrentVa,
                              Length,
                              ExecutionRoutine,
                              Context,
                              WriteToDevice,
                              NULL,
                              0
                              ));
}

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter
    object.  Next a scatter/gather list is built based on the MDL, the
    CurrentVa and the requested Length.  Finally the driver's execution
    function is called with the scatter/gather list.  The adapter is
    released when after the execution function returns.

    The scatter/gather list is allocated if a buffer is not passed and is 
    freed by calling PutScatterGatherList.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

    The data in the buffer cannot be accessed until the put scatter/gather function has been called.

--*/

{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PMDL TempMdl;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    PUCHAR MdlVa;
    NTSTATUS Status;
    PPFN_NUMBER PageFrame;
    ULONG PageOffset;

    if (!Mdl) {
        return (STATUS_INVALID_PARAMETER);
    }

    Status = HalCalculateScatterGatherListSize(AdapterObject,
                                                  Mdl,
                                                  CurrentVa,
                                                  Length,
                                                  &ContextSize,
                                                  &NumberOfMapRegisters 
                                                  );
    if (!NT_SUCCESS(Status)) {
        return (Status);
    }

    //
    // If the adapter does not need map registers then most of this code
    // can be bypassed.  Just build the scatter/gather list and give it
    // to the caller.
    //

    INCREMENT_SCATTER_GATHER_COUNT();

    if (!AdapterObject->NeedsMapRegisters) {

        if (ScatterGatherBuffer) {

            if (ScatterGatherBufferLength < ContextSize) {
                DECREMENT_SCATTER_GATHER_COUNT();
                return (STATUS_BUFFER_TOO_SMALL);
            }

            ScatterGather = ScatterGatherBuffer;

        } else {

            ScatterGather = ExAllocatePoolWithTag( NonPagedPool,
                                                   ContextSize,
                                                   HAL_POOL_TAG );
            if (ScatterGather == NULL) {
                DECREMENT_SCATTER_GATHER_COUNT();
                return( STATUS_INSUFFICIENT_RESOURCES );
            }
        }

        MdlVa = MmGetMdlVirtualAddress(Mdl);

        ScatterGather->Reserved = 0;

        Element = ScatterGather->Elements;
        TempMdl = Mdl;
        TransferLength = Length;
        MdlLength = TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
        PageOffset = BYTE_OFFSET(CurrentVa);

        //
        // Calculate where to start in the MDL.
        //

        PageFrame = MmGetMdlPfnArray(TempMdl);
        PageFrame += ((ULONG_PTR) CurrentVa - ((ULONG_PTR) MdlVa & ~(PAGE_SIZE - 1)))
                        >> PAGE_SHIFT;

        //
        // Loop build the list for each MDL.
        //

        while (TransferLength >  0) {

            if (MdlLength > TransferLength) {

                MdlLength = TransferLength;
            }

            TransferLength -= MdlLength;

            //
            // Loop building the list for the elements within the MDL.
            //

            while (MdlLength > 0) {

                //
                // Compute the starting address of the transfer.
                //

                Element->Address.QuadPart =
                    ((ULONGLONG)*PageFrame << PAGE_SHIFT) + PageOffset;

                Element->Length = PAGE_SIZE - PageOffset;

                if (Element->Length  > MdlLength ) {

                    Element->Length  = MdlLength;
                }

                ASSERT( (ULONG) MdlLength >= Element->Length );
                MdlLength -= Element->Length;

                //
                // Combine contiguous pages.
                //

                if (Element != ScatterGather->Elements ) {

                    if (Element->Address.QuadPart ==
                        (Element - 1)->Address.QuadPart + (Element - 1)->Length) {

                        //
                        // Add the new length to the old length.
                        //

                        (Element - 1)->Length += Element->Length;

                        //
                        // Reuse the current element.
                        //

                        Element--;
                    }
                }

                PageOffset = 0;
                Element++;
                PageFrame++;
            }


            if (TempMdl->Next == NULL) {

                //
                // There are a few cases where the buffer described by the MDL
                // is less than the transfer length.  This occurs when the
                // file system is transfering the last page of the file and
                // MM defines the MDL to be the file size and the file system
                // rounds the write up to a sector.  This extra should never
                // cross a page boundary.  Add this extra to the length of
                // the last element.
                //

                ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
                (Element - 1)->Length += TransferLength;

                break;
            }

            //
            // Advance to the next MDL.  Update the current VA and the MdlLength.
            //

            TempMdl = TempMdl->Next;
            PageOffset = MmGetMdlByteOffset(TempMdl);
            MdlLength = TempMdl->ByteCount;
            PageFrame = MmGetMdlPfnArray(TempMdl);

        }

        //
        // Set the number of elements actually used.
        //

        ScatterGather->NumberOfElements = Element - ScatterGather->Elements;
        if (ScatterGatherBuffer) {
            ScatterGather->Reserved = HAL_WCB_DRIVER_BUFFER;
        }
        
        //
        // Call the driver with the scatter/gather list.
        //

        ExecutionRoutine( DeviceObject,
                          DeviceObject->CurrentIrp,
                          ScatterGather,
                          Context );
        
        return STATUS_SUCCESS;

    }

    if (ScatterGatherBuffer) {

        if (ScatterGatherBufferLength < ContextSize) {
            DECREMENT_SCATTER_GATHER_COUNT();
            return (STATUS_BUFFER_TOO_SMALL);
        }

        WaitBlock = ScatterGatherBuffer;

    } else {
        WaitBlock = ExAllocatePoolWithTag(NonPagedPool, ContextSize, HAL_POOL_TAG);

        if (WaitBlock == NULL) {
            DECREMENT_SCATTER_GATHER_COUNT();
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }

    //
    // Save the interesting data in the wait block.
    //

    if (ScatterGatherBuffer) {
        WaitBlock->Flags |= HAL_WCB_DRIVER_BUFFER;
    } else {
        WaitBlock->Flags = 0;
    }

    WaitBlock->Mdl = Mdl;
    WaitBlock->DmaMdl = NULL;
    WaitBlock->CurrentVa = CurrentVa;
    WaitBlock->Length = Length;
    WaitBlock->DriverExecutionRoutine = ExecutionRoutine;
    WaitBlock->DriverContext = Context;
    WaitBlock->AdapterObject = AdapterObject;
    WaitBlock->WriteToDevice = WriteToDevice;
    WaitBlock->NumberOfMapRegisters = NumberOfMapRegisters;

    WaitBlock->Wcb.DeviceContext = WaitBlock;
    WaitBlock->Wcb.DeviceObject = DeviceObject;
    WaitBlock->Wcb.CurrentIrp = DeviceObject->CurrentIrp;


    //
    // Call the HAL to allocate the adapter channel.
    // HalpAllocateAdapterCallback will fill in the scatter/gather list.
    //

    Status = HalAllocateAdapterChannel( AdapterObject,
                                        &WaitBlock->Wcb,
                                        NumberOfMapRegisters,
                                        HalpAllocateAdapterCallback );

    //
    // If HalAllocateAdapterChannel failed then free the wait block.
    //

    if (!NT_SUCCESS( Status)) {
        DECREMENT_SCATTER_GATHER_COUNT();
        ExFreePool( WaitBlock );
    }

    return( Status );
}

VOID
HalPutScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This function frees the map registers allocated for the scatter gather list. It can also free the 
    scatter gather buffer and any associated MDLs.

Arguments:

    ScatterGather - The scatter gather buffer

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.
    

Return Value:

    Returns a success or error status.

--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    PTRANSLATION_ENTRY TranslationEntry;
    ULONG TransferLength;
    ULONG MdlLength;
    PMDL Mdl;
    PMDL tempMdl;
    PMDL nextMdl;
    PUCHAR CurrentVa;

    DECREMENT_SCATTER_GATHER_COUNT();

    //
    // If the reserved field was empty then just free the list and return.
    //

    if (WaitBlock == NULL) {

        ASSERT(!AdapterObject->NeedsMapRegisters);
        ExFreePool( ScatterGather );
        return;

    }

    if (WaitBlock == (PVOID)HAL_WCB_DRIVER_BUFFER) {
        ASSERT(!AdapterObject->NeedsMapRegisters);
        return;
    }

    ASSERT( WaitBlock == CONTAINING_RECORD( ScatterGather, HAL_WAIT_CONTEXT_BLOCK, ScatterGather ));

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used MDL.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;

#if DBG
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    if (MmGetMdlVirtualAddress(Mdl) < (PVOID)((PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount )) {

        ASSERT( CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );
    }
#endif

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));
    TransferLength = WaitBlock->Length;

    TranslationEntry = WaitBlock->MapRegisterBase;

    //
    // Loop through the used MDLs, calling IoFlushAdapterBuffers.
    //

    while (TransferLength >  0) {

        //
        // Do not perform a flush for buffers of zero length.
        //

        if (MdlLength > 0) {

            if (MdlLength > TransferLength) {
    
                MdlLength = TransferLength;
            }
    
            TransferLength -= MdlLength;
    
            IoFlushAdapterBuffers(  AdapterObject,
                                    Mdl,
                                    TranslationEntry,
                                    CurrentVa,
                                    MdlLength,
                                    WriteToDevice );
    
            TranslationEntry += ADDRESS_AND_SIZE_TO_SPAN_PAGES( CurrentVa,
                                                                MdlLength );
        }

        if (Mdl->Next == NULL) {
            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
    }

    IoFreeMapRegisters( AdapterObject,
                        WaitBlock->MapRegisterBase,
                        WaitBlock->NumberOfMapRegisters
                        );

    if (WaitBlock->DmaMdl) {
        tempMdl = WaitBlock->DmaMdl;
        while (tempMdl) {
            nextMdl = tempMdl->Next;

            //
            // If the MDL was mapped by the driver unmap it here.
            //

            if (tempMdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) {
                MmUnmapLockedPages(tempMdl->MappedSystemVa, tempMdl);
            }

            IoFreeMdl(tempMdl);
            tempMdl = nextMdl;
        }
    }

    if (!(WaitBlock->Flags & HAL_WCB_DRIVER_BUFFER)) {
        ExFreePool( WaitBlock );
    }
}

IO_ALLOCATION_ACTION
HalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the adapter object and map registers are
    available for the data transfer. This routines saves the map register
    base away.  If all of the required bases have not been saved then it
    returns. Otherwise it routine builds the entire scatter/gather
    list by calling IoMapTransfer.  After the list is built it is passed to
    the driver.

Arguments:

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Irp - Supplies the map register offset assigned for this callback.

    MapRegisterBase - Supplies the map register base for use by the adapter
        routines.

    Context - Supplies a pointer to the xhal wait contorl block.

Return Value:

    Returns DeallocateObjectKeepRegisters.


--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = Context;
    ULONG TransferLength;
    LONG MdlLength;
    PMDL Mdl;
    PUCHAR CurrentVa;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    PTRANSLATION_ENTRY TranslationEntry = MapRegisterBase;
    PTRANSLATION_ENTRY NextEntry;
    PDRIVER_LIST_CONTROL DriverExecutionRoutine;
    PVOID DriverContext;
    PIRP CurrentIrp;
    PADAPTER_OBJECT AdapterObject;
    BOOLEAN WriteToDevice;

    //
    // Save the map register base.
    //

    WaitBlock->MapRegisterBase = MapRegisterBase;

    //
    // Save the data that will be overwritten by the scatter gather list.
    //

    DriverExecutionRoutine = WaitBlock->DriverExecutionRoutine;
    DriverContext = WaitBlock->DriverContext;
    CurrentIrp = WaitBlock->Wcb.CurrentIrp;
    AdapterObject = WaitBlock->AdapterObject;
    WriteToDevice = WaitBlock->WriteToDevice;

    //
    // Put the scatter gatther list after wait block. Add a back pointer to
    // the beginning of the wait block.
    //

    ScatterGather = &WaitBlock->ScatterGather;
    ScatterGather->Reserved = (ULONG_PTR) WaitBlock;
    Element = ScatterGather->Elements;

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used MDL.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;

#if DBG
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    if (MmGetMdlVirtualAddress(Mdl) < (PVOID)((PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount )) {

        ASSERT( CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );
    }
#endif

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    TransferLength = WaitBlock->Length;

    //
    // Loop building the list for each MDL.
    //

    while (TransferLength >  0) {

        if ((ULONG) MdlLength > TransferLength) {

            MdlLength = TransferLength;
        }

        TransferLength -= MdlLength;

        NextEntry = TranslationEntry;
        if (MdlLength > 0) {

            NextEntry +=  ADDRESS_AND_SIZE_TO_SPAN_PAGES( CurrentVa,
                                                          MdlLength );

        }

        //
        // Loop building the list for the elments within an MDL.
        //

        while (MdlLength > 0) {

            Element->Length = MdlLength;
            Element->Address = IoMapTransfer( AdapterObject,
                                              Mdl,
                                              MapRegisterBase,
                                              CurrentVa,
                                              &Element->Length,
                                              WriteToDevice );

            ASSERT( (ULONG) MdlLength >= Element->Length );
            MdlLength -= Element->Length;
            CurrentVa += Element->Length;
            Element++;
        }

        if (Mdl->Next == NULL) {

            //
            // There are a few cases where the buffer described by the MDL
            // is less than the transfer length.  This occurs when the
            // file system transfering the last page of file and MM defines
            // the MDL to be the file size and the file system rounds the write
            // up to a sector.  This extra should never cross a page
            // boundary.  Add this extra to the length of the last element.
            //

            ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
            (Element - 1)->Length += TransferLength;

            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
        TranslationEntry = NextEntry;

    }

    //
    // Set the number of elements actually used.
    //

    ScatterGather->NumberOfElements = Element - ScatterGather->Elements;

    //
    // Call the driver with the scatter/gather list.
    //

    DriverExecutionRoutine( DeviceObject,
                            CurrentIrp,
                            ScatterGather,
                            DriverContext );

    return( DeallocateObjectKeepRegisters );
}


VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, the kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{
    PKDEVICE_QUEUE_ENTRY Packet;
    PWAIT_CONTEXT_BLOCK Wcb;
    PADAPTER_OBJECT MasterAdapter;
    BOOLEAN Busy = FALSE;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;
    LONG MapRegisterNumber;

    //
    // Begin by getting the address of the master adapter.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Pull requests of the adapter's device wait queue as long as the
    // adapter is free and there are sufficient map registers available.
    //

    while( TRUE ) {

       //
       // Begin by checking to see whether there are any map registers that
       // need to be deallocated.  If so, then deallocate them now.
       //

       if (AdapterObject->NumberOfMapRegisters != 0) {
           IoFreeMapRegisters( AdapterObject,
                               AdapterObject->MapRegisterBase,
                               AdapterObject->NumberOfMapRegisters
                               );
       }

       //
       // Simply remove the next entry from the adapter's device wait queue.
       // If one was successfully removed, allocate any map registers that it
       // requires and invoke its execution routine.
       //

       Packet = KeRemoveDeviceQueue( &AdapterObject->ChannelWaitQueue );
       if (Packet == NULL) {

           //
           // There are no more requests - break out of the loop.
           //

           break;
       }

       Wcb = CONTAINING_RECORD( Packet,
            WAIT_CONTEXT_BLOCK,
            WaitQueueEntry );

       AdapterObject->CurrentWcb = Wcb;
       AdapterObject->NumberOfMapRegisters = Wcb->NumberOfMapRegisters;

        //
        // Check to see whether this driver wishes to allocate any map
        // registers.  If so, then queue the device object to the master
        // adapter queue to wait for them to become available.  If the driver
        // wants map registers, ensure that this adapter has enough total
        // map registers to satisfy the request.
        //

        if (Wcb->NumberOfMapRegisters != 0 &&
            AdapterObject->MasterAdapter != NULL) {

            //
            // Lock the map register bit map and the adapter queue in the
            // master adapter object. The channel structure offset is used as
            // a hint for the register search.
            //

            KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

            MapRegisterNumber = -1;

            if (IsListEmpty( &MasterAdapter->AdapterQueue)) {
               MapRegisterNumber = RtlFindClearBitsAndSet( MasterAdapter->MapRegisters,
                                                        Wcb->NumberOfMapRegisters,
                                                        0
                                                        );
            }
            if (MapRegisterNumber == -1) {

                //PBUFFER_GROW_WORK_ITEM bufferWorkItem;

               //
               // There were not enough free map registers.  Queue this request
               // on the master adapter where it will wait until some registers
               // are deallocated.
               //

               InsertTailList( &MasterAdapter->AdapterQueue,
                               &AdapterObject->AdapterQueue
                               );
               Busy = 1;

                //
                // Queue a work item to grow the map registers
                //
#if 0
                bufferWorkItem =
                    ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof(BUFFER_GROW_WORK_ITEM),
                                           HAL_POOL_TAG);
                
                if (bufferWorkItem != NULL) {

                    ExInitializeWorkItem( &bufferWorkItem->WorkItem,
                                          HalpGrowMapBufferWorker,
                                          bufferWorkItem );

                    bufferWorkItem->AdapterObject = AdapterObject;
                    bufferWorkItem->MapRegisterCount =
                        Wcb->NumberOfMapRegisters;

                    ExQueueWorkItem( &bufferWorkItem->WorkItem,
                                     DelayedWorkQueue );
                }
#endif

            } else {

                AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                    MasterAdapter->MapRegisterBase + MapRegisterNumber);

                //
                // Set the no scatter/gather flag if scatter/gather is not
                // supported.
                //

                if (!AdapterObject->ScatterGather) {

                    AdapterObject->MapRegisterBase = (PVOID)
                        ((ULONG_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

                }
            }

            KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        } else {

            AdapterObject->MapRegisterBase = NULL;
            AdapterObject->NumberOfMapRegisters = 0;

        }

        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now.
        //

        if (!Busy) {
            AdapterObject->CurrentWcb = Wcb;
            Action = Wcb->DeviceRoutine( Wcb->DeviceObject,
                Wcb->CurrentIrp,
                AdapterObject->MapRegisterBase,
                Wcb->DeviceContext );

            //
            // If the execution routine would like to have the adapter
            // deallocated, then release the adapter object.
            //

            if (Action == KeepObject) {

               //
               // This request wants to keep the channel a while so break
               // out of the loop.
               //

               break;

            }

            //
            // If the driver wants to keep the map registers then set the
            // number allocated to 0.  This keeps the deallocation routine
            // from deallocating them.
            //

            if (Action == DeallocateObjectKeepRegisters) {
                AdapterObject->NumberOfMapRegisters = 0;
            }

        } else {

           //
           // This request did not get the requested number of map registers so
           // break out of the loop.
           //

           break;
        }
    }
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

   If NumberOfMapRegisters != 0, this routine deallocates the map registers
   for the adapter.

   If there are any queued adapters waiting then an attempt is made to allocate
   the next entry.

Arguments:

   AdapterObject - The adapter object where the map registers should be
        returned to.

   MapRegisterBase - The map register base of the registers to be deallocated.

   NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

   None

--+*/
{
   PADAPTER_OBJECT MasterAdapter;
   LONG MapRegisterNumber;
   PWAIT_CONTEXT_BLOCK Wcb;
   PLIST_ENTRY Packet;
   IO_ALLOCATION_ACTION Action;
   KIRQL Irql;


    //
    // Begin by getting the address of the master adapter.
    //

    if (AdapterObject->MasterAdapter != NULL && MapRegisterBase != NULL) {

        MasterAdapter = AdapterObject->MasterAdapter;

    } else {

        //
        // There are no map registers to return.
        //

        return;
    }

    if (NumberOfMapRegisters != 0) {

        //
        // Strip the no scatter/gather flag.
        //
        
        MapRegisterBase = (PVOID) ((ULONG_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);
        
        MapRegisterNumber = (ULONG)((PTRANSLATION_ENTRY) MapRegisterBase -
             (PTRANSLATION_ENTRY) MasterAdapter->MapRegisterBase);
        
        //
        // Acquire the master adapter spinlock which locks the adapter queue and the
        // bit map for the map registers.
        //
        
        KeAcquireSpinLock(&MasterAdapter->SpinLock,&Irql);
        
        //
        // Return the registers to the bit map.
        //
        
        RtlClearBits( MasterAdapter->MapRegisters,
                      MapRegisterNumber,
                      NumberOfMapRegisters
                      );

    } else {

        KeAcquireSpinLock(&MasterAdapter->SpinLock,&Irql);
    }
   

   //
   // Process any requests waiting for map registers in the adapter queue.
   // Requests are processed until a request cannot be satisfied or until
   // there are no more requests in the queue.
   //

   while(TRUE) {

      if ( IsListEmpty(&MasterAdapter->AdapterQueue) ){
         break;
      }

      Packet = RemoveHeadList( &MasterAdapter->AdapterQueue );
      AdapterObject = CONTAINING_RECORD( Packet,
                                         ADAPTER_OBJECT,
                                         AdapterQueue
                                         );
      Wcb = AdapterObject->CurrentWcb;

      //
      // Attempt to allocate map registers for this request. Use the previous
      // register base as a hint.
      //

      MapRegisterNumber = RtlFindClearBitsAndSet( MasterAdapter->MapRegisters,
                                               AdapterObject->NumberOfMapRegisters,
                                               MasterAdapter->NumberOfMapRegisters
                                               );

      if (MapRegisterNumber == -1) {

         //
         // There were not enough free map registers.  Put this request back on
         // the adapter queue where is came from.
         //

         InsertHeadList( &MasterAdapter->AdapterQueue,
                         &AdapterObject->AdapterQueue
                         );

         break;

      }

     KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

     AdapterObject->MapRegisterBase = (PVOID) ((PTRANSLATION_ENTRY)
        MasterAdapter->MapRegisterBase + MapRegisterNumber);

     //
     // Set the no scatter/gather flag if scatter/gather not
     // supported.
     //

     if (!AdapterObject->ScatterGather) {

        AdapterObject->MapRegisterBase = (PVOID)
            ((ULONG_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

     }

     //
     // Invoke the driver's execution routine now.
     //

      Action = Wcb->DeviceRoutine( Wcb->DeviceObject,
        Wcb->CurrentIrp,
        AdapterObject->MapRegisterBase,
        Wcb->DeviceContext );

      //
      // If the driver wishes to keep the map registers then set the number
      // allocated to zero and set the action to deallocate object.
      //

      if (Action == DeallocateObjectKeepRegisters) {
          AdapterObject->NumberOfMapRegisters = 0;
          Action = DeallocateObject;
      }

      //
      // If the driver would like to have the adapter deallocated,
      // then deallocate any map registers allocated and then release
      // the adapter object.
      //

      if (Action == DeallocateObject) {

             //
             // The map registers registers are deallocated here rather than in
             // IoFreeAdapterChannel.  This limits the number of times
             // this routine can be called recursively possibly overflowing
             // the stack.  The worst case occurs if there is a pending
             // request for the adapter that uses map registers and whos
             // excution routine decallocates the adapter.  In that case if there
             // are no requests in the master adapter queue, then IoFreeMapRegisters
             // will get called again.
             //

          if (AdapterObject->NumberOfMapRegisters != 0) {

             //
             // Deallocate the map registers and clear the count so that
             // IoFreeAdapterChannel will not deallocate them again.
             //

             KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

             RtlClearBits( MasterAdapter->MapRegisters,
                           MapRegisterNumber,
                           AdapterObject->NumberOfMapRegisters
                           );

             AdapterObject->NumberOfMapRegisters = 0;

             KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );
          }

          IoFreeAdapterChannel( AdapterObject );
      }

      KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

   }

   KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );
}

VOID
HalPutDmaAdapter(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    This routine frees the DMA adapter if it is not one of the common
    DMA channel adapters.

Arguments:

    AdapterObject - Supplies a pointer to the DMA adapter to be freed.

Return Value:

    None.


--*/
{
    KIRQL Irql;

    //
    // This adapter can be freed if the channel number is zero and
    // it is not the channel zero adapter.
    //

    if ( AdapterObject->ChannelNumber == 0xFF ) {
        
        //
        // Remove this adapter from our list
        //
        KeAcquireSpinLock(&HalpDmaAdapterListLock,&Irql);
        RemoveEntryList(&AdapterObject->AdapterList);
        KeReleaseSpinLock(&HalpDmaAdapterListLock, Irql);

        ObDereferenceObject( AdapterObject );
    }

#ifdef ACPI_HAL
    //
    // Deal with Slave Objects that are F-Type, if we have F-DMA support
    //
    if (HalpFDMAInterface.IsaReleaseFTypeChannel &&
        (AdapterObject->ChannelNumber >= 0) &&
        (AdapterObject->ChannelNumber < EISA_DMA_CHANNELS)) {

        HalpFDMAInterface.IsaReleaseFTypeChannel(NULL,AdapterObject->ChannelNumber);
    }


#endif
}

struct _DMA_ADAPTER *
HaliGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function is a wrapper for HalGetAdapter.  Is is called through
    the HAL dispatch table.

Arguments:

    Context - Unused.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );
}

NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    )
/*++

Routine Description:

    This function builds an MDL from the scatter gather list. This is so if a driver wants to 
    construct a virtual address for the DMA buffer and write to it. The target MDL is freed when the 
    caller calls HalPutScatterGatherList.

Arguments:

    ScatterGather - The scatter gather buffer from which to build the MDL.

    OriginalMdl  - The MDL used to build the scatter gather list (using HalGet or HalBuild API)
    
    TargetMdl - Returns the new MDL in this.
    

Return Value:

    Returns a success or error status.

--*/
{
    PMDL    tempMdl;
    PMDL    newMdl;
    PMDL    targetMdl;
    PMDL    prevMdl;
    PMDL    nextMdl;
    CSHORT  mdlFlags;
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    ULONG    i,j;
    PSCATTER_GATHER_ELEMENT element;
    PPFN_NUMBER pfnArray;
    ULONG   pageFrame;
    ULONG   nPages;

    if (!OriginalMdl) {
        return  STATUS_INVALID_PARAMETER;
    }

    if (!AdapterObject->NeedsMapRegisters) {
        *TargetMdl = OriginalMdl;
        return STATUS_SUCCESS;
    }

    //
    // If this API is called more than once 
    if (WaitBlock && WaitBlock->DmaMdl) {
        return (STATUS_NONE_MAPPED);
    }

    //
    // Allocate a chain of target MDLs
    //

    prevMdl = NULL;
    targetMdl = NULL;

    for (tempMdl = OriginalMdl; tempMdl; tempMdl = tempMdl->Next) {
        PVOID va;
        ULONG byteCount;

        if(tempMdl == OriginalMdl) {
            va = WaitBlock->CurrentVa;

            //
            // This may be a little more than necessary.
            //

            byteCount = MmGetMdlByteCount(tempMdl);
        } else {
            va = MmGetMdlVirtualAddress(tempMdl);
            byteCount = MmGetMdlByteCount(tempMdl);
        }

        newMdl = IoAllocateMdl(va, byteCount, FALSE, FALSE, NULL);
        if (!newMdl) {

            //
            // Clean up previous allocated MDLs
            //

            tempMdl = targetMdl;
            while (tempMdl) {
                nextMdl = tempMdl->Next;
                IoFreeMdl(tempMdl);
                tempMdl = nextMdl;
            }

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        if (!prevMdl) {
            prevMdl = newMdl;
            targetMdl = newMdl;
        } else {
            prevMdl->Next = newMdl;
            prevMdl = newMdl;
        }
    }


    tempMdl = OriginalMdl;

    element = ScatterGather->Elements;
    for (tempMdl = targetMdl; tempMdl; tempMdl = tempMdl->Next) {

        targetMdl->MdlFlags |= MDL_PAGES_LOCKED;
        pfnArray = MmGetMdlPfnArray(tempMdl);

        for (i = 0; i < ScatterGather->NumberOfElements; i++, element++) {
            nPages = BYTES_TO_PAGES(BYTE_OFFSET(element->Address.QuadPart) + element->Length);

            pageFrame = (ULONG)(element->Address.QuadPart >> PAGE_SHIFT);
            for (j = 0; j < nPages; j++) {
                *pfnArray = pageFrame + j;
                pfnArray++;
                ASSERT((PVOID)pfnArray <= (PVOID)((PCHAR)tempMdl + tempMdl->Size));
            }
        }
    }

    *TargetMdl = targetMdl;
    if (WaitBlock) {
        WaitBlock->DmaMdl = targetMdl;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixidle.asm ===
title "Hal Processor Idle"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixidle.asm
;
;Abstract:
;
;
;Author:
;
;
;Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
        .list

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "HalProcessorIdle"
;++
;
; VOID
; HalProcessorIdle(
;       VOID
;       )
;
; Routine Description:
;
;   This function is called when the current processor is idle.
;
;   This function is called with interrupts disabled, and the processor
;   is idle until it receives an interrupt.  The does not need to return
;   until an interrupt is received by the current processor.
;
;   This is the lowest level of processor idle.  It occurs frequently,
;   and this function (alone) should not put the processor into a
;   power savings mode which requeres large amount of time to enter & exit.
;
; Return Value:
;
;--

cPublicProc _HalProcessorIdle, 0
cPublicFpo 0,0

    ;
    ; the following code sequence "sti-halt" puts the processor
    ; into a Halted state, with interrupts enabled, without processing
    ; an interrupt before halting.   The STI instruction has a delay
    ; slot such that it does not take effect until after the instruction
    ; following it - this has the effect of HALTing without allowing
    ; a possible interrupt and then enabling interrupts while HALTed.
    ;

    ;
    ; On an MP hal we don't stop the processor, since that causes
    ; the SNOOP to slow down as well
    ;

        sti

ifdef NT_UP
        hlt
endif

    ;
    ; Now return to the system.  If there's still no work, then it
    ; will call us back to halt again.
    ;

        stdRET    _HalProcessorIdle

stdENDP _HalProcessorIdle

_TEXT$01   ends
           end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixirqarb.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ixirqarb.c

Abstract:

    This module implements an arbiter for IRQs.

Author:

    Santosh Jodh (santoshj) 22-June-1998

Environment:

    NT Kernel Model Driver only

--*/
#include <nthal.h>
#include <arbiter.h>

#ifndef _IN_KERNEL_
#define _IN_KERNEL_
#include <regstr.h>
#undef _IN_KERNEL_
#else
#include <regstr.h>
#endif

#if defined(NEC_98)
#include <pci.h>
#endif
#include "ixpciir.h"

#define ARBITER_CONTEXT_TO_INSTANCE(x)  (x)

#define ARBITER_INTERRUPT_LEVEL         0x10
#define ARBITER_INTERRUPT_EDGE          0x20
#define ARBITER_INTERRUPT_BITS          (ARBITER_INTERRUPT_LEVEL | ARBITER_INTERRUPT_EDGE)

#define NUM_IRQS    16
#if defined(NEC_98)
#define PIC_SLAVE_IRQ           7
#else
#define PIC_SLAVE_IRQ           2
#endif

extern ULONG HalDebug;
#if defined(NEC_98)
extern ULONG NEC98SpecialIRQMask;
#endif

#if DBG
#define DEBUG_PRINT(Level, Message) {   \
    if (HalDebug >= Level) {            \
        DbgPrint("HAL: ");              \
        DbgPrint Message;               \
        DbgPrint("\n");                 \
    }                                   \
}
#else
#define DEBUG_PRINT(Level, Message)
#endif

typedef struct {
    ARBITER_INSTANCE    ArbiterState;
} HAL_ARBITER, *PHAL_ARBITER;

NTSTATUS
HalpInitIrqArbiter (
    IN PDEVICE_OBJECT   HalFdo
    );

NTSTATUS
HalpFillInIrqArbiter (
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

NTSTATUS
HalpArbUnpackRequirement (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    );

NTSTATUS
HalpArbPackResource (
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
HalpArbUnpackResource (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    );

LONG
HalpArbScoreRequirement (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    );

NTSTATUS
HalpArbTestAllocation (
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
HalpArbRetestAllocation (
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

NTSTATUS
HalpArbCommitAllocation(
    IN PARBITER_INSTANCE Arbiter
    );

NTSTATUS
HalpArbRollbackAllocation (
    PARBITER_INSTANCE Arbiter
    );

NTSTATUS
HalpArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    );

BOOLEAN
HalpArbFindSuitableRange (
    PARBITER_INSTANCE   Arbiter,
    PARBITER_ALLOCATION_STATE State
    );

VOID
HalpArbAddAllocation (
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

VOID
HalpArbBacktrackAllocation (
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     );

NTSTATUS
HalpArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    );

BOOLEAN
HalpArbGetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PARBITER_ALLOCATION_STATE State
    );

ULONG
HalpFindLinkInterrupt (
    IN PRTL_RANGE_LIST RangeList,
    IN ULONG Mask,
    IN ULONG Start,
    IN ULONG End,
    IN ULONG Flags,
    IN UCHAR UserFlags
    );

BOOLEAN
HalpArbQueryConflictCallback(
    IN PVOID Context,
    IN PRTL_RANGE Range
    );
VOID
HalpIrqArbiterInterfaceReference(
    IN PVOID    Context
    );
VOID
HalpIrqArbiterInterfaceDereference(
    IN PVOID    Context
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpInitIrqArbiter)
#pragma alloc_text(PAGE, HalpFillInIrqArbiter)
#pragma alloc_text(PAGE, HalpArbUnpackRequirement)
#pragma alloc_text(PAGE, HalpArbPackResource)
#pragma alloc_text(PAGE, HalpArbUnpackResource)
#pragma alloc_text(PAGE, HalpArbScoreRequirement)
#pragma alloc_text(PAGE, HalpArbTestAllocation)
#pragma alloc_text(PAGE, HalpArbRetestAllocation)
#pragma alloc_text(PAGE, HalpArbCommitAllocation)
#pragma alloc_text(PAGE, HalpArbRollbackAllocation)
#pragma alloc_text(PAGE, HalpArbPreprocessEntry)
#pragma alloc_text(PAGE, HalpArbFindSuitableRange)
#pragma alloc_text(PAGE, HalpArbAddAllocation)
#pragma alloc_text(PAGE, HalpArbBacktrackAllocation)
#pragma alloc_text(PAGE, HalpArbBootAllocation)
#pragma alloc_text(PAGE, HalpArbGetNextAllocationRange)
#pragma alloc_text(PAGE, HalpFindLinkInterrupt)
#pragma alloc_text(PAGE, HalpArbQueryConflictCallback)
#pragma alloc_text(PAGE, HalpIrqArbiterInterfaceReference)
#pragma alloc_text(PAGE, HalpIrqArbiterInterfaceDereference)
#endif

HAL_ARBITER HalpArbiter = {{
    0,//Signature
    NULL,//MutexEvent
    NULL,//Name
    {0},//ResourceType
    NULL,//Allocation
    NULL,//PossibleAllocation
    {0},//OrderingList
    {0},//ReservedList
    0,//ReferenceCount
    NULL,//Interface
    0,//AllocationStackMaxSize
    NULL,//AllocationStack
    HalpArbUnpackRequirement,//UnpackRequirement
    HalpArbPackResource,//PackResource
    HalpArbUnpackResource,//UnpackResource
    HalpArbScoreRequirement,//ScoreRequirement
    HalpArbTestAllocation,//TestAllocation
    HalpArbRetestAllocation,//RetestAllocation
    HalpArbCommitAllocation,//CommitAllocation
    HalpArbRollbackAllocation,//RollbackAllocation
    HalpArbBootAllocation,//BootAllocation
    NULL,//QueryArbitrate
    NULL,//QueryConflict
    NULL,//AddReserved
    NULL,//StartArbiter
    HalpArbPreprocessEntry,//PreprocessEntry
    NULL,//AllocateEntry
    HalpArbGetNextAllocationRange,//GetNextAllocationRange
    HalpArbFindSuitableRange,//FindSuitableRange
    HalpArbAddAllocation,//AddAllocation
    HalpArbBacktrackAllocation,//BacktrackAllocation
    NULL,//OverrideConflict
    FALSE,//TransactionInProgress
    &HalpPciIrqRoutingInfo,//Extension
    NULL,//BusDeviceObject
    NULL,//ConflictCallbackContext
    NULL,//ConflictCallback
}};

BOOLEAN
HalpArbQueryConflictCallback(
    IN PVOID Context,
    IN PRTL_RANGE Range
    )
{
    if (Range->Attributes & ARBITER_INTERRUPT_LEVEL)
    {
        if(Range->Flags & RTL_RANGE_SHARED)
        {
            return (TRUE);
        }
        else
        {
            DEBUG_PRINT(1, ("Exclusive level interrupt %02x cannot be shared!", (ULONG)Context));
            return (FALSE);
        }
    }

    DEBUG_PRINT(1, ("Refusing to share edge and level interrupts on %02x", (ULONG)Context));
    return (FALSE);
}

NTSTATUS
HalpArbPreprocessEntry(
    IN PARBITER_INSTANCE Arbiter,
    IN PARBITER_ALLOCATION_STATE State
    )
/*++

Routine Description:

    This routine is called from AllocateEntry to allow preprocessing of
    entries

Arguments:

    Arbiter - The instance data of the arbiter who was called.

    State - The state of the current arbitration.

Return Value:

    None.

--*/
{

#define CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS 0x0001

    PARBITER_ALTERNATIVE current;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Check if this is a level (PCI) or latched (ISA (edge)) interrupt and set
    // RangeAttributes accordingly so we set the appropriate flag when we add the
    // range
    //

    if ((State->Alternatives[0].Descriptor->Flags
            & CM_RESOURE_INTERRUPT_LEVEL_LATCHED_BITS)
                == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)
    {

        State->RangeAttributes &= ~ARBITER_INTERRUPT_BITS;
        State->RangeAttributes |= ARBITER_INTERRUPT_LEVEL;

    } else
    {
        ASSERT(State->Alternatives[0].Descriptor->Flags
                    & CM_RESOURCE_INTERRUPT_LATCHED);

        State->RangeAttributes &= ~ARBITER_INTERRUPT_BITS;
        State->RangeAttributes |= ARBITER_INTERRUPT_EDGE;
    }

    return (STATUS_SUCCESS);
}

BOOLEAN
HalpArbGetNextAllocationRange(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PARBITER_ALLOCATION_STATE State
    )
{
    //
    // Default to having no next range.
    //

    BOOLEAN nextRange = FALSE;

    //
    // Try all possible interrupts on first call.
    //

    if (State->CurrentAlternative) {

        if (++State->CurrentAlternative < &State->Alternatives[State->AlternativeCount]) {

            DEBUG_PRINT(3, ("No next allocation range, exhausted all %08X alternatives", State->AlternativeCount));
            nextRange = TRUE;

        }
    }
    else {

        //
        // First call, try the first alternative.
        //

        State->CurrentAlternative = &State->Alternatives[0];
        nextRange = TRUE;

    }

    if (nextRange) {

        State->CurrentMinimum = State->CurrentAlternative->Minimum;
        State->CurrentMaximum = State->CurrentAlternative->Maximum;
        DEBUG_PRINT(3, ("Next allocation range 0x%I64x-0x%I64x", State->CurrentMinimum, State->CurrentMaximum));

    }

    return nextRange;
}

ULONG
HalpFindLinkInterrupt (
    IN PRTL_RANGE_LIST RangeList,
    IN ULONG Mask,
    IN ULONG Start,
    IN ULONG End,
    IN ULONG Flags,
    IN UCHAR UserFlags
    )

/*++

    Routine Description:

        This routine scans the mask from MSB to LSB for the first
        value that is available in the range list.

    Input Parameters:

        RangeList - List to be searched.

        Mask - Interrupt mask to be scanned.

        Start - Start scan AFTER this interrupt.

        Flags - Flags for the range list.

        UserFlags - Special flags.

    Return Value:

        First available interrupt from the mask iff successful. Else 0.

--*/

{
    ULONG       interrupt;
    ULONG       test;
    NTSTATUS    status;
    BOOLEAN     available;

    if (Start > 0x0F)
    {
        Start = 0x0F;
    }
    if (Start != 0 && Start >= End)
    {
        interrupt = Start;
        test = 1 << interrupt;
        do
        {
            //
            // If this interrupt is supported, see if it is free.
            //

            if (Mask & test)
            {
                available = FALSE;
                status = RtlIsRangeAvailable(   RangeList,
                                                interrupt,
                                                interrupt,
                                                Flags,
                                                UserFlags,
                                                (PVOID)interrupt,
                                                HalpArbQueryConflictCallback,
                                                &available);
                if (NT_SUCCESS(status) && available)
                {
                    return (interrupt);
                }
            }
            interrupt--;
            test >>= 1;
        }
        while (interrupt > End);
    }

    return (0);
}

BOOLEAN
HalpArbFindSuitableRange (
    PARBITER_INSTANCE   Arbiter,
    PARBITER_ALLOCATION_STATE State
    )

/*++

    Routine Description:

        This
    Input Parameters:

    Return Value:

--*/

{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    NTSTATUS                status;
    PLINK_NODE              linkNode;
    ULONG                   interrupt;
    ULONG                   freeInterrupt;
    PLINK_NODE              current;
    ULONG                   busNumber;
    ULONG                   slotNumber;
#if defined(NEC_98)
    PINT_ROUTE_INTERFACE_STANDARD   pciInterface;
    ULONG                   dummy;
    UCHAR                   classCode;
    UCHAR                   subClassCode;
    ROUTING_TOKEN           routingToken;
    UCHAR                   pin;
#endif

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    if (State->Entry->InterfaceType == PCIBus)
    {
#if defined(NEC_98)
        pciInterface = pciIrqRoutingInfo->PciInterface;

        //
        // Call Pci driver to get info about the Pdo.
        //

        status = pciInterface->GetInterruptRouting( State->Entry->PhysicalDeviceObject,
                                                    &busNumber,
                                                    &slotNumber,
                                                    (PUCHAR)&dummy,
                                                    &pin,
                                                    &classCode,
                                                    &subClassCode,
                                                    (PDEVICE_OBJECT *)&dummy,
                                                    &routingToken,
                                                    (PUCHAR)&dummy);

        //
        // This means that it is not a Pci device.
        //

        if (!NT_SUCCESS(status))
        {
            return (FALSE);
        }
#endif
        busNumber = State->Entry->BusNumber;
        slotNumber = State->Entry->SlotNumber;
    }
    else
    {
        busNumber = (ULONG)-1;
        slotNumber = (ULONG)-1;
    }

    //
    // See if there is link information for this device.
    //

    linkNode = NULL;
    status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                State->Entry->PhysicalDeviceObject,
                                busNumber,
                                slotNumber,
                                &linkNode);
    switch (status)
    {
        case STATUS_SUCCESS:

            if (linkNode == NULL)
            {
                DEBUG_PRINT(1, ("Link does not exist for Pci PDO %08x. Hopefully, device can live without an interrupt!", State->Entry->PhysicalDeviceObject));
                return (FALSE);
            }

            //
            // If we have already decided an interrupt for this link,
            // everyone using it gets the same interrupt.
            //

            if (linkNode->PossibleAllocation->RefCount > 0)
            {
                if (    State->CurrentMinimum <= linkNode->PossibleAllocation->Interrupt &&
                        linkNode->PossibleAllocation->Interrupt <= State->CurrentMaximum)
                {
                    State->Start = linkNode->PossibleAllocation->Interrupt;
                    State->End = State->Start;
                    State->CurrentAlternative->Length = 1;

                    DEBUG_PRINT(2, ("Found Irq (%04x) for Pci PDO %08x using link %02x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link));

                    return (TRUE);
                }
                else
                {
                    DEBUG_PRINT(1, ("Found Irq (%04x) for Pci PDO %08x using link %02x but is outside the range (%04x-%04x)!", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link, State->CurrentMinimum, State->CurrentMaximum));

                    return (FALSE);
                }
            }
            else
            {

                //
                // We want to spread out the links as much as we can for
                // performance.
                //

                //
                // First see if this link is programmed for some IRQ.
                //

                interrupt = 0;
                status = PciirqmpGetIrq((PUCHAR)&interrupt, (UCHAR)linkNode->Link);

                if (NT_SUCCESS(status) && interrupt)
                {

                    if (State->CurrentMinimum <= interrupt && interrupt <= State->CurrentMaximum)
                    {
                        //
                        // Make sure the BIOS did not mess up
                        //

                        freeInterrupt = HalpFindLinkInterrupt ( Arbiter->PossibleAllocation,
                                                                linkNode->InterruptMap,
                                                                interrupt,
                                                                interrupt,
                                                                0,
                                                                0);
                        if(freeInterrupt == 0)
                        {
                            DEBUG_PRINT(1, ("BIOS failure. Assigned Irq (%02x) to link %02x which is unavailable or impossible according to mask %04x", interrupt, linkNode->Link, linkNode->InterruptMap));
                        }
                        interrupt = freeInterrupt;
                    }
                    else
                    {
                        DEBUG_PRINT(1, ("Found Irq (%04x) pre-programmedfor link %02x but is outside the range (%04x-%04x)!", interrupt, linkNode->Link, State->CurrentMinimum, State->CurrentMaximum));
                        return (FALSE);
                    }
                }


                if (interrupt == 0)
                {
#if defined(NEC_98)
                    if (NEC98SpecialIRQMask){
                        linkNode->InterruptMap &= ~( 1 << NEC98SpecialIRQMask);
                    }
#endif
                    //
                    // Try to get an interrupt by itself for this link.
                    //

                    interrupt = HalpFindLinkInterrupt ( Arbiter->PossibleAllocation,
                                                        linkNode->InterruptMap,
                                                        (ULONG)State->CurrentMaximum,
                                                        (ULONG)State->CurrentMinimum,
                                                        0,
                                                        0);
#if defined(NEC_98)
                    //
                    // Force to share CardBus IRQ with another PCI Device
                    //
                    if ( interrupt &&
                         classCode == PCI_CLASS_BRIDGE_DEV &&
                         subClassCode == PCI_SUBCLASS_BR_CARDBUS )
                    {
                        //
                        // Remember this.
                        //

                         freeInterrupt = interrupt;

                        do
                        {
                            //
                            // Is this being used by another link?
                            //
                            current = pciIrqRoutingInfo->LinkNodeHead;

                            while ( current != NULL) {

                                if ( current->PossibleAllocation->Interrupt == interrupt )
                                {
                                    //
                                    // somebody use this. Cardbus controller use this, too.
                                    //
                                    interrupt = 0;
                                    break;
                                }
                                current = current->Next;
                            }

                            if (interrupt){
                                interrupt = HalpFindLinkInterrupt ( Arbiter->PossibleAllocation,
                                                                    linkNode->InterruptMap,
                                                                    interrupt - 1,
                                                                    (ULONG)State->CurrentMinimum,
                                                                    0,
                                                                    0);
                                if (interrupt) {
                                    //
                                    // Remember this, if find new interrupt.
                                    //

                                    freeInterrupt = interrupt;
                                }
                            }

                        }
                        while (interrupt);

                        if (!interrupt)
                        {
                            interrupt = freeInterrupt;
                        }

                    } else if ( interrupt )
#else
                    if (interrupt)
#endif
                    {
                        //
                        // Remember this.
                        //

                        freeInterrupt = interrupt;

                        do
                        {
                            //
                            // Is this being used by another link?
                            //

                            for (   current = pciIrqRoutingInfo->LinkNodeHead;
                                    current && current->PossibleAllocation->Interrupt != interrupt;
                                    current = current->Next);
                            if (current == NULL)
                            {
                                break;
                            }

                            interrupt = HalpFindLinkInterrupt ( Arbiter->PossibleAllocation,
                                                                linkNode->InterruptMap,
                                                                interrupt - 1,
                                                                (ULONG)State->CurrentMinimum,
                                                                0,
                                                                0);
                        }
                        while (interrupt);

                        if (!interrupt)
                        {
                            if (!(pciIrqRoutingInfo->Parameters & PCIIR_FLAG_EXCLUSIVE)) {
                                interrupt = freeInterrupt;
                            }
                        }
                    }
                }

                if (interrupt)
                {
                    State->Start = interrupt;
                    State->End = interrupt;
                    State->CurrentAlternative->Length = 1;

                    DEBUG_PRINT(2, ("Found Irq (%04x) for Pci PDO %08x using link %02x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link));

                    return (TRUE);
                }
            }

            //
            // There is no interrupt this link can use, too bad.
            //

            return (FALSE);

        case STATUS_RESOURCE_REQUIREMENTS_CHANGED:

            //
            // Pci Ide device does not share Irqs.
            //

            if (State->CurrentAlternative->Flags & ARBITER_ALTERNATIVE_FLAG_SHARED) {

                State->CurrentAlternative->Flags &= ~ARBITER_ALTERNATIVE_FLAG_SHARED;
            }

        default:


            //
            // Non Pci device.
            //

            break;
    }

    //
    // HACKHACK: This is to allow boot conflict on IRQ 14 and 15.
    // This is so that broken machines which report both PNP06xx and
    // the PCI IDE controller work. One of them (no order guarantee)
    // will come up with a conflict.
    //

    if (State->Entry->Flags & ARBITER_FLAG_BOOT_CONFIG) {
        if (    State->CurrentMinimum == State->CurrentMaximum &&
                (State->CurrentMinimum == 14 || State->CurrentMinimum == 15)) {
            State->RangeAvailableAttributes |= ARBITER_RANGE_BOOT_ALLOCATED;
        }
    }

    return (ArbFindSuitableRange(Arbiter, State));
}

VOID
HalpArbAddAllocation(
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    NTSTATUS                status;
    PLINK_NODE              linkNode;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    DEBUG_PRINT(3, ("Adding Irq (%04x) allocation for PDO %08x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject));

    linkNode = NULL;
    status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                State->Entry->PhysicalDeviceObject,
                                State->Entry->BusNumber,
                                State->Entry->SlotNumber,
                                &linkNode);
    if (NT_SUCCESS(status) && status == STATUS_SUCCESS)
    {
        if (linkNode)
        {
            if (linkNode->PossibleAllocation->RefCount)
            {
                if (linkNode->PossibleAllocation->Interrupt != State->Start)
                {
                    DEBUG_PRINT(1, ("Two different interrupts (old = %08x, new = %08x) for the same link %08x!", linkNode->PossibleAllocation->Interrupt, State->Start, linkNode->Link));
                    ASSERT(linkNode->PossibleAllocation->Interrupt == State->Start);
                }
            }
            else
            {
                DEBUG_PRINT(3, ("Adding new Irq (%04x) allocation for Pci PDO %08x using link %02x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link));

                linkNode->PossibleAllocation->Interrupt = (ULONG)State->Start;
            }

            linkNode->PossibleAllocation->RefCount++;
        }
        else
        {
            DEBUG_PRINT(1, ("This should never happen!"));
            ASSERT(linkNode);
        }
    }

    status = RtlAddRange(   Arbiter->PossibleAllocation,
                            State->Start,
                            State->End,
                            State->RangeAttributes,
                            RTL_RANGE_LIST_ADD_IF_CONFLICT +
                                ((State->CurrentAlternative->Flags &
                                    ARBITER_ALTERNATIVE_FLAG_SHARED)?
                                        RTL_RANGE_LIST_ADD_SHARED : 0),
                            linkNode, // This line is different from the default function
                            State->Entry->PhysicalDeviceObject);

    ASSERT(NT_SUCCESS(status));
}

VOID
HalpArbBacktrackAllocation (
     IN PARBITER_INSTANCE Arbiter,
     IN PARBITER_ALLOCATION_STATE State
     )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    NTSTATUS                status;
    PLINK_NODE              linkNode;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(State);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    DEBUG_PRINT(3, ("Backtracking Irq (%04x) allocation for PDO %08x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject));

    linkNode = NULL;
    status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                State->Entry->PhysicalDeviceObject,
                                State->Entry->BusNumber,
                                State->Entry->SlotNumber,
                                &linkNode);
    if (NT_SUCCESS(status) && status == STATUS_SUCCESS)
    {
        if (linkNode)
        {
            if (linkNode->PossibleAllocation->RefCount == 0)
            {
                DEBUG_PRINT(1, ("Negative ref count during backtracking!"));
                ASSERT(linkNode->PossibleAllocation->RefCount);
            }
            else
            {
                DEBUG_PRINT(3, ("Backtracking Irq (%04x) allocation for Pci PDO %08x using link %02x", (ULONG)State->Start, State->Entry->PhysicalDeviceObject, linkNode->Link));

                linkNode->PossibleAllocation->RefCount--;
                if (linkNode->PossibleAllocation->RefCount == 0)
                {
                    linkNode->PossibleAllocation->Interrupt = 0;
                }
            }
        }
        else
        {
            DEBUG_PRINT(1, ("This should never happen!"));
            ASSERT(linkNode);
        }
    }

    //
    // Let the default function do most of the work.
    //

    ArbBacktrackAllocation(Arbiter, State);
}


NTSTATUS
HalpArbCommitAllocation(
    IN PARBITER_INSTANCE Arbiter
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE              current;
    PLINK_NODE              linkNode;
    NTSTATUS                status;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Program the int line register for all Pci devices.
    //

    FOR_ALL_RANGES(Arbiter->PossibleAllocation, &iterator, current)
    {
        if (current->UserData)
        {
            HalpProgramInterruptLine (  pciIrqRoutingInfo,
                                        current->Owner,
                                        (ULONG)current->Start);
        }
    }



    //
    // Program all links to their possible value if
    // there is a reference to them.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        status = HalpCommitLink(linkNode);
        if (!NT_SUCCESS(status))
        {
            return (status);
        }
    }

    //
    // Let the default function do the rest of the work.
    //

    return (ArbCommitAllocation(Arbiter));
}

NTSTATUS
HalpArbTestAllocation (
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    PLINK_NODE              linkNode;
    NTSTATUS                status;
    PARBITER_LIST_ENTRY     current;
    PDEVICE_OBJECT          previousOwner;
    PDEVICE_OBJECT          currentOwner;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE              currentRange;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(ArbitrationList);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Copy the allocation into the possible allocation for
    // for links.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        *linkNode->PossibleAllocation = *linkNode->Allocation;
    }

    previousOwner = NULL;

    FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, current)
    {
        currentOwner = current->PhysicalDeviceObject;

        if (previousOwner != currentOwner) {

            previousOwner = currentOwner;
            FOR_ALL_RANGES(Arbiter->Allocation, &iterator, currentRange)
            {
                        if (currentRange->Owner == currentOwner)
                        {
                            status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                                                        currentOwner,
                                                current->BusNumber,
                                                current->SlotNumber,
                                                                        &linkNode);
                            if (NT_SUCCESS(status) && status == STATUS_SUCCESS)
                            {
                                if (linkNode)
                                {
                                    if (linkNode->PossibleAllocation->RefCount > 0)
                                    {
                                DEBUG_PRINT(3, ("Decrementing link (%02x) usage to %d during test allocation", linkNode->Link, linkNode->PossibleAllocation->RefCount - 1));

                                linkNode->PossibleAllocation->RefCount--;
                                if (linkNode->PossibleAllocation->RefCount == 0)
                                {
                                    DEBUG_PRINT(3, ("Deleting Irq (%04x) allocation for link (%02x) during test allocation", linkNode->PossibleAllocation->Interrupt, linkNode->Link));
                                    linkNode->PossibleAllocation->Interrupt = 0;
                                }
                                    }
                                }
                            }
                        }
                }
        }
    }

    //
    // Let the default function do most of the work.
    //

    return (ArbTestAllocation(Arbiter, ArbitrationList));
}

NTSTATUS
HalpArbRetestAllocation (
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    PLINK_NODE              linkNode;
    NTSTATUS                status;
    PARBITER_LIST_ENTRY     current;
    PDEVICE_OBJECT          previousOwner;
    PDEVICE_OBJECT          currentOwner;
    RTL_RANGE_LIST_ITERATOR iterator;
    PRTL_RANGE                  currentRange;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(ArbitrationList);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Copy the allocation into the possible allocation for
    // for links.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        *linkNode->PossibleAllocation = *linkNode->Allocation;
    }

    previousOwner = NULL;

    FOR_ALL_IN_LIST(ARBITER_LIST_ENTRY, ArbitrationList, current)
    {
        currentOwner = current->PhysicalDeviceObject;

        if (previousOwner != currentOwner) {

            previousOwner = currentOwner;
            FOR_ALL_RANGES(Arbiter->Allocation, &iterator, currentRange)
            {
                        if (currentRange->Owner == currentOwner)
                        {
                            status = HalpFindLinkNode ( pciIrqRoutingInfo,
                                                                        currentOwner,
                                                current->BusNumber,
                                                current->SlotNumber,
                                                                        &linkNode);
                            if (NT_SUCCESS(status) && status == STATUS_SUCCESS)
                            {
                                if (linkNode)
                                {
                                    if (linkNode->PossibleAllocation->RefCount > 0)
                                    {
                                DEBUG_PRINT(3, ("Decrementing link (%02x) usage to %d during retest allocation", linkNode->Link, linkNode->PossibleAllocation->RefCount - 1));

                                linkNode->PossibleAllocation->RefCount--;
                                if (linkNode->PossibleAllocation->RefCount == 0)
                                {
                                    DEBUG_PRINT(3, ("Deleting Irq (%04x) allocation for link (%02x) during retest allocation", linkNode->PossibleAllocation->Interrupt, linkNode->Link));
                                    linkNode->PossibleAllocation->Interrupt = 0;
                                }
                                    }
                                }
                            }
                        }
                }
        }
    }

    return (ArbRetestAllocation(Arbiter, ArbitrationList));
}

NTSTATUS
HalpArbBootAllocation(
    IN PARBITER_INSTANCE Arbiter,
    IN OUT PLIST_ENTRY ArbitrationList
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    PLINK_NODE              linkNode;
    NTSTATUS                status;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);
    ASSERT(ArbitrationList);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Copy the allocation into the possible allocation for
    // for links.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        *linkNode->PossibleAllocation = *linkNode->Allocation;
    }

    status = ArbBootAllocation(Arbiter, ArbitrationList);

    //
    // Copy possible allocation back into allocation for links.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        *linkNode->Allocation = *linkNode->PossibleAllocation;
    }

    return status;
}

NTSTATUS
HalpArbRollbackAllocation (
    PARBITER_INSTANCE Arbiter
    )
{
    PPCI_IRQ_ROUTING_INFO   pciIrqRoutingInfo;
    PLINK_NODE              linkNode;
    ULONG                   interrupt;

    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Arbiter);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    pciIrqRoutingInfo = Arbiter->Extension;
    ASSERT(pciIrqRoutingInfo);
    ASSERT(pciIrqRoutingInfo == &HalpPciIrqRoutingInfo);

    //
    // Clear the possible allocation.
    //

    for (   linkNode = pciIrqRoutingInfo->LinkNodeHead;
            linkNode;
            linkNode = linkNode->Next)
    {
        linkNode->PossibleAllocation->Interrupt = 0;
        linkNode->PossibleAllocation->RefCount = 0;
    }

    //
    // Let the default function do rest of the work.
    //

    return (ArbRollbackAllocation(Arbiter));
}

NTSTATUS
HalpArbUnpackRequirement (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Minimum,
    OUT PULONGLONG Maximum,
    OUT PULONG Length,
    OUT PULONG Alignment
    )

/*++

    Routine Description:

        This routine unpacks the requirement descriptor into a minimum, maximum value
        and the length and its alignment.

    Input Parameters:

        Descriptor - Requirement to be unpacked.

        Minimum - Receives the minimum value for the requirement.

        Maximum - Receives the maximum value for this requirement.

        Length - Length of the requirement.

        Alignment - Alignment of this requirement.

    Return Value:

        Standard NT status value.

--*/

{
    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Descriptor);
    ASSERT(Minimum);
    ASSERT(Maximum);
    ASSERT(Length);
    ASSERT(Alignment);

    //
    // Make sure we are dealing with the correct resource.
    //

    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Do unpacking.
    //

    *Minimum = (ULONGLONG) Descriptor->u.Interrupt.MinimumVector;
    *Maximum = (ULONGLONG) Descriptor->u.Interrupt.MaximumVector;
    *Length = 1;
    *Alignment = 1;

    DEBUG_PRINT(3, ("Unpacking Irq requirement %p = 0x%04lx - 0x%04lx", Descriptor, *Minimum, *Maximum));

    return (STATUS_SUCCESS);
}

NTSTATUS
HalpArbPackResource (
    IN PIO_RESOURCE_DESCRIPTOR Requirement,
    IN ULONGLONG Start,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine packs the resource descriptor from a starting value and the requirement.

Input Parameters:

    Requirement - Resource requirement to be packed into the resource descriptor.

    Start - Starting value for this resource.

    Descriptor - Resource descriptor to be packed.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Requirement);
    ASSERT(Start < (ULONG)-1);
    ASSERT(Descriptor);

    //
    // Make sure we are dealing with the correct resource.
    //

    ASSERT(Requirement->Type == CmResourceTypeInterrupt);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    Descriptor->Type = CmResourceTypeInterrupt;
    Descriptor->Flags = Requirement->Flags;
    Descriptor->ShareDisposition = Requirement->ShareDisposition;
    Descriptor->u.Interrupt.Vector = (ULONG) Start;
    Descriptor->u.Interrupt.Level = (ULONG) Start;
    Descriptor->u.Interrupt.Affinity = 0xFFFFFFFF;

    DEBUG_PRINT(3, ("Packing Irq resource %p = 0x%04lx", Descriptor, (ULONG)Start));

    return (STATUS_SUCCESS);
}

NTSTATUS
HalpArbUnpackResource (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor,
    OUT PULONGLONG Start,
    OUT PULONG Length
    )

/*++

Routine Description:

    This routine unpacks the resource descriptor into a starting value and length.

Input Parameters:

    Descriptor - Resource descriptor to be unpacked.

    Start - Receives the starting value for this descriptor.

    Length - Receives the length of this resource.

Return Value:

    STATUS_SUCCESS.

--*/

{
    PAGED_CODE();

    //
    // Validate arguments.
    //

    ASSERT(Descriptor);
    ASSERT(Start);
    ASSERT(Length);

    //
    // Make sure we are dealing with the correct resource.
    //

    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Do unpacking.
    //

    *Start = Descriptor->u.Interrupt.Vector;
    *Length = 1;

    DEBUG_PRINT(3, ("Unpacking Irq resource %p = 0x%04lx", Descriptor, (ULONG)*Start));

    return (STATUS_SUCCESS);
}

LONG
HalpArbScoreRequirement (
    IN PIO_RESOURCE_DESCRIPTOR Descriptor
    )

/*++

Routine Description:

    This routine returns a score that indicates the flexibility of this
    device's requirements. Less flexible devices get low scores so that
    they get assigned resources before more flexible devices.

Input Parameters:

    Descriptor - Resource descriptor to be scored.

Return Value:

    Returns the score for the descriptor.

--*/

{
    LONG        score;

    PAGED_CODE();

    //
    // Validate argument.
    //

    ASSERT(Descriptor);

    //
    // Make sure we are dealing with the correct resource.
    //

    ASSERT(Descriptor->Type == CmResourceTypeInterrupt);

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Score is directly determined by number of irqs in the decriptor.
    //

    score = Descriptor->u.Interrupt.MaximumVector -
                Descriptor->u.Interrupt.MinimumVector + 1;

    DEBUG_PRINT(3, ("Scoring Irq resource %p = %i", Descriptor, score));

    return (score);
}

NTSTATUS
HalpInitIrqArbiter (
    IN PDEVICE_OBJECT   HalFdo
    )
{
    NTSTATUS            status;

    if (HalpArbiter.ArbiterState.MutexEvent)
    {
        return STATUS_SUCCESS;
    }

    DEBUG_PRINT(3, ("Initialzing Irq arbiter!"));

    status = ArbInitializeArbiterInstance(  &HalpArbiter.ArbiterState,
                                            HalFdo,
                                            CmResourceTypeInterrupt,
                                            L"HalIRQ",
                                            L"Root",
                                            NULL);

    if (NT_SUCCESS(status))
    {
        //
        // Make interrupts >= 16 unavailable.
        //

        status = RtlAddRange(   HalpArbiter.ArbiterState.Allocation,
                                16,
                                MAXULONG,
                                0,
                                RTL_RANGE_LIST_ADD_IF_CONFLICT,
                                NULL,
                                NULL);

        status = RtlAddRange(   HalpArbiter.ArbiterState.Allocation,
                                PIC_SLAVE_IRQ,
                                PIC_SLAVE_IRQ,
                                0,
                                RTL_RANGE_LIST_ADD_IF_CONFLICT,
                                NULL,
                                NULL);

        DEBUG_PRINT(1, ("Irq arbiter successfully initialized!"));
    }
    else
    {
        //
        // Keep us "uninitialized"
        //
        HalpArbiter.ArbiterState.MutexEvent = NULL;
        ASSERT(NT_SUCCESS(status));
    }

    return (status);
}

VOID
HalpIrqArbiterInterfaceReference(
    IN PVOID    Context
    )
{
    //HalPnpInterfaceReference
    PAGED_CODE();
    return;
}

VOID
HalpIrqArbiterInterfaceDereference(
    IN PVOID    Context
    )
{
    //HalPnpInterfaceDereference
    PAGED_CODE();
    return;
}

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
const ARBITER_INTERFACE ArbInterface = {
    sizeof(ARBITER_INTERFACE),//Size
    1,//Version
    &HalpArbiter.ArbiterState,//Context
    HalpIrqArbiterInterfaceReference,//InterfaceReference
    HalpIrqArbiterInterfaceDereference,//InterfaceDereference
    &ArbArbiterHandler,//ArbiterHandler
    0//Flags -- Do not set ARBITER_PARTIAL here
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

NTSTATUS
HalpFillInIrqArbiter (
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )
{
    *Length = sizeof(ARBITER_INTERFACE);
    if (InterfaceBufferSize < sizeof(ARBITER_INTERFACE)) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    *(PARBITER_INTERFACE)Interface = ArbInterface;

    DEBUG_PRINT(3, ("Providing Irq Arbiter for FDO %08x since Pci Irq Routing is enabled!", DeviceObject));
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixirql.asm
;
; Abstract:
;
;    This module implements the code necessary to raise and lower i386
;    Irql and dispatch software interrupts with the 8259 PIC.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    John Vert (jvert) 27-Nov-1991
;       Moved from kernel into HAL
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
        .list


        EXTRNP  _KeBugCheck,1,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT

        extrn   _HalpApcInterrupt:near
        extrn   _HalpDispatchInterrupt:near
        extrn   _KiUnexpectedInterrupt:near
        extrn   _HalpBusType:DWORD
        extrn   _HalpApcInterrupt2ndEntry:NEAR
        extrn   _HalpDispatchInterrupt2ndEntry:NEAR
        extrn   HalpSpecialDismissLevelTable:dword
        extrn   HalpSpecialDismissTable:dword
        extrn   _HalpEisaELCR:dword

;
; Initialization control words equates for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

OCW2_NON_SPECIFIC_EOI           equ     020H
OCW2_SPECIFIC_EOI               equ     060H
OCW2_SET_PRIORITY               equ     0c0H

PIC_SLAVE_IRQ                   equ     2
PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9

;
; Hardware irq active masks
;

IRQ_ACTIVE_MASK                 equ     0fffffff0h

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

;
; PICsInitializationString - Master PIC initialization command string
;

ifdef MCA

PICsInitializationString        dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string

else

PICsInitializationString   dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string
endif

            align   4
            public  KiI8259MaskTable
KiI8259MaskTable    label   dword
                dd      00000000000000000000000000000000B ; irql 0
                dd      00000000000000000000000000000000B ; irql 1
                dd      00000000000000000000000000000000B ; irql 2
                dd      00000000000000000000000000000000B ; irql 3
                dd      11111111100000000000000000000000B ; irql 4
                dd      11111111110000000000000000000000B ; irql 5
                dd      11111111111000000000000000000000B ; irql 6
                dd      11111111111100000000000000000000B ; irql 7
                dd      11111111111110000000000000000000B ; irql 8
                dd      11111111111111000000000000000000B ; irql 9
                dd      11111111111111100000000000000000B ; irql 10
                dd      11111111111111110000000000000000B ; irql 11
                dd      11111111111111111000000000000000B ; irql 12
                dd      11111111111111111100000000000000B ; irql 13
                dd      11111111111111111110000000000000B ; irql 14
                dd      11111111111111111111000000000000B ; irql 15
                dd      11111111111111111111100000000000B ; irql 16
                dd      11111111111111111111110000000000B ; irql 17
                dd      11111111111111111111111000000000B ; irql 18
                dd      11111111111111111111111000000000B ; irql 19
                dd      11111111111111111111111010000000B ; irql 20
                dd      11111111111111111111111011000000B ; irql 21
                dd      11111111111111111111111011100000B ; irql 22
                dd      11111111111111111111111011110000B ; irql 23
                dd      11111111111111111111111011111000B ; irql 24
                dd      11111111111111111111111011111000B ; irql 25
                dd      11111111111111111111111011111010B ; irql 26
                dd      11111111111111111111111111111010B ; irql 27
                dd      11111111111111111111111111111011B ; irql 28
                dd      11111111111111111111111111111011B ; irql 29
                dd      11111111111111111111111111111011B ; irql 30
                dd      11111111111111111111111111111011B ; irql 31

;
; This table is used to mask all pending interrupts below a given Irql
; out of the IRR
;
        align 4

        public FindHigherIrqlMask
FindHigherIrqlMask label dword
                dd    11111111111111111111111111111110B ; irql 0
                dd    11111111111111111111111111111100B ; irql 1 (APC)
                dd    11111111111111111111111111111000B ; irql 2 (DISPATCH)
                dd    11111111111111111111111111110000B ; irql 3
                dd    00000111111111111111111111110000B ; irql 4
                dd    00000011111111111111111111110000B ; irql 5
                dd    00000001111111111111111111110000B ; irql 6
                dd    00000000111111111111111111110000B ; irql 7
                dd    00000000011111111111111111110000B ; irql 8
                dd    00000000001111111111111111110000B ; irql 9
                dd    00000000000111111111111111110000B ; irql 10
                dd    00000000000011111111111111110000B ; irql 11
                dd    00000000000001111111111111110000B ; irql 12
                dd    00000000000000111111111111110000B ; irql 13
                dd    00000000000000011111111111110000B ; irql 14
                dd    00000000000000001111111111110000B ; irql 15
                dd    00000000000000000111111111110000B ; irql 16
                dd    00000000000000000011111111110000B ; irql 17
                dd    00000000000000000001111111110000B ; irql 18
                dd    00000000000000000001111111110000B ; irql 19
                dd    00000000000000000001011111110000B ; irql 20
                dd    00000000000000000001001111110000B ; irql 20
                dd    00000000000000000001000111110000B ; irql 22
                dd    00000000000000000001000011110000B ; irql 23
                dd    00000000000000000001000001110000B ; irql 24
                dd    00000000000000000001000000110000B ; irql 25
                dd    00000000000000000001000000010000B ; irql 26
                dd    00000000000000000000000000010000B ; irql 27
                dd    00000000000000000000000000000000B ; irql 28
                dd    00000000000000000000000000000000B ; irql 29
                dd    00000000000000000000000000000000B ; irql 30
                dd    00000000000000000000000000000000B ; irql 31

_TEXT   ENDS

_DATA   SEGMENT DWORD PUBLIC 'DATA'
        align   4
;
; The following tables define the addresses of software interrupt routers
;

;
; Use this table if there is NO machine state frame on stack already
;

        public  SWInterruptHandlerTable
SWInterruptHandlerTable label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt           ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2     ; irql 2
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 3
        dd      offset FLAT:HalpHardwareInterrupt00     ; 8259 irq#0
        dd      offset FLAT:HalpHardwareInterrupt01     ; 8259 irq#1
        dd      offset FLAT:HalpHardwareInterrupt02     ; 8259 irq#2
        dd      offset FLAT:HalpHardwareInterrupt03     ; 8259 irq#3
        dd      offset FLAT:HalpHardwareInterrupt04     ; 8259 irq#4
        dd      offset FLAT:HalpHardwareInterrupt05     ; 8259 irq#5
        dd      offset FLAT:HalpHardwareInterrupt06     ; 8259 irq#6
        dd      offset FLAT:HalpHardwareInterrupt07     ; 8259 irq#7
        dd      offset FLAT:HalpHardwareInterrupt08     ; 8259 irq#8
        dd      offset FLAT:HalpHardwareInterrupt09     ; 8259 irq#9
        dd      offset FLAT:HalpHardwareInterrupt10     ; 8259 irq#10
        dd      offset FLAT:HalpHardwareInterrupt11     ; 8259 irq#11
        dd      offset FLAT:HalpHardwareInterrupt12     ; 8259 irq#12
        dd      offset FLAT:HalpHardwareInterrupt13     ; 8259 irq#13
        dd      offset FLAT:HalpHardwareInterrupt14     ; 8259 irq#14
        dd      offset FLAT:HalpHardwareInterrupt15     ; 8259 irq#15

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

;
; Use this table if there is already a machine state frame on stack
;

        public  SWInterruptHandlerTable2
SWInterruptHandlerTable2 label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt2ndEntry   ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2ndEntry ; irql 2

;
; The following table picks up the highest pending software irq level
; from software irr
;

        public  SWInterruptLookUpTable
SWInterruptLookUpTable label byte
        db      0               ; SWIRR=0, so highest pending SW irql= 0
        db      0               ; SWIRR=1, so highest pending SW irql= 0
        db      1               ; SWIRR=2, so highest pending SW irql= 1
        db      1               ; SWIRR=3, so highest pending SW irql= 1
        db      2               ; SWIRR=4, so highest pending SW irql= 2
        db      2               ; SWIRR=5, so highest pending SW irql= 2
        db      2               ; SWIRR=6, so highest pending SW irql= 2
        db      2               ; SWIRR=7, so highest pending SW irql= 2

_TEXT   ENDS

_DATA   SEGMENT DWORD PUBLIC 'DATA'

ifdef IRQL_METRICS

        public HalRaiseIrqlCount
        public HalLowerIrqlCount
        public HalQuickLowerIrqlCount
        public HalApcSoftwareIntCount
        public HalDpcSoftwareIntCount
        public HalHardwareIntCount
        public HalPostponedIntCount
        public Hal8259MaskCount

HalRaiseIrqlCount       dd      0
HalLowerIrqlCount       dd      0
HalQuickLowerIrqlCount  dd      0
HalApcSoftwareIntCount  dd      0
HalDpcSoftwareIntCount  dd      0
HalHardwareIntCount     dd      0
HalPostponedIntCount    dd      0
Hal8259MaskCount        dd      0

endif
_DATA   ENDS

        page ,132
        subttl  "Raise Irql"

_TEXT$01   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING
;++
;
; KIRQL
; KfRaiseIrql (
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    Also, a mask will be used to mask off all the lower lever 8259
;    interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0, 0

        xor     eax, eax        ; Eliminate partial stall on return to caller
        mov     al, PCR[PcIrql]          ; (al) = Old Irql
        mov     PCR[PcIrql], cl          ; set new irql

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

if DBG
        cmp     al, cl                   ; old > new?
        ja      short Kri99              ; yes, go bugcheck

        fstRET  KfRaiseIrql

cPublicFpo 2, 2
Kri99:
        movzx   eax, al
        movzx   ecx, cl
        push    ecx                      ; put new irql where we can find it
        push    eax                      ; put old irql where we can find it
        mov     byte ptr PCR[PcIrql],0   ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
endif
        fstRET  KfRaiseIrql

fstENDP KfRaiseIrql

;++
;
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        xor     eax, eax                ; Eliminate partial stall
        mov     al, PCR[PcIrql]         ; (al) = Old Irql
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL    ; set new irql

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, DISPATCH_LEVEL      ; old > new?
        ja      short Krid99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToDpcLevel

if DBG
cPublicFpo 0,1
Krid99: movzx   eax, al
        push    eax                     ; put old irql where we can find it
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
        stdRET  _KeRaiseIrqlToDpcLevel
endif

stdENDP _KeRaiseIrqlToDpcLevel


;++
;
; KIRQL
; KeRaiseIrqlToSynchLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0
cPublicFpo 0, 0

        xor     eax, eax                ; Eliminate partial stall
        mov     al, PCR[PcIrql]         ; (al) = Old Irql
        mov     byte ptr PCR[PcIrql], SYNCH_LEVEL    ; set new irql

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, SYNCH_LEVEL         ; old > new?
        ja      short Kris99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToSynchLevel

if DBG
cPublicFpo 0,1
Kris99: movzx   eax, al
        push    eax                     ; put old irql where we can find it
        stdCall   _KeBugCheck, <IRQL_NOT_GREATER_OR_EQUAL>        ; never return
        stdRET  _KeRaiseIrqlToSynchLevel
endif

stdENDP _KeRaiseIrqlToSynchLevel

;++
;
; VOID
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KfLowerIrql,1
cPublicFpo 0, 0
        and     ecx, 0ffh

ifdef IRQL_METRICS
        inc     HalLowerIrqlCount
endif

if DBG
        cmp     cl,PCR[PcIrql]          ; Make sure we are not lowering to
        ja      KliBug                  ; ABOVE current level
endif
        pushfd
        cli
        mov     PCR[PcIrql], ecx
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jnz     short Kli10                     ; go dispatch pending interrupts

;
; no interrupts pending, return quickly.
;

        popfd

ifdef IRQL_METRICS
        inc     HalQuickLowerIrqlCount
endif
        fstRET    KfLowerIrql

cPublicFpo 1, 1
align 4
Kli10:

;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Kli40

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 1, 0
        fstRET    KfLowerIrql

Kli40:
;
; Clear all the interrupt masks
;

         mov     eax, PCR[PcIDR]
        SET_8259_MASK

        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 1, 0
        fstRET    KfLowerIrql

if DBG
cPublicFpo 1, 2
KliBug:
        push    ecx                             ; new irql for debugging
        push    PCR[PcIrql]                     ; old irql for debugging
        mov     byte ptr PCR[PcIrql],HIGH_LEVEL   ; avoid recursive error
        stdCall   _KeBugCheck, <IRQL_NOT_LESS_OR_EQUAL>   ; never return
endif

fstENDP KfLowerIrql

;++
;
; VOID
; HalEndSystemInterrupt
;    IN KIRQL NewIrql,
;    IN ULONG Vector
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Vector - Vector number of the interrupt
;
;    Note that esp+12 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HeiNewIrql      equ     [esp + 4]

cPublicProc _HalEndSystemInterrupt  ,2
cPublicFpo 2, 0

        xor     ecx, ecx
        mov     cl, byte ptr HeiNewIrql         ; get new irql value

ifdef IRQL_METRICS
        inc     HalLowerIrqlCount
endif

        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        mov     PCR[PcIrql], ecx
        jnz     short Hei10                     ; go dispatch pending interrupts

;
; no interrupts pending, return quickly.
;


ifdef IRQL_METRICS
        inc      HalQuickLowerIrqlCount
endif
        stdRET    _HalEndSystemInterrupt

align 4
Hei10:

;
; If there is any delayed hardware interrupt being serviced, we leave
; the interrupt masked and simply return.
;

        test    PCR[PcIrrActive], IRQ_ACTIVE_MASK
        jnz     short Hei50

        bsr     ecx, edx                        ; (eax) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jle     short Hei40

;
; Clear all the interrupt masks
;

align 4
Hei15:
        mov     eax, PCR[PcIDR]
        SET_8259_MASK
;
; The pending interrupt is a hardware interrupt.  To prevent the delayed
; interrupts from overflowing stack, we check if the pending level is already
; active.  If yes, we simply return and let the higher level EndSystemInterrupt
; handle it.
;
; (ecx) = pending vector
;

        mov     edx, 1
        shl     edx, cl
        test    PCR[PcIrrActive], edx           ; if the pending int is being
                                                ; processed, just return.
        jne     short Hei50
        or      PCR[PcIrrActive], edx           ; Set Active bit
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Note, it destroys eax
        xor     PCR[PcIrrActive], edx           ; Clear bit in ActiveIrql
        mov     eax, PCR[PcIRR]                 ; Reload IRR
        mov     ecx, PCR[PcIrql]
        and     eax, FindHigherIrqlMask[ecx*4]  ; Is any interrupt pending
        jz      short Hei50                     ; (Most time it will be zero.)
        bsr     ecx, eax                        ; (edx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Hei15

Hei40:

;
; The pending interrupt is at Software Level.  We simply make current
; interrupt frame the new pending software interrupt's frame and
; jmp to the handler routine.
;

        add     esp, 12
        jmp     SWInterruptHandlerTable2[ecx*4] ; Note, it destroys eax


Hei50:
        stdRET    _HalEndSystemInterrupt

stdENDP _HalEndSystemInterrupt

;++
;
; VOID
; HalpEndSoftwareInterrupt
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL from software interrupt
;    leverl to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+8 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HesNewIrql      equ     [esp + 4]

cPublicProc _HalpEndSoftwareInterrupt  ,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HesNewIrql        ; get new irql value
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        mov     PCR[PcIrql], ecx
        jnz     short Hes10

        stdRET    _HalpEndSoftwareInterrupt

align 4
Hes10:
;
; Check if any delayed hardware interrupt is being serviced.  If yes, we
; simply return.
;

        test    PCR[PcIrrActive], IRQ_ACTIVE_MASK
        jnz     short Hes90

;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        ja      short Hes20

;
; Pending interrupt is a soft interrupt. Recycle stack frame
;

        add     esp, 8
        jmp     SWInterruptHandlerTable2[ecx*4] ; Note, it destroys eax

Hes20:
;
; Clear all the interrupt masks
;

        mov     eax, PCR[PcIDR]
        SET_8259_MASK

;
; (ecx) = Pending level
;

        mov     edx, 1
        shl     edx, cl

        or      PCR[PcIrrActive], edx           ; Set Active bit
        xor     PCR[PcIRR], edx                 ; clear bit in IRR

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.

        xor     PCR[PcIrrActive], edx           ; Clear bit in ActiveIrql

        movzx   ecx, byte ptr HesNewIrql        ; get new irql value
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jnz     short Hes10

Hes90:  stdRET  _HalpEndSoftwareInterrupt

stdENDP _HalpEndSoftwareInterrupt

        page ,132
        subttl  "DispatchInterrupt 2"

;++
;
; VOID
; HalpDispatchInterrupt2(
;       VOID
;       );
;
; Routine Description:
;
;   The functional description is the same as HalpDispatchInterrupt.
;
;   This function differs from HalpDispatchInterrupt in how it has been
;   optimized.  This function is optimized for dispatching dispatch interrupts
;   for LowerIrql, ReleaseSpinLock, and RequestSoftwareInterrupt.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    (edx) = 1 shl DISPATCH_LEVEL
;
; Warnings:
;
;   Not all SW int handles this hal uses save all the registers
;   callers to SWInterruptHandler for H/W interrupts assume that
;   ONLY EAX & ECX are destroyed.
;
;   Note: this function saves EBX since KiDispatchInterrupt uses
;   the value without preserving it.
;--

cPublicProc _HalpDispatchInterrupt2
cPublicFpo 0, 2

        xor     ecx, ecx
        and     dword ptr PCR[PcIRR], not (1 shl DISPATCH_LEVEL) ; clear the pending bit in IRR

        mov     cl, PCR[PcIrql]

        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL; set new irql
        push    ecx                             ; Save OldIrql

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;
        sti

        push    ebx
        stdCall _KiDispatchInterrupt            ; Handle DispatchInterrupt
        pop     ebx
        pop     ecx                             ; (ecx) = OldIrql
        mov     edx, 1 shl DISPATCH_LEVEL

        cli

        mov     eax, PCR[PcIRR]
        mov     PCR[PcIrql], ecx                ; restore current irql

        and     eax, FindHigherIrqlMask[ecx*4]  ; (eax) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.

        jnz     short diq10                     ; go dispatch pending interrupts
        stdRET  _HalpDispatchInterrupt2

diq10:
;
; If there is a pending hardware interrupt, then the PICs have been
; masked to reflect the actual Irql.
;

        bsr     ecx, eax                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jbe     short diq20

;
; Clear all the interrupt masks
;

        mov     eax, PCR[PcIDR]
        SET_8259_MASK

        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR

diq20:
;
; (ecx) = Pending level
;

        jmp     SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
diq90:  stdRET  _HalpDispatchInterrupt2

stdENDP _HalpDispatchInterrupt2

        page ,132
        subttl  "Get current irql"

;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0
cPublicFpo 0, 0

        movzx   eax, byte ptr PCR[PcIrql]   ; Current irql is in the PCR
        stdRET    _KeGetCurrentIrql
stdENDP _KeGetCurrentIrql



;++
;
; KIRQL
; HalpDisableAllInterrupts (VOID)
;
; Routine Description:
;
;   This routine is called during a system crash.  The hal needs all
;   interrupts disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Old Irql level
;
;--

cPublicProc _HalpDisableAllInterrupts,0
cPublicFpo 0, 0

    ;
    ; Mask interrupts off at PIC
    ; (raising to high_level does not work on lazy irql implementation)
    ;
        mov     eax, KiI8259MaskTable[HIGH_LEVEL*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

        mov     al, byte ptr PCR[PcIrql]
        mov     byte ptr PCR[PcIrql], HIGH_LEVEL   ; set new irql

        stdRET  _HalpDisableAllInterrupts

stdENDP _HalpDisableAllInterrupts

;++
;
; VOID
; HalpReenableInterrupts (
;     IN KIRQL Irql
;     )
;
; Routine Description:
;
;   This routine restores the PIC to a given state.
;
; Arguments:
;
;    Irql - Irql state to restore to.
;
; Return Value:
;
;    None
;
;--

HriNewIrql      equ     [esp + 4]

cPublicProc _HalpReenableInterrupts,1
cPublicFpo 1, 0

        mov     al, HriNewIrql
        mov     byte ptr PCR[PcIrql],al ; set new irql

        mov     eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

        stdRET  _HalpReenableInterrupts

stdENDP _HalpReenableInterrupts

        page ,132
        subttl  "Postponed Hardware Interrupt Dispatcher"
;++
;
; VOID
; HalpHardwareInterruptNN (
;       VOID
;       );
;
; Routine Description:
;
;    These routines branch through the IDT to simulate the appropriate
;    hardware interrupt.  They use the "INT nn" instruction to do this.
;
; Arguments:
;
;    None.
;
; Returns:
;
;    None.
;
; Environment:
;
;    IRET frame is on the stack
;
;--
cPublicProc _HalpHardwareInterruptTable, 0
cPublicFpo 0,0

        public HalpHardwareInterrupt00
HalpHardwareInterrupt00 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 0
        ret

        public HalpHardwareInterrupt01
HalpHardwareInterrupt01 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 1
        ret

        public HalpHardwareInterrupt02
HalpHardwareInterrupt02 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 2
        ret

        public HalpHardwareInterrupt03
HalpHardwareInterrupt03 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 3
        ret

        public HalpHardwareInterrupt04
HalpHardwareInterrupt04 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 4
        ret

        public HalpHardwareInterrupt05
HalpHardwareInterrupt05 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 5
        ret

        public HalpHardwareInterrupt06
HalpHardwareInterrupt06 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 6
        ret

        public HalpHardwareInterrupt07
HalpHardwareInterrupt07 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 7
        ret

        public HalpHardwareInterrupt08
HalpHardwareInterrupt08 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 8
        ret

        public HalpHardwareInterrupt09
HalpHardwareInterrupt09 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 9
        ret

        public HalpHardwareInterrupt10
HalpHardwareInterrupt10 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 10
        ret

        public HalpHardwareInterrupt11
HalpHardwareInterrupt11 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 11
        ret

        public HalpHardwareInterrupt12
HalpHardwareInterrupt12 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 12
        ret

        public HalpHardwareInterrupt13
HalpHardwareInterrupt13 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 13
        ret

        public HalpHardwareInterrupt14
HalpHardwareInterrupt14 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 14
        ret

        public HalpHardwareInterrupt15
HalpHardwareInterrupt15 label byte
ifdef IRQL_METRICS
        lock inc HalHardwareIntCount
endif
        int     PRIMARY_VECTOR_BASE + 15
        ret

        public HalpHardwareInterruptLevel
HalpHardwareInterruptLevel label byte
cPublicFpo 0,0
        xor     eax, eax
        mov     al,  PCR[PcIrql]
        mov     ecx, PCR[PcIRR]
        and     ecx, FindHigherIrqlMask[eax*4]  ; (ecx) is the bitmask of
                                                ; pending interrupts we need to
                                                ; dispatch now.
        jz      short lvl_90    ; no pending ints

        test    PCR[PcIrrActive], IRQ_ACTIVE_MASK
        jnz     short lvl_90    ; let guy furture down the stack handle it

        mov     eax, ecx                        ; (eax) = bitmask
        bsr     ecx, eax                        ; (cl) = set bit

        mov     eax, 1
        shl     eax, cl
        xor     PCR[PcIRR], eax                 ; clear bit in IRR

        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
align 4
lvl_90:
        ret

stdENDP _HalpHardwareInterruptTable


_TEXT$01   ends

        page ,132
        subttl  "Interrupt Controller Chip Initialization"

_TEXT$02   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING
;++
;
; VOID
; HalpInitializePICs (
;    BOOLEAN EnableInterrupts
;    )
;
; Routine Description:
;
;    This routine sends the 8259 PIC initialization commands and
;    masks all the interrupts on 8259s.
;
; Arguments:
;
;    EnableInterrupts - If this is true, then this function will
;                       explicitly enable interrupts at the end,
;                       as it always did in the past.  If this
;                       is false, then it will preserve the interrupt
;                       flag.
;
; Return Value:
;
;    None.
;
;--

EnableInterrupts equ [esp + 0ch]

cPublicProc _HalpInitializePICs       ,1
cPublicFpo 0, 0

        push    esi                             ; save caller's esi
        pushfd
        cli                                     ; disable interrupt
        
        lea     esi, PICsInitializationString
        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        mov     al, 0FFH                        ; mask all 8259 irqs
        out     dx,al                           ; write mask to PIC
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

;
; Read EISA defined ELCR.  If it looks good save it away.
; If a PCI interrupts is later connected, the vector will
; be assumed level if it's in the ELCR.
;
        mov     edx, 4d1h               ; Eisa Edge/Level port
        in      al, dx                  ; get e/l irq 8-f
        mov     ah, al
        dec     edx
        in      al, dx                  ; get e/l irq 0-7
        and     eax, 0def8h             ; clear reserved bits
        cmp     eax, 0def8h             ; all set?
        je      short Hip50             ; Yes, register not implemented

        mov     _HalpEisaELCR, eax      ; Save possible ELCR settings


;
; If this is an EISA machine, mark all interrupts in the EISA ELCR
; as level interrupts
;
        cmp     _HalpBusType, MACHINE_TYPE_EISA
        jne     short Hip50

;
; Verify this isn't an OPTI chipset machine which claims to be
; EISA, but neglects to follow the EISA spec...
;

        mov     edx, 0481h      ; DmaPageHighPort.Channel2
        mov     al, 055h
        out     dx, al          ; out to Eisa DMA register
        in      al, dx          ; read it back
        cmp     al, 055h        ; if it doesn't stick, then machine
        jne     short Hip50     ; isn't support all eisa registers

;
; Ok - loop and mark all EISA level interrupts
;

        mov     eax, _HalpEisaELCR
        xor     ecx, ecx                        ; start at irq 0
Hip30:
        test    eax, 1                          ; is level bit set?
        jz      short Hip40                     ; no, go to next

;
; Found a level sensitive interrupt:
;   Set the SWInterruptHandler for the irql to be a NOP.
;   Set the SpecialDismiss entry for the irq to be the level version
;
        mov     SWInterruptHandlerTable+4*4[ecx], offset HalpHardwareInterruptLevel

        mov     edx, HalpSpecialDismissLevelTable[ecx]
        mov     HalpSpecialDismissTable[ecx], edx

Hip40:
        add     ecx, 4                          ; next vector
        shr     eax, 1                          ; shift bits down
        jnz     short Hip30                     ; more set bits, then loop


Hip50:
        mov     al, EnableInterrupts
        .if     (al != 0)
        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts
        .endif
        popfd
        pop     esi                             ; restore caller's esi
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs


_TEXT$02   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixinfo.c ===
/*++

Copyright (c) 1991-2000  Microsoft Corporation

Module Name:

    ixinfo.c

Abstract:

Author:

    Ken Reneris (kenr)  08-Aug-1994

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"
#include "pci.h"
#include "pcip.h"

#ifdef _PNP_POWER_
HAL_CALLBACKS   HalCallback;
extern WCHAR    rgzSuspendCallbackName[];

VOID
HalInitSystemPhase2 (
    VOID
    );

VOID
HalpLockSuspendCode (
    IN PVOID    CallbackContext,
    IN PVOID    Argument1,
    IN PVOID    Argument2
    );
#endif

NTSTATUS
HalpQueryInstalledBusInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HaliQuerySystemInformation)
#pragma alloc_text(PAGE,HaliSetSystemInformation)
#pragma alloc_text(INIT,HalInitSystemPhase2)

#ifdef _PNP_POWER_
#pragma alloc_text(PAGE,HalpLockSuspendCode)
#endif

#endif

//
// HalQueryMcaInterface
//

VOID
HalpMcaLockInterface(
    VOID
    );

VOID
HalpMcaUnlockInterface(
    VOID
    );

NTSTATUS
HalpMcaReadRegisterInterface(
    IN     UCHAR           BankNumber,
    IN OUT PMCA_EXCEPTION  Exception
    );

#ifdef ACPI_HAL
extern PHYSICAL_ADDRESS HalpMaxHotPlugMemoryAddress;
#endif

#if defined(ACPI_HAL) && defined(_HALPAE_) && !defined(NT_UP)

extern PVOID HalpAcpiSrat;

NTSTATUS
HalpGetAcpiStaticNumaTopology(
    HAL_NUMA_TOPOLOGY_INTERFACE * NumaInfo
    );

#endif

VOID
HalInitSystemPhase2 (
    VOID
    )
{
#ifdef _PNP_POWER_
    OBJECT_ATTRIBUTES               ObjectAttributes;
    NTSTATUS                        Status;
    UNICODE_STRING                  unicodeString;
    PCALLBACK_OBJECT                CallbackObject;

    //
    // Create hal callbacks
    //

    InitializeObjectAttributes(
        &ObjectAttributes,
        NULL,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );


    ExCreateCallback (&HalCallback.SetSystemInformation, &ObjectAttributes, TRUE, TRUE);
    ExCreateCallback (&HalCallback.BusCheck, &ObjectAttributes, TRUE, TRUE);

    //
    // Connect to suspend callback to lock hal hibaration code
    //

    RtlInitUnicodeString(&unicodeString, rgzSuspendCallbackName);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
    );

    Status = ExCreateCallback (&CallbackObject, &ObjectAttributes, FALSE, FALSE);

    if (NT_SUCCESS(Status)) {
        ExRegisterCallback (
            CallbackObject,
            HalpLockSuspendCode,
            NULL
            );

        ObDereferenceObject (CallbackObject);
    }
#endif
}


#if defined(_HALPAE_) && !defined(NT_UP)

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    );

ULONG HalpFakeNumaNodes;
ULONG HalpFakeNumaAffinity;
ULONG HalpFakeNumaAffinityShift;
ULONG HalpFakeNumaPageMask;
ULONG HalpFakeNumaPageShift;

ULONG
HalpFakeNumaQueryPageToNode(
    IN ULONG_PTR PhysicalPageNumber
    )
{
    ULONG Node;

    Node = (ULONG)PhysicalPageNumber >> HalpFakeNumaPageShift;
    Node &= HalpFakeNumaPageMask;
    return Node;
}

NTSTATUS
HalpFakeNumaQueryProcessorNode(
    IN  ULONG   ProcessorNumber,
    OUT PUSHORT ProcessorId,
    OUT PUCHAR  NodeNumber
    )
{
    NTSTATUS Status;
    KAFFINITY ProcessorMask;
    KAFFINITY Mask;
    UCHAR Node;
    USHORT ApicId;

#if defined(APIC_HAL) && !defined(NT_UP)

    Status = HalpGetApicIdByProcessorNumber((UCHAR)ProcessorNumber, &ApicId);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    *ProcessorId = ApicId;

#else

    *ProcessorId = (USHORT)ProcessorNumber;
    Status = STATUS_SUCCESS;

#endif

    ProcessorMask = 1 << ProcessorNumber;
    for (Node = 0; Node < HalpFakeNumaNodes; Node++) {
        Mask = HalpFakeNumaAffinity << (Node * HalpFakeNumaAffinityShift);
        if ((Mask & ProcessorMask) != 0) {
            *NodeNumber = Node;
            break;
        }
    }

    return Status;
}

#endif


NTSTATUS
HaliQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    NTSTATUS    Status;
    PVOID       InternalBuffer;
    ULONG       Length;
    union {
        HAL_POWER_INFORMATION               PowerInf;
        HAL_PROCESSOR_SPEED_INFORMATION     ProcessorInf;
        MCA_EXCEPTION                       McaException;
        HAL_DISPLAY_BIOS_INFORMATION        DisplayBiosInf;
    } U;

    BOOLEAN     bUseFrameBufferCaching;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    *ReturnedLength = 0;
    Length = 0;

    switch (InformationClass) {
#ifndef ACPI_HAL
        case HalInstalledBusInformation:
            Status = HalpQueryInstalledBusInformation (
                        Buffer,
                        BufferSize,
                        ReturnedLength
                        );
            break;
#endif
        case HalFrameBufferCachingInformation:

            // Note - we want to return TRUE here to enable USWC in all
            // cases except in a "Shared Memory Cluster" machine.
            bUseFrameBufferCaching = TRUE;
            InternalBuffer = &bUseFrameBufferCaching;
            Length = sizeof (BOOLEAN);
            break;


        case HalMcaLogInformation:
            InternalBuffer = &U.McaException;
            Status = HalpGetMcaLog ((PMCA_EXCEPTION)Buffer,
                                    BufferSize,
                                    ReturnedLength);
            break;

#if !defined(_WIN64)
        case HalDisplayBiosInformation:
            InternalBuffer = &U.DisplayBiosInf;
            Length = sizeof(U.DisplayBiosInf);
            U.DisplayBiosInf = HalpGetDisplayBiosInformation ();
            break;
#endif

#ifdef _PNP_POWER_
        case HalPowerInformation:
            RtlZeroMemory (&U.PowerInf, sizeof(HAL_POWER_INFORMATION));

            InternalBuffer = &U.PowerInf;
            Length = sizeof (HAL_POWER_INFORMATION);
            break;


        case HalProcessorSpeedInformation:
            RtlZeroMemory (&U.ProcessorInf, sizeof(HAL_POWER_INFORMATION));

            U.ProcessorInf.MaximumProcessorSpeed = 100;
            U.ProcessorInf.CurrentAvailableSpeed = 100;
            U.ProcessorInf.ConfiguredSpeedLimit  = 100;

            InternalBuffer = &U.PowerInf;
            Length = sizeof (HAL_PROCESSOR_SPEED_INFORMATION);
            break;

        case HalCallbackInformation:
            InternalBuffer = &HalCallback;
            Length = sizeof (HAL_CALLBACKS);
            break;
#endif

#if defined(_HALPAE_) && !defined(NT_UP)

        case HalNumaTopologyInterface:
            if ((BufferSize == sizeof(HAL_NUMA_TOPOLOGY_INTERFACE)) &&
                (HalPaeEnabled() == TRUE)) {

                Status = STATUS_INVALID_LEVEL;

#if defined(ACPI_HAL)

                if (HalpAcpiSrat) {
                    Status = HalpGetAcpiStaticNumaTopology(Buffer);
                    if (NT_SUCCESS(Status)) {
                        *ReturnedLength = sizeof(HAL_NUMA_TOPOLOGY_INTERFACE);
                    }
                    break;
                }
#endif

                //
                // Mega Kludge:
                //
                // Testing Testing Testing.    MM may supply a
                // fake NUMA configuration for testing purposes.
                // In this case information is passed IN to the
                // HAL using this query only interface by passing
                // information in the output buffer and in the
                // returned length field.
                //
                // The returned length field will have been
                // initialized to the special value 'NUMA', in
                // this case, the incoming information buffer
                // contains the NUMA configuration.
                //

                if (HalpFakeNumaNodes == 0) {

                    struct {
                        ULONG Nodes:3;
                        ULONG AffinityShift:6;
                        ULONG PageShift:6;
                        ULONG Signature:17;
                        ULONG Affinity;
                        ULONG Mask;
                    } Fake;

                    ULONG ValidateNodes;
                    ULONG ValidateAffinity1;
                    ULONG ValidateAffinity2;

                    RtlCopyMemory(&Fake, Buffer, sizeof(Fake));

                    //
                    // Do a little validation.
                    //

                    if ((Fake.Signature != 0x15a5a) ||
                        (Fake.Nodes == 0) ||
                        ((Fake.AffinityShift | Fake.PageShift) & 0x20) ||
                        (Fake.Affinity == 0) ||
                        (Fake.Mask == 0) ||
                        (Fake.Mask >= Fake.Nodes)) {
                        Status = STATUS_INVALID_LEVEL;
                        break;
                    }

                    HalpFakeNumaAffinity = Fake.Affinity;
                    HalpFakeNumaAffinityShift = Fake.AffinityShift;
                    HalpFakeNumaPageMask = Fake.Mask;
                    HalpFakeNumaPageShift = Fake.PageShift;

                    //
                    // Generate the affinity mask for each node and
                    // make sure there's no overlapping affinity masks.
                    //

                    ValidateNodes = Fake.Nodes;
                    ValidateAffinity1 = 0;
                    ValidateAffinity2 = 0;
                    while (ValidateNodes) {
                        ValidateNodes--;
                        ValidateAffinity1 = HalpFakeNumaAffinity <<
                                (HalpFakeNumaAffinityShift * ValidateNodes);
                        if (ValidateAffinity1 == 0) {
                            break;
                        }
                        if ((ValidateAffinity1 & ValidateAffinity2) != 0) {
                            ValidateAffinity1 = 0;
                            break;
                        }
                        ValidateAffinity2 |= ValidateAffinity1;
                    }

                    if (!ValidateAffinity1) {
                        Status = STATUS_INVALID_LEVEL;
                        break;
                    }

                    HalpFakeNumaNodes = Fake.Nodes;
                }

                //
                // End Mega Kludge.
                //

                if ((HalPaeEnabled() == TRUE)       &&
                   (HalpFakeNumaNodes != 0)         &&
                   (HalpFakeNumaAffinity != 0)      &&
                   (HalpFakeNumaAffinityShift != 0) &&
                   (HalpFakeNumaPageMask != 0)      &&
                   (HalpFakeNumaPageShift != 0)        ) {

                    //
                    // Pretend we have a numa configuration,...
                    // for testing purposes only.
                    //

                    HAL_NUMA_TOPOLOGY_INTERFACE * NumaInfo;
                    NumaInfo = (HAL_NUMA_TOPOLOGY_INTERFACE *)Buffer;

                    NumaInfo->NumberOfNodes = HalpFakeNumaNodes;
                    NumaInfo->QueryProcessorNode = HalpFakeNumaQueryProcessorNode;
                    NumaInfo->PageToNode = HalpFakeNumaQueryPageToNode;
                    *ReturnedLength = sizeof(HAL_NUMA_TOPOLOGY_INTERFACE);
                    Status = STATUS_SUCCESS;
                }

            } else {

                //
                // Buffer size is wrong, we could return valid data
                // if the buffer is too big,.... but instead we will
                // use this as an indication that we're not compatible
                // with the kernel.
                //

                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

#endif

        case HalQueryMcaInterface:
            if (BufferSize == sizeof(HAL_MCA_INTERFACE)) {
                HAL_MCA_INTERFACE *McaInterface;

                McaInterface = (HAL_MCA_INTERFACE *)Buffer;
                McaInterface->Lock         = HalpMcaLockInterface;
                McaInterface->Unlock       = HalpMcaUnlockInterface;
                McaInterface->ReadRegister = HalpMcaReadRegisterInterface;

                *ReturnedLength = sizeof(HAL_MCA_INTERFACE);
                Status = STATUS_SUCCESS;
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        case HalQueryMaxHotPlugMemoryAddress:
            if (BufferSize == sizeof(PHYSICAL_ADDRESS)) {
#ifdef ACPI_HAL
                *((PPHYSICAL_ADDRESS) Buffer) = HalpMaxHotPlugMemoryAddress;
                *ReturnedLength = sizeof(PHYSICAL_ADDRESS);
                Status = STATUS_SUCCESS;
#else
                Status = STATUS_NOT_IMPLEMENTED;
#endif
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        case HalQueryAMLIIllegalIOPortAddresses:
        {
            HAL_AMLI_BAD_IO_ADDRESS_LIST BadIOAddrList[] =
                        {
                            {0x000,  0x10,  0x1, NULL                           }, // ISA DMA
                            {0x020,  0x2,   0x0, NULL                           }, // PIC
                            {0x040,  0x4,   0x1, NULL                           }, // Timer1, Referesh, Speaker, Control Word
                            {0x048,  0x4,   0x1, NULL                           }, // Timer2, Failsafe
                            {0x070,  0x2,   0x1, NULL                           }, // Cmos/NMI enable
                            {0x074,  0x3,   0x1, NULL                           }, // Extended Cmos
                            {0x081,  0x3,   0x1, NULL                           }, // DMA
                            {0x087,  0x1,   0x1, NULL                           }, // DMA
                            {0x089,  0x1,   0x1, NULL                           }, // DMA
                            {0x08a,  0x2,   0x1, NULL                           }, // DMA
                            {0x08f,  0x1,   0x1, NULL                           }, // DMA
                            {0x090,  0x2,   0x1, NULL                           }, // Arbritration Control Port, Card Select Feedback
                            {0x093,  0x2,   0x1, NULL                           }, // Reserved, System board setup
                            {0x096,  0x2,   0x1, NULL                           }, // POS channel select
                            {0x0A0,  0x2,   0x0, NULL                           }, // Cascaded PIC
                            {0x0C0,  0x20,  0x1, NULL                           }, // ISA DMA
                            {0x4D0,  0x2,   0x0, NULL                           }, // Edge, level control registers for PIC
                            {0xCF8,  0x8,   0x1, &HaliHandlePCIConfigSpaceAccess}, // PCI Config Space Access Pair
                            {0x0,    0x0,   0x0, NULL                           }
                        };

            if(BufferSize < sizeof(BadIOAddrList))
            {
                *ReturnedLength = sizeof(BadIOAddrList);
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            else
            {
                Length = sizeof(BadIOAddrList);
                InternalBuffer = BadIOAddrList;
                Status = STATUS_SUCCESS;
            }
            break;
        }

        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    //
    // If non-zero Length copy data to callers buffer
    //

    if (Length) {
        if (BufferSize < Length) {
            Length = BufferSize;
        }

        *ReturnedLength = Length;
        RtlCopyMemory (Buffer, InternalBuffer, Length);
    }

    return Status;
}

NTSTATUS
HaliSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
{
    NTSTATUS    Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    switch (InformationClass) {

        case HalMcaRegisterDriver:
            Status =  HalpMcaRegisterDriver(
                (PMCA_DRIVER_INFO) Buffer  // Info about registering driver
            );
            break;

        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    return Status;
}



#ifdef _PNP_POWER_

VOID
HalpLockSuspendCode (
    IN PVOID    CallbackContext,
    IN PVOID    Argument1,
    IN PVOID    Argument2
    )
{
    static PVOID    CodeLock;

    switch ((ULONG) Argument1) {
        case 0:
            //
            // Lock code down which might be needed to perform a suspend
            //

            ASSERT (CodeLock == NULL);
            CodeLock = MmLockPagableCodeSection (&HaliSuspendHibernateSystem);
            break;

        case 1:
            //
            // Release the code lock
            //

            MmUnlockPagableImageSection (CodeLock);
            CodeLock = NULL;
            break;
    }
}

#endif

/***  HaliHandlePCIConfigSpaceAccess - Check to see if the Firmware is attempting to 
 *                                     access to PCI Config space. If so, intercept 
 *                                     the read/write call and do it using HAL API's. 
 *                                     This way we can make these calls sync.
 *
 *  ENTRY
 *      BOOLEAN Read  - TRUE iff read 
 *      ULONG   Addr  - Address to do the operation on
 *      ULONG   Size  - Size of data
 *      PULONG  pData - Pointer to the data buffer.
 *      
 *  EXIT
 *      STATUS_SUCCESS if we do the PCI config space access.
 */
NTSTATUS HaliHandlePCIConfigSpaceAccess( BOOLEAN Read, 
                                                       ULONG   Addr,
                                                       ULONG   Size, 
                                                       PULONG  pData
                                                     )
{
    static      PCI_TYPE1_CFG_BITS CF8_Data = {0};
    static      BOOLEAN CF8_Called = FALSE;
    NTSTATUS    Status = STATUS_SUCCESS;
    
    if(Addr == 0xCF8)
    {
        CF8_Data.u.AsULONG = *pData;
        CF8_Called = TRUE;
    }
    else if(Addr >= 0xCFC && Addr <= 0xCFF)
    {
        if(CF8_Called)
        {
            ULONG Offset = 0;
            ULONG Return = 0;
            PCI_SLOT_NUMBER SlotNumber = {0};
            
            Offset = (CF8_Data.u.bits.RegisterNumber << 2) + (Addr - 0xCFC);
            SlotNumber.u.bits.FunctionNumber = CF8_Data.u.bits.FunctionNumber;
            SlotNumber.u.bits.DeviceNumber = CF8_Data.u.bits.DeviceNumber;    

            if (Read)
            {
                //
                // Do PCI config space read through HAL
                //
                Return = HaliPciInterfaceReadConfig( NULL,
                                                    (UCHAR)CF8_Data.u.bits.BusNumber,
                                                    SlotNumber.u.AsULONG,
                                                    pData,
                                                    Offset,
                                                    Size
                                                  );

                
            }
            else
            {
                //
                // Do PCI config space write through HAL
                //
                Return = HaliPciInterfaceWriteConfig( NULL,
                                                     (UCHAR)CF8_Data.u.bits.BusNumber,
                                                     SlotNumber.u.AsULONG,
                                                     pData,
                                                     Offset,
                                                     Size
                                                   );

                
            }
         
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    
    return Status;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixisabus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixisabus.c

Abstract:

Author:

Environment:

Revision History:


--*/

#include "halp.h"

ULONG
HalpGetEisaInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

BOOLEAN
HalpTranslateIsaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpTranslateEisaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

NTSTATUS
HalpAdjustEisaResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

HalpGetEisaData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern USHORT HalpEisaIrqMask;
extern USHORT HalpEisaIrqIgnore;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetEisaInterruptVector)
#pragma alloc_text(PAGE,HalpAdjustEisaResourceList)
#pragma alloc_text(PAGE,HalpGetEisaData)
#pragma alloc_text(PAGE,HalIrqTranslateResourceRequirementsIsa)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesIsa)
#pragma alloc_text(PAGE,HalpRecordEisaInterruptVectors)
#endif


#ifndef ACPI_HAL
ULONG
HalpGetEisaInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

    This function returns the system interrupt vector and IRQL level
    corresponding to the specified bus interrupt level and/or vector. The
    system interrupt vector and IRQL are suitable for use in a subsequent call
    to KeInitializeInterrupt.

Arguments:

    BusHandle - Per bus specific structure

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    UNREFERENCED_PARAMETER( BusInterruptVector );

    //
    // On standard PCs, IRQ 2 is the cascaded interrupt, and it really shows
    // up on IRQ 9.
    //
#if defined(NEC_98)
    if (BusInterruptLevel == 7) {
        BusInterruptLevel = 8;
    }
#else  // defined(NEC_98)
    if (BusInterruptLevel == 2) {
        BusInterruptLevel = 9;
    }
#endif // defined(NEC_98)

    if (BusInterruptLevel > 15) {
        return 0;
    }

    //
    // Get parent's translation from here..
    //
    return  BusHandler->ParentHandler->GetInterruptVector (
                    BusHandler->ParentHandler,
                    RootHandler,
                    BusInterruptLevel,
                    BusInterruptVector,
                    Irql,
                    Affinity
                );
}

NTSTATUS
HalpAdjustEisaResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
{
    SUPPORTED_RANGE     InterruptRange;

    RtlZeroMemory (&InterruptRange, sizeof InterruptRange);
    InterruptRange.Base  = 0;
    InterruptRange.Limit = 15;

    return HaliAdjustResourceListRange (
                BusHandler->BusAddresses,
                &InterruptRange,
                pResourceList
                );
}

BOOLEAN
HalpTranslateIsaBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    BOOLEAN     Status;

    //
    // Translated normally
    //

    Status = HalpTranslateSystemBusAddress (
                    BusHandler,
                    RootHandler,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                );


    //
    // If it could not be translated, and it's memory space
    // then we allow the translation as it would occur on it's
    // corrisponding EISA bus.   We're allowing this because
    // many VLBus drivers are claiming to be ISA devices.
    // (yes, they should claim to be VLBus devices, but VLBus is
    // run by video cards and like everything else about video
    // there's no hope of fixing it.  (At least according to
    // Andre))
    //

    if (Status == FALSE  &&  *AddressSpace == 0) {
        Status = HalTranslateBusAddress (
                    Eisa,
                    BusHandler->BusNumber,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                    );
    }

    return Status;
}

BOOLEAN
HalpTranslateEisaBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    BOOLEAN     Status;

    //
    // Translated normally
    //

    Status = HalpTranslateSystemBusAddress (
                    BusHandler,
                    RootHandler,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                );


    //
    // If it could not be translated, and it's in the 640k - 1m
    // range then (for compatibility) try translating it on the
    // Internal bus for
    //

    if (Status == FALSE  &&
        *AddressSpace == 0  &&
        BusAddress.HighPart == 0  &&
        BusAddress.LowPart >= 0xA0000  &&
        BusAddress.LowPart <  0xFFFFF) {

        Status = HalTranslateBusAddress (
                    Internal,
                    0,
                    BusAddress,
                    AddressSpace,
                    TranslatedAddress
                    );
    }

    return Status;
}
#endif

HalpGetEisaData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Eisa bus data for a slot or address.

Arguments:

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES BusObjectAttributes;
    PWSTR EisaPath = L"\\Registry\\Machine\\Hardware\\Description\\System\\EisaAdapter";
    PWSTR ConfigData = L"Configuration Data";
    ANSI_STRING TmpString;
    ULONG BusNumber;
    UCHAR BusString[] = "00";
    UNICODE_STRING RootName, BusName = {0};
    UNICODE_STRING ConfigDataName;
    NTSTATUS NtStatus;
    PKEY_VALUE_FULL_INFORMATION ValueInformation;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResource;
    PCM_EISA_SLOT_INFORMATION SlotInformation;
    ULONG PartialCount;
    ULONG TotalDataSize, SlotDataSize;
    HANDLE EisaHandle = INVALID_HANDLE;
    HANDLE BusHandle = INVALID_HANDLE;
    ULONG BytesWritten, BytesNeeded;
    PUCHAR KeyValueBuffer = NULL;
    ULONG i;
    ULONG DataLength = 0;
    PUCHAR DataBuffer = Buffer;
    BOOLEAN Found = FALSE;

    PAGED_CODE ();


    RtlInitUnicodeString(
                    &RootName,
                    EisaPath
                    );

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &RootName,
                    OBJ_CASE_INSENSITIVE,
                    (HANDLE)NULL,
                    NULL
                    );

    //
    // Open the EISA root
    //

    NtStatus = ZwOpenKey(
                    &EisaHandle,
                    KEY_READ,
                    &ObjectAttributes
                    );

    if (!NT_SUCCESS(NtStatus)) {
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }

    //
    // Init bus number path
    //

    BusNumber = BusHandler->BusNumber;
    if (BusNumber > 99) {
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }

    if (BusNumber > 9) {
        BusString[0] += (UCHAR) (BusNumber/10);
        BusString[1] += (UCHAR) (BusNumber % 10);
    } else {
        BusString[0] += (UCHAR) BusNumber;
        BusString[1] = '\0';
    }

    RtlInitAnsiString(
                &TmpString,
                BusString
                );

    RtlAnsiStringToUnicodeString(
                            &BusName,
                            &TmpString,
                            TRUE
                            );


    InitializeObjectAttributes(
                    &BusObjectAttributes,
                    &BusName,
                    OBJ_CASE_INSENSITIVE,
                    (HANDLE)EisaHandle,
                    NULL
                    );

    //
    // Open the EISA root + Bus Number
    //

    NtStatus = ZwOpenKey(
                    &BusHandle,
                    KEY_READ,
                    &BusObjectAttributes
                    );

    // Done with Eisa Handle
    ZwClose(EisaHandle);
    EisaHandle = INVALID_HANDLE;

    if (!NT_SUCCESS(NtStatus)) {
        DbgPrint("HAL: Opening Bus Number: Status = %x\n",NtStatus);
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }

    //
    // opening the configuration data. This first call tells us how
    // much memory we need to allocate
    //

    RtlInitUnicodeString(
                &ConfigDataName,
                ConfigData
                );

    //
    // This should fail.  We need to make this call so we can
    // get the actual size of the buffer to allocate.
    //

    ValueInformation = (PKEY_VALUE_FULL_INFORMATION) &i;
    NtStatus = ZwQueryValueKey(
                        BusHandle,
                        &ConfigDataName,
                        KeyValueFullInformation,
                        ValueInformation,
                        0,
                        &BytesNeeded
                        );

    KeyValueBuffer = ExAllocatePoolWithTag(
                            NonPagedPool,
                            BytesNeeded,
                            HAL_POOL_TAG
                            );

    if (KeyValueBuffer == NULL) {
#if DBG
        DbgPrint("HAL: Cannot allocate Key Value Buffer\n");
#endif
        ZwClose(BusHandle);
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }

    ValueInformation = (PKEY_VALUE_FULL_INFORMATION)KeyValueBuffer;

    NtStatus = ZwQueryValueKey(
                        BusHandle,
                        &ConfigDataName,
                        KeyValueFullInformation,
                        ValueInformation,
                        BytesNeeded,
                        &BytesWritten
                        );


    ZwClose(BusHandle);

    if (!NT_SUCCESS(NtStatus)) {
#if DBG
        DbgPrint("HAL: Query Config Data: Status = %x\n",NtStatus);
#endif
        DataLength = 0;
        goto HalpGetEisaDataExit;
    }


    //
    // We get back a Full Resource Descriptor List
    //

    Descriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)((PUCHAR)ValueInformation +
                                         ValueInformation->DataOffset);

    PartialResource = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                          &(Descriptor->PartialResourceList.PartialDescriptors);
    PartialCount = Descriptor->PartialResourceList.Count;

    for (i = 0; i < PartialCount; i++) {

        //
        // Do each partial Resource
        //

        switch (PartialResource->Type) {
            case CmResourceTypeNull:
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:

                //
                // We dont care about these.
                //

                PartialResource++;

                break;

            case CmResourceTypeDeviceSpecific:

                //
                // Bingo!
                //

                TotalDataSize = PartialResource->u.DeviceSpecificData.DataSize;

                SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                                    ((PUCHAR)PartialResource +
                                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                while (((LONG)TotalDataSize) > 0) {

                    if (SlotInformation->ReturnCode == EISA_EMPTY_SLOT) {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION);

                    } else {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION) +
                                  SlotInformation->NumberFunctions *
                                  sizeof(CM_EISA_FUNCTION_INFORMATION);
                    }

                    if (SlotDataSize > TotalDataSize) {

                        //
                        // Something is wrong again
                        //

                        DataLength = 0;
                        goto HalpGetEisaDataExit;
                    }

                    if (SlotNumber != 0) {

                        SlotNumber--;

                        SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                            ((PUCHAR)SlotInformation + SlotDataSize);

                        TotalDataSize -= SlotDataSize;

                        continue;

                    }

                    //
                    // This is our slot
                    //

                    Found = TRUE;
                    break;

                }

                //
                // End loop
                //

                i = PartialCount;

                break;

            default:

#if DBG
                DbgPrint("Bad Data in registry!\n");
#endif

                DataLength = 0;
                goto HalpGetEisaDataExit;
        }
    }

    if (Found) {
        i = Length + Offset;
        if (i > SlotDataSize) {
            i = SlotDataSize;
        }

        DataLength = i - Offset;
        RtlMoveMemory (Buffer, ((PUCHAR)SlotInformation + Offset), DataLength);
    }

HalpGetEisaDataExit:

    if (EisaHandle != INVALID_HANDLE)
    {
        ZwClose(EisaHandle);
    }

    if (KeyValueBuffer) ExFreePool(KeyValueBuffer);
    if (BusName.Buffer) RtlFreeUnicodeString(&BusName);

    return DataLength;
}


NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
)
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourceRequirementsRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    PIO_RESOURCE_DESCRIPTOR modSource, target, rootTarget;
    NTSTATUS                status;
    BOOLEAN                 picSlaveDeleted = FALSE;
    BOOLEAN                 deleteResource;
    ULONG                   sourceCount = 0;
    ULONG                   targetCount = 0;
    ULONG                   resource;
    ULONG                   rootCount;
    ULONG                   invalidIrq;
    BOOLEAN                 pciIsaConflict = FALSE;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    modSource = ExAllocatePoolWithTag(PagedPool,
                                      // we will have at most nine ranges when we are done
                                      sizeof(IO_RESOURCE_DESCRIPTOR) * 9,
                                      HAL_POOL_TAG
                                      );

    if (!modSource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modSource, sizeof(IO_RESOURCE_DESCRIPTOR) * 9);

    //
    // Is the PIC_SLAVE_IRQ in this resource?
    //
    if ((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_IRQ) &&
        (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_IRQ)) {

        //
        // Clip the maximum
        //
        if (Source->u.Interrupt.MinimumVector < PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                Source->u.Interrupt.MinimumVector;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                PIC_SLAVE_IRQ - 1;

            sourceCount++;
        }

        //
        // Clip the minimum
        //
        if (Source->u.Interrupt.MaximumVector > PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                Source->u.Interrupt.MaximumVector;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                PIC_SLAVE_IRQ + 1;

            sourceCount++;
        }

        //
        // In ISA machines, the PIC_SLAVE_IRQ is rerouted
        // to PIC_SLAVE_REDIRECT.  So find out if PIC_SLAVE_REDIRECT
        // is within this list. If it isn't we need to add it.
        //
        if (!((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_REDIRECT) &&
             (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_REDIRECT))) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector = PIC_SLAVE_REDIRECT;
            modSource[sourceCount].u.Interrupt.MaximumVector = PIC_SLAVE_REDIRECT;

            sourceCount++;
        }

    } else {

        *modSource = *Source;
        sourceCount = 1;
    }

    //
    // Now that the PIC_SLAVE_IRQ has been handled, we have
    // to take into account IRQs that may have been steered
    // away to the PCI bus.
    //
    // N.B.  The algorithm used below may produce resources
    // with minimums greater than maximums.  Those will
    // be stripped out later.
    //

    for (invalidIrq = 0; invalidIrq < PIC_VECTORS; invalidIrq++) {

        //
        // Look through all the resources, possibly removing
        // this IRQ from them.
        //
        for (resource = 0; resource < sourceCount; resource++) {

            deleteResource = FALSE;

            if (HalpPciIrqMask & (1 << invalidIrq)) {

                //
                // This IRQ belongs to the PCI bus.
                //

                if (!((HalpBusType == MACHINE_TYPE_EISA) &&
                      ((modSource[resource].Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)))) {

                    //
                    // And this resource is not an EISA-style,
                    // level-triggered interrupt.
                    //
                    // N.B.  Only the system BIOS truely knows
                    //       whether an IRQ on a PCI bus can be
                    //       shared with an IRQ on an ISA bus.
                    //       This code assumes that, in the case
                    //       that the BIOS set an EISA device to
                    //       the same interrupt as a PCI device,
                    //       the machine can actually function.
                    //
                    deleteResource = TRUE;
                }
            }

#ifndef MCA
            if ((HalpBusType == MACHINE_TYPE_EISA) &&
                !(HalpEisaIrqIgnore & (1 << invalidIrq))) {

                if (modSource[resource].Flags != HalpGetIsaIrqState(invalidIrq)) {

                    //
                    // This driver has requested a level-triggered interrupt
                    // and this particular interrupt is set to be edge, or
                    // vice-versa.
                    //
                    deleteResource = TRUE;
                    pciIsaConflict = TRUE;
                }
            }
#endif

            if (deleteResource) {

                if (modSource[resource].u.Interrupt.MinimumVector == invalidIrq) {

                    modSource[resource].u.Interrupt.MinimumVector++;

                } else if (modSource[resource].u.Interrupt.MaximumVector == invalidIrq) {

                    modSource[resource].u.Interrupt.MaximumVector--;

                } else if ((modSource[resource].u.Interrupt.MinimumVector < invalidIrq) &&
                    (modSource[resource].u.Interrupt.MaximumVector > invalidIrq)) {

                    //
                    // Copy the current resource into a new resource.
                    //
                    modSource[sourceCount] = modSource[resource];

                    //
                    // Clip the current resource to a range below invalidIrq.
                    //
                    modSource[resource].u.Interrupt.MaximumVector = invalidIrq - 1;

                    //
                    // Clip the new resource to a range above invalidIrq.
                    //
                    modSource[sourceCount].u.Interrupt.MinimumVector = invalidIrq + 1;

                    sourceCount++;
                }
            }
        }
    }


    target = ExAllocatePoolWithTag(PagedPool,
                                   sizeof(IO_RESOURCE_DESCRIPTOR) * sourceCount,
                                   HAL_POOL_TAG
                                   );

    if (!target) {
        ExFreePool(modSource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now send each of these ranges through
    // HalIrqTranslateResourceRequirementsRoot.
    //
    for (resource = 0; resource < sourceCount; resource++) {

        //
        // Skip over resources that we have previously
        // clobbered (while deleting PCI IRQs.)
        //
        if (modSource[resource].u.Interrupt.MinimumVector >
            modSource[resource].u.Interrupt.MaximumVector) {

            continue;
        }

        status = HalIrqTranslateResourceRequirementsRoot(
                    Context,
                    &modSource[resource],
                    PhysicalDeviceObject,
                    &rootCount,
                    &rootTarget
                    );

        if (!NT_SUCCESS(status)) {
            ExFreePool(target);
            goto HalIrqTranslateResourceRequirementsIsaExit;
        }

        //
        // HalIrqTranslateResourceRequirementsRoot should return
        // either one resource or, occasionally, zero.
        //
        ASSERT(rootCount <= 1);

        if (rootCount == 1) {

            target[targetCount] = *rootTarget;
            targetCount++;
            ExFreePool(rootTarget);
        }
    }

    status = STATUS_TRANSLATION_COMPLETE;
    *TargetCount = targetCount;

    if (targetCount > 0) {

        *Target = target;

    } else {

        ExFreePool(target);
        if (pciIsaConflict == TRUE) {
            status = STATUS_PNP_IRQ_TRANSLATION_FAILED;
        }
    }

HalIrqTranslateResourceRequirementsIsaExit:

    ExFreePool(modSource);
    return status;
}

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourcesRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    CM_PARTIAL_RESOURCE_DESCRIPTOR modSource;
    NTSTATUS    status;
    BOOLEAN     usePicSlave = FALSE;
    ULONG       i;

    modSource = *Source;

    if (Direction == TranslateChildToParent) {

        if (Source->u.Interrupt.Vector == PIC_SLAVE_IRQ) {
            modSource.u.Interrupt.Vector = PIC_SLAVE_REDIRECT;
            modSource.u.Interrupt.Level = PIC_SLAVE_REDIRECT;
        }
    }

    status = HalIrqTranslateResourcesRoot(
                Context,
                &modSource,
                Direction,
                AlternativesCount,
                Alternatives,
                PhysicalDeviceObject,
                Target);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (Direction == TranslateParentToChild) {

        //
        // Because the ISA interrupt controller is
        // cascaded, there is one case where there is
        // a two-to-one mapping for interrupt sources.
        // (On a PC, both 2 and 9 trigger vector 9.)
        //
        // We need to account for this and deliver the
        // right value back to the driver.
        //

        if (Target->u.Interrupt.Level == PIC_SLAVE_REDIRECT) {

            //
            // Search the Alternatives list.  If it contains
            // PIC_SLAVE_IRQ but not PIC_SLAVE_REDIRECT,
            // we should return PIC_SLAVE_IRQ.
            //

            for (i = 0; i < AlternativesCount; i++) {

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_REDIRECT) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_REDIRECT)) {

                    //
                    // The list contains, PIC_SLAVE_REDIRECT.  Stop
                    // looking.
                    //

                    usePicSlave = FALSE;
                    break;
                }

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_IRQ) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_IRQ)) {

                    //
                    // The list contains, PIC_SLAVE_IRQ.  Use it
                    // unless we find PIC_SLAVE_REDIRECT later.
                    //

                    usePicSlave = TRUE;
                }
            }

            if (usePicSlave) {

                Target->u.Interrupt.Level  = PIC_SLAVE_IRQ;
                Target->u.Interrupt.Vector = PIC_SLAVE_IRQ;
            }
        }
    }

    return status;
}

VOID
HalpRecordEisaInterruptVectors(
    VOID
    )
{
    HalpEisaIrqMask = READ_PORT_UCHAR((PUCHAR)EISA_EDGE_LEVEL0) & 0xff;
    HalpEisaIrqMask |= READ_PORT_UCHAR((PUCHAR)EISA_EDGE_LEVEL1) << 8;

    if ((HalpEisaIrqMask == 0xffff) ||
        (HalpEisaIrqMask == 0x0000)) {

        HalpEisaIrqIgnore = 0xffff;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixipi.asm ===
title "Interprocessor Interrupt"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixipi.asm
;
;Abstract:
;
;    Provides the HAL support for Interprocessor Interrupts.
;    This is the UP version.
;
;Author:
;
;    John Vert (jvert) 16-Jul-1991
;
;Revision History:
;
;--
.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include i386\ix8259.inc


        EXTRNP  _KiCoprocessorError,0,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalpRegisterKdSupportFunctions,1
        extrn   _HalpDefaultInterruptAffinity:DWORD
        extrn   _HalpActiveProcessors:DWORD
IFDEF NEC_98
        EXTRNP  _HalpDetectCommonArea,0
endif ; NEC_98

        page ,132
        subttl  "Post InterProcessor Interrupt"
INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalInitializeProcessor(
;       ULONG   Number
;       PVOID   LoaderBlock
;       );
;
;Routine Description:
;
;    Initialize hal pcr values for current processor (if any)
;    (called shortly after processor reaches kernel, before
;    HalInitSystem if P0)
;
;    IPI's and KeReadir/LowerIrq's must be available once this function
;    returns.  (IPI's are only used once two or more processors are
;    available)
;
;Arguments:
;
;    Number - Logical processor number of calling processor
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalInitializeProcessor ,2

;
; Initialize PcIDR in PCR to enable slave IRQ
;

IFDEF NEC_98
        mov     fs:PcIDR, 0ffffff7fh
        stdCall    _HalpDetectCommonArea
else ; NEC_98
        mov     fs:PcIDR, 0fffffffbh
endif ; NEC_98
        mov     dword ptr fs:PcStallScaleFactor, INITIAL_STALL_COUNT

        mov     eax, dword ptr [esp+4]
        lock bts _HalpDefaultInterruptAffinity, eax
        lock bts _HalpActiveProcessors, eax
        
        ;
        ; This next call has nothing to do with processor init.
        ; But this is the only function in the HAL that gets 
        ; called before KdInit.
        ;
        stdCall _HalpRegisterKdSupportFunctions <[esp + 8]>

        stdRET    _HalInitializeProcessor
stdENDP _HalInitializeProcessor

INIT   ends


_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalRequestIpi(
;       IN ULONG Mask
;       );
;
;Routine Description:
;
;    Requests an interprocessor interrupt
;
;Arguments:
;
;    Mask - Supplies a mask of the processors to interrupt
;
;Return Value:
;
;    None.
;
;--

cPublicProc _HalRequestIpi  ,1

if DBG
        int 3
endif
        stdRET    _HalRequestIpi
stdENDP _HalRequestIpi


        page ,132
        subttl  "80387 Irq13 Interrupt Handler"
;++
;
; VOID
; HalpIrq13Handler (
;    );
;
; Routine Description:
;
;    When the 80387 detects an error, it raises its error line.  This
;    was supposed to be routed directly to the 386 to cause a trap 16
;    (which would actually occur when the 386 encountered the next FP
;    instruction).
;
;    However, the ISA design routes the error line to IRQ13 on the
;    slave 8259.  So an interrupt will be generated whenever the 387
;    discovers an error.
;
;    This routine handles that interrupt and passes control to the kernel
;    coprocessor error handler.
;
; Arguments:
;
;    None.
;    Interrupt is disabled.
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST Hi13_a, Hi13_t

cPublicProc _HalpIrq13Handler       ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hi13_a, Hi13_t  ; (ebp) -> Trap frame

;
; Save previous IRQL
;

        push    13 + PRIMARY_VECTOR_BASE    ; Vector
        sub     esp, 4                      ; make space for OldIrql

        stdCall   _HalBeginSystemInterrupt, <I386_80387_IRQL,13 + PRIMARY_VECTOR_BASE,esp>

        stdCall   _KiCoprocessorError         ; call CoprocessorError handler

;
;       Clear the busy latch so that the 386 doesn't mistakenly think
;       that the 387 is still busy.
;

        xor     al,al
        out     I386_80387_BUSY_PORT, al

        INTERRUPT_EXIT                      ; will return to caller

stdENDP _HalpIrq13Handler

_TEXT$03   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixisa.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixisa.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    EISA/ISA specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91

Revision History:

--*/

#ifndef _IXISA_
#define _IXISA_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_ISA_MAP_BUFFER_SIZE      0x40000

#if !defined(_HALPAE_)
#define MAXIMUM_MAP_BUFFER_SIZE         MAXIMUM_ISA_MAP_BUFFER_SIZE
#endif

//
// MAXIMUM_PCI_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for 32-bit PCI devices on a 64-bit system.
//

#define MAXIMUM_PCI_MAP_BUFFER_SIZE  (64 * 1024 * 1024)

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_SMALL_SIZE 0x10000

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_LARGE_SIZE 0x30000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

#define MAXIMUM_PCI_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card.
//

#define MAXIMUM_PHYSICAL_ADDRESS 0x01000000

//
// Define the scatter/gather flag for the Map Register Base.
//

#define NO_SCATTER_GATHER 0x00000001

//
// Define the copy buffer flag for the index.
//

#define COPY_BUFFER 0XFFFFFFFF

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    DMA_ADAPTER DmaHeader;
    struct _ADAPTER_OBJECT *MasterAdapter;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    ULONG CommittedMapRegisters;
    struct _WAIT_CONTEXT_BLOCK *CurrentWcb;
    KDEVICE_QUEUE ChannelWaitQueue;
    PKDEVICE_QUEUE RegisterWaitQueue;
    LIST_ENTRY AdapterQueue;
    KSPIN_LOCK SpinLock;
    PRTL_BITMAP MapRegisters;
    PUCHAR PagePort;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    USHORT DmaPortAddress;
    UCHAR AdapterMode;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN ScatterGather;
    BOOLEAN IgnoreCount;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN Dma64BitAddresses;
    LIST_ENTRY AdapterList;
} ADAPTER_OBJECT;

typedef struct _MASTER_ADAPTER_OBJECT {

    PADAPTER_OBJECT AdapterObject;

    //
    // Maximum number of buffers to allocate for this master adapter.
    //

    ULONG MaxBufferPages;

    //
    // Number of map buffers allocated
    //

    ULONG MapBufferSize;

    PHYSICAL_ADDRESS MapBufferPhysicalAddress;

} MASTER_ADAPTER_OBJECT, *PMASTER_ADAPTER_OBJECT;

ULONG 
HalGetDmaAlignment (
    PVOID Conext
    );

NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    );

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    );


NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapaterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );


PHYSICAL_ADDRESS
__inline
HalpGetAdapterMaximumPhysicalAddress(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine determines and returns the maximum physical address that
    can be accessed by the given adapter.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

Return Value:

    Returns the maximum physical address that can be accessed by this
        device.

--*/

{
    PHYSICAL_ADDRESS maximumAddress;

    //
    // Assume the device requires physical addresses < 16M.
    //

    maximumAddress.HighPart = 0;
    maximumAddress.LowPart = MAXIMUM_PHYSICAL_ADDRESS - 1;

    //
    // IoMapTransfer() is sometimes called with a NULL adapter object.  In
    // this case, assume the adapter is 24 bit.
    //

    if (AdapterObject == NULL) {
        return maximumAddress;
    }

    if (AdapterObject->MasterDevice) {

        if (AdapterObject->Dma64BitAddresses) {

            //
            // This device is a master and can handle 64 bit addresses.
            //

            maximumAddress.QuadPart = (ULONGLONG)-1;

        } else if(AdapterObject->Dma32BitAddresses) {

            //
            // This device is a master and can handle 32 bit addresses.
            //

            maximumAddress.LowPart = (ULONG)-1;
        }
    }

    return maximumAddress;
}


#endif // _IXISA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixlock.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixlock.asm
;
; Abstract:
;
;    This module implements various locking functions optimized for this hal.
;
; Author:
;
;    Ken Reneris (kenr) 21-April-1994
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.486p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
        .list

        EXTRNP _KeBugCheckEx,5,IMPORT
        EXTRNP _KeSetEventBoostPriority, 2, IMPORT
        EXTRNP _KeWaitForSingleObject,5, IMPORT

        extrn  FindHigherIrqlMask:DWORD
        extrn  SWInterruptHandlerTable:DWORD

        EXTRNP _KeRaiseIrql,2
        EXTRNP _KeLowerIrql,1

ifdef NT_UP
    LOCK_ADD  equ   add
    LOCK_DEC  equ   dec
else
    LOCK_ADD  equ   lock add
    LOCK_DEC  equ   lock dec
endif


_TEXT$01   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        PAGE
        subttl  "AcquireSpinLock"

;++
;
;  KIRQL
;  KfAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function raises to DISPATCH_LEVEL and then acquires a the
;     kernel spin lock.
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to DISPATCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we take the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql
;
;--

cPublicFastCall KfAcquireSpinLock,1
cPublicFpo 0,0

        xor     eax, eax        ; Eliminate partial stall on return to caller
        mov     al, PCR[PcIrql]         ; (al) = Old Irql
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL    ; set new irql

ifndef NT_UP
asl10:  ACQUIRE_SPINLOCK    ecx,<short asl20>
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, DISPATCH_LEVEL      ; old > new?
        ja      short asl99             ; yes, go bugcheck
endif
        fstRET    KfAcquireSpinLock

ifndef NT_UP
asl20:  SPIN_ON_SPINLOCK    ecx,<short asl10>
endif

if DBG
cPublicFpo 2,1
asl99:  movzx   eax, al
        stdCall  _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,DISPATCH_LEVEL,0,1>
        ; never returns
endif
        fstRET    KfAcquireSpinLock
fstENDP KfAcquireSpinLock

;++
;
;  KIRQL
;  KeAcquireSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function acquires the SpinLock at SYNCH_LEVEL.  The function
;     is optmized for hoter locks (the lock is tested before acquired.
;     Any spin should occur at OldIrql; however, since this is a UP hal
;     we don't have the code for it)
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to SYNCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we take the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql
;
;--

cPublicFastCall KeAcquireSpinLockRaiseToSynch,1
cPublicFpo 0,0

        xor     eax, eax                ; eliminate partial stall
        mov     al, PCR[PcIrql]         ; (al) = Old Irql
        mov     byte ptr PCR[PcIrql], SYNCH_LEVEL   ; set new irql

ifndef NT_UP
asls10: ACQUIRE_SPINLOCK    ecx,<short asls20>
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, SYNCH_LEVEL         ; old > new?
        ja      short asls99            ; yes, go bugcheck
endif
        fstRET  KeAcquireSpinLockRaiseToSynch

ifndef NT_UP
asls20: SPIN_ON_SPINLOCK    ecx,<short asls10>
endif

if DBG
cPublicFpo 2,1
asls99: movzx   eax, al
        stdCall  _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,SYNCH_LEVEL,0,2>
        ; never returns
endif
        fstRET  KeAcquireSpinLockRaiseToSynch
fstENDP KeAcquireSpinLockRaiseToSynch

        PAGE
        SUBTTL "Release Kernel Spin Lock"

;++
;
;  VOID
;  KfReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN KIRQL       NewIrql
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock and lowers to the new irql
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to DISPATCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we use the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock Supplies a pointer to an executive spin lock.
;     (dl)  = NewIrql  New irql value to set
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KfReleaseSpinLock  ,2
cPublicFpo 0,0
ifndef NT_UP
        RELEASE_SPINLOCK    ecx         ; release it
endif
        xor     ecx, ecx
if DBG
        cmp     dl, PCR[PcIrql]
        ja      short rsl99
endif
        pushfd
        cli
        mov     PCR[PcIrql], dl         ; store old irql
        mov     cl, dl                  ; (ecx) = 32bit extended OldIrql
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[ecx*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
        jne     short rsl20                     ; dispatch now.

        popfd
        fstRet  KfReleaseSpinLock               ; all done

if DBG
rsl99:  xor     eax, eax
        mov     al, PCR[PcIrql]
        movzx   edx, dl
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,edx,0,3>
        ; never returns
endif

cPublicFpo 0,1
rsl20:  bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jle     short rsl40

        mov     eax, PCR[PcIDR]                 ; Clear all the interrupt
        SET_8259_MASK                           ; masks
rsl40:
        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 0, 0
        fstRet  KfReleaseSpinLock               ; all done

fstENDP KfReleaseSpinLock

;++
;
;  VOID
;  FASTCALL
;  ExAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquire ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExAcquireFastMutex,1
cPublicFpo 0,0
        mov     al, PCR[PcIrql]             ; (cl) = OldIrql
if DBG
        cmp     al, APC_LEVEL               ; Is OldIrql > NewIrql?
        ja      short afm99                 ; Yes, bugcheck

        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread  ; (edx) = Current Thread
        cmp     [ecx].FmOwner, edx          ; Already owned by this thread?
        je      short afm98                 ; Yes, error
endif

        mov     byte ptr PCR[PcIrql], APC_LEVEL     ; Set NewIrql
   LOCK_DEC     dword ptr [ecx].FmCount     ; Get count
        jz      short afm_ret               ; The owner? Yes, Done

        inc     dword ptr [ecx].FmContention

cPublicFpo 0,2
        push    eax                         ; save OldIrql
        push    ecx                         ; Save FAST_MUTEX
        add     ecx, FmEvent                ; Wait on Event

        stdCall _KeWaitForSingleObject,<ecx,WrExecutive,0,0,0>

        pop     ecx                         ; (ecx) = FAST_MUTEX
        pop     eax                         ; (al) = OldIrql

cPublicFpo 1,0
afm_ret:

	;
	; Leave a notion of owner behind.
	;
	; Note: if you change this, change ExAcquireFastMutexUnsafe.
        ;
	
if DBG
        cli
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread  ; (edx) = Current Thread
        sti
        mov     [ecx].FmOwner, edx          ; Save in Fast Mutex
else
        ;
        ; Use esp to track the owning thread for debugging purposes.
        ; !thread from kd will find the owning thread.  Note that the
        ; owner isn't cleared on release, check if the mutex is owned
        ; first.
        ;

        mov     [ecx].FmOwner, esp
endif
        mov     byte ptr [ecx].FmOldIrql, al
        fstRet  ExAcquireFastMutex

if DBG

        ; KeBugCheckEx(MUTEX_ALREADY_OWNED, FastMutex, CurrentThread, 0, 4)
        ; (never returns)

afm98:  stdCall _KeBugCheckEx,<MUTEX_ALREADY_OWNED,ecx,edx,0,4>

        ; KeBugCheckEx(IRQL_NOT_LESS_OR_EQUAL, CurrentIrql, APC_LEVEL, 0, 5)
        ; (never returns)

afm99:  movzx   eax, al
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,APC_LEVEL,0,5>

        fstRet  ExAcquireFastMutex
endif

fstENDP ExAcquireFastMutex


;++
;
;  VOID
;  FASTCALL
;  ExReleaseFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function releases ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExReleaseFastMutex,1
cPublicFpo 0,0
        xor     eax, eax
if DBG
        cli
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = CurrentThread
        sti
        cmp     [ecx].FmOwner, edx              ; Owner == CurrentThread?
        jne     short rfm_threaderror           ; No, bugcheck

        or      byte ptr [ecx].FmOwner, 1       ; not the owner anymore
endif

        mov     al, byte ptr [ecx].FmOldIrql    ; (eax) = OldIrql
   LOCK_ADD     dword ptr [ecx].FmCount, 1      ; Remove our count
        js      short rfm05                     ; if < 0, set event
        jnz     short rfm10                     ; if != 0, don't set event

rfm05:
cPublicFpo 0,2
        push    eax                             ; Save OldIrql
        add     ecx, FmEvent
        stdCall _KeSetEventBoostPriority, <ecx, 0>
        pop     eax

cPublicFpo 0,0
rfm10:
        cli
        mov     PCR[PcIrql], eax
        mov     edx, PCR[PcIRR]
        and     edx, FindHigherIrqlMask[eax*4]  ; (edx) is the bitmask of
                                                ; pending interrupts we need to
        jne     short rfm20                     ; dispatch now.

        sti
        fstRet  ExReleaseFastMutex              ; all done
if DBG

        ; KeBugCheck(THREAD_NOT_MUTEX_OWNER, FastMutex, Thread, Owner, 6)
        ; (never returns)

rfm_threaderror:
        stdCall _KeBugCheckEx,<THREAD_NOT_MUTEX_OWNER,ecx,edx,[ecx].FmOwner,6>

endif

rfm20:  bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL
        jle     short rfm40

        mov     eax, PCR[PcIDR]                 ; Clear all the interrupt
        SET_8259_MASK                           ; masks
rfm40:
        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        sti
        fstRet  ExReleaseFastMutex              ; all done
fstENDP ExReleaseFastMutex

;++
;
;  BOOLEAN
;  FASTCALL
;  ExTryToAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquire ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     Returns TRUE if the FAST_MUTEX was acquired; otherwise false
;
;--

cPublicFastCall ExTryToAcquireFastMutex,1
cPublicFpo 0,0
        mov     al, PCR[PcIrql]             ; (al) = OldIrql

if DBG
        cmp     al, APC_LEVEL               ; Is OldIrql > NewIrql?
        ja      short tam99                 ; Yes, bugcheck
endif

;
; Try to acquire - but needs to support 386s.
; *** Warning: This code is NOT MP safe ***
; But, we know that this hal really only runs on UP machines
;
        cli
        cmp     dword ptr [ecx].FmCount, 1      ; Busy?
        jne     short tam20                     ; Yes, abort

        mov     dword ptr [ecx].FmCount, 0      ; acquire count

if DBG
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = Current Thread
        mov     [ecx].FmOwner, edx              ; Save in Fast Mutex
endif
        mov     PCR[PcIrql], APC_LEVEL
        sti
        mov     byte ptr [ecx].FmOldIrql, al
        mov     eax, 1                          ; return TRUE
        fstRet  ExTryToAcquireFastMutex

tam20:  sti
        YIELD
        xor     eax, eax                        ; return FALSE
        fstRet  ExTryToAcquireFastMutex         ; all done

if DBG
        ; KeBugCheckEx(IRQL_NOT_LESS_OR_EQUAL, CurrentIrql, APC_LEVEL, 0, 5)
        ; (never returns)

tam99:  movzx   eax, al
        stdCall _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,APC_LEVEL,0,7>

        xor     eax, eax                        ; return FALSE
        fstRet  ExTryToAcquireFastMutex
endif

fstENDP ExTryToAcquireFastMutex

        page    ,132
        subttl  "Acquire Queued SpinLock"

;++
;
; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and acquires the specified queued spinlock.
;
; Arguments:
;
;    Number (ecx) - Supplies the queued spinlock number.
;
; Return Value:
;
;    The previous IRQL is returned as the function value.
;
;
; Routine Description:
;
;    The Kx versions use a LOCK_QUEUE_HANDLE structure rather than
;    LOCK_QUEUE structures in the PRCB.   Old IRQL is stored in the
;    LOCK_QUEUE_HANDLE.
;
; Arguments:
;
;    SpinLock   (ecx) Address of Actual Lock.
;    LockHandle (edx) Address of lock context.
;
; Return Value:
;
;   None.  Actually returns OldIrql because common code is used
;          for all implementations.
;
;--

        ; compile time assert sizeof(KSPIN_LOCK_QUEUE) == 8

        .errnz  (LOCK_QUEUE_HEADER_SIZE - 8)


; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )

align 16
cPublicFastCall KeAcquireInStackQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,1

        push    SYNCH_LEVEL                     ; raise to SYNCH_LEVEL
        jmp     short aqsl5                     ; continue in common code

fstENDP KeAcquireInStackQueuedSpinLockRaiseToSynch


; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )

cPublicFastCall KeAcquireInStackQueuedSpinLock,2
cPublicFpo 0,1

        ; Get old IRQL and raise to DISPATCH_LEVEL

        push    DISPATCH_LEVEL
aqsl5:
        pop     eax
        push    PCR[PcIrql]
        mov     PCR[PcIrql], al

if DBG
        cmp     [esp], eax
        ja      short aqsl
endif

ifndef NT_UP

        ; store OldIrql and address of actual lock in the queued
        ; spinlock structure in the lock queue handle structure.

        mov     eax, [esp]
        mov     [edx].LqhLock, ecx
        mov     dword ptr [edx].LqhNext, 0
        mov     [edx].LqhOldIrql, al

        ; continue in common code.  common code expects the
        ; address of the "lock structure" in edx, this is at
        ; offset LqhNext in the lock queue handle structure.
        ; not accidentally this offset is zero.

        .errnz  LqhNext
;;      lea     edx, [edx].LqhNext
        jmp     short aqsl15                    ; continue in common code

else

        pop     eax                             ; get old irql and set
        mov     [edx].LqhOldIrql, al            ; in lock queue handle.

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireInStackQueuedSpinLock

endif

fstENDP KeAcquireInStackQueuedSpinLock


; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )

cPublicFastCall KeAcquireQueuedSpinLockRaiseToSynch,1
cPublicFpo 0,1

        push    SYNCH_LEVEL
        jmp     short aqsl10                    ; continue in common code

fstENDP KeAcquireQueuedSpinLockRaiseToSynch


; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;

cPublicFastCall KeAcquireQueuedSpinLock,1
cPublicFpo 0,1

        ; Get old IRQL and raise to DISPATCH_LEVEL

        push    DISPATCH_LEVEL
aqsl10:
        pop     eax
        push    PCR[PcIrql]
        mov     PCR[PcIrql], al

if DBG
        cmp     [esp], eax
        ja      short aqsl
endif

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

        mov     ecx, [edx].LqLock
aqsl15:
        mov     eax, edx                        ; save Lock Queue entry address

        ; Exchange the value of the lock with the address of this
        ; Lock Queue entry.

        xchg    [ecx], edx

        cmp     edx, 0                          ; check if lock is held
        jnz     short @f                        ; jiff held

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [eax].LqLock, ecx

        ; lock has been acquired, return.

endif

aqsl20: pop     eax                             ; restore return value

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireQueuedSpinLock

ifndef NT_UP

@@:
        ; The lock is already held by another processor.  Set the wait
        ; bit in this processor's Lock Queue entry, then set the next
        ; field in the Lock Queue entry of the last processor to attempt
        ; to acquire the lock (this is the address returned by the xchg
        ; above) to point to THIS processor's lock queue entry.

        or      ecx, LOCK_QUEUE_WAIT            ; set lock bit
        mov     [eax].LqLock, ecx

        mov     [edx].LqNext, eax               ; set previous acquirer's
                                                ; next field.

        ; Wait.
@@:
        YIELD                                   ; fire avoidance.
        test    [eax].LqLock, LOCK_QUEUE_WAIT   ; check if still waiting
        jz      short aqsl20                    ; jif lock acquired
        jmp     short @b                        ; else, continue waiting

endif

if DBG

        ; Raising to a lower IRQL. BugCheck.
        ;
        ; KeBugCheckEx(IRQL_NOT_GREATER_OR_EQUAL,
        ;              current (old) IRQL,
        ;              desired IRQL,
        ;              lock number (only if Ke routine, not Kx),
        ;              8);

aqsl:   pop     edx
        stdCall _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,edx,eax,ecx,8>
        ; never returns (but help the debugger back-trace)
        int     3

endif

fstENDP KeAcquireQueuedSpinLock


        page    ,132
        subttl  "Release Queued SpinLock"

;++
;
; VOID
; KeReleaseInStackQueuedSpinLock (
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
;    This differs from KeReleaseQueuedSpinLock in that this version
;    uses a caller supplied lock context where that one uses a
;    predefined lock context in the processor's PRCB.
;
;    This version sets up a compatible register context and uses
;    KeReleaseQueuedSpinLock to do the actual work.
;
; Arguments:
;
;    LockHandle (ecx) - Address of Lock Queue Handle structure.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseInStackQueuedSpinLock,1
cPublicFpo 0,0

        movzx   edx, byte ptr [ecx].LqhOldIrql  ; get old irql

ifndef NT_UP

        lea     eax, [ecx].LqhNext              ; get address of lock struct
        jmp     short rqsl10                    ; continue in common code

else

        jmp     short rqsl30                    ; continue in common code

endif


fstENDP KeReleaseInStackQueuedSpinLock


;++
;
; VOID
; KeReleaseQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number,
;     IN KIRQL                   OldIrql
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (dl)  - Supplies the IRQL value to lower to.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseQueuedSpinLock,2
cPublicFpo 0,0

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     eax, PCR[PcPrcb]                ; get address of PRCB
        lea     eax, [eax+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]
rqsl10:
        push    ebx                             ; need another register
cPublicFpo 0,1

        ; Clear the lock field in the Lock Queue entry.
        mov     ebx, [eax].LqNext
        mov     ecx, [eax].LqLock
;;        and     ecx, NOT (LOCK_QUEUE_OWNER)     ; clear lock bit

        ; Quick check: If Lock Queue entry's Next field is not NULL,
        ; there is another waiter.  Don't bother with ANY atomic ops
        ; in this case.
        ;
        ; Note: test clears CF and sets ZF appropriately, the following
        ; btr sets CF appropriately for the owner check.

        test    ebx, ebx

        ; clear the "I am owner" bit in the Lock entry.

        btr     ecx, 1                          ; clear owner bit

if DBG

        jnc     short rqsl98                    ; bugcheck if was not set
                                                ; tests CF
endif

        mov     [eax].LqLock, ecx               ; clear lock bit in queue entry
        jnz     short rqsl40                    ; jif another processor waits

        ; ebx contains zero here which will be used to set the new owner NULL

        push    eax                             ; save &PRCB->LockQueue[Number]
cPublicFpo 0,2

        ; Use compare exchange to attempt to clear the actual lock.
        ; If there are still no processors waiting for the lock when
        ; the compare exchange happens, the old contents of the lock
        ; should be the address of this lock entry (eax).

        lock cmpxchg [ecx], ebx                 ; store 0 if no waiters
        pop     eax                             ; restore lock queue address
cPublicFpo 0,1
        jnz     short rqsl60                    ; jif store failed

        ; The lock has been released.  Lower IRQL and return to caller.

rqsl20:
        pop     ebx                             ; restore ebx
cPublicFpo 0,0

endif

rqsl30:
        pushfd                                  ; disable interrupts
        cli

        xor     ecx, ecx
        mov     PCR[PcIrql], dl                 ; set new (lower) OldIrql
        mov     cl, dl                          ; ecx = zero extended OldIrql

        mov     edx, PCR[PcIRR]                 ; Check interrupt requests
        and     edx, FindHigherIrqlMask[ecx*4]  ; edx = pending interrupts
                                                ; enabled by lower IRQL.
        jne     short rqsl80                    ; Dispatch pending interrupts.

        popfd                                   ; restore interrupt state

        fstRET  KeReleaseQueuedSpinLock

ifndef NT_UP

        ; Another processor is waiting on this lock.   Hand the lock
        ; to that processor by getting the address of its LockQueue
        ; entry, turning ON its owner bit and OFF its wait bit.

rqsl40: xor     [ebx].LqLock, (LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT)

        ; Done, the other processor now owns the lock, clear the next
        ; field in my LockQueue entry (to preserve the order for entering
        ; the queue again) and proceed to lower IRQL and return.

        mov     [eax].LqNext, 0
        jmp     short rqsl20


        ; We get here if another processor is attempting to acquire
        ; the lock but had not yet updated the next field in this
        ; processor's Queued Lock Next field.   Wait for the next
        ; field to be updated.

rqsl60: mov     ebx, [eax].LqNext
        test    ebx, ebx                        ; check if still 0
        jnz     short rqsl40                    ; jif Next field now set.
        YIELD                                   ; wait a bit
        jmp     short rqsl60                    ; continue waiting

endif

cPublicFpo 0,1
rqsl80: bsr     ecx, edx                        ; (ecx) = Pending irq level
        cmp     ecx, DISPATCH_LEVEL             ; if new int at dispatch level
        jle     short @f                        ; no need to change 8259 masks

        mov     eax, PCR[PcIDR]                 ; Clear all the interrupt
        SET_8259_MASK                           ; masks
@@:
        mov     edx, 1
        shl     edx, cl
        xor     PCR[PcIRR], edx                 ; clear bit in IRR
        call    SWInterruptHandlerTable[ecx*4]  ; Dispatch the pending int.
        popfd

cPublicFpo 0, 0
        fstRet  KfReleaseSpinLock               ; all done

ifndef NT_UP

if DBG

cPublicFpo 0,1

rqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_NOT_OWNED,ecx,eax,0,1>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeReleaseQueuedSpinLock

        page    ,132
        subttl  "Try to Acquire Queued SpinLock"

;++
;
; LOGICAL
; KeTryToAcquireQueuedSpinLock (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; LOGICAL
; KeTryToAcquireQueuedSpinLockRaiseToSynch (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and attempts to acquire the specified queued spinlock.  If the
;    spinlock is already owned by another thread, IRQL is restored
;    to its previous value and FALSE is returned.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (edx) - A pointer to the variable to receive the old
;                    IRQL.
;
; Return Value:
;
;    TRUE if the lock was acquired, FALSE otherwise.
;    N.B. ZF is set if FALSE returned, clear otherwise.
;
;--


align 16
cPublicFastCall KeTryToAcquireQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,0

        mov     eax, SYNCH_LEVEL                ; raise to SYNCH
        jmp     short taqsl10                   ; continue in common code

fstENDP KeTryToAcquireQueuedSpinLockRaiseToSynch


cPublicFastCall KeTryToAcquireQueuedSpinLock,2
cPublicFpo 0,0

        mov     eax, DISPATCH_LEVEL             ; raise to DPC level

        ; Attempt to get the lock with interrupts disabled, raising
        ; the priority in the interrupt controller only if acquisition
        ; is successful.
taqsl10:

if DBG
        cmp     al, PCR[PcIrql]
        jb      short taqsl98
endif

ifndef NT_UP

        push    edx                             ; save address of OldIrql
        pushfd                                  ; save interrupt state
        cli                                     ; disable interrupts

        ; Get address of Lock Queue entry

        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

        mov     ecx, [edx].LqLock

if DBG

        test    ecx, LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT
        jnz     short taqsl99                   ; jiff lock already held (or
                                                ; this proc already waiting).
endif

        cmp     dword ptr [ecx], 0              ; check if already taken
        push    eax                             ; save new IRQL
        jnz     taqsl60                         ; jif already taken
        xor     eax, eax                        ; comparison value (not locked)


        ; Store the Lock Queue entry address in the lock ONLY if the
        ; current lock value is 0.

        lock cmpxchg [ecx], edx
        jnz     short taqsl60

        ; Lock has been acquired.

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [edx].LqLock, ecx

        pop     eax

endif

        ; Raise IRQL and return success.

        xor     ecx, ecx
        mov     cl, PCR[PcIrql]                 ; al = OldIrql
        mov     PCR[PcIrql], al                 ; set new IRQL

ifndef NT_UP

        popfd                                   ; restore interrupt state
        pop     edx

endif

        mov     [edx], cl                       ; *OldIrql = OldIrql
        xor     eax, eax
        or      eax, 1                          ; return TRUE

        fstRET  KeTryToAcquireQueuedSpinLock

ifndef NT_UP

taqsl60:
        ; The lock is already held by another processor.  Indicate
        ; failure to the caller.

        pop     eax                             ; pop new IRQL off stack
        popfd                                   ; restore interrupt state
        pop     edx                             ; pop saved OldIrql address
        xor     eax, eax                        ; return FALSE
        fstRET  KeTryToAcquireQueuedSpinLock

endif

if DBG

taqsl98: stdCall _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,PCR[PcIrql],eax,ecx,9>
taqsl99: stdCall _KeBugCheckEx,<SPIN_LOCK_ALREADY_OWNED,ecx,edx,0,0>
        ; never returns (help the debugger back-trace)
        int     3

endif

fstENDP KeTryToAcquireQueuedSpinLock
_TEXT$01   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixmcaa.asm ===
;++
;Module Name
;   imca.asm
;
;Abstract:
;   Assembly support needed for Intel MCA
;
; Author:
;   Anil Aggarwal (Intel Corp)
;
;Revision History:
;
;
;--

.586p
        .xlist
include hal386.inc
include callconv.inc
include i386\kimacro.inc
        .list

        EXTRNP  _HalpMcaExceptionHandler,0
        EXTRNP  _KeBugCheckEx,5,IMPORT

KGDT_MCA_TSS                EQU     0A0H
MINIMUM_TSS_SIZE            EQU     TssIoMaps

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;                           TEXT Segment
;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

    .586p

;++
;
;VOID
;HalpSerialize(
;   VOID
;   )
;
;   Routine Description:
;       This function implements the fence operation for out-of-order execution
;
;   Arguments:
;       None
;
;   Return Value:
;       None
;
;--

cPublicProc _HalpSerialize,0

        push    ebx
        xor     eax, eax
        cpuid
        pop     ebx

        stdRET  _HalpSerialize

stdENDP _HalpSerialize
 
 
;++
;
; Routine Description:
;
;    Machine Check exception handler
;
;
; Arguments:
;
; Return value:
;
;   If the error is non-restartable, we will bugcheck.
;   Otherwise, we just return 
;
;--
        ASSUME  DS:NOTHING, SS:NOTHING, ES:NOTHING
align dword
        public  _HalpMcaExceptionHandlerWrapper
_HalpMcaExceptionHandlerWrapper       proc
.FPO (0, 0, 0, 0, 0, 2)

        cli

        ;
        ; Update the TSS pointer in the PCR to point to the MCA TSS
        ; (which is what we're running on, or else we wouldn't be here)
        ;

        push    dword ptr PCR[PcTss]
        mov     eax, PCR[PcGdt]
        mov     ch, [eax+KGDT_MCA_TSS+KgdtBaseHi]
        mov     cl, [eax+KGDT_MCA_TSS+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [eax+KGDT_MCA_TSS+KgdtBaseLow]
        mov     PCR[PcTss], ecx

        ;
        ; Clear the busy bit in the TSS selector
        ;
        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_MCA_TSS
        mov     byte ptr [eax+5], 089h  ; 32bit, dpl=0, present, TSS32, not busy

        ;
        ; Clear Nested Task bit in EFLAGS
        ;
        pushfd
        and     [esp], not 04000h
        popfd

        ;
        ; Check if there is a bugcheck-able error. If need to bugcheck, the 
        ; caller does it.
        ;
        stdCall _HalpMcaExceptionHandler

        ;
        ; We're back which means that the error was restartable.
        ;

        pop     dword ptr PCR[PcTss]    ; restore PcTss

        mov     ecx, PCR[PcGdt]
        lea     eax, [ecx] + KGDT_TSS
        mov     byte ptr [eax+5], 08bh  ; 32bit, dpl=0, present, TSS32, *busy*

        pushfd                          ; Set Nested Task bit in EFLAGS
        or      [esp], 04000h           ; so iretd will do a tast switch
        popfd

        iretd                           ; Return from MCA Exception handler
        jmp     short _HalpMcaExceptionHandlerWrapper   
                                        ; For next Machine check exception

_HalpMcaExceptionHandlerWrapper       endp

_TEXT   ends

INIT    SEGMENT DWORD PUBLIC 'CODE'

;++
;VOID
;HalpMcaCurrentProcessorSetTSS(
;   IN PULONG   pTSS   // MCE TSS area for this processor
;   )
;   Routine Description:
;       This function sets up the TSS for MCA exception 18
;
;   Arguments:
;       pTSS  : Pointer to the TSS to be used for MCE
;
;   Return Value:
;       None
;
;--

cPublicProc _HalpMcaCurrentProcessorSetTSS,1
    
        ;
        ; Edit IDT Entry for MCA Exception (18) to contain a task gate
        ;
        mov     ecx, PCR[PcIdt]                     ; Get IDT address
        lea     eax, [ecx] + 090h                   ; MCA Exception is 18
        mov     byte ptr [eax + 5], 085h            ; P=1,DPL=0,Type=5
        mov     word ptr [eax + 2], KGDT_MCA_TSS    ; TSS Segment Selector

        mov     edx, [esp+4]                        ; the address of TSS in edx

        ;
        ; Set various fields in TSS
        ;
        mov     eax, cr3
        mov     [edx + TssCR3], eax

        ; 
        ; Get double fault stack address
        ;
        lea     eax, [ecx] + 040h                ; DF Exception is 8

        ;
        ; Get to TSS Descriptor of double fault handler TSS
        ;
        xor     ecx, ecx
        mov     cx, word ptr [eax+2]
        add     ecx, PCR[PcGdt]

        ;
        ; Get the address of TSS from this TSS Descriptor
        ;
        mov     ah, [ecx+KgdtBaseHi]
        mov     al, [ecx+KgdtBaseMid]
        shl     eax, 16
        mov     ax, [ecx+KgdtBaseLow]

        ;
        ; Get ESP from DF TSS
        ;
        mov     ecx, [eax+038h]

        ; 
        ; Set address of MCA Exception stack to double fault stack address
        ;
        mov     dword ptr [edx+038h], ecx       ; Set ESP
        mov     dword ptr [edx+TssEsp0], ecx    ; Set ESP0

        mov     dword ptr [edx+020h], offset FLAT:_HalpMcaExceptionHandlerWrapper ; set EIP
        mov     dword ptr [edx+024h], 0             ; set EFLAGS
        mov     word ptr [edx+04ch],KGDT_R0_CODE    ; set value for CS
        mov     word ptr [edx+058h],KGDT_R0_PCR     ; set value for FS
        mov     [edx+050h], ss
        mov     word ptr [edx+048h],KGDT_R3_DATA OR RPL_MASK ; Es
        mov     word ptr [edx+054h],KGDT_R3_DATA OR RPL_MASK ; Ds

        ;
        ; Part that gets done in KiInitialiazeTSS()
        ;
        mov     word ptr [edx + 08], KGDT_R0_DATA   ; Set SS0
        mov     word ptr [edx + 060h],0             ; Set LDT
        mov     word ptr [edx + 064h],0             ; Set T bit
        mov     word ptr [edx + 066h],020adh        ; I/O Map base address = sizeof(KTSS)+1

        ;
        ; Edit GDT entry for KGDT_MCA_TSS to create a valid TSS Descriptor
        ;
        mov     ecx, PCR[PcGdt]                     ; Get GDT address
        lea     eax, [ecx] + KGDT_MCA_TSS           ; offset of MCA TSS in GDT
        mov     ecx, eax

        ;
        ; Set Type field of TSS Descriptor
        ;
        mov     byte ptr [ecx + 5], 089H            ; P=1, DPL=0, Type = 9

        ;
        ; Set Base Address field of TSS Descriptor
        ;
        mov     eax, edx                            ; TSS address in eax
        mov     [ecx + KgdtBaseLow], ax
        shr     eax, 16
        mov     [ecx + KgdtBaseHi],ah
        mov     [ecx + KgdtBaseMid],al

        ;
        ; Set Segment limit for TSS Descriptor
        ;
        mov     eax, MINIMUM_TSS_SIZE
        mov     [ecx + KgdtLimitLow],ax

        stdRET  _HalpMcaCurrentProcessorSetTSS

stdENDP _HalpMcaCurrentProcessorSetTSS

INIT   ends

PAGELK      SEGMENT DWORD PUBLIC 'CODE'
;++
;
;VOID
;HalpSetCr4MCEBit(
;   VOID
;   )
;
;   Routine Description:
;       This function sets the CR4.MCE bit
;
;   Arguments:
;       None
;
;   Return Value:
;       None
;
;--

cPublicProc _HalpSetCr4MCEBit,0

    mov     eax, cr4
    or      eax, CR4_MCE
    mov     cr4, eax
    stdRET  _HalpSetCr4MCEBit

stdENDP _HalpSetCr4MCEBit
 

PAGELK     ends
 
         end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixmovnti.asm ===
title "Hal Copy using Movnti"
;++
;
;Copyright (c) 2000  Microsoft Corporation
;
;Module Name:
;
;    ixmovnti.asm
;
;Abstract:
;
;    HAL routine that uses movnti instruction to copy buffer
;    similar to RtlMovememory but does not support backwards and
;    overlapped move 
;    Based on a previously tested fast copy by Jim crossland.
;Author:
;    Gautham chinya
;    Intel Corp 
;    
;Revision History:
;
;--

.386p

        .xlist
include callconv.inc                    ; calling convention macros
include mac386.inc
        .list
;
; Register Definitions (for instruction macros).
;

rEAX            equ     0
rECX            equ     1
rEDX            equ     2
rEBX            equ     3
rESP            equ     4
rEBP            equ     5
rESI            equ     6
rEDI            equ     7

MEMORY_ALIGNMENT_MASK0  = 63
MEMORY_ALIGNMENT_LOG2_0 = 6

MEMORY_ALIGNMENT_MASK1  = 3
MEMORY_ALIGNMENT_LOG2_1 = 2

sfence            macro
                   db      0FH, 0AEH, 0F8H
                  endm

prefetchnta_short macro   GeneralReg, Offset
                   db      0FH, 018H,  040H + GeneralReg, Offset
                  endm

prefetchnta_long  macro   GeneralReg, Offset
                   db      0FH, 018H,  080h + GeneralReg
                   dd      Offset
                  endm

movnti_eax        macro   GeneralReg, Offset
                   db  0FH, 0C3H, 040H + GeneralReg, Offset
                  endm

movnti_eax_0_disp macro   GeneralReg
                   db  0FH, 0C3H, 000H + GeneralReg
                  endm

movnti_ebx        macro   GeneralReg, Offset
                   db  0FH, 0C3H, 058H + GeneralReg, Offset
                  endm

;
;
; Macro that moves 64bytes (1 cache line using movnti (eax and ebx registers)
;
;

movnticopy64bytes  macro
                    mov    eax, [esi]
                    mov    ebx, [esi + 4]
                    movnti_eax_0_disp rEDI
                    movnti_ebx rEDI, 4

                    mov    eax, [esi + 8]
                    mov    ebx, [esi + 12]
                    movnti_eax rEDI, 8
                    movnti_ebx rEDI, 12

                    mov    eax, [esi + 16]
                    mov    ebx, [esi + 20]
                    movnti_eax rEDI, 16
                    movnti_ebx rEDI, 20

                    mov    eax, [esi + 24]
                    mov    ebx, [esi + 28]
                    movnti_eax rEDI, 24
                    movnti_ebx rEDI, 28

                    mov    eax, [esi + 32]
                    mov    ebx, [esi + 36]
                    movnti_eax rEDI,32
                    movnti_ebx rEDI, 36

                    mov    eax, [esi + 40]
                    mov    ebx, [esi + 44]
                    movnti_eax rEDI, 40
                    movnti_ebx rEDI,  44

                    mov    eax, [esi + 48]
                    mov    ebx, [esi + 52]
                    movnti_eax rEDI,48
                    movnti_ebx rEDI, 52

                    mov    eax, [esi + 56]
                    mov    ebx, [esi + 60]
                    movnti_eax rEDI, 56
                    movnti_ebx rEDI, 60
                  endm



_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
           ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
           page ,132
           subttl  "HalpMovntiCopyBuffer"
;++
;
; VOID
; HalpMovntiCopyBuffer(
;    IN PVOID Destination,
;    IN PVOID Source ,
;    IN ULONG Length
;    )
;
; Routine Description:
;
;    This function copies buffers  
;    in 4-byte blocks using movnti.
;
; Arguments:
;
;    Destination - Supplies a pointer to the destination of the move.
;
;    Source - Supplies a pointer to the memory to move.
;
;    Length - Supplies the Length, in bytes, of the memory to be moved.
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpMovntiCopyBuffer ,3  

; Definitions of arguments
; (TOS) = Return address

EmmDestination  equ     [ebp + 4 + 4]
EmmSource       equ     [ebp + 4 + 8]
EmmLength       equ     [ebp + 4 + 12]

        push    ebp
        mov     ebp, esp
        push    esi
        push    edi
        push    ebx
       
        mov     esi, EmmSource
        mov     edi, EmmDestination
        mov     ecx, EmmLength


;
; Before prefetching we must guarantee the TLB is valid.
;
        mov     eax, [esi]

        cld

;
;Check if less than 64 bytes 
;
 
        mov     edx, ecx
        and     ecx, MEMORY_ALIGNMENT_MASK0
        shr     edx, MEMORY_ALIGNMENT_LOG2_0
        je      Copy4
        dec     edx
        je      copy64

        prefetchnta_short rESI, 128
        dec     edx
        je      copy128

        prefetchnta_short rESI, 192
        dec     edx
        je      copy192


         
copyLoop:

        prefetchnta_long rESI, 256

        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]
        
        dec     edx
        jnz     copyLoop


copy192:


        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]
       
copy128:


        movnticopy64bytes
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]

copy64:

        movnticopy64bytes

        or     ecx, ecx  ; anything less than 64 to do?
        jz     ExitRoutine

        prefetchnta_short rESI, 0
;
;Update pointer for last copy    
;
        
        lea     esi, [esi + 64]
        lea     edi, [edi + 64]

;
;Handle extra bytes here in 32 bit chuncks and then 8-bit bytes    
;

Copy4:
         mov    edx, ecx
         and    ecx, MEMORY_ALIGNMENT_MASK1
         shr    edx, MEMORY_ALIGNMENT_LOG2_1

;
; If the number of 32-bit words to move is non-zero, then do it
;         
         jz     RemainingBytes 

Copy4Loop:
         mov    eax, [esi]
         movnti_eax_0_disp rEDI
         lea    esi, [esi+4]
         lea    edi, [edi+4]
         dec    edx
         jnz    Copy4Loop
         
RemainingBytes:
         or     ecx, ecx
         jz     ExitRoutine
         rep     movsb

ExitRoutine:     

        sfence            ;Make all stores globally visible 
        pop     ebx
        pop     edi
        pop     esi
        pop     ebp
        stdRET  _HalpMovntiCopyBuffer 

stdENDP _HalpMovntiCopyBuffer

_TEXT$03 ends
         end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixisasup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "eisa.h"
#include "pci.h"

#include "pcip.h"


//
//Only take the prototype, don't instantiate
//
#include <wdmguid.h>

#include "halpnpp.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE,HalGetAdapter)
        #pragma alloc_text(PAGE,HalpGetIsaIrqState)
#endif

//
// The HalpNewAdapter event is used to serialize allocations
// of new adapter objects, additions to the HalpEisaAdapter
// array, and some global values (MasterAdapterObject) and some
// adapter fields modified by HalpGrowMapBuffers.
// (AdapterObject->NumberOfMapRegisters is assumed not to be
// growable while this even is held)
//
// Note: We don't really need our own an event object for this.
//

#ifndef ACPI_HAL

#define HalpNewAdapter HalpBusDatabaseEvent
extern KEVENT   HalpNewAdapter;

#else

KEVENT   HalpNewAdapter;

//
//F-Type DMA interface globals
//
ISA_FTYPE_DMA_INTERFACE HalpFDMAInterface;
ULONG  HalpFDMAAvail=FALSE;
ULONG  HalpFDMAChecked=FALSE;
#endif

#define ACQUIRE_NEW_ADAPTER_LOCK()  \
{                                   \
    KeWaitForSingleObject (         \
        &HalpNewAdapter,            \
        WrExecutive,                \
        KernelMode,                 \
        FALSE,                      \
        NULL                        \
        );                          \
}

#define RELEASE_NEW_ADAPTER_LOCK()  \
    KeSetEvent (&HalpNewAdapter, 0, FALSE)

PVOID HalpEisaControlBase = 0;
extern KSPIN_LOCK HalpSystemHardwareLock;

//
// Define save area for EISA adapter objects.
//

PADAPTER_OBJECT HalpEisaAdapter[8];

//
// DMA channel control values
// Global, so zero initialized by the compiler.
//
DMA_CHANNEL_CONTEXT HalpDmaChannelState [EISA_DMA_CHANNELS] ;


extern USHORT HalpEisaIrqMask;


//
// Keep a list of all the dma adapters for debugging purposes
//
LIST_ENTRY HalpDmaAdapterList;
KSPIN_LOCK HalpDmaAdapterListLock;

VOID
HalpCopyBufferMap(
                 IN PMDL Mdl,
                 IN PTRANSLATION_ENTRY TranslationEntry,
                 IN PVOID CurrentVa,
                 IN ULONG Length,
                 IN BOOLEAN WriteToDevice
                 );

PHYSICAL_ADDRESS
HalpMapTransfer(
               IN PADAPTER_OBJECT AdapterObject,
               IN PMDL Mdl,
               IN PVOID MapRegisterBase,
               IN PVOID CurrentVa,
               IN OUT PULONG Length,
               IN BOOLEAN WriteToDevice
               );

VOID
HalpMapTransferHelper(
                     IN PMDL Mdl,
                     IN PVOID CurrentVa,
                     IN ULONG TransferLength,
                     IN PPFN_NUMBER PageFrame,
                     IN OUT PULONG Length
                     );



NTSTATUS
HalAllocateAdapterChannel(
                         IN PADAPTER_OBJECT AdapterObject,
                         IN PWAIT_CONTEXT_BLOCK Wcb,
                         IN ULONG NumberOfMapRegisters,
                         IN PDRIVER_CONTROL ExecutionRoutine
                         )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the adapter on the adapter's queue.  If the queue is already
    "busy", then the adapter has already been allocated, so the device object
    is simply placed onto the queue and waits until the adapter becomes free.

    Once the adapter becomes free (or if it already is), then the driver's
    execution routine is invoked.

    Also, a number of map registers may be allocated to the driver by specifying
    a non-zero value for NumberOfMapRegisters.  Then the map register must be
    allocated from the master adapter.  Once there are a sufficient number of
    map registers available, then the execution routine is called and the
    base address of the allocated map registers in the adapter is also passed
    to the driver's execution routine.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    Wcb - Supplies a wait context block for saving the allocation parameters.
        The DeviceObject, CurrentIrp and DeviceContext should be initalized.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/
{

    PADAPTER_OBJECT MasterAdapter;
    BOOLEAN Busy = FALSE;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;
    ULONG MapRegisterNumber;

    //
    // Begin by obtaining a pointer to the master adapter associated with this
    // request.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Initialize the device object's wait context block in case this device
    // must wait before being able to allocate the adapter.
    //

    Wcb->DeviceRoutine = ExecutionRoutine;
    Wcb->NumberOfMapRegisters = NumberOfMapRegisters;

    //
    // Allocate the adapter object for this particular device.  If the
    // adapter cannot be allocated because it has already been allocated
    // to another device, then return to the caller now;  otherwise,
    // continue.
    //

    if (!KeInsertDeviceQueue( &AdapterObject->ChannelWaitQueue,
                              &Wcb->WaitQueueEntry )) {

        //
        // Save the parameters in case there are not enough map registers.
        //

        AdapterObject->NumberOfMapRegisters = NumberOfMapRegisters;
        AdapterObject->CurrentWcb = Wcb;

        //
        // The adapter was not busy so it has been allocated.  Now check
        // to see whether this driver wishes to allocate any map registers.
        // Ensure that this adapter has enough total map registers
        // to satisfy the request.
        //

        if (NumberOfMapRegisters != 0 && AdapterObject->NeedsMapRegisters) {

            //
            // Lock the map register bit map and the adapter queue in the
            // master adapter object. The channel structure offset is used as
            // a hint for the register search.
            //

            if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
                AdapterObject->NumberOfMapRegisters = 0;
                IoFreeAdapterChannel(AdapterObject);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }

            KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

            MapRegisterNumber = (ULONG)-1;

            if (IsListEmpty( &MasterAdapter->AdapterQueue)) {

                MapRegisterNumber = RtlFindClearBitsAndSet(
                                                  MasterAdapter->MapRegisters,
                                                  NumberOfMapRegisters,
                                                  0
                                                  );
            }

            if (MapRegisterNumber == -1) {

                PBUFFER_GROW_WORK_ITEM bufferWorkItem;

                //
                // There were not enough free map registers.  Queue this request
                // on the master adapter where is will wait until some registers
                // are deallocated.
                //

                InsertTailList( &MasterAdapter->AdapterQueue,
                                &AdapterObject->AdapterQueue
                              );
                Busy = 1;

                //
                // Queue a work item to grow the map registers
                //

                bufferWorkItem =
                    ExAllocatePoolWithTag( NonPagedPool,
                                           sizeof(BUFFER_GROW_WORK_ITEM),
                                           HAL_POOL_TAG);
                if (bufferWorkItem != NULL) {

                    ExInitializeWorkItem( &bufferWorkItem->WorkItem,
                                          HalpGrowMapBufferWorker,
                                          bufferWorkItem );

                    bufferWorkItem->AdapterObject = AdapterObject;
                    bufferWorkItem->MapRegisterCount = NumberOfMapRegisters;

                    ExQueueWorkItem( &bufferWorkItem->WorkItem,
                                     DelayedWorkQueue );

               }

            } else {

                //
                // Calculate the map register base from the allocated map
                // register and base of the master adapter object.
                //

                AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                          MasterAdapter->MapRegisterBase + MapRegisterNumber);

                //
                // Set the no scatter/gather flag if scatter/gather not
                // supported.
                //

                if (!AdapterObject->ScatterGather) {

                    AdapterObject->MapRegisterBase = (PVOID)
                     ((ULONG_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

                }
            }

            KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        } else {

            AdapterObject->MapRegisterBase = NULL;
            AdapterObject->NumberOfMapRegisters = 0;
        }

        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now.
        //

        if (!Busy) {

            AdapterObject->CurrentWcb = Wcb;
            Action = ExecutionRoutine( Wcb->DeviceObject,
                                       Wcb->CurrentIrp,
                                       AdapterObject->MapRegisterBase,
                                       Wcb->DeviceContext );

            //
            // If the driver would like to have the adapter deallocated,
            // then release the adapter object.
            //

            if (Action == DeallocateObject) {

                IoFreeAdapterChannel( AdapterObject );

            } else if (Action == DeallocateObjectKeepRegisters) {

                //
                // Set the NumberOfMapRegisters  = 0 in the adapter object.
                // This will keep IoFreeAdapterChannel from freeing the
                // registers. After this it is the driver's responsiblity to
                // keep track of the number of map registers.
                //

                AdapterObject->NumberOfMapRegisters = 0;
                IoFreeAdapterChannel(AdapterObject);

            }
        }
    }

    return (STATUS_SUCCESS);

}

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called in the context of a work item from
    HalAllocateAdapterChannel() when it queues a map register allocation
    because map regiers are not available.

    Its purpose is to attempt to grow the map buffers for the adapter and,
    if successful, process queued adapter allocations.

Arguments:

    Context - Actually a pointer to a BUFFER_GROW_WORK_ITEM structure.

Return Value:

    None.

--*/

{
    PBUFFER_GROW_WORK_ITEM growWorkItem;
    PADAPTER_OBJECT masterAdapter;
    BOOLEAN allocated;
    ULONG bytesToGrow;
    KIRQL oldIrql;

    growWorkItem = (PBUFFER_GROW_WORK_ITEM)Context;
    masterAdapter = growWorkItem->AdapterObject->MasterAdapter;

    //
    // HalpGrowMapBuffers() takes a byte count
    //

    bytesToGrow = growWorkItem->MapRegisterCount * PAGE_SIZE +
                  INCREMENT_MAP_BUFFER_SIZE;

    ACQUIRE_NEW_ADAPTER_LOCK();

    allocated = HalpGrowMapBuffers( masterAdapter,
                                    bytesToGrow );

    RELEASE_NEW_ADAPTER_LOCK();

    if (allocated != FALSE) {

        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

        //
        // The map buffers were grown.  It is likely that someone is waiting
        // in the adapter queue, so try to get things started.
        //
        // The code in IoFreeMapRegisters() does this, and it turns out
        // we can safely get it to do this work for us by freeing 0
        // map registers at a bogus (but non-NULL) register base.
        //

        IoFreeMapRegisters( growWorkItem->AdapterObject,
                            (PVOID)2,
                            0 );

        KeLowerIrql( oldIrql );

    }

    ExFreePool( growWorkItem );
}



PVOID
HalAllocateCrashDumpRegisters(
                             IN PADAPTER_OBJECT AdapterObject,
                             IN PULONG NumberOfMapRegisters
                             )
/*++

Routine Description:

    This routine is called during the crash dump disk driver's initialization
    to allocate a number map registers permanently.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.
    NumberOfMapRegisters - Number of map registers requested. This field
        will be updated to reflect the actual number of registers allocated
        when the number is less than what was requested.

Return Value:

    Returns STATUS_SUCESS if map registers allocated.

--*/
{
    PADAPTER_OBJECT MasterAdapter;
    ULONG MapRegisterNumber;

    //
    // Begin by obtaining a pointer to the master adapter associated with this
    // request.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Check to see whether this driver needs to allocate any map registers.
    //

    if (AdapterObject->NeedsMapRegisters) {

        //
        // Ensure that this adapter has enough total map registers to satisfy
        // the request.
        //

        if (*NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
            AdapterObject->NumberOfMapRegisters = 0;
            return NULL;
        }

        //
        // Attempt to allocate the required number of map registers w/o
        // affecting those registers that were allocated when the system
        // crashed.
        //

        MapRegisterNumber = (ULONG)-1;

        MapRegisterNumber = RtlFindClearBitsAndSet(
                                                  MasterAdapter->MapRegisters,
                                                  *NumberOfMapRegisters,
                                                  0
                                                  );

        if (MapRegisterNumber == (ULONG)-1) {

            //
            // Not enough free map registers were found, so they were busy
            // being used by the system when it crashed.  Force the appropriate
            // number to be "allocated" at the base by simply overjamming the
            // bits and return the base map register as the start.
            //

            RtlSetBits(
                      MasterAdapter->MapRegisters,
                      0,
                      *NumberOfMapRegisters
                      );
            MapRegisterNumber = 0;

        }

        //
        // Calculate the map register base from the allocated map
        // register and base of the master adapter object.
        //

        AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                      MasterAdapter->MapRegisterBase + MapRegisterNumber);

        //
        // Set the no scatter/gather flag if scatter/gather not
        // supported.
        //

        if (!AdapterObject->ScatterGather) {

            AdapterObject->MapRegisterBase = (PVOID)
                 ((ULONG_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

        }

    } else {

        AdapterObject->MapRegisterBase = NULL;
        AdapterObject->NumberOfMapRegisters = 0;
    }

    return AdapterObject->MapRegisterBase;
}

#ifdef ACPI_HAL

NTSTATUS
HalpFDMANotificationCallback(
                            IN PVOID NotificationStructure,
                            IN PVOID Context
                            )
{
    PAGED_CODE();

    //
    // Something is happening to the ISA bus that we've registered on.
    //

    if (IsEqualGUID (&((PTARGET_DEVICE_REMOVAL_NOTIFICATION)NotificationStructure)->Event,
                     &GUID_TARGET_DEVICE_QUERY_REMOVE)) {

        //
        // It's a query remove, just get out.
        // dereference the interface, and clean up our internal data
        //

        ACQUIRE_NEW_ADAPTER_LOCK();
        HalpFDMAInterface.InterfaceDereference(HalpFDMAInterface.Context);

        HalpFDMAAvail=FALSE;

        //
        // Set checked to false, so that if a new bus arrives we can begin anew.
        //

        HalpFDMAChecked=FALSE;
        RELEASE_NEW_ADAPTER_LOCK();

    }

    return STATUS_SUCCESS;
}

#endif


VOID
HalpAddAdapterToList(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    Adds the adapter object to the HalpDmaAdapterList. This is a separate
    function because HalGetAdapter is paged code and cannot acquire a spinlock.

Arguments:

    AdapterObject - Supplies the adapter object to be added to HalpDmaAdapterList

Return Value:

    None

--*/

{
    KIRQL Irql;

    KeAcquireSpinLock(&HalpDmaAdapterListLock,&Irql);
    InsertTailList(&HalpDmaAdapterList, &AdapterObject->AdapterList);
    KeReleaseSpinLock(&HalpDmaAdapterListLock, Irql);

}

PADAPTER_OBJECT
HalGetAdapter(
             IN PDEVICE_DESCRIPTION DeviceDescriptor,
             OUT PULONG NumberOfMapRegisters
             )

/*++

Routine Description:

    This function returns the appropriate adapter object for the device defined
    in the device description structure.  This code works for Isa and Eisa
    systems.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adapter object or NULL if an adapter could not
    be created.

--*/

{
    PADAPTER_OBJECT adapterObject;
    PVOID adapterBaseVa;
    ULONG channelNumber;
    ULONG controllerNumber;
    DMA_EXTENDED_MODE extendedMode;
    UCHAR adapterMode;
    ULONG numberOfMapRegisters;
    BOOLEAN useChannel;
    ULONG maximumLength;
    UCHAR DataByte;
    BOOLEAN dma32Bit;
    BOOLEAN ChannelEnabled;
    KIRQL Irql;      

#ifdef ACPI_HAL
    NTSTATUS Status;
#endif

    PAGED_CODE();

    //
    // Make sure this is the correct version.
    //

    if (DeviceDescriptor->Version > DEVICE_DESCRIPTION_VERSION2) {
        return ( NULL );
    }

#if DBG
    if (DeviceDescriptor->Version == DEVICE_DESCRIPTION_VERSION1) {
            ASSERT (DeviceDescriptor->Reserved1 == FALSE);
    }
#endif

    *((PUCHAR) &extendedMode) = 0;
    
    //
    // Determine if the the channel number is important.  Master cards on
    // Eisa and Mca do not use a channel number.
    //

    if (DeviceDescriptor->InterfaceType != Isa &&
        DeviceDescriptor->Master) {

        useChannel = FALSE;
    } else {

        useChannel = TRUE;
    }

    // Support for ISA local bus machines:
    // If the driver is a Master but really does not want a channel since it
    // is using the local bus DMA, just don't use an ISA channel.
    //

    if (DeviceDescriptor->InterfaceType == Isa &&
        DeviceDescriptor->DmaChannel > 7) {

        useChannel = FALSE;
    }

    //
    // Determine if Eisa DMA is supported.
    //

    if (HalpBusType == MACHINE_TYPE_EISA) {

        WRITE_PORT_UCHAR(&((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort.Channel2, 0x55);
        DataByte = READ_PORT_UCHAR(&((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort.Channel2);

        if (DataByte == 0x55) {
                HalpEisaDma = TRUE;
        }
    }

    //
    // Limit the maximum length to 2 GB this is done so that the BYTES_TO_PAGES
    // macro works correctly.
    //

    maximumLength = DeviceDescriptor->MaximumLength & 0x7fffffff;

    //
    // Channel 4 cannot be used since it is used for chaining. Return null if
    // it is requested.
    //

    if (DeviceDescriptor->DmaChannel == 4 && useChannel) {
        return (NULL);
    }

    if (DeviceDescriptor->InterfaceType == PCIBus &&
        DeviceDescriptor->Master != FALSE &&
        DeviceDescriptor->ScatterGather != FALSE) {

        //
        // This device can handle 32 bits, even if the caller forgot to
        // set Dma32BitAddresses.
        //

        DeviceDescriptor->Dma32BitAddresses = TRUE;
    }

    dma32Bit = DeviceDescriptor->Dma32BitAddresses;

    //
    // Determine the number of map registers for this device.
    //

    if (DeviceDescriptor->ScatterGather &&

        //
        // If we are not in PAE mode or the device can handle 64 bit addresses,
        // then the device can DMA to any physical location
        //

        (HalPaeEnabled() == FALSE ||
         DeviceDescriptor->Dma64BitAddresses != FALSE) &&

        (LessThan16Mb ||
         DeviceDescriptor->InterfaceType == Eisa ||
         DeviceDescriptor->InterfaceType == PCIBus) ) {

        //
        // Since the device support scatter/Gather then map registers are not
        // required.
        //

        numberOfMapRegisters = 0;

    } else {

        ULONG maximumMapRegisters;
        ULONG mapBufferSize;

        maximumMapRegisters = HalpMaximumMapRegisters( dma32Bit );

        //
        // Determine the number of map registers required based on the maximum
        // transfer length, up to a maximum number.
        //

        numberOfMapRegisters = BYTES_TO_PAGES(maximumLength) + 1;

        if (numberOfMapRegisters > maximumMapRegisters) {
            numberOfMapRegisters = maximumMapRegisters;
        }

        //
        // Make sure there where enough registers allocated initalize to support
        // this size relaibly.  This implies there must be to chunks equal to
        // the allocatd size. This is only a problem on Isa systems where the
        // map buffers cannot cross 64KB boundtires.
        //

        mapBufferSize = HalpMapBufferSize( dma32Bit );

        if (!HalpEisaDma &&
            numberOfMapRegisters > mapBufferSize / (PAGE_SIZE * 2)) {

            numberOfMapRegisters = (mapBufferSize / (PAGE_SIZE * 2));
        }

        //
        // If the device is not a master then it only needs one map register
        // and does scatter/Gather.
        //

        if (DeviceDescriptor->ScatterGather && !DeviceDescriptor->Master) {

            numberOfMapRegisters = 1;
        }
    }

    //
    // Set the channel number number.
    //

    if (useChannel != FALSE) {

        channelNumber = DeviceDescriptor->DmaChannel & 0x03;

        //
        // Set the adapter base address to the Base address register and
        // controller number.
        //

        if (!(DeviceDescriptor->DmaChannel & 0x04)) {

            controllerNumber = 1;
            adapterBaseVa =
                (PVOID) &((PEISA_CONTROL) HalpEisaControlBase)->Dma1BasePort;

        } else {

            controllerNumber = 2;
            adapterBaseVa =
                &((PEISA_CONTROL) HalpEisaControlBase)->Dma2BasePort;

        }
    } else {

        adapterBaseVa = NULL;
    }

    //
    // Determine if a new adapter object is necessary.  If so then allocate it.
    //

    if (useChannel && HalpEisaAdapter[DeviceDescriptor->DmaChannel] != NULL) {

        adapterObject = HalpEisaAdapter[DeviceDescriptor->DmaChannel];

        if (adapterObject->NeedsMapRegisters) {

            if (numberOfMapRegisters > adapterObject->MapRegistersPerChannel) {

                adapterObject->MapRegistersPerChannel = numberOfMapRegisters;
            }
        }

    } else {

        //
        // Serialize before allocating a new adapter
        //

        ACQUIRE_NEW_ADAPTER_LOCK();

        //
        // Determine if a new adapter object has already been allocated.
        // If so use it, otherwise allocate a new adapter object
        //

        if (useChannel && HalpEisaAdapter[DeviceDescriptor->DmaChannel] != NULL) {

            adapterObject = HalpEisaAdapter[DeviceDescriptor->DmaChannel];

            if (adapterObject->NeedsMapRegisters) {

                if (numberOfMapRegisters > adapterObject->MapRegistersPerChannel) {

                    adapterObject->MapRegistersPerChannel = numberOfMapRegisters;
                }
            }

        } else {

            //
            // Allocate an adapter object.
            //

            adapterObject =
                (PADAPTER_OBJECT) HalpAllocateAdapterEx( numberOfMapRegisters,
                                                         adapterBaseVa,
                                                         NULL,
                                                         dma32Bit );
            if (adapterObject == NULL) {
                RELEASE_NEW_ADAPTER_LOCK();
                return (NULL);
            }

            if (useChannel) {

                HalpEisaAdapter[DeviceDescriptor->DmaChannel] = adapterObject;

            }

            //
            // Set the maximum number of map registers for this channel bus on
            // the number requested and the type of device.
            //

            if (numberOfMapRegisters) {

                PADAPTER_OBJECT masterAdapterObject;

                masterAdapterObject =
                    HalpMasterAdapter( dma32Bit );

                //
                // The speicified number of registers are actually allowed to be
                // allocated.
                //

                adapterObject->MapRegistersPerChannel = numberOfMapRegisters;

                //
                // Increase the commitment for the map registers.
                //

                if (DeviceDescriptor->Master) {

                    //
                    // Master I/O devices use several sets of map registers double
                    // their commitment.
                    //

                    masterAdapterObject->CommittedMapRegisters +=
                    numberOfMapRegisters * 2;

                } else {

                    masterAdapterObject->CommittedMapRegisters +=
                    numberOfMapRegisters;

                }

                //
                // If the committed map registers is signicantly greater than the
                // number allocated then grow the map buffer.
                //

                if (masterAdapterObject->CommittedMapRegisters >
                    masterAdapterObject->NumberOfMapRegisters  ) {

                    HalpGrowMapBuffers(
                                      masterAdapterObject,
                                      INCREMENT_MAP_BUFFER_SIZE
                                      );
                }

                adapterObject->NeedsMapRegisters = TRUE;

            } else {

                //
                // No real map registers were allocated.  If this is a master
                // device, then the device can have as may registers as it wants.
                //

                adapterObject->NeedsMapRegisters = FALSE;

                if (DeviceDescriptor->Master) {

                    adapterObject->MapRegistersPerChannel =
                                BYTES_TO_PAGES( maximumLength ) + 1;

                } else {

                    //
                    // The device only gets one register.  It must call
                    // IoMapTransfer repeatedly to do a large transfer.
                    //

                    adapterObject->MapRegistersPerChannel = 1;
                }
            }
        }

        RELEASE_NEW_ADAPTER_LOCK();
    }

    adapterObject->IgnoreCount = FALSE;
    if (DeviceDescriptor->Version >= DEVICE_DESCRIPTION_VERSION1) {

        //
        // Move version 1 structure flags.
        // IgnoreCount is used on machines where the DMA Counter
        // is broken.  (Namely PS/1 model 1000s).  Setting this
        // bit informs the hal not to rely on the DmaCount to determine
        // how much data was DMAed.
        //

        adapterObject->IgnoreCount = DeviceDescriptor->IgnoreCount;
    }

    adapterObject->Dma32BitAddresses = DeviceDescriptor->Dma32BitAddresses;
    adapterObject->Dma64BitAddresses = DeviceDescriptor->Dma64BitAddresses;
    adapterObject->ScatterGather = DeviceDescriptor->ScatterGather;
    *NumberOfMapRegisters = adapterObject->MapRegistersPerChannel;

    if (DeviceDescriptor->Master) {

        adapterObject->MasterDevice = TRUE;

    } else {

        adapterObject->MasterDevice = FALSE;

    }

    //
    // If the channel number is not used then we are finished.  The rest of
    // the work deals with channels.
    //

    if (!useChannel) {

        //
        // Add this adapter to our list
        //
        HalpAddAdapterToList(adapterObject);

        return (adapterObject);
    }

    //
    // Setup the pointers to all the random registers.
    //

    adapterObject->ChannelNumber = (UCHAR) channelNumber;

    if (controllerNumber == 1) {

        switch ((UCHAR)channelNumber) {

            case 0:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel0;
                break;

            case 1:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel1;
                break;

            case 2:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel2;
                break;

            case 3:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel3;
                break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 1;

        //
        // Save the extended mode register address.
        //

        adapterBaseVa =
        &((PEISA_CONTROL) HalpEisaControlBase)->Dma1ExtendedModePort;

    } else {

        switch (channelNumber) {
            case 1:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel5;
                break;

            case 2:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel6;
                break;

            case 3:
                adapterObject->PagePort = (PUCHAR) &((PDMA_PAGE) 0)->Channel7;
                break;
        }

        //
        // Set the adapter number.
        //

        adapterObject->AdapterNumber = 2;

        //
        // Save the extended mode register address.
        //
        adapterBaseVa =
        &((PEISA_CONTROL) HalpEisaControlBase)->Dma2ExtendedModePort;

    }


    adapterObject->Width16Bits = FALSE;


#ifdef ACPI_HAL


    //
    //Keep this code here, because if we ever support dynamic ISA buses (ok, ok, stop laughing)
    //We'll want to be able to re-instantiate the interface to the ISAPNP driver for the new bus
    //

    //
    //Get the interface to the ISA bridge iff it supports an
    //interface to F-type DMA support
    //
    if (DeviceDescriptor->DmaSpeed == TypeF) {
        if (!HalpFDMAChecked) {
            PWSTR HalpFDMAInterfaceList;

            Status=IoGetDeviceInterfaces (&GUID_FDMA_INTERFACE_PRIVATE,NULL,0,&HalpFDMAInterfaceList);

            if (!NT_SUCCESS (Status)) {
                HalpFDMAAvail=FALSE;
            } else {

                if (HalpFDMAInterfaceList) {
                    HalpFDMAAvail=TRUE;
                }
            }
            HalpFDMAChecked=TRUE;

            //
            // Motherboard devices TypeF dma support
            //

            if (HalpFDMAAvail) {

                PDEVICE_OBJECT HalpFDMADevObj;
                PFILE_OBJECT HalpFDMAFileObject;
                PIRP irp;
                KEVENT irpCompleted;
                IO_STATUS_BLOCK statusBlock;
                PIO_STACK_LOCATION irpStack;
                UNICODE_STRING localInterfaceName;

                //
                // Convert the symbolic link to an object reference
                //

                RtlInitUnicodeString (&localInterfaceName,HalpFDMAInterfaceList);
                Status = IoGetDeviceObjectPointer (&localInterfaceName,
                                                   FILE_ALL_ACCESS,
                                                   &HalpFDMAFileObject,
                                                   &HalpFDMADevObj);

                
                ExFreePool (HalpFDMAInterfaceList);

                if (NT_SUCCESS (Status)) {
                    PVOID HalpFDMANotificationHandle;

                    //
                    // Setup the IRP to get the interface
                    //

                    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

                    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                                       HalpFDMADevObj,
                                                       NULL,    // Buffer
                                                       0,       // Length
                                                       0,       // StartingOffset
                                                       &irpCompleted,
                                                       &statusBlock
                                                      );


                    if (!irp) {
                            HalpFDMAAvail=FALSE;
                            goto noFtype;
                    }

                    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
                    irp->IoStatus.Information = 0;

                    //
                    // Initialize the stack location
                    //

                    irpStack = IoGetNextIrpStackLocation(irp);

                    ASSERT(irpStack->MajorFunction == IRP_MJ_PNP);

                    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
                    irpStack->Parameters.QueryInterface.InterfaceType =
                        &GUID_ISA_FDMA_INTERFACE;

                    irpStack->Parameters.QueryInterface.Size =
                        sizeof(ISA_FTYPE_DMA_INTERFACE);

                    irpStack->Parameters.QueryInterface.Version = 1;
                    irpStack->Parameters.QueryInterface.Interface =
                        (PINTERFACE) &HalpFDMAInterface;

                    //
                    // Call the driver and wait for completion
                    //

                    Status = IoCallDriver(HalpFDMADevObj, irp);

                    if (Status == STATUS_PENDING) {

                        KeWaitForSingleObject(&irpCompleted,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL);

                        Status = statusBlock.Status;
                    }

                    if (!NT_SUCCESS(Status)) {
                        HalpFDMAAvail=FALSE;
                        goto noFtype;
                    }

                    //
                    // Now, register a callback so that the ISA bus can go
                    // away.
                    //

                    IoRegisterPlugPlayNotification (EventCategoryTargetDeviceChange,
                                                    0,
                                                    HalpFDMAFileObject,
                                                    HalpFDMADevObj->DriverObject,
                                                    HalpFDMANotificationCallback,
                                                    0,
                                                    &HalpFDMANotificationHandle);

                    //
                    // Release the handle to the interface from IoGetDevicePointer
                    //

                    ObDereferenceObject (HalpFDMAFileObject);

                } else {

                    HalpFDMAAvail=FALSE;
                }
            }
        }

        if (HalpFDMAAvail) {
            ULONG chMask;

            //
            // Fence this, so that no two people can ask for F-Type at once.
            //

            ACQUIRE_NEW_ADAPTER_LOCK();
            Status = HalpFDMAInterface.IsaSetFTypeChannel (HalpFDMAInterface.Context,DeviceDescriptor->DmaChannel,&chMask);
            RELEASE_NEW_ADAPTER_LOCK();

#if DBG
            if (!(NT_SUCCESS (Status))) {

                DbgPrint ("HAL: Tried to get F-Type DMA for channel %d, "
                          "but channel Mask %X already has it!\n",
                          channelNumber,
                          chMask);
            }
#endif
        }

    }
    noFtype:

#endif

    if (HalpEisaDma) {

        //
        // Initialzie the extended mode port.
        //

        extendedMode.ChannelNumber = (UCHAR)channelNumber;

        switch (DeviceDescriptor->DmaSpeed) {
            case Compatible:
                extendedMode.TimingMode = COMPATIBLITY_TIMING;
                break;

            case TypeA:
                extendedMode.TimingMode = TYPE_A_TIMING;
                break;

            case TypeB:
                extendedMode.TimingMode = TYPE_B_TIMING;
                break;

            case TypeC:
                extendedMode.TimingMode = BURST_TIMING;
                break;

            case TypeF:

                //
                // DMA chip should be set to compatibility mode
                // and the bridge handles type-f
                //

                extendedMode.TimingMode = COMPATIBLITY_TIMING;
                break;

            default:
                ObDereferenceObject( adapterObject );
                return (NULL);

        }

        switch (DeviceDescriptor->DmaWidth) {
            case Width8Bits:
                extendedMode.TransferSize = BY_BYTE_8_BITS;
                break;

            case Width16Bits:
                extendedMode.TransferSize = BY_BYTE_16_BITS;

                //
                // Note Width16bits should not be set here because there is no need
                // to shift the address and the transfer count.
                //

                break;

            case Width32Bits:
                extendedMode.TransferSize = BY_BYTE_32_BITS;
                break;

            default:
                ObDereferenceObject( adapterObject );
                return (NULL);

        }

        WRITE_PORT_UCHAR( adapterBaseVa, *((PUCHAR) &extendedMode));

    } else if (!DeviceDescriptor->Master) {

        switch (DeviceDescriptor->DmaWidth) {
            case Width8Bits:

                //
                // The channel must use controller 1.
                //

                if (controllerNumber != 1) {
                    ObDereferenceObject( adapterObject );
                    return (NULL);
                }

                break;

            case Width16Bits:

                //
                // The channel must use controller 2.
                //

                if (controllerNumber != 2) {
                    ObDereferenceObject( adapterObject );
                    return (NULL);
                }

                adapterObject->Width16Bits = TRUE;
                break;

            default:
                ObDereferenceObject( adapterObject );
                return (NULL);

        }
    }

    //
    // Initialize the adapter mode register value to the correct parameters,
    // and save them in the adapter object.
    //
    ChannelEnabled = FALSE;
    adapterMode = 0;
    ((PDMA_EISA_MODE) &adapterMode)->Channel = adapterObject->ChannelNumber;

    if (DeviceDescriptor->Master) {
        ChannelEnabled = TRUE;

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = CASCADE_REQUEST_MODE;

        //
        // Set the mode, and enable the request.
        //

        if (adapterObject->AdapterNumber == 1) {

            //
            // This request is for DMA controller 1
            //

            PDMA1_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                        &dmaControl->SingleMask,
                        (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                        );

        } else {

            //
            // This request is for DMA controller 2
            //

            PDMA2_CONTROL dmaControl;

            dmaControl = adapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

            //
            // Unmask the DMA channel.
            //

            WRITE_PORT_UCHAR(
                        &dmaControl->SingleMask,
                        (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber)
                        );

        }

    } else if (DeviceDescriptor->DemandMode) {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = DEMAND_REQUEST_MODE;

    } else {

        ((PDMA_EISA_MODE) &adapterMode)->RequestMode = SINGLE_REQUEST_MODE;

    }

    if (DeviceDescriptor->AutoInitialize) {

        ((PDMA_EISA_MODE) &adapterMode)->AutoInitialize = 1;

    }

    adapterObject->AdapterMode = adapterMode;

    //
    // Store the value we wrote to the Mode and Mask registers so that we
    // can restore it after the machine sleeps.
    //

    HalpDmaChannelState [adapterObject->ChannelNumber + ((adapterObject->AdapterNumber - 1) * 4)].ChannelMode =
    adapterMode;
    HalpDmaChannelState [adapterObject->ChannelNumber + ((adapterObject->AdapterNumber - 1) * 4)].ChannelExtendedMode =
    *((PUCHAR)&extendedMode);

    HalpDmaChannelState [adapterObject->ChannelNumber + ((adapterObject->AdapterNumber - 1) * 4)].ChannelMask = (ChannelEnabled) ?
        (UCHAR) (DMA_CLEARMASK | adapterObject->ChannelNumber):
            (UCHAR) (DMA_SETMASK | adapterObject->ChannelNumber);

    HalpDmaChannelState [adapterObject->ChannelNumber + ((adapterObject->AdapterNumber - 1) * 4)].ChannelProgrammed = TRUE;

    return (adapterObject);
}


PHYSICAL_ADDRESS
IoMapTransfer(
             IN PADAPTER_OBJECT AdapterObject,
             IN PMDL Mdl,
             IN PVOID MapRegisterBase,
             IN PVOID CurrentVa,
             IN OUT PULONG Length,
             IN BOOLEAN WriteToDevice
             )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    ULONG transferLength;
    PHYSICAL_ADDRESS returnAddress;
    PPFN_NUMBER pageFrame;
    ULONG pageOffset;

    //
    // If the adapter is a 32-bit bus master, take the fast path,
    // otherwise call HalpMapTransfer for the slow path
    //

    if (MapRegisterBase == NULL) {

        pageOffset = BYTE_OFFSET(CurrentVa);

        //
        // Calculate how much of the transfer is contiguous
        //
        transferLength = PAGE_SIZE - pageOffset;
        pageFrame = MmGetMdlPfnArray(Mdl);
        pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT;

        //
        // Compute the starting address of the transfer
        //
        returnAddress.QuadPart =
            ((ULONG64)*pageFrame << PAGE_SHIFT) + pageOffset;

        //
        // If the transfer is not completely contained within
        // a page, call the helper to compute the appropriate
        // length.
        //
        if (transferLength < *Length) {
                HalpMapTransferHelper(Mdl, CurrentVa, transferLength, pageFrame, Length);
        }
        return (returnAddress);
    }

    return (HalpMapTransfer(AdapterObject,
                            Mdl,
                            MapRegisterBase,
                            CurrentVa,
                            Length,
                            WriteToDevice));

}


VOID
HalpMapTransferHelper(
                     IN PMDL Mdl,
                     IN PVOID CurrentVa,
                     IN ULONG TransferLength,
                     IN PPFN_NUMBER PageFrame,
                     IN OUT PULONG Length
                     )

/*++

Routine Description:

    Helper routine for bus master transfers that cross a page
    boundary.  This routine is separated out from the IoMapTransfer
    fast path in order to minimize the total instruction path
    length taken for the common network case where the entire
    buffer being mapped is contained within one page.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    TransferLength = Supplies the current transferLength

    PageFrame - Supplies a pointer to the starting page frame of the transfer

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

Return Value:

    None.  *Length will be updated

--*/

{
    PFN_NUMBER thisPageFrame;
    PFN_NUMBER nextPageFrame;

    do {

        thisPageFrame = *PageFrame;
        PageFrame += 1;
        nextPageFrame = *PageFrame;

        if ((thisPageFrame + 1) != nextPageFrame) {

            //
            // The next page frame is not contiguous with this one,
            // so break the transfer here.
            //

            break;
        }

        if (((thisPageFrame ^ nextPageFrame) & 0xFFFFFFFFFFF00000UI64) != 0) {

            //
            // The next page frame is contiguous with this one,
            // but it crosses a 4GB boundary, another reason to
            // break the transfer.
            //

            break;
        }

        TransferLength += PAGE_SIZE;

    } while ( TransferLength < *Length );


    //
    // Limit the Length to the maximum TransferLength.
    //

    if (TransferLength < *Length) {
        *Length = TransferLength;
    }
}


PHYSICAL_ADDRESS
HalpMapTransfer(
               IN PADAPTER_OBJECT AdapterObject,
               IN PMDL Mdl,
               IN PVOID MapRegisterBase,
               IN PVOID CurrentVa,
               IN OUT PULONG Length,
               IN BOOLEAN WriteToDevice
               )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    BOOLEAN useBuffer;
    ULONG transferLength;
    PHYSICAL_ADDRESS logicalAddress;
    PHYSICAL_ADDRESS returnAddress;
    ULONG index;
    PPFN_NUMBER pageFrame;
    PUCHAR bytePointer;
    UCHAR adapterMode;
    UCHAR dataByte;
    PTRANSLATION_ENTRY translationEntry;
    ULONG pageOffset;
    KIRQL   Irql;
    BOOLEAN masterDevice;
    PHYSICAL_ADDRESS maximumPhysicalAddress;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
                   TRUE : FALSE;

    pageOffset = BYTE_OFFSET(CurrentVa);

#if DBG

    //
    // Catch slave mode devices that seem to want to try and have more than one
    // outstanding request.  If they do then the bus locks.
    //

    if (!masterDevice) {
        ASSERT (HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelBusy == FALSE);

        HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelBusy =
        TRUE;
    }
#endif

    //
    // Calculate how much of the transfer is contiguous.
    //

    transferLength = PAGE_SIZE - pageOffset;
    pageFrame = MmGetMdlPfnArray(Mdl);
    pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT;

    logicalAddress.QuadPart =
        (((ULONGLONG)*pageFrame) << PAGE_SHIFT) + pageOffset;

    //
    // If the buffer is contigous and does not cross a 64 K bountry then
    // just extend the buffer.  The 64 K bountry restriction does not apply
    // to Eisa systems.
    //

    if (HalpEisaDma) {

        while ( transferLength < *Length ) {

            if (*pageFrame + 1 != *(pageFrame + 1)) {
                break;
            }

            transferLength += PAGE_SIZE;
            pageFrame++;

        }

    } else {

        while ( transferLength < *Length ) {

            if (*pageFrame + 1 != *(pageFrame + 1) ||
                (*pageFrame & ~0x0f) != (*(pageFrame + 1) & ~0x0f)) {
                    break;
            }

            transferLength += PAGE_SIZE;
            pageFrame++;
        }
    }

    //
    // Limit the transferLength to the requested Length.
    //

    transferLength = transferLength > *Length ? *Length : transferLength;

    ASSERT(MapRegisterBase != NULL);

    //
    // Strip no scatter/gather flag.
    //

    translationEntry = (PTRANSLATION_ENTRY) ((ULONG_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

    if ((ULONG_PTR) MapRegisterBase & NO_SCATTER_GATHER
        && transferLength < *Length) {

        logicalAddress.QuadPart = translationEntry->PhysicalAddress + pageOffset;
        translationEntry->Index = COPY_BUFFER;
        index = 0;
        transferLength = *Length;
        useBuffer = TRUE;

    } else {

        //
        // If there are map registers, then update the index to indicate
        // how many have been used.
        //

        useBuffer = FALSE;
        index = translationEntry->Index;
        translationEntry->Index += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                                                 CurrentVa,
                                                                 transferLength
                                                                 );
        //
        // PeterJ added the following to catch drivers which don't call
        // IoFlushAdapterBuffers.   Calling IoMapTransfer repeatedly
        // without calling IoFlushAdapterBuffers will run you out of
        // map registers,....  Some PCI device drivers think they can
        // get away with this because they do 32 bit direct transfers.
        // Try plugging one of these into a system with > 4GB and see
        // what happens to you.
        //
        ASSERT(translationEntry->Index <=
               AdapterObject->MapRegistersPerChannel);
    }

    //
    // It must require memory to be within the adapter's address range.  If the
    // logical address is greater than that which the adapter can directly
    // access then map registers must be used
    //

    maximumPhysicalAddress =
        HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

    if ((ULONGLONG)(logicalAddress.QuadPart + transferLength - 1) >
        (ULONGLONG)maximumPhysicalAddress.QuadPart) {

        logicalAddress.QuadPart = (translationEntry + index)->PhysicalAddress +
                                  pageOffset;
        useBuffer = TRUE;

        if ((ULONG_PTR) MapRegisterBase & NO_SCATTER_GATHER) {

            translationEntry->Index = COPY_BUFFER;
            index = 0;

        }

    }

    //
    // Copy the data if necessary.
    //

    if (useBuffer  &&  WriteToDevice) {
        HalpCopyBufferMap(
                         Mdl,
                         translationEntry + index,
                         CurrentVa,
                         transferLength,
                         WriteToDevice
                         );
    }

    //
    // Return the length.
    //

    *Length = transferLength;

    //
    // Return the logical address to transfer to.
    //

    returnAddress = logicalAddress;

    //
    // If no adapter was specificed then there is no more work to do so
    // return.
    //

    if (AdapterObject == NULL || AdapterObject->MasterDevice) {

        return (returnAddress);
    }

    //
    // Determine the mode based on the transfer direction.
    //

    adapterMode = AdapterObject->AdapterMode;
    if (WriteToDevice) {
        ((PDMA_EISA_MODE) &adapterMode)->TransferType = (UCHAR) WRITE_TRANSFER;
    } else {
        ((PDMA_EISA_MODE) &adapterMode)->TransferType = (UCHAR) READ_TRANSFER;

        if (AdapterObject->IgnoreCount) {

            //
            // When the DMA is over there will be no way to tell how much
            // data was transfered, so the entire transfer length will be
            // copied.  To ensure that no stale data is returned to the
            // caller zero the buffer before hand.
            //

            RtlZeroMemory (
                          (PUCHAR) translationEntry[index].VirtualAddress + pageOffset,
                          transferLength
                          );
        }
    }

    bytePointer = (PUCHAR) &logicalAddress;

    if (AdapterObject->Width16Bits) {

        //
        // If this is a 16 bit transfer then adjust the length and the address
        // for the 16 bit DMA mode.
        //

        transferLength >>= 1;

        //
        // In 16 bit DMA mode the low 16 bits are shifted right one and the
        // page register value is unchanged. So save the page register value
        // and shift the logical address then restore the page value.
        //

        dataByte = bytePointer[2];
        logicalAddress.QuadPart >>= 1;
        bytePointer[2] = dataByte;

    }


    //
    // grab the spinlock for the system DMA controller
    //

    KeAcquireSpinLock( &AdapterObject->MasterAdapter->SpinLock, &Irql );

    //
    // Determine the controller number based on the Adapter number.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseAddress,
                        bytePointer[0]
                        );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseAddress,
                        bytePointer[1]
                        );

        WRITE_PORT_UCHAR(
                        ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
                        (ULONG_PTR)AdapterObject->PagePort,
                        bytePointer[2]
                        );

        if (HalpEisaDma) {

            //
            // Write the high page register with zero value. This enable a special mode
            // which allows ties the page register and base count into a single 24 bit
            // address register.
            //

            WRITE_PORT_UCHAR(
                            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
                            (ULONG_PTR)AdapterObject->PagePort,
                            0
                            );
        }

        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseCount,
                        (UCHAR) ((transferLength - 1) & 0xff)
                        );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseCount,
                        (UCHAR) ((transferLength - 1) >> 8)
                        );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
                        &dmaControl->SingleMask,
                        (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
                        );

    } else {

        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        WRITE_PORT_UCHAR( &dmaControl->Mode, adapterMode );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseAddress,
                        bytePointer[0]
                        );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseAddress,
                        bytePointer[1]
                        );

        WRITE_PORT_UCHAR(
                        ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageLowPort) +
                        (ULONG_PTR)AdapterObject->PagePort,
                        bytePointer[2]
                        );

        if (HalpEisaDma) {

            //
            // Write the high page register with zero value. This enable a
            // special mode which allows ties the page register and base
            // count into a single 24 bit address register.
            //

            WRITE_PORT_UCHAR(
                            ((PUCHAR) &((PEISA_CONTROL) HalpEisaControlBase)->DmaPageHighPort) +
                            (ULONG_PTR)AdapterObject->PagePort,
                            0
                            );
        }

        //
        // Notify DMA chip of the length to transfer.
        //

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseCount,
                        (UCHAR) ((transferLength - 1) & 0xff)
                        );

        WRITE_PORT_UCHAR(
                        &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                        .DmaBaseCount,
                        (UCHAR) ((transferLength - 1) >> 8)
                        );


        //
        // Set the DMA chip to read or write mode; and unmask it.
        //

        WRITE_PORT_UCHAR(
                        &dmaControl->SingleMask,
                        (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber)
                        );

    }

    //
    // Record what we wrote to the mask register.
    //

    HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelMask =
    (UCHAR) (DMA_CLEARMASK | AdapterObject->ChannelNumber);


    KeReleaseSpinLock (&AdapterObject->MasterAdapter->SpinLock, Irql);
    return (returnAddress);
}

BOOLEAN
IoFlushAdapterBuffers(
                     IN PADAPTER_OBJECT AdapterObject,
                     IN PMDL Mdl,
                     IN PVOID MapRegisterBase,
                     IN PVOID CurrentVa,
                     IN ULONG Length,
                     IN BOOLEAN WriteToDevice
                     )

/*++

Routine Description:

    This routine flushes the DMA adapter object buffers.  For the Jazz system
    its clears the enable flag which aborts the dma.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
        buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
        or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
        where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
        the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    PTRANSLATION_ENTRY translationEntry;
    PPFN_NUMBER pageFrame;
    ULONG transferLength;
    ULONG partialLength;
    BOOLEAN masterDevice;
    PHYSICAL_ADDRESS maximumPhysicalAddress;
    ULONG maximumPhysicalPage;

    masterDevice = AdapterObject == NULL || AdapterObject->MasterDevice ?
                   TRUE : FALSE;

    //
    // If this is a slave device, then stop the DMA controller.
    //

    if (!masterDevice) {

        //
        // Mask the DMA request line so that DMA requests cannot occur.
        //

        if (AdapterObject->AdapterNumber == 1) {

            //
            // This request is for DMA controller 1
            //

            PDMA1_CONTROL dmaControl;

            dmaControl = AdapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR(
                            &dmaControl->SingleMask,
                            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
                            );

        } else {

            //
            // This request is for DMA controller 2
            //

            PDMA2_CONTROL dmaControl;

            dmaControl = AdapterObject->AdapterBaseVa;

            WRITE_PORT_UCHAR(
                            &dmaControl->SingleMask,
                            (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber)
                            );

        }

        //
        // Record what we wrote to the mask register.
        //

        HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelMask =
        (UCHAR) (DMA_SETMASK | AdapterObject->ChannelNumber);

        //
        // Mark the channel as not in use
        //
#if DBG
        HalpDmaChannelState [AdapterObject->ChannelNumber + ((AdapterObject->AdapterNumber - 1) * 4)].ChannelBusy =
        FALSE;
#endif
    }

    if (MapRegisterBase == NULL) {
        return (TRUE);
    }

    //
    // Determine if the data needs to be copied to the orginal buffer.
    // This only occurs if the data tranfer is from the device, the
    // MapReisterBase is not NULL and the transfer spans a page.
    //

    if (!WriteToDevice) {

        //
        // Strip no scatter/gather flag.
        //

        translationEntry = (PTRANSLATION_ENTRY) ((ULONG_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

        //
        // If this is not a master device, then just transfer the buffer.
        //

        if ((ULONG_PTR) MapRegisterBase & NO_SCATTER_GATHER) {

            if (translationEntry->Index == COPY_BUFFER) {

                if (!masterDevice && !AdapterObject->IgnoreCount) {

                    //
                    // Copy only the bytes that have actually been transfered.
                    //
                    //

                    Length -= HalReadDmaCounter(AdapterObject);
                }

                //
                // The adapter does not support scatter/gather copy the buffer.
                //

                HalpCopyBufferMap(
                                 Mdl,
                                 translationEntry,
                                 CurrentVa,
                                 Length,
                                 WriteToDevice
                                 );

            }

        } else {

            //
            // Cycle through the pages of the transfer to determine if there
            // are any which need to be copied back.
            //

            maximumPhysicalAddress =
                HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

            maximumPhysicalPage =
                (ULONG)(maximumPhysicalAddress.QuadPart >> PAGE_SHIFT);

            transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
            partialLength = transferLength;
            pageFrame = MmGetMdlPfnArray(Mdl);
            pageFrame += ((ULONG_PTR) CurrentVa - (ULONG_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT;

            while ( transferLength <= Length ) {

                if (*pageFrame > maximumPhysicalPage) {

                    HalpCopyBufferMap(
                                     Mdl,
                                     translationEntry,
                                     CurrentVa,
                                     partialLength,
                                     WriteToDevice
                                     );

                }

                (PCCHAR) CurrentVa += partialLength;
                partialLength = PAGE_SIZE;

                //
                // Note that transferLength indicates the amount which will be
                // transfered after the next loop; thus, it is updated with the
                // new partial length.
                //

                transferLength += partialLength;
                pageFrame++;
                translationEntry++;
            }

            //
            // Process the any remaining residue.
            //

            partialLength = Length - transferLength + partialLength;
            if (partialLength && *pageFrame > maximumPhysicalPage) {

                HalpCopyBufferMap(
                                 Mdl,
                                 translationEntry,
                                 CurrentVa,
                                 partialLength,
                                 WriteToDevice
                                 );

            }
        }
    }

    //
    // Strip no scatter/gather flag.
    //

    translationEntry = (PTRANSLATION_ENTRY) ((ULONG_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

    //
    // Clear index in map register.
    //

    translationEntry->Index = 0;

    return TRUE;
}

ULONG
HalReadDmaCounter(
                 IN PADAPTER_OBJECT AdapterObject
                 )
/*++

Routine Description:

    This function reads the DMA counter and returns the number of bytes left
    to be transfered.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object to be read.

Return Value:

    Returns the number of bytes still be be transfered.

--*/

{
    ULONG count;
    ULONG high;
    KIRQL Irql;

    //
    // Grab the spinlock for the system DMA controller.
    //

    KeAcquireSpinLock( &AdapterObject->MasterAdapter->SpinLock, &Irql );

    //
    // Determine the controller number based on the Adapter number.
    //

    if (AdapterObject->AdapterNumber == 1) {

        //
        // This request is for DMA controller 1
        //

        PDMA1_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );


        //
        // Initialize count to a value which will not match.
        //

        count = 0xFFFF00;

        //
        // Loop until the same high byte is read twice.
        //

        do {

            high = count;

            WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

            //
            // Read the current DMA count.
            //

            count = READ_PORT_UCHAR(
                                   &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                                   .DmaBaseCount
                                   );

            count |= READ_PORT_UCHAR(
                                    &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                                    .DmaBaseCount
                                    ) << 8;

        } while ((count & 0xFFFF00) != (high & 0xFFFF00));

    } else {

        //
        // This request is for DMA controller 2
        //

        PDMA2_CONTROL dmaControl;

        dmaControl = AdapterObject->AdapterBaseVa;

        WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

        //
        // Initialize count to a value which will not match.
        //

        count = 0xFFFF00;

        //
        // Loop until the same high byte is read twice.
        //

        do {

            high = count;

            WRITE_PORT_UCHAR( &dmaControl->ClearBytePointer, 0 );

            //
            // Read the current DMA count.
            //

            count = READ_PORT_UCHAR(
                                   &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                                   .DmaBaseCount
                                   );

            count |= READ_PORT_UCHAR(
                                    &dmaControl->DmaAddressCount[AdapterObject->ChannelNumber]
                                    .DmaBaseCount
                                    ) << 8;

        } while ((count & 0xFFFF00) != (high & 0xFFFF00));

    }

    //
    // Release the spinlock for the system DMA controller.
    //

    KeReleaseSpinLock( &AdapterObject->MasterAdapter->SpinLock, Irql );

    //
    // The DMA counter has a bias of one and can only be 16 bit long.
    //

    count = (count + 1) & 0xFFFF;

    //
    // If this is a 16 bit dma the multiply the count by 2.
    //

    if (AdapterObject->Width16Bits) {

        count *= 2;

    }

    return (count);
}

ULONG
HalpGetIsaIrqState(
                  ULONG   Vector
                  )
{
    ULONG   vectorState = CM_RESOURCE_INTERRUPT_LATCHED;

    if (HalpBusType == MACHINE_TYPE_EISA) {

        if (HalpEisaIrqMask & (1 << Vector)) {

            vectorState = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        }
    }

    return vectorState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixpcibrd.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcibrd.c

Abstract:

    Get PCI-PCI bridge information

Author:

    Ken Reneris (kenr) 14-June-1994

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "stdio.h"

// debugging only...
// #define INIT_PCI_BRIDGE 1

extern WCHAR rgzMultiFunctionAdapter[];
extern WCHAR rgzConfigurationData[];
extern WCHAR rgzIdentifier[];
extern WCHAR rgzReservedResources[];


#if DBG
#define DBGMSG(a)   DbgPrint(a)
#else
#define DBGMSG(a)
#endif



#define IsPciBridge(a)                                         \
            ((a)->VendorID != PCI_INVALID_VENDORID          && \
             PCI_CONFIG_TYPE(a) == PCI_BRIDGE_TYPE          && \
             (a)->BaseClass == PCI_CLASS_BRIDGE_DEV         && \
             (a)->SubClass  == PCI_SUBCLASS_BR_PCI_TO_PCI)

#define IsCardbusBridge(a)                                     \
            ((a)->VendorID != PCI_INVALID_VENDORID          && \
             PCI_CONFIG_TYPE(a) == PCI_CARDBUS_BRIDGE_TYPE  && \
             (a)->BaseClass == PCI_CLASS_BRIDGE_DEV         && \
             (a)->SubClass  == PCI_SUBCLASS_BR_CARDBUS)

typedef struct {
    ULONG               BusNo;
    PBUS_HANDLER        BusHandler;
    PPCIPBUSDATA        BusData;
    PCI_SLOT_NUMBER     SlotNumber;
    PPCI_COMMON_CONFIG  PciData;
    ULONG               IO, Memory, PFMemory;
    UCHAR               Buffer[PCI_COMMON_HDR_LENGTH];
} CONFIGBRIDGE, *PCONFIGBRIDGE;

//
// Internal prototypes
//


#ifdef INIT_PCI_BRIDGE
VOID
HalpGetPciBridgeNeeds (
    IN ULONG            HwType,
    IN PUCHAR           MaxPciBus,
    IN PCONFIGBRIDGE    Current
    );
#endif

VOID
HalpSetPciBridgedVgaCronk (
    IN ULONG BusNumber,
    IN ULONG Base,
    IN ULONG Limit
    );


ULONG
HalpGetBridgedPCIInterrupt (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

ULONG
HalpGetBridgedPCIISAInt (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

VOID
HalpPCIBridgedPin2Line (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );


VOID
HalpPCIBridgedLine2Pin (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

NTSTATUS
HalpGetBridgedPCIIrqTable (
    IN PBUS_HANDLER     BusHandler,
    IN PBUS_HANDLER     RootHandler,
    IN PCI_SLOT_NUMBER  PciSlot,
    OUT PUCHAR          IrqTable
    );




#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpGetPciBridgeConfig)
#pragma alloc_text(INIT,HalpSetPciBridgedVgaCronk)
#pragma alloc_text(INIT,HalpFixupPciSupportedRanges)

#ifdef INIT_PCI_BRIDGE
#pragma alloc_text(PAGE,HalpGetBridgedPCIInterrupt)
//#pragma alloc_text(PAGE,HalpGetBridgedPCIIrqTable)
#pragma alloc_text(INIT,HalpGetPciBridgeNeeds)
#endif
#endif

VOID
HalpCardBusPin2Line(
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )

/*++

Routine Description:

    Devices on CardBus busses use the interrupt assigned to the bridge.
    That's how it works.

Arguments:

    BusHandler      Bus Handler for the bus this (cardbus) device.  That
                    is, the bus handler which was created for the bridge
                    under which this device resides.
    RootHandler     Pointer to the bus handler for the root.
    SlotNumber      Slot number for the cardbus device (typically 0).
    PciData         PCI Config space common header (64 bytes).

Return Value:

    None.

--*/

{
    PPCIPBUSDATA        ChildBusData;
    ULONG               Length;
    UCHAR               ParentInterruptLine;

    //
    // If this device doesn't use interrupts, do nothing.
    //

    if (!PciData->u.type0.InterruptPin) {
        return;
    }

    ChildBusData  = (PPCIPBUSDATA)BusHandler->BusData;

    //
    // Read the interrupt information from the parent, ie the 
    // cardbus bridge's config space.
    //
    // Note: We use HalGetBusData because it will do the Pin2Line
    // function in the parent for us.

    Length = HalGetBusDataByOffset(
                 PCIConfiguration,
                 ChildBusData->ParentBus,
                 ChildBusData->CommonData.ParentSlot.u.AsULONG,
                 &ParentInterruptLine,
                 FIELD_OFFSET(PCI_COMMON_CONFIG, u.type2.InterruptLine),
                 sizeof(ParentInterruptLine)
                 );

    //
    // Return the parent's interrupt line value.
    //

    PciData->u.type0.InterruptLine = ParentInterruptLine;
}
   
VOID
HalpPciMakeBusAChild(
    IN PBUS_HANDLER Child,
    IN PBUS_HANDLER Parent
    )

/*++

Routine Description:

    Make bus 'Child' a child of bus 'Parent'.   This routine is used
    when the child bus is disabled or not really present.   The child
    bus consumes no resources.

Arguments:

    Child       The bus which is to become a child.
    Parent      The bus Child is a child of.

Return Value:

    None.

--*/

{
    HalpSetBusHandlerParent(Child, Parent);
    ((PPCIPBUSDATA)(Child->BusData))->ParentBus = (UCHAR)Parent->BusNumber;

    //
    // Give the bus an empty range list so it isn't
    // consumed from the parent.
    //

    HalpFreeRangeList(Child->BusAddresses);
    Child->BusAddresses = HalpAllocateNewRangeList();
}

BOOLEAN
HalpGetPciBridgeConfig (
    IN ULONG            HwType,
    IN PUCHAR           MaxPciBus
    )
/*++

Routine Description:

    Scan the devices on all known pci buses trying to locate any
    pci to pci bridges.  Record the hierarchy for the buses, and
    which buses have what addressing limits.

Arguments:

    HwType      - Configuration type.
    MaxPciBus   - # of PCI buses reported by the bios

--*/
{
    PBUS_HANDLER        ChildBus;
    PBUS_HANDLER        LastKnownRoot;
    PPCIPBUSDATA        ChildBusData;
    ULONG               d, f, i, j, BusNo;
    ULONG               ChildBusNo, ChildSubNo, ChildPrimaryBusNo;
    ULONG               FixupBusNo;
    UCHAR               Rescan, TestLimit1, TestLimit2;
    BOOLEAN             FoundDisabledBridge;
    BOOLEAN             FoundSomeFunction;
    CONFIGBRIDGE        CB;

    Rescan = 0;
    FoundDisabledBridge = FALSE;

    //
    // Find each bus on a bridge and initialize it's base and limit information
    //

    CB.PciData = (PPCI_COMMON_CONFIG) CB.Buffer;
    CB.SlotNumber.u.bits.Reserved = 0;
    for (BusNo=0; BusNo < *MaxPciBus; BusNo++) {

        CB.BusHandler = HalpHandlerForBus (PCIBus, BusNo);
        CB.BusData = (PPCIPBUSDATA) CB.BusHandler->BusData;
        FoundSomeFunction = FALSE;

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            CB.SlotNumber.u.bits.DeviceNumber = d;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                CB.SlotNumber.u.bits.FunctionNumber = f;

                //
                // Read PCI configuration information
                //

                HalpReadPCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    CB.PciData,
                    0,
                    PCI_COMMON_HDR_LENGTH
                    );

                if (CB.PciData->VendorID == PCI_INVALID_VENDORID) {
                    // function not populated
                    continue;
                }

                FoundSomeFunction = TRUE;

                if (IsPciBridge(CB.PciData)) {

                    //
                    // PCI-PCI bridge
                    //

                    ChildBusNo = (ULONG)CB.PciData->u.type1.SecondaryBus;
                    ChildSubNo = (ULONG)CB.PciData->u.type1.SubordinateBus;
                    ChildPrimaryBusNo = (ULONG)CB.PciData->u.type1.PrimaryBus;

                } else if (IsCardbusBridge(CB.PciData)) {

                    //
                    // PCI-Cardbus bridge
                    //

                    ChildBusNo = (ULONG)CB.PciData->u.type2.SecondaryBus;
                    ChildSubNo = (ULONG)CB.PciData->u.type2.SubordinateBus;
                    ChildPrimaryBusNo = (ULONG)CB.PciData->u.type2.PrimaryBus;

                } else {

                    //
                    // Not a known bridge type, next function.
                    //

                    continue;
                }

                //
                // Whenever we find a bridge, mark all all bus nodes that
                // have not already been processed between this bus and
                // the new child as children of this bus.
                //
                // eg if, on bus 0, we find a bridge to bus 6 thru 8, mark
                // busses 1 thru 8 as a child of 0.  (unless they have
                // already been processed).
                //
                // This stops non-existant busses in the gap between the
                // primary bus and the first child bus from looking like
                // additional root busses.
                //

                for (FixupBusNo = CB.BusHandler->BusNumber + 1;
                     FixupBusNo <= ChildSubNo;
                     FixupBusNo++) {

                    ChildBus = HalpHandlerForBus(PCIBus, FixupBusNo);

                    if (ChildBus == NULL) {
                        continue;
                    }
    
                    ChildBusData = (PPCIPBUSDATA) ChildBus->BusData;

                    if (ChildBusData->BridgeConfigRead) {

                        //
                        // This child bus's relationships already processed
                        //

                        continue;
                    }
    
                    HalpPciMakeBusAChild(ChildBus, CB.BusHandler);
                    ChildBusData->CommonData.ParentSlot = CB.SlotNumber;
                }

                if (!(CB.PciData->Command & 
                      (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE))) {
                    // this PCI bridge is not enabled - skip it for now
                    
                    FoundDisabledBridge = TRUE;

                    // Even though the bridge is disabled the bus number
                    // may have been set.  If so then update the parent
                    // child relation ship so that the we do not see this
                    // as a root bus.
                    
                    if (ChildBusNo <= CB.BusHandler->BusNumber) {
                        continue;
                    }

                    ChildBus = HalpHandlerForBus (PCIBus, ChildBusNo);
                    if (ChildBus == NULL) {

                        //
                        // Even though the bus is currently disabled,
                        // the system may configure it so we still 
                        // want a bus handler created for it.
                        //

                        if (ChildBusNo > Rescan) {
                            Rescan = (UCHAR)ChildBusNo;
                        }
                        continue;
                    }
    
                    ChildBusData = (PPCIPBUSDATA) ChildBus->BusData;
                    if (ChildBusData->BridgeConfigRead) {
                        // this child buses relationships already processed
                        continue;
                    }
    
                    HalpPciMakeBusAChild(ChildBus, CB.BusHandler);
                    ChildBusData->CommonData.ParentSlot = CB.SlotNumber;

                    //
                    // Even though we won't actually configure the
                    // bridge, mark the configuration as read so we 
                    // don't mistake it for a root bus.
                    //

                    ChildBusData->BridgeConfigRead = TRUE;
                    continue;
                }

                if (ChildPrimaryBusNo != CB.BusHandler->BusNumber) {

                    DBGMSG ("HAL GetPciData: bad primarybus!!!\n");
                    // skip it...
                    continue;
                }

                if (ChildBusNo <= CB.BusHandler->BusNumber) {

                    // secondary bus number doesn't make any sense.  HP Omnibook may
                    // not fill this field in on a virtually disabled pci-pci bridge

                    FoundDisabledBridge = TRUE;
                    continue;
                }

                //
                // Found a PCI-PCI bridge.  Determine it's parent child
                // releationships
                //

                ChildBus = HalpHandlerForBus (PCIBus, ChildBusNo);
                if (!ChildBus) {
                    DBGMSG ("HAL GetPciData: found configured pci bridge\n");

                    // up the number of buses
                    if (ChildBusNo > Rescan) {
                        Rescan = (UCHAR)ChildBusNo;
                    }
                    continue;
                }

                ChildBusData = (PPCIPBUSDATA) ChildBus->BusData;
                if (ChildBusData->BridgeConfigRead) {
                    // this child buses releationships already processed
                    continue;
                }

                //
                // Remember the limits which are programmed into this bridge
                //

                ChildBusData->BridgeConfigRead = TRUE;
                HalpSetBusHandlerParent (ChildBus, CB.BusHandler);
                ChildBusData->ParentBus = (UCHAR) CB.BusHandler->BusNumber;
                ChildBusData->CommonData.ParentSlot = CB.SlotNumber;

                if (IsCardbusBridge(CB.PciData)) {

                    //
                    // Cardbus handled by the PCI driver, don't try to
                    // interpret here.
                    //

                    HalpFreeRangeList(ChildBus->BusAddresses);
                    ChildBus->BusAddresses = HalpAllocateNewRangeList();

                    //
                    // Pin to Line (and vis-versa) for a device plugged
                    // into the cardbus bus, get the same values as the
                    // bridge itself.  Override the line2pin routine in
                    // the cardbus bridge handler to use the parent's
                    // slot value.   Note:  line2pin doesn't do much.
                    // In DBG PC/AT builds, it simply undoes the IRQXOR
                    // used to catch drivers that are accessing the h/w
                    // directly.   The normal routine will do this just
                    // fine so we don't need to override it as well.
                    //

                    ChildBusData->CommonData.Pin2Line = HalpCardBusPin2Line;
                    continue;
                }

                ChildBus->BusAddresses->IO.Base =
                            PciBridgeIO2Base(
                                CB.PciData->u.type1.IOBase,
                                CB.PciData->u.type1.IOBaseUpper16
                                );

                ChildBus->BusAddresses->IO.Limit =
                            PciBridgeIO2Limit(
                                CB.PciData->u.type1.IOLimit,
                                CB.PciData->u.type1.IOLimitUpper16
                                );

                ChildBus->BusAddresses->IO.SystemAddressSpace = 1;

                //
                // Special VGA address remapping occuring on this bridge?
                //

                if (CB.PciData->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_VGA) {

                    //
                    // Yes, then this bridge is positively decoding the
                    // range 0xA0000 thru 0xBFFFF regardless of the memory
                    // range settings.  Add this range, if it overlaps it
                    // will get cleaned up later.
                    //
                    // Also, IO ranges 3b0 thru 3bb and 3c0 thru 3df.
                    //

                    HalpAddRange(
                        &ChildBus->BusAddresses->Memory,
                        0,              // address space
                        0,              // system base
                        0xa0000,        // range base
                        0xbffff         // range limit
                        );

                    HalpAddRange(
                        &ChildBus->BusAddresses->IO,
                        1,              // address space
                        0,              // system base
                        0x3b0,          // range base
                        0x3bb           // range limit
                        );

                    HalpAddRange(
                        &ChildBus->BusAddresses->IO,
                        1,              // address space
                        0,              // system base
                        0x3c0,          // range base
                        0x3df           // range limit
                        );

                    //
                    // Claim all aliases to these IO addresses.
                    // 
                    // Bits 15:10 are not decoded so anything in
                    // the same 10 bits as the above in the range
                    // 0x400 thru 0xffff is an alias.
                    //

                    HalpSetPciBridgedVgaCronk (
                        ChildBus->BusNumber,
                        0x0400,
                        0xffff
                        );
                }

                //
                // If supported I/O ranges on this bus are limitied to
                // 256bytes on every 1K aligned boundry within the
                // range, then redo supported IO BusAddresses to match
                //

                if (CB.PciData->u.type1.BridgeControl & PCI_ENABLE_BRIDGE_ISA  &&
                    ChildBus->BusAddresses->IO.Base < ChildBus->BusAddresses->IO.Limit) {

                    // assume Base is 1K aligned
                    i = (ULONG) ChildBus->BusAddresses->IO.Base;
                    j = (ULONG) ChildBus->BusAddresses->IO.Limit;

                    // convert head entry
                    ChildBus->BusAddresses->IO.Limit = i + 255;
                    i += 1024;

                    // add remaining ranges
                    while (i < j) {
                        HalpAddRange (
                            &ChildBus->BusAddresses->IO,
                            1,          // address space
                            0,          // system base
                            i,          // bus address
                            i + 255     // bus limit
                            );

                        // next range
                        i += 1024;
                    }
                }

                ChildBus->BusAddresses->Memory.Base =
                        PciBridgeMemory2Base(CB.PciData->u.type1.MemoryBase);

                ChildBus->BusAddresses->Memory.Limit =
                        PciBridgeMemory2Limit(CB.PciData->u.type1.MemoryLimit);

                // On x86 it's ok to clip Prefetch to 32 bits

                if (CB.PciData->u.type1.PrefetchBaseUpper32 == 0) {
                    ChildBus->BusAddresses->PrefetchMemory.Base =
                            PciBridgeMemory2Base(CB.PciData->u.type1.PrefetchBase);


                    ChildBus->BusAddresses->PrefetchMemory.Limit =
                            PciBridgeMemory2Limit(CB.PciData->u.type1.PrefetchLimit);

                    if (CB.PciData->u.type1.PrefetchLimitUpper32) {
                        ChildBus->BusAddresses->PrefetchMemory.Limit = 0xffffffff;
                    }
                }

                //
                // h/w hack the Win9x people allowed folks to make.  Determine
                // if the bridge is subtractive decode or not by seeing if
                // it's IObase/limit is read-only.
                //

                TestLimit1 = CB.PciData->u.type1.IOLimit + 1;
                if (!TestLimit1) {
                    TestLimit1 = 0xFE;
                }
#if 0
                DbgPrint ("PciBridge OrigLimit=%d TestLimit=%d ",
                    CB.PciData->u.type1.IOLimit,
                    TestLimit1
                    );
#endif

                HalpWritePCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    &TestLimit1,
                    FIELD_OFFSET (PCI_COMMON_CONFIG, u.type1.IOLimit),
                    1
                    );

                HalpReadPCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    &TestLimit2,
                    FIELD_OFFSET (PCI_COMMON_CONFIG, u.type1.IOLimit),
                    1
                    );

                HalpWritePCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    &CB.PciData->u.type1.IOLimit,
                    FIELD_OFFSET (PCI_COMMON_CONFIG, u.type1.IOLimit),
                    1
                    );

                ChildBusData->Subtractive = TestLimit1 != TestLimit2;
#if 0
                DbgPrint ("Result=%d, Subtractive=%d\n",
                    TestLimit2,
                    ChildBusData->Subtractive
                    );

                DbgPrint ("Device buffer %x\n", CB.PciData);
#endif

                //
                // Now if its substractive,  assume no range means the entire
                // range.
                //

                if (ChildBusData->Subtractive) {

                    if (ChildBus->BusAddresses->IO.Base == PciBridgeIO2Base(0,0) &&
                        ChildBus->BusAddresses->IO.Limit <= PciBridgeIO2Limit(0,0)) {

                        ChildBus->BusAddresses->IO.Limit = 0x7FFFFFFFFFFFFFFF;

                        if (ChildBus->BusAddresses->Memory.Base == PciBridgeMemory2Base(0)) {
                            ChildBus->BusAddresses->Memory.Limit = 0x7FFFFFFFFFFFFFFF;
                        }
                    }
                }

                // should call HalpAssignPCISlotResources to assign
                // baseaddresses, etc...
            }
        }
        if (!((PPCIPBUSDATA)(CB.BusHandler->BusData))->BridgeConfigRead) {

            //
            // We believe this bus to be a root.
            //

            if ((FoundSomeFunction == FALSE) && (BusNo != 0)) {

                //
                // Nothing found on this bus. Assume it's not really
                // a root.   (Always assume 0 is a root).  (This bus
                // probably doesn't exist at all but ntdetect doesn't
                // tell us that).
                //
                // Pretend this bus is a child of the last known root.
                // At least this way it won't get a PDO and be handed
                // to the PCI driver.
                //

                HalpPciMakeBusAChild(CB.BusHandler, LastKnownRoot);

            } else {

                //
                // Found something on it (or it's zero), set as last
                // known root.
                //

                LastKnownRoot = CB.BusHandler;
            }
        }
    }

    if (Rescan) {
        *MaxPciBus = Rescan+1;
        return TRUE;
    }

    if (!FoundDisabledBridge) {
        return FALSE;
    }

    DBGMSG ("HAL GetPciData: found disabled pci bridge\n");

#ifdef INIT_PCI_BRIDGE
    //
    //  We've calculated all the parent's buses known bases & limits.
    //  While doing this a pci-pci bus was found that the bios didn't
    //  configure.  This is not expected, and we'll make some guesses
    //  at a configuration here and enable it.
    //
    //  (this code is primarily for testing the above code since
    //   currently no system bioses actually configure the child buses)
    //

    for (BusNo=0; BusNo < *MaxPciBus; BusNo++) {

        CB.BusHandler = HalpHandlerForBus (PCIBus, BusNo);
        CB.BusData = (PPCIPBUSDATA) CB.BusHandler->BusData;

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            CB.SlotNumber.u.bits.DeviceNumber = d;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                CB.SlotNumber.u.bits.FunctionNumber = f;

                HalpReadPCIConfig (
                    CB.BusHandler,
                    CB.SlotNumber,
                    CB.PciData,
                    0,
                    PCI_COMMON_HDR_LENGTH
                    );

                if (CB.PciData->VendorID == PCI_INVALID_VENDORID) {
                    continue;
                }

                if (!IsPciBridge (CB.PciData)) {
                    // not a PCI-PCI bridge
                    continue;
                }

                if ((CB.PciData->Command & 
                      (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE))) {
                    // this PCI bridge is enabled
                    continue;
                }

                //
                // We have a disabled bus - assign it a number, then
                // determine all the requirements of all devices
                // on the other side of this bridge
                //

                CB.BusNo = BusNo;
                HalpGetPciBridgeNeeds (HwType, MaxPciBus, &CB);
            }
        }
    }
    // preform Rescan
    return TRUE;

#else

    return FALSE;

#endif

}

VOID
HalpFixupPciSupportedRanges (
    IN ULONG MaxBuses
    )
/*++

Routine Description:

    PCI-PCI bridged buses only see addresses which their parent
    bueses support.   So adjust any PCI SUPPORT_RANGES to be
    a complete subset of all of it's parent buses.

    For PCI-PCI briges which use postive address decode to forward
    addresses, remove any addresses from any PCI bus which are bridged
    to a child PCI bus.

--*/
{
    ULONG               i;
    PBUS_HANDLER        Bus, ParentBus;
    PPCIPBUSDATA        BusData;
    PSUPPORTED_RANGES   HRanges;

    //
    // Pass 1 - shrink all PCI supported ranges to be a subset of
    // all of it's parent buses
    //

    for (i = 0; i < MaxBuses; i++) {

        Bus = HalpHandlerForBus (PCIBus, i);

        ParentBus = Bus->ParentHandler;
        while (ParentBus) {

            HRanges = Bus->BusAddresses;
            Bus->BusAddresses = HalpMergeRanges (
                                  ParentBus->BusAddresses,
                                  HRanges
                                  );

            HalpFreeRangeList (HRanges);
            ParentBus = ParentBus->ParentHandler;
        }
    }

    //
    // Pass 2 - remove all positive child PCI bus ranges from parent PCI buses
    //

    for (i = 0; i < MaxBuses; i++) {
        Bus = HalpHandlerForBus (PCIBus, i);
        BusData = (PPCIPBUSDATA) Bus->BusData;

        //
        // If the bridge is not subtractive, remove the ranges from the parents
        //

        if (!BusData->Subtractive) {

            ParentBus = Bus->ParentHandler;
            while (ParentBus) {

                if (ParentBus->InterfaceType == PCIBus) {
                    HalpRemoveRanges (
                          ParentBus->BusAddresses,
                          Bus->BusAddresses
                    );
                }

                ParentBus = ParentBus->ParentHandler;
            }
        }
    }

    //
    // Cleanup
    //

    for (i = 0; i < MaxBuses; i++) {
        Bus = HalpHandlerForBus (PCIBus, i);
        HalpConsolidateRanges (Bus->BusAddresses);
    }
}



VOID
HalpSetPciBridgedVgaCronk (
    IN ULONG BusNumber,
    IN ULONG BaseAddress,
    IN ULONG LimitAddress
    )
/*++

Routine Description:                                                           .

    The 'vga compatible addresses' bit is set in the bridge control regiter.
    This causes the bridge to pass any I/O address in the range of: 10bit
    decode 3b0-3bb & 3c0-3df, as TEN bit addresses.

    As far as I can tell this "feature" is an attempt to solve some problem
    which the folks solving it did not fully understand, so instead of doing
    it right we have this fine mess.

    The solution is to take the least of all evils which is to remove any
    I/O port ranges which are getting remapped from any IoAssignResource
    request.  (ie, IoAssignResources will never contimplate giving any
    I/O port out in the suspected ranges).

    note: memory allocation error here is fatal so don't bother with the
    return codes.

Arguments:

    Base    - Base of IO address range in question
    Limit   - Limit of IO address range in question

--*/
{
    UNICODE_STRING                      unicodeString;
    OBJECT_ATTRIBUTES                   objectAttributes;
    HANDLE                              handle;
    ULONG                               Length;
    PCM_RESOURCE_LIST                   ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR     Descriptor;
    ULONG                               AddressMSBs;
    WCHAR                               ValueName[80];
    NTSTATUS                            status;

    //
    // Open reserved resource settings
    //

    RtlInitUnicodeString (&unicodeString, rgzReservedResources);
    InitializeObjectAttributes( &objectAttributes,
                                &unicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                (PSECURITY_DESCRIPTOR) NULL
                                );

    status = ZwOpenKey( &handle, KEY_READ|KEY_WRITE, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Build resource list of reseved ranges
    //

    Length = ((LimitAddress - BaseAddress) / 1024 + 2) * 2 *
                sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                sizeof (CM_RESOURCE_LIST);

    ResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(PagedPool,
                                                            Length,
                                                            HAL_POOL_TAG);
    if (!ResourceList) {

        //
        // Can't possibly be out of paged pool at this stage of the
        // game.  This system is very unwell, get out.
        //

        return;
    }
    RtlZeroMemory(ResourceList, Length);

    ResourceList->Count = 1;
    ResourceList->List[0].InterfaceType = PCIBus;
    ResourceList->List[0].BusNumber     = BusNumber;
    Descriptor = ResourceList->List[0].PartialResourceList.PartialDescriptors;

    while (BaseAddress < LimitAddress) {
        AddressMSBs = BaseAddress & ~0x3ff;     // get upper 10bits of addr

        //
        // Add xx3b0 through xx3bb
        //

        Descriptor->Type                  = CmResourceTypePort;
        Descriptor->ShareDisposition      = CmResourceShareDeviceExclusive;
        Descriptor->Flags                 = CM_RESOURCE_PORT_IO;
        Descriptor->u.Port.Start.QuadPart = AddressMSBs | 0x3b0;
        Descriptor->u.Port.Length         = 0xb;

        Descriptor += 1;
        ResourceList->List[0].PartialResourceList.Count += 1;

        //
        // Add xx3c0 through xx3df
        //

        Descriptor->Type                  = CmResourceTypePort;
        Descriptor->ShareDisposition      = CmResourceShareDeviceExclusive;
        Descriptor->Flags                 = CM_RESOURCE_PORT_IO;
        Descriptor->u.Port.Start.QuadPart = AddressMSBs | 0x3c0;
        Descriptor->u.Port.Length         = 0x1f;

        Descriptor += 1;
        ResourceList->List[0].PartialResourceList.Count += 1;

        //
        // Next range
        //

        BaseAddress += 1024;
    }

    //
    // Add the reserved ranges to avoid during IoAssignResource
    //

    swprintf(ValueName, L"HAL_PCI_%d", BusNumber);
    RtlInitUnicodeString(&unicodeString, ValueName);

    ZwSetValueKey(handle,
                  &unicodeString,
                  0L,
                  REG_RESOURCE_LIST,
                  ResourceList,
                  (ULONG) Descriptor - (ULONG) ResourceList
                  );


    ExFreePool(ResourceList);
    ZwClose(handle);
}



#ifdef INIT_PCI_BRIDGE

VOID
HalpGetPciBridgeNeeds (
    IN ULONG            HwType,
    IN PUCHAR           MaxPciBus,
    IN PCONFIGBRIDGE    Current
    )
{
    ACCESS_MASK                     DesiredAccess;
    UNICODE_STRING                  unicodeString;
    PUCHAR                          buffer;
    HANDLE                          handle;
    OBJECT_ATTRIBUTES               objectAttributes;
    PCM_FULL_RESOURCE_DESCRIPTOR    Descriptor;
    PCONFIGURATION_COMPONENT        Component;
    CONFIGBRIDGE                    CB;
    ULONG                           mnum, d, f, i;
    NTSTATUS                        status;

    buffer = ExAllocatePoolWithTag(PagedPool, 1024, HAL_POOL_TAG);

    if (!buffer) {

        //
        // Give up, we're not going anywhere anyway.
        //

        return;
    }

    //
    // Init CB structure
    //

    CB.PciData = (PPCI_COMMON_CONFIG) CB.Buffer;
    CB.SlotNumber.u.bits.Reserved = 0;
    Current->IO = Current->Memory = Current->PFMemory = 0;

    //
    // Assign this bridge an ID, and turn on configuration space
    //

    Current->PciData->u.type1.PrimaryBus = (UCHAR) Current->BusNo;
    Current->PciData->u.type1.SecondaryBus = (UCHAR) *MaxPciBus;
    Current->PciData->u.type1.SubordinateBus = (UCHAR) 0xFF;
    Current->PciData->u.type1.SecondaryStatus = 0xffff;
    Current->PciData->Status  = 0xffff;
    Current->PciData->Command = 0;

    Current->PciData->u.type1.BridgeControl = PCI_ASSERT_BRIDGE_RESET;

    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );

    KeStallExecutionProcessor (100);

    Current->PciData->u.type1.BridgeControl = 0;
    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );


    KeStallExecutionProcessor (100);

    //
    // Allocate new handler for bus
    //

    CB.BusHandler = HalpAllocateAndInitPciBusHandler (HwType, *MaxPciBus, FALSE);
    CB.BusData = (PPCIPBUSDATA) CB.BusHandler->BusData;
    CB.BusNo = *MaxPciBus;
    *MaxPciBus += 1;

    //
    // Add another PCI bus in the registry
    //

    mnum = 0;
    for (; ;) {
        //
        // Find next available MultiFunctionAdapter key
        //

        DesiredAccess = KEY_READ | KEY_WRITE;
        swprintf ((PWCHAR) buffer, L"%s\\%d", rgzMultiFunctionAdapter, mnum);
        RtlInitUnicodeString (&unicodeString, (PWCHAR) buffer);

        InitializeObjectAttributes( &objectAttributes,
                                    &unicodeString,
                                    OBJ_CASE_INSENSITIVE,
                                    NULL,
                                    (PSECURITY_DESCRIPTOR) NULL
                                    );

        status = ZwOpenKey( &handle, DesiredAccess, &objectAttributes);
        if (!NT_SUCCESS(status)) {
            break;
        }

        // already exists, next
        ZwClose (handle);
        mnum += 1;
    }

    ZwCreateKey (&handle,
                   DesiredAccess,
                   &objectAttributes,
                   0,
                   NULL,
                   REG_OPTION_VOLATILE,
                   &d
                );

    //
    // Add needed registry values for this MultifucntionAdapter entry
    //

    RtlInitUnicodeString (&unicodeString, rgzIdentifier);
    ZwSetValueKey (handle,
                   &unicodeString,
                   0L,
                   REG_SZ,
                   L"PCI",
                   sizeof (L"PCI")
                   );

    RtlInitUnicodeString (&unicodeString, rgzConfigurationData);
    Descriptor = (PCM_FULL_RESOURCE_DESCRIPTOR) buffer;
    Descriptor->InterfaceType = PCIBus;
    Descriptor->BusNumber = CB.BusNo;
    Descriptor->PartialResourceList.Version = 0;
    Descriptor->PartialResourceList.Revision = 0;
    Descriptor->PartialResourceList.Count = 0;
    ZwSetValueKey (handle,
                   &unicodeString,
                   0L,
                   REG_FULL_RESOURCE_DESCRIPTOR,
                   Descriptor,
                   sizeof (*Descriptor)
                   );


    RtlInitUnicodeString (&unicodeString, L"Component Information");
    Component = (PCONFIGURATION_COMPONENT) buffer;
    RtlZeroMemory (Component, sizeof (*Component));
    Component->AffinityMask = 0xffffffff;
    ZwSetValueKey (handle,
                   &unicodeString,
                   0L,
                   REG_BINARY,
                   Component,
                   FIELD_OFFSET (CONFIGURATION_COMPONENT, ConfigurationDataLength)
                   );

    ZwClose (handle);


    //
    // Since the BIOS didn't configure this bridge we'll assume that
    // the PCI interrupts are bridged.  (for BIOS configured buses we
    // assume that the BIOS put the ISA bus IRQ in the InterruptLine value)
    //

    CB.BusData->Pin2Line = (PciPin2Line) HalpPCIBridgedPin2Line;
    CB.BusData->Line2Pin = (PciLine2Pin) HalpPCIBridgedLine2Pin;
    //CB.BusData->GetIrqTable = (PciIrqTable) HalpGetBridgedPCIIrqTable;

    if (Current->BusHandler->GetInterruptVector == HalpGetPCIIntOnISABus) {

        //
        // The parent bus'es interrupt pin to vector mappings is not
        // a static function, and is determined by the boot firmware.
        //

        //CB.BusHandler->GetInterruptVector = (PGETINTERRUPTVECTOR) HalpGetBridgedPCIISAInt;

        // read each device on parent bus
        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            CB.SlotNumber.u.bits.DeviceNumber = d;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                CB.SlotNumber.u.bits.FunctionNumber = f;

                HalpReadPCIConfig (
                    Current->BusHandler,
                    CB.SlotNumber,
                    CB.PciData,
                    0,
                    PCI_COMMON_HDR_LENGTH
                    );

                if (CB.PciData->VendorID == PCI_INVALID_VENDORID) {
                    continue;
                }

                if (CB.PciData->u.type0.InterruptPin  &&
                    (PCI_CONFIG_TYPE (CB.PciData) == PCI_DEVICE_TYPE  ||
                     PCI_CONFIG_TYPE (CB.PciData) == PCI_BRIDGE_TYPE)) {

                    // get bios supplied int mapping
                    i = CB.PciData->u.type0.InterruptPin + d % 4;
                    CB.BusData->SwizzleIn[i] = CB.PciData->u.type0.InterruptLine;
                }
            }
        }

    } else {
        _asm int 3;
    }

    //
    // Look at each device on the bus and determine it's resource needs
    //

    for (d = 0; d < PCI_MAX_DEVICES; d++) {
        CB.SlotNumber.u.bits.DeviceNumber = d;

        for (f = 0; f < PCI_MAX_FUNCTION; f++) {
            CB.SlotNumber.u.bits.FunctionNumber = f;

            HalpReadPCIConfig (
                CB.BusHandler,
                CB.SlotNumber,
                CB.PciData,
                0,
                PCI_COMMON_HDR_LENGTH
                );

            if (CB.PciData->VendorID == PCI_INVALID_VENDORID) {
                continue;
            }

            if (IsPciBridge (CB.PciData)) {
                // oh look - another bridge ...
                HalpGetPciBridgeNeeds (HwType, MaxPciBus, &CB);
                continue;
            }

            if (PCI_CONFIG_TYPE (CB.PciData) != PCI_DEVICE_TYPE) {
                continue;
            }

            // found a device - figure out the resources it needs
        }
    }

    //
    // Found all sub-buses set SubordinateBus accordingly
    //

    Current->PciData->u.type1.SubordinateBus = (UCHAR) *MaxPciBus - 1;

    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );


    //
    // Set the bridges IO, Memory, and Prefetch Memory windows
    //

    // For now just pick some numbers & set everyone the same
    //  IO      0x6000 - 0xFFFF
    //  MEM     0x40000000 - 0x4FFFFFFF
    //  PFMEM   0x50000000 - 0x5FFFFFFF

    Current->PciData->u.type1.IOBase       = 0x6000     >> 12 << 4;
    Current->PciData->u.type1.IOLimit      = 0xffff     >> 12 << 4;
    Current->PciData->u.type1.MemoryBase   = 0x40000000 >> 20 << 4;
    Current->PciData->u.type1.MemoryLimit  = 0x4fffffff >> 20 << 4;
    Current->PciData->u.type1.PrefetchBase  = 0x50000000 >> 20 << 4;
    Current->PciData->u.type1.PrefetchLimit = 0x5fffffff >> 20 << 4;

    Current->PciData->u.type1.PrefetchBaseUpper32    = 0;
    Current->PciData->u.type1.PrefetchLimitUpper32   = 0;
    Current->PciData->u.type1.IOBaseUpper16         = 0;
    Current->PciData->u.type1.IOLimitUpper16        = 0;
    Current->PciData->u.type1.BridgeControl         =
        PCI_ENABLE_BRIDGE_ISA;

    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );

    HalpReadPCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        Current->PciData,
        0,
        PCI_COMMON_HDR_LENGTH
        );

    // enable memory & io decodes

    Current->PciData->Command =
        PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE | PCI_ENABLE_BUS_MASTER;

    HalpWritePCIConfig (
        Current->BusHandler,
        Current->SlotNumber,
        &Current->PciData->Command,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
        sizeof (Current->PciData->Command)
        );

    ExFreePool (buffer);
}

VOID
HalpPCIBridgedPin2Line (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    test function particular to dec pci-pci bridge card

--*/
{
    PPCIPBUSDATA    BusData;
    ULONG           i;

    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Convert slot Pin into Bus INTA-D.
    //

    i = (PciData->u.type0.InterruptPin +
          SlotNumber.u.bits.DeviceNumber - 1) % 4;

    PciData->u.type0.InterruptLine = BusData->SwizzleIn[i] ^ IRQXOR;
    PciData->u.type0.InterruptLine = 0x0b ^ IRQXOR;
}


VOID
HalpPCIBridgedLine2Pin (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++

    This functions maps the device's InterruptLine to it's
    device specific InterruptPin value.

    test function particular to dec pci-pci bridge card

--*/
{
    PPCIPBUSDATA    BusData;
    ULONG           i;

    if (!PciNewData->u.type0.InterruptPin) {
        return ;
    }

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    i = (PciNewData->u.type0.InterruptPin +
          SlotNumber.u.bits.DeviceNumber - 1) % 4;

    PciNewData->u.type0.InterruptLine = BusData->SwizzleIn[i] ^ IRQXOR;
    PciNewData->u.type0.InterruptLine = 0x0b ^ IRQXOR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixmca.c ===
/*++

Module Name:

    ixmca.c

Abstract:

    HAL component of the Machine Check Architecture.
    All exported MCA functionality is present in this file.

Author:

    Srikanth Kambhatla (Intel)

Revision History:

    Anil Aggarwal (Intel)
        Changes incorporated as per design review with Microsoft

--*/

#include <bugcodes.h>
#include <halp.h>
#include <stdlib.h>
#include <stdio.h>
#include <nthal.h>

//
// Structure to keep track of MCA features available on installed hardware
//

typedef struct _MCA_INFO {
    FAST_MUTEX          Mutex;
    UCHAR               NumBanks;           // Number of Banks present
    ULONGLONG           Bank0Config;        // Bank0 configuration setup by BIOS.
                                            // This will be used as mask when
                                            // setting up bank 0
    MCA_DRIVER_INFO     DriverInfo;         // Info about registered driver
    KDPC                Dpc;                // DPC object for MCA

} MCA_INFO, *PMCA_INFO;


//
// Default MCA Bank configuration
//
#define MCA_DEFAULT_BANK_CONF       0xFFFFFFFFFFFFFFFF

//
// MCA architecture related defines
//

#define MCA_NUM_REGS        4

#define MCE_VALID           0x01
#define MCA_VECTOR          18

//
// MSR register addresses for MCA
//

#define MCG_CAP             0x179
#define MCG_STATUS          0x17a
#define MCG_CTL             0x17b
#define MCG_EAX             0x180
#define MCG_EBX             0x181
#define MCG_ECX             0x182
#define MCG_EDX             0x183
#define MCG_ESI             0x184
#define MCG_EDI             0x185
#define MCG_EBP             0x186
#define MCG_ESP             0x187
#define MCG_EFLAGS          0x188
#define MCG_EIP             0x189
#define MC0_CTL             0x400
#define MC0_STATUS          0x401
#define MC0_ADDR            0x402
#define MC0_MISC            0x403

#define PENTIUM_MC_ADDR     0x0
#define PENTIUM_MC_TYPE     0x1

//
// Bit Masks for MCG_CAP
//
#define MCA_CNT_MASK        0xFF
#define MCG_CTL_PRESENT     0x100
#define MCG_EXT_PRESENT     0x200
typedef struct _MCG_CAPABILITY {
    union {
        struct {
            ULONG       McaCnt:8;
            ULONG       McaCntlPresent:1;
            ULONG       McaExtPresent:1;
            ULONG       Reserved_1: 6;
            ULONG       McaExtCnt: 8;
            ULONG       Reserved_2: 8;
            ULONG       Reserved_3;
        } hw;
        ULONGLONG       QuadPart;
    } u;
} MCG_CAPABILITY, *PMCG_CAPABILITY;

//
// V2 defines up through Eip
//

#define MCG_EFLAGS_OFFSET      (MCG_EFLAGS-MCG_EAX+1)

//
// Writing all 1's to MCG_CTL register enables logging.
//

#define MCA_MCGCTL_ENABLE_LOGGING      0xffffffffffffffff

//
// Bit interpretation of MCG_STATUS register
//

#define MCG_MC_INPROGRESS       0x4
#define MCG_EIP_VALID           0x2
#define MCG_RESTART_EIP_VALID   0x1

//
// For the function that reads the error reporting bank log, the type of error we
// are interested in
//
#define MCA_GET_ANY_ERROR               0x1
#define MCA_GET_NONRESTARTABLE_ERROR    0x2


//
// Defines for the size of TSS and the initial stack to operate on
//
#define MINIMUM_TSS_SIZE 0x68

//
// Global Varibles
//

MCA_INFO            HalpMcaInfo;
BOOLEAN             HalpMcaInterfaceLocked;
extern KAFFINITY    HalpActiveProcessors;
#if !defined(_WIN64) || defined(PICACPI)
extern UCHAR        HalpClockMcaQueueDpc;
#endif

extern UCHAR        MsgMCEPending[];
extern WCHAR        rgzSessionManager[];
extern WCHAR        rgzEnableMCE[];
extern WCHAR        rgzEnableMCA[];


//
// External prototypes
//

VOID
HalpMcaCurrentProcessorSetTSS (
    IN PULONG   pTSS
    );

#if !defined(_AMD64_)

VOID
HalpSetCr4MCEBit (
    VOID
    );

#endif  // _AMD64_

//
// Internal prototypes
//

VOID
HalpMcaInit (
    VOID
    );

NTSTATUS
HalpMcaReadProcessorException (
    IN OUT PMCA_EXCEPTION  Exception,
    IN BOOLEAN  NonRestartableOnly
    );

VOID
HalpMcaQueueDpc(
    VOID
    );

VOID
HalpMcaGetConfiguration (
    OUT PULONG  MCEEnabled,
    OUT PULONG  MCAEnabled
    );

VOID
HalpMcaLockInterface(
    VOID
    );

VOID
HalpMcaUnlockInterface(
    VOID
    );

NTSTATUS
HalpMcaReadRegisterInterface(
    IN     UCHAR           BankNumber,
    IN OUT PMCA_EXCEPTION  Exception
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpMcaInit)
#pragma alloc_text(PAGELK, HalpMcaCurrentProcessorSetConfig)
#pragma alloc_text(INIT, HalpMcaGetConfiguration)
#pragma alloc_text(PAGE, HalpGetMcaLog)
#pragma alloc_text(PAGE, HalpMcaRegisterDriver)
#pragma alloc_text(PAGE, HalpMcaLockInterface)
#pragma alloc_text(PAGE, HalpMcaUnlockInterface)

#endif

//
// Register names for registers starting at MCG_EAX
//

char *RegNames[] = {
    "eax", "ebx", "ecx", "edx", "esi", "edi", "ebp", "esp", "eflags", "eip"
};

#define REGNAMECNT (sizeof(RegNames)/sizeof(RegNames[0]))


VOID
HalpMcaLockInterface(
    VOID
    )
{
    ExAcquireFastMutex(&HalpMcaInfo.Mutex);

#if DBG

    ASSERT(HalpMcaInterfaceLocked == FALSE);
    HalpMcaInterfaceLocked = TRUE;

#endif
        
}

VOID
HalpMcaUnlockInterface(
    VOID
    )
{
    ExReleaseFastMutex(&HalpMcaInfo.Mutex);

#if DBG

    ASSERT(HalpMcaInterfaceLocked == TRUE);
    HalpMcaInterfaceLocked = FALSE;

#endif
        
}

//
// All the initialization code for MCA goes here
//

VOID
HalpMcaInit (
    VOID
    )

/*++
    Routine Description:
        This routine is called to do all the initialization work

    Arguments:
        None

    Return Value:
        STATUS_SUCCESS if successful
        error status otherwise
--*/

{
    ULONGLONG   MsrCapability;
    KIRQL       OldIrql;
    KAFFINITY   ActiveProcessors, CurrentAffinity;
    ULONGLONG   MsrMceType;
    ULONG       MCEEnabled;
    ULONG       MCAEnabled;
    PULONG      pTSS;

    //
    // This lock synchronises access to the log area when we call the
    // logger on multiple processors.
    //
    // Note: This must be initialized regardless of whether or not
    // this processor supports MCA.
    //

    ExInitializeFastMutex (&HalpMcaInfo.Mutex);

    //
    // If this processor does not support MCA, nothing more to do.
    //

    if ( (!(HalpFeatureBits & HAL_MCE_PRESENT)) &&
         (!(HalpFeatureBits & HAL_MCA_PRESENT)) ) {

         return;  // nothing to do
    }

    HalpMcaGetConfiguration(&MCEEnabled, &MCAEnabled);

    if ( (HalpFeatureBits & HAL_MCE_PRESENT) &&
         (!(HalpFeatureBits & HAL_MCA_PRESENT)) ) {

        if (MCEEnabled == FALSE) {

            // User has not enabled MCE capability.
            HalpFeatureBits &= ~(HAL_MCE_PRESENT | HAL_MCA_PRESENT);

            return;
        }

#if DBG
        DbgPrint("MCE feature is enabled via registry\n");
#endif // DBG

        MsrMceType = RDMSR(PENTIUM_MC_TYPE);

        if (((PLARGE_INTEGER)(&MsrMceType))->LowPart & MCE_VALID) {

            //
            // On an AST PREMMIA MX machine we seem to have a Machine
            // Check Pending always.
            //

            HalDisplayString(MsgMCEPending);
            HalpFeatureBits &= ~(HAL_MCE_PRESENT | HAL_MCA_PRESENT);
            return;
        }
    }

    //
    // If MCA is available, find out the number of banks available and
    // also get the platform specific bank 0 configuration
    //

    if ( HalpFeatureBits & HAL_MCA_PRESENT ) {

        if (MCAEnabled == FALSE) {

            //
            // User has disabled MCA capability.
            //
#if DBG
            DbgPrint("MCA feature is disabled via registry\n");
#endif // DBG

            HalpFeatureBits &= ~(HAL_MCE_PRESENT | HAL_MCA_PRESENT);
            return;
        }

        MsrCapability = RDMSR(MCG_CAP);
        HalpMcaInfo.NumBanks = (UCHAR)(MsrCapability & MCA_CNT_MASK);

        //
        // Find out the Bank 0 configuration setup by BIOS. This will be used
        // as a mask when writing to Bank 0
        //

        HalpMcaInfo.Bank0Config = RDMSR(MC0_CTL);
    }

    ASSERT(HalpFeatureBits & HAL_MCE_PRESENT);


    //
    // Initialize on each processor
    //

#if !defined(_AMD64_)

    ActiveProcessors = HalpActiveProcessors;
    for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

        if (ActiveProcessors & CurrentAffinity) {

            ActiveProcessors &= ~CurrentAffinity;
            KeSetSystemAffinityThread (CurrentAffinity);

            //
            // Initialize MCA support on this processor
            //

            //
            // Allocate memory for this processor's TSS and it's own
            // private stack
            //
            pTSS   = (PULONG)ExAllocatePoolWithTag(NonPagedPool,
                                                   MINIMUM_TSS_SIZE,
                                                   HAL_POOL_TAG
                                                   );

            if (!pTSS) {

                //
                // This allocation is critical.
                //

                KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                             MINIMUM_TSS_SIZE,
                             2,
                             (ULONG_PTR)__FILE__,
                             __LINE__
                             );
            }

            RtlZeroMemory(pTSS, MINIMUM_TSS_SIZE);
           
            OldIrql = KfRaiseIrql(HIGH_LEVEL);

            HalpMcaCurrentProcessorSetTSS(pTSS);
            HalpMcaCurrentProcessorSetConfig();

            KeLowerIrql(OldIrql);
        }
    }

#endif  // _AMD64_

    //
    // Restore threads affinity
    //

    KeRevertToUserAffinityThread();
}


VOID
HalpMcaCurrentProcessorSetConfig (
    VOID
    )
/*++

    Routine Description:

        This routine sets/modifies the configuration of the machine check
        architecture on the current processor. Input is specification of
        the control register MCi_CTL for each bank of the MCA architecture.
        which controls the generation of machine check exceptions for errors
        logged to that bank.

        If MCA is not available on this processor, check if MCE is available.
        If so, enable MCE in CR4

    Arguments:

        Context: Array of values of MCi_CTL for each bank of MCA.
                    If NULL, use MCA_DEFAULT_BANK_CONF values for each bank

    Return Value:

        None

--*/
{
    ULONGLONG   MciCtl;
    ULONGLONG   McgCap;
    ULONGLONG   McgCtl;
    ULONG       BankNum;


    if (HalpFeatureBits & HAL_MCA_PRESENT) {
        //
        // MCA is available. Initialize MCG_CTL register if present
        // Writing all 1's enable MCE or MCA Error Exceptions
        //

        McgCap = RDMSR(MCG_CAP);

        if (McgCap & MCG_CTL_PRESENT) {
            McgCtl = MCA_MCGCTL_ENABLE_LOGGING;
            WRMSR(MCG_CTL, McgCtl);
        }

        //
        // Enable all MCA errors
        //
        for ( BankNum = 0; BankNum < HalpMcaInfo.NumBanks; BankNum++ ) {

            //
            // Use MCA_DEFAULT_BANK_CONF for each bank
            //

            MciCtl = MCA_DEFAULT_BANK_CONF;

            //
            // If this is bank 0, use HalpMcaInfo.Bank0Config as a mask
            //
            if (BankNum == 0) {
                MciCtl &= HalpMcaInfo.Bank0Config;
            }

            WRMSR(MC0_CTL + (BankNum * MCA_NUM_REGS), MciCtl);
        }
    }

    //
    // Enable MCE bit in CR4
    //

#if defined(_AMD64_)
    {
        ULONG64 cr4;

        cr4 = ReadCR4();
        cr4 |= CR4_MCE;
        WriteCR4(cr4);
    }
#else
    HalpSetCr4MCEBit();
#endif
}


NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO DriverInfo
    )
/*++
    Routine Description:
        This routine is called by the driver (via HalSetSystemInformation)
        to register its presence. Only one driver can be registered at a time.

    Arguments:
        DriverInfo: Contains info about the callback routine and the DriverObject

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.
--*/

{
    KIRQL       OldIrql;
    PVOID       UnlockHandle;
    NTSTATUS    Status;

    PAGED_CODE();


    Status = STATUS_UNSUCCESSFUL;

    if ((HalpFeatureBits & HAL_MCE_PRESENT)  &&  DriverInfo->DpcCallback) {

        HalpMcaLockInterface();

        //
        // Register driver
        //

        if (!HalpMcaInfo.DriverInfo.DpcCallback) {

            // Initialize the DPC object
            KeInitializeDpc(
                &HalpMcaInfo.Dpc,
                DriverInfo->DpcCallback,
                DriverInfo->DeviceContext
                );

            // register driver
            HalpMcaInfo.DriverInfo.ExceptionCallback = DriverInfo->ExceptionCallback;
            HalpMcaInfo.DriverInfo.DpcCallback = DriverInfo->DpcCallback;
            HalpMcaInfo.DriverInfo.DeviceContext = DriverInfo->DeviceContext;
            Status = STATUS_SUCCESS;
        }

        HalpMcaUnlockInterface();
    } else if (!DriverInfo->DpcCallback) {
        HalpMcaLockInterface();
        // Only deregistering myself is permitted
        if (HalpMcaInfo.DriverInfo.DeviceContext == DriverInfo->DeviceContext) {
            HalpMcaInfo.DriverInfo.ExceptionCallback = NULL;
            HalpMcaInfo.DriverInfo.DpcCallback = NULL;
            HalpMcaInfo.DriverInfo.DeviceContext = NULL;
            Status = STATUS_SUCCESS;
        }
        HalpMcaUnlockInterface();
    }

    return Status;
}

#define MAX_MCA_NONFATAL_RETRIES 5
#define MCA_NONFATAL_ERORRS_BEFORE_WBINVD 3

NTSTATUS
HalpGetMcaLog (
    IN OUT PMCA_EXCEPTION  Exception,
    IN     ULONG           BufferSize,
    OUT    PULONG          Length
    )

/*++
 
Routine Description:

    This is the entry point for driver to read the bank logs
    Called by HaliQuerySystemInformation()

Arguments:

    Exception:     Buffer into which the error is reported
    BufferSize: Size of the passed buffer
    Length:     of the result

Return Value:

    Success or failure

--*/

{
    KAFFINITY        ActiveProcessors, CurrentAffinity;
    NTSTATUS         Status;
    ULONG            p1, p2;
    ULONGLONG        p3;
    static ULONG     McaStatusCount = 0;
    static ULONG     SavedBank = 0;
    static ULONGLONG SavedMcaStatus = 0;
    static KAFFINITY SavedAffinity = 0;


    PAGED_CODE();

    if (! (HalpFeatureBits & HAL_MCA_PRESENT)) {
        return(STATUS_NO_SUCH_DEVICE);
    }

    switch (BufferSize) {

    case MCA_EXCEPTION_V1_SIZE:
        Exception->VersionNumber = 1;
        break;

    case MCA_EXCEPTION_V2_SIZE:
        ASSERT(Exception->VersionNumber == 2);
        break;

    default:
        return(STATUS_INVALID_PARAMETER);
    }


    ActiveProcessors = HalpActiveProcessors;
    Status = STATUS_NOT_FOUND;

    HalpMcaLockInterface();

    *Length = 0;
    for (CurrentAffinity = 1; ActiveProcessors; CurrentAffinity <<= 1) {

        if (ActiveProcessors & CurrentAffinity) {

            ActiveProcessors &= ~CurrentAffinity;
            KeSetSystemAffinityThread (CurrentAffinity);

            //
            // Check this processor for an exception
            //

            Status = HalpMcaReadProcessorException (Exception, FALSE);

            //
            // Avoiding going into an infinite loop  reporting a non-fatal 
            // single bit MCA error.  This can be the result of the same
            // error being generated repeatly by the hardware.
            //

            if (Status == STATUS_SUCCESS) {

                //
                // Check to see if the same processor is reporting the
                // same MCA status.
                //

                if ((CurrentAffinity == SavedAffinity) &&
                    (SavedBank == Exception->u.Mca.BankNumber) &&
                    (SavedMcaStatus == Exception->u.Mca.Status.QuadPart)) {

                    //
                    // Check to see if the same error is generated more than
                    // n times.  Currently n==5.  If so, bugcheck the system.
                    //

                    if (McaStatusCount >= MAX_MCA_NONFATAL_RETRIES) {

                        if (Exception->VersionNumber == 1) {

                            //
                            // Parameters for bugcheck
                            //

                            p1 = ((PLARGE_INTEGER)(&Exception->u.Mce.Type))->LowPart;
                            p2 = 0;
                            p3 = Exception->u.Mce.Address;

                        } else {

                            //
                            // Parameters for bugcheck
                            //

                            p1 = Exception->u.Mca.BankNumber;
                            p2 = Exception->u.Mca.Address.Address;
                            p3 = Exception->u.Mca.Status.QuadPart;
                        }
                         
                        //
                        // We need a new bugcheck code for this case.
                        //

                        KeBugCheckEx (
                            MACHINE_CHECK_EXCEPTION,
                            p1,
                            p2,
                            ((PLARGE_INTEGER)(&p3))->HighPart,
                            ((PLARGE_INTEGER)(&p3))->LowPart
                        );

                    } else {

                        //
                        // This error is seen more than 1 once.  If it has
                        // occurred more than
                        // MCA_NONFATAL_ERORRS_BEFORE_WBINVD times, write
                        // back and Invalid cache to see if the error can be
                        // cleared.
                        //

                        McaStatusCount++;
                        if (McaStatusCount >=
                            MCA_NONFATAL_ERORRS_BEFORE_WBINVD) {
#if defined(_AMD64_)
                            WritebackInvalidate();
#else
                            _asm {
                                wbinvd
                            }
#endif
                        } 
                    }

                } else {

                    //
                    // First time we have seen this error, save the Status,
                    // affinity and clear the count.
                    //

                    SavedMcaStatus = Exception->u.Mca.Status.QuadPart;
                    SavedBank = Exception->u.Mca.BankNumber;
                    McaStatusCount = 0;
                    SavedAffinity = CurrentAffinity;
                }

            } else {

                //
                // Either we did not get an error or it will be fatal.
                // If we did not get an error and we are doing the processor
                // that reported the last error, clear things so we do not
                // match previous errors.  Since each time we look for an
                // error we start over with the first processor we do not
                // have to worry about multiple processor having stuck
                // errors.  We will only be able to see the first one.
                //

                if (SavedAffinity == CurrentAffinity) {
                    SavedMcaStatus = 0;
                    SavedBank = 0;
                    McaStatusCount = 0;
                    SavedAffinity = 0;
                }
            }

            //
            // If found, return current information
            //

            if (Status != STATUS_NOT_FOUND) {
                ASSERT (Status != STATUS_SEVERITY_ERROR);
                *Length = BufferSize;
                break;
            }
        }
    }

    //
    // Restore threads affinity, release mutex, and return
    //

    KeRevertToUserAffinityThread();
    HalpMcaUnlockInterface();
    return Status;
}


// Set the following to check async capability

BOOLEAN  NoMCABugCheck = FALSE;

VOID
HalpMcaExceptionHandler (
    VOID
    )

/*++
    Routine Description:
        This is the MCA exception handler.

    Arguments:
        None

    Return Value:
        None
--*/

{
    NTSTATUS        Status;
    MCA_EXCEPTION   BankLog;
    ULONG           p1;
    ULONGLONG       McgStatus, p3;

    if (!(HalpFeatureBits & HAL_MCA_PRESENT) ) {

        //
        // If we have ONLY MCE (and not MCA), read the MC_ADDR and MC_TYPE
        // MSRs, print the values and bugcheck as the errors are not
        // restartable.
        //

        BankLog.VersionNumber = 1;
        BankLog.ExceptionType = HAL_MCE_RECORD;
        BankLog.u.Mce.Address = RDMSR(PENTIUM_MC_ADDR);
        BankLog.u.Mce.Type = RDMSR(PENTIUM_MC_TYPE);
        Status = STATUS_SEVERITY_ERROR;

        //
        // Parameters for bugcheck
        //

        p1 = ((PLARGE_INTEGER)(&BankLog.u.Mce.Type))->LowPart;
        p3 = BankLog.u.Mce.Address;

    } else {

        McgStatus = RDMSR(MCG_STATUS);
        ASSERT( (McgStatus & MCG_MC_INPROGRESS) != 0);

        BankLog.VersionNumber = 2;
        Status = HalpMcaReadProcessorException (&BankLog, TRUE);

        //
        // Clear MCIP bit in MCG_STATUS register
        //

        McgStatus = 0;
        WRMSR(MCG_STATUS, McgStatus);

        //
        // Parameters for bugcheck
        //

        p1 = BankLog.u.Mca.BankNumber;
        p3 = BankLog.u.Mca.Status.QuadPart;
    }

    if (Status == STATUS_SEVERITY_ERROR) {

        //
        // Call the exception callback of the driver so that
        // the error can be logged to NVRAM
        //

        if (HalpMcaInfo.DriverInfo.ExceptionCallback) {
            HalpMcaInfo.DriverInfo.ExceptionCallback (
                         HalpMcaInfo.DriverInfo.DeviceContext,
                         &BankLog
                         );
        }

        if (!NoMCABugCheck)    {

            //
            // Bugcheck
            //

            KeBugCheckEx(
                            MACHINE_CHECK_EXCEPTION,
                            p1,
                            (ULONG_PTR) &BankLog,
                            ((PLARGE_INTEGER)(&p3))->HighPart,
                            ((PLARGE_INTEGER)(&p3))->LowPart
                            );

            // NOT REACHED
        }
    }

    //
    // Must be restartable. Indicate to the timer tick routine that a
    // DPC needs queued for MCA driver.
    //

    if (HalpMcaInfo.DriverInfo.DpcCallback) {
        HalpClockMcaQueueDpc = 1;
    }
}

VOID
HalpMcaQueueDpc(
    VOID
    )

/*++

  Routine Description: 

    Gets called from the timer tick to check if DPC
    needs to be queued

--*/

{
    KeInsertQueueDpc(
        &HalpMcaInfo.Dpc,
        NULL,
        NULL
        );
}


NTSTATUS
HalpMcaReadRegisterInterface(
    IN     UCHAR           BankNumber,
    IN OUT PMCA_EXCEPTION  Exception
    )

/*++

Routine Description:

    This routine reads the given MCA register number from the
    current processor and returns the result in the Exception
    structure.

Arguments:

    BankNumber  Number of MCA Bank to be examined.
    Exception   Buffer into which the error is reported

Return Value:

    STATUS_SUCCESS      if an error was found and the data copied into
                        the excption buffer.
    STATUS_UNSUCCESSFUL if the register contains no error information.
    STATUS_NOT_FOUND    if the register number exceeds the maximum number
                        of registers.
    STATUS_INVALID_PARAMETER if the Exception record is of an unknown type.

--*/

{
    ULONGLONG   McgStatus;
    MCI_STATS   istatus;
    NTSTATUS    ReturnStatus;
    MCG_CAPABILITY cap;
    ULONG       Reg;

    //
    // Are they asking for a valid register?
    //

    if (BankNumber >= HalpMcaInfo.NumBanks) {
        return STATUS_NOT_FOUND;
    }

    //
    // The exception buffer should tell us if it's version 1 or
    // 2.   Anything else we don't know how to deal with.
    //

    if ((Exception->VersionNumber < 1) ||
        (Exception->VersionNumber > 2)) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Read the global status register
    //

    McgStatus = RDMSR(MCG_STATUS);

    //
    // Read the Status MSR of the requested bank
    //

    istatus.QuadPart = RDMSR(MC0_STATUS + BankNumber * MCA_NUM_REGS);


    if (istatus.MciStats.Valid == 0) {

        //
        // No error in this bank.
        //

        return STATUS_UNSUCCESSFUL;
    }

    //
    // When MCIP bit is set, the execution can be restarted when
    // (MCi_STATUS.DAM == 0) && (MCG_STATUS.RIPV == 1)
    //
    // Note: STATUS_SEVERITY_ERROR is not a valid status choice.
    //

    ReturnStatus = STATUS_SUCCESS;

    if ((McgStatus & MCG_MC_INPROGRESS) &&
        (!(McgStatus & MCG_RESTART_EIP_VALID) ||
         istatus.MciStats.Damage)) {

        ReturnStatus = STATUS_SEVERITY_ERROR;
    }

    //
    // Complete extended exception record, if requested.
    //

    if (Exception->VersionNumber == 2) {
        cap.u.QuadPart = RDMSR(MCG_CAP);
        if (cap.u.hw.McaExtCnt > 0) {
            // Get Version 2 stuff from MSRs.
            Exception->ExtCnt = cap.u.hw.McaExtCnt;
            if (Exception->ExtCnt > MCA_EXTREG_V2MAX) {
                Exception->ExtCnt = MCA_EXTREG_V2MAX;
            }
            for (Reg = 0; Reg < Exception->ExtCnt; Reg++) {
                Exception->ExtReg[Reg] = RDMSR(MCG_EAX+Reg);
            }
            if (cap.u.hw.McaExtCnt >= MCG_EFLAGS_OFFSET) {
                if (RDMSR(MCG_EFLAGS) == 0) {
                    // Let user know he got only Version 1 data.
                    Exception->VersionNumber = 1;
                }
            }
        } else {
            // Let user know he got only Version 1 data.
            Exception->VersionNumber = 1;
        }
    }

    //
    // Complete exception record
    //

    Exception->ExceptionType = HAL_MCA_RECORD;
    Exception->TimeStamp.QuadPart = 0;
    Exception->u.Mca.Address.QuadPart = 0;
    Exception->u.Mca.Misc = 0;
    Exception->u.Mca.BankNumber = BankNumber;
    Exception->u.Mca.Status = istatus;

    Exception->ProcessorNumber = KeGetCurrentProcessorNumber();

#if defined(_AMD64_)
    if (KeGetCurrentIrql() != CLOCK_LEVEL) {
#else
    if (KeGetCurrentIrql() != CLOCK2_LEVEL) {
#endif
        KeQuerySystemTime(&Exception->TimeStamp);
    }

    if (istatus.MciStats.AddressValid) {
        Exception->u.Mca.Address.QuadPart =
                RDMSR(MC0_ADDR + BankNumber * MCA_NUM_REGS);
    }

    //
    // Although MiscValid should never be set on P6 it
    // seems that sometimes it is.   It is not implemented
    // on P6 and above so don't read it there.
    //

    if (istatus.MciStats.MiscValid &&
        (KeGetCurrentPrcb()->CpuType != 6)) {
        Exception->u.Mca.Misc =
                RDMSR(MC0_MISC + BankNumber * MCA_NUM_REGS);
    }

    //
    // Clear Machine Check in MCi_STATUS register
    //

    WRMSR(MC0_STATUS + Exception->u.Mca.BankNumber * MCA_NUM_REGS, 0);

    //
    // Clear Register state in MCG_EFLAGS
    //

    if (Exception->VersionNumber != 1) {
        WRMSR(MCG_EFLAGS, 0);
    }

    //
    // When the Valid bit of status register is cleared, hardware may write
    // a new buffered error report into the error reporting area. The
    // serializing instruction is required to permit the update to complete
    //

    HalpSerialize();
    return(ReturnStatus);
}


NTSTATUS
HalpMcaReadProcessorException (
    IN OUT PMCA_EXCEPTION  Exception,
    IN BOOLEAN  NonRestartableOnly
    )

/*++

Routine Description:

    This routine logs the errors from the MCA banks on one processor.
    Necessary checks for the restartability are performed. The routine
    1> Checks for restartability, and for each bank identifies valid bank
        entries and logs error.
    2> If the error is not restartable provides additional information about
        bank and the MCA registers.
    3> Resets the Status registers for each bank

Arguments:
    Exception:  Into which we log the error if found
    NonRestartableOnly: Get any error vs. look for error that is not-restartable

Return Values:
   STATUS_SEVERITY_ERROR:   Detected non-restartable error.
   STATUS_SUCCESS:          Successfully logged bank values
   STATUS_NOT_FOUND:        No error found on any bank

--*/

{
    UCHAR       BankNumber;
    NTSTATUS    ReturnStatus = STATUS_NOT_FOUND;

    //
    // scan banks on current processor and log contents of first valid bank
    // reporting error. Once we find a valid error, no need to read remaining
    // banks. It is the application responsibility to read more errors.
    //

    for (BankNumber = 0; BankNumber < HalpMcaInfo.NumBanks; BankNumber++) {

        ReturnStatus = HalpMcaReadRegisterInterface(BankNumber, Exception);

        if ((ReturnStatus == STATUS_UNSUCCESSFUL) ||
            ((ReturnStatus == STATUS_SUCCESS) &&
             (NonRestartableOnly == TRUE))) {

            //
            // No error in this bank or only looking for non-restartable
            // errors, skip this one.
            //

            ReturnStatus = STATUS_NOT_FOUND;
            continue;
        }

        //
        // We either found an uncorrected error OR found a corrected error
        // and we were asked for either corrected or uncorrected error
        // Return this error.
        //

        ASSERT((ReturnStatus == STATUS_SUCCESS) ||
               (ReturnStatus == STATUS_SEVERITY_ERROR));
        break;
    }

    return(ReturnStatus);
}


VOID
HalpMcaGetConfiguration (
    OUT PULONG  MCEEnabled,
    OUT PULONG  MCAEnabled
)

/*++

Routine Description:

    This routine stores the Machine Check configuration information.

Arguments:

    MCEEnabled - Pointer to the MCEEnabled indicator.
                 0 = False, 1 = True (0 if value not present in Registry).

    MCAEnabled - Pointer to the MCAEnabled indicator.
                 0 = False, 1 = True (1 if value not present in Registry).

Return Value:

    None.

--*/

{

    RTL_QUERY_REGISTRY_TABLE    Parameters[3];
    ULONG                       DefaultDataMCE;
    ULONG                       DefaultDataMCA;


    RtlZeroMemory(Parameters, sizeof(Parameters));
    DefaultDataMCE = *MCEEnabled = FALSE;
    DefaultDataMCA = *MCAEnabled = TRUE;

    //
    // Gather all of the "user specified" information from
    // the registry.
    //

    Parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[0].Name = rgzEnableMCE;
    Parameters[0].EntryContext = MCEEnabled;
    Parameters[0].DefaultType = REG_DWORD;
    Parameters[0].DefaultData = &DefaultDataMCE;
    Parameters[0].DefaultLength = sizeof(ULONG);

    Parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    Parameters[1].Name = rgzEnableMCA;
    Parameters[1].EntryContext =  MCAEnabled;
    Parameters[1].DefaultType = REG_DWORD;
    Parameters[1].DefaultData = &DefaultDataMCA;
    Parameters[1].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(
        RTL_REGISTRY_CONTROL | RTL_REGISTRY_OPTIONAL,
        rgzSessionManager,
        Parameters,
        NULL,
        NULL
        );
}

VOID
HalHandleMcheck (
    IN PKTRAP_FRAME TrapFrame,
    IN PKEXCEPTION_FRAME ExceptionFrame
    )
{
    HalpMcaExceptionHandler();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixnmi.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixnmi.c

Abstract:

    Provides standard x86 NMI handler

Author:

    kenr

Revision History:

--*/
#include "halp.h"
#include "bugcodes.h"
#include "inbv.h"

#define SYSTEM_CONTROL_PORT_A        0x92
#define SYSTEM_CONTROL_PORT_B        0x61
#define EISA_EXTENDED_NMI_STATUS    0x461

const UCHAR EisaNMIMsg[] = MSG_NMI_EISA_IOCHKERR;

// The IRET performed in HalpBiosCall() called from HalpBiosDisplayReset()
// under HalpDisplayString() allows a second NMI to occur. 
// This ends up causing a trap 0d because the NMI TSS is busy.  Because
// the normal trap 0d handler attempts to bugcheck which trashes the screen,
// this flag (HalpNMIInProgress) tells HalpBiosDisplayReset() to leave its
// trap 0d handler in place which will then just spin on a jump to self if
// a second NMI occurs.

volatile ULONG  HalpNMIInProgress;

BOOLEAN HalpNMIDumpFlag;

VOID
HalHandleNMI(
    IN OUT PVOID NmiInfo
    )
/*++

Routine Description:

    Called DURING an NMI.  The system will BugCheck when an NMI occurs.
    This function can return the proper bugcheck code, bugcheck itself,
    or return success which will cause the system to iret from the nmi.

    This function is called during an NMI - no system services are available.
    In addition, you don't want to touch any spinlock which is normally
    used since we may have been interrupted while owning it, etc, etc...

Warnings:

    Do NOT:
      Make any system calls
      Attempt to acquire any spinlock used by any code outside the NMI handler
      Change the interrupt state.  Do not execute any IRET inside this code

    Passing data to non-NMI code must be done using manual interlocked
    functions.  (xchg instructions).

Arguments:

    NmiInfo - Pointer to NMI information structure  (TBD)
            - NULL means no NMI information structure was passed

Return Value:

    BugCheck code

--*/
{
    UCHAR   StatusByte;
    UCHAR   EisaPort;
    UCHAR   c;
    ULONG   port, i;


#ifndef NT_UP

#if defined(_AMD64_)
    static ULONG NMILock;
    while (InterlockedCompareExchange(&NMILock,1,0) != 0) {
    };
#else
static volatile ULONG  NMILock;

    _asm {
LockNMILock:
    lock    bts NMILock, 0
    jc      LockNMILock
    }
#endif

    if (HalpNMIInProgress == 0) {
#endif
        HalpNMIInProgress++;

        StatusByte = READ_PORT_UCHAR((PUCHAR) SYSTEM_CONTROL_PORT_B);

        //
        // Enable InbvDisplayString calls to make it through to bootvid driver.
        //
        
        if (InbvIsBootDriverInstalled()) {
        
            InbvAcquireDisplayOwnership();
        
            InbvResetDisplay();
            InbvSolidColorFill(0,0,639,479,4); // make the screen blue
            InbvSetTextColor(15);
            InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
            InbvEnableDisplayString(TRUE);     // enable display string
            InbvSetScrollRegion(0,0,639,479);  // set to use entire screen
        }
        
        HalDisplayString (MSG_HARDWARE_ERROR1);
        HalDisplayString (MSG_HARDWARE_ERROR2);
    
        if (StatusByte & 0x80) {
            HalDisplayString (MSG_NMI_PARITY);
        } 

        if (StatusByte & 0x40) {
            HalDisplayString (MSG_NMI_CHANNEL_CHECK);
        }
    
        if (HalpBusType == MACHINE_TYPE_EISA) {
            //
            // This is an Eisa machine, check for extnded nmi information...
            //
    
            StatusByte = READ_PORT_UCHAR((PUCHAR) EISA_EXTENDED_NMI_STATUS);
    
            if (StatusByte & 0x80) {
                HalDisplayString (MSG_NMI_FAIL_SAFE);
            }
    
            if (StatusByte & 0x40) {
                HalDisplayString (MSG_NMI_BUS_TIMEOUT);
            }
    
            if (StatusByte & 0x20) {
                HalDisplayString (MSG_NMI_SOFTWARE_NMI);
            }
    
            //
            // Look for any Eisa expansion board.  See if it asserted NMI.
            //
    
            for (EisaPort = 1; EisaPort <= 0xf; EisaPort++) {
                port = (EisaPort << 12) + 0xC80;
                WRITE_PORT_UCHAR ((PUCHAR) (ULONG_PTR)port, 0xff);
                StatusByte = READ_PORT_UCHAR ((PUCHAR) (ULONG_PTR)port);
    
                if ((StatusByte & 0x80) == 0) {
                    //
                    // Found valid Eisa board,  Check to see if it's
                    // if IOCHKERR is asserted.
                    //
    
                    StatusByte = READ_PORT_UCHAR ((PUCHAR) (ULONG_PTR)port+4);
                    if (StatusByte & 0x2  &&  StatusByte != 0xff) {
                        UCHAR Msg[sizeof(EisaNMIMsg)];

                        RtlCopyMemory(Msg, EisaNMIMsg, sizeof(Msg));
                        c = (EisaPort > 9 ? 'A'-10 : '0') + EisaPort;
                        for (i=0; Msg[i]; i++) {
                            if (Msg[i] == '%') {
                                Msg[i] = c;
                                break;
                            }
                        }
                        HalDisplayString (Msg);
                    }
                }
            }
        }

        HalDisplayString (MSG_HALT);

        if (HalpNMIDumpFlag) {
            KeBugCheckEx(NMI_HARDWARE_FAILURE,(ULONG)'ODT',0,0,0);
        }

#ifndef NT_UP
    }

    NMILock = 0;         
#endif

    if ((*((PBOOLEAN)(*(PLONG_PTR)&KdDebuggerNotPresent)) == FALSE) &&
        (**((PUCHAR *)&KdDebuggerEnabled) != FALSE)) {
        KeEnterKernelDebugger();
    }

    while(TRUE) {
        // Just sit here so that screen does not get corrupted.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixpcibus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcibus.c

Abstract:

    Get/Set bus data routines for the PCI bus

Author:

    Ken Reneris (kenr) 14-June-1994

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

extern const WCHAR rgzMultiFunctionAdapter[];
extern const WCHAR rgzConfigurationData[];
extern const WCHAR rgzIdentifier[];
extern const WCHAR rgzPCIIdentifier[];
extern const WCHAR rgzPCICardList[];

//
// Globals
//

KSPIN_LOCK          HalpPCIConfigLock;

PCI_CONFIG_HANDLER  PCIConfigHandler;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("INITCONST")
#endif // ALLOC_DATA_PRAGMA
const PCI_CONFIG_HANDLER  PCIConfigHandlerType1 = {
    HalpPCISynchronizeType1,
    HalpPCIReleaseSynchronzationType1,
    {
        HalpPCIReadUlongType1,          // 0
        HalpPCIReadUcharType1,          // 1
        HalpPCIReadUshortType1          // 2
    },
    {
        HalpPCIWriteUlongType1,         // 0
        HalpPCIWriteUcharType1,         // 1
        HalpPCIWriteUshortType1         // 2
    }
};

const PCI_CONFIG_HANDLER  PCIConfigHandlerType2 = {
    HalpPCISynchronizeType2,
    HalpPCIReleaseSynchronzationType2,
    {
        HalpPCIReadUlongType2,          // 0
        HalpPCIReadUcharType2,          // 1
        HalpPCIReadUshortType2          // 2
    },
    {
        HalpPCIWriteUlongType2,         // 0
        HalpPCIWriteUcharType2,         // 1
        HalpPCIWriteUshortType2         // 2
    }
};
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

const UCHAR PCIDeref[4][4] = { {0,1,2,2},{1,1,1,1},{2,1,2,2},{1,1,1,1} };

#define SIZEOF_PARTIAL_INFO_HEADER FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)

#if DBG

ULONG HalpPCIIllegalBusScannerDetected;
ULONG HalpPCIStopOnIllegalBusScannerDetected;

#endif

extern BOOLEAN HalpDoingCrashDump;

VOID
HalpPCIConfig (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    );

VOID
HalpGetNMICrashFlag (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpQueryPciRegistryInfo)
#pragma alloc_text(INIT,HalpIsRecognizedCard)
#pragma alloc_text(INIT,HalpIsValidPCIDevice)
#pragma alloc_text(INIT,HalpGetNMICrashFlag)
#pragma alloc_text(PAGE,HalpAssignPCISlotResources)
#pragma alloc_text(PAGE,HalIrqTranslateRequirementsPciBridge)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesPciBridge)
#pragma alloc_text(PAGELK,HalpPCISynchronizeOrionB0)
#pragma alloc_text(PAGELK,HalpPCIReleaseSynchronzationOrionB0)
#endif


PPCI_REGISTRY_INFO_INTERNAL
HalpQueryPciRegistryInfo (
    VOID
    )
/*++

Routine Description:

    Reads information from the registry concerning PCI, including the number
    of buses and the hardware access mechanism.

Arguments:

    None.

Returns:

    Buffer that must be freed by the caller, NULL if insufficient memory exists
    to complete the request, or the information cannot be located.

--*/
{
    PPCI_REGISTRY_INFO_INTERNAL     PCIRegInfo = NULL;
    PPCI_REGISTRY_INFO              PCIRegInfoHeader = NULL;
    UNICODE_STRING                  unicodeString, ConfigName, IdentName;
    HANDLE                          hMFunc, hBus, hCardList;
    OBJECT_ATTRIBUTES               objectAttributes;
    NTSTATUS                        status;
    UCHAR                           buffer [sizeof(PPCI_REGISTRY_INFO) + 99];
    PWSTR                           p;
    WCHAR                           wstr[8];
    ULONG                           i, junk;
    ULONG                           cardListIndex, cardCount, cardMax;
    PKEY_VALUE_FULL_INFORMATION     ValueInfo;
    PCM_FULL_RESOURCE_DESCRIPTOR    Desc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    UCHAR                           partialInfo[SIZEOF_PARTIAL_INFO_HEADER +
                                                sizeof(PCI_CARD_DESCRIPTOR)];
    PKEY_VALUE_PARTIAL_INFORMATION  partialInfoHeader;
    KEY_FULL_INFORMATION            keyFullInfo;

    //
    // Search the hardware description looking for any reported
    // PCI bus.  The first ARC entry for a PCI bus will contain
    // the PCI_REGISTRY_INFO.

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return NULL;
    }

    unicodeString.Buffer = wstr;
    unicodeString.MaximumLength = sizeof (wstr);

    RtlInitUnicodeString (&ConfigName, rgzConfigurationData);
    RtlInitUnicodeString (&IdentName,  rgzIdentifier);

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;

    for (i=0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {
            //
            // Out of Multifunction adapter entries...
            //

            ZwClose (hMFunc);
            return NULL;
        }

        //
        // Check the Identifier to see if this is a PCI entry
        //

        status = ZwQueryValueKey (
                    hBus,
                    &IdentName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) ValueInfo + ValueInfo->DataOffset);
        if (p[0] != L'P' || p[1] != L'C' || p[2] != L'I' || p[3] != 0) {
            ZwClose (hBus);
            continue;
        }

        //
        // The first PCI entry has the PCI_REGISTRY_INFO structure
        // attached to it.
        //

        status = ZwQueryValueKey (
                    hBus,
                    &ConfigName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        Desc  = (PCM_FULL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      ValueInfo + ValueInfo->DataOffset);
        PDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      Desc->PartialResourceList.PartialDescriptors);

        if (PDesc->Type == CmResourceTypeDeviceSpecific) {

            // got it..
            PCIRegInfoHeader = (PPCI_REGISTRY_INFO) (PDesc+1);
            ZwClose (hMFunc);
            break;
        }
    }

    if (!PCIRegInfoHeader) {

        return NULL;
    }

    //
    // Retrieve the list of interesting cards.
    //

    RtlInitUnicodeString (&unicodeString, rgzPCICardList);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );

    status = ZwOpenKey (&hCardList, KEY_READ, &objectAttributes);
    if (NT_SUCCESS(status)) {

        status = ZwQueryKey( hCardList,
                             KeyFullInformation,
                             &keyFullInfo,
                             sizeof(keyFullInfo),
                             &junk );

        if ( NT_SUCCESS(status) ) {

            cardMax = keyFullInfo.Values;

            PCIRegInfo = (PPCI_REGISTRY_INFO_INTERNAL) ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(PCI_REGISTRY_INFO_INTERNAL) +
                cardMax * sizeof(PCI_CARD_DESCRIPTOR),
                HAL_POOL_TAG
                );

            if (PCIRegInfo) {

                //
                // Now that we've allocated enough room, enumerate again.
                //
                partialInfoHeader = (PKEY_VALUE_PARTIAL_INFORMATION) partialInfo;

                for(cardListIndex = cardCount = 0;
                    cardListIndex < cardMax;
                    cardListIndex++) {

                    status = ZwEnumerateValueKey(
                        hCardList,
                        cardListIndex,
                        KeyValuePartialInformation,
                        partialInfo,
                        sizeof(partialInfo),
                        &junk
                        );

                    //
                    // Note that STATUS_NO_MORE_ENTRIES is a failure code
                    //
                    if (!NT_SUCCESS( status )) {
                        break;
                    }

                    if (partialInfoHeader->DataLength != sizeof(PCI_CARD_DESCRIPTOR)) {

                        continue;
                    }

                    RtlCopyMemory(
                        PCIRegInfo->CardList + cardCount,
                        partialInfoHeader->Data,
                        sizeof(PCI_CARD_DESCRIPTOR)
                        );

                    cardCount++;
                } // next cardListIndex
            }

        }
        ZwClose (hCardList);
    }

    if (!PCIRegInfo) {

        PCIRegInfo = (PPCI_REGISTRY_INFO_INTERNAL) ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(PCI_REGISTRY_INFO_INTERNAL),
            HAL_POOL_TAG
            );

        if (!PCIRegInfo) {

            return NULL;
        }

        cardCount = 0;
    }

    RtlCopyMemory(
        PCIRegInfo,
        PCIRegInfoHeader,
        sizeof(PCI_REGISTRY_INFO)
        );

    PCIRegInfo->ElementCount = cardCount;

    return PCIRegInfo;
}

BOOLEAN
HalpIsRecognizedCard(
    IN PPCI_REGISTRY_INFO_INTERNAL  PCIRegInfo,
    IN PPCI_COMMON_CONFIG           PciData,
    IN ULONG                        FeatureMask
    )
/*++

Routine Description:

    Walks the internal registry info list to find any cards matching the passed
    in "feature" mask.

Arguments:

    PCIRegInfo    - Pointer to reg info with the list of "notable" devices.
    PciData       - Config space (with subsystem info for cardbus bridges)
    FeatureMask   - PCIFT flags to try to match

Returns:

    Buffer that must be freed by the caller, NULL if insufficient memory exists
    to complete the request, or the information cannot be located.

--*/
{
    ULONG element;

    //
    // Detect if this has a h
    //
    for(element = 0; element < PCIRegInfo->ElementCount; element++) {

        if (FeatureMask & PCIRegInfo->CardList[element].Flags) {

            if (PCIRegInfo->CardList[element].VendorID != PciData->VendorID) {

                continue;
            }

            if (PCIRegInfo->CardList[element].DeviceID != PciData->DeviceID) {

                continue;
            }

            if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_REVISIONID) {

                if (PCIRegInfo->CardList[element].RevisionID != PciData->RevisionID) {

                    continue;
                }
            }

            switch(PCI_CONFIGURATION_TYPE(PciData)) {

                case PCI_DEVICE_TYPE:
                    if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_SSVID) {

                        if (PCIRegInfo->CardList[element].SubsystemVendorID != PciData->u.type0.SubVendorID) {

                            continue;
                        }
                    }

                    if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_SSID) {

                        if (PCIRegInfo->CardList[element].SubsystemID != PciData->u.type0.SubSystemID) {

                            continue;
                        }
                    }
                    break;

                case PCI_BRIDGE_TYPE:
                    break;

                case PCI_CARDBUS_BRIDGE_TYPE:
                    if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_SSVID) {

                        if (PCIRegInfo->CardList[element].SubsystemVendorID !=
                           ((TYPE2EXTRAS *)(PciData->DeviceSpecific))->SubVendorID) {

                            continue;
                        }
                    }

                    if (PCIRegInfo->CardList[element].Flags & PCICF_CHECK_SSID) {

                        if (PCIRegInfo->CardList[element].SubsystemID !=
                           ((TYPE2EXTRAS *)(PciData->DeviceSpecific))->SubSystemID) {

                            continue;
                        }
                    }
                    break;
            }

            //
            // We found the device matching one of the passed in feature bits.
            //
            return TRUE;
        }
    }

    return FALSE;
}

BOOLEAN
HalpIsValidPCIDevice (
    IN PBUS_HANDLER    BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
/*++

Routine Description:

    Reads the device configuration data for the given slot and
    returns TRUE if the configuration data appears to be valid for
    a PCI device; otherwise returns FALSE.

Arguments:

    BusHandler  - Bus to check
    Slot        - Slot to check

--*/

{
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    ULONG               i, j;


    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    //
    // Read device common header
    //

    HalpReadPCIConfig (BusHandler, Slot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Valid device header?
    //

    if (PciData->VendorID == PCI_INVALID_VENDORID  ||
        PCI_CONFIG_TYPE (PciData) != PCI_DEVICE_TYPE) {

        return FALSE;
    }

    //
    // Check fields for reasonable values
    //

    if ((PciData->u.type0.InterruptPin && PciData->u.type0.InterruptPin > 4) ||
        (PciData->u.type0.InterruptLine & 0x70)) {
        return FALSE;
    }

    for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
        j = PciData->u.type0.BaseAddresses[i];

        if (j & PCI_ADDRESS_IO_SPACE) {
            if (j > 0xffff) {
                // IO port > 64k?
                return FALSE;
            }
        } else {
            if (j > 0xf  &&  j < 0x80000) {
                // Mem address < 0x8000h?
                return FALSE;
            }
        }

        if (Is64BitBaseAddress(j)) {
            i += 1;
        }
    }

    //
    // Guess it's a valid device..
    //

    return TRUE;
}

ULONG
HalpGetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:

    BusNumber - Indicates which bus.

    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

    If this PCI slot has never been set, then the configuration information
    returned is zeroed.


--*/
{
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;
    ULONG               i, bit;

    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue
        // in the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested at least some data within the
        // common header.  Read the whole header, effect the
        // fields we need to and then copy the user's requested
        // bytes from the header
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;

        //
        // Read this PCI devices slot data
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            PciData->VendorID = PCI_INVALID_VENDORID;
            Len = 2;       // only return invalid id

#if DBG

            //
            // If this read would have accessed beyond the common header
            // then it is highly likely we have detected a device driver
            // doing a legacy scan of the bus but reading more than the
            // allowed configuration header.   This can have catastrophic
            // side effects.
            //

            if ((Length + Offset) > PCI_COMMON_HDR_LENGTH) {
                if (++HalpPCIIllegalBusScannerDetected == 1) {
                    DbgPrint("HAL Warning: PCI Configuration Access had detected an invalid bus scan.\n");
                }
                if (HalpPCIStopOnIllegalBusScannerDetected) {
                    DbgBreakPoint();
                }
            }

#endif

        } else {

            BusData->CommonData.Pin2Line (BusHandler, RootHandler, Slot, PciData);
        }

        //
        // Has this PCI device been configured?
        //

#if 0

        //
        // On DBG build, if this PCI device has not yet been configured,
        // then don't report any current configuration the device may have.
        //

        bit = PciBitIndex(Slot.u.bits.DeviceNumber, Slot.u.bits.FunctionNumber);

        if (!RtlCheckBit(&BusData->DeviceConfigured, bit) &&
            PCI_CONFIG_TYPE (PciData) == PCI_DEVICE_TYPE) {

            for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
                PciData->u.type0.BaseAddresses[i] = 0;
            }

            PciData->u.type0.ROMBaseAddress = 0;
            PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
        }
#endif


        //
        // Copy whatever data overlaps into the callers buffer
        //

        if (Len < Offset) {
            // no data at caller's buffer
            return 0;
        }

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory(Buffer, iBuffer + Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and read from it.
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpReadPCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

ULONG
HalpSetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Pci bus data for a device.

Arguments:


    VendorSpecificDevice - The VendorID (low Word) and DeviceID (High Word)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/
{
    PPCI_COMMON_CONFIG  PciData, PciData2;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    UCHAR               iBuffer2[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len, cnt;


    if (Length > sizeof (PCI_COMMON_CONFIG)) {
        Length = sizeof (PCI_COMMON_CONFIG);
    }


    Len = 0;
    PciData = (PPCI_COMMON_CONFIG) iBuffer;
    PciData2 = (PPCI_COMMON_CONFIG) iBuffer2;


    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue in
        // the device specific area.
        //

        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            return 0;
        }

    } else {

        //
        // Caller requested to set at least some data within the
        // common header.
        //

        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig (BusHandler, Slot, PciData, 0, Len);
        if (PciData->VendorID == PCI_INVALID_VENDORID  ||
            PCI_CONFIG_TYPE (PciData) != PCI_DEVICE_TYPE) {

            // no device, or header type unkown
            return 0;
        }


        //
        // Set this device as configured
        //

        BusData = (PPCIPBUSDATA) BusHandler->BusData;
#if DBG && !defined(ACPI_HAL)
        cnt = PciBitIndex(Slot.u.bits.DeviceNumber, Slot.u.bits.FunctionNumber);
        RtlSetBits (&BusData->DeviceConfigured, cnt, 1);
#endif
        //
        // Copy COMMON_HDR values to buffer2, then overlay callers changes.
        //

        RtlMoveMemory (iBuffer2, iBuffer, Len);
        BusData->CommonData.Pin2Line (BusHandler, RootHandler, Slot, PciData2);

        Len -= Offset;
        if (Len > Length) {
            Len = Length;
        }

        RtlMoveMemory (iBuffer2+Offset, Buffer, Len);

        // in case interrupt line or pin was editted
        BusData->CommonData.Line2Pin (BusHandler, RootHandler, Slot, PciData2, PciData);

#if DBG
        //
        // Verify R/O fields haven't changed
        //
        if (PciData2->VendorID   != PciData->VendorID       ||
            PciData2->DeviceID   != PciData->DeviceID       ||
            PciData2->RevisionID != PciData->RevisionID     ||
            PciData2->ProgIf     != PciData->ProgIf         ||
            PciData2->SubClass   != PciData->SubClass       ||
            PciData2->BaseClass  != PciData->BaseClass      ||
            PciData2->HeaderType != PciData->HeaderType     ||
            PciData2->BaseClass  != PciData->BaseClass      ||
            PciData2->u.type0.MinimumGrant   != PciData->u.type0.MinimumGrant   ||
            PciData2->u.type0.MaximumLatency != PciData->u.type0.MaximumLatency) {
                DbgPrint ("PCI SetBusData: Read-Only configuration value changed\n");
        }
#endif
        //
        // Set new PCI configuration
        //

        HalpWritePCIConfig (BusHandler, Slot, iBuffer2+Offset, Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and write it
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //

            HalpWritePCIConfig (BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return Len;
}

VOID
HalpReadPCIConfig (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID return no data
        //

        RtlFillMemory (Buffer, Length, (UCHAR) -1);
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                    PCIConfigHandler.ConfigRead);
}

VOID
HalpWritePCIConfig (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    if (!HalpValidPCISlot (BusHandler, Slot)) {
        //
        // Invalid SlotID do nothing
        //
        return ;
    }

    HalpPCIConfig (BusHandler, Slot, (PUCHAR) Buffer, Offset, Length,
                    PCIConfigHandler.ConfigWrite);
}

BOOLEAN
HalpValidPCISlot (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
{
    PCI_SLOT_NUMBER                 Slot2;
    PPCIPBUSDATA                    BusData;
    ULONG                           i;
    UCHAR Header[FIELD_OFFSET(PCI_COMMON_CONFIG, u)];
    PPCI_COMMON_CONFIG PciConfig = (PPCI_COMMON_CONFIG)&Header;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    if (Slot.u.bits.Reserved != 0) {
        return FALSE;
    }

    if (Slot.u.bits.DeviceNumber >= BusData->MaxDevice) {
        return FALSE;
    }

    if (Slot.u.bits.FunctionNumber == 0) {
        return TRUE;
    }

    //
    // Non zero function numbers are only supported if the
    // device has the PCI_MULTIFUNCTION bit set in it's header
    //

    i = Slot.u.bits.DeviceNumber;

    //
    // Read DeviceNumber, Function zero, to determine if the
    // PCI supports multifunction devices
    //

    Slot2 = Slot;
    Slot2.u.bits.FunctionNumber = 0;

    HalpReadPCIConfig (
        BusHandler,
        Slot2,
        &Header,
        0,
        sizeof(Header)
        );

    if (PciConfig->VendorID == PCI_INVALID_VENDORID) {

        //
        // This device doesn't exist, therefore, this function
        // doesn't exist.
        //

        return FALSE;
    }

    if (PciConfig->HeaderType & PCI_MULTIFUNCTION) {

        //
        // It's a multifunction device.  Slot is valid.
        //

        return TRUE;
    }

    //
    // Special cases, ie HACKs for broken hardware.
    //

    if ((PciConfig->VendorID == 0x8086) &&
        (PciConfig->DeviceID == 0x122e)) {

        //
        // This device lies, it really is multifunction.
        // It's also writable so write back the correct value
        // to avoid coming down this path in future.
        //

        PciConfig->HeaderType |= PCI_MULTIFUNCTION;
        HalpWritePCIConfig(
            BusHandler,
            Slot2,
            &PciConfig->HeaderType,
            FIELD_OFFSET(PCI_COMMON_CONFIG, HeaderType),
            sizeof(PciConfig->HeaderType)
            );

        return TRUE;
    }

    //
    // None of the above, must not be a multifunction device.
    //

    return FALSE;
}


VOID
HalpPCIConfig (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PUCHAR           Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN FncConfigIO      *ConfigIO
    )
{
    KIRQL               OldIrql;
    ULONG               i;
    UCHAR               State[20];
    PPCIPBUSDATA        BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    PCIConfigHandler.Synchronize (BusHandler, Slot, &OldIrql, State);

    while (Length) {
        i = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];
        i = ConfigIO[i] (BusData, State, Buffer, Offset);

        Offset += i;
        Buffer += i;
        Length -= i;
    }

    PCIConfigHandler.ReleaseSynchronzation (BusHandler, OldIrql);
}

VOID
HalpPCISynchronizeType1 (
    IN PBUS_HANDLER         BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    )
{
    //
    // Initialize PciCfg1
    //

    PciCfg1->u.AsULONG = 0;
    PciCfg1->u.bits.BusNumber = BusHandler->BusNumber;
    PciCfg1->u.bits.DeviceNumber = Slot.u.bits.DeviceNumber;
    PciCfg1->u.bits.FunctionNumber = Slot.u.bits.FunctionNumber;
    PciCfg1->u.bits.Enable = TRUE;

    //
    // Synchronize with PCI type1 config space
    //

    if (!HalpDoingCrashDump) {
        *Irql = KfRaiseIrql (HIGH_LEVEL);
        KiAcquireSpinLock (&HalpPCIConfigLock);
    } else {
        *Irql = HIGH_LEVEL;
    }
}

VOID
HalpPCIReleaseSynchronzationType1 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    )
{
    PCI_TYPE1_CFG_BITS  PciCfg1;
    PPCIPBUSDATA        BusData;

    //
    // Disable PCI configuration space
    //

    PciCfg1.u.AsULONG = 0;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1.u.AsULONG);

    //
    // Release spinlock
    //

    if (!HalpDoingCrashDump) {
        KiReleaseSpinLock (&HalpPCIConfigLock);
        KeLowerIrql (Irql);
    }
}


VOID
HalpPCISynchronizeOrionB0 (
    IN PBUS_HANDLER         BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    )
{
    PCI_TYPE1_CFG_BITS      Cfg1;
    union {
        ULONG   dword;
        USHORT  word;
        UCHAR   byte[4];
    } Buffer;

    //
    // First perform normal type 1 synchronization
    //

    HalpPCISynchronizeType1 (BusHandler, Slot, Irql, PciCfg1);

    //
    // Apply Orion B0 workaround
    //

    Cfg1.u.AsULONG=0;
    Cfg1.u.bits.BusNumber = HalpOrionOPB.Handler->BusNumber;
    Cfg1.u.bits.DeviceNumber = HalpOrionOPB.Slot.u.bits.DeviceNumber;
    Cfg1.u.bits.FunctionNumber = HalpOrionOPB.Slot.u.bits.FunctionNumber;
    Cfg1.u.bits.Enable = TRUE;

    //
    // Read OPB until we get back the expected Vendor ID and device ID
    //

    do  {
        HalpPCIReadUlongType1 (HalpOrionOPB.Handler->BusData, &Cfg1, Buffer.byte, 0);
    } while (Buffer.dword != 0x84c48086);

    //
    // The bug is that the config read will return whatever value you
    // happened to read last. Read register 0x54 till we don't read the
    // last value read any more(Vendor ID/Device ID).
    //

    do  {
        HalpPCIReadUshortType1 (HalpOrionOPB.Handler->BusData, &Cfg1, Buffer.byte, 0x54);
    } while (Buffer.word == 0x8086);

    //
    // Disable inbound posting by clearing bit 0 of register 0x54
    //

    Buffer.word &= ~0x1;
    HalpPCIWriteUshortType1 (HalpOrionOPB.Handler->BusData, &Cfg1, Buffer.byte, 0x54);
}

VOID
HalpPCIReleaseSynchronzationOrionB0 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    )
{

    PCI_TYPE1_CFG_BITS      PciCfg1;
    PPCIPBUSDATA            BusData;
    union {
        ULONG   dword;
        USHORT  word;
        UCHAR   byte[4];
    } Buffer;

    PciCfg1.u.AsULONG=0;
    PciCfg1.u.bits.BusNumber = HalpOrionOPB.Handler->BusNumber;
    PciCfg1.u.bits.DeviceNumber = HalpOrionOPB.Slot.u.bits.DeviceNumber;
    PciCfg1.u.bits.FunctionNumber = HalpOrionOPB.Slot.u.bits.FunctionNumber;
    PciCfg1.u.bits.Enable = TRUE;

    HalpPCIReadUshortType1 (HalpOrionOPB.Handler->BusData, &PciCfg1, Buffer.byte, 0x54);


    //
    // Enable Inbound posting by setting bit 0 of register 0x54 of ncOPB
    //

    Buffer.word |= 0x1;
    HalpPCIWriteUshortType1 (HalpOrionOPB.Handler->BusData, &PciCfg1, Buffer.byte, 0x54);

    //
    // Complete type 1 synchronization
    //

    HalpPCIReleaseSynchronzationType1 (BusHandler, Irql);
}



ULONG
HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *Buffer = READ_PORT_UCHAR ((PUCHAR) (ULONG_PTR)(BusData->Config.Type1.Data + i));
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT) (ULONG_PTR)(BusData->Config.Type1.Data + i));
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG) (ULONG_PTR)BusData->Config.Type1.Data);
    return sizeof (ULONG);
}


ULONG
HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_UCHAR ((PUCHAR) (ULONG_PTR)(BusData->Config.Type1.Data + i), *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    ULONG               i;

    i = Offset % sizeof(ULONG);
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_USHORT ((PUSHORT) (ULONG_PTR)(BusData->Config.Type1.Data + i), *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA         BusData,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1,
    IN PUCHAR               Buffer,
    IN ULONG                Offset
    )
{
    PciCfg1->u.bits.RegisterNumber = Offset / sizeof(ULONG);
    WRITE_PORT_ULONG (BusData->Config.Type1.Address, PciCfg1->u.AsULONG);
    WRITE_PORT_ULONG ((PULONG) (ULONG_PTR)BusData->Config.Type1.Data, *((PULONG) Buffer));
    return sizeof (ULONG);
}


VOID HalpPCISynchronizeType2 (
    IN PBUS_HANDLER             BusHandler,
    IN PCI_SLOT_NUMBER          Slot,
    IN PKIRQL                   Irql,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Initialize Cfg2Addr
    //

    PciCfg2Addr->u.AsUSHORT = 0;
    PciCfg2Addr->u.bits.Agent = (USHORT) Slot.u.bits.DeviceNumber;
    PciCfg2Addr->u.bits.AddressBase = (USHORT) BusData->Config.Type2.Base;

    //
    // Synchronize with type2 config space - type2 config space
    // remaps 4K of IO space, so we can not allow other I/Os to occur
    // while using type2 config space.
    //

    HalpPCIAcquireType2Lock (&HalpPCIConfigLock, Irql);

    PciCfg2Cse.u.AsUCHAR = 0;
    PciCfg2Cse.u.bits.Enable = TRUE;
    PciCfg2Cse.u.bits.FunctionNumber = (UCHAR) Slot.u.bits.FunctionNumber;
    PciCfg2Cse.u.bits.Key = 0xff;

    //
    // Select bus & enable type 2 configuration space
    //

    WRITE_PORT_UCHAR (BusData->Config.Type2.Forward, (UCHAR) BusHandler->BusNumber);
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);
}


VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUS_HANDLER         BusHandler,
    IN KIRQL                Irql
    )
{
    PCI_TYPE2_CSE_BITS      PciCfg2Cse;
    PPCIPBUSDATA            BusData;

    //
    // disable PCI configuration space
    //

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    PciCfg2Cse.u.AsUCHAR = 0;
    WRITE_PORT_UCHAR (BusData->Config.Type2.CSE, PciCfg2Cse.u.AsUCHAR);
    WRITE_PORT_UCHAR (BusData->Config.Type2.Forward, (UCHAR) 0);

    //
    // Restore interrupts, release spinlock
    //

    HalpPCIReleaseType2Lock (&HalpPCIConfigLock, Irql);
}


ULONG
HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *Buffer = READ_PORT_UCHAR ((PUCHAR) PciCfg2Addr->u.AsUSHORT);
    return sizeof (UCHAR);
}

ULONG
HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *((PUSHORT) Buffer) = READ_PORT_USHORT ((PUSHORT) PciCfg2Addr->u.AsUSHORT);
    return sizeof (USHORT);
}

ULONG
HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    *((PULONG) Buffer) = READ_PORT_ULONG ((PULONG) PciCfg2Addr->u.AsUSHORT);
    return sizeof(ULONG);
}


ULONG
HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_UCHAR ((PUCHAR) PciCfg2Addr->u.AsUSHORT, *Buffer);
    return sizeof (UCHAR);
}

ULONG
HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_USHORT ((PUSHORT) PciCfg2Addr->u.AsUSHORT, *((PUSHORT) Buffer));
    return sizeof (USHORT);
}

ULONG
HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA             BusData,
    IN PPCI_TYPE2_ADDRESS_BITS  PciCfg2Addr,
    IN PUCHAR                   Buffer,
    IN ULONG                    Offset
    )
{
    PciCfg2Addr->u.bits.RegisterNumber = (USHORT) Offset;
    WRITE_PORT_ULONG ((PULONG) PciCfg2Addr->u.AsUSHORT, *((PULONG) Buffer));
    return sizeof(ULONG);
}


NTSTATUS
HalpAssignPCISlotResources (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *pAllocatedResources
    )
/*++

Routine Description:

    Reads the targeted device to determine it's required resources.
    Calls IoAssignResources to allocate them.
    Sets the targeted device with it's assigned resoruces
    and returns the assignments to the caller.

Arguments:

Return Value:

    STATUS_SUCCESS or error

--*/
{
    NTSTATUS                        status;
    PUCHAR                          WorkingPool;
    PPCI_COMMON_CONFIG              PciData, PciOrigData, PciData2;
    PCI_SLOT_NUMBER                 PciSlot;
    PPCIPBUSDATA                    BusData;
    PIO_RESOURCE_REQUIREMENTS_LIST  CompleteList;
    PIO_RESOURCE_DESCRIPTOR         Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    ULONG                           BusNumber;
    ULONG                           i, j, m, length, memtype;
    ULONG                           NoBaseAddress, RomIndex, Option;
    PULONG                          BaseAddress[PCI_TYPE0_ADDRESSES + 1];
    PULONG                          OrigAddress[PCI_TYPE0_ADDRESSES + 1];
    BOOLEAN                         Match, EnableRomBase, RequestedInterrupt;
    KIRQL                           Kirql;
    KAFFINITY                       Kaffinity;

    *pAllocatedResources = NULL;
    PciSlot = *((PPCI_SLOT_NUMBER) &Slot);
    BusNumber = BusHandler->BusNumber;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Allocate some pool for working space
    //

    i = sizeof (IO_RESOURCE_REQUIREMENTS_LIST) +
        sizeof (IO_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2) * 2 +
        PCI_COMMON_HDR_LENGTH * 3;

    WorkingPool = (PUCHAR)ExAllocatePoolWithTag(PagedPool, i, HAL_POOL_TAG);
    if (!WorkingPool) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Zero initialize pool, and get pointers into memory
    //

    RtlZeroMemory (WorkingPool, i);
    CompleteList = (PIO_RESOURCE_REQUIREMENTS_LIST) WorkingPool;
    PciData     = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 3);
    PciData2    = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 2);
    PciOrigData = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 1);

    //
    // Read the PCI device's configuration
    //

    HalpReadPCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        ExFreePool (WorkingPool);
        return STATUS_NO_SUCH_DEVICE;
    }

    //
    // For now since there's not PnP support in the OS, if the BIOS hasn't
    // enable a VGA device don't allow it to get enabled via this interface.
    //

    if ( (PciData->BaseClass == 0 && PciData->SubClass == 1) ||
         (PciData->BaseClass == 3 && PciData->SubClass == 0)) {

        if ((PciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) == 0) {
            ExFreePool (WorkingPool);
            return STATUS_DEVICE_NOT_CONNECTED;
        }
    }

    //
    // Make a copy of the device's current settings
    //

    RtlMoveMemory (PciOrigData, PciData, PCI_COMMON_HDR_LENGTH);

    //
    // Initialize base addresses base on configuration data type
    //

    switch (PCI_CONFIG_TYPE(PciData)) {
        case 0 :
            NoBaseAddress = PCI_TYPE0_ADDRESSES+1;
            for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type0.BaseAddresses[j];
                OrigAddress[j] = &PciOrigData->u.type0.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type0.ROMBaseAddress;
            OrigAddress[j] = &PciOrigData->u.type0.ROMBaseAddress;
            RomIndex = j;
            break;
        case 1:
            NoBaseAddress = PCI_TYPE1_ADDRESSES+1;
            for (j=0; j < PCI_TYPE1_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type1.BaseAddresses[j];
                OrigAddress[j] = &PciOrigData->u.type1.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type1.ROMBaseAddress;
            OrigAddress[j] = &PciOrigData->u.type1.ROMBaseAddress;
            RomIndex = j;
            break;

        default:
            ExFreePool (WorkingPool);
            return STATUS_NO_SUCH_DEVICE;
    }

    //
    // If the BIOS doesn't have the device's ROM enabled, then we won't
    // enable it either.  Remove it from the list.
    //

    EnableRomBase = TRUE;
    if (!(*BaseAddress[RomIndex] & PCI_ROMADDRESS_ENABLED)) {
        ASSERT (RomIndex+1 == NoBaseAddress);
        EnableRomBase = FALSE;
        NoBaseAddress -= 1;
    }

    //
    // Set resources to all bits on to see what type of resources
    // are required.
    //

    for (j=0; j < NoBaseAddress; j++) {
        *BaseAddress[j] = 0xFFFFFFFF;
    }

    PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
    *BaseAddress[RomIndex] &= ~PCI_ROMADDRESS_ENABLED;
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    // note type0 & type1 overlay ROMBaseAddress, InterruptPin, and InterruptLine
    BusData->CommonData.Pin2Line (BusHandler, RootHandler, PciSlot, PciData);

    //
    // Build an IO_RESOURCE_REQUIREMENTS_LIST for the PCI device
    //

    CompleteList->InterfaceType = PCIBus;
    CompleteList->BusNumber = BusNumber;
    CompleteList->SlotNumber = Slot;
    CompleteList->AlternativeLists = 1;

    CompleteList->List[0].Version = 1;
    CompleteList->List[0].Revision = 1;

    Descriptor = CompleteList->List[0].Descriptors;

    //
    // If PCI device has an interrupt resource, add it
    //

    RequestedInterrupt = FALSE;
    if (PciData->u.type0.InterruptPin  &&
        PciData->u.type0.InterruptLine != (0 ^ IRQXOR)  &&
        PciData->u.type0.InterruptLine != (0xFF ^ IRQXOR) &&
        HalGetInterruptVector(PCIBus,
                              BusNumber,
                              PciData->u.type0.InterruptLine,
                              PciData->u.type0.InterruptLine,
                              &Kirql,
                              &Kaffinity)) {
        RequestedInterrupt = TRUE;
        CompleteList->List[0].Count++;

        Descriptor->Option = 0;
        Descriptor->Type   = CmResourceTypeInterrupt;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags  = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        if (ARGUMENT_PRESENT(DeviceObject)) {

            //
            // Let the arbiter pick any interrupt.
            //

            Descriptor->u.Interrupt.MinimumVector = 0;
            Descriptor->u.Interrupt.MaximumVector = 0xff;

        } else {

            //
            // Translation is going to fail, because we won't
            // be able to identify this device by its device
            // object.  So trim the requested interrupt resources
            // down to what's in the interrupt line register.
            // The translator will punt and read this.
            //

            Descriptor->u.Interrupt.MinimumVector = PciData->u.type0.InterruptLine;
            Descriptor->u.Interrupt.MaximumVector = PciData->u.type0.InterruptLine;
        }
        Descriptor++;
    }

    //
    // Add a memory/port resoruce for each PCI resource
    //

    // Clear ROM reserved bits

    *BaseAddress[RomIndex] &= ~0x7FF;

    for (j=0; j < NoBaseAddress; j++) {
        if (*BaseAddress[j]) {
            i = *BaseAddress[j];

            // scan for first set bit, that's the length & alignment
            length = 1 << (i & PCI_ADDRESS_IO_SPACE ? 2 : 4);
            while (!(i & length)  &&  length) {
                length <<= 1;
            }

            // scan for last set bit, that's the maxaddress + 1
            for (m = length; i & m; m <<= 1) ;
            m--;

            // check for hosed PCI configuration requirements
            if (length & ~m) {
#if DBG
                DbgPrint ("PCI: defective device! Bus %d, Slot %d, Function %d\n",
                    BusNumber,
                    PciSlot.u.bits.DeviceNumber,
                    PciSlot.u.bits.FunctionNumber
                    );

                DbgPrint ("PCI: BaseAddress[%d] = %08lx\n", j, i);
#endif
                // the device is in error - punt.  don't allow this
                // resource any option - it either gets set to whatever
                // bits it was able to return, or it doesn't get set.

                if (i & PCI_ADDRESS_IO_SPACE) {
                    m = i & ~0x3;
                    Descriptor->u.Port.MinimumAddress.LowPart = m;
                } else {
                    m = i & ~0xf;
                    Descriptor->u.Memory.MinimumAddress.LowPart = m;
                }

                m += length;    // max address is min address + length
            }

            //
            // Add requested resource
            //

            Descriptor->Option = 0;
            if (i & PCI_ADDRESS_IO_SPACE) {
                memtype = 0;

                if (PciOrigData->Command & PCI_ENABLE_IO_SPACE) {

                    //
                    // The IO range is/was already enabled at some location, add that
                    // as it's preferred setting.
                    //

                    Descriptor->Type = CmResourceTypePort;
                    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                    Descriptor->Flags = CM_RESOURCE_PORT_IO;
                    Descriptor->Option = IO_RESOURCE_PREFERRED;

                    Descriptor->u.Port.Length = length;
                    Descriptor->u.Port.Alignment = length;
                    Descriptor->u.Port.MinimumAddress.LowPart = *OrigAddress[j] & ~0x3;
                    Descriptor->u.Port.MaximumAddress.LowPart =
                        Descriptor->u.Port.MinimumAddress.LowPart + length - 1;

                    CompleteList->List[0].Count++;
                    Descriptor++;

                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                }

                //
                // Add this IO range
                //

                Descriptor->Type = CmResourceTypePort;
                Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                Descriptor->Flags = CM_RESOURCE_PORT_IO;

                Descriptor->u.Port.Length = length;
                Descriptor->u.Port.Alignment = length;
                Descriptor->u.Port.MaximumAddress.LowPart = m;

            } else {

                memtype = i & PCI_ADDRESS_MEMORY_TYPE_MASK;

                Descriptor->Flags  = CM_RESOURCE_MEMORY_READ_WRITE;
                if (j == RomIndex) {
                    // this is a ROM address
                    Descriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                }

                if (i & PCI_ADDRESS_MEMORY_PREFETCHABLE) {
                    Descriptor->Flags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
                }

                if ((j == RomIndex)  ||
                    ((PciOrigData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                     ((!Is64BitBaseAddress(i)) || (*OrigAddress[j+1] == 0)))) {

                    //
                    // The memory range is/was already enabled at some location,
                    // add that as it's preferred setting.
                    //

                    Descriptor->Type = CmResourceTypeMemory;
                    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                    Descriptor->Option = IO_RESOURCE_PREFERRED;

                    Descriptor->u.Port.Length = length;
                    Descriptor->u.Port.Alignment = length;
                    Descriptor->u.Port.MinimumAddress.LowPart = *OrigAddress[j] & ~0xF;
                    Descriptor->u.Port.MaximumAddress.LowPart =
                        Descriptor->u.Port.MinimumAddress.LowPart + length - 1;

                    CompleteList->List[0].Count++;
                    Descriptor++;

                    Descriptor->Flags = Descriptor[-1].Flags;
                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                }

                //
                // Add this memory range
                //

                Descriptor->Type = CmResourceTypeMemory;
                Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

                Descriptor->u.Memory.Length = length;
                Descriptor->u.Memory.Alignment = length;
                Descriptor->u.Memory.MaximumAddress.LowPart = m;

                if (memtype == PCI_TYPE_20BIT && m > 0xFFFFF) {
                    // limit to 20 bit address
                    Descriptor->u.Memory.MaximumAddress.LowPart = 0xFFFFF;
                }
            }

            CompleteList->List[0].Count++;
            Descriptor++;


            if (Is64BitBaseAddress(i)) {
                // skip upper half of 64 bit address since this processor
                // only supports 32 bits of address space
                j++;
            }
        }
    }

    CompleteList->ListSize = (ULONG)
            ((PUCHAR) Descriptor - (PUCHAR) CompleteList);

    //
    // Restore the device settings as we found them, enable memory
    // and io decode after setting base addresses.  This is done in
    // case HalAdjustResourceList wants to read the current settings
    // in the device.
    //

    HalpWritePCIConfig (
        BusHandler,
        PciSlot,
        &PciOrigData->Status,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Status),
        PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
        );

    HalpWritePCIConfig (
        BusHandler,
        PciSlot,
        PciOrigData,
        0,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
        );

    //
    // Have the IO system allocate resource assignments
    //

    status = IoAssignResources (
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                CompleteList,
                pAllocatedResources
            );

    if (!NT_SUCCESS(status)) {
        goto CleanUp;
    }

    //
    // Slurp the assigments back into the PciData structure and
    // perform them
    //

    CmDescriptor = (*pAllocatedResources)->List[0].PartialResourceList.PartialDescriptors;

    //
    // If PCI device has an interrupt resource then that was
    // passed in as the first requested resource
    //

    if (RequestedInterrupt) {
        PciData->u.type0.InterruptLine = (UCHAR) CmDescriptor->u.Interrupt.Vector;
        BusData->CommonData.Line2Pin (BusHandler, RootHandler, PciSlot, PciData, PciOrigData);
        CmDescriptor++;
    }

    //
    // Pull out resources in the order they were passed to IoAssignResources
    //

    for (j=0; j < NoBaseAddress; j++) {
        i = *BaseAddress[j];
        if (i) {
            if (i & PCI_ADDRESS_IO_SPACE) {
                *BaseAddress[j] = CmDescriptor->u.Port.Start.LowPart;
            } else {
                *BaseAddress[j] = CmDescriptor->u.Memory.Start.LowPart;
                if (Is64BitBaseAddress(i)) {

                    //
                    // 64 bit address occupies 2 BARs.  Reset the
                    // upper 32 bits to zero (currently FFFFFFFF
                    // from above).  Actually, set to upper 32 bits
                    // from assigned resource.
                    //

                    j++;
                    *BaseAddress[j] = CmDescriptor->u.Memory.Start.HighPart;
                }
            }
            CmDescriptor++;
        }
    }

    //
    // Turn off decodes, then set new addresses
    //

    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Read configuration back and verify address settings took
    //

    HalpReadPCIConfig(BusHandler, PciSlot, PciData2, 0, PCI_COMMON_HDR_LENGTH);

    Match = TRUE;
    if (PciData->u.type0.InterruptLine  != PciData2->u.type0.InterruptLine ||
        PciData->u.type0.InterruptPin   != PciData2->u.type0.InterruptPin  ||
        PciData->u.type0.ROMBaseAddress != PciData2->u.type0.ROMBaseAddress) {
            Match = FALSE;
    }

    for (j=0; j < NoBaseAddress; j++) {
        if (*BaseAddress[j]) {
            if (*BaseAddress[j] & PCI_ADDRESS_IO_SPACE) {
                i = PCI_ADDRESS_IO_ADDRESS_MASK;
            } else {
                i = PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            }

            if ((*BaseAddress[j] & i) !=
                (*((PULONG) ((PUCHAR) BaseAddress[j] -
                             (PUCHAR) PciData +
                             (PUCHAR) PciData2)) & i)) {

                    Match = FALSE;
            }

            if (Is64BitBaseAddress(*BaseAddress[j])) {
                // skip upper 32 bits
                j++;
            }
        }
    }

    if (!Match) {
#if DBG
        DbgPrint ("PCI: defective device! Bus %d, Slot %d, Function %d\n",
            BusNumber,
            PciSlot.u.bits.DeviceNumber,
            PciSlot.u.bits.FunctionNumber
            );
#endif
        status = STATUS_DEVICE_PROTOCOL_ERROR;
        goto CleanUp;
    }

    //
    // Settings took - turn on the appropiate decodes
    //

    if (EnableRomBase  &&  *BaseAddress[RomIndex]) {
        // a rom address was allocated and should be enabled
        *BaseAddress[RomIndex] |= PCI_ROMADDRESS_ENABLED;
        HalpWritePCIConfig (
            BusHandler,
            PciSlot,
            BaseAddress[RomIndex],
            (ULONG) ((PUCHAR) BaseAddress[RomIndex] - (PUCHAR) PciData),
            sizeof (ULONG)
            );
    }

    //
    // Enable IO, Memory, and BUS_MASTER decodes
    // (use HalSetBusData since valid settings now set)
    //

    PciData->Command |= PCI_ENABLE_IO_SPACE |
                        PCI_ENABLE_MEMORY_SPACE |
                        PCI_ENABLE_BUS_MASTER;

    HalSetBusDataByOffset (
        PCIConfiguration,
        BusHandler->BusNumber,
        PciSlot.u.AsULONG,
        &PciData->Command,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
        sizeof (PciData->Command)
        );

CleanUp:
    if (!NT_SUCCESS(status)) {

        //
        // Failure, if there are any allocated resources free them
        //

        if (*pAllocatedResources) {
            IoAssignResources (
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                NULL,
                NULL
                );

            ExFreePool (*pAllocatedResources);
            *pAllocatedResources = NULL;
        }

        //
        // Restore the device settings as we found them, enable memory
        // and io decode after setting base addresses
        //

        HalpWritePCIConfig (
            BusHandler,
            PciSlot,
            &PciOrigData->Status,
            FIELD_OFFSET (PCI_COMMON_CONFIG, Status),
            PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
            );

        HalpWritePCIConfig (
            BusHandler,
            PciSlot,
            PciOrigData,
            0,
            FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
            );
    }

    ExFreePool (WorkingPool);
    return status;
}

VOID
HalpGetNMICrashFlag (
    VOID
    )
{
    UNICODE_STRING    unicodeString, NMICrashDumpName;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE            hCrashControl;
    UCHAR             buffer [sizeof(PPCI_REGISTRY_INFO) + 99];
    ULONG             rsize;
    NTSTATUS          status;
    extern BOOLEAN    HalpNMIDumpFlag;

    //
    // Open Crash Control Registry Key
    //

    RtlInitUnicodeString (&unicodeString, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\CrashControl");

    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL);

    HalpNMIDumpFlag = FALSE;

    status = ZwOpenKey (&hCrashControl, KEY_READ, &objectAttributes);

    if (NT_SUCCESS(status)) {

        //
        // Look for NMICrashDump Value
        //

        RtlInitUnicodeString (&NMICrashDumpName, L"NMICrashDump");

        status = ZwQueryValueKey (
                    hCrashControl,
                    &NMICrashDumpName,
                    KeyValuePartialInformation,
                    (PKEY_VALUE_PARTIAL_INFORMATION) buffer,
                    sizeof (buffer),
                    &rsize
                    );

        if ((NT_SUCCESS (status)) && (rsize == FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data[0]) + sizeof(ULONG))) {
            HalpNMIDumpFlag = (BOOLEAN)(((PKEY_VALUE_PARTIAL_INFORMATION)buffer)->Data[0]);
        }

        ZwClose (hCrashControl);
    }
}

#ifndef ACPI_HAL
#define PciBridgeSwizzle(device, pin)       \
    ((((pin - 1) + device) % 4) + 1)

#define PCIPin2Int(Slot,Pin)                                                \
                     ((((Slot.u.bits.DeviceNumber << 2) | (Pin-1)) != 0) ?  \
                      (Slot.u.bits.DeviceNumber << 2) | (Pin-1) : 0x80);

#define PCIInt2Pin(interrupt)                                               \
            ((interrupt & 0x3) + 1)

#define PCIInt2Slot(interrupt)                                              \
            ((interrupt  & 0x7f ) >> 2)

NTSTATUS
HalIrqTranslateRequirementsPciBridge(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function translates IRQ resource requirements to
    the parent PCI bus.  This is only to be used for devices
    on a PCI bus created by a PCI to PCI bridge where there
    is no other mechanism for determining the interrupt
    routing exists.  (i.e. this bus is generated by a
    plug-in bridge.)

Arguments:

    Context  - must hold the slot number of the bridge


Return Value:

    STATUS_SUCCESS, so long as we can allocate the necessary
    memory

--*/
{
    PIO_RESOURCE_DESCRIPTOR target;
    PCI_SLOT_NUMBER         bridgeSlot;
    NTSTATUS                status;
    ULONG                   bridgePin;
    ULONG                   pciBusNumber;
    PCI_SLOT_NUMBER         pciSlot;
    UCHAR                   interruptLine;
    UCHAR                   interruptPin;
    UCHAR                   dummy;
    PDEVICE_OBJECT          parentPdo;
    ROUTING_TOKEN           routingToken;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);
    ASSERT(Source->u.Interrupt.MinimumVector == Source->u.Interrupt.MaximumVector);

    target = ExAllocatePoolWithTag(PagedPool,
                                   sizeof(IO_RESOURCE_DESCRIPTOR),
                                   HAL_POOL_TAG);

    if (!target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to fill in all the relevant fields.
    //

    *target = *Source;

    status = PciIrqRoutingInterface.GetInterruptRouting(
                PhysicalDeviceObject,
                &pciBusNumber,
                &pciSlot.u.AsULONG,
                &interruptLine,
                &interruptPin,
                &dummy,
                &dummy,
                &parentPdo,
                &routingToken,
                &dummy
                );

    ASSERT(NT_SUCCESS(status));

    //
    // Find the translated IRQ.
    //

    bridgeSlot.u.AsULONG = 0;
    bridgeSlot.u.bits.DeviceNumber = (ULONG)Context;

    bridgePin = PciBridgeSwizzle(PCIInt2Slot(Source->u.Interrupt.MinimumVector),
                                 PCIInt2Pin(Source->u.Interrupt.MinimumVector));

    //
    // The translated value is the the "PCI INT" of the pin
    // on the bridge.
    //

    target->u.Interrupt.MinimumVector =
        PCIPin2Int(bridgeSlot, bridgePin);

    target->u.Interrupt.MaximumVector = target->u.Interrupt.MinimumVector;

    *TargetCount = 1;
    *Target = target;

    return STATUS_SUCCESS;
}

NTSTATUS
HalIrqTranslateResourcesPciBridge(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function translates IRQ resources to and from
    the parent PCI bus.  This is only to be used for devices
    on a PCI bus created by a PCI to PCI bridge where there
    is no other mechanism for determining the interrupt
    routing exists.  (i.e. this bus is generated by a
    plug-in bridge.)

Arguments:

    Context  - must hold the slot number of the bridge


Return Value:

    STATUS_SUCCESS

--*/
{
    PCI_SLOT_NUMBER         bridgeSlot, deviceSlot, childSlot;
    ULONG                   bridgePin;
    ULONG                   pciBusNumber, targetPciBusNumber, bridgeBusNumber;
    UCHAR                   interruptPin;
    UCHAR                   dummy;
    PDEVICE_OBJECT          parentPdo;
    ROUTING_TOKEN           routingToken;
    NTSTATUS                status;
    UCHAR                   buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG      pciData;
    ULONG                   d, f;
    PBUS_HANDLER            busHandler;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);
    ASSERT(Source->u.Interrupt.Vector == Source->u.Interrupt.Level);
    ASSERT(PciIrqRoutingInterface.GetInterruptRouting);

    *Target = *Source;

    status = PciIrqRoutingInterface.GetInterruptRouting(
                PhysicalDeviceObject,
                &pciBusNumber,
                &deviceSlot.u.AsULONG,
                &dummy,
                &interruptPin,
                &dummy,
                &dummy,
                &parentPdo,
                &routingToken,
                &dummy
                );

    ASSERT(NT_SUCCESS(status));

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Find the translated IRQ.
        //

        bridgeSlot.u.AsULONG = 0;
        bridgeSlot.u.bits.DeviceNumber = (ULONG_PTR)Context & 0xffff;

        bridgePin = PciBridgeSwizzle(PCIInt2Slot(Source->u.Interrupt.Vector),
                                     PCIInt2Pin(Source->u.Interrupt.Vector));

        //
        // The translated value is the the "PCI INT" of the pin
        // on the bridge.
        //

        Target->u.Interrupt.Vector =
            PCIPin2Int(bridgeSlot, bridgePin);

        Target->u.Interrupt.Level = Target->u.Interrupt.Vector;

        //
        // The affinity should have been inherited from Source
        // and it should be non-zero.
        //

        ASSERT(Target->u.Interrupt.Affinity != 0);

        break;

    case TranslateParentToChild:

        //
        // The child-relative representation of Vector and Level
        // is from the MPS spec.  And we need to know the device
        // number and interrupt pin value.
        //

        //
        // TEMPTEMP Use bushandlers until HALMPS is rid of them.
        //

        pciData = (PPCI_COMMON_CONFIG)&buffer;

        bridgeBusNumber = ((ULONG_PTR)Context >> 16) & 0xffff;
        busHandler = HaliHandlerForBus(PCIBus, bridgeBusNumber);
        bridgeSlot.u.AsULONG =  (ULONG_PTR)Context & 0xffff;

        HalpReadPCIConfig(busHandler,
                          bridgeSlot,
                          pciData,
                          0,
                          PCI_COMMON_HDR_LENGTH);

        if (pciData->u.type1.SecondaryBus == pciBusNumber) {

            //
            // This device is sitting on the bus that we are translating
            // into.  So create a vector based on the address of this device.
            //   (Are we at the bottom of the translation?)
            //

            Target->u.Interrupt.Vector = PCIPin2Int(deviceSlot, interruptPin);
            Target->u.Interrupt.Level = Target->u.Interrupt.Vector;

            return STATUS_SUCCESS;

        } else {

            //
            // This device is not sitting on the bus that we are translating
            // into.  This device must be a (grand) child of another bridge that
            // sits on this bus.  And that bridge will have our device's bus
            // within its Subordinate bus register.
            //

            targetPciBusNumber = pciData->u.type1.SecondaryBus;
            bridgeSlot.u.AsULONG = 0;

            for (d = 0; d < PCI_MAX_DEVICES; d++) {
                for (f = 0; f < PCI_MAX_FUNCTION; f++) {

                    bridgeSlot.u.bits.DeviceNumber = d;
                    bridgeSlot.u.bits.FunctionNumber = f;

                    busHandler = HaliHandlerForBus(PCIBus, targetPciBusNumber);
                    HalpReadPCIConfig(busHandler,
                                      bridgeSlot,
                                      pciData,
                                      0,
                                      PCI_COMMON_HDR_LENGTH);

                    if ((PCI_CONFIGURATION_TYPE(pciData) == PCI_BRIDGE_TYPE) ||
                        (PCI_CONFIGURATION_TYPE(pciData) == PCI_CARDBUS_BRIDGE_TYPE)) {

                        //
                        // This is a bridge.  Check the subordinate bus.
                        //

                        if (pciData->u.type1.SubordinateBus >= pciBusNumber) {

                            //
                            // Now we know the device number of the bridge on this
                            // bus that applies to this translation.  We still need
                            // to know what pin will be triggered.  To know that,
                            // we have to look one more bus down.
                            //
                            // There are two cases:
                            //
                            // 1)  The next bus down contains the device.
                            //
                            // 2)  The next bus down contains another bridge.
                            //
                            //

                            if (pciData->u.type1.SecondaryBus == pciBusNumber) {

                                //
                                // This is case 1).
                                //

                                interruptPin = (UCHAR)PciBridgeSwizzle(deviceSlot.u.bits.DeviceNumber,
                                                                       interruptPin);

                            } else {

                                //
                                // This is case 2).
                                //
                                // Technically, to get the right answer, we would have to
                                // figure out which pin the bridge is going to trigger.  But
                                // to do that, we would have to scan down busses until we found
                                // the device.  And the information gathered on that little
                                // journey would never get used.
                                //

                                interruptPin = 1;
                            }


                            Target->u.Interrupt.Vector = PCIPin2Int(bridgeSlot, interruptPin);
                            Target->u.Interrupt.Level = Target->u.Interrupt.Vector;

                            return STATUS_SUCCESS;
                        }
                    }
                }
            }
        }

        return STATUS_NOT_FOUND;
    }

    return STATUS_SUCCESS;
}
#endif

#if DBG
VOID
HalpTestPci (ULONG flag2)
{
    PCI_SLOT_NUMBER     SlotNumber;
    PCI_COMMON_CONFIG   PciData, OrigData;
    ULONG               i, f, j, k, bus;
    BOOLEAN             flag;


    if (!flag2) {
        return ;
    }

    DbgBreakPoint ();
    SlotNumber.u.bits.Reserved = 0;

    //
    // Read every possible PCI Device/Function and display it's
    // default info.
    //
    // (note this destories it's current settings)
    //

    flag = TRUE;
    for (bus = 0; flag; bus++) {

        for (i = 0; i < PCI_MAX_DEVICES; i++) {
            SlotNumber.u.bits.DeviceNumber = i;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                SlotNumber.u.bits.FunctionNumber = f;

                //
                // Note: This is reading the DeviceSpecific area of
                // the device's configuration - normally this should
                // only be done on device for which the caller understands.
                // I'm doing it here only for debugging.
                //

                j = HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

                if (j == 0) {
                    // out of buses
                    flag = FALSE;
                    break;
                }

                if (j < PCI_COMMON_HDR_LENGTH) {
                    continue;
                }

                HalSetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    1
                    );

                HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

#if 0
                memcpy (&OrigData, &PciData, sizeof PciData);

                for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                    PciData.u.type0.BaseAddresses[j] = 0xFFFFFFFF;
                }

                PciData.u.type0.ROMBaseAddress = 0xFFFFFFFF;

                HalSetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

                HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );
#endif

                DbgPrint ("PCI Bus %d Slot %2d %2d  ID:%04lx-%04lx  Rev:%04lx",
                    bus, i, f, PciData.VendorID, PciData.DeviceID,
                    PciData.RevisionID);


                if (PciData.u.type0.InterruptPin) {
                    DbgPrint ("  IntPin:%x", PciData.u.type0.InterruptPin);
                }

                if (PciData.u.type0.InterruptLine) {
                    DbgPrint ("  IntLine:%x", PciData.u.type0.InterruptLine);
                }

                if (PciData.u.type0.ROMBaseAddress) {
                        DbgPrint ("  ROM:%08lx", PciData.u.type0.ROMBaseAddress);
                }

                DbgPrint ("\n    Cmd:%04x  Status:%04x  ProgIf:%04x  SubClass:%04x  BaseClass:%04lx\n",
                    PciData.Command, PciData.Status, PciData.ProgIf,
                     PciData.SubClass, PciData.BaseClass);

                k = 0;
                for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                    if (PciData.u.type0.BaseAddresses[j]) {
                        DbgPrint ("  Ad%d:%08lx", j, PciData.u.type0.BaseAddresses[j]);
                        k = 1;
                    }
                }

#if 0
                if (PciData.u.type0.ROMBaseAddress == 0xC08001) {

                    PciData.u.type0.ROMBaseAddress = 0xC00001;
                    HalSetBusData (
                        PCIConfiguration,
                        bus,
                        SlotNumber.u.AsULONG,
                        &PciData,
                        sizeof (PciData)
                        );

                    HalGetBusData (
                        PCIConfiguration,
                        bus,
                        SlotNumber.u.AsULONG,
                        &PciData,
                        sizeof (PciData)
                        );

                    DbgPrint ("\n  Bogus rom address, edit yields:%08lx",
                        PciData.u.type0.ROMBaseAddress);
                }
#endif

                if (k) {
                    DbgPrint ("\n");
                }

                if (PciData.VendorID == 0x8086) {
                    // dump complete buffer
                    DbgPrint ("Command %x, Status %x, BIST %x\n",
                        PciData.Command, PciData.Status,
                        PciData.BIST
                        );

                    DbgPrint ("CacheLineSz %x, LatencyTimer %x",
                        PciData.CacheLineSize, PciData.LatencyTimer
                        );

                    for (j=0; j < 192; j++) {
                        if ((j & 0xf) == 0) {
                            DbgPrint ("\n%02x: ", j + 0x40);
                        }
                        DbgPrint ("%02x ", PciData.DeviceSpecific[j]);
                    }
                    DbgPrint ("\n");
                }


#if 0
                //
                // now print original data
                //

                if (OrigData.u.type0.ROMBaseAddress) {
                        DbgPrint (" oROM:%08lx", OrigData.u.type0.ROMBaseAddress);
                }

                DbgPrint ("\n");
                k = 0;
                for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                    if (OrigData.u.type0.BaseAddresses[j]) {
                        DbgPrint (" oAd%d:%08lx", j, OrigData.u.type0.BaseAddresses[j]);
                        k = 1;
                    }
                }

                //
                // Restore original settings
                //

                HalSetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &OrigData,
                    sizeof (PciData)
                    );
#endif

                //
                // Next
                //

                if (k) {
                    DbgPrint ("\n\n");
                }
            }
        }
    }
    DbgBreakPoint ();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixpciir.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ixpciir.h

Abstract:

    This header file defines the private interfaces, defines and structures
    for Pci Irq Routing support.

Author:

    Santosh Jodh (santoshj) 10-June-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include <pciirqmp.h>

#define PCI_LINK_SIGNATURE  'KNLP'

#define IsPciIrqRoutingEnabled()    \
    (HalpPciIrqRoutingInfo.PciIrqRoutingTable && HalpPciIrqRoutingInfo.PciInterface)

typedef struct _LINK_STATE LINK_STATE, *PLINK_STATE;
typedef struct _LINK_NODE LINK_NODE, *PLINK_NODE;
typedef struct _PCI_IRQ_ROUTING_INFO PCI_IRQ_ROUTING_INFO, *PPCI_IRQ_ROUTING_INFO;

struct _LINK_STATE {
    ULONG           Interrupt;      // Interrupt for this link.
    ULONG           RefCount;       // Number of devices using this link.
};

struct _LINK_NODE {
    ULONG       Signature;      // Signature 'PLNK'.
    PLINK_NODE  Next;
    ULONG       Link;           // Link value.
    ULONG       InterruptMap;   // Possible Irq map.
    PLINK_STATE Allocation;
    PLINK_STATE PossibleAllocation;
};

struct _PCI_IRQ_ROUTING_INFO {
    PPCI_IRQ_ROUTING_TABLE          PciIrqRoutingTable;
    PINT_ROUTE_INTERFACE_STANDARD   PciInterface;
    PLINK_NODE                      LinkNodeHead;
    ULONG                           Parameters;
};

NTSTATUS
HalpInitPciIrqRouting (
    OUT PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo
    );

NTSTATUS
HalpFindLinkNode (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Bus,
    IN ULONG Slot,
    OUT PLINK_NODE *LinkNode
    );

NTSTATUS
HalpCommitLink (
    IN PLINK_NODE LinkNode
    );

VOID
HalpProgramInterruptLine (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Interrupt
    );

extern PCI_IRQ_ROUTING_INFO HalpPciIrqRoutingInfo;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixphwsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixphwsup.c

Abstract:

    This module contains the HalpXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would normally reside in the internal.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "halp.h"
#if MCA

#include "mca.h"

#else

#include "eisa.h"

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpAllocateAdapter)
#pragma alloc_text(PAGELK,HalpGrowMapBuffers)
#endif


//
// Some devices require a physically contiguous data buffer for DMA transfers.
// Map registers are used to give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//

#if defined(_HALPAE_)
MASTER_ADAPTER_OBJECT MasterAdapter24;
MASTER_ADAPTER_OBJECT MasterAdapter32;
#else
PADAPTER_OBJECT MasterAdapterObject;
#endif

BOOLEAN LessThan16Mb;
BOOLEAN HalpEisaDma;

#define ADAPTER_BASE_MASTER    ((PVOID)-1)


#if !defined(_HALPAE_)

//
// Map buffer prameters.  These are initialized in HalInitSystem.
//

PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
ULONG HalpMapBufferSize;

#endif

//
// Define DMA operations structure.
//

const DMA_OPERATIONS HalpDmaOperations = {
    sizeof(DMA_OPERATIONS),
    (PPUT_DMA_ADAPTER) HalPutDmaAdapter,
    (PALLOCATE_COMMON_BUFFER) HalAllocateCommonBuffer,
    (PFREE_COMMON_BUFFER) HalFreeCommonBuffer,
    (PALLOCATE_ADAPTER_CHANNEL) IoAllocateAdapterChannel,
    (PFLUSH_ADAPTER_BUFFERS) IoFlushAdapterBuffers,
    (PFREE_ADAPTER_CHANNEL) IoFreeAdapterChannel,
    (PFREE_MAP_REGISTERS) IoFreeMapRegisters,
    (PMAP_TRANSFER) IoMapTransfer,
    (PGET_DMA_ALIGNMENT) HalGetDmaAlignment,
    (PREAD_DMA_COUNTER) HalReadDmaCounter,
    (PGET_SCATTER_GATHER_LIST) HalGetScatterGatherList,
    (PPUT_SCATTER_GATHER_LIST) HalPutScatterGatherList,
    (PCALCULATE_SCATTER_GATHER_LIST_SIZE)HalCalculateScatterGatherListSize,
    (PBUILD_SCATTER_GATHER_LIST) HalBuildScatterGatherList,
    (PBUILD_MDL_FROM_SCATTER_GATHER_LIST) HalBuildMdlFromScatterGatherList
    };



BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    )
/*++

Routine Description:

    This function attempts to allocate additional map buffers for use by I/O
    devices.  The map register table is updated to indicate the additional
    buffers.

    Caller owns the HalpNewAdapter event

Arguments:

    AdapterObject - Supplies the adapter object for which the buffers are to be
        allocated.

    Amount - Indicates the size of the map buffers which should be allocated.

Return Value:

    TRUE is returned if the memory could be allocated.

    FALSE is returned if the memory could not be allocated.

--*/
{
    ULONG MapBufferPhysicalAddress;
    PVOID MapBufferVirtualAddress;
    PTRANSLATION_ENTRY TranslationEntry;
    LONG NumberOfPages;
    LONG i;
    PHYSICAL_ADDRESS physicalAddressMinimum;
    PHYSICAL_ADDRESS physicalAddressMaximum;
    PHYSICAL_ADDRESS boundaryAddress;
    KIRQL Irql;
    PVOID CodeLockHandle;
    ULONG maximumBufferPages;
    BOOLEAN dma32Bit;
    ULONG bytesToAllocate;

    PAGED_CODE();

    dma32Bit = AdapterObject->Dma32BitAddresses;
    boundaryAddress.QuadPart = 0;

    NumberOfPages = BYTES_TO_PAGES(Amount);

    //
    // Make sure there is room for the additional pages.  The maximum number of
    // slots needed is equal to NumberOfPages + Amount / 64K + 1.
    //

    maximumBufferPages =
        HalpMaximumMapBufferRegisters( dma32Bit );

    i = maximumBufferPages - (NumberOfPages +
        (NumberOfPages * PAGE_SIZE) / 0x10000 + 1 +
        AdapterObject->NumberOfMapRegisters);

    if (i < 0) {

        //
        // Reduce the allocation amount so it will fit.
        //

        NumberOfPages += i;
    }

    if (NumberOfPages <= 0) {

        //
        // No more memory can be allocated.
        //

        return(FALSE);
    }

    if (AdapterObject->NumberOfMapRegisters == 0  &&
        HalpMapBufferSize( dma32Bit )) {

        NumberOfPages =
            BYTES_TO_PAGES( HalpMapBufferSize( dma32Bit ));

        //
        // Since this is the initial allocation, use the buffer allocated by
        // HalInitSystem rather than allocating a new one.
        //

        MapBufferPhysicalAddress =
            HalpMapBufferPhysicalAddress( dma32Bit ).LowPart;

        //
        // Map the buffer for access.
        //

        MapBufferVirtualAddress = MmMapIoSpace(
            HalpMapBufferPhysicalAddress( dma32Bit ),
            HalpMapBufferSize( dma32Bit ),
            TRUE                                // Cache enable.
            );

        if (MapBufferVirtualAddress == NULL) {

            //
            // The buffer could not be mapped.
            //

            HalpMapBufferSize( dma32Bit ) = 0;
            return(FALSE);
        }


    } else {

        //
        // Allocate the map buffers.
        //

        physicalAddressMaximum =
            HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

        if (physicalAddressMaximum.LowPart == (ULONG)-1) {

            //
            // This adapter can handle at least 32-bit addresses.  In an effort
            // to leave memory to 24-bit adapters, try to make this allocation
            // above the 24 bit line.
            //

            physicalAddressMinimum.QuadPart = MAXIMUM_PHYSICAL_ADDRESS;

        } else {

            physicalAddressMinimum.QuadPart = 0;
        }

        bytesToAllocate = NumberOfPages * PAGE_SIZE;

        //
        // This loop is executed a maximum of two times.
        //

        while(TRUE) {

            MapBufferVirtualAddress =
                MmAllocateContiguousMemorySpecifyCache( bytesToAllocate,
                                                        physicalAddressMinimum,
                                                        physicalAddressMaximum,
                                                        boundaryAddress,
                                                        MmCached );

            if (MapBufferVirtualAddress != NULL) {

                //
                // The memory was allocated.
                //

                break;
            }

            //
            // The allocation attempt failed.
            //

            if (physicalAddressMinimum.QuadPart != 0) {

                //
                // We were trying to allocate memory above the 16M line as
                // an optimization.  Relax that requirement and try again.
                //

                physicalAddressMinimum.QuadPart = 0;

            } else {

                //
                // The memory could not be allocated.
                //

                return FALSE;
            }
        }

        //
        // Get the physical address of the map base.
        //

        MapBufferPhysicalAddress = MmGetPhysicalAddress(
            MapBufferVirtualAddress
            ).LowPart;

    }

    //
    // Initialize the map registers where memory has been allocated.
    // Serialize with master adapter object.
    //

    CodeLockHandle = MmLockPagableCodeSection (&HalpGrowMapBuffers);
    KeAcquireSpinLock( &AdapterObject->SpinLock, &Irql );

    TranslationEntry = ((PTRANSLATION_ENTRY) AdapterObject->MapRegisterBase) +
        AdapterObject->NumberOfMapRegisters;

    for (i = 0; (LONG) i < NumberOfPages; i++) {

        //
        // Make sure the perivous entry is physically contiguous with the next
        // entry and that a 64K physical bountry is not crossed unless this
        // is an Eisa system.
        //

        if (TranslationEntry != AdapterObject->MapRegisterBase &&
            (((TranslationEntry - 1)->PhysicalAddress + PAGE_SIZE) !=
            MapBufferPhysicalAddress || (!HalpEisaDma &&
            ((TranslationEntry - 1)->PhysicalAddress & ~0x0ffff) !=
            (MapBufferPhysicalAddress & ~0x0ffff)))) {

            //
            // An entry needs to be skipped in the table.  This entry will
            // remain marked as allocated so that no allocation of map
            // registers will cross this bountry.
            //

            TranslationEntry++;
            AdapterObject->NumberOfMapRegisters++;
        }

        //
        // Clear the bits where the memory has been allocated.
        //

        RtlClearBits(
            AdapterObject->MapRegisters,
            (ULONG)(TranslationEntry - (PTRANSLATION_ENTRY)
                AdapterObject->MapRegisterBase),
            1
            );

        TranslationEntry->VirtualAddress = MapBufferVirtualAddress;
        TranslationEntry->PhysicalAddress = MapBufferPhysicalAddress;
        TranslationEntry++;
        (PCCHAR) MapBufferVirtualAddress += PAGE_SIZE;
        MapBufferPhysicalAddress += PAGE_SIZE;

    }

    //
    // Remember the number of pages that were allocated.
    //

    AdapterObject->NumberOfMapRegisters += NumberOfPages;

    //
    // Release master adapter object.
    //

    KeReleaseSpinLock( &AdapterObject->SpinLock, Irql );
    MmUnlockPagableImageSection (CodeLockHandle);
    return(TRUE);
}

#if defined(HalpAllocateAdapterEx)
#undef HalpAllocateAdapterEx
#endif


PADAPTER_OBJECT
HalpAllocateAdapterEx(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber,
    IN BOOLEAN Dma32Bit
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    physically contiguous memory pages.

    Caller owns the HalpNewAdapter event


Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
                             channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the the DMA controller or ADAPTER_BASE_MASTER.

    ChannelNumber - Unused.

    Dma32Bit - Indicates whether the adapter is 24 bit or 32 bit.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{

    PADAPTER_OBJECT AdapterObject;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Size;
    ULONG BitmapSize;
    HANDLE Handle;
    NTSTATUS Status;
    ULONG mapBuffers;
    BOOLEAN creatingMaster;

    UNREFERENCED_PARAMETER(ChannelNumber);

    PAGED_CODE();

    if (AdapterBaseVa == ADAPTER_BASE_MASTER) {
        creatingMaster = TRUE;
    } else {
        creatingMaster = FALSE;
    }

    //
    // Initialize the master adapter if necessary.
    //

    if (creatingMaster == FALSE &&
        MapRegistersPerChannel != 0) {

        //
        // This is not a recursive master adapter allocation, and map registers
        // are necessary.  Allocate a master adapter object of the appropriate
        // type if necessary.
        //

        if (HalpMasterAdapter( Dma32Bit ) == NULL) {

            AdapterObject = HalpAllocateAdapterEx( MapRegistersPerChannel,
                                                   ADAPTER_BASE_MASTER,
                                                   NULL,
                                                   Dma32Bit );

            //
            // If we could not allocate the master adapter then give up.
            //

            if (AdapterObject == NULL) {
                return NULL;
            }

            AdapterObject->Dma32BitAddresses = Dma32Bit;
            AdapterObject->MasterDevice = Dma32Bit;
            HalpMasterAdapter( Dma32Bit ) = AdapterObject;
        }
    }

    //
    // Begin by initializing the object attributes structure to be used when
    // creating the adapter object.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                OBJ_PERMANENT,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL
                              );

    //
    // Determine the size of the adapter object. If this is the master object
    // then allocate space for the register bit map; otherwise, just allocate
    // an adapter object.
    //

    if (creatingMaster != FALSE) {

       //
       // Allocate a bit map large enough MAXIMUM_MAP_BUFFER_SIZE / PAGE_SIZE
       // of map register buffers.
       //

       mapBuffers = HalpMaximumMapBufferRegisters( Dma32Bit );

       BitmapSize = (((sizeof( RTL_BITMAP ) +
            ((mapBuffers + 7) >> 3)) + 3) & ~3);

       Size = sizeof( ADAPTER_OBJECT ) + BitmapSize;

    } else {

       Size = sizeof( ADAPTER_OBJECT );

    }

    //
    // Now create the adapter object.
    //

    Status = ObCreateObject( KernelMode,
                             *IoAdapterObjectType,
                             &ObjectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             Size,
                             0,
                             0,
                             (PVOID *)&AdapterObject );

    //
    // Reference the object.
    //

    if (NT_SUCCESS(Status)) {

        Status = ObReferenceObjectByPointer(
            AdapterObject,
            FILE_READ_DATA | FILE_WRITE_DATA,
            *IoAdapterObjectType,
            KernelMode
            );

    }

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the object table.
    //

    if (NT_SUCCESS( Status )) {

        RtlZeroMemory (AdapterObject, sizeof (ADAPTER_OBJECT));

        Status = ObInsertObject( AdapterObject,
                                 NULL,
                                 FILE_READ_DATA | FILE_WRITE_DATA,
                                 0,
                                 (PVOID *) NULL,
                                 &Handle );

        if (NT_SUCCESS( Status )) {

            ZwClose( Handle );

            //
            // Initialize the adapter object itself.
            //

            AdapterObject->DmaHeader.Version = IO_TYPE_ADAPTER;
            AdapterObject->DmaHeader.Size = (USHORT) Size;
            AdapterObject->MapRegistersPerChannel = 1;
            AdapterObject->AdapterBaseVa = AdapterBaseVa;
            AdapterObject->ChannelNumber = 0xff;
            AdapterObject->DmaHeader.DmaOperations = (PDMA_OPERATIONS)&HalpDmaOperations;
            AdapterObject->Dma32BitAddresses = Dma32Bit;

            if (MapRegistersPerChannel) {

                AdapterObject->MasterAdapter = HalpMasterAdapter( Dma32Bit );

            } else {

                AdapterObject->MasterAdapter = NULL;

            }

            //
            // Initialize the channel wait queue for this adapter.
            //

            KeInitializeDeviceQueue( &AdapterObject->ChannelWaitQueue );

            //
            // If this is the MasterAdatper then initialize the register bit map,
            // AdapterQueue and the spin lock.
            //

            if (creatingMaster != FALSE) {

               KeInitializeSpinLock( &AdapterObject->SpinLock );

               InitializeListHead( &AdapterObject->AdapterQueue );

               AdapterObject->MapRegisters = (PVOID) ( AdapterObject + 1);

               RtlInitializeBitMap( AdapterObject->MapRegisters,
                                    (PULONG) (((PCHAR) (AdapterObject->MapRegisters)) + sizeof( RTL_BITMAP )),
                                    ( mapBuffers )
                                    );
               //
               // Set all the bits in the memory to indicate that memory
               // has not been allocated for the map buffers.
               //

               RtlSetAllBits( AdapterObject->MapRegisters );
               AdapterObject->NumberOfMapRegisters = 0;
               AdapterObject->CommittedMapRegisters = 0;

               //
               // Allocate the memory map registers.
               //

               AdapterObject->MapRegisterBase =
                   ExAllocatePoolWithTag(
                       NonPagedPool,
                       mapBuffers * sizeof(TRANSLATION_ENTRY),
                       HAL_POOL_TAG
                       );

               if (AdapterObject->MapRegisterBase == NULL) {

                   ObDereferenceObject( AdapterObject );
                   AdapterObject = NULL;
                   return(NULL);

               }

               //
               // Zero the map registers.
               //

               RtlZeroMemory(
                    AdapterObject->MapRegisterBase,
                    mapBuffers * sizeof(TRANSLATION_ENTRY)
                    );

               if (!HalpGrowMapBuffers(AdapterObject, INITIAL_MAP_BUFFER_SMALL_SIZE))
               {

                   //
                   // If no map registers could be allocated then free the
                   // object.
                   //

                   ObDereferenceObject( AdapterObject );
                   AdapterObject = NULL;
                   return(NULL);

               }
           }

        } else {

            //
            // An error was incurred for some reason.  Set the return value
            // to NULL.
            //

            AdapterObject = (PADAPTER_OBJECT) NULL;
        }
    } else {

        AdapterObject = (PADAPTER_OBJECT) NULL;

    }


    return AdapterObject;

}

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    physically contiguous memory pages.

    Caller owns the HalpNewAdapter event


Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
                             channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the DMA controller or ADAPTER_BASE_MASTER.

    ChannelNumber - Unused.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{
    return HalpAllocateAdapterEx( MapRegistersPerChannel,
                                  AdapterBaseVa,
                                  ChannelNumber,
                                  FALSE );
}


ULONG
HalGetDmaAlignment (
    PVOID Conext
    )
{
    return HalGetDmaAlignmentRequirement();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixpciir.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ixpciir.c

Abstract:

    This module implements the code to provide Pci Irq Routing
    support. It reads the routing table, provides the Irq arbiter
    and uses the chipset miniport library to program the links.

Author:

    Santosh Jodh (santoshj) 10-June-1998

Environment:

    Kernel mode only.

Revision History:

--*/

//
// This module is compatible with PAE mode and therefore treats physical
// addresses as 64-bit entities.
//

#if !defined(_PHYS64_)
#define _PHYS64_
#endif

#include "halp.h"
#include <pci.h>
#include <stdio.h>

#ifndef _IN_KERNEL_
#define _IN_KERNEL_
#include <regstr.h>
#undef _IN_KERNEL_
#else
#include <regstr.h>
#endif

#include "pcip.h"
#include "ixpciir.h"

#ifndef MAXIMUM_VALUE_NAME_LENGTH
#define MAXIMUM_VALUE_NAME_LENGTH   256
#endif

//
// MS specification for PCI IRQ Routing specifies that the BIOS
// provide the table in the ROM between the physical addresses
// of 0xF0000 and 0xFFFFF. The table starts on a 16-byte boundary
// with a 4-byte signature of "$PIR".
//
// Other restrictions:
//
// Version:     Should be 1.0
// Size:        Must be integral multiple of 16 bytes and > 32 bytes
// Checksum:    The entire table should checksum to 0.
//

#define PIRT_BIOS_START     0xf0000
#define PIRT_BIOS_END       0xfffff
#define PIRT_BIOS_SIZE      (PIRT_BIOS_END - PIRT_BIOS_START + 1)
#define PIRT_ALIGNMENT      16

#define PIRT_SIGNATURE      'RIP$'      // $PIR little endian

#define PIRT_VERSION        0x0100

ULONG
HalpGetIrqRoutingTable (
    OUT PPCI_IRQ_ROUTING_TABLE   *PciIrqRoutingTable,
    IN ULONG Options
    );

ULONG
HalpInitializeMiniport (
    IN OUT PPCI_IRQ_ROUTING_INFO  PciIrqRoutingInfo
    );

NTSTATUS
HalpInitLinkNodes (
    PPCI_IRQ_ROUTING_INFO   PciIrqRoutingInfo
    );

PPCI_IRQ_ROUTING_TABLE
HalpGetRegistryTable (
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    IN ULONG    HeaderSize OPTIONAL
    );

PPCI_IRQ_ROUTING_TABLE
HalpGetPCIBIOSTableFromRealMode(
    VOID
    );

PPCI_IRQ_ROUTING_TABLE
HalpGet$PIRTable (
    VOID
    );

PPCI_IRQ_ROUTING_TABLE
HalpCopy$PIRTable (
    IN PUCHAR   BiosPtr,
    IN PUCHAR   BiosEnd
    );

BOOLEAN
HalpSanityCheckTable (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable,
    IN BOOLEAN IgnoreChecksum
    );

PSLOT_INFO
HalpBarberPole (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Bus,
    IN ULONG Slot,
    IN OUT PUCHAR Pin
    );

BOOLEAN
HalpBarberPolePin (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Parent,
    IN ULONG Bus,
    IN ULONG Device,
    IN OUT PUCHAR Pin
    );

PSLOT_INFO
HalpGetSlotInfo (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable,
    IN UCHAR   Bus,
    IN UCHAR   Device
    );

NTSTATUS
HalpReadRegistryValue (
    IN HANDLE  Root,
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    OUT PULONG  Data
    );

NTSTATUS
HalpWriteRegistryValue (
    IN HANDLE  Root,
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    IN ULONG   Value
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpInitPciIrqRouting)
#pragma alloc_text(PAGE, HalpGetIrqRoutingTable)
#pragma alloc_text(PAGE, HalpInitializeMiniport)
#pragma alloc_text(PAGE, HalpInitLinkNodes)
#pragma alloc_text(PAGE, HalpGetRegistryTable)
#pragma alloc_text(PAGE, HalpGetPCIBIOSTableFromRealMode)
#pragma alloc_text(PAGE, HalpGet$PIRTable)
#pragma alloc_text(PAGE, HalpCopy$PIRTable)
#pragma alloc_text(PAGE, HalpSanityCheckTable)
#pragma alloc_text(PAGE, HalpBarberPole)
#pragma alloc_text(PAGE, HalpBarberPolePin)
#pragma alloc_text(PAGE, HalpFindLinkNode)
#pragma alloc_text(PAGE, HalpGetSlotInfo)
#pragma alloc_text(PAGE, HalpReadRegistryValue)
#pragma alloc_text(PAGE, HalpWriteRegistryValue)
#pragma alloc_text(PAGE, HalpProgramInterruptLine)
#pragma alloc_text(PAGELK, HalpCommitLink)
#endif

extern PULONG InitSafeBootMode;

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
//
// Global key for Pci Irq Routing.
//

const WCHAR   rgzPciIrqRouting[] = REGSTR_PATH_PCIIR;

//
// Pci Irq Routing options value.
//

const WCHAR   rgzOptions[] = REGSTR_VAL_OPTIONS;

//
// Pci Irq Routing status values.
//

const WCHAR   rgzStatus[] = REGSTR_VAL_STAT;

//
// Pci Irq Routing Table status values.
//

const WCHAR   rgzTableStatus[] = REGSTR_VAL_TABLE_STAT;

//
// Pci Irq Routing Miniport status values.
//

const WCHAR   rgzMiniportStatus[] = REGSTR_VAL_MINIPORT_STAT;

//
// Offset from 0xF0000 where $PIR table was last found.
//

const WCHAR   rgz$PIROffset[] = L"$PIROffset";

//
// Irq Miniports key under rgzPciIrqRouting.
// This key contains keys whose name is the device-vendor id
// for the chipsets we support.
//

const WCHAR   rgzIrqMiniports[] = REGSTR_PATH_PCIIR L"\\IrqMiniports";

//
// Each miniport key contains a instance value which
// corresponds to the entry for the chipset in the
// miniport table.
//

const WCHAR   rgzInstance[] = L"Instance";

//
// This key overrides all miniports if present.
//

const WCHAR   rgzOverride[] = L"Override";

//
// Registry key for the routing table.
//

const WCHAR   rgzIrqRoutingTable[] = REGSTR_PATH_PCIIR L"\\IrqRoutingTables";

//
// Registry key for BIOS attributes.
//

const WCHAR   rgzBiosInfo[] = REGSTR_PATH_BIOSINFO L"\\PciIrqRouting";
const WCHAR   rgzAttributes[] = L"Attributes";

const WCHAR   rgzPciParameters[] = L"Parameters";

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

PCI_IRQ_ROUTING_INFO    HalpPciIrqRoutingInfo = {0};
ULONG                   HalpIrqMiniportInitialized = 0;

NTSTATUS
HalpInitPciIrqRouting (
    OUT PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo
    )

/*++

    Routine Description:

        This routine initializes Pci Irq Routing by reading the
        Irq routing table, initializing the chipset miniport and
        initializing the Pci Interrupt Routing interface.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing information.

    Return Value:

--*/

{
    NTSTATUS    status;
    ULONG       pirStatus;
    ULONG       tableStatus;
    ULONG       miniportStatus;
    ULONG       pirOptions;

    PAGED_CODE();

    //
    // Setup to return failure.
    //

    HalpIrqMiniportInitialized = 0;
    status = STATUS_UNSUCCESSFUL;
    pirStatus = PIR_STATUS_MAX;
    tableStatus = PIR_STATUS_TABLE_MAX | (PIR_STATUS_TABLE_MAX << 16);
    miniportStatus = PIR_STATUS_MINIPORT_MAX | (PIR_STATUS_MINIPORT_MAX << 16);

    //
    // No IRQ routing in safe boot.
    //

    if (!(*InitSafeBootMode))
    {
        pirStatus = PIR_STATUS_DISABLED;

        //
        // Read Pci Interrupt Routing options set by the user.
        //

        pirOptions = 0;
        HalpReadRegistryValue(NULL, rgzPciIrqRouting, rgzOptions, &pirOptions);

        //
        //  Make sure Pci Interrupt Routing is not disabled.
        //

        if (pirOptions & PIR_OPTION_ENABLED)
        {
            //
            // First get the interface from Pci.
            //

            if (PciIrqRoutingInfo->PciInterface)
            {
                HalPrint(("Obtained the Pci Interrupt Routing Interface from Pci driver!"));

                status = STATUS_UNSUCCESSFUL;

                //
                // Get the Pci Interrupt Routing table for this motherboard.
                //

                tableStatus = HalpGetIrqRoutingTable(&PciIrqRoutingInfo->PciIrqRoutingTable, pirOptions);
                if ((tableStatus & 0xFFFF) < PIR_STATUS_TABLE_NONE)
                {
                    //
                    // Get the miniport instance for this motherboard.
                    //

                    miniportStatus = HalpInitializeMiniport(PciIrqRoutingInfo);
                    if ((miniportStatus & 0xFFFF) < PIR_STATUS_MINIPORT_NONE)
                    {

                        //
                        // Validate the Pci Irq Routing table with the miniport.
                        //

                        status = PciirqmpValidateTable( PciIrqRoutingInfo->PciIrqRoutingTable,
                                                        ((tableStatus & 0xFFFF) == PIR_STATUS_TABLE_REALMODE)? 1 : 0);
                        if (!NT_SUCCESS(status))
                        {
                            HalPrint(("Pci irq miniport failed to validate the routing table!"));
                            miniportStatus |= (PIR_STATUS_MINIPORT_INVALID << 16);
                        }
                        else
                        {
                            HalPrint(("Pci irq miniport validated routing table!"));
                            miniportStatus |= (PIR_STATUS_MINIPORT_SUCCESS << 16);
                            pirStatus = PIR_STATUS_ENABLED;
                            HalpIrqMiniportInitialized = TRUE;
                        }
                    }
                }
            }
            else
            {
                pirStatus = PIR_STATUS_ERROR;
            }
        }
        else
        {
            HalPrint(("Pci Irq Routing disabled!"));
        }

        //
        // Create list of links.
        //

        if (NT_SUCCESS(status))
        {
            status = HalpInitLinkNodes(PciIrqRoutingInfo);
        }

        //
        // Free the memory for the routing table if there was any error.
        //

        if (!NT_SUCCESS(status))
        {
            if (PciIrqRoutingInfo->PciIrqRoutingTable != NULL)
            {
                ExFreePool(PciIrqRoutingInfo->PciIrqRoutingTable);
                PciIrqRoutingInfo->PciIrqRoutingTable = NULL;
            }

            if (PciIrqRoutingInfo->PciInterface)
            {
                PciIrqRoutingInfo->PciInterface = NULL;
            }
        }

        //
        // Initialize the miniport if not done yet.
        //

        if (!HalpIrqMiniportInitialized)
        {
            PCI_IRQ_ROUTING_TABLE table;

            //
            // Use a local routing table variable since the miniport initialization
            // just needs to look at certain fields in the table.
            //

            PciIrqRoutingInfo->PciIrqRoutingTable = &table;
            PciIrqRoutingInfo->PciIrqRoutingTable->RouterBus = 0;
            PciIrqRoutingInfo->PciIrqRoutingTable->RouterDevFunc = 0;
            PciIrqRoutingInfo->PciIrqRoutingTable->CompatibleRouter = 0xFFFFFFFF;
            PciIrqRoutingInfo->PciIrqRoutingTable->MiniportData = 0;
            HalpIrqMiniportInitialized = ((HalpInitializeMiniport(PciIrqRoutingInfo) & 0xFFFF) < PIR_STATUS_MINIPORT_NONE)? TRUE : FALSE;

            //
            // Reset the routing table to NULL since we dont need it any more.
            //

            PciIrqRoutingInfo->PciIrqRoutingTable = NULL;
        }
    }

    //
    // Record the status in the registry for user display.
    //

    HalpWriteRegistryValue(NULL, rgzPciIrqRouting, rgzStatus, pirStatus);
    HalpWriteRegistryValue(NULL, rgzPciIrqRouting, rgzTableStatus, tableStatus);
    HalpWriteRegistryValue(NULL, rgzPciIrqRouting, rgzMiniportStatus, miniportStatus);

    return (status);
}

ULONG
HalpGetIrqRoutingTable (
    OUT PPCI_IRQ_ROUTING_TABLE   *PciIrqRoutingTable,
    IN ULONG Options
    )

/*++

Routine Description:

    Reads the Pci Irq Routing table. First tries to
    read the table from the registry if available. Otherwise
    scans the BIOS ROM for the $PIR table.

Input Parameters:

    PciIrqRoutingTable is the pointer to the variable
    that recieves the pointer to the routing table.

Return Value:

    Status value indicating the source of the table.

--*/

{
    ULONG tableStatus = PIR_STATUS_TABLE_NONE | (PIR_STATUS_TABLE_MAX << 16);
    ULONG biosAttributes = 0;

    PAGED_CODE();

    *PciIrqRoutingTable = NULL;

    HalpReadRegistryValue(NULL, rgzBiosInfo, rgzAttributes, &biosAttributes);

    if (Options & PIR_OPTION_REGISTRY)
    {
        //
        // First try getting it from the registry.
        //

        *PciIrqRoutingTable = HalpGetRegistryTable(rgzIrqRoutingTable, rgzOverride, 0);
        if (*PciIrqRoutingTable != NULL)
        {
            HalPrint(("Pci Irq Table read from the registry!"));
            tableStatus = PIR_STATUS_TABLE_REGISTRY;
        }
    }

    if ((Options & PIR_OPTION_MSSPEC) && !(biosAttributes & PIR_OPTION_MSSPEC))
    {
        if (*PciIrqRoutingTable == NULL)
        {
            //
            // Next try getting it by scanning the BIOS ROM for $PIR table.
            //

            *PciIrqRoutingTable = HalpGet$PIRTable();
            if (*PciIrqRoutingTable != NULL)
            {
                HalPrint(("Pci Irq Routing table read from $PIR table in BIOS ROM!"));
                tableStatus = PIR_STATUS_TABLE_MSSPEC;
            }
        }
    }

    if ((Options & PIR_OPTION_REALMODE) && !(biosAttributes & PIR_OPTION_REALMODE))
    {
        if (*PciIrqRoutingTable == NULL)
        {
            //
            // First try getting it from the registry.
            //

            *PciIrqRoutingTable = HalpGetPCIBIOSTableFromRealMode();
            if (*PciIrqRoutingTable != NULL)
            {
                HalPrint(("Pci Irq Table read from PCI BIOS using real-mode interface!"));
                tableStatus = PIR_STATUS_TABLE_REALMODE;
            }
        }
    }

    if (*PciIrqRoutingTable == NULL)
    {
        if (biosAttributes)
        {
            tableStatus = PIR_STATUS_TABLE_BAD | (PIR_STATUS_TABLE_MAX << 16);
        }

        HalPrint(("No Pci Irq Routing table found for this system!"));
    }
    else
    {
        tableStatus |= (PIR_STATUS_TABLE_SUCCESS << 16);
    }

    return (tableStatus);
}

ULONG
HalpInitializeMiniport (
    IN OUT PPCI_IRQ_ROUTING_INFO    PciIrqRoutingInfo
    )

/*++

Routine Description:

    Initializes the appropriate miniport for this motherboard.

Input Parameters:

    PciIrqRoutingTable - Routing Table for which miniport
    needs to be initialized.

Return Value:

    Status value indicating whether the miniport initialized or not.

--*/

{
    ULONG                   miniportStatus;
    NTSTATUS                status;
    PBUS_HANDLER            busHandler;
    PCI_SLOT_NUMBER         slotNumber;
    ULONG                   device;
    ULONG                   function;
    ULONG                   routerId;
    ULONG                   miniportInstance;
    HANDLE                  irqMiniport;
    UCHAR                   headerType;
    WCHAR                   buffer[10];
    UNICODE_STRING          keyName;
    PPCI_IRQ_ROUTING_TABLE  pciIrqRoutingTable = PciIrqRoutingInfo->PciIrqRoutingTable;


    PAGED_CODE();

    //
    // Setup to return failure.
    //

    miniportStatus = PIR_STATUS_MINIPORT_NONE;

    //
    // Open the Pci Interrupt Miniport key.
    //

    RtlInitUnicodeString( &keyName, rgzIrqMiniports);

    status = HalpOpenRegistryKey(   &irqMiniport,
                                    NULL,
                                    &keyName,
                                    KEY_READ,
                                    FALSE);
    if (NT_SUCCESS(status))
    {
        //
        // First see if there is any overriding miniport.
        //

        status = HalpReadRegistryValue( irqMiniport,
                                        rgzOverride,
                                        rgzInstance,
                                        &miniportInstance);
        if (!NT_SUCCESS(status))
        {
            //
            // Next see if there is an entry for the specified device.
            //

            busHandler = HalpHandlerForBus(PCIBus, pciIrqRoutingTable->RouterBus);
            if (busHandler)
            {
                slotNumber.u.bits.DeviceNumber = pciIrqRoutingTable->RouterDevFunc >> 3;
                slotNumber.u.bits.FunctionNumber = pciIrqRoutingTable->RouterDevFunc & 0x07;
                routerId = 0xFFFFFFFF;
                HalpReadPCIConfig(  busHandler,
                                    slotNumber,
                                    &routerId,
                                    0,
                                    4);
                if (routerId != 0xFFFFFFFF)
                {

                    swprintf(buffer, L"%08X", routerId);

                    status = HalpReadRegistryValue( irqMiniport,
                                                    buffer,
                                                    rgzInstance,
                                                    &miniportInstance);
                    if (NT_SUCCESS(status))
                    {
                        HalPrint(("Found miniport instance %08X for this motherboard!", miniportInstance));
                        miniportStatus = PIR_STATUS_MINIPORT_NORMAL;
                        HalpReadRegistryValue(irqMiniport, buffer, rgzPciParameters, &PciIrqRoutingInfo->Parameters);
                    }
                }
            }
        }
        else
        {
            HalPrint(("Overriding miniport instance %08X found for this motherboard!", miniportInstance));
            miniportStatus = PIR_STATUS_MINIPORT_OVERRIDE;
        }

        //
        // Next see if we have a miniport for the compatible router.
        //

        if (miniportStatus == PIR_STATUS_MINIPORT_NONE)
        {

            //
            // Make sure there is a valid compatible router.
            //

            if (    pciIrqRoutingTable->CompatibleRouter != 0xFFFFFFFF &&
                    pciIrqRoutingTable->CompatibleRouter != 0)
            {
                swprintf(buffer, L"%08X", pciIrqRoutingTable->CompatibleRouter);

                status = HalpReadRegistryValue( irqMiniport,
                                                buffer,
                                                rgzInstance,
                                                &miniportInstance);
                if (NT_SUCCESS(status))
                {
                    HalPrint(("Found miniport instance %08X for this motherboard using compatible router %08X!", miniportInstance, pciIrqRoutingTable->CompatibleRouter));
                    miniportStatus = PIR_STATUS_MINIPORT_COMPATIBLE;
                    HalpReadRegistryValue(irqMiniport, buffer, rgzPciParameters, &PciIrqRoutingInfo->Parameters);
                }
            }
        }

        if (miniportStatus == PIR_STATUS_MINIPORT_NONE)
        {
            //
            // Last see if any device on bus 0 matches any of our supported
            // routers.
            //

            busHandler = HalpHandlerForBus(PCIBus, 0);
            if (busHandler)
            {
                slotNumber.u.AsULONG = 0;
                for (   device = 0;
                        device < PCI_MAX_DEVICES && (miniportStatus == PIR_STATUS_MINIPORT_NONE);
                        device++)
                {
                    slotNumber.u.bits.DeviceNumber = device;

                    for (function = 0; function < PCI_MAX_FUNCTION; function++)
                    {
                        slotNumber.u.bits.FunctionNumber = function;

                        //
                        // Dont waste time if this is not a multifunction device.
                        //

                        if (function == 1)
                        {
                            headerType = 0;
                            HalpReadPCIConfig(  busHandler,
                                                slotNumber,
                                                &headerType,
                                                0x0E,
                                                sizeof(headerType));
                            if (!(headerType & PCI_MULTIFUNCTION))
                                break;
                        }

                        routerId = 0xFFFFFFFF;
                        HalpReadPCIConfig(  busHandler,
                                            slotNumber,
                                            &routerId,
                                            0,
                                            4);
                        if (routerId == 0xFFFFFFFF)
                            continue;

                        swprintf(buffer, L"%08X", routerId);

                        status = HalpReadRegistryValue( irqMiniport,
                                                        buffer,
                                                        rgzInstance,
                                                        &miniportInstance);
                        if (NT_SUCCESS(status))
                        {
                            HalPrint(("Found miniport instance %08X for this motherboard for bus 0 device %08X", miniportInstance, routerId));
                            pciIrqRoutingTable->RouterBus = 0;
                            pciIrqRoutingTable->RouterDevFunc = (UCHAR)((device << 3) + function);
                            miniportStatus = PIR_STATUS_MINIPORT_NORMAL;
                            HalpReadRegistryValue(irqMiniport, buffer, rgzPciParameters, &PciIrqRoutingInfo->Parameters);
                            break;
                        }
                    }
                }
            }
        }

        ZwClose(irqMiniport);

        //
        // Initialize the miniport if we found one.
        //

        if (miniportStatus != PIR_STATUS_MINIPORT_NONE)
        {
            status = PciirqmpInit(  miniportInstance,
                                    pciIrqRoutingTable->RouterBus,
                                    pciIrqRoutingTable->RouterDevFunc);
            if (!NT_SUCCESS(status))
            {
                HalPrint(("Pci Irq miniport %08X failed to initialize!", miniportInstance));
                miniportStatus |= (PIR_STATUS_MINIPORT_ERROR << 16);
            }
            else
            {
                HalPrint(("Pci Irq miniport %08X successfully initialized!", miniportInstance));
            }
        }
        else
        {
            HalPrint(("No Pci Irq miniport found for this system!"));
            miniportStatus |= (PIR_STATUS_MINIPORT_MAX << 16);
        }
    }
    else
    {
        HalPrint(("Could not open the Pci Irq Miniports key, no miniports provided!"));
        miniportStatus = PIR_STATUS_MINIPORT_NOKEY | (PIR_STATUS_MINIPORT_MAX << 16);
    }

    return (miniportStatus);
}

NTSTATUS
HalpInitLinkNodes (
    PPCI_IRQ_ROUTING_INFO   PciIrqRoutingInfo
    )

/*++

    Routine Description:

        This routine creates a singly linked list of link nodes
        structures from the Pci Irq Routing table.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing Information.

    Return Value:

        STATUS_SUCCESS iff successful. Else STATUS_UNSUCCESSFUL.

--*/

{
    PPCI_IRQ_ROUTING_TABLE  pciIrqRoutingTable;
    PSLOT_INFO              slotInfo;
    PSLOT_INFO              lastSlot;
    PPIN_INFO               pinInfo;
    PPIN_INFO               lastPin;
    PLINK_NODE              linkNode;
    NTSTATUS                status = STATUS_SUCCESS;
    PLINK_NODE              temp;

    ASSERT(PciIrqRoutingInfo);

    pciIrqRoutingTable = PciIrqRoutingInfo->PciIrqRoutingTable;

    PciIrqRoutingInfo->LinkNodeHead = NULL;

    //
    // Process all slots in this table.
    //

    slotInfo = (PSLOT_INFO)((PUCHAR)pciIrqRoutingTable +
                                        sizeof(PCI_IRQ_ROUTING_TABLE));
    lastSlot = (PSLOT_INFO)((PUCHAR)pciIrqRoutingTable +
                                        pciIrqRoutingTable->TableSize);
    while (slotInfo < lastSlot)
    {
        //
        // Process all pins.
        //

        pinInfo = &slotInfo->PinInfo[0];
        lastPin = &slotInfo->PinInfo[NUM_IRQ_PINS];
        while (pinInfo < lastPin)
        {
            //
            // Only process valid link values.
            //

            if(pinInfo->Link)
            {
                //
                // Have we seen this link before.
                //

                for (   linkNode = PciIrqRoutingInfo->LinkNodeHead;
                        linkNode && linkNode->Link != pinInfo->Link;
                        linkNode = linkNode->Next);
                if (linkNode == NULL)
                {
                    //
                    // Allocate memory for new link info.
                    //

                    linkNode = ExAllocatePoolWithTag(   NonPagedPool,
                                                        sizeof(LINK_NODE),
                                                        HAL_POOL_TAG);
                    if (linkNode)
                    {
                        linkNode->Allocation = ExAllocatePoolWithTag(   NonPagedPool,
                                                                        sizeof(LINK_STATE),
                                                                        HAL_POOL_TAG);

                        linkNode->PossibleAllocation = ExAllocatePoolWithTag(   NonPagedPool,
                                                                                sizeof(LINK_STATE),
                                                                                HAL_POOL_TAG);
                        if (    linkNode->Allocation &&
                                linkNode->PossibleAllocation)
                        {
                            linkNode->Signature = PCI_LINK_SIGNATURE;
                            linkNode->Next = PciIrqRoutingInfo->LinkNodeHead;
                            PciIrqRoutingInfo->LinkNodeHead = linkNode;
                            linkNode->Link = pinInfo->Link;
                            linkNode->InterruptMap = pinInfo->InterruptMap;
                            linkNode->Allocation->Interrupt = 0;
                            linkNode->Allocation->RefCount = 0;
                            linkNode->PossibleAllocation->Interrupt = 0;
                            linkNode->PossibleAllocation->RefCount = 0;
                        }
                        else
                        {
                            status = STATUS_UNSUCCESSFUL;
                            break;
                        }
                    }
                    else
                    {
                        status = STATUS_UNSUCCESSFUL;
                        break;
                    }
                }
            }

            //
            // Next pin.
            //

            pinInfo++;
        }

        //
        // Next slot.
        //

        slotInfo++;
    }

    //
    // Clean up if there was an error.
    //

    if (!NT_SUCCESS(status))
    {
        linkNode = PciIrqRoutingInfo->LinkNodeHead;
        while (linkNode)
        {
            if (linkNode->Allocation)
            {
                ExFreePool(linkNode->Allocation);
            }
            if (linkNode->PossibleAllocation)
            {
                ExFreePool(linkNode->PossibleAllocation);
            }

            temp = linkNode;
            linkNode = linkNode->Next;
            ExFreePool(temp);
        }

        PciIrqRoutingInfo->LinkNodeHead = NULL;
    }

    return (status);
}

PPCI_IRQ_ROUTING_TABLE
HalpGetRegistryTable (
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    IN ULONG    HeaderSize OPTIONAL
    )

/*++

Routine Description:

    Reads the Pci Irq Routing Table from the registry. The table is
    saved as Override value under IrqRoutingTable key.

Input Parameters:

    None.

Return Value:

    Pointer to the Pci Irq Routing Table if successful.
    NULL if there is no valid table in the registry.

--*/

{
    PVOID                           table = NULL;
    NTSTATUS                        status;
    HANDLE                          hPIR;
    ULONG                           tableSize;
    PKEY_VALUE_FULL_INFORMATION     valueInfo;
    PVOID                           buffer;
    UNICODE_STRING                  override;
    UNICODE_STRING                  keyName;

    PAGED_CODE();

    //
    // Open the PciInterruptRouting registry key.
    //

    RtlInitUnicodeString(&keyName, KeyName);
    status = HalpOpenRegistryKey(&hPIR, NULL, &keyName, KEY_ALL_ACCESS, FALSE);
    if (NT_SUCCESS(status))
    {
        //
        // Get the size of the table.
        //

        tableSize = 0;
        RtlInitUnicodeString(&override, ValueName);
        status = ZwQueryValueKey(   hPIR,
                                    &override,
                                    KeyValueFullInformation,
                                    NULL,
                                    0,
                                    &tableSize);
        if (tableSize != 0)
        {

            //
            // Allocate memory for the table.
            //

            buffer = ExAllocatePoolWithTag( PagedPool,
                                            tableSize,
                                            HAL_POOL_TAG);
            if (buffer != NULL)
            {
                //
                // Read the table.
                //

                status = ZwQueryValueKey(   hPIR,
                                            &override,
                                            KeyValueFullInformation,
                                            buffer,
                                            tableSize,
                                            &tableSize);
                if (NT_SUCCESS(status))
                {
                    valueInfo = (PKEY_VALUE_FULL_INFORMATION)buffer;

                    table = ExAllocatePoolWithTag(  PagedPool,
                                                    valueInfo->DataLength - HeaderSize,
                                                    HAL_POOL_TAG);
                    if (table != NULL)
                    {
                        memcpy( table,
                                (PUCHAR)buffer + valueInfo->DataOffset + HeaderSize,
                                valueInfo->DataLength - HeaderSize);

                        if (HalpSanityCheckTable(table, TRUE) == FALSE)
                        {
                            ExFreePool(table);
                            table = NULL;
                        }
                    }
                    else
                    {
                        HalPrint(("Could not allocate memory to read the Pci Irq Routing Table from the registry!"));
                        ASSERT(table);
                    }
                }

                ExFreePool(buffer);
            }
            else
            {
                HalPrint(("Could not allocate memory to read the Pci Irq Routing Table from the registry!"));
                ASSERT(buffer);
            }
        }

        ZwClose(hPIR);
    }

    return (table);
}

PPCI_IRQ_ROUTING_TABLE
HalpGet$PIRTable (
    VOID
    )

/*++

Routine Description:

    Reads the Pci Irq Routing Table from $PIR table in the BIOS ROM.

Input Parameters:

    None.

Return Value:

    Pointer to the Pci Irq Routing Table if successful.
    NULL if there is no valid table in the ROM.

--*/

{
    PUCHAR                          biosStart;
    PUCHAR                          biosEnd;
    PUCHAR                          searchPtr;
    NTSTATUS                        status;
    ULONG                           offset;
    PPCI_IRQ_ROUTING_TABLE          table;
    PHYSICAL_ADDRESS                biosStartPhysical;

    PAGED_CODE();

    //
    // Setup to return failure.
    //

    table = NULL;

    biosStartPhysical.QuadPart = PIRT_BIOS_START;
    biosStart = (PUCHAR)HalpMapPhysicalMemory(  biosStartPhysical,
                                                PIRT_BIOS_SIZE >> PAGE_SHIFT);
    if (biosStart != NULL)
    {
        biosEnd = biosStart + PIRT_BIOS_SIZE;

        //
        // First try the cached location from the registry.
        //

        status = HalpReadRegistryValue( NULL,
                                        rgzPciIrqRouting,
                                        rgz$PIROffset,
                                        &offset);
        if (NT_SUCCESS(status))
        {
            table = HalpCopy$PIRTable(biosStart + offset, biosEnd);
        }

        if (table == NULL)
        {
            for (   searchPtr = biosStart;
                    searchPtr < biosEnd;
                    searchPtr += PIRT_ALIGNMENT)
            {
                table = HalpCopy$PIRTable(searchPtr, biosEnd);
                if (table != NULL)
                {
                    //
                    // Record this offset so it can be used on the next boot.
                    //

                    offset = searchPtr - biosStart;
                    HalPrint(("Recording location %08X of $PIR table in the registry!", PIRT_BIOS_START + offset));
                    HalpWriteRegistryValue( NULL,
                                            rgzPciIrqRouting,
                                            rgz$PIROffset,
                                            offset);
                    break;
                }
            }
        }
        else
        {
            HalPrint(("Used cached location %08X to read $PIR table!", PIRT_BIOS_START + offset));
        }
    }
    else
    {
        HalPrint(("Failed to map BIOS ROM to scan for $PIR Pci Irq Routing Table!"));
        ASSERT(biosStart);
    }

    return (table);
}

PPCI_IRQ_ROUTING_TABLE
HalpGetPCIBIOSTableFromRealMode(
    VOID
    )

/*++

Routine Description:

    Gets the PCI IRQ routing table from PCI BIOS using real-mode
    interface. The table is read by ntdetect.com and added to the
    ARC tree in the registry.

Input Parameters:

    None.

Return Value:

    Pointer to the Pci Irq Routing Table if successful.
    NULL if there is no valid table.

--*/

{
    PPCI_IRQ_ROUTING_TABLE      table = NULL;
    NTSTATUS                    status;
    HANDLE                      mf;
    HANDLE                      child = NULL;
    UNICODE_STRING              unicodeString;
    ULONG                       index;
    ULONG                       length;
    ULONG                                               temp;
    BOOLEAN                     done;
    BOOLEAN                     error;
    PKEY_BASIC_INFORMATION      keyInfo;
    PKEY_VALUE_FULL_INFORMATION childInfo;

        length = PAGE_SIZE;
    keyInfo = ExAllocatePoolWithTag(    PagedPool,
                                        length,
                                        HAL_POOL_TAG);

        if (keyInfo == NULL)
        {
                HalPrint(("Could not allocate memory to enumerate keys!"));
                return (table);
        }

    childInfo = ExAllocatePoolWithTag(    PagedPool,
                                        length,
                                        HAL_POOL_TAG);

    if (childInfo == NULL)
    {
        ExFreePool(keyInfo);
        HalPrint(("Could not allocate memory to query value!"));
        return (table);
    }

    //
    // Search for the IRQ routing table under the multifunction branch of the registry.
    //

    RtlInitUnicodeString(   &unicodeString,
                            L"\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter");
    status = HalpOpenRegistryKey(&mf, NULL, &unicodeString, MAXIMUM_ALLOWED, FALSE);
    if (NT_SUCCESS(status))
    {
        index = 0;
        done = FALSE;
        error = FALSE;
        while (!done && !error)
        {
            error = TRUE;
            status = ZwEnumerateKey(    mf,
                                                    index++,
                                                    KeyBasicInformation,
                                                    keyInfo,
                                                    length,
                                                    &temp);
            if (NT_SUCCESS(status))
            {
                keyInfo->Name[keyInfo->NameLength / sizeof(WCHAR)] = UNICODE_NULL;
                RtlInitUnicodeString(&unicodeString, keyInfo->Name);
                status = HalpOpenRegistryKey(   &child,
                                                mf,
                                                &unicodeString,
                                                MAXIMUM_ALLOWED,
                                                FALSE);
                if (NT_SUCCESS(status))
                {
                    //
                    // Read the "identifier".
                    //

                    RtlInitUnicodeString(&unicodeString, L"Identifier");
                    status = ZwQueryValueKey(   child,
                                                        &unicodeString,
                                                        KeyValueFullInformation,
                                                        childInfo,
                                                        length,
                                                        &temp);
                    if (NT_SUCCESS(status))
                    {
                        error = FALSE;
                        if ((8 * sizeof(WCHAR) + sizeof(UNICODE_NULL)) == childInfo->DataLength)
                        {
                            done = RtlEqualMemory( (PCHAR)childInfo + childInfo->DataOffset,
                                                    L"PCI BIOS",
                                                    childInfo->DataLength);
                        }
                    }
                    else
                    {
                        HalPrint(("Failed to query value!"));
                    }
                }
                else
                {
                        HalPrint(("Could not open child key!"));
                }
            }
            else
            {
                HalPrint(("Failed to enumerate keys!"));
            }

            //
            // Close the child key if it was successfully opened.
            //

            if (child)
            {
                ZwClose(child);
                child = NULL;
            }
        }

        //
        // Close the MF adapter key.
        //

        ZwClose(mf);

        if (done && !error)
        {
            unicodeString.Length = 0;
            unicodeString.MaximumLength = (USHORT)(256 * sizeof(WCHAR) + keyInfo->NameLength);
            unicodeString.Buffer = ExAllocatePoolWithTag(   PagedPool,
                                                            unicodeString.MaximumLength,
                                                            HAL_POOL_TAG);
            if (unicodeString.Buffer)
            {
                RtlAppendUnicodeToString(   &unicodeString,
                                            L"\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultiFunctionAdapter\\");
                RtlAppendUnicodeToString(&unicodeString, keyInfo->Name);
                RtlAppendUnicodeToString(&unicodeString, L"\\RealModeIrqRoutingTable\\0");
                table = HalpGetRegistryTable(unicodeString.Buffer, L"Configuration Data", sizeof(CM_FULL_RESOURCE_DESCRIPTOR));
                if (table == NULL)
                {
                                HalPrint(("Could not read table from PCIBIOS using real-mode interface!"));
                }
                ExFreePool(unicodeString.Buffer);
            }
            else
            {
                HalPrint(("Could not allocate memory to read routing table from PCIBIOS real-mode interface!"));
            }
        }

                ExFreePool(keyInfo);
                ExFreePool(childInfo);
    }

    return (table);
}

PPCI_IRQ_ROUTING_TABLE
HalpCopy$PIRTable (
    IN PUCHAR   BiosPtr,
    IN PUCHAR   BiosEnd
    )

/*++

Routine Description:

    Allocates memory and copies the $PIR table if found at the specified
address.

Input Parameters:

    BiosPtr is the location that possibly contains the $PIR table.
    BiosEnd is the last possible BIOS ROM address.

Return Value:

    Pointer to the Pci Irq Routing Table if successful.
    NULL if there is no valid table at the specified address.

--*/

{
    PPCI_IRQ_ROUTING_TABLE  table = (PPCI_IRQ_ROUTING_TABLE)BiosPtr;
    PVOID                   buffer = NULL;

    PAGED_CODE();

    //
    // Validate this table.
    //

    if (    (table->Signature == PIRT_SIGNATURE) &&
            (BiosPtr + table->TableSize <= BiosEnd) &&
            (table->Signature == PIRT_SIGNATURE) &&
            (table->TableSize > 0) )
    {
        //
        // Allocate memory for the table.
        //

        buffer = ExAllocatePoolWithTag( PagedPool,
                                        table->TableSize,
                                        HAL_POOL_TAG);
         if (buffer != NULL)
        {
            //
            // Copy the table from the ROM into the allocated memory.
            //

            memcpy(buffer, table, table->TableSize);
            if (!HalpSanityCheckTable(buffer, FALSE))
            {
                ExFreePool(buffer);
                buffer = NULL;
            }

        }
        else
        {
            HalPrint(("Failed to allocate memory for $PIR Pci Irq Routing Table!"));
            ASSERT(buffer);
        }
    }

    return (buffer);
}

BOOLEAN
HalpSanityCheckTable (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable,
    IN BOOLEAN IgnoreChecksum
    )

/*++

Routine Description:

    Validate the Pci Irq Routing Table.

Input Parameters:

    PciIrqRoutingTable - Pointer to the Pci Irq Routing Table.

Return Value:

    TRUE if this is a valid table, else FALSE.

--*/

{
    CHAR        checkSum;
    PUCHAR      tablePtr;
    PUCHAR      tableEnd;
    PSLOT_INFO  slotInfo;
    PSLOT_INFO  lastSlot;
    PPIN_INFO   pinInfo;
    PPIN_INFO   lastPin;
    BOOLEAN     hasNonZeroBusEntries = FALSE;
    BOOLEAN     valid = TRUE;

    PAGED_CODE();

    //
    // Test1: Should have a valid signature.
    //

    if (PciIrqRoutingTable->Signature != PIRT_SIGNATURE)
    {
        HalPrint(("Pci Irq Routing Table has invalid signature %08X!", PciIrqRoutingTable->Signature));
        valid = FALSE;
    }

    //
    // Test2 - Should have a valid version.
    //

    else if (PciIrqRoutingTable->Version != PIRT_VERSION)
    {
        HalPrint(("Pci Irq Routing Table has invalid version %04X!", PciIrqRoutingTable->Version));
        valid = FALSE;
    }

    //
    // Test3 - Should have a valid size.
    //

    else if (   PciIrqRoutingTable->TableSize % 16 != 0 ||
                PciIrqRoutingTable->TableSize <= sizeof (PCI_IRQ_ROUTING_TABLE))
    {
        HalPrint(("Pci Irq Routing Table has invalid size %04X!", PciIrqRoutingTable->TableSize));
        valid = FALSE;
    }
    else if (!IgnoreChecksum)
    {
        //
        // Test4 - Should have a valid checksum.
        //

        checkSum = 0;
        tablePtr = (PUCHAR)PciIrqRoutingTable;

        for (   tableEnd = tablePtr + PciIrqRoutingTable->TableSize;
                tablePtr < tableEnd;
                tablePtr++)
        {
            checkSum += *tablePtr;
        }

        if (checkSum != 0)
        {
            HalPrint(("Pci Irq Routing Table checksum is invalid!"));
            valid = FALSE;
        }
    }

    if(valid)
    {
        PSLOT_INFO  testSlot;
        ULONG       pin;

        //
        // First get rid of sutpid entries.
        //

        slotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
        lastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);

        while (slotInfo < lastSlot && valid)
        {
            //
            // Process all pins.
            //

            pinInfo = &slotInfo->PinInfo[0];
            lastPin = &slotInfo->PinInfo[NUM_IRQ_PINS];

            while (pinInfo < lastPin)
            {
                //
                // Check for bad cases.
                //

                if(pinInfo->Link)
                {
                    if (    pinInfo->InterruptMap == 0x0000 ||
                            pinInfo->InterruptMap == 0x0001)
                    {
                        HalPrint(("Removing stupid maps (%04X) from IRQ routing table entry (b=%02X, d=%02X, s=%02X)!", pinInfo->InterruptMap, slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                        pinInfo->InterruptMap = 0;
                        pinInfo->Link = 0;
                    }
                }

                //
                // Next pin.
                //

                pinInfo++;
            }

            //
            // Remove this entry if all pins have NULL links.
            //

            if (    slotInfo->PinInfo[0].Link == 0 &&
                    slotInfo->PinInfo[1].Link == 0 &&
                    slotInfo->PinInfo[2].Link == 0 &&
                    slotInfo->PinInfo[3].Link == 0)
            {
                HalPrint(("Removed redundant entry (b=%02X, d=%02X, s=%02X) from IRQ routing table!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                *slotInfo = *(--lastSlot);
                PciIrqRoutingTable->TableSize -= sizeof(SLOT_INFO);

                //
                // Need to test the newly copied entry.
                //

                continue;
            }

            //
            // Merge entries for MF devices.
            //

            testSlot = slotInfo + 1;
            while (testSlot < lastSlot)
            {
                if (    (testSlot->DeviceNumber & 0xF8) == (slotInfo->DeviceNumber & 0xF8) &&
                        testSlot->BusNumber == slotInfo->BusNumber)
                {
                    //
                    // Process all pins.
                    //
                    for (pin = 0; pin < NUM_IRQ_PINS; pin++)
                    {
                        if (testSlot->PinInfo[pin].Link)
                        {
                            if (slotInfo->PinInfo[pin].Link)
                            {
                                HalPrint(("Multiple entries for the same device (b=%02X, d=%02X, s=%02X) and link (%04X) in IRQ routing table!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber, slotInfo->PinInfo[pin].Link));
                                valid = FALSE;
                                break;
                            }
                            else
                            {
                                HalPrint(("Merging multiple entries for same device (b=%02X, d=%02X, s=%02X) in IRQ routing table!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                                slotInfo->PinInfo[pin] = testSlot->PinInfo[pin];
                            }
                        }
                    }
                    if (!valid)
                    {
                        break;
                    }
                    *testSlot = *(--lastSlot);
                    PciIrqRoutingTable->TableSize -= sizeof(SLOT_INFO);

                    //
                    // Need to test the newly copied entry.
                    //

                    continue;
                }
                testSlot++;
            }

            if (slotInfo->BusNumber > 0)
            {
                hasNonZeroBusEntries = TRUE;
            }

            //
            // Next slot.
            //

            slotInfo++;
        }

        if (valid && PciIrqRoutingTable->TableSize == sizeof(PCI_IRQ_ROUTING_TABLE))
        {
            HalPrint(("No IRQ routing table left after sanity checking!"));
            valid = FALSE;
        }
    }

    //
    // Make sure there are entries for all bus 0 devices in the table.
    //

    if (valid)
    {
        PBUS_HANDLER        busHandler;
        PCI_SLOT_NUMBER     slotNumber;
        ULONG               device;
        ULONG               function;
        UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
        PPCI_COMMON_CONFIG  pciData = (PPCI_COMMON_CONFIG)&buffer[0];


        busHandler = HalpHandlerForBus(PCIBus, 0);
        if (busHandler)
        {
            slotNumber.u.AsULONG = 0;
            for (   device = 0;
                    device < PCI_MAX_DEVICES && valid;
                    device++)
            {
                slotNumber.u.bits.DeviceNumber = device;

                for (function = 0; function < PCI_MAX_FUNCTION && valid; function++)
                {
                    slotNumber.u.bits.FunctionNumber = function;

                    //
                    // Read the standard config space.
                    //

                    HalpReadPCIConfig(busHandler, slotNumber, pciData, 0, PCI_COMMON_HDR_LENGTH);

                    //
                    // Make sure this is a valid device.
                    //

                    if (pciData->VendorID != 0xFFFF && pciData->DeviceID != 0xFFFF)
                    {

                        //
                        // Ignore IDE devices.
                        //

                        if (    (pciData->BaseClass != PCI_CLASS_MASS_STORAGE_CTLR && pciData->SubClass != PCI_SUBCLASS_MSC_IDE_CTLR) ||
                                (pciData->ProgIf & 0x05))
                        {
                            //
                            // Handle P-P bridges separately.
                            //

                            if (    ((pciData->HeaderType & 0x7F) == PCI_BRIDGE_TYPE) &&
                                    pciData->BaseClass == PCI_CLASS_BRIDGE_DEV && pciData->SubClass == PCI_SUBCLASS_BR_PCI_TO_PCI)
                            {
                                //
                                // P-P bridge.
                                //

                                if (!hasNonZeroBusEntries)
                                {
                                    //
                                    // Must have the bridge with at least one entry.
                                    //

                                    slotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
                                    lastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);
                                    valid = FALSE;
                                    while (slotInfo < lastSlot && !valid)
                                    {
                                        if ((slotInfo->DeviceNumber>>3) == (UCHAR)device)
                                        {
                                            //
                                            // Process all pins.
                                            //

                                            pinInfo = &slotInfo->PinInfo[0];
                                            lastPin = &slotInfo->PinInfo[NUM_IRQ_PINS];

                                            while (pinInfo < lastPin)
                                            {
                                                if(pinInfo->Link)
                                                {
                                                    valid = TRUE;
                                                    break;
                                                }
                                                pinInfo++;
                                            }
                                        }
                                        slotInfo++;
                                    }
                                    if (!valid)
                                    {
                                        HalPrint(("All links missing for bridge (b=%02X, d=%02X, s=%02X)!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                                    }
                                }
                            }
                            else
                            {
                                UCHAR   intLine;
                                UCHAR   intPin;

                                //
                                // Normal device.
                                //

                                if ((pciData->HeaderType & 0x7F) == PCI_CARDBUS_BRIDGE_TYPE)
                                {
                                    intPin = pciData->u.type2.InterruptPin;
                                    intLine = pciData->u.type2.InterruptLine;
                                }
                                else
                                {
                                    intPin = pciData->u.type0.InterruptPin;
                                    intLine = pciData->u.type0.InterruptLine;
                                }

                                if (intPin && intPin <= NUM_IRQ_PINS)
                                {
                                    if (    !(pciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) ||
                                            (intLine && intLine <= 0x0F))
                                    {
                                        intPin--;
                                        slotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
                                        lastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);
                                        valid = FALSE;
                                        while (slotInfo < lastSlot)
                                        {
                                            if (    (slotInfo->DeviceNumber>>3) == (UCHAR)device &&
                                                    slotInfo->PinInfo[intPin].Link)
                                            {
                                                valid = TRUE;
                                                break;
                                            }
                                            slotInfo++;
                                        }
                                        if (!valid)
                                        {
                                            HalPrint(("Missing entry for device (b=%02X, d=%02X, s=%02X) in the IRQ routing table!", slotInfo->BusNumber, slotInfo->DeviceNumber>>3, slotInfo->SlotNumber));
                                        }
                                    }
                                }
                            }
                        }
                    }

                    //
                    // Dont waste time if this is not a multifunction device or
                    // device does not exist.
                    //

                    if (    (function == 0 && !(pciData->HeaderType & PCI_MULTIFUNCTION)) ||
                            pciData->HeaderType == 0xFF)
                    {
                        break;
                    }
                }
            }
        }
    }


    if (!valid) {
        HalPrint (("Failing IRQ routing table. IRQ routing will be disabled"));
    }

    return (valid);
}

NTSTATUS
HalpFindLinkNode (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Bus,
    IN ULONG Slot,
    OUT PLINK_NODE *LinkNode
    )
{
    PINT_ROUTE_INTERFACE_STANDARD   pciInterface;
    NTSTATUS        status;
    ULONG           dummy;
    UCHAR           classCode;
    UCHAR           subClassCode;
    ROUTING_TOKEN   routingToken;
    PSLOT_INFO      slotInfo;
    PLINK_NODE      linkNode;
    UCHAR           pin;

    PAGED_CODE();

    ASSERT(IsPciIrqRoutingEnabled());

    *LinkNode = NULL;
    pciInterface = PciIrqRoutingInfo->PciInterface;

    //
    // Call Pci driver to get info about the Pdo.
    //

    status = pciInterface->GetInterruptRouting( Pdo,
                                                &Bus,
                                                &Slot,
                                                (PUCHAR)&dummy,
                                                &pin,
                                                &classCode,
                                                &subClassCode,
                                                (PDEVICE_OBJECT *)&dummy,
                                                &routingToken,
                                                (PUCHAR)&dummy);

    //
    // This means that it is not a Pci device.
    //

    if (!NT_SUCCESS(status))
    {
        return (STATUS_NOT_FOUND);
    }

    //
    // Pci Ide Irqs behave differently than other Pci devices.
    //

    if (    classCode == PCI_CLASS_MASS_STORAGE_CTLR &&
            subClassCode == PCI_SUBCLASS_MSC_IDE_CTLR)
    {
        PBUS_HANDLER        busHandler;
        PCI_SLOT_NUMBER     slot;
        UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
        PPCI_COMMON_CONFIG  pciData = (PPCI_COMMON_CONFIG)&buffer[0];
        BOOLEAN             nativeMode = FALSE;

        //
        // Check for native mode IDE controller.
        //

        busHandler = HalpHandlerForBus(PCIBus, Bus);
        if (busHandler)
        {
            slot.u.AsULONG = Slot;
            HalpReadPCIConfig(busHandler, slot, pciData, 0, PCI_COMMON_HDR_LENGTH);
            if (    pciData->VendorID != 0xFFFF &&
                    pciData->DeviceID != 0xFFFF &&
                    pciData->BaseClass == classCode &&
                    pciData->SubClass == subClassCode)
            {
                //
                // Check if either channel is in native mode?
                //

                if (pciData->ProgIf & 0x05)
                {
                    nativeMode = TRUE;
                }
            }
        }

        if (!nativeMode)
        {
            return (STATUS_RESOURCE_REQUIREMENTS_CHANGED);
        }
    }

    //
    // Have we cached this before?
    //

    if (routingToken.LinkNode != NULL)
    {
        ASSERT(((PLINK_NODE)routingToken.LinkNode)->Signature == PCI_LINK_SIGNATURE);

        *LinkNode = (PLINK_NODE)routingToken.LinkNode;

        return (STATUS_SUCCESS);
    }

    //
    // Get the slot info for this device.
    //

    slotInfo = HalpBarberPole(  PciIrqRoutingInfo,
                                Pdo,
                                Bus,
                                Slot,
                                &pin);
    if (slotInfo != NULL)
    {
        ASSERT(pin <4);

        for (   linkNode = PciIrqRoutingInfo->LinkNodeHead;
                linkNode && linkNode->Link != slotInfo->PinInfo[pin].Link;
                linkNode = linkNode->Next);

        if (linkNode != NULL)
        {
            *LinkNode = linkNode;

            //
            // Initialize the routing token.
            //

            routingToken.LinkNode = linkNode;
            routingToken.StaticVector = 0;
            routingToken.Flags = 0;

            //
            // Save the routing token.
            //

            status = pciInterface->SetInterruptRoutingToken(    Pdo,
                                                                &routingToken);
            if (!NT_SUCCESS(status))
            {
                HalPrint(("Failed to set Pci routing token!"));
                ASSERT(NT_SUCCESS(status));
            }
        }
    }

    return (STATUS_SUCCESS);
}

PSLOT_INFO
HalpBarberPole (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Bus,
    IN ULONG Slot,
    IN OUT PUCHAR Pin
    )

/*++

    Routine Description:

        This routine implements the "barber pole" algorithm to determine the interrupt
        pin for Pci devices behind bridges.

    Input Parameters:

        PciIrqRouting - Pci Irq Routing information.

        Pdo - Pci device object for which we barber pole.

        Pin - Interrupt pin for the Pci device entry in the routing table we reached.

    Return Value:

        Slot info for the specified device iff successful.

--*/

{
    ULONG                           dummy;
    UCHAR                           pin;
    PDEVICE_OBJECT                  parent;
    ROUTING_TOKEN                   routingToken;
    BOOLEAN                         success;
    PSLOT_INFO                      slotInfo;
    NTSTATUS                        status;
    PINT_ROUTE_INTERFACE_STANDARD   pciInterface;

    PAGED_CODE();

    ASSERT(IsPciIrqRoutingEnabled());

    pciInterface = PciIrqRoutingInfo->PciInterface;

    //
    // This device MUST be a PCI device with a valid interrupt pin.
    //

    status = pciInterface->GetInterruptRouting( Pdo,
                                                &Bus,
                                                &Slot,
                                                (PUCHAR)&dummy,
                                                &pin,
                                                (PUCHAR)&dummy,
                                                (PUCHAR)&dummy,
                                                &parent,
                                                &routingToken,
                                                (PUCHAR)&dummy);
    if (!NT_SUCCESS(status) || pin == 0)
    {
        return (NULL);
    }

    //
    // Normalize the pin.
    //

    pin--;
    success = TRUE;
    while (success)
    {
        slotInfo = HalpGetSlotInfo( PciIrqRoutingInfo->PciIrqRoutingTable,
                                    (UCHAR)Bus,
                                    (UCHAR)(Slot & 0x1F));

        if (slotInfo != NULL)
        {
            break;
        }

        //
        // Get barber pole info for the parent.
        //

        success = HalpBarberPolePin(    PciIrqRoutingInfo,
                                        parent,
                                        Bus,
                                        Slot & 0x1F,
                                        &pin);

        Bus = (ULONG)-1;
        Slot = (ULONG)-1;

        //
        // Get parent's info.
        //

        status = pciInterface->GetInterruptRouting( parent,
                                                    &Bus,
                                                    &Slot,
                                                    (PUCHAR)&dummy,
                                                    (PUCHAR)&dummy,
                                                    (PUCHAR)&dummy,
                                                    (PUCHAR)&dummy,
                                                    &parent,
                                                    &routingToken,
                                                    (PUCHAR)&dummy);
        if (!NT_SUCCESS(status))
        {
            success = FALSE;
            break;
        }
    }

    //
    // Return unsuccessfully if we encountered any weird error.
    //

    if (success == FALSE)
        slotInfo = NULL;

    if (slotInfo)
    {
        *Pin = pin;
    }

    return (slotInfo);
}

BOOLEAN
HalpBarberPolePin (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Parent,
    IN ULONG Bus,
    IN ULONG Device,
    IN OUT PUCHAR Pin
    )

/*++

    Routine Description:

        This routine returns the info used for barber poling.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing information.

        Parent - Parent device object as we barber pole.

        Bus - Child device objects bus number.

        Device - Device number for the child device.

        Pin - Child device objects interrupt pin number (normalized) on entry.

    Return Value:

        TRUE iff successful.

--*/

{
    ULONG                           parentBus;
    ULONG                           parentSlot;
    ULONG                           dummy;
    UCHAR                           parentPin;
    UCHAR                           classCode;
    UCHAR                           subClassCode;
    ROUTING_TOKEN                   routingToken;
    NTSTATUS                        status;
    PINT_ROUTE_INTERFACE_STANDARD   pciInterface;

    PAGED_CODE();

    ASSERT(IsPciIrqRoutingEnabled());

    pciInterface = PciIrqRoutingInfo->PciInterface;

    //
    // Read the registry flags and see if this device supports straight
    // through routing.
    //

    //
    // Check if the pin table is present in the registry.
    //

    parentBus = (ULONG)-1;
    parentSlot = (ULONG)-1;

    //
    // Get info about the parent from Pci.
    //

    status = pciInterface->GetInterruptRouting( Parent,
                                                &parentBus,
                                                &parentSlot,
                                                (PUCHAR)&dummy,
                                                &parentPin,
                                                &classCode,
                                                &subClassCode,
                                                (PDEVICE_OBJECT *)&dummy,
                                                &routingToken,
                                                (PUCHAR)&dummy);
    if (NT_SUCCESS(status) && classCode == PCI_CLASS_BRIDGE_DEV)
    {
        switch (subClassCode)
        {
            case PCI_SUBCLASS_BR_PCI_TO_PCI:

                *Pin = (*Pin + (UCHAR)Device) % 4;
                break;

            case PCI_SUBCLASS_BR_CARDBUS:

                *Pin = parentPin - 1;
                break;

            default:

                HalPrint(("Pci device (bus=%02lx, slot=%02lx) does not have a PCI bridge as its parent!", Bus, Device));
                ASSERT(FALSE);
                return (FALSE);
        }
    }

    return (TRUE);
}

PSLOT_INFO
HalpGetSlotInfo (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable,
    IN UCHAR   Bus,
    IN UCHAR   Device
    )

/*++

    Routine Description:

        This routine searches the Pci Irq Routing Table for an entry for the specified
        Pci device on the given bus number.

    Input Parameters:

        PciIrqRoutingInfo - Pci Irq Routing information.

        Bus - Bus number of the Pci device.

        Device - Device number of the Pci device.

    Return Value:

        Pointer to the slot info for the specified device iff successful.

--*/
{
    PSLOT_INFO              slotInfo;
    PSLOT_INFO              lastSlot;

    PAGED_CODE();

    ASSERT(IsPciIrqRoutingEnabled());

    //
    // Process all slots in this table.
    //

    slotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable +
                                        sizeof(PCI_IRQ_ROUTING_TABLE));
    lastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable +
                                        PciIrqRoutingTable->TableSize);

    while (slotInfo < lastSlot)
    {
        if (    slotInfo->BusNumber == Bus &&
                (slotInfo->DeviceNumber >> 3) == Device)
        {
            return (slotInfo);
        }
        slotInfo++;
    }

    return (NULL);
}

NTSTATUS
HalpReadRegistryValue (
    IN HANDLE  Root,
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    OUT PULONG  Data
    )

/*++

Routine Description:

    Reads the value for the valuename under the key specified.

Input Parameters:

    Root is the handle of the root if any.
    KeyName is the name of the key under which this value appears.
    ValueName is the name of the value to be read.
    Data is the variable that receives the value read.

Return Value:

    Standard NT status value.

--*/

{
    UNICODE_STRING      valueName;
    HANDLE              hKey;
    NTSTATUS            status;
    UCHAR               buffer[sizeof(KEY_VALUE_FULL_INFORMATION) + MAXIMUM_VALUE_NAME_LENGTH + sizeof(ULONG)];
    ULONG               cbData;
    UNICODE_STRING      keyName;

    PAGED_CODE();

    RtlInitUnicodeString( &keyName, KeyName);

    status = HalpOpenRegistryKey(&hKey, Root, &keyName, KEY_READ, FALSE);
    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&valueName, ValueName);
        status = ZwQueryValueKey(   hKey,
                                    &valueName,
                                    KeyValueFullInformation,
                                    &buffer[0],
                                    sizeof(buffer),
                                    &cbData);

        if (NT_SUCCESS(status))
        {
            *Data = *(PULONG)((PUCHAR)&buffer[0] + ((PKEY_VALUE_FULL_INFORMATION)&buffer[0])->DataOffset);
        }

        ZwClose(hKey);
    }

    return (status);
}

NTSTATUS
HalpWriteRegistryValue (
    IN HANDLE  Root,
    IN const WCHAR*  KeyName,
    IN const WCHAR*  ValueName,
    IN ULONG   Value
    )

/*++

Routine Description:

    Writes the value for the valuename under the key specified.

Input Parameters:

    Root is the handle of the root if any.
    KeyName is the name of the key under which this value appears.
    ValueName is the name of the value to be written.
    Value is the value to be written.

Return Value:

    Standard NT status value.

--*/

{
    NTSTATUS        status;
    UNICODE_STRING  valueName;
    HANDLE          hKey;
    UNICODE_STRING  keyName;

    PAGED_CODE();

    RtlInitUnicodeString(&keyName, KeyName);

    status = HalpOpenRegistryKey(&hKey, Root, &keyName, KEY_ALL_ACCESS, FALSE);
    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&valueName, ValueName);
        status = ZwSetValueKey( hKey,
                                &valueName,
                                0,
                                REG_DWORD,
                                &Value,
                                sizeof(Value));
        ZwClose(hKey);
    }

    return (status);
}

NTSTATUS
HalpCommitLink (
    IN PLINK_NODE LinkNode
    )
{
    NTSTATUS status;
    ULONG interrupt;
    PLINK_STATE temp;

    //
    // Read the current state of this link.
    //

    interrupt = 0;
    status = PciirqmpGetIrq((PUCHAR)&interrupt, (UCHAR)LinkNode->Link);
    if (LinkNode->PossibleAllocation->RefCount)
    {
        //
        // Program the link.
        //

        if (NT_SUCCESS(status) && interrupt != LinkNode->PossibleAllocation->Interrupt)
        {
            PciirqmpSetIrq((UCHAR)LinkNode->PossibleAllocation->Interrupt, (UCHAR)LinkNode->Link);
        }
    }
    else if (LinkNode->Allocation->RefCount)
    {
        //
        // Disable the link.
        //

        if (NT_SUCCESS(status) && interrupt)
        {
            PciirqmpSetIrq((UCHAR)0, (UCHAR)LinkNode->Link);
        }
    }
#if defined(NEC_98)
    else if (!(LinkNode->PossibleAllocation->Interrupt))
    {
        //
        // Disable the link.
        //

        PciirqmpSetIrq((UCHAR)0, (UCHAR)LinkNode->Link);
    }
#endif

    //
    // Swap the possible with the allocation.
    //

    temp = LinkNode->Allocation;
    LinkNode->Allocation = LinkNode->PossibleAllocation;
    LinkNode->PossibleAllocation = temp;

    return (STATUS_SUCCESS);
}

VOID
HalpProgramInterruptLine (
    IN PPCI_IRQ_ROUTING_INFO PciIrqRoutingInfo,
    IN PDEVICE_OBJECT Pdo,
    IN ULONG Interrupt
    )
{
    PAGED_CODE();

    //
    // We should never be here if Pci Irq routing is not enabled.
    //

    ASSERT(IsPciIrqRoutingEnabled());

    PciIrqRoutingInfo->PciInterface->UpdateInterruptLine(Pdo, (UCHAR)Interrupt);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixpcisup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpcisup.c

Abstract:

    Support functions for doing PCI the bus-handler
    way.

Author:

    Ken Reneris (kenr) 14-June-1994

Environment:

    Kernel mode

Revision History:

    Moved code into this file so that it would be
    easier to build a non-bus-handler HAL.  This
    file will only be compiled into HALs that
    use bus handlers.  -- Jake Oshins 2-Dec-1997

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "chiphacks.h"

BOOLEAN
HalpIsIdeDevice(
    IN PPCI_COMMON_CONFIG PciData
    );

VOID
HalpGetNMICrashFlag (
    VOID
    );

extern BOOLEAN HalpDisableHibernate;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitializePciBus)
#pragma alloc_text(INIT,HalpIsIdeDevice)
#pragma alloc_text(INIT,HalpAllocateAndInitPciBusHandler)
#endif

VOID
HalpInitializePciBus (
    VOID
    )
{
    PPCI_REGISTRY_INFO_INTERNAL  PCIRegInfo;
    ULONG                        i, d, HwType, BusNo, f;
    PBUS_HANDLER                 BusHandler;
    PCI_SLOT_NUMBER              SlotNumber;
    PPCI_COMMON_CONFIG           PciData;
    UCHAR                        iBuffer[PCI_COMMON_HDR_LENGTH + sizeof(TYPE2EXTRAS)];
    ULONG                        OPBNumber;
    BOOLEAN                      OPBA2B0Found, COPBInbPostingEnabled;
    UCHAR                        buffer [4];
    BOOLEAN                      fullDecodeChipset = FALSE;
    NTSTATUS                     Status;
    ULONG                        flags;

    PCIRegInfo = HalpQueryPciRegistryInfo();

    if (!PCIRegInfo) {
        return;
    }

    //
    // Initialize spinlock for synchronizing access to PCI space
    //

    KeInitializeSpinLock (&HalpPCIConfigLock);
    PciData = (PPCI_COMMON_CONFIG) iBuffer;

    //
    // PCIRegInfo describes the system's PCI support as indicated by the BIOS.
    //

    HwType = PCIRegInfo->HardwareMechanism & 0xf;

    //
    // Some AMI bioses claim machines are Type2 configuration when they
    // are really type1.   If this is a Type2 with at least one bus,
    // try to verify it's not really a type1 bus
    //

    if (PCIRegInfo->NoBuses  &&  HwType == 2) {

        //
        // Check each slot for a valid device.  Which every style configuration
        // space shows a valid device first will be used
        //

        SlotNumber.u.bits.Reserved = 0;
        SlotNumber.u.bits.FunctionNumber = 0;

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            SlotNumber.u.bits.DeviceNumber = d;

            //
            // First try what the BIOS claims - type 2.  Allocate type2
            // test handle for PCI bus 0.
            //

            HwType = 2;
            BusHandler = HalpAllocateAndInitPciBusHandler (HwType, 0, TRUE);

            if (HalpIsValidPCIDevice (BusHandler, SlotNumber)) {
                break;
            }

            //
            // Valid device not found on Type2 access for this slot.
            // Reallocate the bus handler are Type1 and take a look.
            //

            HwType = 1;
            BusHandler = HalpAllocateAndInitPciBusHandler (HwType, 0, TRUE);

            if (HalpIsValidPCIDevice (BusHandler, SlotNumber)) {
                break;
            }

            HwType = 2;
        }

        //
        // Reset handler for PCI bus 0 to whatever style config space
        // was finally decided.
        //

        HalpAllocateAndInitPciBusHandler (HwType, 0, FALSE);
    }


    //
    // For each PCI bus present, allocate a handler structure and
    // fill in the dispatch functions
    //

    do {
        for (i=0; i < PCIRegInfo->NoBuses; i++) {

            //
            // If handler not already built, do it now
            //

            if (!HalpHandlerForBus (PCIBus, i)) {
                HalpAllocateAndInitPciBusHandler (HwType, i, FALSE);
            }
        }

        //
        // Bus handlers for all PCI buses have been allocated, go collect
        // pci bridge information.
        //

    } while (HalpGetPciBridgeConfig (HwType, &PCIRegInfo->NoBuses)) ;

    //
    // Fixup SUPPORTED_RANGES
    //

    HalpFixupPciSupportedRanges (PCIRegInfo->NoBuses);


    //
    // Look for PCI controllers which have known work-arounds, and make
    // sure they are applied.
    //
    // In addition, fill in the bitmask HalpPciIrqMask with all the
    // interrupts that PCI devices might use.
    //

    OPBNumber = 0;
    OPBA2B0Found = FALSE;
    COPBInbPostingEnabled = FALSE;

    SlotNumber.u.bits.Reserved = 0;
    for (BusNo=0; BusNo < PCIRegInfo->NoBuses; BusNo++) {
        BusHandler = HalpHandlerForBus (PCIBus, BusNo);

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            SlotNumber.u.bits.DeviceNumber = d;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                SlotNumber.u.bits.FunctionNumber = f;

                //
                // Read PCI configuration information
                //

                HalpReadPCIConfig (BusHandler, SlotNumber, PciData, 0, PCI_COMMON_HDR_LENGTH);

                if (*((PULONG)(PciData)) == 0xffffffff) {
                    continue;
                }

                if (PCI_CONFIGURATION_TYPE(PciData) == PCI_CARDBUS_BRIDGE_TYPE) {

                    HalpReadPCIConfig(
                        BusHandler,
                        SlotNumber,
                        PciData+1,
                        FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceSpecific),
                        sizeof(TYPE2EXTRAS)
                        );
                }

#ifndef SUBCLASSPCI
                //
                // Look at interrupt line register and fill in HalpPciIrqMask,
                // but not for an IDE controller, as IDE controllers really
                // trigger interrupts like ISA devices.
                //
                if (PCI_CONFIGURATION_TYPE(PciData) != 1) {
                    if ((PciData->u.type0.InterruptPin != 0) &&
                        (PciData->u.type0.InterruptLine != 0) &&
                        (PciData->u.type0.InterruptLine < PIC_VECTORS) &&
                        !HalpIsIdeDevice(PciData)) {

                        HalpPciIrqMask |= 1 << PciData->u.type0.InterruptLine;
                    }
                }
#endif
                //
                // Check for chips with known work-arounds to apply
                //

                if (PciData->VendorID == 0x8086  &&
                    PciData->DeviceID == 0x04A3  &&
                    PciData->RevisionID < 0x11) {

                    //
                    // 82430 PCMC controller
                    //

                    HalpReadPCIConfig (BusHandler, SlotNumber, buffer, 0x53, 2);

                    buffer[0] &= ~0x08;     // turn off bit 3 register 0x53

                    if (PciData->RevisionID == 0x10) {  // on rev 0x10, also turn
                        buffer[1] &= ~0x01;             // bit 0 register 0x54
                    }

                    HalpWritePCIConfig (BusHandler, SlotNumber, buffer, 0x53, 2);
                }

                if (PciData->VendorID == 0x8086  &&
                    PciData->DeviceID == 0x0484  &&
                    PciData->RevisionID <= 3) {

                    //
                    // 82378 ISA bridge & SIO
                    //

                    HalpReadPCIConfig (BusHandler, SlotNumber, buffer, 0x41, 1);

                    buffer[0] &= ~0x1;      // turn off bit 0 register 0x41

                    HalpWritePCIConfig (BusHandler, SlotNumber, buffer, 0x41, 1);
                }

                //
                // Look for Orion PCI Bridge
                //

                if (PciData->VendorID == 0x8086 &&
                    PciData->DeviceID == 0x84c4 ) {

                    //
                    // 82450 Orion PCI Bridge Workaround
                    // Need a workaround if following conditions are true:
                    // i) 2 OPBs present
                    // ii)There is an A2/B0 step OPB present.
                    // iii) Inbound posting on the compatibility OPB is
                    //      enabled.
                    // NOTE: Inbound Posting on the non-compatibility OPB
                    // MUST BE disabled by BIOS
                    //

                    OPBNumber += 1;

                    if (PciData->RevisionID <= 4) {
                        OPBA2B0Found = TRUE;
                    }

                    if (SlotNumber.u.bits.DeviceNumber == (0xc8>>3)) {

                        // Found compatibility OPB. Determine if the compatibility
                        // OPB has inbound posting enabled by testing bit 0 of reg 54

                        HalpReadPCIConfig (BusHandler, SlotNumber, buffer, 0x54, 2);
                        COPBInbPostingEnabled = (buffer[0] & 0x1) ? TRUE : FALSE;

                    } else {

                        // The compatibility OPB ALWAYS has a device
                        // number 0xc8. Save the ncOPB slot number
                        // and BusHandler

                        HalpOrionOPB.Slot = SlotNumber;
                        HalpOrionOPB.Handler = BusHandler;
                    }
                }

                //
                // Check the list for host bridges who's existance will mark a
                // chipset as 16bit decode. We use this to cover for BIOS
                // writers who list "fixed" PnPBIOS resources without noticing
                // that such a descriptor implies their device is 10bit decode.
                //

                if ((!fullDecodeChipset) &&
                    HalpIsRecognizedCard(PCIRegInfo, PciData,
                                         PCIFT_FULLDECODE_HOSTBRIDGE)) {

                    fullDecodeChipset = TRUE;
                }

                //
                // Look for ICH, or any other Intel or VIA UHCI USB controller.
                //

                if ((PciData->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
                    (PciData->SubClass == PCI_SUBCLASS_SB_USB) &&
                    (PciData->ProgIf == 0x00)) {
                    if (PciData->VendorID == 0x8086) {

                        HalpStopUhciInterrupt(BusNo,
                                              SlotNumber,
                                              TRUE);

                    } else if (PciData->VendorID == 0x1106) {

                        HalpStopUhciInterrupt(BusNo,
                                              SlotNumber,
                                              FALSE);

                    }
                }

                //
                // Look for an OHCI-compliant USB controller.
                //

                if ((PciData->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
                    (PciData->SubClass == PCI_SUBCLASS_SB_USB) &&
                    (PciData->ProgIf == 0x10)) {

                    HalpStopOhciInterrupt(BusNo,
                                          SlotNumber);
                }

                Status = HalpGetChipHacks(PciData->VendorID,
                                          PciData->DeviceID,
                                          0,
                                          &flags);

                if (NT_SUCCESS(Status)) {

                    if (flags & DISABLE_HIBERNATE_HACK_FLAG) {
                        HalpDisableHibernate = TRUE;
                    }

                    if (flags & WHACK_ICH_USB_SMI_HACK_FLAG) {
                        HalpWhackICHUsbSmi(BusNo, SlotNumber);
                    }
                }

            }   // next function
        }   // next device
    }   // next bus

    //
    // Is Orion B0 workaround needed?
    //

    if (OPBNumber >= 2 && OPBA2B0Found && COPBInbPostingEnabled) {

        //
        // Replace synchronization functions with Orion specific functions
        //

        ASSERT (PCIConfigHandler.Synchronize == HalpPCISynchronizeType1);
        MmLockPagableCodeSection (&HalpPCISynchronizeOrionB0);
        PCIConfigHandler.Synchronize = HalpPCISynchronizeOrionB0;
        PCIConfigHandler.ReleaseSynchronzation = HalpPCIReleaseSynchronzationOrionB0;
    }

    //
    // Check if we should crashdump on NMI.
    //

    HalpGetNMICrashFlag();

#if DBG
    HalpTestPci (0);
#endif

    //
    // Mark the chipset appropriately.
    //
    HalpMarkChipsetDecode(fullDecodeChipset);

    ExFreePool(PCIRegInfo);
}

PBUS_HANDLER
HalpAllocateAndInitPciBusHandler (
    IN ULONG        HwType,
    IN ULONG        BusNo,
    IN BOOLEAN      TestAllocation
    )
{
    PBUS_HANDLER    Bus;
    PPCIPBUSDATA    BusData;

    Bus = HalpAllocateBusHandler (
                PCIBus,                 // Interface type
                PCIConfiguration,       // Has this configuration space
                BusNo,                  // bus #
                Internal,               // child of this bus
                0,                      //      and number
                sizeof (PCIPBUSDATA)    // sizeof bus specific buffer
                );

    if (!Bus) {
        return NULL;
    }
    
    //
    // Fill in PCI handlers
    //

    Bus->GetBusData = (PGETSETBUSDATA) HalpGetPCIData;
    Bus->SetBusData = (PGETSETBUSDATA) HalpSetPCIData;
    Bus->GetInterruptVector  = (PGETINTERRUPTVECTOR) HalpGetPCIIntOnISABus;
    Bus->AdjustResourceList  = (PADJUSTRESOURCELIST) HalpAdjustPCIResourceList;
    Bus->AssignSlotResources = (PASSIGNSLOTRESOURCES) HalpAssignPCISlotResources;
    Bus->BusAddresses->Dma.Limit = 0;

    BusData = (PPCIPBUSDATA) Bus->BusData;

    //
    // Fill in common PCI data
    //

    BusData->CommonData.Tag         = PCI_DATA_TAG;
    BusData->CommonData.Version     = PCI_DATA_VERSION;
    BusData->CommonData.ReadConfig  = (PciReadWriteConfig) HalpReadPCIConfig;
    BusData->CommonData.WriteConfig = (PciReadWriteConfig) HalpWritePCIConfig;
    BusData->CommonData.Pin2Line    = (PciPin2Line) HalpPCIPin2ISALine;
    BusData->CommonData.Line2Pin    = (PciLine2Pin) HalpPCIISALine2Pin;

    //
    // Set defaults
    //

    BusData->MaxDevice   = PCI_MAX_DEVICES;
    BusData->GetIrqRange = (PciIrqRange) HalpGetISAFixedPCIIrq;

    RtlInitializeBitMap (&BusData->DeviceConfigured,
                BusData->ConfiguredBits, 256);

    switch (HwType) {
        case 1:
            //
            // Initialize access port information for Type1 handlers
            //

            RtlCopyMemory (&PCIConfigHandler,
                           &PCIConfigHandlerType1,
                           sizeof (PCIConfigHandler));

            BusData->Config.Type1.Address = PCI_TYPE1_ADDR_PORT;
            BusData->Config.Type1.Data    = PCI_TYPE1_DATA_PORT;
            break;

        case 2:
            //
            // Initialize access port information for Type2 handlers
            //

            RtlCopyMemory (&PCIConfigHandler,
                           &PCIConfigHandlerType2,
                           sizeof (PCIConfigHandler));

            BusData->Config.Type2.CSE     = PCI_TYPE2_CSE_PORT;
            BusData->Config.Type2.Forward = PCI_TYPE2_FORWARD_PORT;
            BusData->Config.Type2.Base    = PCI_TYPE2_ADDRESS_BASE;

            //
            // Early PCI machines didn't decode the last bit of
            // the device id.  Shrink type 2 support max device.
            //
            BusData->MaxDevice            = 0x10;

            break;

        default:
            // unsupport type
            DBGMSG ("HAL: Unkown PCI type\n");
    }

    if (!TestAllocation) {
#ifdef SUBCLASSPCI
        HalpSubclassPCISupport (Bus, HwType);
#endif
    }

    return Bus;
}

BOOLEAN
HalpIsIdeDevice(
    IN PPCI_COMMON_CONFIG PciData
    )
{
    if ((PciData->BaseClass == PCI_CLASS_MASS_STORAGE_CTLR) &&
        (PciData->SubClass == PCI_SUBCLASS_MSC_IDE_CTLR)) {

        return TRUE;
    }

    //
    // Now look for old, hard to recognize controllers.
    //

    if (PciData->VendorID == 0x1c1c) {   // Old Symphony controller
        return TRUE;
    }

    if ((PciData->VendorID == 0x10B9) &&
        ((PciData->DeviceID == 0x5215) ||
         (PciData->DeviceID == 0x5219))) {  // ALI controllers
        return TRUE;
    }

    if ((PciData->VendorID == 0x1097) &&
        (PciData->DeviceID == 0x0038)) {    // Appian controller
        return TRUE;
    }

    if ((PciData->VendorID == 0x0E11) &&
        (PciData->DeviceID == 0xAE33)) {    // Compaq controller
        return TRUE;
    }

    if ((PciData->VendorID == 0x1042) &&
        (PciData->DeviceID == 0x1000)) {    // PCTECH controller
        return TRUE;
    }

    if ((PciData->VendorID == 0x1039) &&
        ((PciData->DeviceID == 0x0601) ||
         (PciData->DeviceID == 0x5513))) {  // SIS controllers
        return TRUE;
    }

    if ((PciData->VendorID == 0x10AD) &&
        ((PciData->DeviceID == 0x0001) ||
         (PciData->DeviceID == 0x0150))) {  // Newer Symphony controllers
        return TRUE;
    }

    if ((PciData->VendorID == 0x1060) &&
        (PciData->DeviceID == 0x0101)) {    // United Microelectronics controller
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixpciint.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpciint.c

Abstract:

    All PCI bus interrupt mapping is in this module, so that a real
    system which doesn't have all the limitations which PC PCI
    systems have can replaced this code easly.
    (bus memory & i/o address mappings can also be fix here)

Author:

    Ken Reneris

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

#ifdef WANT_IRQ_ROUTING
#include "ixpciir.h"
#endif

ULONG   HalpEisaELCR;
BOOLEAN HalpDoingCrashDump;
BOOLEAN HalpPciLockSettings;


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetPCIIntOnISABus)
#pragma alloc_text(PAGE,HalpAdjustPCIResourceList)
#pragma alloc_text(PAGE,HalpGetISAFixedPCIIrq)
#endif


ULONG
HalpGetPCIIntOnISABus (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
{
    if (BusInterruptLevel < 1) {
        // bogus bus level
        return 0;
    }


    //
    // Current PCI buses just map their IRQs ontop of the ISA space,
    // so foreward this to the isa handler for the isa vector
    // (the isa vector was saved away at either HalSetBusData or
    // IoAssignReosurces time - if someone is trying to connect a
    // PCI interrupt without performing one of those operations first,
    // they are broken).
    //

    return HalGetInterruptVector (
#ifndef MCA
                Isa, 0,
#else
                MicroChannel, 0,
#endif
                BusInterruptLevel ^ IRQXOR,
                0,
                Irql,
                Affinity
            );
}


VOID
HalpPCIPin2ISALine (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    On the current PC implementations, the bios has already filled in
    InterruptLine as it's ISA value and there's no portable way to
    change it.

    On a DBG build we adjust InterruptLine just to ensure driver's
    don't connect to it without translating it on the PCI bus.

--*/
{
    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    //
    // On a PC there's no Slot/Pin/Line mapping which needs to
    // be done.
    //

    PciData->u.type0.InterruptLine ^= IRQXOR;
}



VOID
HalpPCIISALine2Pin (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++

    This functions maps the device's InterruptLine to it's
    device specific InterruptPin value.

    On the current PC implementations, this information is
    fixed by the BIOS.  Just make sure the value isn't being
    editted since PCI doesn't tell us how to dynically
    connect the interrupt.

--*/
{
    if (!PciNewData->u.type0.InterruptPin) {
        return ;
    }

    PciNewData->u.type0.InterruptLine ^= IRQXOR;

#if DBG
    if (PciNewData->u.type0.InterruptLine != PciOldData->u.type0.InterruptLine ||
        PciNewData->u.type0.InterruptPin  != PciOldData->u.type0.InterruptPin) {
        DbgPrint ("HalpPCILine2Pin: System does not support changing the PCI device interrupt routing\n");
        DbgBreakPoint ();
    }
#endif
}

#if !defined(SUBCLASSPCI)

VOID
HalpPCIAcquireType2Lock (
    PKSPIN_LOCK SpinLock,
    PKIRQL      Irql
    )
{
    if (!HalpDoingCrashDump) {
        *Irql = KfRaiseIrql (HIGH_LEVEL);
        KiAcquireSpinLock (SpinLock);
    } else {
        *Irql = HIGH_LEVEL;
    }
}


VOID
HalpPCIReleaseType2Lock (
    PKSPIN_LOCK SpinLock,
    KIRQL       Irql
    )
{
    if (!HalpDoingCrashDump) {
        KiReleaseSpinLock (SpinLock);
        KfLowerIrql (Irql);
    }
}

#endif

NTSTATUS
HalpAdjustPCIResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
/*++
    Rewrite the callers requested resource list to fit within
    the supported ranges of this bus
--*/
{
    NTSTATUS                Status;
    PPCIPBUSDATA            BusData;
    PCI_SLOT_NUMBER         PciSlot;
    PSUPPORTED_RANGE        Interrupt;
    PSUPPORTED_RANGE        Range, HoldRange;
    PSUPPORTED_RANGES       SupportedRanges;
    PPCI_COMMON_CONFIG      PciData, PciOrigData;
    UCHAR                   buffer[PCI_COMMON_HDR_LENGTH];
    UCHAR                   buffer2[PCI_COMMON_HDR_LENGTH];
    BOOLEAN                 UseBusRanges;
    ULONG                   i, j, RomIndex, length, ebit;
    ULONG                   Base[PCI_TYPE0_ADDRESSES + 1];
    PULONG                  BaseAddress[PCI_TYPE0_ADDRESSES + 1];


    BusData = (PPCIPBUSDATA) BusHandler->BusData;
    PciSlot = *((PPCI_SLOT_NUMBER) &(*pResourceList)->SlotNumber);

    //
    // Determine PCI device's interrupt restrictions
    //

    Status = BusData->GetIrqRange(BusHandler, RootHandler, PciSlot, &Interrupt);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    SupportedRanges = NULL;
    UseBusRanges    = TRUE;
    Status          = STATUS_INSUFFICIENT_RESOURCES;

    if (HalpPciLockSettings) {

        PciData = (PPCI_COMMON_CONFIG) buffer;
        PciOrigData = (PPCI_COMMON_CONFIG) buffer2;
        HalpReadPCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

        //
        // If this is a device, and it current has its decodes enabled,
        // then use the currently programmed ranges only
        //

        if (PCI_CONFIG_TYPE(PciData) == 0 &&
            (PciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE))) {

            //
            // Save current settings
            //

            RtlMoveMemory (PciOrigData, PciData, PCI_COMMON_HDR_LENGTH);


            for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type0.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type0.ROMBaseAddress;
            RomIndex = j;

            //
            // Write all one-bits to determine lengths for each address
            //

            for (j=0; j < PCI_TYPE0_ADDRESSES + 1; j++) {
                Base[j] = *BaseAddress[j];
                *BaseAddress[j] = 0xFFFFFFFF;
            }

            PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
            *BaseAddress[RomIndex] &= ~PCI_ROMADDRESS_ENABLED;
            HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
            HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

            //
            // restore original settings
            //

            HalpWritePCIConfig (
                BusHandler,
                PciSlot,
                &PciOrigData->Status,
                FIELD_OFFSET (PCI_COMMON_CONFIG, Status),
                PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
                );

            HalpWritePCIConfig (
                BusHandler,
                PciSlot,
                PciOrigData,
                0,
                FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
                );

            //
            // Build a memory & io range list of just the ranges already
            // programmed into the device
            //

            UseBusRanges    = FALSE;
            SupportedRanges = HalpAllocateNewRangeList();
            if (!SupportedRanges) {
                goto CleanUp;
            }

            *BaseAddress[RomIndex] &= ~PCI_ADDRESS_IO_SPACE;
            for (j=0; j < PCI_TYPE0_ADDRESSES + 1; j++) {

                i = *BaseAddress[j];

                if (i & PCI_ADDRESS_IO_SPACE) {
                    length = 1 << 2;
                    Range  = &SupportedRanges->IO;
                    ebit   = PCI_ENABLE_IO_SPACE;

                } else {
                    length = 1 << 4;
                    Range  = &SupportedRanges->Memory;
                    ebit   = PCI_ENABLE_MEMORY_SPACE;

                    if (i & PCI_ADDRESS_MEMORY_PREFETCHABLE) {
                        Range = &SupportedRanges->PrefetchMemory;
                    }
                }

                Base[j] &= ~(length-1);
                while (!(i & length)  &&  length) {
                    length <<= 1;
                }

                if (j == RomIndex &&
                    !(PciOrigData->u.type0.ROMBaseAddress & PCI_ROMADDRESS_ENABLED)) {

                    // range not enabled, don't use it
                    length = 0;
                }

                if (length) {
                    if (!(PciOrigData->Command & ebit)) {
                        // range not enabled, don't use preprogrammed values
                        UseBusRanges = TRUE;
                    }

                    if (Range->Limit >= Range->Base) {
                        HoldRange = Range->Next;
                        Range->Next = ExAllocatePoolWithTag(
                                          PagedPool,
                                          sizeof(SUPPORTED_RANGE),
                                          HAL_POOL_TAG
                                          );
                        Range = Range->Next;
                        if (!Range) {
                            goto CleanUp;
                        }

                        Range->Next = HoldRange;
                    }

                    Range->Base  = Base[j];
                    Range->Limit = Base[j] + length - 1;
                }

                if (Is64BitBaseAddress(i)) {
                    // skip upper half of 64 bit address since this processor
                    // only supports 32 bits of address space
                    j++;
                }
            }
        }
    }

    //
    // Adjust resources
    //

    Status = HaliAdjustResourceListRange (
                UseBusRanges ? BusHandler->BusAddresses : SupportedRanges,
                Interrupt,
                pResourceList
                );

CleanUp:
    if (SupportedRanges) {
        HalpFreeRangeList (SupportedRanges);
    }

    ExFreePool (Interrupt);
    return Status;
}



NTSTATUS
HalpGetISAFixedPCIIrq (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      PciSlot,
    OUT PSUPPORTED_RANGE    *Interrupt
    )
{
    UCHAR                   buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG      PciData;


    PciData = (PPCI_COMMON_CONFIG) buffer;
    HalGetBusData (
        PCIConfiguration,
        BusHandler->BusNumber,
        PciSlot.u.AsULONG,
        PciData,
        PCI_COMMON_HDR_LENGTH
        );

    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        return STATUS_UNSUCCESSFUL;
    }

    *Interrupt = ExAllocatePoolWithTag(PagedPool,
                                       sizeof(SUPPORTED_RANGE),
                                       HAL_POOL_TAG);
    if (!*Interrupt) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (*Interrupt, sizeof (SUPPORTED_RANGE));
    (*Interrupt)->Base = 1;                 // base = 1, limit = 0

    if (!PciData->u.type0.InterruptPin) {
        return STATUS_SUCCESS;
    }

#ifdef WANT_IRQ_ROUTING

    //  
    // Let the arbiter decide which Irq this device gets.
    //
    
    if (IsPciIrqRoutingEnabled()) {

        //
        // If a video card has been enabled by the BIOS
        // and the BIOS did not assign any interrupt to it
        // then assume this device does not need an interrupt.
        //

        if (PciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) {

            if (    (PciData->BaseClass == PCI_CLASS_PRE_20 && PciData->SubClass == PCI_SUBCLASS_VID_XGA_CTLR) ||
                    (PciData->BaseClass == PCI_CLASS_DISPLAY_CTLR && 
                        (PciData->SubClass == PCI_SUBCLASS_VID_VGA_CTLR || PciData->SubClass == PCI_SUBCLASS_VID_XGA_CTLR))) {

                if (    PciData->u.type0.InterruptLine == (0 ^ IRQXOR)  ||
                        PciData->u.type0.InterruptLine == (0xFF ^ IRQXOR)) {
                    
#if DBG
                    DbgPrint ("HalpGetValidPCIFixedIrq: BIOS did not assign an interrupt to the video device %04X%04X\n", PciData->VendorID, PciData->DeviceID);
#endif
        //
        // We need to let the caller continue, since the caller may
        // not care that the interrupt vector is connected or not
        //

                    return STATUS_SUCCESS;
                }
            }
        }
        //
        // Return all possible interrupts since Pci Irq Routing is enabled.
        //
        
        (*Interrupt)->Base  = 0;
        (*Interrupt)->Limit = 0xFF;    
        
        return STATUS_SUCCESS;        
    }  
    
#endif

    if (PciData->u.type0.InterruptLine == (0 ^ IRQXOR)  ||
        PciData->u.type0.InterruptLine == (0xFF ^ IRQXOR)) {

#if DBG
        DbgPrint ("HalpGetValidPCIFixedIrq: BIOS did not assign an interrupt vector for the device\n");
#endif
        //
        // We need to let the caller continue, since the caller may
        // not care that the interrupt vector is connected or not
        //

        return STATUS_SUCCESS;
    }

    (*Interrupt)->Base  = PciData->u.type0.InterruptLine;
    (*Interrupt)->Limit = PciData->u.type0.InterruptLine;
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixpnpdrv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixpnpdrv.c

Abstract:

    Implements functionality necessary for the
    HAL to become a PnP-style device driver
    after system initialization.  This is done
    so that the HAL can enumerate the PCI busses
    in the way that the PnP stuff expects.

Author:

    Jake Oshins (jakeo) 27-Jan-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "exboosts.h"
#include "wchar.h"
#include "pci.h"
#include "pcip.h"
#if defined(NT_UP) && defined(APIC_HAL)
#include "apic.inc"
#include "pcmp_nt.inc"
#endif

#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg("PAGECONST")
#endif // ALLOC_DATA_PRAGMA
//Instantiate the guids here only.
#include "initguid.h"
#include "wdmguid.h"
#ifdef ALLOC_DATA_PRAGMA
#pragma const_seg()
#endif // ALLOC_DATA_PRAGMA

#ifdef WANT_IRQ_ROUTING
// Pci Irq Routing.
#include "ixpciir.h"
#endif

WCHAR rgzTranslated[] = L".Translated";
WCHAR rgzBusTranslated[] = L".Bus.Translated";
WCHAR rgzResourceMap[] = L"\\REGISTRY\\MACHINE\\HARDWARE\\RESOURCEMAP";

#if DBG
ULONG   HalDebug = 0;
#endif

extern WCHAR rgzTranslated[];
extern WCHAR rgzBusTranslated[];
extern WCHAR rgzResourceMap[];
extern WCHAR HalHardwareIdString[];
#if defined(NT_UP) && defined(APIC_HAL)
extern WCHAR MpHalHardwareIdString[];
#endif
extern struct   HalpMpInfo HalpMpInfoTable;

typedef enum {
    Hal = 0x80,
    PciDriver,
    IsaPnpDriver,
    McaDriver
} PDO_TYPE;

typedef enum {
    PdoExtensionType = 0xc0,
    FdoExtensionType
} EXTENSION_TYPE;

typedef struct _PDO_EXTENSION *PPDO_EXTENSION;
typedef struct _FDO_EXTENSION *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION{
    EXTENSION_TYPE                  ExtensionType;
    PDEVICE_OBJECT                  Next;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    PFDO_EXTENSION                  ParentFdoExtension;
    PDO_TYPE                        PdoType;
    ULONG                           BusNumber;
    ULONG                           MaxSubordinateBusNumber;
    PBUS_HANDLER                    Bus;
    LONG                            InterfaceReferenceCount;
} PDO_EXTENSION, *PPDO_EXTENSION;

#define ASSERT_PDO_EXTENSION(x) ASSERT((x)->ExtensionType == PdoExtensionType );

typedef struct _FDO_EXTENSION{
    EXTENSION_TYPE        ExtensionType;
    PDEVICE_OBJECT        ChildPdoList;
    PDEVICE_OBJECT        PhysicalDeviceObject;  // PDO passed into AddDevice()
    PDEVICE_OBJECT        FunctionalDeviceObject;
    PDEVICE_OBJECT        AttachedDeviceObject;
    ULONG                 BusCount;
} FDO_EXTENSION, *PFDO_EXTENSION;

#define ASSERT_FDO_EXTENSION(x) ASSERT((x)->ExtensionType == FdoExtensionType );

INT_ROUTE_INTERFACE_STANDARD PciIrqRoutingInterface = {0};

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
HalpCompleteRequest(
    IN OUT PIRP Irp,
    IN NTSTATUS Status,
    IN ULONG Information
    );

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
HalpQueryDeviceText(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_TEXT_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpQueryInterfaceFdo(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

#endif

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    );

NTSTATUS
HalpQueryResourceRequirements(
    PDEVICE_OBJECT DeviceObject,
    PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpRemoveAssignedResources(
    PBUS_HANDLER Bus
    );

VOID
HalpMarkNonAcpiHal(
    VOID
    );

//
//  Define the PNP interface functions.
//

VOID
HalPnpInterfaceReference(
    PVOID Context
    );

VOID
HalPnpInterfaceDereference(
    PVOID Context
    );

BOOLEAN
HalPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

struct _DMA_ADAPTER *
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

ULONG
HalPnpReadConfig(
    IN PVOID Context,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalPnpWriteConfig(
    IN PVOID Context,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpGetPciInterfaces(
    IN PDEVICE_OBJECT PciPdo
    );

#ifdef APIC_HAL
NTSTATUS
HalpPci2MpsBusNumber(
    IN UCHAR PciBusNumber,
    OUT UCHAR *MpsBusNumber
    );

BOOLEAN
HalpMpsBusIsRootBus(
    IN  UCHAR MpsBus
    );
#endif

#define PCI_HAL_DRIVER_NAME  L"\\Driver\\PCI_HAL"
#define ISA_HAL_DRIVER_NAME  L"\\Driver\\ISA_HAL"
#define MCA_HAL_DRIVER_NAME  L"\\Driver\\MCA_HAL"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliInitPnpDriver)
#pragma alloc_text(PAGE, HalpDriverEntry)
#pragma alloc_text(PAGE, HalpAddDevice)
#pragma alloc_text(PAGE, HalpDispatchPnp)
#pragma alloc_text(PAGELK, HalpDispatchPower)
#pragma alloc_text(PAGE, HalpDispatchWmi)
#pragma alloc_text(PAGE, HalpQueryDeviceRelations)
#pragma alloc_text(PAGE, HalpQueryIdPdo)
#pragma alloc_text(PAGE, HalpQueryIdFdo)
#pragma alloc_text(PAGE, HalpQueryCapabilities)
#pragma alloc_text(PAGE, HalpQueryInterface)
#ifdef WANT_IRQ_ROUTING
#pragma alloc_text(PAGE, HalpQueryInterfaceFdo)
#endif
#pragma alloc_text(PAGE, HalpQueryDeviceText)
#pragma alloc_text(PAGE, HalpQueryResources)
#pragma alloc_text(PAGE, HalpQueryResourceRequirements)
#pragma alloc_text(PAGE, HalpRemoveAssignedResources)
#pragma alloc_text(PAGE, HalpMarkNonAcpiHal)
#pragma alloc_text(INIT, HalpMarkChipsetDecode)
#pragma alloc_text(PAGE, HalpOpenRegistryKey)
#pragma alloc_text(PAGE, HalpGetPciInterfaces)
#pragma alloc_text(PAGE, HalPnpInterfaceDereference)
#endif

PDRIVER_OBJECT HalpDriverObject;

NTSTATUS
HaliInitPnpDriver(
    VOID
    )
/*++

Routine Description:

    This routine starts the process of making the HAL into
    a "driver," which is necessary because we need to
    enumerate a Plug and Play PDO for the PCI driver and ISAPNP
    driver.

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/
{

    UNICODE_STRING  DriverName;
    NTSTATUS Status;

    PAGED_CODE();

    //
    // For different bus pdo, we will use different hal name such that
    // it is less confusion.
    //

    if (HalpHandlerForBus (PCIBus, 0)) {
        RtlInitUnicodeString( &DriverName, PCI_HAL_DRIVER_NAME );
    } else if (HalpHandlerForBus(MicroChannel, 0)) {
        RtlInitUnicodeString( &DriverName, MCA_HAL_DRIVER_NAME );
    } else {
        RtlInitUnicodeString( &DriverName, ISA_HAL_DRIVER_NAME );
    }

    Status = IoCreateDriver( &DriverName, HalpDriverEntry );

    //
    // John Vert (jvert) 7/23/1998
    //   There is a value in the registry that the ACPI HAL sets to disable
    //   the firmware mapper. Unfortunately this value is persistent. So if
    //   you have an ACPI machine and "upgrade" it to a non-ACPI machine, the
    //   value is still present. Workaround here is to set the value to zero.
    //
    HalpMarkNonAcpiHal();

    if (!NT_SUCCESS( Status )) {
        ASSERT( NT_SUCCESS( Status ));
        return Status;
    }

    return STATUS_SUCCESS;

}

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    PnP Driver Object.  In this function, we need to remember the DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/
{
    NTSTATUS Status;
    PDEVICE_OBJECT detectedDeviceObject = NULL;

    PAGED_CODE();

    //
    // File the pointer to our driver object away
    //

    HalpDriverObject = DriverObject;

    //
    // Fill in the driver object
    //

    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE) HalpAddDevice;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = HalpDispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = HalpDispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = HalpDispatchWmi;

    Status = IoReportDetectedDevice(DriverObject,
                                    InterfaceTypeUndefined,
                                    -1,
                                    -1,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    &detectedDeviceObject);

    ASSERT( detectedDeviceObject != NULL );

    if (!(NT_SUCCESS(Status))) {
        HalPrint(("IoReportDetectedDevice failed"));
        return Status;
    }

    Status = HalpAddDevice(DriverObject, detectedDeviceObject);

    return Status;

}

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine handles AddDevice for an madeup PDO device.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT Status.

--*/
{
    PDEVICE_OBJECT FunctionalDeviceObject;
    PDEVICE_OBJECT ChildDeviceObject;
    PDEVICE_OBJECT AttachedDevice;
    NTSTATUS       Status;
    PFDO_EXTENSION FdoExtension;
    PPDO_EXTENSION PdoExtension;
    PDEVICE_OBJECT  Pdo2;
    ULONG BusNumber;
    ULONG BusCount = 0;
    PBUS_HANDLER Bus;
    WCHAR Buffer[40];
    UNICODE_STRING Unicode;
    PDO_TYPE PdoType;
    UCHAR MpsBusNumber;

    PAGED_CODE();

    //
    // We've been given the PhysicalDeviceObject.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    Status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(FDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &FunctionalDeviceObject     // store new device object here
                );

    if( !NT_SUCCESS( Status )){

        DbgBreakPoint();
        return Status;
    }

    //
    // Fill in the FDO extension
    //

    FdoExtension = (PFDO_EXTENSION) FunctionalDeviceObject->DeviceExtension;
    FdoExtension->ExtensionType = FdoExtensionType;
    FdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    FdoExtension->FunctionalDeviceObject = FunctionalDeviceObject;
    FdoExtension->ChildPdoList = NULL;

    //
    // Now attach to the PDO we were given.
    //

    AttachedDevice = IoAttachDeviceToDeviceStack(FunctionalDeviceObject,
                                                 PhysicalDeviceObject );
    if (AttachedDevice == NULL) {

        HalPrint(("Couldn't attach"));

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice( FunctionalDeviceObject );

        return STATUS_NO_SUCH_DEVICE;

    }

    FdoExtension->AttachedDeviceObject = AttachedDevice;

    //
    // Clear the device initializing flag.
    //

    FunctionalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Find any child PCI busses.
    //

    for ( BusNumber = 0;
          Bus = HaliReferenceHandlerForBus(PCIBus, BusNumber);
          BusNumber++ ) {

#ifdef APIC_HAL
        Status = HalpPci2MpsBusNumber((UCHAR)BusNumber, &MpsBusNumber);

        if (NT_SUCCESS(Status)) {

            if (!HalpMpsBusIsRootBus(MpsBusNumber)) {

                //
                // This is not a root PCI bus, so skip it.
                //
                continue;
            }
        }
#endif

        if (Bus->ParentHandler != NULL &&
            Bus->ParentHandler->InterfaceType == PCIBus) {

            //
            // Skip bridges.
            //

            HaliDereferenceBusHandler( Bus );
            continue;
        }

        //
        // Remove the system resoruces from the range lists.
        //

        Status = HalpRemoveAssignedResources( Bus );

        if (!NT_SUCCESS(Status)) {

            HaliDereferenceBusHandler( Bus );
            return Status;
        }

        _snwprintf( Buffer, sizeof( Buffer ), L"\\Device\\Hal Pci %d", BusCount );
        RtlInitUnicodeString( &Unicode, Buffer );

        //
        // Next, create a PDO for the PCI driver.
        //

        Status = IoCreateDevice(
                    DriverObject,               // our driver object
                    sizeof(PDO_EXTENSION),      // size of our extension
                    &Unicode,                   // our name
                    FILE_DEVICE_BUS_EXTENDER,   // device type
                    0,                          // device characteristics
                    FALSE,                      // not exclusive
                    &ChildDeviceObject          // store new device object here
                    );

        if (!NT_SUCCESS(Status)) {

            HaliDereferenceBusHandler( Bus );
            return Status;
        }

        //
        // Fill in the PDO extension
        //

        PdoExtension = (PPDO_EXTENSION) ChildDeviceObject->DeviceExtension;
        PdoExtension->ExtensionType = PdoExtensionType;
        PdoExtension->PhysicalDeviceObject = ChildDeviceObject;
        PdoExtension->ParentFdoExtension = FdoExtension;
        PdoExtension->PdoType = PciDriver;
        PdoExtension->BusNumber = BusNumber;
        PdoExtension->MaxSubordinateBusNumber = 0xff;  // correct value later
        PdoExtension->Bus = Bus;

        BusCount++;

        //
        // Record this as a child of the HAL.  Add new childern at the
        // end of the list.
        //


        PdoExtension->Next = NULL;

        if (FdoExtension->ChildPdoList == NULL) {
            FdoExtension->ChildPdoList = ChildDeviceObject;
        } else {

            for (Pdo2 = FdoExtension->ChildPdoList;
                ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next != NULL;
                Pdo2 = ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next);

            ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next = ChildDeviceObject;
        }


        //
        // Clear the device initializing flag.
        //

        ChildDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    }

    //
    // Now loop through all the children PDOs making sure that
    // the MaxSubordinateBusNumbers are reasonable.  This loop
    // assumes that the list is sorted by BusNumber.
    //

    Pdo2 = FdoExtension->ChildPdoList;

    while (Pdo2) {

        if (!((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next) {

            //
            // There is no next Pdo extension, which means that
            // this bus represents the last root bus, which means
            // that we can leave its subordinate bus number at 0xff.
            //

            break;
        }

        if (((PPDO_EXTENSION) Pdo2->DeviceExtension)->MaxSubordinateBusNumber >=
            ((PPDO_EXTENSION) ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next->DeviceExtension)->BusNumber) {

            //
            // Set the subordinate bus number at one less than the bus number of the
            // next root bus.
            //

            ((PPDO_EXTENSION)Pdo2->DeviceExtension)->MaxSubordinateBusNumber =
                ((PPDO_EXTENSION) ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next->DeviceExtension)->BusNumber - 1;
        }

        Pdo2 = ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next;
    }

    FdoExtension->BusCount = BusCount;

    if (BusCount == 0) {
        Bus = HaliReferenceHandlerForBus(Isa, 0);
        if (!Bus) {
            Bus = HaliReferenceHandlerForBus(Eisa, 0);
        }
        if (Bus) {
            _snwprintf( Buffer, sizeof( Buffer ), L"\\Device\\Hal Isa %d", 0 );
            RtlInitUnicodeString( &Unicode, Buffer );
            PdoType = IsaPnpDriver;
        } else {
            Bus = HaliReferenceHandlerForBus(MicroChannel, 0);
            ASSERT(Bus);
            _snwprintf( Buffer, sizeof( Buffer ), L"\\Device\\Hal Mca %d", 0 );
            RtlInitUnicodeString( &Unicode, Buffer );
            PdoType = McaDriver;
        }
    }
    if (Bus) {

        //
        // Next, create a PDO for the PCI driver.
        //

        Status = IoCreateDevice(
                    DriverObject,               // our driver object
                    sizeof(PDO_EXTENSION),      // size of our extension
                    &Unicode,                   // our name
                    FILE_DEVICE_BUS_EXTENDER,   // device type
                    0,                          // device characteristics
                    FALSE,                      // not exclusive
                    &ChildDeviceObject          // store new device object here
                    );

        if (!NT_SUCCESS(Status)) {
            return Status;
        }

        //
        // Fill in the PDO extension
        //

        PdoExtension = (PPDO_EXTENSION) ChildDeviceObject->DeviceExtension;
        PdoExtension->ExtensionType = PdoExtensionType;
        PdoExtension->PhysicalDeviceObject = ChildDeviceObject;
        PdoExtension->ParentFdoExtension = FdoExtension;
        PdoExtension->BusNumber = 0;
        PdoExtension->MaxSubordinateBusNumber = 0;
        PdoExtension->Bus = Bus;
        PdoExtension->PdoType = PdoType;

        //
        // Record this as a child of the HAL
        //

        PdoExtension->Next = FdoExtension->ChildPdoList;
        FdoExtension->ChildPdoList = ChildDeviceObject;
        FdoExtension->BusCount = 1;

        //
        // Clear the device initializing flag.
        //

        ChildDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
HalpPassIrpFromFdoToPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    Given an FDO, pass the IRP to the next device object in the
    device stack.  This is the PDO if there are no lower level
    filters.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{

    PIO_STACK_LOCATION irpSp;       // our stack location
    PIO_STACK_LOCATION nextIrpSp;   // next guy's
    PFDO_EXTENSION     fdoExtension;

    HalPrint(("PassIrp ..."));

    //
    // Get the pointer to the device extension.
    //

    fdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Call the PDO driver with the request.
    //

    return IoCallDriver(fdoExtension->AttachedDeviceObject ,Irp);
}

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP_POWER IRPs for madeup PDO device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS Status;
    ULONG length;
    DEVICE_RELATION_TYPE relationType;
    EXTENSION_TYPE  extensionType;
    BOOLEAN passDown;
#if DBG
    PUCHAR objectTypeString;
#endif //DBG
    PPDO_EXTENSION pdoExtension;


    PAGED_CODE();

    pdoExtension = (PPDO_EXTENSION)DeviceObject->DeviceExtension;
    extensionType = ((PFDO_EXTENSION)pdoExtension)->ExtensionType;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    switch (extensionType) {

    case PdoExtensionType:

#if DBG
        objectTypeString = "PDO";
#endif //DBG

        switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            HalPrint(("(%s) Start_Device Irp received",
                       objectTypeString));

            Status = STATUS_SUCCESS;

            //
            // If we are starting a PCI PDO, then we want to
            // collect a little bit of information from the PCI driver.
            //

            if (pdoExtension->PdoType == PciDriver) {

                Status = HalpGetPciInterfaces(DeviceObject);
                ASSERT(NT_SUCCESS(Status));

                if (NT_SUCCESS(Status)) {

                    PciIrqRoutingInterface.InterfaceReference(PciIrqRoutingInterface.Context);

#ifdef WANT_IRQ_ROUTING

                    //
                    // Initialize Pci Irq Routing.
                    //

                    HalpPciIrqRoutingInfo.PciInterface = &PciIrqRoutingInterface;
                    if (NT_SUCCESS(HalpInitPciIrqRouting(&HalpPciIrqRoutingInfo)))
                    {
                        HalPrint(("Pci Irq Routing initialized successfully!"));
                    }
                    else
                    {
                        HalPrint(("No Pci Irq routing on this system!"));
                    }
#endif
                } else {

                    RtlZeroMemory(&PciIrqRoutingInterface, sizeof(INT_ROUTE_INTERFACE_STANDARD));
                }
            }

            break;


        case IRP_MN_QUERY_STOP_DEVICE:

            HalPrint(("(%s) Query_Stop_Device Irp received",
                       objectTypeString));

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            HalPrint(("(%s) Cancel_Stop_Device Irp received",
                       objectTypeString));

            Status = STATUS_SUCCESS;
            break;


        case IRP_MN_STOP_DEVICE:

            HalPrint(("(%s) Stop_Device Irp received",
                       objectTypeString));

            //
            // If we get a stop device request for a PDO, we simply
            // return success.
            //

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_RESOURCES:

            HalPrint(("(%s) Query_Resources Irp received",
                       objectTypeString));

            Status = HalpQueryResources(DeviceObject,
                         (PCM_RESOURCE_LIST *)&Irp->IoStatus.Information);

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            HalPrint(("(%s) Query_Resource_Requirements Irp received",
                       objectTypeString));

            Status = HalpQueryResourceRequirements(DeviceObject,
                         (PIO_RESOURCE_REQUIREMENTS_LIST*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            HalPrint(("(%s) Query_Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            Status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            HalPrint(("(%s) Cancel_Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:

            HalPrint(("(%s) Remove_device Irp for %x",
                       objectTypeString,
                       DeviceObject));

            if ((((PPDO_EXTENSION)(DeviceObject->DeviceExtension))->PdoType == PciDriver) &&
                (PciIrqRoutingInterface.InterfaceReference != NULL)) {

                PciIrqRoutingInterface.InterfaceDereference(PciIrqRoutingInterface.Context);
            }

            Status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalPrint(("(%s) Query_Device_Relations Irp received",
                      objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            Status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_DEVICE_TEXT:

            HalPrint(("(%s) Query Device Text Irp received",
                       objectTypeString));

            Status = HalpQueryDeviceText(DeviceObject,
                                         irpSp->Parameters.QueryDeviceText.DeviceTextType,
                                         (PWSTR*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_ID:

            HalPrint(("(%s) Query_Id Irp received",
                       objectTypeString));

            Status = HalpQueryIdPdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_INTERFACE:

            HalPrint(("(%s) Query_Interface Irp received",
                       objectTypeString));

            Status = HalpQueryInterface(
                         DeviceObject,
                         irpSp->Parameters.QueryInterface.InterfaceType,
                         irpSp->Parameters.QueryInterface.Version,
                         irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                         irpSp->Parameters.QueryInterface.Size,
                         irpSp->Parameters.QueryInterface.Interface,
                         &Irp->IoStatus.Information
                         );
            break;

        case IRP_MN_QUERY_CAPABILITIES:

            HalPrint(("(%s) Query_Capabilities Irp received",
                       objectTypeString));

            Status = HalpQueryCapabilities(DeviceObject,
                                           irpSp->Parameters.DeviceCapabilities.Capabilities);

            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:

            HalPrint(("(%s) Device_Usage_Notification Irp received",
                       objectTypeString));
            Status = STATUS_SUCCESS;

            break;

        default:

            HalPrint(("(%s) Unsupported Irp (%d) received",
                       objectTypeString,
                       irpSp->MinorFunction));

            Status = STATUS_NOT_SUPPORTED ;
            break;
        }

        break;  // end PDO cases

    case FdoExtensionType:

#if DBG
        objectTypeString = "FDO";
#endif //DBG
        passDown = TRUE;

        switch (irpSp->MinorFunction){

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalPrint(("(%s) Query_Device_Relations Irp received",
                      objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            Status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_ID:

            HalPrint(("(%s) Query_Id Irp received",
                       objectTypeString));

            Status = HalpQueryIdFdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

#ifdef WANT_IRQ_ROUTING
        case IRP_MN_QUERY_INTERFACE:

            HalPrint(("(%s) Query_Interface Irp received",
                       objectTypeString));

            Status = HalpQueryInterfaceFdo(
                         DeviceObject,
                         irpSp->Parameters.QueryInterface.InterfaceType,
                         irpSp->Parameters.QueryInterface.Version,
                         irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                         irpSp->Parameters.QueryInterface.Size,
                         irpSp->Parameters.QueryInterface.Interface,
                         &Irp->IoStatus.Information
                         );
            break;

#endif

        default:

            //
            // Ignore any PNP Irps unknown by the FDO but allow them
            // down to the PDO.
            //
            Status = STATUS_NOT_SUPPORTED ;
            break;
        }

        if (passDown && (NT_SUCCESS(Status) || (Status == STATUS_NOT_SUPPORTED))) {

            //
            // Pass FDO IRPs down to the PDO.
            //
            // Set Irp status first.
            //

            if (Status != STATUS_NOT_SUPPORTED) {

                Irp->IoStatus.Status = Status;
            }

            HalPrint(("(%s) Passing down Irp (%x)",
                      objectTypeString, irpSp->MinorFunction));
            return HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
        }

        break;  // end FDO cases

    default:

        HalPrint(("Received IRP for unknown Device Object"));
        Status = STATUS_NOT_SUPPORTED;
        break;

    }

    //
    // Complete the Irp and return.
    //

    if (Status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = Status;

    } else {

        Status = Irp->IoStatus.Status ;

    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for madeup device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;
    PIO_STACK_LOCATION irpSp;

    HalPrint(("Power IRP for DevObj: %x", DeviceObject));

    //
    // Simply store the appropriate status and complete the request.
    //

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Simply store the appropriate status and complete the request.
    //

    Status = Irp->IoStatus.Status;

    if ((irpSp->MinorFunction == IRP_MN_QUERY_POWER) ||
        (irpSp->MinorFunction == IRP_MN_SET_POWER)) {

        Irp->IoStatus.Status = Status = STATUS_SUCCESS;
    
    } else if (irpSp->MinorFunction == IRP_MN_WAIT_WAKE) {
        //
        // Fail this explicitly as we don't know how to wake the system...
        //
        Irp->IoStatus.Status = Status = STATUS_NOT_SUPPORTED;
    }

    PoStartNextPowerIrp(Irp);

    if (extensionType == PdoExtensionType) {

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

    } else {

#ifdef APIC_HAL
        if (irpSp->MinorFunction == IRP_MN_SET_POWER) {
            if (irpSp->Parameters.Power.Type == SystemPowerState) {
                
                switch (irpSp->Parameters.Power.State.SystemState) {
                case PowerSystemHibernate:
                    
                    HalpBuildResumeStructures();
                    break;
                    
                case PowerSystemWorking:
                    
                    HalpFreeResumeStructures();
                    break;

                default:
                    break;
                }
            }
        }
#endif

        Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
    }
    return Status;
}

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    if (extensionType == FdoExtensionType) {
        Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
    } else {
        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}


NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description:

    This routine builds a DEVICE_RELATIONS structure that
    tells the PnP manager how many children we have.

Arguments:

    DeviceObject - FDO of PCI_HAL

    RelationType - we only respond to BusRelations

    DeviceRelations - pointer to the structure

Return Value:

    status

--*/
{
    PFDO_EXTENSION  FdoExtension;
    PDEVICE_RELATIONS   relations = NULL;
    ULONG count;
    PDEVICE_OBJECT  *Pdo;
    PDEVICE_OBJECT  Pdo2;
    EXTENSION_TYPE  extensionType;

    PAGED_CODE();

    FdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;
    extensionType = FdoExtension->ExtensionType;
    count = FdoExtension->BusCount;

    switch (RelationType) {

        case BusRelations:

            if ((extensionType == PdoExtensionType)||(count == 0)) {

                //
                // Don't touch the IRP
                //
                return STATUS_NOT_SUPPORTED ;
            }

            if (*DeviceRelations != NULL) {
                count += (*DeviceRelations)->Count;
            }

            relations = ExAllocatePoolWithTag(
                PagedPool,
                sizeof(DEVICE_RELATIONS) +
                (count - 1) * sizeof( PDEVICE_OBJECT),
                HAL_POOL_TAG
                );

            if (relations == NULL) {
                HalPrint(("HalpQueryDeviceRelations: couldn't allocate pool"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            relations->Count = count;
            Pdo = relations->Objects;

            count = 0;

            if (*DeviceRelations != NULL) {

                for ( count = 0; count < (*DeviceRelations)->Count; count++) {

                    *Pdo = (*DeviceRelations)->Objects[count];
                    Pdo++;
                }
                ExFreePool(*DeviceRelations);
            }

            //
            //  Add our PDO's to the list.
            //
            Pdo2 = FdoExtension->ChildPdoList;
            while (Pdo2 != NULL) {

                *Pdo = Pdo2;
                ObReferenceObject(Pdo2);
                Pdo2 = ((PPDO_EXTENSION) Pdo2->DeviceExtension)->Next;
                Pdo++;
                ASSERT( count++ < relations->Count );
            }

            *DeviceRelations = relations;
            return STATUS_SUCCESS;

        case TargetDeviceRelation:

            if (extensionType == FdoExtensionType) {

                //
                // Don't touch the IRP
                //
                return STATUS_NOT_SUPPORTED ;
            }

            relations = ExAllocatePoolWithTag(
                PagedPool,
                sizeof(DEVICE_RELATIONS),
                HAL_POOL_TAG
                );

            if (!relations) {

                return STATUS_INSUFFICIENT_RESOURCES;
            }

            relations->Count = 1;
            relations->Objects[0] = DeviceObject ;

            ObReferenceObject(relations->Objects[0]);
            *DeviceRelations = relations;

            return STATUS_SUCCESS ;

        default:

            break;
    }

    HalPrint(("We don't support this kind of device relation"));
    return STATUS_NOT_SUPPORTED ;
}

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    UNICODE_STRING String;
    WCHAR Buffer[16];
    NTSTATUS Status;
    static WCHAR PciHardwareIdString[] = L"PCI_HAL\\PNP0A03";
    static WCHAR PciCompatibleString[] = L"*PNP0A03";
    static WCHAR IsaHardwareIdString[] = L"ISA_HAL\\PNP0A00";
    static WCHAR IsaCompatibleString[] = L"*PNP0A00";
    static WCHAR McaHardwareIdString[] = L"ISA_HAL\\PNP0A02";
    static WCHAR McaCompatibleString[] = L"*PNP0A02";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:
        if (PdoExtension->PdoType == PciDriver) {
            sourceString = PciHardwareIdString;
            stringLen = sizeof(PciHardwareIdString);
        } else if (PdoExtension->PdoType == IsaPnpDriver) {
            sourceString = IsaHardwareIdString;
            stringLen = sizeof(IsaHardwareIdString);
        } else if (PdoExtension->PdoType == McaDriver) {
            sourceString = McaHardwareIdString;
            stringLen = sizeof(McaHardwareIdString);
        }
        break;

    case BusQueryCompatibleIDs:

        if (PdoExtension->PdoType == PciDriver) {
            sourceString = PciCompatibleString;
            stringLen = sizeof(PciCompatibleString);
        } else if (PdoExtension->PdoType == IsaPnpDriver) {
            sourceString = IsaCompatibleString;
            stringLen = sizeof(IsaCompatibleString);
        } else if (PdoExtension->PdoType == McaDriver) {
            sourceString = McaCompatibleString;
            stringLen = sizeof(McaCompatibleString);
        }
        break;

    case BusQueryInstanceID:

        String.Buffer = Buffer;
        String.MaximumLength = 16 * sizeof(WCHAR);
        Status = RtlIntegerToUnicodeString( PdoExtension->BusNumber, 10, &String );

        //
        //  Note the string length in this case does not include a NULL.
        //  the code below will terminate the string with NULL.
        //

        sourceString = Buffer;
        stringLen = String.Length;
        break;
    }
    if (sourceString) {

        //
        // Note that hardware IDs and compatible IDs must be terminated by
        // 2 NULLs.
        //

        idString = ExAllocatePoolWithTag(PagedPool,
                                         stringLen + sizeof(UNICODE_NULL),
                                         HAL_POOL_TAG);

        if (!idString) {
            HalPrint(("HalpQueryIdPdo: couldn't allocate pool\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(idString,
                      sourceString, stringLen);

        *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

        *BusQueryId = idString;

        return STATUS_SUCCESS;
    } else {
        return STATUS_NOT_SUPPORTED;
    }
}
NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    UNICODE_STRING String;
    WCHAR Buffer[16];
    NTSTATUS Status;
    PWCHAR widechar;
    static WCHAR HalInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        //
        // For the UP version of the APIC HAL, we want to detect if there is more 
        // than one processor installed. If so, we want to return the ID of
        // the MP HAL rather than the UP HAL. This will induce PNP to reconfigure
        // our devnode and setup the MP HAL for the next boot.
        //
        sourceString = HalHardwareIdString;
#if defined(NT_UP) && defined(APIC_HAL)
        if (HalpMpInfoTable.ProcessorCount > 1) {
            sourceString = MpHalHardwareIdString;
        }
#endif
        widechar = sourceString;
        while (*widechar != UNICODE_NULL) {
            widechar++;
        }
        stringLen =  (PUCHAR)widechar - ((PUCHAR)sourceString) + 2;
        break;

    case BusQueryInstanceID:

        sourceString = HalInstanceIdString;
        stringLen = sizeof(HalInstanceIdString);
        break;

    default:
        break;
    }
    if (sourceString) {

        //
        // Note that hardware IDs and compatible IDs must be terminated by
        // 2 NULLs.
        //

        idString = ExAllocatePoolWithTag(PagedPool,
                                         stringLen + sizeof(UNICODE_NULL),
                                         HAL_POOL_TAG);

        if (!idString) {
            HalPrint(("HalpQueryIdFdo: couldn't allocate pool\n"));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(idString,
                      sourceString, stringLen);

        *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

        *BusQueryId = idString;

        return STATUS_SUCCESS;
    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT Pdo,
    IN PDEVICE_CAPABILITIES Capabilities
    )
/*++

Routine Description:

    This routine fills in the DEVICE_CAPABILITIES structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    Capabilities - pointer to the structure to be filled in.

Return Value:

    status

--*/
{
    PPDO_EXTENSION PdoExtension = (PPDO_EXTENSION) Pdo->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    ASSERT(Capabilities->Version == 1);
    if (Capabilities->Version != 1) {

        return STATUS_NOT_SUPPORTED;

    }

    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = TRUE;
    Capabilities->SilentInstall = TRUE;
    Capabilities->RawDeviceOK = FALSE;
    Capabilities->Address = PdoExtension->BusNumber;
    Capabilities->UINumber = PdoExtension->BusNumber;
    Capabilities->D1Latency = 0;
    Capabilities->D2Latency = 0;
    Capabilities->D3Latency = 0;

    //
    // Default S->D mapping
    //
    Capabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
    Capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
    Capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    //
    // Make it work on NTAPM --- note that we might have to check to see
    // if the machine supports APM before we do this
    //
    Capabilities->DeviceState[PowerSystemSleeping3] = PowerDeviceD3;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    InterfaceType - Pointer to the interface type GUID.

    Version - Supplies the requested interface version.

    InterfaceSpecificData - This is context that means something based on the
                            interface.

    InterfaceBufferSize - Supplies the length of the buffer for the interface
                          structure.

    Interface - Supplies a pointer where the interface informaiton should
        be returned.

    Length - This value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    PPDO_EXTENSION PdoExtension = (PPDO_EXTENSION)DeviceObject->DeviceExtension;
    CM_RESOURCE_TYPE resource = (CM_RESOURCE_TYPE)InterfaceSpecificData;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION(PdoExtension);

    if (IsEqualGUID(&GUID_BUS_INTERFACE_STANDARD, InterfaceType)) {

        PBUS_INTERFACE_STANDARD standard = (PBUS_INTERFACE_STANDARD)Interface;

        //
        // ASSERT we know about all of the fields in the structure.
        //

        ASSERT(sizeof(BUS_INTERFACE_STANDARD) == FIELD_OFFSET(BUS_INTERFACE_STANDARD, GetBusData) + sizeof(PGET_SET_DEVICE_DATA));

        *Length = sizeof(BUS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(BUS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  The only version this code knows about is 1.
        //

        standard->Size = sizeof(BUS_INTERFACE_STANDARD);
        standard->Version = HAL_BUS_INTERFACE_STD_VERSION;
        standard->Context = DeviceObject;

        standard->InterfaceReference = HalPnpInterfaceReference;
        standard->InterfaceDereference = HalPnpInterfaceDereference;
        standard->TranslateBusAddress = HalPnpTranslateBusAddress;
        standard->GetDmaAdapter = HalPnpGetDmaAdapter;
        standard->SetBusData = NULL;
        standard->GetBusData = NULL;

    } else if ((IsEqualGUID(&GUID_PCI_BUS_INTERFACE_STANDARD, InterfaceType)) &&
               (PdoExtension->PdoType == PciDriver)) {

        PPCI_BUS_INTERFACE_STANDARD pciStandard = (PPCI_BUS_INTERFACE_STANDARD)Interface;

        *Length = sizeof(PCI_BUS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(PCI_BUS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        // Fill in the interface, which is used for reading and
        // writing PCI configuration space.
        //

        pciStandard->Size = sizeof(PCI_BUS_INTERFACE_STANDARD);
        pciStandard->Version = PCI_BUS_INTERFACE_STANDARD_VERSION;
        pciStandard->Context = DeviceObject;

        pciStandard->InterfaceReference = HalPnpInterfaceReference;
        pciStandard->InterfaceDereference = HalPnpInterfaceDereference;
        pciStandard->ReadConfig = HaliPciInterfaceReadConfig;
        pciStandard->WriteConfig = HaliPciInterfaceWriteConfig;
        pciStandard->PinToLine = NULL;
        pciStandard->LineToPin = NULL;

#if 0

    } else if (IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType)) {

        PTRANSLATOR_INTERFACE translator = (PTRANSLATOR_INTERFACE)Interface;

        if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {

            *Length = sizeof(TRANSLATOR_INTERFACE);
            return STATUS_BUFFER_TOO_SMALL;
        }

        switch ((CM_RESOURCE_TYPE)InterfaceSpecificData) {

        case CmResourceTypeInterrupt:

            switch(PdoExtension->PdoType) {
            case PciDriver:
                translator->Context = (PVOID)PCIBus;
                break;
            case IsaPnpDriver:
                translator->Context = (PVOID)Isa;
                break;
            case McaDriver:
                translator->Context = (PVOID)MicroChannel;
                break;
            default:

                //
                // Don't know how to handle this.
                //

                HalPrint(("HAL: PDO %08x unknown Type 0x%x, failing QueryInterface\n",
                          DeviceObject,
                          PdoExtension->PdoType
                          ));

                return STATUS_NOT_SUPPORTED;
            }
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                HalIrqTranslateResourceRequirementsRoot;

            break;


//      Truth is, halx86 doesn't provide translators for memory or
//      io resources either.   But if it did, it would look like this.

        case CmResourceTypeMemory:
        case CmResourceTypePort:

            translator->Context = DeviceObject;
            translator->Version = HAL_MEMIO_TRANSLATOR_VERSION;
            translator->TranslateResources = HalpTransMemIoResource;
            translator->TranslateResourceRequirements =
                HalpTransMemIoResourceRequirement;
            break;


        default:
            return STATUS_NOT_SUPPORTED;
        }


        //
        // Common initialization
        //
        translator->Size = sizeof(TRANSLATOR_INTERFACE);
        translator->InterfaceReference = HalPnpInterfaceReference;
        translator->InterfaceDereference = HalPnpInterfaceDereference;

        *Length = sizeof(TRANSLATOR_INTERFACE);

#endif

#ifdef WANT_IRQ_ROUTING
    } else if ( IsPciIrqRoutingEnabled() &&
                IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType) &&
                resource == CmResourceTypeInterrupt &&
                PdoExtension->PdoType == PciDriver) {

        //
        // We want to arbitrate on untranslated resources, so we get rid of Irq
        // translator provided by Pci iff Irq Routing is enabled.
        //

        HalPrint(("Getting rid of Pci Irq translator interface since Pci Irq Routing is enabled!"));

        RtlZeroMemory((LPGUID)InterfaceType, sizeof(GUID));

        return STATUS_NOT_SUPPORTED;

#endif

    } else {

        //
        //  Unsupport bus interface type.
        //

        return STATUS_NOT_SUPPORTED ;
    }

    //
    // Bump the reference count.
    //

    InterlockedIncrement(&PdoExtension->InterfaceReferenceCount);

    return STATUS_SUCCESS;
}

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpQueryInterfaceFdo(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for
    a device.

Arguments:

    DeviceObject - FDO of the child

    InterfaceType - Pointer to the interface type GUID.

    Version - Supplies the requested interface version.

    InterfaceSpecificData - This is context that means something based on the
                            interface.

    InterfaceBufferSize - Supplies the length of the buffer for the interface
                          structure.

    Interface - Supplies a pointer where the interface informaiton should
        be returned.

    Length - Supplies the length of the buffer for the interface structure.
        This value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    NTSTATUS                status = STATUS_NOT_SUPPORTED;
    CM_RESOURCE_TYPE        resource = (CM_RESOURCE_TYPE)InterfaceSpecificData;

    PAGED_CODE();

    if (    resource == CmResourceTypeInterrupt &&
            IsPciIrqRoutingEnabled()) {

        if (IsEqualGUID(&GUID_ARBITER_INTERFACE_STANDARD, InterfaceType)) {

            status = HalpInitIrqArbiter(DeviceObject);

            if (NT_SUCCESS(status))
            {
                status = HalpFillInIrqArbiter(
                    DeviceObject,
                    InterfaceType,
                    Version,
                    InterfaceSpecificData,
                    InterfaceBufferSize,
                    Interface,
                    Length
                    );
            }
        }
        else if (IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType)) {

            PTRANSLATOR_INTERFACE   translator;

            *Length = sizeof(TRANSLATOR_INTERFACE);
            if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            translator = (PTRANSLATOR_INTERFACE)Interface;

            //
            // Fill in the common bits.
            //

            RtlZeroMemory(translator, sizeof (TRANSLATOR_INTERFACE));
            translator->Size = sizeof(TRANSLATOR_INTERFACE);
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->Context = DeviceObject;
            translator->InterfaceReference = HalTranslatorReference;
            translator->InterfaceDereference = HalTranslatorDereference;

            //
            // Set IRQ translator for PCI interrupts.
            //

            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                                            HalIrqTranslateResourceRequirementsRoot;

            status = STATUS_SUCCESS;

            HalPrint(("Providing Irq translator for FDO %08x since Pci Irq Routing is enabled!", DeviceObject));
        }
    }

    return (status);
}

#endif

NTSTATUS
HalpQueryDeviceText(
    IN PDEVICE_OBJECT DeviceObject,
    IN DEVICE_TEXT_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    NTSTATUS Status;
    static WCHAR PciDeviceNameText[] = L"Pci Root Bus";
    static WCHAR IsaDeviceNameText[] = L"Isa Root Bus";
    static WCHAR McaDeviceNameText[] = L"Mca Root Bus";

    PAGED_CODE();

    if (PdoExtension->PdoType == PciDriver) {
        sourceString = PciDeviceNameText;
        stringLen = sizeof(PciDeviceNameText);
    } else if (PdoExtension->PdoType == IsaPnpDriver) {
        sourceString = IsaDeviceNameText;
        stringLen = sizeof(IsaDeviceNameText);
    } else if (PdoExtension->PdoType == McaDriver) {
        sourceString = McaDeviceNameText;
        stringLen = sizeof(McaDeviceNameText);
    }
    if (sourceString) {
        switch (IdType) {
        case DeviceTextDescription:
        case DeviceTextLocationInformation:

            idString = ExAllocatePoolWithTag(PagedPool,
                                             stringLen,
                                             HAL_POOL_TAG);

            if (!idString) {
                HalPrint(("HalpQueryDeviceText: couldn't allocate pool\n"));
                return STATUS_INSUFFICIENT_RESOURCES;
            }

            RtlCopyMemory(idString,
                          sourceString, stringLen);

            *BusQueryId = idString;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_SUPPORTED;
}

NTSTATUS
HalpQueryResources(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PCM_RESOURCE_LIST *Resources
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_RESOURCE_REQUIREMENTS.

Arguments:

    DeviceObject - PDO of the child

    Resources - pointer to be filled in with the devices
        resource list.

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PCM_RESOURCE_LIST  ResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR Descriptor;
    PSUPPORTED_RANGE Range;
    ULONG ResourceListSize;
    ULONG Count = 1;


    if (PdoExtension->PdoType != PciDriver) {

        *Resources = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Determine the number of resourse list needed.  Already counted
    // one for the Bus Number.
    //

    for (Range = &PdoExtension->Bus->BusAddresses->IO; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->Memory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->PrefetchMemory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    //
    // Convert this resourceListSize into the number of bytes that we
    // must allocate
    //

    ResourceListSize = sizeof(CM_RESOURCE_LIST) +
        ( (Count - 1) * sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) );

    ResourceList = ExAllocatePoolWithTag(
                       PagedPool,
                       ResourceListSize,
                       HAL_POOL_TAG);

    if (ResourceList == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( ResourceList, ResourceListSize );

    //
    // Initialize the list header.
    //

    ResourceList->Count = 1;
    ResourceList->List[0].InterfaceType = PNPBus;
    ResourceList->List[0].BusNumber = -1;
    ResourceList->List[0].PartialResourceList.Version = 1;
    ResourceList->List[0].PartialResourceList.Revision = 1;
    ResourceList->List[0].PartialResourceList.Count = Count;
    Descriptor = ResourceList->List[0].PartialResourceList.PartialDescriptors;

    //
    // Create descriptor for the Bus Number.
    //

    Descriptor->Type = CmResourceTypeBusNumber;
    Descriptor->ShareDisposition = CmResourceShareShared;
    Descriptor->u.BusNumber.Start = PdoExtension->BusNumber;
    Descriptor->u.BusNumber.Length = PdoExtension->MaxSubordinateBusNumber -
                                        PdoExtension->BusNumber + 1;
    Descriptor++;

    for (Range = &PdoExtension->Bus->BusAddresses->IO; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypePort;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_PORT_IO;
        Descriptor->u.Port.Length = (ULONG)(Range->Limit - Range->Base) + 1;
        Descriptor->u.Port.Start.QuadPart = Range->Base;
        Descriptor++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->Memory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypeMemory;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
        Descriptor->u.Memory.Length = (ULONG)(Range->Limit - Range->Base) + 1;
        Descriptor->u.Memory.Start.QuadPart = Range->Base;
        Descriptor++;

    }

    for (Range = &PdoExtension->Bus->BusAddresses->PrefetchMemory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypeMemory;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;
        Descriptor->u.Memory.Length = (ULONG)(Range->Limit - Range->Base) + 1;
        Descriptor->u.Memory.Start.QuadPart = Range->Base;
        Descriptor++;
    }

    *Resources = ResourceList;

    return STATUS_SUCCESS;

}

NTSTATUS
HalpQueryResourceRequirements(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_RESOURCE_REQUIREMENTS.

Arguments:

    DeviceObject - PDO of the child

    Requirements - pointer to be filled in with the devices
        resource requirements.

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PIO_RESOURCE_REQUIREMENTS_LIST  ResourceList;
    PIO_RESOURCE_DESCRIPTOR Descriptor;
    PSUPPORTED_RANGE Range;
    ULONG ResourceListSize;
    ULONG Count = 0;


    if (PdoExtension->PdoType != PciDriver) {

        *Requirements = NULL;
        return STATUS_SUCCESS;
    }

    //
    // Determine the number of resourse list needed.
    //

    for (Range = &PdoExtension->Bus->BusAddresses->IO; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->Memory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->PrefetchMemory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Count++;
    }

    //
    // Convert this resourceListSize into the number of bytes that we
    // must allocate
    //

    ResourceListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
        ( (Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );

    ResourceList = ExAllocatePoolWithTag(
                       PagedPool,
                       ResourceListSize,
                       HAL_POOL_TAG);

    if (ResourceList == NULL ) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( ResourceList, ResourceListSize );
    ResourceList->ListSize = ResourceListSize;

    //
    // Initialize the list header.
    //

    ResourceList->AlternativeLists = 1;
    ResourceList->InterfaceType = PNPBus;
    ResourceList->BusNumber = -1;
    ResourceList->List[0].Version = 1;
    ResourceList->List[0].Revision = 1;
    ResourceList->List[0].Count = Count;
    Descriptor = ResourceList->List[0].Descriptors;

    for (Range = &PdoExtension->Bus->BusAddresses->IO; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypePort;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_PORT_IO;
        Descriptor->u.Port.Length = (ULONG) (Range->Limit - Range->Base + 1);
        Descriptor->u.Port.Alignment = 0x01;
        Descriptor->u.Port.MinimumAddress.QuadPart = Range->Base;
        Descriptor->u.Port.MaximumAddress.QuadPart = Range->Limit;
        Descriptor++;
    }

    for (Range = &PdoExtension->Bus->BusAddresses->Memory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypeMemory;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE;
        Descriptor->u.Memory.Length = (ULONG) (Range->Limit - Range->Base + 1);
        Descriptor->u.Memory.Alignment = 0x01;
        Descriptor->u.Memory.MinimumAddress.QuadPart = Range->Base;
        Descriptor->u.Memory.MaximumAddress.QuadPart = Range->Limit;
        Descriptor++;

    }

    for (Range = &PdoExtension->Bus->BusAddresses->PrefetchMemory; Range != NULL; Range = Range->Next) {

        //
        // If the limit is zero then skip this entry.
        //

        if (Range->Limit == 0) {
            continue;
        }

        Descriptor->Type = CmResourceTypeMemory;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags = CM_RESOURCE_MEMORY_READ_WRITE | CM_RESOURCE_MEMORY_PREFETCHABLE;
        Descriptor->u.Memory.Length = (ULONG) (Range->Limit - Range->Base + 1);
        Descriptor->u.Memory.Alignment = 0x01;
        Descriptor->u.Memory.MinimumAddress.QuadPart = Range->Base;
        Descriptor->u.Memory.MaximumAddress.QuadPart = Range->Limit;
        Descriptor++;
    }

    *Requirements = ResourceList;

    return STATUS_SUCCESS;

}

NTSTATUS
HalpRemoveAssignedResources (
    PBUS_HANDLER Bus
    )
/*

Routine Description:

    Reads the rgzResourceMap in the registry and builds a canonical list of
    all in use resources ranges by resource type.

Arguments:



*/
{
    HANDLE                          ClassKeyHandle, DriverKeyHandle;
    HANDLE                          ResourceMap;
    ULONG                           ClassKeyIndex, DriverKeyIndex, DriverValueIndex;
    PCM_RESOURCE_LIST               CmResList;
    PCM_FULL_RESOURCE_DESCRIPTOR    CmFResDesc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDesc;
    UNICODE_STRING                  KeyName;
    ULONG                           BufferSize;
    union {
        PVOID                       Buffer;
        PKEY_BASIC_INFORMATION      KeyBInf;
        PKEY_FULL_INFORMATION       KeyFInf;
        PKEY_VALUE_FULL_INFORMATION VKeyFInf;
    } U;
    PUCHAR                          LastAddr;
    ULONG                           Temp, Length, i, j;
    ULONG                           TranslatedStrLen;
    ULONG                           BusTranslatedStrLen;
    NTSTATUS                        Status;
    LONGLONG                        li;

    PAGED_CODE();

    //
    // Removed page zero.
    //

    HalpRemoveRange( &Bus->BusAddresses->Memory,
                     0i64,
                     (LONGLONG) (PAGE_SIZE - 1)
                     );

    //
    // Start out with one page of buffer.
    //

    BufferSize = PAGE_SIZE;

    U.Buffer = ExAllocatePoolWithTag(
                   PagedPool,
                   BufferSize,
                   HAL_POOL_TAG);
    if (U.Buffer == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    for (TranslatedStrLen=0; rgzTranslated[TranslatedStrLen]; TranslatedStrLen++) ;
    for (BusTranslatedStrLen=0; rgzBusTranslated[BusTranslatedStrLen]; BusTranslatedStrLen++) ;
    TranslatedStrLen    *= sizeof (WCHAR);
    BusTranslatedStrLen *= sizeof (WCHAR);

    RtlInitUnicodeString( &KeyName, rgzResourceMap );

    Status = HalpOpenRegistryKey( &ResourceMap, NULL, &KeyName, KEY_READ, FALSE );

    if (!NT_SUCCESS( Status )) {
        HalPrint(("HalRemoveSystemResourcesFromPci: Failed to open resource map key Status = %lx\n", Status ));
        ExFreePool( U.Buffer );
        return Status;
    }


    //
    // Walk resource map and collect any inuse resources
    //

    ClassKeyIndex = 0;

    ClassKeyHandle  = INVALID_HANDLE;
    DriverKeyHandle = INVALID_HANDLE;
    Status = STATUS_SUCCESS;

    while (NT_SUCCESS(Status)) {

        //
        // Get the class information
        //

        Status = ZwEnumerateKey( ResourceMap,
                                 ClassKeyIndex++,
                                 KeyBasicInformation,
                                 U.KeyBInf,
                                 BufferSize,
                                 &Temp );

        if (!NT_SUCCESS( Status )) {
            break;
        }


        //
        // Create a UNICODE_STRING using the counted string passed back to
        // us in the information structure, and open the class key.
        //

        KeyName.Buffer = (PWSTR)  U.KeyBInf->Name;
        KeyName.Length = (USHORT) U.KeyBInf->NameLength;
        KeyName.MaximumLength = (USHORT) U.KeyBInf->NameLength;

        Status = HalpOpenRegistryKey( &ClassKeyHandle,
                                     ResourceMap,
                                     &KeyName,
                                     KEY_READ,
                                     FALSE  );

        if (!NT_SUCCESS( Status )) {
            break;
        }

        DriverKeyIndex = 0;
        while (NT_SUCCESS (Status)) {

            //
            // Get the class information
            //

            Status = ZwEnumerateKey( ClassKeyHandle,
                                     DriverKeyIndex++,
                                     KeyBasicInformation,
                                     U.KeyBInf,
                                     BufferSize,
                                     &Temp );

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            // Create a UNICODE_STRING using the counted string passed back to
            // us in the information structure, and open the class key.
            //
            // This is read from the key we created, and the name
            // was NULL terminated.
            //

            KeyName.Buffer = (PWSTR)  U.KeyBInf->Name;
            KeyName.Length = (USHORT) U.KeyBInf->NameLength;
            KeyName.MaximumLength = (USHORT) U.KeyBInf->NameLength;

            Status = HalpOpenRegistryKey( &DriverKeyHandle,
                                         ClassKeyHandle,
                                         &KeyName,
                                         KEY_READ,
                                         FALSE);

            if (!NT_SUCCESS( Status )) {
                break;
            }

            //
            // Get full information for that key so we can get the
            // information about the data stored in the key.
            //

            Status = ZwQueryKey( DriverKeyHandle,
                                 KeyFullInformation,
                                 U.KeyFInf,
                                 BufferSize,
                                 &Temp );

            if (!NT_SUCCESS( Status )) {
                break;
            }

            Length = sizeof( KEY_VALUE_FULL_INFORMATION ) +
                U.KeyFInf->MaxValueNameLen + U.KeyFInf->MaxValueDataLen + sizeof(UNICODE_NULL);

            if (Length > BufferSize) {
                PVOID TempBuffer;

                //
                // Get a larger buffer
                //

                TempBuffer = ExAllocatePoolWithTag(
                                 PagedPool,
                                 Length,
                                 HAL_POOL_TAG);
                if (TempBuffer == NULL) {
                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                ExFreePool (U.Buffer);
                U.Buffer = TempBuffer;
                BufferSize = Length;
            }

            DriverValueIndex = 0;
            for (; ;) {
                Status = ZwEnumerateValueKey( DriverKeyHandle,
                                              DriverValueIndex++,
                                              KeyValueFullInformation,
                                              U.VKeyFInf,
                                              BufferSize,
                                              &Temp );

                if (!NT_SUCCESS( Status )) {
                    break;
                }

                //
                // If this is not a translated resource list, skip it.
                //

                i = U.VKeyFInf->NameLength;
                if (i < TranslatedStrLen ||
                    RtlCompareMemory (
                        ((PUCHAR) U.VKeyFInf->Name) + i - TranslatedStrLen,
                        rgzTranslated,
                        TranslatedStrLen
                        ) != TranslatedStrLen
                    ) {
                    // does not end in rgzTranslated
                    continue;
                }

                //
                // If this is a bus translated resource list, ????
                //

                if (i >= BusTranslatedStrLen &&
                    RtlCompareMemory (
                        ((PUCHAR) U.VKeyFInf->Name) + i - BusTranslatedStrLen,
                        rgzBusTranslated,
                        BusTranslatedStrLen
                        ) == BusTranslatedStrLen
                    ) {

                    // ends in rgzBusTranslated
                    continue;
                }


                //
                // Run the CmResourceList and save each InUse resource
                //

                CmResList = (PCM_RESOURCE_LIST) ( (PUCHAR) U.VKeyFInf + U.VKeyFInf->DataOffset);
                LastAddr  = (PUCHAR) CmResList + U.VKeyFInf->DataLength;
                CmFResDesc = &CmResList->List[0];

                for (i=0; i < CmResList->Count && NT_SUCCESS(Status) ; i++) {

                    for (j=0; j < CmFResDesc->PartialResourceList.Count && NT_SUCCESS(Status); j++) {

                        CmDesc = &CmFResDesc->PartialResourceList.PartialDescriptors[j];

                        if ((PUCHAR) (CmDesc+1) > LastAddr) {
                            if (i) {
                                HalPrint(("IopAssignResourcesPhase2: a. CmResourceList in regitry too short\n"));
                            }
                            break;
                        }


                        if ((PUCHAR) (CmDesc+1) > LastAddr) {
                            i = CmResList->Count;
                            HalPrint(("IopAssignResourcesPhase2: b. CmResourceList in regitry too short\n"));
                            break;
                        }

                        switch (CmDesc->Type) {
                        case CmResourceTypePort:

                            HalpRemoveRange( &Bus->BusAddresses->IO,
                                             CmDesc->u.Generic.Start.QuadPart,
                                             CmDesc->u.Generic.Start.QuadPart +
                                             CmDesc->u.Generic.Length - 1
                                             );

                            break;

                        case CmResourceTypeMemory:

                            //
                            // The HAL's notion of prefetchable may not be
                            // consistent.  So just remove any memory resource
                            // from both the prefetchable and non-prefetchable
                            // lists.
                            //

                            HalpRemoveRange( &Bus->BusAddresses->PrefetchMemory,
                                             CmDesc->u.Generic.Start.QuadPart,
                                             CmDesc->u.Generic.Start.QuadPart +
                                             CmDesc->u.Generic.Length - 1
                                             );


                            HalpRemoveRange( &Bus->BusAddresses->Memory,
                                             CmDesc->u.Generic.Start.QuadPart,
                                             CmDesc->u.Generic.Start.QuadPart +
                                             CmDesc->u.Generic.Length - 1
                                             );

                            break;

                        default:
                            break;
                        }
                    }

                  //
                  // Start at the end of the last CmDesc
                  // since the PCM_PARTIAL_RESOURCE_DESCRIPTOR array
                  // is variable size we can't just use the index.
                  //
                  (PCM_PARTIAL_RESOURCE_DESCRIPTOR) CmFResDesc = CmDesc+1;

                }

            }   // next DriverValueIndex

            if (DriverKeyHandle != INVALID_HANDLE) {
                ZwClose (DriverKeyHandle);
                DriverKeyHandle = INVALID_HANDLE;
            }

            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
            }

            if (!NT_SUCCESS(Status)) {
                break;
            }
        }   // next DriverKeyIndex

        if (ClassKeyHandle != INVALID_HANDLE) {
            ZwClose (ClassKeyHandle);
            ClassKeyHandle = INVALID_HANDLE;
        }

        if (Status == STATUS_NO_MORE_ENTRIES) {
            Status = STATUS_SUCCESS;
        }

    }   // next ClassKeyIndex

    if (Status == STATUS_NO_MORE_ENTRIES) {
        Status = STATUS_SUCCESS;
    }

    ZwClose( ResourceMap );
    ExFreePool (U.Buffer);

    HalpConsolidateRanges (Bus->BusAddresses);

    return Status;
}


VOID
HalpMarkNonAcpiHal(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG tmpValue;
    UNICODE_STRING unicodeString;
    HANDLE hCurrentControlSet, handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Open/create System\CurrentControlSet key.
    //

    RtlInitUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");
    status = HalpOpenRegistryKey (
                 &hCurrentControlSet,
                 NULL,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 FALSE
                 );
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\Pnp
    //

    RtlInitUnicodeString(&unicodeString, L"Control\\Pnp");
    status = HalpOpenRegistryKey (
                 &handle,
                 hCurrentControlSet,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 TRUE
                 );
    ZwClose(hCurrentControlSet);
    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&unicodeString, L"DisableFirmwareMapper");
    tmpValue = 0;
    ZwSetValueKey(handle,
                  &unicodeString,
                  0,
                  REG_DWORD,
                  &tmpValue,
                  sizeof(tmpValue)
                  );
    ZwClose(handle);
}

VOID
HalpMarkChipsetDecode(
    BOOLEAN FullDecodeChipset
    )

/*++

Routine Description:


Arguments:

    FullDecodeChipset   - TRUE if NTOSKRNL should consider all fixed I/O
                          descriptors for PNPBIOS devices as 16bit. FALSE if
                          they should be taken at their word.

Return Value:

    None.

--*/
{
    ULONG tmpValue;
    UNICODE_STRING unicodeString;
    HANDLE hCurrentControlSet, handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Open/create System\CurrentControlSet key.
    //

    RtlInitUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");
    status = HalpOpenRegistryKey (
                 &hCurrentControlSet,
                 NULL,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 FALSE
                 );
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\Biosinfo\PNPBios
    //

    RtlInitUnicodeString(&unicodeString, L"Control\\Biosinfo\\PNPBios");
    status = HalpOpenRegistryKey (
                 &handle,
                 hCurrentControlSet,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 TRUE
                 );
    ZwClose(hCurrentControlSet);
    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&unicodeString, L"FullDecodeChipsetOverride");
    tmpValue = (ULONG) FullDecodeChipset;
    ZwSetValueKey(handle,
                  &unicodeString,
                  0,
                  REG_DWORD,
                  &tmpValue,
                  sizeof(tmpValue)
                  );
    ZwClose(handle);
}

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}


VOID
HalPnpInterfaceReference(
    PVOID Context
    )
/*++

Routine Description:

    This function increments the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    InterlockedIncrement( &PdoExtension->InterfaceReferenceCount );
}

VOID
HalPnpInterfaceDereference(
    PVOID Context
    )
/*++

Routine Description:

    This function decrements the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    LONG Result;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Result = InterlockedDecrement( &PdoExtension->InterfaceReferenceCount );

    ASSERT( Result >= 0 );
}

BOOLEAN
HalPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    This function is used to translate bus addresses from legacy drivers.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    BusAddress - Supplies the orginal address to be translated.

    Length - Supplies the length of the range to be translated.

    AddressSpace - Points to the location of of the address space type such as
        memory or I/O port.  This value is updated by the translation.

    TranslatedAddress - Returns the translated address.

Return Value:

    Returns a boolean indicating if the operations was a success.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PBUS_HANDLER Bus;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Bus = PdoExtension->Bus;

    return Bus->TranslateBusAddress( Bus,
                                          Bus,
                                          BusAddress,
                                          AddressSpace,
                                          TranslatedAddress );


}

ULONG
HalPnpReadConfig(
    IN PVOID Context,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function reads the PCI configuration space.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    Slot - Indicates the slot to be read or writen.

    Buffer - Supplies a pointer to where the data should be placed.

    Offset - Indicates the offset into the data where the reading should begin.

    Length - Indicates the count of bytes which should be read.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PBUS_HANDLER Bus;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Bus = PdoExtension->Bus;

    return Bus->GetBusData( Bus, Bus, Slot, Buffer, Offset, Length );

}

ULONG
HalPnpWriteConfig(
    IN PVOID Context,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    Slot - Indicates the slot to be read or writen.

    Buffer - Supplies a pointer to where the data to be written is.

    Offset - Indicates the offset into the data where the writing should begin.

    Length - Indicates the count of bytes which should be written.

Return Value:

    Returns the number of bytes read.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PBUS_HANDLER Bus;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Bus = PdoExtension->Bus;

    return Bus->SetBusData( Bus, Bus, Slot, Buffer, Offset, Length );

}

PDMA_ADAPTER
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PBUS_HANDLER Bus;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Bus = PdoExtension->Bus;

    //
    //  Fill in the bus number.
    //

    DeviceDescriptor->BusNumber = Bus->BusNumber;
    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );
}

NTSTATUS
HalpGetPciInterfaces(
    IN PDEVICE_OBJECT PciPdo
    )
/*++

Routine Description:

    This function queries the PCI driver for interfaces used in interrupt
    translation and arbitration.

Arguments:

    PciPdo - PDO of a PCI bus

Return Value:

--*/
{
    NTSTATUS            status;
    PDEVICE_OBJECT      topDeviceInStack;
    KEVENT              irpCompleted;
    PIRP                irp;
    IO_STATUS_BLOCK     statusBlock;
    PIO_STACK_LOCATION  irpStack;

    PAGED_CODE();

    KeInitializeEvent(&irpCompleted, SynchronizationEvent, FALSE);

    //
    // Send an IRP to the PCI driver to get the Interrupt Routing Interface.
    //
    topDeviceInStack = IoGetAttachedDeviceReference(PciPdo);

    irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       topDeviceInStack,
                                       NULL,    // Buffer
                                       0,       // Length
                                       0,       // StartingOffset
                                       &irpCompleted,
                                       &statusBlock);

    if (!irp) {
        return STATUS_UNSUCCESSFUL;
    }

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = 0;

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set the function codes and parameters.
    //

    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = &GUID_INT_ROUTE_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size = sizeof(INT_ROUTE_INTERFACE_STANDARD);
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) &PciIrqRoutingInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Call the driver and wait for completion
    //

    status = IoCallDriver(topDeviceInStack, irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&irpCompleted, Executive, KernelMode, FALSE, NULL);
        status = statusBlock.Status;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixproc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixsproc.c

Abstract:

    Stub functions for UP hals.

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITCONST") // INITCONST is OK to use for data_seg
#endif // ALLOC_DATA_PRAGMA
WCHAR HalHardwareIdString[] = L"e_isa_up\0";

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif // ALLOC_DATA_PRAGMA

const UCHAR HalName[] = "PC Compatible Eisa/Isa HAL";
#define HalName        L"PC Compatible Eisa/Isa HAL"
ULONG   HalDisplayBusRanges;

BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpMcaInit (
    VOID
    );

VOID HalpInitOtherBuses (VOID);
VOID HalpInitializePciBus (VOID);
VOID HalpInitializePciStubs (VOID);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitMP)
#pragma alloc_text(INIT,HalStartNextProcessor)
#pragma alloc_text(INIT,HalAllProcessorsStarted)
#pragma alloc_text(INIT,HalReportResourceUsage)
#pragma alloc_text(INIT,HalpInitOtherBuses)
#endif



BOOLEAN
HalpInitMP (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    // do nothing
    return TRUE;
}


VOID
HalpResetAllProcessors (
    VOID
    )
{
    // Just return, that will invoke the standard PC reboot code
}


BOOLEAN
HalStartNextProcessor (
   IN PLOADER_PARAMETER_BLOCK   pLoaderBlock,
   IN PKPROCESSOR_STATE         pProcessorState
   )
{
    // no other processors
    return FALSE;
}

BOOLEAN
HalAllProcessorsStarted (
    VOID
    )
{
    if (HalpFeatureBits & HAL_NO_SPECULATION) {

        //
        // Processor doesn't perform speculative execeution,
        // remove fences in critical code paths
        //

        HalpRemoveFences ();
    }

    return TRUE;
}


VOID
HalReportResourceUsage (
    VOID
    )
{
    INTERFACE_TYPE  interfacetype;
    UNICODE_STRING  UHalName;

    HalInitSystemPhase2 ();

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();
    HalpInitializePciStubs ();

    //
    // Complete ALL bus initialization before reporting resource usage.
    //

    switch (HalpBusType) {
        case MACHINE_TYPE_ISA:  interfacetype = Isa;            break;
        case MACHINE_TYPE_EISA: interfacetype = Eisa;           break;
        case MACHINE_TYPE_MCA:  interfacetype = MicroChannel;   break;
        default:                interfacetype = Internal;       break;
    }

    RtlInitUnicodeString (&UHalName, HalName);
    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        interfacetype       // device space interface type
    );

#if DBG
    //
    // Display all buses & ranges
    //

    if (HalDisplayBusRanges) {
        HalpDisplayAllBusRanges ();
    }
#endif

    //
    // Declare that we are capable of
    // hibernation.
    //
    HalpRegisterHibernate ();

    HalpRegisterPciDebuggingDeviceInfo();
}


VOID
HalpInitOtherBuses (
    VOID
    )
{
    // no other internal buses supported
}

ULONG
FASTCALL
HalSystemVectorDispatchEntry (
    IN ULONG Vector,
    OUT PKINTERRUPT_ROUTINE **FlatDispatch,
    OUT PKINTERRUPT_ROUTINE *NoConnection
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixprofil.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixprofile.asm
;
; Abstract:
;
;    This module implements the code necessary to initialize,
;    field and process the profile interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (landy@corollary.com) 26-Mar-1992
;       Move much code into separate modules for easy inclusion by various
;       HAL builds.
;
;	Add HalBeginSystemInterrupt() call at beginning of ProfileInterrupt
;	code - this must be done before any sti.
;	Also add HalpProfileInterrupt2ndEntry for additional processors to
;	join the flow of things.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _KeProfileInterrupt,1,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0

;
; Constants used to initialize CMOS/Real Time Clock
;

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

align 4
ProfileIntervalTable    dd      1221    ; unit = 100 ns
                        dd      2441
                        dd      4883
                        dd      9766
                        dd      19531
                        dd      39063
                        dd      78125
                        dd      156250
                        dd      312500
                        dd      625000
                        dd      1250000
                        dd      2500000
                        dd      5000000
                        dd      5000000 OR 80000000H

ProfileIntervalInitTable db     00100011B
                        db      00100100B
                        db      00100101B
                        db      00100110B
                        db      00100111B
                        db      00101000B
                        db      00101001B
                        db      00101010B
                        db      00101011B
                        db      00101100B
                        db      00101101B
                        db      00101110B
                        db      00101111B
                        db      00101111B

;
; HALs wishing to reuse the code in this module should set the HAL
; global variable IxProfileVector to their profile vector.
;
		public	_IxProfileVector
_IxProfileVector	dd	PROFILE_VECTOR

_TEXT   ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

RegisterAProfileValue   db      00101000B ; default interval = 3.90625 ms

;
; The following array stores the per microsecond loop count for each
; central processor.
;

HalpProfileInterval     dd      -1

public _HalpProfilingStopped
_HalpProfilingStopped   dd      1

_DATA   ends

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   HalStartProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the slowest thing we can get away with to the value
;       that's been KeSetProfileInterval
;
;   All processors will run this routine, but it doesn't hurt to have
;   each one reinitialize the CMOS, since none of them will be let go
;   from the stall until they all finish.
;
;--

cPublicProc _HalStartProfileInterrupt    ,1

;   Mark profiling as active
;

        mov     dword ptr _HalpProfilingStopped, 0

;
;   Set the interrupt rate to what is actually needed
;
        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     al, RegisterAProfileValue
        shl     ax, 8
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalStartProfileInterrupt

stdENDP _HalStartProfileInterrupt



;++
;
;   HalStopProfileInterrupt(
;       IN ULONG Reserved
;       );
;
;   Routine Description:
;
;       What we do here is change the interrupt
;       rate from the high profiling rate to the slowest thing we
;       can get away with for PerformanceCounter rollover notification.
;
;--

cPublicProc _HalStopProfileInterrupt    ,1

;
;   Turn off profiling hit computation and profile interrupt
;

;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending profiling interrupt
        mov     dword ptr _HalpProfilingStopped, 1
        stdCall   _HalpReleaseCmosSpinLock

        stdRET    _HalStopProfileInterrupt

stdENDP _HalStopProfileInterrupt

;++
;   ULONG
;   HalSetProfileInterval (
;       ULONG Interval
;       );
;
;   Routine Description:
;
;       This procedure sets the interrupt rate (and thus the sampling
;       interval) for the profiling interrupt.
;
;       If profiling is active (KiProfilingStopped == 0) the actual
;       hardware interrupt rate will be set.  Otherwise, a simple
;       rate validation computation is done.
;
;   Arguments:
;
;       (TOS+4) - Interval in 100ns unit.
;
;   Return Value:
;
;       Interval actually used by system.
;
;--

cPublicProc _HalSetProfileInterval    ,1

        mov     edx, [esp+4]            ; [edx] = interval in 100ns unit
        and     edx, 7FFFFFFFh          ; Remove highest bit.
        mov     ecx, 0                  ; index = 0

Hspi00:
        mov     eax, ProfileIntervalTable[ecx * 4]
        cmp     edx, eax                ; if request interval < suport interval
        jbe     short Hspi10            ; if be, find supported interval
        inc     ecx
        jmp     short Hspi00

Hspi10:
        and     eax, 7FFFFFFFh          ; remove highest bit from supported interval
        jecxz   short Hspi20            ; If first entry then use it

        push    esi                     ; See which is closer to requested
        mov     esi, eax                ; rate - current entry, or preceeding
        sub     esi, edx

        sub     edx, ProfileIntervalTable[ecx * 4 - 4]
        cmp     esi, edx
        pop     esi
        jc      short Hspi20

        dec     ecx                     ; use preceeding entry
        mov     eax, ProfileIntervalTable[ecx * 4]

Hspi20:
        push    eax                     ; save interval value
        mov     al, ProfileIntervalInitTable[ecx]
        mov     RegisterAProfileValue, al
        test    dword ptr _HalpProfilingStopped,-1
        jnz     short Hspi90

        stdCall   _HalStartProfileInterrupt,<0> ; Re-start profile interrupt
                                        ; with the new interval

Hspi90: pop     eax
        stdRET    _HalSetProfileInterval    ; (eax) = cReturn interval

stdENDP _HalSetProfileInterval

        page ,132
        subttl  "System Profile Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of a profile interrupt.
;    Its function is to dismiss the interrupt, raise system Irql to
;    PROFILE_LEVEL and transfer control to
;    the standard system routine to process any active profiles.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeProfileInterrupt, which returns
;
;    Sets Irql = PROFILE_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hpi_a, Hpi_t

cPublicProc _HalpProfileInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hpi_a, Hpi_t

;
; (esp) - base of trap frame
;
; HalBeginSystemInterrupt must be called before any sti's
;
;

        push    _IxProfileVector
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall	_HalBeginSystemInterrupt, <PROFILE_LEVEL,_IxProfileVector,esp>

        or      al,al                   ; check for spurious interrupt
        jz      Hpi100


;
; This is the RTC interrupt, so we have to clear the
; interrupt flag on the RTC.
;
        stdCall	_HalpAcquireCmosSpinLock

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
if  DBG
        align   4
Hpi10:  test    al, 80h
        jz      short Hpi15
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        jmp     short Hpi10
Hpi15:
endif   ; DBG

        stdCall _HalpReleaseCmosSpinLock

        sti
;
; This entry point is provided for symmetric multiprocessor HALs.
; Since it only makes sense for one processor to clear the CMOS,
; all other processors can instead jmp into this entry point.
;

	align 4
        public     _HalpProfileInterrupt2ndEntry@0
_HalpProfileInterrupt2ndEntry@0:

;
; (esp) = OldIrql
; (esp+4) = H/W vector
; (esp+8) = base of trap frame
;

;
;   Now check for any profiling stuff to do.
;

        cmp     _HalpProfilingStopped, dword ptr 1 ; Has profiling been stopped?
        jz      short Hpi90                 ; if z, prof disenabled

        stdCall _KeProfileInterrupt,<ebp>   ; (ebp) = trapframe

Hpi90:
        INTERRUPT_EXIT

	align	4
Hpi100:
        add     esp, 8                      ; spurious, no EndOfInterrupt
        SPURIOUS_INTERRUPT_EXIT             ; exit interrupt without eoi

stdENDP _HalpProfileInterrupt

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixslpctx.inc ===
;
; Structure at the begining of a real-mode startup block
;

PxParamBlock struc
    SPx_Jmp_Inst    dd  ?
    SPx_flag        dd  ?
    SPx_flat_addr   dd  ?
    SPx_TiledCR3    dd  ?
    SPx_P0EBP       dd  ?
    SPx_PB          db  ProcessorStateLength dup (?)
PxParamBlock ends
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixsleep.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixsleep.h

Abstract:

    This file has all the common headers used
    for saving and restoring context for multiple
    processors.

Author:

    Jake Oshins (jakeo) March 25, 1998

Revision History:

--*/

VOID
HalpSavePicState(
    VOID
    );

VOID
HalpRestorePicState(
    VOID
    );

VOID
HalpRestoreTempPicState(
    VOID
    );

ULONG
HalpBuildTiledCR3Ex (
    IN PKPROCESSOR_STATE    ProcessorState,
    IN ULONG                ProcNum
    );

VOID
HalpFreeTiledCR3Ex (
    ULONG ProcNum
    );

VOID
HalpUnMapIOApics(
    VOID
    );

VOID
HalpSaveProcessorStateAndWait(
    IN PKPROCESSOR_STATE ProcessorState,
    IN PULONG            Count
    );

extern PVOID HalpResumeContext;
extern PKPROCESSOR_STATE HalpHiberProcState;
extern ULONG             CurTiledCr3LowPart;
extern PPHYSICAL_ADDRESS HalpTiledCr3Addresses;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixqspin.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    isqspin.c

Abstract:

    This module provides an (optionally) instrumented, platform independent
    implementation of the Kernel Import Queued Spinlock routines.  Where
    optimal performance is required, platform dependent versions are
    used.   The code in this file can be used to bootstrap a system or
    on UP systems where them MP version is only used during installation.

    ref: ACM Transactions on Computer Systems, Vol. 9, No. 1, Feb 1991.
         Algorithms for Global Synchronization on Shared Memory
         Multiprocessors.

    The basic algorithm is as follows:

    When attempting to acquire the spinlock, the contents of the spinlock
    is atomically exchanged with the address of the context of the acquirer.
    If the previous value was zero, the acquisition attempt is successful.
    If non-zero, it is a pointer to the context of the most recent attempt
    to acquire the lock (which may have been successful or may be waiting).
    The next pointer in this most recent context is updated to point to
    the context of the new waiter (this attempt).

    When releasing the lock, a compare exchange is done with the contents
    of the lock and the address of the releasing context, if the compare
    succeeds, zero is stored in the lock and it has been released.  If
    not equal, another thread is waiting and that thread is granted the
    lock.

    Benefits:

    . Each processor spins on a local variable.  Standard spinlocks
    have each processor spinning on the same variable which is possibly
    in a dirty cache line causing this cache line to be passed from
    processor to processor repeatedly.
    . The lock is granted to the requestors in the order the requests
    for the lock were made (ie fair).
    . Atomic operations are reduced to one for each acquire and one
    for each release.

    In this implementation, the context structure for the commonly
    used (high frequency) system locks is in a table in the PRCB,
    and references to a lock are made by the lock's index.

Author:

    Peter L Johnston (peterj) 20-August-1998

Environment:

    Kernel Mode only.

Revision History:

--*/


#include "halp.h"

#if defined(_X86_)
#pragma intrinsic(_enable)
#pragma intrinsic(_disable)
#endif

//
// Define the YIELD instruction.
//

#if defined(_X86_) && !defined(NT_UP)

#define YIELD()     _asm { rep nop }

#else

#define YIELD()

#endif

#define INIT_DEBUG_BREAKER 0x10000000

#if !defined(NT_UP)

VOID
FASTCALL
HalpAcquireQueuedSpinLock (
    IN PKSPIN_LOCK_QUEUE Current
    )

/*++

Routine Description:

    This function acquires the specified queued spinlock.  IRQL must be
    high enough on entry to grarantee a processor switch cannot occur.

Arguments:

    Current     Address of Queued Spinlock structure.

Return Value:

    None.

--*/

{
    PKSPIN_LOCK_QUEUE Previous;
    PULONG            Lock;

#if DBG

    ULONG             DebugBreaker;

#endif

    //
    // Attempt to acquire the lock.
    //

    Lock = (PULONG)&Current->Lock;

    ASSERT((*Lock & 3) == 0);

    Previous = InterlockedExchangePointer(Current->Lock, Current);

    if (Previous == NULL) {

        *Lock |= LOCK_QUEUE_OWNER;

    } else {

        //
        // Lock is already held, update next pointer in previous
        // context to point to this new waiter and wait until the
        // lock is granted.
        //

        volatile ULONG * LockBusy = (ULONG *)&Current->Lock;

        ASSERT(Previous->Next == NULL);
        ASSERT(!(*LockBusy & LOCK_QUEUE_WAIT));

        *LockBusy |= LOCK_QUEUE_WAIT;

        Previous->Next = Current;

#if DBG

        DebugBreaker = INIT_DEBUG_BREAKER;

#endif

        while ((*LockBusy) & LOCK_QUEUE_WAIT) {
            YIELD();

#if DBG

            if (--DebugBreaker == 0) {
                DbgBreakPoint();
            }

#endif

        }

        ASSERT(*LockBusy & LOCK_QUEUE_OWNER);
    }
}

LOGICAL
FASTCALL
HalpTryToAcquireQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    This function attempts to acquire the specified queued spinlock.
    Interrupts are disabled.

Arguments:

    Number      Queued Spinlock Number.

Return Value:

    TRUE    If the lock was acquired,
    FALSE   if it is already held by another processor.

--*/

{
    PKSPIN_LOCK_QUEUE Current;
    PKSPIN_LOCK_QUEUE Owner;

    //
    // See if the lock is available.
    //

    Current = &(KeGetCurrentPrcb()->LockQueue[Number]);

    ASSERT(((ULONG)Current->Lock & 3) == 0);

    if (!*(Current->Lock)) {
        Owner = InterlockedCompareExchangePointer(Current->Lock, Current, NULL);

        if (Owner == NULL) {

            //
            // Lock has been acquired.
            //

            Current->Lock = (PKSPIN_LOCK)
                            (((ULONG)Current->Lock) | LOCK_QUEUE_OWNER);
            return TRUE;
        }
    }

    return FALSE;
}

VOID
FASTCALL
HalpReleaseQueuedSpinLock (
    IN PKSPIN_LOCK_QUEUE Current
    )

/*++

Routine Description:

    Release a (queued) spinlock.   If other processors are waiting
    on this lock, hand the lock to the next in line.

Arguments:

    Current     Address of Queued Spinlock structure.

Return Value:

    None.

--*/

{
    PKSPIN_LOCK_QUEUE Next;
    PULONG            Lock;
    volatile VOID **  Waiting;

#if DBG

    ULONG             DebugBreaker = INIT_DEBUG_BREAKER;

#endif

    Lock = (PULONG)&Current->Lock;

    ASSERT((*Lock & 3) == LOCK_QUEUE_OWNER);

    //
    // Clear lock owner in my own struct.
    //

    *Lock ^= LOCK_QUEUE_OWNER;

    Next = Current->Next;

    if (!Next) {

        //
        // No waiter, attempt to release the lock.   As there is no other
        // waiter, the current lock value should be THIS lock structure
        // ie "Current".  We do a compare exchange Current against the
        // lock, if it succeeds, the lock value is replaced with NULL and
        // the lock has been released.  If the compare exchange fails it
        // is because someone else has acquired but hadn't yet updated
        // our next field (which we checked above).
        //

        Next = InterlockedCompareExchangePointer(Current->Lock, NULL, Current);

        if (Next == Current) {

            //
            // Lock has been released.
            //

            return;
        }

        //
        // There is another waiter,... but our next pointer hadn't been
        // updated when we checked earlier.   Wait for it to be updated.
        //

        Waiting = (volatile VOID **)&Current->Next;

        while (!*Waiting) {
            YIELD();

#if DBG

            if (--DebugBreaker == 0) {
                DbgBreakPoint();
            }

#endif

        }

        Next = (struct _KSPIN_LOCK_QUEUE *)*Waiting;
    }

    //
    // Hand the lock to the next waiter.
    //

    Lock = (PULONG)&Next->Lock;
    ASSERT((*Lock & 3) == LOCK_QUEUE_WAIT);

    Current->Next = NULL;

    *Lock ^= (LOCK_QUEUE_WAIT + LOCK_QUEUE_OWNER);
}

#endif


VOID
FASTCALL
KeReleaseQueuedSpinLock (
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN KIRQL OldIrql
    )

/*++

Routine Description:

    Release a (queued) spinlock.   If other processors are waiting
    on this lock, hand the lock to the next in line.

Arguments:

    Number      Queued Spinlock Number.
    OldIrql     IRQL to lower to once the lock has been released.

Return Value:

    None.

--*/

{

#if !defined(NT_UP)

    HalpReleaseQueuedSpinLock(&KeGetCurrentPrcb()->LockQueue[Number]);

#endif

    KfLowerIrql(OldIrql);
}

KIRQL
FASTCALL
KeAcquireQueuedSpinLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    Raise to DISPATCH_LEVEL and acquire the specified queued spinlock.

Arguments:

    Number      Queued Spinlock Number.

Return Value:

    OldIrql     The IRQL prior to raising to DISPATCH_LEVEL.

--*/

{
    KIRQL OldIrql;

    OldIrql = KfRaiseIrql(DISPATCH_LEVEL);

#if !defined(NT_UP)

    HalpAcquireQueuedSpinLock(&(KeGetCurrentPrcb()->LockQueue[Number]));

#endif

    return OldIrql;
}

KIRQL
FASTCALL
KeAcquireQueuedSpinLockRaiseToSynch (
    IN KSPIN_LOCK_QUEUE_NUMBER Number
    )

/*++

Routine Description:

    Raise to SYNCH_LEVEL and acquire the specified queued spinlock.

Arguments:

    Number      Queued Spinlock Number.

Return Value:

    OldIrql     The IRQL prior to raising to SYNCH_LEVEL.

--*/

{
    KIRQL OldIrql;

    OldIrql = KfRaiseIrql(SYNCH_LEVEL);

#if !defined(NT_UP)

    HalpAcquireQueuedSpinLock(&(KeGetCurrentPrcb()->LockQueue[Number]));

#endif

    return OldIrql;
}

LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLock(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    )

/*++

Routine Description:

    Attempt to acquire the specified queued spinlock.  If successful,
    raise IRQL to DISPATCH_LEVEL.

Arguments:

    Number      Queued Spinlock Number.
    OldIrql     Pointer to KIRQL to receive the old IRQL.

Return Value:

    TRUE        if the lock was acquired,
    FALSE       otherwise.

--*/

{

#if !defined(NT_UP)

    LOGICAL Success;

    _disable();
    Success = HalpTryToAcquireQueuedSpinLock(Number);
    if (Success) {
        *OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    }
    _enable();
    return Success;

#else

    *OldIrql = KfRaiseIrql(DISPATCH_LEVEL);
    return TRUE;

#endif
}

LOGICAL
FASTCALL
KeTryToAcquireQueuedSpinLockRaiseToSynch(
    IN KSPIN_LOCK_QUEUE_NUMBER Number,
    IN PKIRQL OldIrql
    )

/*++

Routine Description:

    Attempt to acquire the specified queued spinlock.  If successful,
    raise IRQL to SYNCH_LEVEL.

Arguments:

    Number      Queued Spinlock Number.
    OldIrql     Pointer to KIRQL to receive the old IRQL.

Return Value:

    TRUE        if the lock was acquired,
    FALSE       otherwise.

--*/

{

#if !defined(NT_UP)

    LOGICAL Success;

    _disable();
    Success = HalpTryToAcquireQueuedSpinLock(Number);
    if (Success) {
        *OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    }
    _enable();
    return Success;

#else

    *OldIrql = KfRaiseIrql(SYNCH_LEVEL);
    return TRUE;

#endif
}

VOID
FASTCALL
KeAcquireInStackQueuedSpinLock (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;

#endif

    LockHandle->OldIrql = KeRaiseIrqlToDpcLevel();

#if !defined(NT_UP)

    HalpAcquireQueuedSpinLock(&LockHandle->LockQueue);

#endif

    return;
}


VOID
FASTCALL
KeAcquireInStackQueuedSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock,
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    LockHandle->LockQueue.Next = NULL;
    LockHandle->LockQueue.Lock = SpinLock;

#endif

    LockHandle->OldIrql = KeRaiseIrqlToSynchLevel();

#if !defined(NT_UP)

    HalpAcquireQueuedSpinLock(&LockHandle->LockQueue);

#endif

    return;
}


VOID
FASTCALL
KeReleaseInStackQueuedSpinLock (
    IN PKLOCK_QUEUE_HANDLE LockHandle
    )

{

#if !defined(NT_UP)

    HalpReleaseQueuedSpinLock(&LockHandle->LockQueue);

#endif

    KeLowerIrql(LockHandle->OldIrql);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixstall.asm ===
title  "Stall Execution Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixstall.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (corollary!landy) 04-Dec-92
;       Created this module by moving routines from ixclock.asm to here.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0

;
; Constants used to initialize CMOS/Real Time Clock
;

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate
RTCIRQ                  EQU     8       ; IRQ number for RTC interrupt
REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B

;
; RegisterAInitByte sets 8Hz clock rate, used during init to set up
; KeStallExecutionProcessor, etc.  (See RegASystemClockByte below.)
;

RegisterAInitByte       EQU     00101101B ; RT/CMOS Register 'A' init byte
                                        ; 32.768KHz Base divider rate
                                        ;  8Hz int rate, period = 125.0ms
PeriodInMicroSecond     EQU     125000  ;

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

HalpStallCount  dd      0

_DATA   ends

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Stall Execution Counter"
;++
;
; VOID
; HalpInitializeStallExecution (
;    IN CCHAR ProcessorNumber
;    )
;
; Routine Description:
;
;    This routine initialize the per Microsecond counter for
;    KeStallExecutionProcessor
;
; Arguments:
;
;    ProcessorNumber - Processor Number
;
; Return Value:
;
;    None.
;
; Note:
;
;    Current implementation assumes that all the processors share
;    the same Real Time Clock.  So, the dispatcher database lock is
;    acquired before entering this routine to guarantee only one
;    processor can access the routine.
;
;--

KiseInterruptCount      equ     [ebp-12] ; local variable

cPublicProc _HalpInitializeStallExecution     ,1

ifndef NT_UP
;;
;; This function currently doesn't work from any processor but the
;; boot processor - for now stub out the others
;;

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbNumber, 0
        je      @f

        mov     eax, HalpStallCount
        mov     PCR[PcStallScaleFactor], eax
        stdRET    _HalpInitializeStallExecution
@@:
endif

        push    ebp                     ; save ebp
        mov     ebp, esp                ; set up 12 bytes for local use
        sub     esp, 12

        pushfd                          ; save caller's eflag

;
; Initialize Real Time Clock to interrupt us for every 125ms at
; IRQ 8.
;

        cli                             ; make sure interrupts are disabled

;
; Get and save current 8259 masks
;

        xor     eax,eax

;
; Assume there is no third and fourth PICs
;
; Get interrupt Mask on PIC2
;

        in      al,PIC2_PORT1
        shl     eax, 8

;
; Get interrupt Mask on PIC1
;

        in      al,PIC1_PORT1
        push    eax                     ; save the masks
        mov     eax, NOT (( 1 SHL PIC_SLAVE_IRQ) + (1 SHL RTCIRQ))
                                        ; Mask all the irqs except irq 2 and 8
        SET_8259_MASK                   ; Set 8259's int mask register

;
; Since RTC interrupt will come from IRQ 8, we need to
; Save original irq 8 descriptor and set the descriptor to point to
; our own handler.
;

        sidt    fword ptr [ebp-8]       ; get IDT address
        mov     ecx, [ebp-6]            ; (ecx)->IDT

        mov     eax, (RTCIRQ+PRIMARY_VECTOR_BASE)

        shl     eax, 3                  ; 8 bytes per IDT entry
        add     ecx, eax                ; now at the correct IDT RTC entry

        push    dword ptr [ecx]         ; (TOS) = original desc of IRQ 8
        push    dword ptr [ecx + 4]     ; each descriptor has 8 bytes

        ;
        ; Pushing the appropriate entry address now (instead of
        ; the IDT start address later) to make the pop at the end simpler.
        ;
        push    ecx                     ; (TOS) -> &IDT[HalProfileVector]

        mov     eax, offset FLAT:RealTimeClockHandler

        mov     word ptr [ecx], ax              ; Lower half of handler addr
        mov     word ptr [ecx+2], KGDT_R0_CODE  ; set up selector
        mov     word ptr [ecx+4], D_INT032      ; 386 interrupt gate

        shr     eax, 16                 ; (ax)=higher half of handler addr
        mov     word ptr [ecx+6], ax

        mov     dword ptr KiseinterruptCount, 0 ; set no interrupt yet

        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize
        mov     dword ptr [KiseInterruptCount], 0

        stdCall   _HalpReleaseCmosSpinLock

;
; Now enable the interrupt and start the counter
; (As a matter of fact, only IRQ8 can come through.)
;
        xor     eax, eax                ; (eax) = 0, initialize loopcount
ALIGN 16
        sti
        jmp     kise10

ALIGN 16
kise10:
        sub     eax, 1                  ; increment the loopcount
        jnz     short kise10

if DBG
;
; Counter overflowed
;

        stdCall   _DbgBreakPoint
endif
        jmp     short kise10

;
; Our RealTimeClock interrupt handler.  The control comes here through
; irq 8.
; Note: we discard first real time clock interrupt and compute the
;       permicrosecond loopcount on receiving of the second real time
;       interrupt.  This is because the first interrupt is generated
;       based on the previous real time tick interval.
;

RealTimeClockHandler:

        inc     dword ptr KiseInterruptCount ; increment interrupt count
        cmp     dword ptr KiseInterruptCount,1 ; Is this the first interrupt?
        jnz     kise25                  ; no, its the second go process it
        pop     eax                     ; get rid of original ret addr
        push    offset FLAT:kise10      ; set new return addr


        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock
;
; Dismiss the interrupt.
;
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        xor     eax, eax                ; reset loop counter

        iretd

kise25:

;
; ** temporary - check for incorrect KeStallExecutionProcessorLoopCount
;

if DBG
        cmp     eax, 0
        jnz     short kise30
        stdCall   _DbgBreakPoint

endif
                                         ; never return
;
; ** End temporay code
;

kise30:
        neg     eax
        xor     edx, edx                ; (edx:eax) = divident
        mov     ecx, PeriodInMicroSecond; (ecx) = time spent in the loop
        div     ecx                     ; (eax) = loop count per microsecond
        cmp     edx, 0                  ; Is remainder =0?
        jz      short kise40            ; yes, go kise40
        inc     eax                     ; increment loopcount by 1
kise40:
        mov     PCR[PcStallScaleFactor], eax
        mov     HalpStallCount, eax

;
; Reset return address to kexit
;

        pop     eax                     ; discard original return address
        push    offset FLAT:kexit       ; return to kexit
        mov     eax, (HIGHEST_LEVEL_FOR_8259 - RTCIRQ)

;
; Shutdown periodic interrupt
;
        stdCall   _HalpAcquireCmosSpinLock
        mov     ax,(RegisterAInitByte SHL 8) OR 0AH ; Register A
        CMOS_WRITE                      ; Initialize it
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_DISABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; dismiss pending interrupt
        stdCall   _HalpReleaseCmosSpinLock

;
; Dismiss the interrupt.
;
        mov     eax, RTCIRQ
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        and     word ptr [esp+8], NOT 0200H ; Disable interrupt upon return
        iretd

kexit:                                  ; Interrupts are disabled
        pop     ecx                     ; (ecx) -> &IDT[HalProfileVector]
        pop     [ecx+4]                 ; restore higher half of RTC desc
        pop     [ecx]                   ; restore lower half of RTC desc

        pop     eax                     ; (eax) = origianl 8259 int masks
        SET_8259_MASK

        popfd                           ; restore caller's eflags
        mov     esp, ebp
        pop     ebp                     ; restore ebp
        stdRET    _HalpInitializeStallExecution

stdENDP _HalpInitializeStallExecution

cPublicProc _HalpRemoveFences
        mov     word ptr fence1, 0c98bh
        stdRET    _HalpRemoveFences
stdENDP _HalpRemoveFences

INIT   ends

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Stall Execution"
;++
;
; VOID
; KeStallExecutionProcessor (
;    IN ULONG MicroSeconds
;    )
;
; Routine Description:
;
;    This function stalls execution for the specified number of microseconds.
;    KeStallExecutionProcessor
;
; Arguments:
;
;    MicroSeconds - Supplies the number of microseconds that execution is to be
;        stalled.
;
; Return Value:
;
;    None.
;
;--

MicroSeconds equ [esp + 4]


cPublicProc _KeStallExecutionProcessor       ,1
cPublicFpo 1, 0

;
; Issue a CPUID to implement a "fence"
;
        push    ebx                             ; cpuid uses eax, ebx, ecx, edx
        xor     eax, eax                        ; Processor zero
    .586p
fence1: cpuid
    .386p
        pop     ebx

        mov     ecx, MicroSeconds               ; (ecx) = Microseconds
        jecxz   short kese10                    ; return if no loop needed

        mov     eax, PCR[PcStallScaleFactor]    ; get per microsecond
                                                ; loop count for the processor
        mul     ecx                             ; (eax) = desired loop count

if   DBG
;
; Make sure we the loopcount is less than 4G and is not equal to zero
;

        cmp     edx, 0
        jz      short @f
        int 3

@@:     cmp     eax,0
        jnz     short @f
        int 3
@@:
endif
ALIGN 16
        jmp     kese05

ALIGN 16
kese05: sub     eax, 1                          ; (eax) = (eax) - 1
        jnz     short kese05
kese10:
        stdRET    _KeStallExecutionProcessor

stdENDP _KeStallExecutionProcessor

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixslpctx.asm ===
title  "Sleep Context"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixslpctx.asm
;
; Abstract:
;
;    This module implements the code for saving processor
;    context before putting the machine to sleep.  It also
;    contains the code for building a page that a processor
;    in real mode can jump to in order to transition into
;    p-mode and assume a thread context.
;
; Author:
;
;    Jake Oshins (jakeo) March 13, 1998
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Much of this code has been moved from halmps\i386\mpsproca.asm.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include apic.inc
include i386\ixslpctx.inc
include mac386.inc
        .list

        extrn   _HalpLowStub:DWORD
        extrn   _KeSaveStateForHibernate:proc
ifdef ACPI_HAL        
        EXTRNP  HalpAcpiFlushCache, 0,,FASTCALL
endif

PAGELK16 SEGMENT DWORD PUBLIC USE16 'CODE'       ; start 16 bit code


;++
;
; VOID
; _StartPx_RMStub
;
; Routine Description:
;
;   When a new processor is started, it starts in real-mode and is
;   sent to a copy of this function which has been copied into low memory.
;   (below 1m and accessable from real-mode).
;
;   Once CR0 has been set, this function jmp's to a StartPx_PMStub
;
; Arguments:
;    none
;
; Return Value:
;    does not return, jumps to StartPx_PMStub
;
;--
cPublicProc _StartPx_RMStub  ,0
    cli

    db  066h                            ; load the GDT
    lgdt    fword ptr cs:[SPx_PB.PsSpecialRegisters.SrGdtr]

    db  066h                            ; load the IDT
    lidt    fword ptr cs:[SPx_PB.PsSpecialRegisters.SrIdtr]

    mov     eax, cs:[SPx_TiledCR3]

    nop                                 ; Fill - Ensure 13 non-page split
    nop                                 ; accesses before CR3 load
    nop                                 ; (P6 errata #11 stepping B0)
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop
    nop

    mov     cr3, eax

    ;
    ; Restore CR4 to enable Page Size Extensions
    ; before we got real CR3 which might use Large Page.
    ; If SrCr4 is non-zero, then CR4 exists
    ;

    mov     eax, dword ptr cs:[SPx_PB.PsSpecialRegisters.SrCr4]
    or      eax, eax
    jz      @f
.586p
    mov     cr4, eax
.386p
@@:

    mov     ebp, dword ptr cs:[SPx_P0EBP]
    mov     ecx, dword ptr cs:[SPx_PB.PsContextFrame.CsSegDs]
    mov     ebx, dword ptr cs:[SPx_PB.PsSpecialRegisters.SrCr3]
    mov     eax, dword ptr cs:[SPx_PB.PsSpecialRegisters.SrCr0]
    mov     edi, dword ptr cs:[SPx_flat_addr]

    mov     cr0, eax                    ; into prot mode

    db  066h
    db  0eah                            ; reload cs:eip
SPrxPMStub  dd  0
SPrxFlatCS  dw  0

_StartPx_RMStub_Len      equ     $ - _StartPx_RMStub
stdENDP _StartPx_RMStub


PAGELK16 ends                            ; End 16 bit code

PAGELK    SEGMENT PARA PUBLIC 'CODE'       ; Start 32 bit code
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; StartPx_PMStub
;
; Routine Description:
;
;   This function completes the processor's state loading, and signals
;   the requesting processor that the state has been loaded.
;
; Arguments:
;    ebx    - requested CR3 for this processors_state
;    cx     - requested ds for this processors_state
;    ebp    - EBP of P0
;    edi    - p-mode address of startup block
;
; Return Value:
;    does not return - completes the loading of the processors_state
;
;--
    align   dword    ; to make sure we don't cross a page boundry
            ; before reloading CR3

cPublicProc _StartPx_PMStub  ,0

    ; process is now in the load image copy of this function.
    ; (ie, it's not the low memory copy)

    mov     cr3, ebx                    ; get real CR3
    mov     ds, cx                      ; set real ds

    lea     esi, [edi].SPx_PB.PsSpecialRegisters

    lldt    word ptr ds:[esi].SrLdtr    ; load ldtr

    ;
    ; Force the TSS descriptor into a non-busy state, so we don't fault
    ; when we load the TR.
    ;
    mov     eax, ds:[esi].SrGdtr+2      ; (eax)->GDT base
    xor     ecx, ecx
    mov     cx,  word ptr ds:[esi].SrTr
    add     eax, 5
    add     eax, ecx                    ; (eax)->TSS Desc. Byte
    and     byte ptr [eax],NOT 2

    ltr     word ptr ds:[esi].SrTr      ; load tss

    lea     edx, [edi].SPx_PB.PsContextFrame
    mov     es, word ptr ds:[edx].CsSegEs   ; Set other selectors
    mov     fs, word ptr ds:[edx].CsSegFs
    mov     gs, word ptr ds:[edx].CsSegGs
    mov     ss, word ptr ds:[edx].CsSegSs

    cld                                     ; make lodsd ascending (below)
    xor     eax, eax                        ; disable debug registers while
    mov     dr7, eax                        ; setting them.

    add     esi, SrKernelDr0

    .errnz  (SrKernelDr1 - SrKernelDr0 - 1 * 4)
    .errnz  (SrKernelDr2 - SrKernelDr0 - 2 * 4)
    .errnz  (SrKernelDr3 - SrKernelDr0 - 3 * 4)
    .errnz  (SrKernelDr6 - SrKernelDr0 - 4 * 4)
    .errnz  (SrKernelDr7 - SrKernelDr0 - 5 * 4)

    lodsd
    mov     dr0, eax                    ; load dr0-dr7
    lodsd
    mov     dr1, eax
    lodsd
    mov     dr2, eax
    lodsd
    mov     dr3, eax
    lodsd
    mov     dr6, eax
    lodsd
    mov     dr7, eax

    mov     esp, dword ptr ds:[edx].CsEsp
    mov     ecx, dword ptr ds:[edx].CsEcx

    push    dword ptr ds:[edx].CsEflags
    popfd                               ; load eflags

    push    dword ptr ds:[edx].CsEip    ; make a copy of remaining
    push    dword ptr ds:[edx].CsEax    ; registers which need
    push    dword ptr ds:[edx].CsEbx    ; loaded
    push    dword ptr ds:[edx].CsEdx
    push    dword ptr ds:[edx].CsEsi
    push    dword ptr ds:[edx].CsEdi
    push    dword ptr ds:[edx].CsEbp

    inc     [edi.SPx_flag]              ; Signal p0 that we are
                                        ; done with it's data
    ; Set remaining registers
    pop     ebp
    pop     edi
    pop     esi
    pop     edx
    pop     ebx
    pop     eax
    stdRET  _StartPx_PMStub

stdENDP _StartPx_PMStub

;++
;
; VOID
; StartPx_BuildRealModeStart(
;     IN PUCHAR ParamBlock
;     )
;
; Routine Description:
;
;   This function sets up the real mode startup page
;
; Arguments:
;
;   PxParamBlock -- address of the structure that should end up
;                   at the beginning of HalpLowStub
;
;--

ParamBlockAddress      equ [ebp + 8]
cPublicProc _StartPx_BuildRealModeStart  ,1

        push    ebp
        mov     ebp, esp
        push    ebx
        push    esi
        push    edi

        mov     edx, ParamBlockAddress

        ;
        ; Build a jmp to the start of the Real mode startup code
        ;
        ; This is needed because the Local APIC implementations
        ; use a Startup IPI that must be Page aligned.  The allocation
        ; code int MP_INIT ensures that this is page aligned.  The
        ; original code was written to place the parameter block first.
        ; By adding a jump instruction to the start of the parameter block
        ; we can run either way.
        ;


        mov     eax, size PxParamBlock - 3  ; Jump destination relative to
                                            ;  next instruction
        shl     eax, 8                      ; Need room for jmp instruction
        mov     al,0e9h
        mov     [edx].SPx_Jmp_Inst, eax

        ;
        ;  Save the p-mode address of PxParamBlock
        ;
        mov     eax, _HalpLowStub
        mov     [edx].SPx_flat_addr, eax

        ;
        ; Copy RMStub to low memory
        ;

        mov     esi, OFFSET FLAT:_StartPx_RMStub
        mov     ecx, _StartPx_RMStub_Len

        mov     edi, _HalpLowStub             ; Destination was allocated by MpInit
        add     edi, size PxParamBlock        ; Parameter Block is placed first
        rep     movsb

        ;
        ;  Copy the parameter block to low memory
        ;
        mov     ecx, size PxParamBlock          ; Structure length
        mov     esi, ParamBlockAddress          ; Parameter Block is placed first
        mov     edi, _HalpLowStub               ; Destination Address
        rep     movsb

        ;
        ;  Now we need to create a pointer allowing the Real Mode code to
        ;  Branch to the Protected mode code
        ;
        mov     eax, _HalpLowStub                 ; low memory Address
        add     eax, size PxParamBlock          ; Move past the Parameter block

        ;
        ;  In order to get to the label we need to compute the label offset relative
        ;  to the start of the routine and then use this as a offset from the start of
        ;  the routine ( HalpLowStub + (size PxParamBlock)) in low memory.
        ;
        ;  The following code creates a pointer to (RMStub - StartPx_RMStub)
        ;  which can then be used to access code locations via code labels directly.
        ;  Since the [eax.Label] results in the address (eax + Label) loading eax
        ;  with the pointer created above results in (RMStub - StartPx_RMStub + Label).
        ;
        mov     ebx, OFFSET FLAT:_StartPx_RMStub
        sub     eax, ebx                        ; (eax) = adjusted pointer

        ;
        ;  Patch the real mode code with a valid long jump address, first CS then offset
        ;
        mov     bx, word ptr [edx].SPx_PB.PsContextFrame.CsSegCs
        mov     [eax.SPrxFlatCS], bx
        mov     [eax.SPrxPMStub], offset _StartPx_PMStub

        pop     edi
        pop     esi
        pop     ebx
        pop     ebp

        stdRET  _StartPx_BuildRealModeStart

stdENDP _StartPx_BuildRealModeStart

        subttl  "Save Processor State"
;++
;
; VOID
; HalpSaveProcessorStateAndWait(
;    IN PKPROCESSOR_STATE ProcessorState
;   )
;
; Routine Description:
;
;   This function saves the volatile, non-volatile and special register
;   state of the current processor.
;
;   N.B.  Floating point state is NOT captured.
;
; Arguments:
;
;    ProcessorState  (esp+4) - Address of processor state record to fill in.
;
;    pBarrier  - Address of a value to use as a lock.
;
; Return Value:
;
;    None. This function does not return.
;
;--

ProcessorState  equ [esp + 8]
pBarrier        equ dword ptr [esp + 12]

cPublicProc _HalpSaveProcessorStateAndWait,2

        push    ebx
        mov     ebx, ProcessorState

        cmp     ebx, 0  ; if this isn't filled in, don't save context
        jz      hspsaw_statesaved
        
        ;
        ; Fill in ProcessorState
        ;

        push    ebx
        call    _KeSaveStateForHibernate        ; _cdecl function
        add     esp, 4

        ;; Save return address, not caller's return address
        mov     eax,[esp+4]
        mov     [ebx.PsContextFrame.CsEip],eax

        ;; Save caller's ebp, not caller's return ebp.
        mov     [ebx.PsContextFrame.CsEbp],ebp

        ;; Set ESP to value just before this function call
        lea     eax,[esp+16]
        mov     [ebx.PsContextFrame.CsEsp],eax

hspsaw_statesaved:
ifdef ACPI_HAL        
        ;
        ; Flush the cache, as the processor may be about
        ; to power off.
        ;
        
        fstCall HalpAcpiFlushCache
endif        
        ;
        ; Signal that this processor has saved its state
        ;

        mov     ebx, pBarrier
        lock inc dword ptr [ebx]

        ;
        ; Wait for the hibernation file to be written.
        ; Processor 0 will zero Barrier when it is
        ; finished.
        ;
        ; N.B.  We can't return from this function
        ; before the hibernation file is finished
        ; because we would be tearing down the very same
        ; stack that we will be jumping onto when the
        ; processor resumes.  But after the hibernation
        ; file is written, it doesn't matter, because
        ; the stack will be restored from disk.
        ;
hspsaw_spin:

        YIELD
        cmp     dword ptr [ebx], 0
        jne     hspsaw_spin

        ;
        ; Invalidate the processor cache so that any stray gamma
        ; rays (I'm serious) that may have flipped cache bits
        ; while in S1 will be ignored.
        ;
        ; Honestly.  Intel asked for this.  I'm serious.
        ;
;.586        
;        invd
;.386        

        pop     ebx

        stdRET    _HalpSaveProcessorStateAndWait

stdENDP _HalpSaveProcessorStateAndWait

PAGELK    ends                            ; end 32 bit code

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixslpsup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixslpsup.c

Abstract:

    This file provides the code that saves and restores
    state for traditional motherboard devices when the
    system goes into a sleep state that removes power.

    This code is included in multiple HALs.

Author:

    Jake Oshins (jakeo) May 6, 1997

Revision History:

--*/
#include "halp.h"
#include "ixsleep.h"

#if defined(APIC_HAL)
#include "apic.inc"
#include "..\..\halmps\i386\pcmp_nt.inc"

VOID
StartPx_RMStub(
    VOID
    );
#endif

typedef struct _SAVE_CONTEXT_DPC_CONTEXT {
    PVOID   SaveArea;
    volatile ULONG Complete;
} SAVE_CONTEXT_DPC_CONTEXT, *PSAVE_CONTEXT_DPC_CONTEXT;

VOID
HalpSaveContextTargetProcessor (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    );

#ifdef WANT_IRQ_ROUTING
#include "ixpciir.h"
#endif
extern UCHAR HalpAsmDataMarker;
extern PVOID   HalpEisaControlBase;
extern ULONG   HalpIrqMiniportInitialized;

PKPROCESSOR_STATE   HalpHiberProcState;
ULONG               CurTiledCr3LowPart;
PPHYSICAL_ADDRESS   HalpTiledCr3Addresses;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliLocateHiberRanges)
#pragma alloc_text(PAGELK, HalpSavePicState)
#pragma alloc_text(PAGELK, HalpSaveDmaControllerState)
#pragma alloc_text(PAGELK, HalpSaveTimerState)
#pragma alloc_text(PAGELK, HalpRestorePicState)
#pragma alloc_text(PAGELK, HalpRestoreDmaControllerState)
#pragma alloc_text(PAGELK, HalpRestoreTimerState)
#pragma alloc_text(PAGELK, HalpBuildResumeStructures)
#pragma alloc_text(PAGELK, HalpFreeResumeStructures)
#pragma alloc_text(PAGELK, HalpSaveContextTargetProcessor)
#endif


#define EISA_CONTROL (PUCHAR)&((PEISA_CONTROL) HalpEisaControlBase)


VOID
HalpPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    )
{
    ULONG       action = PtrToUlong(Argument1);
    ULONG       state  = PtrToUlong(Argument2);

    if (action == PO_CB_SYSTEM_STATE_LOCK) {

        switch (state) {
        case 0:

            //
            // Lock down everything in the PAGELK code section.  (We chose
            // HalpSaveDmaControllerState because it exists in every HAL.)
            //

            HalpSleepPageLock = MmLockPagableCodeSection((PVOID)HalpSaveDmaControllerState);
#if defined(APIC_HAL)
            HalpSleepPage16Lock = MmLockPagableCodeSection((PVOID) StartPx_RMStub );
#endif

#ifdef ACPI_HAL

            HalpMapNvsArea();
#endif
            break;

        case 1:                 // unlock it all

            MmUnlockPagableImageSection(HalpSleepPageLock);
#ifdef APIC_HAL
            MmUnlockPagableImageSection(HalpSleepPage16Lock);
#endif

#ifdef ACPI_HAL
            HalpFreeNvsBuffers();
#endif
        }
    }

    return;
}

VOID
HalpSavePicState(
    VOID
    )
{
    HalpMotherboardState.PicState.MasterMask =
        READ_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1);

    HalpMotherboardState.PicState.SlaveMask =
        READ_PORT_UCHAR(EISA_CONTROL->Interrupt2ControlPort1);

#if !defined(ACPI_HAL)

#ifdef WANT_IRQ_ROUTING
    if(HalpIrqMiniportInitialized)
    {
        ULONG elcrMask = 0;

        PciirqmpGetTrigger(&elcrMask);
        HalpMotherboardState.PicState.MasterEdgeLevelControl = (UCHAR)((elcrMask >> 8) & 0xFF);
        HalpMotherboardState.PicState.SlaveEdgeLevelControl = (UCHAR)(elcrMask & 0xFF);
    }
    else
    {
#endif
        if (HalpBusType == MACHINE_TYPE_EISA) {
#endif
            HalpMotherboardState.PicState.MasterEdgeLevelControl =
                READ_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel);

            HalpMotherboardState.PicState.SlaveEdgeLevelControl =
                READ_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel);

#if !defined(ACPI_HAL)
        }
#ifdef WANT_IRQ_ROUTING
    }
#endif
#endif
}

VOID
HalpRestorePicState(
    VOID
    )
{
    ULONG flags;


    flags = HalpDisableInterrupts();

    HalpInitializePICs(FALSE);

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1,
                     HalpMotherboardState.PicState.MasterMask);

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2ControlPort1,
                     HalpMotherboardState.PicState.SlaveMask);

    //
    // For halx86, the PCI interrupt vector programming
    // is static, so this code can just restore everything.
    //

    HalpRestorePicEdgeLevelRegister();

    HalpRestoreInterrupts(flags);
}

VOID
HalpRestorePicEdgeLevelRegister(
    VOID
    )
{
#if !defined(ACPI_HAL)
#ifdef WANT_IRQ_ROUTING
    if(HalpIrqMiniportInitialized)
    {
        PLINK_NODE  linkNode;
        PLINK_STATE temp;
        ULONG       elcrMask = (HalpMotherboardState.PicState.MasterEdgeLevelControl << 8) |
                                           HalpMotherboardState.PicState.SlaveEdgeLevelControl;

        PciirqmpSetTrigger(elcrMask);

        //
        // Reprogram all links.
        //

        for (   linkNode = HalpPciIrqRoutingInfo.LinkNodeHead;
                linkNode;
                linkNode = linkNode->Next)
        {
            //
            // Swap the possible with the allocation.
            //

            temp = linkNode->Allocation;
            linkNode->Allocation = linkNode->PossibleAllocation;
            linkNode->PossibleAllocation = temp;
            HalpCommitLink(linkNode);
        }

    }
    else
    {
#endif
        if (HalpBusType == MACHINE_TYPE_EISA) {
#endif

            WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel,
                             HalpMotherboardState.PicState.MasterEdgeLevelControl);

            WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel,
                             HalpMotherboardState.PicState.SlaveEdgeLevelControl);
#if !defined(ACPI_HAL)
        }
#ifdef WANT_IRQ_ROUTING
    }
#endif
#endif
}

VOID
HalpSaveDmaControllerState(
    VOID
    )
{
}

VOID
HalpRestoreDmaControllerState(
    VOID
    )
/*++
Routine Description:

    This function puts the DMA controller back into the
    same state it was in before the machine went to sleep.

Arguments:

    None.

Notes:

    Normally, the DMA controller structures would be guarded
    by spinlocks.  But this function is called with interrupts
    turned off and all but one processor spinning.

--*/
{
    UCHAR   i;

    WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.AllMask,0xF);
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.AllMask,0xE);
    HalpIoDelay();

    //
    //Reset the DMA command registers
    //
#if defined(NEC_98)
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.DmaStatus,0x40);
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.DmaStatus,0x40);
#else
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.DmaStatus,0);
    WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.DmaStatus,0);
#endif
    HalpIoDelay();

    for (i = 0; i < (EISA_DMA_CHANNELS / 2); i++) {

        //
        // Check to see if the array contains a value for this channel.
        //
        if (HalpDmaChannelState[i].ChannelProgrammed) {

            WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.Mode,
                             HalpDmaChannelState[i].ChannelMode);

            if (HalpEisaDma) {
                WRITE_PORT_UCHAR(EISA_CONTROL->Dma1ExtendedModePort,
                              HalpDmaChannelState[i].ChannelExtendedMode);
            }

            WRITE_PORT_UCHAR(EISA_CONTROL->Dma1BasePort.SingleMask,
                             HalpDmaChannelState[i].ChannelMask);

            HalpIoDelay();
        }
    }

    for (i = (EISA_DMA_CHANNELS / 2); i < EISA_DMA_CHANNELS; i++) {

        //
        // Check to see if the array contains a value for this channel.
        //
        if (HalpDmaChannelState[i].ChannelProgrammed) {

            WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.Mode,
                             HalpDmaChannelState[i].ChannelMode);

            if (HalpEisaDma) {
                WRITE_PORT_UCHAR(EISA_CONTROL->Dma2ExtendedModePort,
                             HalpDmaChannelState[i].ChannelExtendedMode);
            }

            WRITE_PORT_UCHAR(EISA_CONTROL->Dma2BasePort.SingleMask,
                             HalpDmaChannelState[i].ChannelMask);

            HalpIoDelay();
        }
    }
}


VOID
HalpSaveTimerState(
    VOID
    )
{
}

VOID
HalpRestoreTimerState(
    VOID
    )
{
    HalpInitializeClock();
}

VOID
HaliLocateHiberRanges (
    IN PVOID MemoryMap
    )
{
    //
    // Mark the hal's data section as needed to be cloned
    //

    PoSetHiberRange (
        MemoryMap,
        PO_MEM_CLONE,
        (PVOID) &HalpFeatureBits,
        0,
        'dlah'
        );

#if defined(_HALPAE_)

    //
    // Mark DMA buffers as not needing to be saved.
    //

    if (MasterAdapter24.MapBufferSize != 0) {
        PoSetHiberRange( MemoryMap,
                         PO_MEM_DISCARD | PO_MEM_PAGE_ADDRESS,
                         (PVOID)(ULONG_PTR)(MasterAdapter24.MapBufferPhysicalAddress.LowPart >>
                                     PAGE_SHIFT),
                         MasterAdapter24.MapBufferSize >> PAGE_SHIFT,
                         'mlah' );
    }

    if (MasterAdapter32.MapBufferSize != 0) {
        PoSetHiberRange( MemoryMap,
                         PO_MEM_DISCARD | PO_MEM_PAGE_ADDRESS,
                         (PVOID)(ULONG_PTR)(MasterAdapter32.MapBufferPhysicalAddress.LowPart >>
                                     PAGE_SHIFT),
                         MasterAdapter32.MapBufferSize >> PAGE_SHIFT,
                         'mlah' );
    }

#else

    //
    // Mark DMA buffer has not needing saved
    //

    if (HalpMapBufferSize) {
        PoSetHiberRange (
            MemoryMap,
            PO_MEM_DISCARD | PO_MEM_PAGE_ADDRESS,
            (PVOID) (HalpMapBufferPhysicalAddress.LowPart >> PAGE_SHIFT),
            HalpMapBufferSize >> PAGE_SHIFT,
            'mlah'
            );
    }

#endif
}

NTSTATUS
HalpBuildResumeStructures(
    VOID
    )
{
    KAFFINITY   CurrentAffinity, ActiveProcessors;
    ULONG       ProcNum, Processor, NumberProcessors = 1;
    KDPC        Dpc;
    SAVE_CONTEXT_DPC_CONTEXT    Context;

    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);

#if defined(APIC_HAL)
    //
    // If KeActiveProcessors() were callable at 
    // DISPATCH_LEVEL, I would use that.
    //

    NumberProcessors = HalpMpInfoTable.NtProcessors;
#endif    
    ActiveProcessors = (1 << NumberProcessors) - 1;

#if defined(APIC_HAL) || defined(ACPI_HAL)
    //
    // Allocate space to save processor context for other processors
    //

    HalpTiledCr3Addresses = NULL;

    HalpHiberProcState =
        ExAllocatePoolWithTag(NonPagedPool,
            (NumberProcessors * sizeof(KPROCESSOR_STATE)),
             HAL_POOL_TAG);

    if (!HalpHiberProcState) {
        goto BuildResumeStructuresError;
    }

    RtlZeroMemory(HalpHiberProcState,
                  NumberProcessors * sizeof(KPROCESSOR_STATE));

    //
    // Allocate space for tiled CR3 for all processors
    //

    HalpTiledCr3Addresses =
        ExAllocatePoolWithTag(NonPagedPool,
            (NumberProcessors * sizeof(PHYSICAL_ADDRESS)),
             HAL_POOL_TAG);

    if (!HalpTiledCr3Addresses) {
        goto BuildResumeStructuresError;
    }

    RtlZeroMemory(HalpTiledCr3Addresses,
                  (NumberProcessors * sizeof(PHYSICAL_ADDRESS)));

    //
    // Get IDT and GDT for all processors except BSP,
    // map and save tiled CR3
    //

    KeInitializeDpc (&Dpc, HalpSaveContextTargetProcessor, &Context);
    KeSetImportanceDpc (&Dpc, HighImportance);

    ProcNum = 0;
    CurrentAffinity = 1;
    Processor = 0;
    
    while (ActiveProcessors) {
        if (ActiveProcessors & CurrentAffinity) {
        
            ActiveProcessors &= ~CurrentAffinity;
    
            RtlZeroMemory(&Context, sizeof(Context));
            Context.SaveArea = &(HalpHiberProcState[ProcNum]);
    
            if (Processor == (KeGetPcr())->Prcb->Number) {
    
                //
                // We're running on this processor.  Just call
                // the DPC routine from here.
    
                HalpSaveContextTargetProcessor(&Dpc, &Context, NULL, NULL);
    
            } else {
    
                //
                // Issue DPC to target processor
                //
    
                KeSetTargetProcessorDpc (&Dpc, (CCHAR) Processor);
                KeInsertQueueDpc (&Dpc, NULL, NULL);
    
                //
                // Wait for DPC to be complete.
                //
                while (Context.Complete == FALSE); 
            }

            ProcNum++;
        }
        
        Processor++;
        CurrentAffinity <<= 1;
    }
    
    for (ProcNum = 0; ProcNum < NumberProcessors; ProcNum++) {
        HalpTiledCr3Addresses[ProcNum].LowPart =
                HalpBuildTiledCR3Ex(&(HalpHiberProcState[ProcNum]),ProcNum);
    }
#endif

    return STATUS_SUCCESS;

#if defined(APIC_HAL) || defined(ACPI_HAL)
BuildResumeStructuresError:

    if (HalpHiberProcState) ExFreePool(HalpHiberProcState);
    if (HalpTiledCr3Addresses) ExFreePool(HalpTiledCr3Addresses);
    return STATUS_UNSUCCESSFUL;
#endif
}

NTSTATUS
HalpFreeResumeStructures(
    VOID
    )
{
    ULONG       ProcNum, NumberProcessors = 1;
    
#if defined(APIC_HAL)
    NumberProcessors = HalpMpInfoTable.NtProcessors;
#endif
    
#if defined(APIC_HAL) || defined(ACPI_HAL)

    if (HalpHiberProcState)  {
        ExFreePool(HalpHiberProcState);
        HalpHiberProcState = NULL;
    }

    if (HalpTiledCr3Addresses) {
        ExFreePool(HalpTiledCr3Addresses);
        HalpTiledCr3Addresses = NULL;
    }

    for (ProcNum = 0; ProcNum < NumberProcessors; ProcNum++) {
            HalpFreeTiledCR3Ex(ProcNum);
    }
#endif
    return STATUS_SUCCESS;
}

VOID
HalpSaveContextTargetProcessor (
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemArgument1,
    IN PVOID    SystemArgument2
    )
{
    PSAVE_CONTEXT_DPC_CONTEXT Context = (PSAVE_CONTEXT_DPC_CONTEXT)DeferredContext;

    KeSaveStateForHibernate(Context->SaveArea);
    InterlockedIncrement(&Context->Complete);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixswint.asm ===
title   "Software Interrupts"

;++
;
; Copyright (c) 1992  Microsoft Corporation
;
; Module Name:
;
;    ixswint.asm
;
; Abstract:
;
;    This module implements the software interrupt handlers
;    for x86 machines
;
; Author:
;
;    John Vert (jvert) 2-Jan-1992
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
        .list

        EXTRNP  _KiDeliverApc,3,IMPORT
        EXTRNP  _KiDispatchInterrupt,0,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        extrn   SWInterruptHandlerTable:dword
        extrn   SWInterruptLookUpTable:byte
ifdef IRQL_METRICS
        extrn   HalApcSoftwareIntCount:dword
        extrn   HalDpcSoftwareIntCount:dword
endif

_TEXT$02   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalRequestSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;    This routine is used to request a software interrupt to the
;    system. Also, this routine checks to see if any software
;    interrupt should be generated.
;    The following condition will cause software interrupt to
;    be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalRequestSoftwareInterrupt ,1
cPublicFpo 0, 1

        mov     eax,1
        shl     eax, cl                 ; convert to mask
        pushfd                          ; save interrupt mode
        cli                             ; disable interrupt
        or      PCR[PcIRR], eax         ; set the request bit
        mov     cl, PCR[PcIrql]         ; get current IRQL

        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        and     eax, 3                  ; mask off pending HW interrupts

        xor     edx, edx
        mov     dl, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     dl, cl                  ; Is highest SW int level > irql?
        jbe     short KsiExit           ; No, jmp ksiexit
        call    SWInterruptHandlerTable[edx*4] ; yes, simulate interrupt
                                        ; to the appropriate handler
KsiExit:
        popfd                           ; restore original interrupt mode
        fstRET  HalRequestSoftwareInterrupt

fstENDP HalRequestSoftwareInterrupt

        page ,132
        subttl  "Request Software Interrupt"

;++
;
; VOID
; HalClearSoftwareInterrupt (
;    IN KIRQL RequestIrql
;    )
;
; Routine Description:
;
;   This routine is used to clear a possible pending software interrupt.
;   Support for this function is optional, and allows the kernel to
;   reduce the number of spurious software interrupts it receives/
;
; Arguments:
;
;    (cl) = RequestIrql - Supplies the request IRQL value
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall HalClearSoftwareInterrupt ,1
cPublicFpo 0, 0

        mov     eax,1
        shl     eax, cl                 ; convert to mask

        not     eax
        and     PCR[PcIRR], eax         ; clear pending irr bit

        fstRET  HalClearSoftwareInterrupt

fstENDP HalClearSoftwareInterrupt



        page ,132
        subttl  "Dispatch Interrupt"
;++
;
; VOID
; HalpDispatchInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is the interrupt handler for a software interrupt generated
;    at DISPATCH_LEVEL.  Its function is to save the machine state, raise
;    Irql to DISPATCH_LEVEL, dismiss the interrupt, and call the DPC
;    delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST hdpi_a, hdpi_t

        align dword
        public _HalpDispatchInterrupt
_HalpDispatchInterrupt proc
ifdef IRQL_METRICS
        lock inc HalDpcSoftwareIntCount
endif
;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state on trap frame
;

        ENTER_INTERRUPT hdpi_a, hdpi_t
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )

        public  _HalpDispatchInterrupt2ndEntry
_HalpDispatchInterrupt2ndEntry:

; Save previous IRQL and set new priority level

        push    PCR[PcIrql]                       ; save previous IRQL
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL; set new irql
        and     dword ptr PCR[PcIRR], not (1 shl DISPATCH_LEVEL) ; clear the pending bit in IRR

;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; Go do Dispatch Interrupt processing
;
        stdCall   _KiDispatchInterrupt

;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                          ; will do an iret

_HalpDispatchInterrupt endp

        page ,132
        subttl  "APC Interrupt"
;++
;
; HalpApcInterrupt(
;       VOID
;       );
;
; Routine Description:
;
;    This routine is entered as the result of a software interrupt generated
;    at APC_LEVEL. Its function is to save the machine state, raise Irql to
;    APC_LEVEL, dismiss the interrupt, and call the APC delivery routine.
;
; Arguments:
;
;    None
;    Interrupt is Disabled
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST hapc_a, hapc_t

        align dword
        public _HalpApcInterrupt
_HalpApcInterrupt proc
ifdef IRQL_METRICS
        lock inc HalApcSoftwareIntCount
endif
;
; Create IRET frame on stack
;
        pop     eax
        pushfd
        push    cs
        push    eax

;
; Save machine state in trap frame
;
        ENTER_INTERRUPT hapc_a, hapc_t
.FPO ( FPO_LOCALS+1, 0, 0, 0, 0, FPO_TRAPFRAME )


        public     _HalpApcInterrupt2ndEntry
_HalpApcInterrupt2ndEntry:

;
; Save previous IRQL and set new priority level
;

        push    PCR[PcIrql]              ; save previous Irql
        mov     byte ptr PCR[PcIrql], APC_LEVEL   ; set new Irql
        and     dword ptr PCR[PcIRR], not (1 shl APC_LEVEL) ; dismiss pending APC
;
; Now it is safe to enable interrupt to allow higher priority interrupt
; to come in.
;

        sti

;
; call the APC delivery routine.
;

        mov     eax, [ebp]+TsSegCs      ; get interrupted code's CS
        and     eax, MODE_MASK          ; extract the mode

        test    dword ptr [ebp]+TsEFlags, EFLAGS_V86_MASK
        jz      short @f

        or      eax, MODE_MASK          ; If v86 frame, then set user_mode
@@:

;
; call APC deliver routine
;       Previous mode
;       Null exception frame
;       Trap frame

        stdCall   _KiDeliverApc, <eax, 0,ebp>

;
;
; Do interrupt exit processing
;

        SOFT_INTERRUPT_EXIT                  ; will do an iret

_HalpApcInterrupt       endp

_TEXT$02   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixreboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixreboot.c

Abstract:

    Provides the interface to the firmware for x86.  Since there is no
    firmware to speak of on x86, this is just reboot support.

Author:

    John Vert (jvert) 12-Aug-1991

Revision History:

--*/

//
// This module is compatible with PAE mode and therefore treats physical
// addresses as 64-bit entities.
//

#if !defined(_PHYS64_)
#define _PHYS64_
#endif

#include "halp.h"
#include "pci.h"

#ifdef ACPI_HAL
#include "acpitabl.h"
#include "xxacpi.h"
extern UCHAR   HalpPiix4;
#endif


//
// Defines to let us diddle the CMOS clock and the keyboard
//

#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64

//
// Private function prototypes
//

VOID
HalpReboot (
    VOID
    )

/*++

Routine Description:

    This procedure resets the CMOS clock to the standard timer settings
    so the bios will work, and then issues a reset command to the keyboard
    to cause a warm boot.

    It is very machine dependent, this implementation is intended for
    PC-AT like machines.

    This code copied from the "old debugger" sources.

    N.B.

        Will NOT return.

--*/

{
    UCHAR   Scratch;
    PUSHORT Magic;
    PUCHAR  ResetAddress;
    PHYSICAL_ADDRESS zeroPhysical;
    PCI_SLOT_NUMBER slot;

    //
    // By sticking 0x1234 at physical location 0x472, we can bypass the
    // memory check after a reboot.
    //

    zeroPhysical.QuadPart = 0;
    Magic = HalpMapPhysicalMemory(zeroPhysical, 1);
    if (Magic) {
        Magic[0x472 / sizeof(USHORT)] = 0x1234;
    }

    //
    // Turn off interrupts
    //

    HalpAcquireCmosSpinLock();
    HalpDisableInterrupts();

    //
    // Reset the cmos clock to a standard value
    // (We are setting the periodic interrupt control on the MC147818)
    //

    //
    // Disable periodic interrupt
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x0b);      // Set up for control reg B.
    KeStallExecutionProcessor(1);

    Scratch = READ_PORT_UCHAR(CMOS_DATA);
    KeStallExecutionProcessor(1);

    Scratch &= 0xbf;                        // Clear periodic interrupt enable

    WRITE_PORT_UCHAR(CMOS_DATA, Scratch);
    KeStallExecutionProcessor(1);

    //
    // Set "standard" divider rate
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x0a);      // Set up for control reg A.
    KeStallExecutionProcessor(1);

    Scratch = READ_PORT_UCHAR(CMOS_DATA);
    KeStallExecutionProcessor(1);

    Scratch &= 0xf0;                        // Clear rate setting
    Scratch |= 6;                           // Set default rate and divider

    WRITE_PORT_UCHAR(CMOS_DATA, Scratch);
    KeStallExecutionProcessor(1);

    //
    // Set a "neutral" cmos address to prevent weirdness
    // (Why is this needed? Source this was copied from doesn't say)
    //

    WRITE_PORT_UCHAR(CMOS_CTRL, 0x15);
    KeStallExecutionProcessor(1);

    HalpResetAllProcessors();

#ifdef ACPI_HAL

    if ((HalpFixedAcpiDescTable.Header.Revision > 1) && 
        (HalpFixedAcpiDescTable.flags & RESET_CAP)) {

        switch (HalpFixedAcpiDescTable.reset_reg.AddressSpaceID) {
        case 0:         // Memory
            
            ResetAddress = 
                HalpMapPhysicalMemory(HalpFixedAcpiDescTable.reset_reg.Address, 1);
            
            WRITE_REGISTER_UCHAR(ResetAddress, 
                                 HalpFixedAcpiDescTable.reset_val);
            break;

        case 1:         // I/O

            WRITE_PORT_UCHAR((PUCHAR)(ULONG_PTR)HalpFixedAcpiDescTable.reset_reg.Address.LowPart,
                             HalpFixedAcpiDescTable.reset_val);
            break;

        case 2:         // PCI Config

            slot.u.AsULONG = 0;
            slot.u.bits.DeviceNumber = 
                HalpFixedAcpiDescTable.reset_reg.Address.HighPart;
            slot.u.bits.FunctionNumber = 
                HalpFixedAcpiDescTable.reset_reg.Address.LowPart >> 16;
            
            HalSetBusDataByOffset(PCIBus,
                                  0,
                                  slot.u.AsULONG,
                                  &HalpFixedAcpiDescTable.reset_val,
                                  HalpFixedAcpiDescTable.reset_reg.Address.LowPart & 0xff,
                                  1);
            break;
        }
    }

#endif
    
    //
    // If we return, send the reset command to the keyboard controller
    //

    WRITE_PORT_UCHAR(KEYBPORT, RESET);

    HalpHalt();
}



#ifndef ACPI_HAL

VOID
HaliHaltSystem (
    VOID
    )

/*++

Routine Description:

    This procedure is called when the machine has crashed and is to be
    halted

    N.B.

        Will NOT return.

--*/

{
    _asm {
        cli
        hlt
    }
}

VOID
HalpCheckPowerButton (
    VOID
    )
{
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixsysbus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixsysbus.c

Abstract:

Author:

Environment:

Revision History:


--*/

#include "halp.h"
#ifdef WANT_IRQ_ROUTING
#include "ixpciir.h"
#endif

KAFFINITY HalpDefaultInterruptAffinity;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpGetSystemInterruptVector)
#pragma alloc_text(PAGE,HalTranslatorReference)
#pragma alloc_text(PAGE,HalTranslatorDereference)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesRoot)
#pragma alloc_text(PAGE,HalIrqTranslateResourceRequirementsRoot)
#pragma alloc_text(PAGE,HalpTransMemIoResource)
#pragma alloc_text(PAGE,HalpTransMemIoResourceRequirement)
#pragma alloc_text(PAGE,HaliGetInterruptTranslator)
#endif

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    )

/*++

Routine Description:

    This routine performs a very similar function to HalTranslateBusAddress
    except that InterfaceType and BusNumber are not known by the caller.
    This function will walk all busses known by the HAL looking for a
    valid translation for the input BusAddress of type AddressSpace.

    This function is recallable using the input/output Context parameter.
    On the first call to this routine for a given translation the ULONG_PTR
    Context should be NULL.  Note:  Not the address of it but the contents.

    If the caller decides the returned translation is not the desired
    translation, it calls this routine again passing Context in as it
    was returned on the previous call.  This allows this routine to
    traverse the bus structures until the correct translation is found
    and is provided because on multiple bus systems, it is possible for
    the same resource to exist in the independent address spaces of
    multiple busses.

Arguments:

    BusAddress          Address to be translated.
    AddressSpace        0 = Memory
                        1 = IO (There are other possibilities).
                        N.B. This argument is a pointer, the value
                        will be modified if the translated address
                        is of a different address space type from
                        the untranslated bus address.
    TranslatedAddress   Pointer to where the translated address
                        should be stored.
    Context             Pointer to a ULONG_PTR. On the initial call,
                        for a given BusAddress, it should contain
                        0.  It will be modified by this routine,
                        on subsequent calls for the same BusAddress
                        the value should be handed in again,
                        unmodified by the caller.
    NextBus             FALSE if we should attempt this translation
                        on the same bus as indicated by Context,
                        TRUE if we should be looking for another
                        bus.

Return Value:

    TRUE    if translation was successful,
    FALSE   otherwise.

--*/

{
    //
    // First, make sure the context parameter was supplied and is
    // being used correctly.  This also ensures that the caller
    // doesn't get stuck in a loop looking for subsequent translations
    // for the same thing.  We won't succeed the same translation twice
    // unless the caller reinits the context.
    //

    if ((!Context) || (*Context && (NextBus == TRUE))) {
        return FALSE;
    }
    *Context = 1;

    //
    // PC/AT (halx86) case is simplest, there is no translation.
    //

    *TranslatedAddress = BusAddress;
    return TRUE;
}

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    PSUPPORTED_RANGE    pRange;

    pRange = NULL;

    //
    // If this fails, it means someone has given us a RESOURCE_TYPE with some decode type flags
    // set. We should probably handle this.
    //

    ASSERT (*AddressSpace == 0 ||
            *AddressSpace == 1);

    //
    // The checking of bus ranges for PCI busses is performed by the PCI driver
    // in NT5 (or Windows 2000 or whatever its called) so only check for none
    // PCI busses.
    //


    switch (*AddressSpace) {
    case 0:

        if (BusHandler->InterfaceType != PCIBus) {

           // verify memory address is within buses memory limits
           for (pRange = &BusHandler->BusAddresses->PrefetchMemory; pRange; pRange = pRange->Next) {
                if (BusAddress.QuadPart >= pRange->Base &&
                    BusAddress.QuadPart <= pRange->Limit) {
                    break;
                }
           }

           if (!pRange) {
               for (pRange = &BusHandler->BusAddresses->Memory; pRange; pRange = pRange->Next) {
                    if (BusAddress.QuadPart >= pRange->Base &&
                        BusAddress.QuadPart <= pRange->Limit) {
                        break;
                    }
               }
           }

        } else {
            //
            // This is a PCI bus and SystemBase is constant for all ranges
            //

            pRange = &BusHandler->BusAddresses->Memory;
        }

        break;

    case 1:

        if (BusHandler->InterfaceType != PCIBus) {

            // verify IO address is within buses IO limits
            for (pRange = &BusHandler->BusAddresses->IO; pRange; pRange = pRange->Next) {
                if (BusAddress.QuadPart >= pRange->Base &&
                    BusAddress.QuadPart <= pRange->Limit) {
                    break;
                }
            }
            break;

        } else {
            //
            // This is a PCI bus and SystemBase is constant for all ranges
            //

            pRange = &BusHandler->BusAddresses->IO;

        }
    }


    if (pRange) {
        TranslatedAddress->QuadPart = BusAddress.QuadPart + pRange->SystemBase;
        *AddressSpace = pRange->SystemAddressSpace;
        return TRUE;
    }

    return FALSE;
}


ULONG
HalpGetRootInterruptVector(
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
{
    ULONG SystemVector;
    
    UNREFERENCED_PARAMETER( InterruptLevel );

    SystemVector = InterruptLevel + PRIMARY_VECTOR_BASE;
    
    if ((SystemVector < PRIMARY_VECTOR_BASE) ||
        (SystemVector > PRIMARY_VECTOR_BASE + HIGHEST_LEVEL_FOR_8259) ) {

        //
        // This is an illegal BusInterruptVector and cannot be connected.
        //

        return(0);
    }
    
    *Irql = (KIRQL)(HIGHEST_LEVEL_FOR_8259 + PRIMARY_VECTOR_BASE - SystemVector);
    *Affinity = HalpDefaultInterruptAffinity;
    ASSERT(HalpDefaultInterruptAffinity);

    return SystemVector;

}

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

Arguments:

    BusInterruptLevel - Supplies the bus specific interrupt level.

    BusInterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG SystemVector;

    UNREFERENCED_PARAMETER( BusHandler );
    UNREFERENCED_PARAMETER( RootHandler );

    SystemVector = HalpGetRootInterruptVector(BusInterruptLevel,
                                              BusInterruptVector,
                                              Irql,
                                              Affinity);
    
    if (HalpIDTUsageFlags[SystemVector].Flags & IDTOwned ) {

        //
        // This is an illegal BusInterruptVector and cannot be connected.
        //

        return(0);
    }

    return SystemVector;
}

//
// This section implements a "translator," which is the PnP-WDM way
// of doing the same thing that the first part of this file does.
//
VOID
HalTranslatorReference(
    PVOID Context
    )
{
    return;
}

VOID
HalTranslatorDereference(
    PVOID Context
    )
{
    return;
}

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function takes a CM_PARTIAL_RESOURCE_DESCRIPTOR and translates
    it to an IO-bus-relative from a Processor-bus-relative form, or the other
    way around.  In this x86-specific example, an IO-bus-relative form is the
    ISA IRQ and the Processor-bus-relative form is the IDT entry and the
    associated IRQL.

    N.B.  This funtion has an associated "Direction."  These are not exactly
          reciprocals.  This has to be the case because the output from
          HalIrqTranslateResourceRequirementsRoot will be used as the input
          for the ParentToChild case.

          ChildToParent:

            Level  (ISA IRQ)        -> IRQL
            Vector (ISA IRQ)        -> x86 IDT entry
            Affinity (not refereced)-> KAFFINITY

          ParentToChild:

            Level (not referenced)  -> (ISA IRQ)
            Vector (IDT entry)      -> (ISA IRQ)
            Affinity                -> 0xffffffff

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    Direction   - direction of translation (parent to child or child to parent)

    AlternativesCount   - unused

    Alternatives        - unused
    
    PhysicalDeviceObject- unused

    Target      - translated descriptor

Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    KAFFINITY  affinity;
    KIRQL      irql;
    ULONG      vector;

    UNREFERENCED_PARAMETER(AlternativesCount);
    UNREFERENCED_PARAMETER(Alternatives);
    UNREFERENCED_PARAMETER(PhysicalDeviceObject);
    
    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // Copy everything
    //
    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Translate the IRQ
        //

        vector = HalpGetRootInterruptVector(Source->u.Interrupt.Level,
                                            Source->u.Interrupt.Vector,
                                            &irql,
                                            &affinity);
        if (vector != 0) {

            Target->u.Interrupt.Level  = irql;
            Target->u.Interrupt.Vector = vector;
            Target->u.Interrupt.Affinity = affinity;
            status = STATUS_TRANSLATION_COMPLETE;
        }

        break;

    case TranslateParentToChild:                                        

        //
        // There is no inverse to HalpGetSystemInterruptVector, so we
        // just do what that function would do.
        //
        Target->u.Interrupt.Level = Target->u.Interrupt.Vector =
            Source->u.Interrupt.Vector - PRIMARY_VECTOR_BASE;
        Target->u.Interrupt.Affinity = 0xFFFFFFFF;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }
    return status;
}

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes an IO_RESOURCE_DESCRIPTOR and translates
    it from an IO-bus-relative to a Processor-bus-relative form.  In this
    x86-specific example, an IO-bus-relative form is the ISA IRQ and the
    Processor-bus-relative form is the IDT entry and the associated IRQL.
    This is essentially a PnP form of HalGetInterruptVector.

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    PhysicalDeviceObject- unused

    TargetCount - 1

    Target      - translated descriptor

Return Value:

    status

--*/
{
    KAFFINITY  affinity;
    KIRQL      irql;
    ULONG      vector;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // The interrupt requirements were obtained by calling HalAdjustResourceList
    // so we don't need to call it again.
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );
    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *TargetCount = 1;

    //
    // Copy the requirement unchanged
    //

    **Target = *Source;

    //
    // Perform the translation of the minimum & maximum
    //

    vector = HalpGetRootInterruptVector(Source->u.Interrupt.MinimumVector,
                                        Source->u.Interrupt.MinimumVector,
                                        &irql,
                                        &affinity);

    (*Target)->u.Interrupt.MinimumVector = vector;

    vector = HalpGetRootInterruptVector(Source->u.Interrupt.MaximumVector,
                                        Source->u.Interrupt.MaximumVector,
                                        &irql,
                                        &affinity);

    (*Target)->u.Interrupt.MaximumVector = vector;

    return STATUS_TRANSLATION_COMPLETE;
}

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )

/*++

Routine Description:

    This routine translates memory and IO resource requirements.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt requirement to translate

    PhysicalDeviceObject - The device requesting the resource

    TargetCount - Pointer to where to return the number of descriptors this
        requirement translates into

    Target - Pointer to where a pointer to a callee allocated buffer containing
        the translated descriptors should be placed.

Return Value:

    STATUS_SUCCESS or an error status

Note:

    We do not perform any translation.

--*/

{
    ASSERT(Source);
    ASSERT(Target);
    ASSERT(TargetCount);
    ASSERT(Source->Type == CmResourceTypeMemory ||
           Source->Type == CmResourceTypePort);


    //
    // Allocate space for the target
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );
    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to target and update the fields that have changed
    //

    **Target = *Source;
    *TargetCount = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )

/*++

Routine Description:

    This routine translates memory and IO resources.   On generic x86
    machines, such as those that use this HAL, there isn't actually
    any translation.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt resource to translate

    Direction - The direction in relation to the Pnp device tree translation
        should occur in.

    AlternativesCount - The number of alternatives this resource was selected
        from.

    Alternatives - Array of alternatives this resource was selected from.

    PhysicalDeviceObject - The device requesting the resource

    Target - Pointer to a caller allocated buffer to hold the translted resource
        descriptor.

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    NTSTATUS status;

    //
    // Copy the target to the source
    //

    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Make sure PnP knows it doesn't have to walk up the tree
        // translating at each point.
        //

        status = STATUS_TRANSLATION_COMPLETE;
        break;

    case TranslateParentToChild:

        //
        // We do not translate requirements so do nothing...
        //

        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }
    return status;
}

NTSTATUS
HaliGetInterruptTranslator(
        IN INTERFACE_TYPE ParentInterfaceType,
        IN ULONG ParentBusNumber,
        IN INTERFACE_TYPE BridgeInterfaceType,
        IN USHORT Size,
        IN USHORT Version,
        OUT PTRANSLATOR_INTERFACE Translator,
        OUT PULONG BridgeBusNumber
        )
/*++

Routine Description:


Arguments:

        ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

        ParentBusNumber - The number of the bus the bridge lives on.

        ParentSlotNumber - The slot number the bridge lives in (where valid).

        BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

        ResourceType - The resource type we want to translate.

        Size - The size of the translator buffer.

        Version - The version of the translator interface requested.

        Translator - Pointer to the buffer where the translator should be returned

        BridgeBusNumber - Pointer to where the bus number of the bridge bus should be returned

Return Value:

    Returns the status of this operation.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(ParentInterfaceType);
    UNREFERENCED_PARAMETER(ParentBusNumber);

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof(TRANSLATOR_INTERFACE));

#ifdef WANT_IRQ_ROUTING

        //
        // Dont provide Irq translator iff Pci Irq Routing
        // is enabled.
        //

        if (IsPciIrqRoutingEnabled()) {

            HalPrint(("Not providing Isa Irq Translator since Pci Irq routing is enabled!\n"));

            return STATUS_NOT_SUPPORTED;
        }

#endif
    
    //
    // Fill in the common bits.
    //

    RtlZeroMemory(Translator, sizeof (TRANSLATOR_INTERFACE));

    Translator->Size = sizeof(TRANSLATOR_INTERFACE);
    Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
    Translator->Context = (PVOID)BridgeInterfaceType;
    Translator->InterfaceReference = HalTranslatorReference;
    Translator->InterfaceDereference = HalTranslatorDereference;

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
    case InterfaceTypeUndefined:  // special "IDE" cookie

        //
        // Set IRQ translator for (E)ISA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    case MicroChannel:
    case PCIBus:

        //
        // Set IRQ translator for the MCA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesRoot;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsRoot;

        return STATUS_SUCCESS;
    }
    
    //
    // If we got here, we don't have an interface.
    //

    return STATUS_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ncrdetct.c ===
/*++

Copyright (c) 1992  NCR Corporation

Module Name:

    ncrdetect.c

Abstract:

Authors:

    Richard Barton (o-richb) 24-Jan-1992
    Brian Weischedel         30-Nov-1992

Environment:

    Kernel mode only.

Revision History:

--*/

#ifndef _NTOS_
#include "nthal.h"
#endif

PVOID
HalpMapPhysicalMemory(
    IN PVOID PhysicalAddress,
    IN ULONG NumberPages
    );

VOID
ReadCMOS(
    IN ULONG StartingOffset,
    IN ULONG Count,
    IN PUCHAR ReturnValuePtr);

ULONG   NCRPlatform;

#define NCR3450 0x35333433              // Copied here to build standalone
#define NCR3550 0x30353834
#define NCR3360 0x33333630

//  WPD definitions:

PUCHAR  WPDStringID            =  "NCR Voyager-1";
PUCHAR  WPDPlatformName        =  "System 3360";
#define WPDStringIDLength         13
#define WPDStringIDRangeStart     (0xE000 << 4)       // physical address
#define WPDStringIDRangeSize      0x10000             // 1 segment (64k)

//  MSBU definitions:

PUCHAR  MSBUCopyrightString     = "Copyright (C) ???? NCR\0";
#define MSBUCopyrightStringLen          23
#define MSBUCopyrightPhysicalPtr        ((0xF000 << 4) + (0xE020))
typedef struct  {
        ULONG   ClassFromFirmware;
        PUCHAR  PlatformName;
}       MSBUPlatformMapEntry;
MSBUPlatformMapEntry    MSBUPlatformMap[]       = {{NCR3450, "System 3450"},
                                                   {NCR3550, "System 3550"},
                                                   {0, 0}};

PUCHAR
NCRDeterminePlatform(
    OUT PBOOLEAN IsConfiguredMp
)
/*++

Routine Description:
    Determine on which NCR platform we are running.  For now just display
    a message.  Later we may not continue the boot if we're on an
    unrecognized platform.

Arguments:
    none.

Return Value:
    Pointer to character string identifying which NCR platform.  NULL means
    it is unrecognized, and we shouldn't continue.

--*/
{
        BOOLEAN                 Matchfound;
        MSBUPlatformMapEntry    *MSBUPlatformMapPtr;
        PVOID                   BIOSPagePtr;
        PUCHAR                  StringPtr;
        PUCHAR                  CopyrightPtr;
        PUCHAR                  SearchPtr;
        UCHAR                   CpuFlags;


  // first check for a WPD platform by searching the 0xE000 BIOS segment
  // for a ROM string that identifies this system as a 3360


        // get virtual address to the BIOS region (assuming region is both
        // page aligned and multiple pages in size)

        BIOSPagePtr = HalpMapPhysicalMemory((PVOID) WPDStringIDRangeStart,
                                            (WPDStringIDRangeSize >> 12));

        if (BIOSPagePtr != NULL) {

                SearchPtr = BIOSPagePtr;   // begin search at start of region
                Matchfound = FALSE;

                // search until string is found or we are beyond the region

                while (!Matchfound && (SearchPtr <= (PUCHAR)((ULONG)BIOSPagePtr +
                                                     WPDStringIDRangeSize -
                                                     WPDStringIDLength))) {

                        // see if SearchPtr points to the desired string

                        StringPtr = (PUCHAR)((ULONG)SearchPtr++);
                        CopyrightPtr = WPDStringID;

                        // continue compare as long as characters compare
                        // and not at end of string

                        while ((Matchfound = (*CopyrightPtr++ == *StringPtr++)) &&
                              (CopyrightPtr < WPDStringID + WPDStringIDLength));
                }

                // see if string was found (i.e., if this is a 3360)

                if (Matchfound) {

                        // store system identifier ("3360") for later HAL use

                        NCRPlatform = NCR3360;

                        // read CPU good flags from CMOS and determine if MP

                        ReadCMOS(0x88A, 1, &CpuFlags);
                        // *IsConfiguredMp = (CpuFlags & (CpuFlags-1)) ? TRUE : FALSE;

                        // This is an MP hal
                        *IsConfiguredMp = TRUE;

                        return(WPDPlatformName);
                }

        }


  // now check for an MSBU platform


        /*
         *  Map in the BIOS text so we can look for our copyright string.
         */
        BIOSPagePtr = (PVOID)((ULONG)MSBUCopyrightPhysicalPtr &
                              ~(PAGE_SIZE - 1));
        BIOSPagePtr = HalpMapPhysicalMemory(BIOSPagePtr, 2);
        if (BIOSPagePtr == NULL)
                return(NULL);

        StringPtr = (PUCHAR)((ULONG)BIOSPagePtr +
                        ((ULONG)MSBUCopyrightPhysicalPtr & (PAGE_SIZE - 1)))
                        + (MSBUCopyrightStringLen - 1);
        CopyrightPtr = MSBUCopyrightString + (MSBUCopyrightStringLen - 1);
        do {
                Matchfound = ((*CopyrightPtr == '?') ||
                              (*CopyrightPtr == *StringPtr));
                --CopyrightPtr;
                --StringPtr;
        } while (Matchfound && (CopyrightPtr >= MSBUCopyrightString));

        //
        // /*
        //  *  Clear the mapping to BIOS. We mapped in two pages.
        //  */
        // BIOSPagePtr = MiGetPteAddress(BIOSPagePtr);
        // *(PULONG)BIOSPagePtr = 0;
        // *(((PULONG)BIOSPagePtr)+1) = 0;
        // /*
        //  *  Flush the TLB.
        //  */
        // _asm {
        //         mov     eax, cr3
        //         mov     cr3, eax
        // }
        //

        if (Matchfound) {
                /*
                 *  must be an MSBU machine..determine which.
                 */
                ReadCMOS(0xB16, 4, (PUCHAR)&NCRPlatform);
                for (MSBUPlatformMapPtr = MSBUPlatformMap;
                     (MSBUPlatformMapPtr->ClassFromFirmware != 0);
                     ++MSBUPlatformMapPtr) {
                        if (MSBUPlatformMapPtr->ClassFromFirmware ==
                                NCRPlatform) {

                                *IsConfiguredMp = TRUE;
                                return(MSBUPlatformMapPtr->PlatformName);
                        }
                }

                /*
                 *  prerelease version of firmware had this machine class
                 *  at the wrong offset into CMOS.  until all those versions
                 *  of firmware are extinguished from the face of the earth
                 *  we should recognize them with this:
                 */
                ReadCMOS(0xAB3, 4, (PUCHAR)&NCRPlatform);
                for (MSBUPlatformMapPtr = MSBUPlatformMap;
                     (MSBUPlatformMapPtr->ClassFromFirmware != 0);
                     ++MSBUPlatformMapPtr) {
                        if (MSBUPlatformMapPtr->ClassFromFirmware ==
                                NCRPlatform) {
                                *IsConfiguredMp = TRUE;
                                return(MSBUPlatformMapPtr->PlatformName);
                        }
                }
        }

        return(NULL);
}


#ifndef SETUP         // if built with Hal, must provide ReadCMOS routine

ULONG
HalpGetCmosData (
    IN ULONG SourceLocation,
    IN ULONG SourceAddress,
    IN PUCHAR Buffer,
    IN ULONG Length);

VOID
ReadCMOS(
    IN ULONG StartingOffset,
    IN ULONG Count,
    IN PUCHAR ReturnValuePtr
)
/*++

Routine Description:
    This routine simply converts a ReadCMOS call (a routine in setup) to
    the corresponding routine provided in the Hal (HalpGetCmosData).

--*/
{
    HalpGetCmosData(1, StartingOffset, ReturnValuePtr, Count);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixthunk.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixthunk.c

Abstract:

    This module contains the standard call routines which thunk to
    fastcall routines.

Author:

    Ken Reneris (kenr) 04-May-1994

Environment:

    Kernel mode

Revision History:


--*/

#if !defined(_WIN64)

#include "halp.h"

#ifdef KeRaiseIrql
#undef KeRaiseIrql
#endif

VOID
KeRaiseIrql (
    IN KIRQL    NewIrql,
    OUT PKIRQL  OldIrql
    )
{
    *OldIrql = KfRaiseIrql (NewIrql);
}


#ifdef KeLowerIrql
#undef KeLowerIrql
#endif


VOID
KeLowerIrql (
    IN KIRQL    NewIrql
    )
{
    KfLowerIrql (NewIrql);
}

#ifdef KeAcquireSpinLock
#undef KeAcquireSpinLock
#endif

VOID
KeAcquireSpinLock (
    IN PKSPIN_LOCK  SpinLock,
    OUT PKIRQL      OldIrql
    )
{
    *OldIrql = KfAcquireSpinLock (SpinLock);
}


#ifdef KeReleaseSpinLock
#undef KeReleaseSpinLock
#endif

VOID
KeReleaseSpinLock (
    IN PKSPIN_LOCK  SpinLock,
    IN KIRQL        NewIrql
    )
{
    KfReleaseSpinLock (SpinLock, NewIrql);
}

#endif  // _WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\pmpcisup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmpcibus.c

Abstract:

    Implements simplified PCI configuration
    read and write functions for use in
    an ACPI HAL.

Author:

    Jake Oshins (jakeo) 1-Dec-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "cardbus.h"

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

NTSTATUS
HalpSearchForPciDebuggingDevice(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG                        StartBusNumber,
    IN ULONG                        EndBusNumber,
    IN ULONG                        MinMem,
    IN ULONG                        MaxMem,
    IN USHORT                       MinIo,
    IN USHORT                       MaxIo,
    IN BOOLEAN                      ConfigureBridges
    );

PCIPBUSDATA HalpFakePciBusData = {
    {
        PCI_DATA_TAG,//Tag
        PCI_DATA_VERSION,//Version
        (PciReadWriteConfig)HalpReadPCIConfig,//ReadConfig
        (PciReadWriteConfig) HalpWritePCIConfig,//WriteConfig
        (PciPin2Line)HalpPCIPin2ISALine,//Pin2Line
        (PciLine2Pin)HalpPCIISALine2Pin,//Line2Pin
        {0},//ParentSlot
        NULL,NULL,NULL,NULL//Reserved[4]
    },
    {0},//Config
    PCI_MAX_DEVICES,//MaxDevice
};

BUS_HANDLER HalpFakePciBusHandler = {
    BUS_HANDLER_VERSION,//Version
    PCIBus,//InterfaceType
    PCIConfiguration,//ConfigurationType
    0,//BusNumber
    NULL,//DeviceObject
    NULL,//ParentHandler
    (PPCIBUSDATA)&HalpFakePciBusData,//BusData
    0,//DeviceControlExtensionSize
    NULL,//BusAddresses
    {0},//Reserved[4]
    (PGETSETBUSDATA)HalpGetPCIData,//GetBusData
    (PGETSETBUSDATA)HalpSetPCIData,//SetBusData
    NULL,//AdjustResourceList
    (PASSIGNSLOTRESOURCES)HalpAssignPCISlotResources,//AssignSlotResources
    NULL,//GetInterruptVector
    NULL,//TranslateBusAddress
};

ULONG       HalpMinPciBus = 0;
ULONG       HalpMaxPciBus = 0;

PCI_TYPE1_CFG_CYCLE_BITS HalpPciDebuggingDevice[MAX_DEBUGGING_DEVICES_SUPPORTED] = {0};

extern BOOLEAN HalpDoingCrashDump;

PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

VOID
HalpFindFreeResourceLimits(
    IN      ULONG   Bus,
    IN OUT  ULONG   *MinIo,
    IN OUT  ULONG   *MaxIo,
    IN OUT  ULONG   *MinMem,
    IN OUT  ULONG   *MaxMem,
    IN OUT  ULONG   *MinBus,
    IN OUT  ULONG   *MaxBus
    );

NTSTATUS
HalpSetupUnconfiguredDebuggingDevice(
    IN ULONG   Bus,
    IN ULONG   Slot,
    IN ULONG   IoMin,
    IN ULONG   IoMax,
    IN ULONG   MemMin,
    IN ULONG   MemMax,
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice
    );

NTSTATUS
HalpConfigurePciBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    );

NTSTATUS
HalpConfigureCardBusBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    );

VOID
HalpUnconfigurePciBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    );

VOID
HalpUnconfigureCardBusBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    );

ULONG
HalpKdStallExecution(
    ULONG   LoopCount
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitializePciStubs)
#pragma alloc_text(INIT,HalpRegisterKdSupportFunctions)
#pragma alloc_text(INIT,HalpRegisterPciDebuggingDeviceInfo)
#pragma alloc_text(PAGEKD,HalpConfigurePciBridge)
#pragma alloc_text(PAGEKD,HalpConfigureCardBusBridge)
#pragma alloc_text(PAGEKD,HalpFindFreeResourceLimits)
#pragma alloc_text(PAGEKD,HalpPhase0GetPciDataByOffset)
#pragma alloc_text(PAGEKD,HalpPhase0SetPciDataByOffset)
#pragma alloc_text(PAGEKD,HalpReleasePciDeviceForDebugging)
#pragma alloc_text(PAGEKD,HalpSearchForPciDebuggingDevice)
#pragma alloc_text(PAGEKD,HalpSetupPciDeviceForDebugging)
#pragma alloc_text(PAGEKD,HalpSetupUnconfiguredDebuggingDevice)
#pragma alloc_text(PAGEKD,HalpUnconfigurePciBridge)
#pragma alloc_text(PAGEKD,HalpUnconfigureCardBusBridge)
#pragma alloc_text(PAGEKD,HalpKdStallExecution)
#endif

VOID
HalpInitializePciStubs (
    VOID
    )
{
    PPCI_REGISTRY_INFO_INTERNAL  PCIRegInfo;
    PPCIPBUSDATA                 BusData;
    UCHAR                        iBuffer[PCI_COMMON_HDR_LENGTH];
    ULONG                        HwType;
    ULONG                        BusNo = 0;
    ULONG                        Bytes;
    ULONG                        Slot;
    PCI_COMMON_CONFIG            PciData;
                        
    PCIRegInfo = HalpQueryPciRegistryInfo();

    if (PCIRegInfo) {

        //
        // PCIRegInfo describes the system's PCI support as indicated by the BIOS.
        //
        HwType = PCIRegInfo->HardwareMechanism & 0xf;
        ExFreePool(PCIRegInfo);
    } else {
        //
        // no PCI bus information was gathered by NTDETECT,
        // assume type 1 access.
        //
        HwType = 1;
    }

    //
    // Initialize spinlock for synchronizing access to PCI space
    //

    KeInitializeSpinLock (&HalpPCIConfigLock);

    BusData = (PPCIPBUSDATA) HalpFakePciBusHandler.BusData;

    //
    // Set defaults
    //

    switch (HwType) {
        case 1:
            //
            // Initialize access port information for Type1 handlers
            //

            RtlCopyMemory (&PCIConfigHandler,
                           &PCIConfigHandlerType1,
                           sizeof (PCIConfigHandler));

            BusData->Config.Type1.Address = PCI_TYPE1_ADDR_PORT;
            BusData->Config.Type1.Data    = PCI_TYPE1_DATA_PORT;
            break;

        case 2:
            //
            // Initialize access port information for Type2 handlers
            //

            RtlCopyMemory (&PCIConfigHandler,
                           &PCIConfigHandlerType2,
                           sizeof (PCIConfigHandler));

            BusData->Config.Type2.CSE     = PCI_TYPE2_CSE_PORT;
            BusData->Config.Type2.Forward = PCI_TYPE2_FORWARD_PORT;
            BusData->Config.Type2.Base    = PCI_TYPE2_ADDRESS_BASE;

            //
            // Early PCI machines didn't decode the last bit of
            // the device id.  Shrink type 2 support max device.
            //
            BusData->MaxDevice            = 0x10;

            break;

        default:
            // unsupport type
            DBGMSG ("HAL: Unkown PCI type\n");
    }


    //
    // Make a good guess about how many PCI busses are in the system
    // and initialize HalpMaxPciBus with this guess.  When the PCI
    // driver starts, we will get a better answer here.
    //
    // Calling HaliPciInterfaceReadConfig has the side effect of 
    // bumping up HalpMaxPciBus if it hits a populated device.  So
    // the algorithm here is to just keep searching for devices until
    // we have searched 0x10 busses higher than the current maximum.
    //

    while (BusNo < 0x100) {

        //
        // Scan across this bus.  As soon as we find a device, 
        // then move on to another bus.
        //

        for (Slot = 0;
             Slot < PCI_MAX_DEVICES;
             Slot++) {
        
            Bytes = HaliPciInterfaceReadConfig(NULL,
                                               (UCHAR)BusNo,
                                               Slot,
                                               (PVOID)&PciData,
                                               0,
                                               4
                                               );
            if ((Bytes != 0) &&
                (PciData.VendorID != PCI_INVALID_VENDORID)) {
                
                //
                // This was a populated device.  Bump up HalpMaxPciBus.
                //

                HalpMaxPciBus = BusNo;
                break;
            }
        }

        BusNo++;
    }
}


ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    PCI_SLOT_NUMBER slotNum;
    BUS_HANDLER     busHand;

    UNREFERENCED_PARAMETER(Context);
    
    slotNum.u.AsULONG = Slot;

    //
    // Fake a bus handler.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    //
    // Calculate the right bus number.
    //

    busHand.BusNumber = BusOffset;

    HalpReadPCIConfig(&busHand,
                      slotNum,
                      Buffer,
                      Offset,
                      Length
                      );

    //
    // This is a hack.  The legacy HAL interfaces need to be able
    // to distinguish between busses that exist and busses that
    // don't.  And many users of the legacy interfaces implicitly
    // assume that PCI busses are tightly packed.  (i.e. All busses
    // between the lowest numbered one and the highest numbered one
    // exist.)  So here we are keeping track of the highest numbered
    // bus that we have seen so far.
    //

    if ((Length >= 2) &&
        (((PPCI_COMMON_CONFIG)Buffer)->VendorID != PCI_INVALID_VENDORID)) {

        //
        // This is a valid device.
        //

        if (busHand.BusNumber > HalpMaxPciBus) {

            //
            // This is the highest numbered bus we have
            // yet seen.
            //

            HalpMaxPciBus = busHand.BusNumber;
        }
    }

    return Length;
}

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    PCI_SLOT_NUMBER slotNum;
    BUS_HANDLER     busHand;

    UNREFERENCED_PARAMETER(Context);

    slotNum.u.AsULONG = Slot;

    //
    // Fake a bus handler.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    //
    // Calculate the right bus number.
    //

    busHand.BusNumber = BusOffset;

    HalpWritePCIConfig(&busHand,
                       slotNum,
                       Buffer,
                       Offset,
                       Length
                       );

    return Length;
}

VOID
HaliSetMaxLegacyPciBusNumber(
    IN ULONG BusNumber
    )
/*++

Routine Description:

    This routine bumps the Legacy PCI bus maximum up to whatever
    is passed in.  This may be necessary because the ACPI driver
    needs to run a configuration cycle to a PCI device before the
    PCI driver loads.  This happens mostly in the context of a
    _REG method.

Arguments:

    BusNumber - max PCI bus number

Return Value:

    none
    
Notes:

    Caller is responsible for acquiring any necessary PCI config
    spinlocks.    

--*/
{
    if (BusNumber > HalpMaxPciBus) {
        HalpMaxPciBus = BusNumber;
    }
}

ULONG
HalpPhase0SetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine writes to PCI configuration space prior to bus handler
    installation.

Arguments:

    BusNumber   PCI Bus Number.  This is the 8 bit BUS Number which is
                bits 23-16 of the Configuration Address.  In support of
                multiple top level busses, the upper 24 bits of this
                argument will supply the index into the table of
                configuration address registers.
    SlotNumber  PCI Slot Number, 8 bits composed of the 5 bit device
                number (bits 15-11 of the configuration address) and
                the 3 bit function number (10-8).
    Buffer      Address of source data.
    Offset      Number of bytes to skip from base of PCI config area.
    Length      Number of bytes to write

Return Value:

    Returns length of data written.

Notes:

    Caller is responsible for acquiring any necessary PCI config
    spinlocks.    

--*/

{
    PCI_TYPE1_CFG_BITS ConfigAddress;
    ULONG ReturnLength;
    PCI_SLOT_NUMBER slot;
    PUCHAR Bfr = (PUCHAR)Buffer;

    ASSERT(!(Offset & ~0xff));
    ASSERT(Length);
    ASSERT((Offset + Length) <= 256);

    if ( Length + Offset > 256 ) {
        if ( Offset > 256 ) {
            return 0;
        }
        Length = 256 - Offset;
    }

    ReturnLength = Length;
    slot.u.AsULONG = SlotNumber;

    ConfigAddress.u.bits.BusNumber = BusNumber;
    ConfigAddress.u.bits.DeviceNumber = slot.u.bits.DeviceNumber;
    ConfigAddress.u.bits.FunctionNumber = slot.u.bits.FunctionNumber;
    ConfigAddress.u.bits.RegisterNumber = (Offset & 0xfc) >> 2;
    ConfigAddress.u.bits.Enable = TRUE;

    if ( Offset & 0x3 ) {
        //
        // Access begins at a non-register boundary in the config
        // space.  We need to read the register containing the data
        // and rewrite only the changed data.   (I wonder if this
        // ever really happens?)
        //
        ULONG SubOffset = Offset & 0x3;
        ULONG SubLength = 4 - SubOffset;
        union {
            ULONG All;
            UCHAR Bytes[4];
        } Tmp;

        if ( SubLength > Length ) {
            SubLength = Length;
        }

        //
        // Adjust Length (remaining) and (new) Offset by amount covered
        // in this first word.
        //
        Length -= SubLength;
        Offset += SubLength;

        //
        // Get the first word (register), replace only those bytes that
        // need to be changed, then write the whole thing back out again.
        //
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        while ( SubLength-- ) {
            Tmp.Bytes[SubOffset++] = *Bfr++;
        }

        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp.All);

        //
        // Aim ConfigAddressRegister at the next word (register).
        //
        ConfigAddress.u.bits.RegisterNumber++;
    }

    //
    // Do the majority of the transfer 4 bytes at a time.
    //
    while ( Length > sizeof(ULONG) ) {
        ULONG Tmp = *(UNALIGNED PULONG)Bfr;
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp);
        ConfigAddress.u.bits.RegisterNumber++;
        Bfr += sizeof(ULONG);
        Length -= sizeof(ULONG);

    }

    //
    // Do bytes in last register.
    //
    if ( Length ) {
        union {
            ULONG All;
            UCHAR Bytes[4];
        } Tmp;
        ULONG i = 0;
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        while ( Length-- ) {
            Tmp.Bytes[i++] = *(PUCHAR)Bfr++;
        }
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp.All);
    }

    return ReturnLength;
}

ULONG
HalpPhase0GetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine reads PCI config space prior to bus handlder installation.

Arguments:

    BusNumber   PCI Bus Number.  This is the 8 bit BUS Number which is
                bits 23-16 of the Configuration Address.  In support of
                multiple top level busses, the upper 24 bits of this
                argument will supply the index into the table of
                configuration address registers.
    SlotNumber  PCI Slot Number, 8 bits composed of the 5 bit device
                number (bits 15-11 of the configuration address) and
                the 3 bit function number (10-8).
    Buffer      Address of source data.
    Offset      Number of bytes to skip from base of PCI config area.
    Length      Number of bytes to write

Return Value:

    Amount of data read.

--*/

{
    PCI_TYPE1_CFG_BITS ConfigAddress;
    PCI_TYPE1_CFG_BITS ConfigAddressTemp;
    ULONG ReturnLength;
    ULONG i;
    PCI_SLOT_NUMBER slot;
    union {
        ULONG All;
        UCHAR Bytes[4];
    } Tmp;

    ASSERT(!(Offset & ~0xff));
    ASSERT(Length);
    ASSERT((Offset + Length) <= 256);

    if ( Length + Offset > 256 ) {
        if ( Offset > 256 ) {
            return 0;
        }
        Length = 256 - Offset;
    }

    ReturnLength = Length;
    slot.u.AsULONG = SlotNumber;

    ConfigAddress.u.bits.BusNumber = BusNumber;
    ConfigAddress.u.bits.DeviceNumber = slot.u.bits.DeviceNumber;
    ConfigAddress.u.bits.FunctionNumber = slot.u.bits.FunctionNumber;
    ConfigAddress.u.bits.RegisterNumber = (Offset & 0xfc) >> 2;
    ConfigAddress.u.bits.Enable = TRUE;

    //
    // If we are being asked to read data when function != 0, check
    // first to see if this device decares itself as a multi-function
    // device.  If it doesn't, don't do this read.
    //
    if (ConfigAddress.u.bits.FunctionNumber != 0) {

        ConfigAddressTemp.u.bits.RegisterNumber = 3; // contains header type
        ConfigAddressTemp.u.bits.FunctionNumber = 0; // look at base package
        ConfigAddressTemp.u.bits.DeviceNumber = ConfigAddress.u.bits.DeviceNumber;
        ConfigAddressTemp.u.bits.BusNumber    = ConfigAddress.u.bits.BusNumber;
        ConfigAddressTemp.u.bits.Enable       = TRUE;

        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddressTemp.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        if (!(Tmp.Bytes[2] & 0x80)) { // if the Header type field's multi-function bit is not set

            for (i = 0; i < Length; i++) {
                *((PUCHAR)Buffer)++ = 0xff; // Make this read as if the device isn't populated
            }

            return Length;
        }
    }

    i = Offset & 0x3;

    while ( Length ) {
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);
        while ( (i < 4) && Length) {
            *((PUCHAR)Buffer)++ = Tmp.Bytes[i];
            i++;
            Length--;
        }
        i = 0;
        ConfigAddress.u.bits.RegisterNumber++;
    }
    return ReturnLength;
}

NTSTATUS
HalpSetupPciDeviceForDebugging(
    IN     PLOADER_PARAMETER_BLOCK   LoaderBlock,   OPTIONAL    
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
/*++

Routine Description:

    This routine finds and initializes a PCI device to be
    used for communicating with a debugger.  

    The caller fills in as much of DEBUG_DEVICE_DESCRIPTOR 
    as it cares to, filling unused fields with (-1).  

    This routine attempts to find a matching PCI device.  It
    matches first based on Bus and Slot, if the caller has
    provided them.  Then it matches on VendorID/DeviceID, if
    the caller has provided them.  Last, it matches on
    BaseClass/SubClass.

    This routine will fill in any unused fields in the structure
    so that the caller can know specifically which PCI 
    device matched the criteria.

    If the matching PCI device is not enabled, or it is
    behind a PCI to PCI bridge that is not enabled, this 
    routine makes a best-effort attempt to find a safe
    configuration that allows the device (and possibly bridges)
    to function, and enables them.

    If the PCI device implements memory mapped Base Address
    registers, this function will create a virtual to physical
    mapping for the memory ranges implied by the Base Address
    Registers and fill in the TranslatedAddress field with
    virtual pointers to the bases of the ranges.  It will then
    fill in the Type field with CmResourceTypeMemory.  And
    the Valid field with be TRUE.

    If the PCI device implements I/O port Base Address registers,
    this function will put the translated port address in
    TranslatedAddress, setting the Type field to CmResourceTypePort
    and the Valid field to TRUE.

    If the PCI device does not implement a specific Base Address
    Register, the Valid field will be FALSE.

Arguments:

    PciDevice - Structure indicating the device
    
Return Value:

    STATUS_SUCCESS if the device is configured and usable.

    STATUS_NO_MORE_MATCHES if no device matched the criteria.

    STATUS_INSUFFICIENT_RESOURCES if the memory requirements
    couldn't be met.
    
    STATUS_UNSUCCESSFUL if the routine failed for other reasons.
    
--*/
{
    NTSTATUS            status;
    PCI_SLOT_NUMBER     slot;
    ULONG               i, j;
    ULONG               maxPhys;
    
    status = HalpSearchForPciDebuggingDevice(
                PciDevice,
                0,
                0xff,
                0x10000000,
                0xfc000000,
                0x1000,
                0xffff,
                FALSE);

    if (!NT_SUCCESS(status)) {

        //
        // We didn't find the device using a conservative
        // search.  Try a more invasive one.
        //

        status = HalpSearchForPciDebuggingDevice(
                    PciDevice,
                    0,
                    0xff,
                    0x10000000,
                    0xfc000000,
                    0x1000,
                    0xffff,
                    TRUE);
    }
    
    //
    // Record the Bus/Dev/Func so that we can stuff it in the 
    // registry later.
    //

    if (NT_SUCCESS(status)) {
    
        if (PciDevice->Initialized) {
            //
            // Here we were just asked to reconfigure the bridges since
            // we already 
            //
            return status;
        }
        
        slot.u.AsULONG = PciDevice->Slot;

        for (i = 0; 
             i < MAX_DEBUGGING_DEVICES_SUPPORTED;
             i++) {

            if ((HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) &&
                (HalpPciDebuggingDevice[i].u.bits.FunctionNumber == 
                 slot.u.bits.FunctionNumber)                         &&
                (HalpPciDebuggingDevice[i].u.bits.DeviceNumber ==
                 slot.u.bits.DeviceNumber)                           &&
                (HalpPciDebuggingDevice[i].u.bits.BusNumber == 
                 PciDevice->Bus)) {

                //
                // This device has already been set up for
                // debugging.  Thus we should refuse to set
                // it up again.
                //

                return STATUS_UNSUCCESSFUL;
            }
        }

        for (i = 0; 
             i < MAX_DEBUGGING_DEVICES_SUPPORTED;
             i++) {

            if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == FALSE) {

                //
                // This slot is available.
                //

                HalpPciDebuggingDevice[i].u.bits.FunctionNumber = 
                    slot.u.bits.FunctionNumber;
                HalpPciDebuggingDevice[i].u.bits.DeviceNumber = 
                    slot.u.bits.DeviceNumber;
                HalpPciDebuggingDevice[i].u.bits.BusNumber = PciDevice->Bus;
                HalpPciDebuggingDevice[i].u.bits.Reserved1 = TRUE;
                PciDevice->Initialized = TRUE;

                break;
            }
        }

        //
        // Check to see if the caller wants any memory.
        //
       
        if (PciDevice->Memory.Length != 0) {
       
            if (!LoaderBlock) {
                return STATUS_INVALID_PARAMETER_1;
            }
       
            if (PciDevice->Memory.MaxEnd.QuadPart == 0) {
                PciDevice->Memory.MaxEnd.QuadPart = -1;
            }
       
            maxPhys = PciDevice->Memory.MaxEnd.HighPart ? 0xffffffff : PciDevice->Memory.MaxEnd.LowPart;
            maxPhys -= PciDevice->Memory.Length;
            
            //
            // The HAL APIs will always return page-aligned
            // memory.  So ignore Aligned for now.
            //
       
            maxPhys = PtrToUlong(PAGE_ALIGN(maxPhys));
            maxPhys += ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length);
       
            PciDevice->Memory.Start.HighPart = 0;
            PciDevice->Memory.Start.LowPart = 
                HalpAllocPhysicalMemory(LoaderBlock,
                                        maxPhys,
                                        ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length),
                                        FALSE);
       
            if (!PciDevice->Memory.Start.LowPart) {
                return STATUS_INSUFFICIENT_RESOURCES;
            }
       
            PciDevice->Memory.VirtualAddress =
                HalpMapPhysicalMemory64(PciDevice->Memory.Start,
                                        ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length));
        }
    }

    return status;
}

VOID
HalpFindFreeResourceLimits(
    IN      ULONG   Bus,
    IN OUT  ULONG   *MinIo,
    IN OUT  ULONG   *MaxIo,
    IN OUT  ULONG   *MinMem,
    IN OUT  ULONG   *MaxMem,
    IN OUT  ULONG   *MinBus,
    IN OUT  ULONG   *MaxBus
    )
{
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    UCHAR               bus, dev, func, bytesRead;
    PCI_SLOT_NUMBER     pciSlot, targetSlot;
    ULONG               newMinMem, newMaxMem;
    ULONG               newMinIo, newMaxIo;
    ULONG               newMinBus, newMaxBus;
    UCHAR               barNo;

    pciData = (PPCI_COMMON_CONFIG)buffer;
    pciSlot.u.AsULONG = 0;
    newMinMem   = *MinMem;
    newMaxMem   = *MaxMem;
    newMinIo    = *MinIo;
    newMaxIo    = *MaxIo;
    newMinBus   = *MinBus;
    newMaxBus   = *MaxBus;
    
    for (dev = 0; dev < PCI_MAX_DEVICES; dev++) {
        for (func = 0; func < PCI_MAX_FUNCTION; func++) {

            pciSlot.u.bits.DeviceNumber = dev;
            pciSlot.u.bits.FunctionNumber = func;


            bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(Bus,
                                 pciSlot.u.AsULONG,
                                 pciData,
                                 0,
                                 PCI_COMMON_HDR_LENGTH);

            if (bytesRead == 0) continue;

            if (pciData->VendorID != PCI_INVALID_VENDORID) {

                switch (PCI_CONFIGURATION_TYPE(pciData)) {
                case PCI_DEVICE_TYPE:
                    
                    //
                    // While we scan across the bus, keep track
                    // of the minimum decoder values that we've seen.
                    // This will be used if we have to configure the
                    // device.  This relies on the fact that most BIOSes
                    // assign addresses from the top down.
                    //

                    for (barNo = 0; barNo < PCI_TYPE0_ADDRESSES; barNo++) {

                        if (pciData->u.type0.BaseAddresses[barNo] & 
                            PCI_ADDRESS_IO_SPACE) {

                            if (pciData->u.type0.BaseAddresses[barNo] & 
                                PCI_ADDRESS_IO_ADDRESS_MASK) {

                                //
                                // This BAR is implemented
                                //

                                if ((pciData->u.type0.BaseAddresses[barNo] &
                                     PCI_ADDRESS_IO_ADDRESS_MASK) <  
                                    ((newMaxIo / 2) + (newMinIo / 2))) {

                                    //
                                    // This BAR is at the bottom of the range.
                                    // Bump up the min.
                                    //

                                    newMinIo = (USHORT)MAX (newMinIo,
                                                            (pciData->u.type0.BaseAddresses[barNo] &
                                                             PCI_ADDRESS_IO_ADDRESS_MASK) + 0x100);

                                } else {

                                    //
                                    // This BAR is not at the bottom of the range.
                                    // Bump down the max.
                                    //

                                    newMaxIo = (USHORT)MIN (newMaxIo,
                                                            pciData->u.type0.BaseAddresses[barNo] &
                                                            PCI_ADDRESS_IO_ADDRESS_MASK);
                                }
                            }

                        } else {

                            if (pciData->u.type0.BaseAddresses[barNo] &
                                PCI_ADDRESS_MEMORY_ADDRESS_MASK) {

                                //
                                // The BAR is populated.
                                //

                                if ((pciData->u.type0.BaseAddresses[barNo] &
                                     PCI_ADDRESS_MEMORY_ADDRESS_MASK) <
                                    ((newMaxMem / 2) + (newMinMem / 2))) {

                                    //
                                    // This BAR is at the bottom of the range.
                                    // Bump up the min.
                                    //

                                    newMinMem = MAX (newMinMem, 
                                                     (pciData->u.type0.BaseAddresses[barNo] &
                                                        PCI_ADDRESS_MEMORY_ADDRESS_MASK) + 0x10000);

                                } else {

                                    //
                                    // This BAR is not at the bottom of the range.
                                    // Bump down the max.
                                    //

                                    newMaxMem = MIN (newMaxMem, 
                                                     (pciData->u.type0.BaseAddresses[barNo] &
                                                        PCI_ADDRESS_MEMORY_ADDRESS_MASK));

                                }
                            }
                        }
                    }
                    
                    break;

                case PCI_CARDBUS_BRIDGE_TYPE:
                
                    {
                      ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                      USHORT bridgeIoMin, bridgeIoMax;
                      ULONG LegacyBaseAddress;
                      UCHAR bytesRead;

                      bytesRead = (UCHAR) HalpPhase0GetPciDataByOffset(Bus,
                                                                       pciSlot.u.AsULONG, 
                                                                       &LegacyBaseAddress,
                                                                       CARDBUS_LEGACY_MODE_BASE_ADDR,
                                                                       4);
                                                               
                      if (bytesRead != 4) continue;                                                               


                      if ((LegacyBaseAddress & ~1) &&
                          (pciData->u.type2.SecondaryBus != 0) &&
                          (pciData->u.type2.SubordinateBus !=0) &&
                          (pciData->u.type2.Range[0].Base != 0) &&
                          (pciData->u.type2.SocketRegistersBaseAddress != 0) &&
                          (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                          (pciData->Command & PCI_ENABLE_IO_SPACE)) {

                        bridgeMemMin = pciData->u.type2.Range[0].Base;
                        bridgeMemMax = pciData->u.type2.Range[0].Limit | 0xfff;
                        bridgeIoMin = (USHORT)pciData->u.type2.Range[2].Base;
                        bridgeIoMax = (USHORT)pciData->u.type2.Range[2].Limit | 0x3;

                        //
                        // Keep track of address space allocation.
                        //

                        if (bridgeIoMin > ((newMaxIo / 2) + (newMinIo / 2))) {
                            newMaxIo = MIN(newMaxIo, bridgeIoMin);
                        }

                        if (bridgeIoMax < ((newMaxIo / 2) + (newMinIo / 2))) {
                            newMinIo = MAX(newMinIo, bridgeIoMax) + 1;
                        }

                        if (bridgeMemMin > ((newMaxMem / 2) + (newMinMem / 2))) {
                            newMaxMem = MIN(newMaxMem, bridgeMemMin);
                        }

                        if (bridgeMemMax < ((newMaxMem / 2) + (newMinMem / 2))) {
                            newMinMem = MAX(newMinMem, bridgeMemMax) + 1;
                        }

                        //
                        // Keep track of bus numbers.
                        //

                        if (pciData->u.type2.PrimaryBus > ((newMaxBus / 2) + (newMinBus / 2))) {
                            newMaxBus = MIN(newMaxBus, pciData->u.type2.PrimaryBus);
                        }

                        if (pciData->u.type2.SubordinateBus < ((newMaxBus / 2) + (newMinBus / 2))) {
                            newMinBus = MAX(newMinBus, pciData->u.type2.SubordinateBus) + 1;
                        }
                      }
                    }  
                    
                    break;
                
                case PCI_BRIDGE_TYPE:

                    {
                      ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                      USHORT bridgeIoMin, bridgeIoMax;

                      if ((pciData->u.type1.SecondaryBus != 0) &&
                          (pciData->u.type1.SubordinateBus !=0) &&
                          (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                          (pciData->Command & PCI_ENABLE_IO_SPACE)) {

                        bridgeMemMin = PciBridgeMemory2Base(pciData->u.type1.MemoryBase);
                        bridgeMemMax = PciBridgeMemory2Limit(pciData->u.type1.MemoryLimit);
                        bridgeIoMin = (USHORT)PciBridgeIO2Base(pciData->u.type1.IOBase, 0);
                        bridgeIoMax = (USHORT)PciBridgeIO2Limit(pciData->u.type1.IOLimit, 0);

                        //
                        // Keep track of address space allocation.
                        //

                        if (bridgeIoMin > ((newMaxIo / 2) + (newMinIo / 2))) {
                            newMaxIo = MIN(newMaxIo, bridgeIoMin);
                        }

                        if (bridgeIoMax < ((newMaxIo / 2) + (newMinIo / 2))) {
                            newMinIo = MAX(newMinIo, bridgeIoMax) + 1;
                        }

                        if (bridgeMemMin > ((newMaxMem / 2) + (newMinMem / 2))) {
                            newMaxMem = MIN(newMaxMem, bridgeMemMin);
                        }

                        if (bridgeMemMax < ((newMaxMem / 2) + (newMinMem / 2))) {
                            newMinMem = MAX(newMinMem, bridgeMemMax) + 1;
                        }

                        //
                        // Keep track of bus numbers.
                        //

                        if (pciData->u.type1.PrimaryBus > ((newMaxBus / 2) + (newMinBus / 2))) {
                            newMaxBus = MIN(newMaxBus, pciData->u.type1.PrimaryBus);
                        }

                        if (pciData->u.type1.SubordinateBus < ((newMaxBus / 2) + (newMinBus / 2))) {
                            newMinBus = MAX(newMinBus, pciData->u.type1.SubordinateBus) + 1;
                        }
                      }
                    
                      break;
                    
                      default:
                        break;

                    }

                }

                if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                    (func == 0)) {
                    break;
                }
            }
        }
    }

    *MinMem = newMinMem;
    *MaxMem = newMaxMem;
    *MinIo  = newMinIo;
    *MaxIo  = newMaxIo;
    *MinBus = newMinBus;
    *MaxBus = newMaxBus;
}

NTSTATUS
HalpSetupUnconfiguredDebuggingDevice(
    IN ULONG   Bus,
    IN ULONG   Slot,
    IN ULONG   IoMin,
    IN ULONG   IoMax,
    IN ULONG   MemMin,
    IN ULONG   MemMax,
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice
    )
{

    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    ULONG               barLength, bytesRead;
    ULONG               barContents = 0;
    PHYSICAL_ADDRESS    physicalAddress;
    PCI_SLOT_NUMBER     pciSlot;
    UCHAR               barNo;

    pciSlot.u.AsULONG = Slot;
    pciData = (PPCI_COMMON_CONFIG)buffer;

    bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(Bus,
                         pciSlot.u.AsULONG,
                         pciData,
                         0,
                         PCI_COMMON_HDR_LENGTH);

    ASSERT(bytesRead != 0);

    PciDevice->Bus = Bus;
    PciDevice->Slot = pciSlot.u.AsULONG;
    PciDevice->VendorID = pciData->VendorID;
    PciDevice->DeviceID = pciData->DeviceID;
    PciDevice->BaseClass = pciData->BaseClass;
    PciDevice->SubClass = pciData->SubClass;

  //DbgPrint("Configuring device between %x - %x\n",
  //         MemMin, MemMax);

    //
    // Cycle through the BARs, turning them on if necessary,
    // and mapping them.
    //

    for (barNo = 0; barNo < PCI_TYPE0_ADDRESSES; barNo++) {

        barContents = 0xffffffff;

        PciDevice->BaseAddress[barNo].Valid = FALSE;

        HalpPhase0SetPciDataByOffset(Bus,
                                     pciSlot.u.AsULONG,
                                     &barContents,
                                     0x10 + (4 * barNo),
                                     4);

        HalpPhase0GetPciDataByOffset(Bus,
                                     pciSlot.u.AsULONG,
                                     &barContents,
                                     0x10 + (4 * barNo),
                                     4);

        if (pciData->u.type0.BaseAddresses[barNo] & 
            PCI_ADDRESS_IO_SPACE) {

            //
            // This is an I/O BAR.
            //

            barLength = (((USHORT)barContents & PCI_ADDRESS_IO_ADDRESS_MASK) - 1) ^
                0xffff;

            if (!(pciData->u.type0.BaseAddresses[barNo] &
                  PCI_ADDRESS_IO_ADDRESS_MASK)) {

                //
                // And it's empty.
                //

                //
                // Try to fit this I/O window half-way between the min and the max.
                //

                if ((ULONG)(IoMax - IoMin) >= (barLength * 3)) {

                    //
                    // There is plenty of room, make a safe guess.  Try
                    // to put it half-way between the upper and lower
                    // bounds, rounding up to the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] = 
                        (((IoMax / 2) + (IoMin / 2)) + barLength) & (barLength -1);

                } else if (barLength >= (IoMax - 
                                         ((IoMin & (barLength -1)) ?
                                            ((IoMin + barLength) & (barLength -1)) :
                                            IoMin))) {
                    //
                    // Space is tight, make a not-so-safe guess.  Try
                    // to put it at the bottom of the range, rounded
                    // up the the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        ((IoMin & (barLength -1)) ?
                                            ((IoMin + barLength) & (barLength -1)) :
                                            IoMin);
                }

                IoMin = (USHORT)pciData->u.type0.BaseAddresses[barNo];
            }

            pciData->Command |= PCI_ENABLE_IO_SPACE;

            PciDevice->BaseAddress[barNo].Type = CmResourceTypePort;
            PciDevice->BaseAddress[barNo].Valid = TRUE;
            PciDevice->BaseAddress[barNo].TranslatedAddress = 
                (PUCHAR)(ULONG_PTR)(pciData->u.type0.BaseAddresses[barNo] &
                PCI_ADDRESS_IO_ADDRESS_MASK);
            PciDevice->BaseAddress[barNo].Length = barLength;

        } else {

            //
            // This is a memory BAR.
            //

            barLength = ((barContents & PCI_ADDRESS_MEMORY_ADDRESS_MASK) - 1) ^
                0xffffffff;

            if (!(pciData->u.type0.BaseAddresses[barNo] &
                  PCI_ADDRESS_MEMORY_ADDRESS_MASK)) {

                //
                // And it's empty.
                //

                if (barLength == 0) continue;

                //
                // Try to fit this memory window half-way between the min and the max.
                //

                if ((ULONG)(MemMax - MemMin) >= (barLength * 3)) {

                    //
                    // There is plenty of room, make a safe guess.  Try
                    // to put it half-way between the upper and lower
                    // bounds, rounding up to the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] = 
                        (ULONG)(((MemMax / 2) + (MemMin / 2))
                                 + barLength) & ~(barLength -1);

                } else if (barLength >= (ULONG)(MemMax - 
                                         ((MemMin & ~(barLength -1)) ?
                                            ((MemMin + barLength) & ~(barLength -1)) :
                                            MemMin))) {
                    //
                    // Space is tight, make a not-so-safe guess.  Try
                    // to put it at the bottom of the range, rounded
                    // up the the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (ULONG)((MemMin & ~(barLength -1)) ?
                                    ((MemMin + barLength) & ~(barLength -1)) :
                                      MemMin);
                }

                MemMin = pciData->u.type0.BaseAddresses[barNo] & 
                    PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            }

            pciData->Command |= PCI_ENABLE_MEMORY_SPACE;

            physicalAddress.HighPart = 0;
            physicalAddress.LowPart = pciData->u.type0.BaseAddresses[barNo] 
                & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            PciDevice->BaseAddress[barNo].Type = CmResourceTypeMemory;
            PciDevice->BaseAddress[barNo].Valid = TRUE;
            PciDevice->BaseAddress[barNo].TranslatedAddress = 
                HalpMapPhysicalMemory64(physicalAddress,
                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(physicalAddress.LowPart, barLength));
            PciDevice->BaseAddress[barNo].Length = barLength;
        }
    }

    pciData->Command |= PCI_ENABLE_BUS_MASTER;

    //
    // Write back any changes we made.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 pciSlot.u.AsULONG,
                                 pciData,
                                 0,
                                 0x40);

    return STATUS_SUCCESS;
}


NTSTATUS
HalpSearchForPciDebuggingDevice(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG                        StartBusNumber,
    IN ULONG                        EndBusNumber,
    IN ULONG                        MinMem,
    IN ULONG                        MaxMem,
    IN USHORT                       MinIo,
    IN USHORT                       MaxIo,
    IN BOOLEAN                      ConfigureBridges
    )
/*++

Routine Description:

    This routine is a helper function for 
    HalpSetupPciDeviceForDebugging.
    
Arguments:

    PciDevice - Structure indicating the device

Return Value:

    STATUS_SUCCESS if the device is configured and usable.

    STATUS_NO_MORE_MATCHES if no device matched the criteria.

    STATUS_UNSUCCESSFUL if the routine fails for other reasons.
--*/
#define TARGET_DEVICE_NOT_FOUND 0x10000
{
    NTSTATUS            status;
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    UCHAR               bus, dev, func, bytesRead;
    PCI_SLOT_NUMBER     pciSlot, targetSlot;
    ULONG               newMinMem, newMaxMem;
    ULONG               newMinIo, newMaxIo;
    ULONG               newMinBus, newMaxBus;
    UCHAR               barNo;
    BOOLEAN             unconfigureBridge;

    pciData = (PPCI_COMMON_CONFIG)buffer;
    pciSlot.u.AsULONG = 0;
    newMinMem = MinMem;
    newMaxMem = MaxMem;
    newMinIo = MinIo;
    newMaxIo = MaxIo;
    newMinBus = StartBusNumber;
    newMaxBus = EndBusNumber;
    bus = (UCHAR)StartBusNumber;
    
  //DbgPrint("HalpSearchForPciDebuggingDevice:\n"
  //         "\tMem: %x-%x\n"
  //         "\tI/O: %x-%x\n"
  //         "\tBus: %x-%x\n"
  //         "\t%s Configuring Bridges\n",
  //         MinMem, MaxMem,
  //         MinIo, MaxIo,
  //         StartBusNumber, EndBusNumber,
  //         ConfigureBridges ? "" : "Not");
    
    //
    // This bit stays set to 1 until we find the device.
    //
    targetSlot.u.bits.Reserved = TARGET_DEVICE_NOT_FOUND;

    while (TRUE) {
        
        UCHAR nextBus;

        nextBus = bus + 1;
        
        HalpFindFreeResourceLimits(bus,
                                   &newMinIo,
                                   &newMaxIo,
                                   &newMinMem,
                                   &newMaxMem,
                                   &newMinBus,
                                   &newMaxBus
                                   );

        for (dev = 0; dev < PCI_MAX_DEVICES; dev++) {
            for (func = 0; func < PCI_MAX_FUNCTION; func++) {

                pciSlot.u.bits.DeviceNumber = dev;
                pciSlot.u.bits.FunctionNumber = func;


                bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(bus,
                                     pciSlot.u.AsULONG,
                                     pciData,
                                     0,
                                     PCI_COMMON_HDR_LENGTH);

                if (bytesRead == 0) continue;

                if (pciData->VendorID != PCI_INVALID_VENDORID) {

                  //DbgPrint("%04x:%04x - %x/%x/%x - \tSlot: %x\n",
                  //         pciData->VendorID,
                  //         pciData->DeviceID,
                  //         pciData->BaseClass,
                  //         pciData->SubClass,
                  //         pciData->ProgIf,
                  //         pciSlot.u.AsULONG);

                    switch (PCI_CONFIGURATION_TYPE(pciData)) {
                    case PCI_DEVICE_TYPE:

                        //
                        // Match first on Bus/Dev/Func
                        //

                        if ((PciDevice->Bus == bus) &&
                            (PciDevice->Slot == pciSlot.u.AsULONG)) {

                          //DbgPrint("\n\nMatched on Bus/Slot\n\n");
                            
                            return HalpSetupUnconfiguredDebuggingDevice(
                                        bus,
                                        pciSlot.u.AsULONG,
                                        newMinIo,
                                        newMaxIo,
                                        newMinMem,
                                        newMaxMem,
                                        PciDevice
                                        );
                        }

                        if ((PciDevice->Bus == MAXULONG) &&
                            (PciDevice->Slot == MAXULONG)) {

                            //
                            // Bus and Slot weren't specified.  Match
                            // on VID/DID.
                            //

                            if ((pciData->VendorID == PciDevice->VendorID) &&
                                (pciData->DeviceID == PciDevice->DeviceID)) {

                              //DbgPrint("\n\nMatched on Vend/Dev\n\n");

                                return HalpSetupUnconfiguredDebuggingDevice(
                                            bus,
                                            pciSlot.u.AsULONG,
                                            newMinIo,
                                            newMaxIo,
                                            newMinMem,
                                            newMaxMem,
                                            PciDevice
                                            );
                            }
                        
                            if ((PciDevice->VendorID == MAXUSHORT) &&
                                (PciDevice->DeviceID == MAXUSHORT)) {

                                //
                                // VID/DID weren't specified.  Match
                                // on class codes.
                                //

                                if ((pciData->BaseClass == PciDevice->BaseClass) &&
                                    (pciData->SubClass == PciDevice->SubClass)) {

                                  //DbgPrint("\n\nMatched on Base/Sub\n\n");
                                    //
                                    // Further match on Programming Interface,
                                    // if specified.
                                    //

                                    if ((PciDevice->ProgIf != MAXUCHAR) &&
                                        (PciDevice->ProgIf != pciData->ProgIf)) {

                                        break;
                                    }

                                  //DbgPrint("\n\nMatched on programming interface\n\n");

                                    return HalpSetupUnconfiguredDebuggingDevice(
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                PciDevice
                                                );
                                }
                            }

                        }
                        
                        break;

                    case PCI_CARDBUS_BRIDGE_TYPE:

                        {
                          ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                          USHORT bridgeIoMin, bridgeIoMax;
                          ULONG LegacyBaseAddress;
                          
                          unconfigureBridge = FALSE;
                            
                        //DbgPrint("Found a CardBus bridge\n");

                          HalpPhase0GetPciDataByOffset(bus,
                                                       pciSlot.u.AsULONG, 
                                                       &LegacyBaseAddress,
                                                       CARDBUS_LEGACY_MODE_BASE_ADDR,
                                                       4);

                          if (!(((LegacyBaseAddress & ~1) == 0) &&
                                (pciData->u.type2.SecondaryBus != 0) &&
                                (pciData->u.type2.SubordinateBus !=0) &&
                                (pciData->u.type2.Range[0].Base != 0) &&
                                (pciData->u.type2.SocketRegistersBaseAddress != 0) &&
                                (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                                (pciData->Command & PCI_ENABLE_IO_SPACE))) {

                              //
                              // The bridge is unconfigured.
                              //

                              if (ConfigureBridges){

                                  //
                                  // We should configure it now.
                                  //
                                  status = HalpConfigureCardBusBridge(
                                                PciDevice,
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                MAX((UCHAR)newMinBus, (bus + 1)),
                                                newMaxBus,
                                                pciData
                                                );
                              
                                  if (!NT_SUCCESS(status)) {
                                      break;
                                  }

                                  unconfigureBridge = TRUE;

                              } else {
                                  
                                  //
                                  // We aren't configuring bridges
                                  // on this pass.
                                  //

                                  break;
                              }

                          }
                                                        

                          bridgeMemMin = pciData->u.type2.Range[0].Base;
                          bridgeMemMax = pciData->u.type2.Range[0].Limit | 0xfff;
                          bridgeIoMin = (USHORT)pciData->u.type2.Range[2].Base;
                          bridgeIoMax = (USHORT)pciData->u.type2.Range[2].Limit | 0x3;

                        //DbgPrint("Configured:  I/O %x-%x  Mem %x-%x\n",
                        //         bridgeIoMin, bridgeIoMax,
                        //         bridgeMemMin, bridgeMemMax); 

                          //
                          // Recurse.
                          //
                          status = HalpSearchForPciDebuggingDevice(
                              PciDevice,
                              (ULONG)pciData->u.type2.SecondaryBus,
                              (ULONG)pciData->u.type2.SubordinateBus,
                              bridgeMemMin,
                              bridgeMemMax,
                              bridgeIoMin,
                              bridgeIoMax,
                              ConfigureBridges);
                          
                          if (NT_SUCCESS(status)) {
                              return status;
                          }
                          
                          if (!unconfigureBridge) {
                              
                              //
                              // Bump up the bus number so that we don't
                              // scan down the busses we just recursed into.
                              //

                              nextBus = pciData->u.type2.SubordinateBus + 1;

                          } else {

                              HalpUnconfigureCardBusBridge(bus,
                                                           pciSlot.u.AsULONG);
                          }
                        }

                        break;
                        
                    case PCI_BRIDGE_TYPE:
                        
                        {
                          ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                          USHORT bridgeIoMin, bridgeIoMax;
                            
                          unconfigureBridge = FALSE;
                        //DbgPrint("Found a PCI to PCI bridge\n");

                          if (!((pciData->u.type1.SecondaryBus != 0) &&
                                (pciData->u.type1.SubordinateBus !=0) &&
                                (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                                (pciData->Command & PCI_ENABLE_IO_SPACE))) {

                              //
                              // The bridge is unconfigured.
                              //

                              if (ConfigureBridges){

                                  //
                                  // We should configure it now.
                                  //
    
                                  status = HalpConfigurePciBridge(
                                                PciDevice,
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                MAX((UCHAR)newMinBus, (bus + 1)),
                                                newMaxBus,
                                                pciData
                                                );
                              
                                  if (!NT_SUCCESS(status)) {
                                      break;
                                  }

                                  unconfigureBridge = TRUE;

                              } else {
                                  
                                  //
                                  // We aren't configuring bridges
                                  // on this pass.
                                  //

                                  break;
                              }

                          }
                                                        
                          bridgeMemMin = PciBridgeMemory2Base(pciData->u.type1.MemoryBase);
                          bridgeMemMax = PciBridgeMemory2Limit(pciData->u.type1.MemoryLimit);
                          bridgeIoMin = (USHORT)PciBridgeIO2Base(pciData->u.type1.IOBase, 0);
                          bridgeIoMax = (USHORT)PciBridgeIO2Limit(pciData->u.type1.IOLimit, 0);

                        //DbgPrint("Configured:  I/O %x-%x  Mem %x-%x\n",
                        //         bridgeIoMin, bridgeIoMax,
                        //         bridgeMemMin, bridgeMemMax); 

                          //
                          // Recurse.
                          //
                          
                          status = HalpSearchForPciDebuggingDevice(
                              PciDevice,
                              (ULONG)pciData->u.type1.SecondaryBus,
                              (ULONG)pciData->u.type1.SubordinateBus,
                              bridgeMemMin,
                              bridgeMemMax,
                              bridgeIoMin,
                              bridgeIoMax,
                              ConfigureBridges);
                          
                          if (NT_SUCCESS(status)) {
                              return status;
                          }
                          
                          if (!unconfigureBridge) {
                              
                              //
                              // Bump up the bus number so that we don't
                              // scan down the busses we just recursed into.
                              //

                              nextBus = pciData->u.type1.SubordinateBus + 1;

                          } else {

                              HalpUnconfigurePciBridge(bus,
                                                       pciSlot.u.AsULONG);
                          }
                        }

                        break;
                    default:
                        break;

                    }

                }

                if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                    (func == 0)) {
                    break;
                }
            }
        }

        if (nextBus >= EndBusNumber) {
            break;
        }

        bus = nextBus;
    }

    return STATUS_NOT_FOUND;
}



NTSTATUS
HalpReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
/*++

Routine Description:

    This routine de-allocates any resources acquired in
    HalpSetupPciDeviceForDebugging.
    
Arguments:

    PciDevice - Structure indicating the device

Return Value:

--*/
{
    ULONG i;

    for (i = 0; i < PCI_TYPE0_ADDRESSES; i++) {

        if (PciDevice->BaseAddress[i].Valid &&
            PciDevice->BaseAddress[i].Type == CmResourceTypeMemory) {

            PciDevice->BaseAddress[i].Valid = FALSE;
            
            HalpUnmapVirtualAddress(PciDevice->BaseAddress[i].TranslatedAddress,
                                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                        PciDevice->BaseAddress[i].TranslatedAddress, 
                                        PciDevice->BaseAddress[i].Length));
        }
    }
    
    return STATUS_SUCCESS;
}

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine fills in the HalPrivateDispatchTable
    with the functions needed for debugging through
    PCI devices.
    
Arguments:

    LoaderBlock - The Loader Block

Return Value:

--*/
{
    
    KdSetupPciDeviceForDebugging = HalpSetupPciDeviceForDebugging;
    KdReleasePciDeviceForDebugging = HalpReleasePciDeviceForDebugging;

#ifdef ACPI_HAL    
    KdGetAcpiTablePhase0 = HalpGetAcpiTablePhase0;
#endif

    KdCheckPowerButton = HalpCheckPowerButton;
    KdMapPhysicalMemory64 = HalpMapPhysicalMemory64;
    KdUnmapVirtualAddress = HalpUnmapVirtualAddress;
}

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    ULONG               disposition;
    ULONG               bus;
    UCHAR               i;
    PCI_SLOT_NUMBER     slot;
    NTSTATUS            status;
    BOOLEAN             debuggerFound = FALSE;

    PAGED_CODE();

    for (i = 0; 
         i < MAX_DEBUGGING_DEVICES_SUPPORTED;
         i++) {

        if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) {
            //
            // Must be using a PCI device for a debugger.
            //
            debuggerFound = TRUE;
        }
    }

    if (!debuggerFound) {
        return;
    }
    
    //
    // Open PCI service key.
    //

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\PCI");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Get the right key

    RtlInitUnicodeString (&UnicodeString,
                          L"Debug");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               BaseHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey (&Handle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_VOLATILE,
                          &disposition);

    ZwClose(BaseHandle);
    BaseHandle = Handle;
    
    ASSERT(disposition == REG_CREATED_NEW_KEY);
    
    if (!NT_SUCCESS(status)) {
        return;
    }

    for (i = 0; 
         i < MAX_DEBUGGING_DEVICES_SUPPORTED;
         i++) {

        if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) {

            //
            // This entry is populated.  Create a key for it.
            //

            RtlInitUnicodeString (&UnicodeString,
                                  L"0");

            (*(PCHAR)&(UnicodeString.Buffer[0])) += i;

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       BaseHandle,
                                       (PSECURITY_DESCRIPTOR) NULL);

            status = ZwCreateKey (&Handle,
                                  KEY_READ,
                                  &ObjectAttributes,
                                  0,
                                  (PUNICODE_STRING) NULL,
                                  REG_OPTION_VOLATILE,
                                  &disposition);

            ASSERT(disposition == REG_CREATED_NEW_KEY);

            //
            // Fill in the values below this key.
            //
            
            bus = HalpPciDebuggingDevice[i].u.bits.BusNumber;

            RtlInitUnicodeString (&UnicodeString,
                                  L"Bus");

            status = ZwSetValueKey (Handle,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &bus,
                                    sizeof(ULONG));

            //ASSERT(NT_SUCCESS(status));

            slot.u.AsULONG = 0;
            slot.u.bits.FunctionNumber = HalpPciDebuggingDevice[i].u.bits.FunctionNumber;
            slot.u.bits.DeviceNumber = HalpPciDebuggingDevice[i].u.bits.DeviceNumber;

            RtlInitUnicodeString (&UnicodeString,
                                  L"Slot");

            status = ZwSetValueKey (Handle,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &slot.u.AsULONG,
                                    sizeof(ULONG));

            //ASSERT(NT_SUCCESS(status));

            ZwClose(Handle);
        }
    }
    
    ZwClose(BaseHandle);
    return;
}

NTSTATUS
HalpConfigurePciBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    )
{
    USHORT  memUnits = 0;
    ULONG   memSize;

    PciData->u.type1.PrimaryBus = (UCHAR)Bus;
    PciData->u.type1.SecondaryBus = (UCHAR)BusMin;
    PciData->u.type1.SubordinateBus = (UCHAR)(MIN(BusMax, (BusMin + 2)));

    PciData->Command &= ~PCI_ENABLE_BUS_MASTER;

  //DbgPrint("HalpConfigurePciBridge: P: %x  S: %x  S: %x\n"
  //         "\tI/O  %x-%x  Mem %x-%x  Bus %x-%x\n",
  //         PciData->u.type1.PrimaryBus,
  //         PciData->u.type1.SecondaryBus,
  //         PciData->u.type1.SubordinateBus,
  //         IoMin, IoMax,
  //         MemMin, MemMax,
  //         BusMin, BusMax);
    
    //
    // Only enable I/O on the bridge if we are looking for
    // something besides a 1394 controller.
    //

    if (!((PciDevice->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
          (PciDevice->SubClass == PCI_SUBCLASS_SB_IEEE1394))) {

        if (((IoMax & 0xf000) - (IoMin & 0xf000)) >= 0X1000) {

            //
            // There is enough I/O space here to enable
            // an I/O window.
            //

            PciData->u.type1.IOBase = 
                (UCHAR)((IoMax & 0xf000) >> 12) - 1;
            PciData->u.type1.IOLimit = PciData->u.type1.IOBase;

            PciData->Command |= PCI_ENABLE_IO_SPACE;
            PciData->Command |= PCI_ENABLE_BUS_MASTER;
        }
    }

    //
    // Enable a memory window if possible.
    //

    memSize = ((MemMax + 1) & 0xfff00000) - (MemMin & 0xfff00000);

    if (memSize >= 0x100000) {

        memUnits = 1;
    }

    if (memSize >= 0x400000) {

        memUnits = 4;
    }

    if (memUnits > 0) {

        //
        // There is enough space.
        //

        PciData->u.type1.MemoryBase = 
            (USHORT)((MemMax & 0xfff00000) >> 16) - (memUnits << 4);

        PciData->u.type1.MemoryLimit = PciData->u.type1.MemoryBase + ((memUnits - 1) << 4);
        
        PciData->Command |= PCI_ENABLE_MEMORY_SPACE;
        PciData->Command |= PCI_ENABLE_BUS_MASTER;
        
    }

    if (PciData->Command & PCI_ENABLE_BUS_MASTER) {
        
        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot,
                                     PciData,
                                     0,
                                     0x24);

        return STATUS_SUCCESS;

    } else {
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
HalpUnconfigurePciBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    )
{
    UCHAR   buffer[0x20] = {0};

    //
    // Zero the command register.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                 2);

    //
    // Zero the address space and bus number registers.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u),
                                 0x20);
}


NTSTATUS
HalpConfigureCardBusBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    )
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    ULONG   ulTemp;
    ULONG SocketRegBase;
    USHORT BridgeControl = 0;
    PCARDBUS_SOCKET_REGS SocketRegs;
    PHYSICAL_ADDRESS physicalAddress;
    static BOOLEAN FirstCall = TRUE;
    UCHAR bytesRead;
    USHORT command, origCmd;

    //
    // First check to see there is a CardBus device in the slot
    // power it on.
    //
    
    //
    // Turn on socket registers in a suitable location
    //
    
    bytesRead = (UCHAR) HalpPhase0GetPciDataByOffset(Bus,
                                                     Slot, 
                                                     &SocketRegBase,
                                                     FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.SocketRegistersBaseAddress),
                                                     4);
                                                     
    if (bytesRead != 4) {
        return STATUS_UNSUCCESSFUL;
    }                                                     

    if (!SocketRegBase) {
        SocketRegBase = ((MemMin + 0xfff) & 0xfffff000);
        
        if ((SocketRegBase + 0x1000) >= MemMax) {
            return STATUS_UNSUCCESSFUL;
        }
    
        //
        // Adjust MemMin to allow the socket registers to remain visible
        //
        MemMin = SocketRegBase + 0x1000;
        
        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot, 
                                     &SocketRegBase,
                                     FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.SocketRegistersBaseAddress),
                                     4);
    }        

    physicalAddress.HighPart = 0;
    physicalAddress.LowPart = SocketRegBase;
    SocketRegs = HalpMapPhysicalMemory64(physicalAddress, 1);
    
    if (!SocketRegs) {
        return STATUS_UNSUCCESSFUL;
    }        
    
    PciData->u.type2.SocketRegistersBaseAddress = SocketRegBase;
    
    //
    // Turn off legacy mode base address
    //
    ulTemp = 0;
    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot, 
                                 &ulTemp,
                                 CARDBUS_LEGACY_MODE_BASE_ADDR,
                                 4);

    //
    // Make sure memory space is enabled
    //                                 
    bytesRead = (UCHAR) HalpPhase0GetPciDataByOffset(Bus,
                                                     Slot, 
                                                     &origCmd,
                                                     FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                                     2);
                                                     
    command = origCmd | PCI_ENABLE_MEMORY_SPACE;
    
    if (command != origCmd) {
        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot,
                                     &command,
                                     FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                     2);
    }
                                         
    //
    // make sure it looks like cardbus socket registers
    //
    if ((SocketRegs->Mask & 0xfffffff0) == 0) {
        //
        // make sure events are disabled
        //
        SocketRegs->Mask = 0;

        HalpKdStallExecution(600);
        
        //
        // See if a CardBus card is in the slot
        //            
        if ((SocketRegs->PresentState & SKTSTATE_CARDTYPE_MASK) == SKTSTATE_CBCARD) {
        
           //
           // power up the card
           //
           
           SocketRegs->Control = SKTPOWER_VCC_033V | SKTPOWER_VPP_033V;

           HalpKdStallExecution(600);

           status = STATUS_SUCCESS;
        }
    }

    //
    // if we don't have a useable cardbus device, clean up and exit
    //    
    if (!NT_SUCCESS(status)) {
        if (command != origCmd) {
            HalpPhase0SetPciDataByOffset(Bus,
                                         Slot,
                                         &origCmd,
                                         FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                         2);
        }
                                             
        //
        // turn socket registers back off
        //    
        SocketRegBase = 0;
        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot, 
                                     &SocketRegBase,
                                     FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.SocketRegistersBaseAddress),
                                     4);
        return status;
    }
    
    //
    // Make sure CBRST is off
    //
    
    HalpPhase0GetPciDataByOffset(Bus,
                                 Slot, 
                                 &BridgeControl,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.BridgeControl),
                                 2);

    if (BridgeControl & CARDBUS_BRIDGE_CONTROL_RESET) {

        BridgeControl &= ~CARDBUS_BRIDGE_CONTROL_RESET;
        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot, 
                                     &BridgeControl,
                                     FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.BridgeControl),
                                     2);
    }                                     
    

    PciData->u.type2.PrimaryBus = (UCHAR)Bus;
    PciData->u.type2.SecondaryBus = (UCHAR)BusMin;
    PciData->u.type2.SubordinateBus = (UCHAR)(MIN(BusMax, (BusMin + 2)));

    PciData->Command &= ~PCI_ENABLE_BUS_MASTER;

  //DbgPrint("HalpConfigureCardBusBridge: P: %x  S: %x  S: %x\n"
  //         "\tI/O  %x-%x  Mem %x-%x  Bus %x-%x\n",
  //         PciData->u.type2.PrimaryBus,
  //         PciData->u.type2.SecondaryBus,
  //         PciData->u.type2.SubordinateBus,
  //         IoMin, IoMax,
  //         MemMin, MemMax,
  //         BusMin, BusMax);
    
    //
    // Only enable I/O on the bridge if we are looking for
    // something besides a 1394 controller.
    //

    if (!((PciDevice->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
          (PciDevice->SubClass == PCI_SUBCLASS_SB_IEEE1394))) {

        PciData->u.type2.Range[2].Base = IoMin;
        PciData->u.type2.Range[2].Limit = IoMax & 0xffc;

        PciData->Command |= PCI_ENABLE_IO_SPACE;
        PciData->Command |= PCI_ENABLE_BUS_MASTER;
    }

    //
    // Enable a memory window if possible.
    //

    if (MemMax > MemMin) {

        PciData->u.type2.Range[0].Base = MemMin;
        PciData->u.type2.Range[0].Limit = MemMax & 0xfffff000;
        
        PciData->Command |= PCI_ENABLE_MEMORY_SPACE;
        PciData->Command |= PCI_ENABLE_BUS_MASTER;
        
    }

    
    if (PciData->Command & PCI_ENABLE_BUS_MASTER) {
        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot,
                                     PciData,
                                     0,
                                     0x3c);
        return STATUS_SUCCESS;

    } else {
        return STATUS_UNSUCCESSFUL;
    }
}


VOID
HalpUnconfigureCardBusBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    )
{
    UCHAR   buffer[0x2c] = {0};
    ULONG SocketRegBase = 0xffffffff;
    PCARDBUS_SOCKET_REGS SocketRegs;
    PHYSICAL_ADDRESS physicalAddress;

    HalpPhase0GetPciDataByOffset(Bus,
                                 Slot, 
                                 &SocketRegBase,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u.type2.SocketRegistersBaseAddress),
                                 4);

    if (SocketRegBase) {                                 
        physicalAddress.HighPart = 0;
        physicalAddress.LowPart = SocketRegBase;
        SocketRegs = HalpMapPhysicalMemory64(physicalAddress, 1);
        
        //
        // Turn power back off
        //

        if (SocketRegs) {        
            SocketRegs->Control = 0;
        }            

    }        
    //
    // Zero the command register.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                 2);

    //
    // Zero the address space and bus number registers.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u),
                                 0x2c);
}

ULONG
HalpKdStallExecution(
    ULONG   LoopCount
    )
{
    ULONG i,j,b,k,l;

    b = 1;

    for (k=0;k<LoopCount;k++) {

        for (i=1;i<100000;i++) {

            PAUSE_PROCESSOR
            b=b* (i>>k);

        }

    };

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\pcip.h ===
//
// Hal specific PCI bus structures
//
// Copyright (c) 1995-1999  Microsoft Corporation
//

typedef struct _TYPE2EXTRAS {
    USHORT  SubVendorID;
    USHORT  SubSystemID;
    ULONG   LegacyModeBaseAddress;
} TYPE2EXTRAS;

typedef NTSTATUS
(*PciIrqRange) (
    IN PBUS_HANDLER     BusHandler,
    IN PBUS_HANDLER     RootHandler,
    IN PCI_SLOT_NUMBER  PciSlot,
    OUT PSUPPORTED_RANGE *Interrupt
    );

typedef struct tagPCIPBUSDATA {

    //
    // Defined PCI data
    //

    PCIBUSDATA      CommonData;

    //
    // Implementation specific data
    //

    union {
        struct {
            PULONG  Address;
            ULONG   Data;
        } Type1;
        struct {
            PUCHAR  CSE;
            PUCHAR  Forward;
            ULONG   Base;
        } Type2;
    } Config;

    ULONG           MaxDevice;
    PciIrqRange     GetIrqRange;

    BOOLEAN         BridgeConfigRead;
    UCHAR           ParentBus;
    BOOLEAN         Subtractive;
    UCHAR           reserved[1];
    UCHAR           SwizzleIn[4];

    RTL_BITMAP      DeviceConfigured;
    ULONG           ConfiguredBits[PCI_MAX_DEVICES * PCI_MAX_FUNCTION / 32];

    USHORT          IrqMask;
} PCIPBUSDATA, *PPCIPBUSDATA;

#define PciBitIndex(Dev,Fnc)   (Fnc*32 + Dev);

#define PCI_CONFIG_TYPE(PciData)    ((PciData)->HeaderType & ~PCI_MULTIFUNCTION)

#define Is64BitBaseAddress(a)   \
            (((a & PCI_ADDRESS_IO_SPACE) == 0)  &&  \
             ((a & PCI_ADDRESS_MEMORY_TYPE_MASK) == PCI_TYPE_64BIT))


//
// Orion B0 errata workaround
//

struct {
    PBUS_HANDLER        Handler;
    PCI_SLOT_NUMBER     Slot;
} HalpOrionOPB;

typedef ULONG (*FncConfigIO) (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

typedef VOID (*FncSync) (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

typedef VOID (*FncReleaseSync) (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    );

typedef struct _PCI_CONFIG_HANDLER {
    FncSync         Synchronize;
    FncReleaseSync  ReleaseSynchronzation;
    FncConfigIO     ConfigRead[3];
    FncConfigIO     ConfigWrite[3];
} PCI_CONFIG_HANDLER, *PPCI_CONFIG_HANDLER;

extern KSPIN_LOCK HalpPCIConfigLock;
extern PCI_CONFIG_HANDLER PCIConfigHandler;
extern const PCI_CONFIG_HANDLER PCIConfigHandlerType1;
extern const PCI_CONFIG_HANDLER PCIConfigHandlerType2;

//
// Feature types (for PCI_CARD_DESCRIPTOR)
//
#define PCIFT_FULLDECODE_HOSTBRIDGE   0x00001

//
// Card flags (for PCI_CARD_DESCRIPTOR)
//
#define PCICF_CHECK_REVISIONID        0x10000
#define PCICF_CHECK_SSVID             0x20000
#define PCICF_CHECK_SSID              0x40000

//
// Description of a PCI card.
//
typedef struct _PCI_CARD_DESCRIPTOR {

    ULONG   Flags;
    USHORT  VendorID;
    USHORT  DeviceID;
    USHORT  RevisionID;
    USHORT  SubsystemVendorID;
    USHORT  SubsystemID;
    USHORT  Reserved;

} PCI_CARD_DESCRIPTOR;

//
// Superclass of PCI_REGISTRY_INFO
//
typedef struct _PCI_REGISTRY_INFO_INTERNAL {

    struct              _PCI_REGISTRY_INFO; // unnamed structure.
    ULONG               ElementCount;
    PCI_CARD_DESCRIPTOR CardList[]; // Zero entries.

} PCI_REGISTRY_INFO_INTERNAL, *PPCI_REGISTRY_INFO_INTERNAL;

//
// The venerable IRQXOR has got to go, as it now has to extend into
// the PCI driver.  And that would require the PCI driver to match
// the HAL in its checked/free nature.
//

//#if DBG
//#define IRQXOR 0x2B
//#else
#define IRQXOR 0
//#endif


//
// Prototypes for functions in ixpcibus.c
//

VOID
HalpInitializePciBus (
    VOID
    );

VOID
HalpInitializePciStubs (
    VOID
    );

PPCI_REGISTRY_INFO_INTERNAL
HalpQueryPciRegistryInfo (
    VOID
    );

BOOLEAN
HalpIsRecognizedCard(
    IN PPCI_REGISTRY_INFO_INTERNAL  PCIRegInfo,
    IN PPCI_COMMON_CONFIG           PciData,
    IN ULONG                        FeatureMask
    );

VOID
HalpReadPCIConfig (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


VOID
HalpWritePCIConfig (
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

PBUS_HANDLER
HalpAllocateAndInitPciBusHandler (
    IN ULONG        HwType,
    IN ULONG        BusNo,
    IN BOOLEAN      TestAllocation
    );


BOOLEAN
HalpIsValidPCIDevice (
    IN PBUS_HANDLER  BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

BOOLEAN
HalpValidPCISlot (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

VOID HalpPCISynchronizeType1 (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType1 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    );

VOID
HalpPCISynchronizeOrionB0 (
    IN PBUS_HANDLER         BusHandler,
    IN PCI_SLOT_NUMBER      Slot,
    IN PKIRQL               Irql,
    IN PPCI_TYPE1_CFG_BITS  PciCfg1
    );

VOID
HalpPCIReleaseSynchronzationOrionB0 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType1 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

VOID HalpPCISynchronizeType2 (
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN PKIRQL           Irql,
    IN PVOID            State
    );

VOID HalpPCIReleaseSynchronzationType2 (
    IN PBUS_HANDLER     BusHandler,
    IN KIRQL            Irql
    );

ULONG HalpPCIReadUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIReadUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUlongType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUcharType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG HalpPCIWriteUshortType2 (
    IN PPCIPBUSDATA     BusData,
    IN PVOID            State,
    IN PUCHAR           Buffer,
    IN ULONG            Offset
    );

ULONG
HalpGetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignPCISlotResources (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

//
// Prototypes for functions in ixpciint.c
//

ULONG
HalpGetPCIIntOnISABus (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

VOID
HalpPCIAcquireType2Lock (
    PKSPIN_LOCK SpinLock,
    PKIRQL      Irql
    );

VOID
HalpPCIReleaseType2Lock (
    PKSPIN_LOCK SpinLock,
    KIRQL       Irql
    );

NTSTATUS
HalpAdjustPCIResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

VOID
HalpPCIPin2ISALine (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

VOID
HalpPCIISALine2Pin (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

NTSTATUS
HalpGetISAFixedPCIIrq (
    IN PBUS_HANDLER      BusHandler,
    IN PBUS_HANDLER      RootHandler,
    IN PCI_SLOT_NUMBER   PciSlot,
    OUT PSUPPORTED_RANGE  *Interrupt
    );

//
// Prototypes for functions in ixpcibrd.c
//

BOOLEAN
HalpGetPciBridgeConfig (
    IN ULONG            HwType,
    IN PUCHAR           MaxPciBus
    );

VOID
HalpFixupPciSupportedRanges (
    IN ULONG MaxBuses
    );

//
// Prototypes for functions in pmpcisup.c
//

ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

#if DBG
#define DBGMSG(a)   DbgPrint(a)
VOID
HalpTestPci (
    ULONG
    );
#else
#define DBGMSG(a)
#endif

#ifdef SUBCLASSPCI

VOID
HalpSubclassPCISupport (
    IN PBUS_HANDLER BusHandler,
    IN ULONG        HwType
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxbiosa.asm ===
;++
;
; Copyright (c) 1991  Microsoft Corporation
;
; Module Name:
;
;     xxbiosa.asm
;
; Abstract:
;
;     This implements the necessary code to put the processor into
;     V86 mode, make a BIOS call, and return safely to protected mode.
;
; Author:
;
;     John Vert (jvert) 29-Oct-1991
;
; Environment:
;
;     Kernel mode
;
; Notes:
;
;     This module is intended for use in panic situations, such as a bugcheck.
;     As a result, we cannot rely on the integrity of the system so we must
;     handle everything ourselves.  Notably, we must map our own memory by
;     adding our own page tables and PTEs.
;
;     We also cannot call KeBugCheck when we notice something has gone wrong.
;
; Revision History:
;
;--
.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
        .list

        extrn   _DbgPrint:proc
        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT

        public  _HalpRealModeStart
        public  _HalpRealModeEnd
;
; 32-bit override
;
OVERRIDE        equ     66h

;
; Reginfo structure
;

RegInfo struc
RiSegSs         dd 0
RiEsp           dd 0
RiEFlags        dd 0
RiSegCs         dd 0
RiEip           dd 0
RiTrapFrame     dd 0
RiCsLimit       dd 0
RiCsBase        dd 0
RiCsFlags       dd 0
RiSsLimit       dd 0
RiSsBase        dd 0
RiSsFlags       dd 0
RiPrefixFlags   dd 0
RegInfo ends
REGINFOSIZE     EQU 52

INT_NN_OPCODE   EQU     0CDH

        page ,132
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; In order to return to the calling function after we've trapped out of
; V86 mode, we save our ESP value here.
;
HalpSavedEsp    dd      0

_DATA   ENDS


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:NOTHING, ES:NOTHING, SS:FLAT, FS:NOTHING, GS:NOTHING

if DBG
        page ,132
        subttl "Processing Exception occurred in ABIOS code"
;++
; VOID
; KiAbiosException (
;    VOID
;    )
;
; Routine Description:
;
;    This routine is called after an exception being detected
;    in ABIOS ROM code.  The system will switch 16 stack to 32 bit
;    stack and bugcheck.
;
;    N.B.  In fact this routine is simply used to resolve a reference
;          to KiAbiosException routine in the Kimacro.inc ENTER_TRAP
;          macro.
;
;
; Arguments:
;
;    None.
;
; Return value:
;
;    system stopped.
;
;--
        public  _KiAbiosException
_KiAbiosException proc
_Ki16BitStackException:
        ret

_KiAbiosException endp

endif


;++
; ULONG
; HalpBorrowTss (
;    VOID
;    )
;
; Routine Description:
;
;    This routine checks if the current TSS has IO MAP space.
;    if yes, it simply returns.  Otherwise, it switches to use
;    the regular TSS.
;
; Arguments:
;
;    None.
;
; Return value:
;
;    Return original TSS selector if the regular Tss is borrowed by us.
;
;--
cPublicProc _HalpBorrowTss, 0
cPublicFpo 0, 0

        xor     eax, eax
        str     ax
        mov     edx, PCR[PcGdt]
        add     edx, eax                        ; (edx)->Gdt Entry of current
                                                ;        TSS
        xor     ecx, ecx
        mov     cl, [edx].KgdtLimitHi
        shl     ecx, 16
        mov     cx, [edx].KgdtLimitLow          ; (ecx) = TSS limit
        cmp     ecx, 2000H                      ; Is Io map space available?
        ja      short Hbt99                     ; if a, yes, return

        sub     edx, eax                        ; (edx)->GDT table
        mov     ch, [edx+KGDT_TSS+KgdtBaseHi]
        mov     cl, [edx+KGDT_TSS+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [edx+KGDT_TSS+KgdtBaseLow]
        mov     PCR[PcTss], ecx
        mov     ecx, KGDT_TSS                   ; switch to use regular TSS
        mov     byte ptr [edx+KGDT_TSS+5], 089h ; 32bit, dpl=0, present, TSS32,
                                                ; not busy.
        ltr     cx
        stdRET  _HalpBorrowTss                  ; (eax) = Original TSS sel

Hbt99:
        xor     eax, eax                        ; No TSS swapped
        stdRET  _HalpBorrowTss

stdENDP _HalpBorrowTss


;++
; VOID
; HalpReturnTss (
;    ULONG TssSelector
;    )
;
; Routine Description:
;
;    This routine switches the current TSS from regular TSS back to
;    the panic TSS (NMI TSS or Double fault TSS).
;
; Arguments:
;
;    TssSelector - the TSS selector to return to.
;
; Return value:
;
;    None.
;
;--
cPublicProc _HalpReturnTss, 1
cPublicFpo 1, 0

        mov     edx, PCR[PcGdt]                 ; (edx)-> Gdt table
        mov     eax, [esp + 4]
        and     eax, 0FFFFh                     ; (eax)= New TSS sel
        add     edx, eax                        ; (edx)->Gdt Entry of new TSS

        mov     ch, [edx+KgdtBaseHi]
        mov     cl, [edx+KgdtBaseMid]
        shl     ecx, 16
        mov     cx, [edx+KgdtBaseLow]
        mov     PCR[PcTss], ecx
        mov     byte ptr [edx+5], 089h          ; 32bit, dpl=0, present, TSS32,
        ltr     ax
        stdRET  _HalpReturnTss                  ; return and clear stack

stdENDP _HalpReturnTss

;++
;
; VOID
; HalpBiosCall
;     VOID
;     )
;
; Routine Description:
;
;     This routine completes the transition to real mode, calls BIOS, and
;     returns to protected mode.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--
;;ALIGN 4096
cPublicProc _HalpBiosCall   ,0

        push    ebp
        mov     ebp, esp
        pushfd
        push    edi
        push    esi
        push    ebx
        push    ds
        push    es
        push    fs
        push    gs
        push    offset FLAT:HbcProtMode         ; address where we will start
                                                ; protected mode again once
                                                ; V86 has completed.
        mov     HalpSavedEsp, esp

        mov     eax, cr0                        ; make sure alignment
        and     eax, not CR0_AM                 ; checks are disabled
        mov     cr0, eax

;
; Create space for the V86 trap frame and update the ESP0 value in the TSS
; to use this space.  We will set this up just below our current stack pointer.
; The stuff we push on the stack after we set ESP0 is irrelevant once we
; make it to V86 mode, so it's ok to blast it.
;
        mov     esi, fs:PcTss                   ; (esi) -> TSS
        mov     eax, esp
        sub     eax, NPX_FRAME_LENGTH           ; skip FP save area
        mov     [esi]+TssEsp0, eax

        push    dword ptr 0h                    ; V86 GS
        push    dword ptr 0h                    ; V86 FS
        push    dword ptr 0h                    ; V86 DS
        push    dword ptr 0h                    ; V86 ES
        push    dword ptr 2000h                 ; V86 SS

;
; We calculate the V86 sp by adding the difference between the linear address
; of the V86 ip (HbcReal) and the linear address of the V86 sp (HbcV86Stack)
; to the offset of the V86 ip (HbcReal & 0xfff).
;

        mov     eax, offset FLAT:HbcV86Stack-4
        sub     eax, offset FLAT:HbcReal
        mov     edx, offset HbcReal        
        and     edx, 0fffh
        add     eax, edx
        push    eax                              ; V86 esp

        pushfd
        or      dword ptr [esp], EFLAGS_V86_MASK; V86 eflags
        or      [esp], 03000h                   ; Give IOPL3
        push    dword ptr 2000h                 ; V86 CS
        mov     eax, offset HbcReal
        and     eax, 0fffh

        push    edx                             ; V86-mode EIP is offset
                                                ; into CS.
        iretd

_HalpRealModeStart      label   byte

HbcReal:
        db      OVERRIDE        ; make mov 32-bits
        mov     eax, 12h        ; 640x480x16 colors
        int     10h

        db      0c4h, 0c4h      ; BOP to indicate V86 mode is done.

;
; V86-mode stack
;
align 4
        db      2048 dup(0)
HbcV86Stack:

_HalpRealModeEnd        label   byte

HbcProtMode:
;
; We are back from V86 mode, so restore everything we saved and we are done.
;
        pop     gs
        pop     fs
        pop     es
        pop     ds
        pop     ebx
        pop     esi
        pop     edi
        popfd
        pop     ebp
        stdRET    _HalpBiosCall

        public  _HalpBiosCallEnd
_HalpBiosCallEnd label byte



_HalpBiosCall   endp


        subttl "HAL General Protection Fault"
;++
;
; Routine Description:
;
;    Handle General protection fault.
;
;    This fault handler is used by the HAL for V86 mode faults only.
;    It should NEVER be used except when running in V86 mode.  The HAL
;    replaces the general-purpose KiTrap0D handler entry in the IDT with
;    this routine.  This allows us to emulate V86-mode instructions which
;    cause a fault.  After we return from V86 mode, we can restore the
;    KiTrap0D handler in the IDT.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:FLAT

        ENTER_DR_ASSIST Htd_a, Htd_t, NoAbiosAssist
cPublicProc _HalpTrap0D     ,0

        ENTER_TRAP Htd_a, Htd_t

;
;   Did the trap occur in V86 mode?  If not, something is completely messed up.
;
        test    dword ptr [ebp]+TsEFlags,00020000H
        jnz     Ht0d10

;
; The trap was not from V86 mode, so something is very wrong.  We cannot
; BugCheck, since we are probably already in a BugCheck.  So just stop.
;

if DBG
_TEXT segment
MsgBadHalTrap   db 'HAL: Trap0D while not in V86 mode',0ah,0dh,0
_TEXT ends

        push    offset FLAT:MsgBadHalTrap
        call    _DbgPrint
        add     esp,4
        stdCall   _DbgBreakPoint
endif
;
; We can't bugcheck, so just commit suicide.  Maybe we should reboot?
;
        jmp     $

Ht0d10:
        stdCall   HalpDispatchV86Opcode
        SPURIOUS_INTERRUPT_EXIT
stdENDP _HalpTrap0d

        subttl "HAL Invalid Opcode Fault"
;++
;
; Routine Description:
;
;    Handle invalid opcode fault
;
;    This fault handler is used by the HAL to indicate when V86 mode
;    execution is finished.  The V86 code attempts to execute an invalid
;    instruction (BOP) when it is done, and that brings us here.
;    This routine just removes the trap frame from the stack and does
;    a RET.  Note that this assumes that ESP0 in the TSS has been set
;    up to point to the top of the stack that we want to be running on
;    when the V86 call has completed.
;
;    This should NEVER be used except when running in V86 mode.  The HAL
;    replaces the general-purpose KiTrap06 handler entry in the IDT with
;    this routine.  It also sets up ESP0 in the TSS appropriately.  After
;    the V86 call has completed, it restores these to their previous values.
;
; Arguments:
;
;    At entry, the saved CS:EIP point to the faulting instruction
;    Error code (whose value depends on detected condition) is provided.
;
; Return value:
;
;    None
;
;--
        ASSUME  DS:FLAT, SS:NOTHING, ES:FLAT

cPublicProc _HalpTrap06     ,0
        mov     eax,KGDT_R3_DATA OR RPL_MASK
        mov     ds,ax
        mov     es,ax
        mov     esp, HalpSavedEsp
        ret

stdENDP _HalpTrap06

        subttl "Instruction Emulation Dispatcher"
;++
;
;   Routine Description:
;
;       This routine dispatches to the opcode specific emulation routine,
;       based on the first byte of the opcode.  Two byte opcodes, and prefixes
;       result in another level of dispatching, from the handling routine.
;
;       This code blatantly stolen from ke\i386\instemul.asm
;
;   Arguments:
;
;       ebp = pointer to trap frame
;
;   Returns:
;
;       Nothing
;

cPublicProc HalpDispatchV86Opcode ,0

RI      equ     [ebp - REGINFOSIZE]
        push    ebp
        mov     ebp,esp
        sub     esp,REGINFOSIZE
        push    esi
        push    edi

        ; Initialize RegInfo

        mov     esi,[ebp]
        mov     RI.RiTrapFrame,esi
        movzx   eax,word ptr [esi].TsHardwareSegSs
        mov     RI.RiSegSs,eax
        mov     eax,[esi].TsHardwareEsp
        mov     RI.RiEsp,eax
        mov     eax,[esi].TsEFlags
        mov     RI.RiEFlags,eax
        movzx   eax,word ptr [esi].TsSegCs
        mov     RI.RiSegCs,eax
        mov     eax,[esi].TsEip
        mov     RI.RiEip,eax

        xor     eax,eax
        mov     RI.RiPrefixFlags,eax
        lea     esi,RI

;
; Convert CS to a linear address
;

        mov     eax,[esi].RiSegCs
        shl     eax,4
        mov     [esi].RiCsBase,eax
        mov     [esi].RiCsLimit,0FFFFh
        mov     [esi].RiCsFlags,0

        mov     edi,RI.RiEip
        cmp     edi,RI.RiCsLimit
        ja      doerr

        add     edi,RI.RiCsBase
        mov     dl, [edi]                               ; get faulting opcode
        cmp     dl, INT_NN_OPCODE
        je      short @f

        stdCall HalpOpcodeInvalid
        jmp     short doerr

@@:
        stdCall HalpOpcodeINTnn
        test    eax,0FFFFh
        jz      do20

        mov     edi,RI.RiTrapFrame
        mov     eax,RI.RiEip                            ; advance eip
        mov     [edi].TsEip,eax
        mov     eax,1
do20:   pop     edi
        pop     esi
        mov     esp,ebp
        pop     ebp
        ret

doerr:  xor     eax,eax
        jmp     do20
stdENDP HalpDispatchV86Opcode

        page   ,132
        subttl "Invalid Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine handles invalid opcodes.  It prints the invalid
;       opcode message, and breaks into the kernel debugger.
;
;   Arguments:
;
;       esi = address of reg info
;       edx = opcode
;
;   Returns:
;
;       nothing
;

_TEXT segment
HalpMsgInvalidOpcode db 'HAL: An invalid V86 opcode was encountered at '
                     db 'address %x:%x',0ah, 0dh, 0
_TEXT ends

cPublicProc HalpOpcodeInvalid ,0

        push    [esi].RiEip
        push    [esi].RiSegCs
        push    offset FLAT:HalpMsgInvalidOpcode
        call    _DbgPrint               ; display invalid opcode message
        add     esp,12
        int     3
        xor     eax,eax
        stdRET    HalpOpcodeInvalid

stdENDP HalpOpcodeInvalid

        subttl "INTnn Opcode Handler"
;++
;
;   Routine Description:
;
;       This routine emulates an INTnn opcode.  It retrieves the handler
;       from the IVT, pushes the current cs:ip and flags on the stack,
;       and dispatches to the handler.
;
;   Arguments:
;
;       esi = address of reg info
;       edx = opcode
;
;   Returns:
;
;       Current CS:IP on user stack
;       RiCs:RiEip -> handler from IVT
;

cPublicProc HalpOpcodeINTnn ,0

        push    ebp
        push    edi
        push    ebx

;
; Convert SS to linear address
;
        mov     eax,[esi].RiSegSs
        shl     eax,4
        mov     [esi].RiSsBase,eax
        mov     [esi].RiSsLimit,0FFFFh
        mov     [esi].RiSsFlags,0

        inc     [esi].RiEip                     ; point to int #
        mov     edi,[esi].RiEip
        cmp     edi,[esi].RiCsLimit
        ja      oinerr

        add     edi,[esi].RiCsBase
        movzx   ecx,byte ptr [edi]              ; get int #
        inc     [esi].RiEip                     ; inc past end of instruction
        stdCall   HalpPushInt
        test    eax,0FFFFh
        jz      oin20                           ; error!
;
;  Note:  Some sort of check for BOP should go here, or in push int.
;

        mov     ebp,[esi].RiTrapFrame
        mov     eax,[esi].RiSegSs
        mov     [ebp].TsHardwareSegSs,eax
        mov     eax,[esi].RiEsp
        mov     [ebp].TsHardwareEsp,eax
        mov     eax,[esi].RiSegCs
        mov     [ebp].TsSegCs,eax
        mov     eax,[esi].RiEFlags
        mov     [ebp].TsEFlags,eax
        mov     eax,1
oin20:  pop     ebx
        pop     edi
        pop     ebp
        stdRET    HalpOpcodeINTnn

oinerr: xor     eax,eax
        jmp     oin20

stdENDP HalpOpcodeINTnn

        page   ,132
        subttl "Push Interrupt frame on user stack"
;++
;
;   Routine Description:
;
;       This routine pushes an interrupt frame on the user stack
;
;   Arguments:
;
;       ecx = interrupt #
;       esi = address of reg info
;   Returns:
;
;       interrupt frame pushed on stack
;       reg info updated
;
cPublicProc HalpPushInt ,0
        push    ebx

        mov     edx,[esi].RiEsp
        mov     ebx,[esi].RiSsBase
        and     edx,0FFFFh              ; only use a 16 bit sp
        sub     dx,2
        mov     ax,word ptr [esi].RiEFlags
        mov     [ebx+edx],ax            ; push flags
        sub     dx,2
        mov     ax,word ptr [esi].RiSegCs
        mov     [ebx+edx],ax            ; push cs
        sub     dx,2
        mov     ax,word ptr [esi].RiEip
        mov     [ebx+edx],ax            ; push ip
        mov     eax,[ecx*4]             ; get new cs:ip value
        push    eax
        movzx   eax,ax
        mov     [esi].RiEip,eax
        pop     eax
        shr     eax,16
        mov     [esi].RiSegCs,eax
        mov     word ptr [esi].RiEsp,dx

;
; Convert CS to a linear address
;

        mov     eax,[esi].RiSegCs
        shl     eax,4
        mov     [esi].RiCsBase,eax
        mov     [esi].RiCsLimit,0FFFFh
        mov     [esi].RiCsFlags,0

        mov     eax,1                   ; success
pi80:   pop     ebx
        stdRET    HalpPushInt
stdENDP HalpPushInt


_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to enable/disable system
;    interrupts.
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;--


.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
        .list

        extrn   KiI8259MaskTable:DWORD
        EXTRNP  _KeBugCheck,1,IMPORT

ifdef IRQL_METRICS
        extrn   HalPostponedIntCount:dword
endif
        extrn   _HalpEisaELCR:dword     ; Set bit indicates LEVEL
        extrn   _HalpEisaIrqIgnore:dword
        extrn   SWInterruptHandlerTable:dword
        extrn   _HalpIrqMiniportInitialized:dword
        extrn   HalpHardwareInterruptLevel:proc
        extrn   _PciirqmpGetTrigger@4:proc
        extrn   _PciirqmpSetTrigger@4:proc

;
; Constants used to initialize CMOS/Real Time Clock
;

CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port

;
; Macros to Read/Write/Reset CMOS to initialize RTC
;

; CMOS_READ
;
; Description: This macro read a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Return: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

_DATA   SEGMENT DWORD PUBLIC 'DATA'

align   dword
;
; HalDismissSystemInterrupt does an indirect jump through this table so it
; can quickly execute specific code for different interrupts.
;
        public  HalpSpecialDismissTable
HalpSpecialDismissTable label   dword
        dd      offset FLAT:HalpDismissNormal   ; irq 0
        dd      offset FLAT:HalpDismissNormal   ; irq 1
        dd      offset FLAT:HalpDismissNormal   ; irq 2
        dd      offset FLAT:HalpDismissNormal   ; irq 3
        dd      offset FLAT:HalpDismissNormal   ; irq 4
        dd      offset FLAT:HalpDismissNormal   ; irq 5
        dd      offset FLAT:HalpDismissNormal   ; irq 6
        dd      offset FLAT:HalpDismissIrq07    ; irq 7
        dd      offset FLAT:HalpDismissNormal   ; irq 8
        dd      offset FLAT:HalpDismissNormal   ; irq 9
        dd      offset FLAT:HalpDismissNormal   ; irq A
        dd      offset FLAT:HalpDismissNormal   ; irq B
        dd      offset FLAT:HalpDismissNormal   ; irq C
        dd      offset FLAT:HalpDismissIrq0d    ; irq D
        dd      offset FLAT:HalpDismissNormal   ; irq E
        dd      offset FLAT:HalpDismissIrq0f    ; irq F
        dd      offset FLAT:HalpDismissNormal   ; irq 10
        dd      offset FLAT:HalpDismissNormal   ; irq 11
        dd      offset FLAT:HalpDismissNormal   ; irq 12
        dd      offset FLAT:HalpDismissNormal   ; irq 13
        dd      offset FLAT:HalpDismissNormal   ; irq 14
        dd      offset FLAT:HalpDismissNormal   ; irq 15
        dd      offset FLAT:HalpDismissNormal   ; irq 16
        dd      offset FLAT:HalpDismissNormal   ; irq 17
        dd      offset FLAT:HalpDismissNormal   ; irq 18
        dd      offset FLAT:HalpDismissNormal   ; irq 19
        dd      offset FLAT:HalpDismissNormal   ; irq 1A
        dd      offset FLAT:HalpDismissNormal   ; irq 1B
        dd      offset FLAT:HalpDismissNormal   ; irq 1C
        dd      offset FLAT:HalpDismissNormal   ; irq 1D
        dd      offset FLAT:HalpDismissNormal   ; irq 1E
        dd      offset FLAT:HalpDismissNormal   ; irq 1F
        dd      offset FLAT:HalpDismissNormal   ; irq 20
        dd      offset FLAT:HalpDismissNormal   ; irq 21
        dd      offset FLAT:HalpDismissNormal   ; irq 22
        dd      offset FLAT:HalpDismissNormal   ; irq 23

_DATA   ENDS

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

        public  HalpSpecialDismissLevelTable
HalpSpecialDismissLevelTable label   dword
        dd      offset FLAT:HalpDismissLevel        ; irq 0
        dd      offset FLAT:HalpDismissLevel        ; irq 1
        dd      offset FLAT:HalpDismissLevel        ; irq 2
        dd      offset FLAT:HalpDismissLevel        ; irq 3
        dd      offset FLAT:HalpDismissLevel        ; irq 4
        dd      offset FLAT:HalpDismissLevel        ; irq 5
        dd      offset FLAT:HalpDismissLevel        ; irq 6
        dd      offset FLAT:HalpDismissIrq07Level   ; irq 7
        dd      offset FLAT:HalpDismissLevel        ; irq 8
        dd      offset FLAT:HalpDismissLevel        ; irq 9
        dd      offset FLAT:HalpDismissLevel        ; irq A
        dd      offset FLAT:HalpDismissLevel        ; irq B
        dd      offset FLAT:HalpDismissLevel        ; irq C
        dd      offset FLAT:HalpDismissIrq0dLevel   ; irq D
        dd      offset FLAT:HalpDismissLevel        ; irq E
        dd      offset FLAT:HalpDismissIrq0fLevel   ; irq F

_TEXT   ENDS

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;BOOLEAN
;HalBeginSystemInterrupt(
;    IN KIRQL Irql
;    IN CCHAR Vector,
;    OUT PKIRQL OldIrql
;    )
;
;
;
;Routine Description:
;
;    This routine is used to dismiss the specified vector number.  It is called
;    before any interrupt service routine code is executed.
;
;    N.B.  This routine does NOT preserve EAX or EBX
;
;    On a UP machine the interrupt dismissed at BeginSystemInterrupt time.
;    This is fine since the irql is being raise to mask it off.
;    HalEndSystemInterrupt is simply a LowerIrql request.
;
;
;Arguments:
;
;    Irql   - Supplies the IRQL to raise to
;
;    Vector - Supplies the vector of the interrupt to be dismissed
;
;    OldIrql- Location to return OldIrql
;
;
;Return Value:
;
;    FALSE - Interrupt is spurious and should be ignored
;
;    TRUE -  Interrupt successfully dismissed and Irql raised.
;
;--
align dword
HbsiIrql        equ     byte  ptr [esp+4]
HbsiVector      equ     byte  ptr [esp+8]
HbsiOldIrql     equ     dword ptr [esp+12]

cPublicProc _HalBeginSystemInterrupt ,3
.FPO ( 0, 3, 0, 0, 0, 0 )
        xor     ecx, ecx
        mov     cl, HbsiVector                  ; (ecx) = System Vector
        sub     ecx, PRIMARY_VECTOR_BASE        ; (ecx) = 8259 IRQ #
if DBG
        cmp     ecx, 1fh
        jbe     hbsi00
        int     3
hbsi00:

endif
        jmp     HalpSpecialDismissTable[ecx*4]

HalpDismissIrq0f:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff
HalpIrq0fSpurious:
;
; This is a spurious interrupt.
; Because the slave PIC is cascaded to irq2 of master PIC, we need to
; dismiss the interupt on master PIC's irq2.
;

        mov     al, PIC2_EOI            ; Specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        mov     eax,0                   ; return FALSE
        stdRET    _HalBeginSystemInterrupt

HalpDismissIrq07:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     HalpDismissNormal       ; No, so this is NOT a spurious int
        mov     eax, 0                  ; return FALSE
        stdRET    _HalBeginSystemInterrupt

HalpDismissIrq0d:
;
; Clear the NPX busy latch.
;

        xor     al,al
        out     I386_80387_BUSY_PORT, al

align 4
HalpDismissNormal:
;
; Raise IRQL to requested level
;
        xor     ebx,ebx
        mov     al, HbsiIrql            ; (al) = New irql
                                        ; (ecx) = IRQ #
        mov     bl, PCR[PcIrql]         ; (ebx) = Current Irql

;
; Now we check to make sure the Irql of this interrupt > current Irql.
; If it is not, we dismiss it as spurious and set the appropriate bit
; in the IRR so we can dispatch the interrupt when Irql is lowered
;
        cmp     al, bl
        jbe     Hdsi300

        mov     PCR[PcIrql], al         ; set new Irql
        mov     edx, HbsiOldIrql        ; save current irql to OldIrql variable
        mov     byte ptr [edx], bl

;
; Dismiss interrupt.
;
        mov     eax, ecx                ; (eax) = IRQ #
        cmp     eax, 8                  ; EOI to master or slave?
        jae     short Hbsi100           ; EIO to both master and slave

        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt
        sti
        mov     eax, 1                  ; return TRUE
        stdRET    _HalBeginSystemInterrupt

align 4
Hbsi100:
        add     al, OCW2_SPECIFIC_EOI - 8   ; specific eoi to slave
        out     PIC2_PORT0, al

        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        sti
        mov     eax, 1                  ; return TRUE
        stdRET    _HalBeginSystemInterrupt

align 4
Hdsi300:
;
; An interrupt has come in at a lower Irql, so we dismiss it as spurious and
; set the appropriate bit in the IRR so that KeLowerIrql knows to dispatch
; it when Irql is lowered.
;
; (ecx) = 8259 IRQ#
; (al)  = New Irql
; (ebx) = Current Irql
;

        mov     eax, 1
        add     ecx, 4                  ; (ecx) = Irq # + 4
        shl     eax, cl
        or      PCR[PcIRR], eax

;
; Raise Irql to prevent it from happening again
;

;
; Get the PIC masks for Irql
;

        mov     eax, KiI8259MaskTable[ebx*4]
        or      eax, PCR[PcIDR]
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

Hbsi390:

ifdef IRQL_METRICS
        lock inc HalPostponedIntCount
endif

        xor     eax, eax                ; return FALSE, spurious interrupt
        stdRET    _HalBeginSystemInterrupt


HalpDismissIrq0fLevel:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissLevel  ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff
        jmp     HalpIrq0fSpurious

HalpDismissIrq07Level:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissLevel  ; No, so this is NOT a spurious int
        mov     eax, 0                  ; return FALSE
        stdRET    _HalBeginSystemInterrupt

HalpDismissIrq0dLevel:
;
; Clear the NPX busy latch.
;

        xor     al,al
        out     I386_80387_BUSY_PORT, al

align 4
HalpDismissLevel:
;
; Mask this level interrupt off
; (ecx) = 8259 IRQ#
;
        mov     al, HbsiIrql            ; (al) = New irql
        mov     eax, KiI8259MaskTable[eax*4]    ; get 8259's masks
        or      eax, PCR[PcIDR]         ; mask disabled irqs
        SET_8259_MASK                   ; send mask to 8259s
;
; The SWInterruptHandler for this vector has been set to a NOP.
; Set the vector's IRR so that Lower Irql will clear the 8259 mask for this
; Irq when the irql is lowered below this level.
;
        mov     eax, ecx                ; (eax) = Irq #
        mov     ebx, 1
        add     ecx, 4                  ; (ecx) = Irq # + 4
        shl     ebx, cl
        or      PCR[PcIRR], ebx

;
; Dismiss interrupt.  Current interrupt is already masked off.
; Then check to make sure the Irql of this interrupt > current Irql.
; If it is not, we dismiss it as spurious - since this is a level interrupt
; when the 8259's are unmasked the interrupt will reoccur
;
        mov     cl, HbsiIrql
        mov     bl, PCR[PcIrql]
        mov     edx, HbsiOldIrql

        cmp     eax, 8                  ; EOI to master or slave?
        jae     short Hbsi450           ; EIO to both master and slave

        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt

        cmp     cl, bl
        jbe     short Hbsi390           ; Spurious?

        mov     PCR[PcIrql], cl         ; raise to new irql
        mov     byte ptr [edx], bl      ; return old irql
        sti
        mov     eax, 1                  ; return TRUE
        stdRET    _HalBeginSystemInterrupt

align 4
Hbsi450:
        add     al, OCW2_SPECIFIC_EOI - 8   ; specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master

        cmp     cl, bl
        jbe     Hbsi390                 ; Spurious?

        mov     PCR[PcIrql], cl         ; raise to new irql
        mov     byte ptr [edx], bl      ; return old irql
        sti
        mov     eax, 1                  ; return TRUE
        stdRET    _HalBeginSystemInterrupt

stdENDP _HalBeginSystemInterrupt


;++
;VOID
;HalDisableSystemInterrupt(
;    IN CCHAR Vector,
;    IN KIRQL Irql
;    )
;
;
;
;Routine Description:
;
;    Disables a system interrupt.
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be disabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be disabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalDisableSystemInterrupt      ,2
.FPO ( 0, 2, 0, 0, 0, 0 )

;

        movzx   ecx, byte ptr [esp+4]           ; (ecx) = Vector
        sub     ecx, PRIMARY_VECTOR_BASE        ; (ecx) = 8259 irq #
        mov     edx, 1
        shl     edx, cl                         ; (ebx) = bit in IMR to disable
        cli
        or      PCR[PcIDR], edx
        xor     eax, eax

;
; Get the current interrupt mask register from the 8259
;
        in      al, PIC2_PORT1
        shl     eax, 8
        in      al, PIC1_PORT1
;
; Mask off the interrupt to be disabled
;
        or      eax, edx
;
; Write the new interrupt mask register back to the 8259
;
        out     PIC1_PORT1, al
        shr     eax, 8
        out     PIC2_PORT1, al
        PIC2DELAY

        sti
        stdRET    _HalDisableSystemInterrupt

stdENDP _HalDisableSystemInterrupt

;++
;
;BOOLEAN
;HalEnableSystemInterrupt(
;    IN ULONG Vector,
;    IN KIRQL Irql,
;    IN KINTERRUPT_MODE InterruptMode
;    )
;
;
;Routine Description:
;
;    Enables a system interrupt
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be enabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be enabled.
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalEnableSystemInterrupt       ,3
.FPO ( 0, 3, 0, 0, 0, 0 )

        movzx   ecx, byte ptr [esp+4]           ; (ecx) = vector
        sub     ecx, PRIMARY_VECTOR_BASE
        jc      hes_error
        cmp     ecx, CLOCK2_LEVEL
        jnc     hes_error


;
; Use the IRQ miniport to get the HW state.
;
        cmp     _HalpIrqMiniportInitialized, 0
        jz      hes_noMPGet


        push    ecx
        lea     eax, _HalpEisaELCR
        push    eax
        call    _PciirqmpGetTrigger@4
        pop     ecx

hes_noMPGet:

        bt      _HalpEisaIrqIgnore,ecx ;;Is this Eisa Ignore bit set?
        jc      short hes_ProgPic
;
; Clear or set the edge\level mask bit depending on what the caller wants.
;
        btr     _HalpEisaELCR, ecx
        mov     al, [esp+12]
        cmp     al, 0
        jnz     short hes_edge

        bt      _HalpEisaELCR, ecx
        jc      short @F

        ; Caller wants level triggered interrupts
        ; if IRQ routing is turned on, try and provide it
        cmp     _HalpIrqMiniportInitialized, 0
        jz      short @F
        bts     _HalpEisaELCR, ecx


@@:
        mov     SWInterruptHandlerTable+4*4[ecx*4], offset HalpHardwareInterruptLevel

        mov     edx, HalpSpecialDismissLevelTable[ecx*4]
        mov     HalpSpecialDismissTable[ecx*4], edx

hes_edge:
        cmp     _HalpIrqMiniportInitialized, 0
        jz      hes_ProgPIC
;
; Program the HW to make it match the callers request.
;
        mov     eax, _HalpEisaELCR

        push    ecx
        push    eax
        call    _PciirqmpSetTrigger@4
        pop     ecx

if 0
.err

;;
;; We can't just arbitrarily blast ports. This makes machines do really weird things
;;
hes_noMPSet:
        mov     edx, 4d0h
        out     dx, al
        inc     edx
        mov     al, ah
        out     dx, al
endif


hes_ProgPIC:

        mov     eax, 1
        shl     eax, cl                         ; (ebx) = bit in IMR to enable
        not     eax

        cli
        and     PCR[PcIDR], eax

;
; Get the PIC masks for Irql 0
;
        mov     eax, KiI8259MaskTable[0]
        or      eax, PCR[PcIDR]
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

        sti
        mov     eax, 1                          ; return TRUE
        stdRET    _HalEnableSystemInterrupt

hes_error:
if DBG
        int 3
endif
        xor     eax, eax                        ; FALSE
        stdRET    _HalEnableSystemInterrupt

stdENDP _HalEnableSystemInterrupt


_TEXT$01   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\ixusage.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixusage.c

Abstract:

Author:

    Ken Reneris (kenr)

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "kdcom.h"
#include "acpitabl.h"

#define KEY_VALUE_BUFFER_SIZE 1024

//
// Array to remember hal's IDT usage
//

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INITCONST") //Yes, this says INITCONST, but that is fine.
#endif

//
// IDT vector usage info
//
IDTUsage    HalpIDTUsage[MAXIMUM_IDTVECTOR+1] = {0};

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

//
// IDT vector usage info
//
IDTUsageFlags HalpIDTUsageFlags[MAXIMUM_IDTVECTOR+1] = {0};

extern WCHAR HalpSzSystem[];
extern WCHAR HalpSzSerialNumber[];
extern ADDRESS_USAGE HalpDetectedROM;

KAFFINITY       HalpActiveProcessors;

PUCHAR KdComPortInUse = NULL;

ADDRESS_USAGE HalpComIoSpace = {
    NULL, CmResourceTypePort, DeviceUsage,
    {
        0x2F8,  0x8,    // Default is 2F8 for COM2.  This will be changed.
        0, 0
    }
};

BOOLEAN HalpGetInfoFromACPI = FALSE;

USHORT HalpComPortIrqMapping[5][2] = {
    {COM1_PORT, 4},
    {COM2_PORT, 3},
    {COM3_PORT, 4},
    {COM4_PORT, 3},
    {0,0}
};

VOID
HalpGetResourceSortValue (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  pRCurLoc,
    OUT PULONG                          sortscale,
    OUT PLARGE_INTEGER                  sortvalue
    );

VOID
HalpReportSerialNumber (
    VOID
    );

#ifndef ACPI_HAL

VOID
HalpInheritROMBlocks (
    VOID
    );

VOID
HalpAddROMRanges (
    VOID
    );

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpEnableInterruptHandler)
#pragma alloc_text(INIT,HalpRegisterVector)
#pragma alloc_text(INIT,HalpGetResourceSortValue)
#pragma alloc_text(INIT,HalpReportResourceUsage)
#pragma alloc_text(INIT,HalpReportSerialNumber)

#ifndef ACPI_HAL
#pragma alloc_text(INIT,HalpInheritROMBlocks)
#pragma alloc_text(INIT,HalpAddROMRanges)
#endif

#endif


#if !defined(_WIN64)

NTSTATUS
HalpEnableInterruptHandler (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    )
/*++

Routine Description:

    This function connects & registers an IDT vectors usage by the HAL.

Arguments:

Return Value:

--*/
{
    
#ifndef ACPI_HAL
    //
    // Remember which vector the hal is connecting so it can be reported
    // later on
    //
    // If this is an ACPI HAL, the vectors will be claimed by the BIOS.
    // This is done for Win98 compatibility.
    //
    HalpRegisterVector (ReportFlags, BusInterruptVector, SystemInterruptVector, SystemIrql);
#endif

    //
    // Connect the IDT and enable the vector now
    //

    KiSetHandlerAddressToIDT(SystemInterruptVector, HalInterruptServiceRoutine);
    HalEnableSystemInterrupt(SystemInterruptVector, SystemIrql, InterruptMode);
    return STATUS_SUCCESS;
}
#endif



VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    )
/*++

Routine Description:

    This registers an IDT vectors usage by the HAL.

Arguments:

Return Value:

--*/
{
#if DBG
    // There are only 0ff IDT entries...
    ASSERT (SystemInterruptVector <= MAXIMUM_IDTVECTOR  &&
            BusInterruptVector <= MAXIMUM_IDTVECTOR);
#endif

    //
    // Remember which vector the hal is connecting so it can be reported
    // later on
    //

    HalpIDTUsageFlags[SystemInterruptVector].Flags = ReportFlags;
    HalpIDTUsage[SystemInterruptVector].Irql  = SystemIrql;
    HalpIDTUsage[SystemInterruptVector].BusReleativeVector = (UCHAR) BusInterruptVector;
}


VOID
HalpGetResourceSortValue (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  pRCurLoc,
    OUT PULONG                          sortscale,
    OUT PLARGE_INTEGER                  sortvalue
    )
/*++

Routine Description:

    Used by HalpReportResourceUsage in order to properly sort
    partial_resource_descriptors.

Arguments:

    pRCurLoc    - resource descriptor

Return Value:

    sortscale   - scaling of resource descriptor for sorting
    sortvalue   - value to sort on


--*/
{
    switch (pRCurLoc->Type) {
        case CmResourceTypeInterrupt:
            *sortscale = 0;
            *sortvalue = RtlConvertUlongToLargeInteger(
                        pRCurLoc->u.Interrupt.Level );
            break;

        case CmResourceTypePort:
            *sortscale = 1;
            *sortvalue = pRCurLoc->u.Port.Start;
            break;

        case CmResourceTypeMemory:
            *sortscale = 2;
            *sortvalue = pRCurLoc->u.Memory.Start;
            break;

        default:
            *sortscale = 4;
            *sortvalue = RtlConvertUlongToLargeInteger (0);
            break;
    }
}

#ifndef ACPI_HAL

VOID
HalpInheritROMBlocks (void)
{
    PBUS_HANDLER        Bus;
    PCM_FULL_RESOURCE_DESCRIPTOR ResourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResourceDescriptor;
    PKEY_VALUE_FULL_INFORMATION KeyValueBuffer;
    PCM_ROM_BLOCK BiosBlock;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING SectionName;
    UNICODE_STRING WorkString;

    HANDLE RegistryHandle;
    NTSTATUS Status;

    LARGE_INTEGER ViewBase;

    PVOID BaseAddress;
    PVOID destination;

    ULONG ViewSize;
    ULONG ResultLength;
    ULONG Index;
    ULONG LastMappedAddress;

    Bus = HaliHandlerForBus (PCIBus, 0);
    if (!Bus) {
        //
        //No root bus????
        //
        return;
    }

    //
    // Set up and open KeyPath
    //

    RtlInitUnicodeString(&SectionName,HalpSzSystem);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &SectionName,
        OBJ_CASE_INSENSITIVE,
        (HANDLE)NULL,
        NULL
        );

    Status = ZwOpenKey(
        &RegistryHandle,
        KEY_READ,
        &ObjectAttributes
        );

    if (!NT_SUCCESS(Status)) {
        return;
    }

    //
    // Allocate space for the data
    //

    KeyValueBuffer = ExAllocatePoolWithTag(
        PagedPool,
        KEY_VALUE_BUFFER_SIZE,
        ' MDV'
        );

    if (KeyValueBuffer == NULL) {
        ZwClose(RegistryHandle);
        return ;
    }

    //
    // Get the data for the rom information
    //

    RtlInitUnicodeString(
        &WorkString,
        L"Configuration Data"
        );

    Status = ZwQueryValueKey(
        RegistryHandle,
        &WorkString,
        KeyValueFullInformation,
        KeyValueBuffer,
        KEY_VALUE_BUFFER_SIZE,
        &ResultLength
        );

    if (!NT_SUCCESS(Status)) {
        ZwClose(RegistryHandle);
        ExFreePool(KeyValueBuffer);
        return ;
    }


    //
    //At this point, we have the data, so go ahead and
    //add in all of the range, except VGA, we can
    //assume we're not going to want to drop another card there
    //
    HalpAddRange( &Bus->BusAddresses->Memory,
                  0,
                  0,
                  0xC0000,
                  0xFFFFF
                  );



    ResourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)
        ((PUCHAR) KeyValueBuffer + KeyValueBuffer->DataOffset);

    if ((KeyValueBuffer->DataLength < sizeof(CM_FULL_RESOURCE_DESCRIPTOR)) ||
        (ResourceDescriptor->PartialResourceList.Count < 2)
    ) {
        ZwClose(RegistryHandle);
        ExFreePool(KeyValueBuffer);
        // No rom blocks.
        return;
    }

    PartialResourceDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
        ((PUCHAR)ResourceDescriptor +
        sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
        ResourceDescriptor->PartialResourceList.PartialDescriptors[0]
            .u.DeviceSpecificData.DataSize);


    if (KeyValueBuffer->DataLength < ((PUCHAR)PartialResourceDescriptor -
        (PUCHAR)ResourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
        + sizeof(CM_ROM_BLOCK))
    ) {
        ZwClose(RegistryHandle);
        ExFreePool(KeyValueBuffer);
        return;// STATUS_ILL_FORMED_SERVICE_ENTRY;
    }


    BiosBlock = (PCM_ROM_BLOCK)((PUCHAR)PartialResourceDescriptor +
        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

    Index = PartialResourceDescriptor->u.DeviceSpecificData.DataSize /
        sizeof(CM_ROM_BLOCK);

    //
    // N.B.  Rom blocks begin on 2K (not necessarily page) boundaries
    //       They end on 512 byte boundaries.  This means that we have
    //       to keep track of the last page mapped, and round the next
    //       Rom block up to the next page boundary if necessary.
    //

    LastMappedAddress = 0xC0000;

    while (Index) {
#if 0
        DbgPrint(
            "Bios Block, PhysAddr = %lx, size = %lx\n",
            BiosBlock->Address,
            BiosBlock->Size
            );
#endif
        if ((Index > 1) &&
            ((BiosBlock->Address + BiosBlock->Size) == BiosBlock[1].Address)
        ) {
            //
            // Coalesce adjacent blocks
            //
            BiosBlock[1].Address = BiosBlock[0].Address;
            BiosBlock[1].Size += BiosBlock[0].Size;
            Index--;
            BiosBlock++;
            continue;
        }

        BaseAddress = (PVOID)(BiosBlock->Address);
        ViewSize = BiosBlock->Size;

        if ((ULONG)BaseAddress < LastMappedAddress) {
            if (ViewSize > (LastMappedAddress - (ULONG)BaseAddress)) {
                ViewSize = ViewSize - (LastMappedAddress - (ULONG)BaseAddress);
                BaseAddress = (PVOID)LastMappedAddress;
            } else {
                ViewSize = 0;
            }
        }

        ViewBase.LowPart = (ULONG)BaseAddress;

        if (ViewSize > 0) {

            HalpRemoveRange ( &Bus->BusAddresses->Memory,
                 ViewBase.LowPart,
                 ViewSize);


            LastMappedAddress = (ULONG)BaseAddress + ViewSize;
        }

        Index--;
        BiosBlock++;
    }

    //
    // Free up the handles
    //

    ZwClose(RegistryHandle);
    ExFreePool(KeyValueBuffer);


}

VOID
HalpAddROMRanges (
    VOID
    )
{
    PCM_FULL_RESOURCE_DESCRIPTOR resourceDescriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialResourceDescriptor;
    PKEY_VALUE_FULL_INFORMATION keyValueBuffer;
    PCM_ROM_BLOCK biosBlock;
    ULONG resultLength;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING sectionName;
    UNICODE_STRING workString;
    HANDLE registryHandle;
    NTSTATUS status;
    LARGE_INTEGER viewBase;
    PVOID baseAddress;
    ULONG viewSize;
    ULONG index;
    ULONG element;
    ULONG lastMappedAddress;
    ADDRESS_USAGE *addrUsage;

    RtlInitUnicodeString(&sectionName, HalpSzSystem);
    InitializeObjectAttributes( &objectAttributes,
                                &sectionName,
                                OBJ_CASE_INSENSITIVE,
                                (HANDLE)NULL,
                                NULL);
    status = ZwOpenKey( &registryHandle,
                        KEY_READ,
                        &objectAttributes);
    if (NT_SUCCESS(status)) {
        
        //
        // Allocate space for the data
        //
    
        keyValueBuffer = ExAllocatePoolWithTag( PagedPool,
                                                KEY_VALUE_BUFFER_SIZE,
                                                ' MDV');
        if (keyValueBuffer) {

            //
            // Get the data for the rom information
            //
        
            RtlInitUnicodeString(   &workString,
                                    L"Configuration Data");        
            status = ZwQueryValueKey(   registryHandle,
                                        &workString,
                                        KeyValueFullInformation,
                                        keyValueBuffer,
                                        KEY_VALUE_BUFFER_SIZE,
                                        &resultLength);
            if (NT_SUCCESS(status)) {

                resourceDescriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)((PUCHAR)keyValueBuffer + keyValueBuffer->DataOffset);            
                if (    keyValueBuffer->DataLength >= sizeof(CM_FULL_RESOURCE_DESCRIPTOR) &&
                        resourceDescriptor->PartialResourceList.Count >= 2) {
                    
                    partialResourceDescriptor = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)((PUCHAR)resourceDescriptor +
                                                    sizeof(CM_FULL_RESOURCE_DESCRIPTOR) +
                                                    resourceDescriptor->PartialResourceList.PartialDescriptors[0].u.DeviceSpecificData.DataSize);                                
                    if (    keyValueBuffer->DataLength >= 
                                ((PUCHAR)partialResourceDescriptor - (PUCHAR)resourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) + sizeof(CM_ROM_BLOCK))) {

                    
                        addrUsage = &HalpDetectedROM;
                        
                        //
                        // N.B.  Rom blocks begin on 2K (not necessarily page) boundaries
                        //       They end on 512 byte boundaries.  This means that we have
                        //       to keep track of the last page mapped, and round the next
                        //       Rom block up to the next page boundary if necessary.
                        //

                        biosBlock = (PCM_ROM_BLOCK)((PUCHAR)partialResourceDescriptor + sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));                                                              
                        lastMappedAddress = 0xC0000;                    
                        for (   index = partialResourceDescriptor->u.DeviceSpecificData.DataSize / sizeof(CM_ROM_BLOCK), element = 0;
                                index;
                                index--, biosBlock++) {

                            //
                            // Coalesce adjacent blocks
                            //

                            if (    index > 1 && (biosBlock->Address + biosBlock->Size) == biosBlock[1].Address) {

                                biosBlock[1].Address = biosBlock[0].Address;
                                biosBlock[1].Size += biosBlock[0].Size;
                                continue;

                            }

                            baseAddress = (PVOID)(biosBlock->Address);
                            viewSize = biosBlock->Size;                    
                            if ((ULONG)baseAddress < lastMappedAddress) {

                                if (viewSize > (lastMappedAddress - (ULONG)baseAddress)) {

                                    viewSize = viewSize - (lastMappedAddress - (ULONG)baseAddress);
                                    baseAddress = (PVOID)lastMappedAddress;

                                } else {

                                    viewSize = 0;

                                }
                            }

                            viewBase.LowPart = (ULONG)baseAddress;
                            if (viewSize > 0) {

                                addrUsage->Element[element].Start = viewBase.LowPart;
                                addrUsage->Element[element].Length = viewSize;
                                element++;
                                lastMappedAddress = (ULONG)baseAddress + viewSize;

                            }
                        }
                        
                        //
                        // Register address usage if we found at least one ROM block.
                        //
                            
                        if (element) {

                            addrUsage->Element[element].Start = 0;
                            addrUsage->Element[element].Length = 0;
                            HalpRegisterAddressUsage(addrUsage);

                        }                         
                    }
                }                
            }

            ExFreePool(keyValueBuffer);
        }

        ZwClose(registryHandle);        
    }
}

#endif

VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PCM_RESOURCE_LIST               RawResourceList, TranslatedResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    pRFullDesc,      pTFullDesc;
    PCM_PARTIAL_RESOURCE_LIST       pRPartList,      pTPartList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pRCurLoc,        pTCurLoc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pRSortLoc,       pTSortLoc;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  RPartialDesc,    TPartialDesc;
    ULONG   i, j, k, ListSize, Count;
    ULONG   curscale, sortscale;
    UCHAR   pass, reporton;
    INTERFACE_TYPE  interfacetype;
    ULONG           CurrentIDT, CurrentElement;
    ADDRESS_USAGE   *CurrentAddress;
    LARGE_INTEGER   curvalue, sortvalue;

#ifdef ACPI_HAL
    extern PDEBUG_PORT_TABLE HalpDebugPortTable;
#endif

    //
    // Claim the debugger com port resource if it is in use
    //
    if (KdComPortInUse != NULL) {
        HalpComIoSpace.Element[0].Start = (ULONG)(ULONG_PTR)KdComPortInUse;
        HalpRegisterAddressUsage(&HalpComIoSpace);

#ifdef ACPI_HAL
        if (HalpDebugPortTable) {
            if (HalpDebugPortTable->BaseAddress.AddressSpaceID == 1) {
                HalpGetInfoFromACPI = TRUE;
            }
        }
#endif

        //
        // The debugger does not use any interrupts. However for consistent
        // behaviour between a machine with and without a debugger, we claim
        // an interrupt for the debugger if the debugger port address is one
        // for COM1-4.
        //
        
        if (!HalpGetInfoFromACPI) {
            for (i = 0; HalpComPortIrqMapping[i][0]; i++) {
                
                if ((PUCHAR)HalpComPortIrqMapping[i][0] == KdComPortInUse) {
                    
                    HalpRegisterVector( DeviceUsage | InterruptLatched,
                                        HalpComPortIrqMapping[i][1],
                                        HalpComPortIrqMapping[i][1] +
                                        PRIMARY_VECTOR_BASE,
                                        HIGH_LEVEL);
                    break;
                }
            }
        }
    }
    
#ifndef ACPI_HAL  // ACPI HALs don't deal with address maps

    HalpInheritROMBlocks();

    HalpAddROMRanges();

#endif

    //
    // Allocate some space to build the resource structure
    //

    RawResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(
                                             NonPagedPool,
                                             PAGE_SIZE*2,
                                             HAL_POOL_TAG);
    TranslatedResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(
                                                    NonPagedPool,
                                                    PAGE_SIZE*2,
                                                    HAL_POOL_TAG);
    if (!RawResourceList || !TranslatedResourceList) {

        //
        // These allocations were critical.
        //

        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     PAGE_SIZE*4,
                     1,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    // This functions assumes unset fields are zero
    RtlZeroMemory(RawResourceList, PAGE_SIZE*2);
    RtlZeroMemory(TranslatedResourceList, PAGE_SIZE*2);

    //
    // Initialize the lists
    //

    RawResourceList->List[0].InterfaceType = (INTERFACE_TYPE) -1;

    pRFullDesc = RawResourceList->List;
    pRCurLoc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) RawResourceList->List;
    pTCurLoc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) TranslatedResourceList->List;

    //
    // Make sure all vectors 00-2f are reserved
    // 00-1E reserved by Intel
    // 1F    reserved by Intel for APIC (apc priority level)
    // 20-2e reserved by Microsoft
    // 2f    reserved by Microsoft for APIC (dpc priority level)
    //

    for(i=0; i < PRIMARY_VECTOR_BASE; i++) {
        if (!(HalpIDTUsageFlags[i].Flags & IDTOwned)) {
             HalpIDTUsageFlags[i].Flags = InternalUsage;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }

    for(pass=0; pass < 2; pass++) {
        if (pass == 0) {
            //
            // First pass - build resource lists for resources reported
            // reported against device usage.
            //

            reporton = DeviceUsage & ~IDTOwned;
            interfacetype = DeviceInterfaceToUse;
        } else {

            //
            // Second pass = build reousce lists for resources reported
            // as internal usage.
            //

            reporton = InternalUsage & ~IDTOwned;
            interfacetype = Internal;
        }

        CurrentIDT = 0;
        CurrentElement = 0;
        CurrentAddress = HalpAddressUsageList;

        for (; ;) {
            if (CurrentIDT <= MAXIMUM_IDTVECTOR) {
                //
                // Check to see if CurrentIDT needs to be reported
                //

                if (!(HalpIDTUsageFlags[CurrentIDT].Flags & reporton)) {
                    // Don't report on this one
                    CurrentIDT++;
                    continue;
                }

                //
                // Report CurrentIDT resource
                //

                RPartialDesc.Type = CmResourceTypeInterrupt;
                RPartialDesc.ShareDisposition = CmResourceShareDriverExclusive;
                RPartialDesc.Flags =
                    HalpIDTUsageFlags[CurrentIDT].Flags & InterruptLatched ?
                    CM_RESOURCE_INTERRUPT_LATCHED :
                    CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                RPartialDesc.u.Interrupt.Vector = HalpIDTUsage[CurrentIDT].BusReleativeVector;
                RPartialDesc.u.Interrupt.Level = HalpIDTUsage[CurrentIDT].BusReleativeVector;
                RPartialDesc.u.Interrupt.Affinity = HalpActiveProcessors;

                RtlCopyMemory (&TPartialDesc, &RPartialDesc, sizeof TPartialDesc);
                TPartialDesc.u.Interrupt.Vector = CurrentIDT;
                TPartialDesc.u.Interrupt.Level = HalpIDTUsage[CurrentIDT].Irql;

                CurrentIDT++;

            } else {
                //
                // Check to see if CurrentAddress needs to be reported
                //

                if (!CurrentAddress) {
                    break;                  // No addresses left
                }

                if (!(CurrentAddress->Flags & reporton)) {
                    // Don't report on this list
                    CurrentElement = 0;
                    CurrentAddress = CurrentAddress->Next;
                    continue;
                }

                if (!CurrentAddress->Element[CurrentElement].Length) {
                    // End of current list, go to next list
                    CurrentElement = 0;
                    CurrentAddress = CurrentAddress->Next;
                    continue;
                }

                //
                // Report CurrentAddress
                //

                RPartialDesc.Type = (UCHAR) CurrentAddress->Type;
                RPartialDesc.ShareDisposition = CmResourceShareDriverExclusive;

                if (RPartialDesc.Type == CmResourceTypePort) {
                    i = 1;              // address space port
                    RPartialDesc.Flags = CM_RESOURCE_PORT_IO;

                    if (HalpBusType == MACHINE_TYPE_EISA) {
                        RPartialDesc.Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
                    }
#ifdef ACPI_HAL
                    RPartialDesc.Flags |= CM_RESOURCE_PORT_16_BIT_DECODE;
#endif
                } else {
                    i = 0;              // address space memory
                    if (CurrentAddress->Flags & RomResource) {
                        RPartialDesc.Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                    } else {
                        RPartialDesc.Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                    }
                }

                // Notice: assuming u.Memory and u.Port have the same layout
                RPartialDesc.u.Memory.Start.HighPart = 0;
                RPartialDesc.u.Memory.Start.LowPart =
                    CurrentAddress->Element[CurrentElement].Start;

                RPartialDesc.u.Memory.Length =
                    CurrentAddress->Element[CurrentElement].Length;

                // translated address = Raw address
                RtlCopyMemory (&TPartialDesc, &RPartialDesc, sizeof TPartialDesc);
                HalTranslateBusAddress (
                    interfacetype,                  // device bus or internal
                    0,                              // bus number
                    RPartialDesc.u.Memory.Start,    // source address
                    &i,                             // address space
                    &TPartialDesc.u.Memory.Start ); // translated address

                if (RPartialDesc.Type == CmResourceTypePort  &&  i == 0) {
                    TPartialDesc.Flags = CM_RESOURCE_PORT_MEMORY;
                }

                CurrentElement++;
            }

            //
            // Include the current resource in the HALs list
            //

            if (pRFullDesc->InterfaceType != interfacetype) {
                //
                // Interface type changed, add another full section
                //

                RawResourceList->Count++;
                TranslatedResourceList->Count++;

                pRFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pRCurLoc;
                pTFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pTCurLoc;

                pRFullDesc->InterfaceType = interfacetype;
                pTFullDesc->InterfaceType = interfacetype;

                pRPartList = &pRFullDesc->PartialResourceList;
                pTPartList = &pTFullDesc->PartialResourceList;

                //
                // Bump current location pointers up
                //
                pRCurLoc = pRFullDesc->PartialResourceList.PartialDescriptors;
                pTCurLoc = pTFullDesc->PartialResourceList.PartialDescriptors;
            }


            pRPartList->Count++;
            pTPartList->Count++;
            RtlCopyMemory (pRCurLoc, &RPartialDesc, sizeof RPartialDesc);
            RtlCopyMemory (pTCurLoc, &TPartialDesc, sizeof TPartialDesc);

            pRCurLoc++;
            pTCurLoc++;
        }
    }

    ListSize = (ULONG) ( ((PUCHAR) pRCurLoc) - ((PUCHAR) RawResourceList) );

    //
    // The HAL's resource usage structures have been built
    // Sort the partial lists based on the Raw resource values
    //

    pRFullDesc = RawResourceList->List;
    pTFullDesc = TranslatedResourceList->List;

    for (i=0; i < RawResourceList->Count; i++) {

        pRCurLoc = pRFullDesc->PartialResourceList.PartialDescriptors;
        pTCurLoc = pTFullDesc->PartialResourceList.PartialDescriptors;
        Count = pRFullDesc->PartialResourceList.Count;

        for (j=0; j < Count; j++) {
            HalpGetResourceSortValue (pRCurLoc, &curscale, &curvalue);

            pRSortLoc = pRCurLoc;
            pTSortLoc = pTCurLoc;

            for (k=j; k < Count; k++) {
                HalpGetResourceSortValue (pRSortLoc, &sortscale, &sortvalue);

                if (sortscale < curscale ||
                    (sortscale == curscale &&
                     RtlLargeIntegerLessThan (sortvalue, curvalue)) ) {

                    //
                    // Swap the elements..
                    //

                    RtlCopyMemory (&RPartialDesc, pRCurLoc, sizeof RPartialDesc);
                    RtlCopyMemory (pRCurLoc, pRSortLoc, sizeof RPartialDesc);
                    RtlCopyMemory (pRSortLoc, &RPartialDesc, sizeof RPartialDesc);

                    // swap translated descriptor as well
                    RtlCopyMemory (&TPartialDesc, pTCurLoc, sizeof TPartialDesc);
                    RtlCopyMemory (pTCurLoc, pTSortLoc, sizeof TPartialDesc);
                    RtlCopyMemory (pTSortLoc, &TPartialDesc, sizeof TPartialDesc);

                    // get new curscale & curvalue
                    HalpGetResourceSortValue (pRCurLoc, &curscale, &curvalue);
                }

                pRSortLoc++;
                pTSortLoc++;
            }

            pRCurLoc++;
            pTCurLoc++;
        }

        pRFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pRCurLoc;
        pTFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pTCurLoc;
    }


    //
    // Inform the IO system of our resources..
    //

    IoReportHalResourceUsage (
        HalName,
        RawResourceList,
        TranslatedResourceList,
        ListSize
    );

    ExFreePool (RawResourceList);
    ExFreePool (TranslatedResourceList);

    //
    // Add system's serial number
    //

    HalpReportSerialNumber ();
}

VOID
HalpReportSerialNumber (
    VOID
    )
{
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString;
    HANDLE              hSystem;
    NTSTATUS            status;

    if (!HalpSerialLen) {
        return ;
    }

    //
    // Open HKEY_LOCAL_MACHINE\Hardware\Description\System
    //

    RtlInitUnicodeString (&unicodeString, HalpSzSystem);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );


    status = ZwOpenKey (&hSystem, KEY_READ | KEY_WRITE, &objectAttributes);
    if (NT_SUCCESS(status)) {

        //
        // Add "Serial Number" as REG_BINARY
        //

        RtlInitUnicodeString (&unicodeString, HalpSzSerialNumber);

        ZwSetValueKey (
                hSystem,
                &unicodeString,
                0L,
                REG_BINARY,
                HalpSerialNumber,
                HalpSerialLen
                );

        ZwClose (hSystem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxdisp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxdisp.c

Abstract:

    This module implements the HAL display initialization and output routines
    for a x86 system.

Author:

    David N. Cutler (davec) 27-Apr-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include <inbv.h>

VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    )
{
    return;
}

VOID
HalDisplayString (
    PUCHAR String
    )

{
    InbvDisplayString(String);  // lets forward for now...
}

VOID
HalQueryDisplayParameters (
    OUT PULONG WidthInCharacters,
    OUT PULONG HeightInLines,
    OUT PULONG CursorColumn,
    OUT PULONG CursorRow
    )

{
    return;
}

VOID
HalSetDisplayParameters (
    IN ULONG CursorColumn,
    IN ULONG CursorRow
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxhal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxhal.c

Abstract:


    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for an
    x86 system.

Author:

    David N. Cutler (davec) 25-Apr-1991

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

ULONG HalpBusType;

extern ADDRESS_USAGE HalpDefaultPcIoSpace;
extern ADDRESS_USAGE HalpEisaIoSpace;
extern UCHAR         HalpSzPciLock[];
extern UCHAR         HalpSzBreak[];
extern BOOLEAN       HalpPciLockSettings;
extern UCHAR         HalpGenuineIntel[];

extern PULONG KiEnableTimerWatchdog;
extern ULONG HalpTimerWatchdogEnabled;
extern PCHAR HalpTimerWatchdogStorage;
extern PVOID HalpTimerWatchdogCurFrame;
extern PVOID HalpTimerWatchdogLastFrame;
extern ULONG HalpTimerWatchdogStorageOverflow;

extern KSPIN_LOCK HalpDmaAdapterListLock;
extern LIST_ENTRY HalpDmaAdapterList;

#ifdef ACPI_HAL
extern KEVENT   HalpNewAdapter;
#endif


VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

ULONG
HalpGetFeatureBits (
    VOID
    );

VOID
HalpInitReservedPages(
    VOID
    );

VOID
HalpAcpiTimerPerfCountHack(
    VOID
    );

#ifndef NT_UP
ULONG
HalpInitMP(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );
#endif


KSPIN_LOCK HalpSystemHardwareLock;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpGetParameters)
#pragma alloc_text(INIT,HalInitSystem)
#pragma alloc_text(INIT,HalpGetFeatureBits)
#endif


VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This gets any parameters from the boot.ini invocation line.

Arguments:

    None.

Return Value:

    None

--*/
{
    PCHAR       Options;

    if (LoaderBlock != NULL  &&  LoaderBlock->LoadOptions != NULL) {
        Options = LoaderBlock->LoadOptions;

        //
        // Check if PCI settings are locked down
        //

        if (strstr(Options, HalpSzPciLock)) {
            HalpPciLockSettings = TRUE;
        }

        //
        //  Has the user asked for an initial BreakPoint?
        //

        if (strstr(Options, HalpSzBreak)) {
            DbgBreakPoint();
        }
    }

    return;
}


VOID
HalpInitTimerWatchdog(
    IN ULONG Phase
    )
/*++

Routine Description:

    Determines if the system is running on a GenuineIntel part and initializes
    HalpTimerWatchdogEnabled accordingly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (Phase == 0) {
        ULONG   GenuinePentiumOrLater = FALSE, Junk;
        PKPRCB  Prcb;

        Prcb = KeGetCurrentPrcb();

        if (Prcb->CpuID) {
            UCHAR Buffer[50];

            //
            // Determine the processor type
            //

            HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
            Buffer[12] = 0;

            GenuinePentiumOrLater =
                ((strcmp(Buffer, HalpGenuineIntel) == 0) && (Prcb->CpuType >= 5));

            HalpTimerWatchdogEnabled = GenuinePentiumOrLater;
        }
    } else if (HalpTimerWatchdogEnabled) {
        //
        // Allocate 2 pages for stack snapshots, each snapshot is 64 DWORDs.
        //
        if (HalpTimerWatchdogStorage =
                ExAllocatePoolWithTag( NonPagedPool, PAGE_SIZE * 2, HAL_POOL_TAG )) {
            HalpTimerWatchdogLastFrame =
                HalpTimerWatchdogStorage + (PAGE_SIZE * 2 - 64*4);
            HalpTimerWatchdogStorageOverflow = 0;
            HalpTimerWatchdogCurFrame = HalpTimerWatchdogStorage;
        } else {
            HalpTimerWatchdogEnabled = FALSE;
        }
    }
}


BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )


/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    A value of TRUE is returned is the initialization was successfully
    complete. Otherwise a value of FALSE is returend.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PLIST_ENTRY NextMd;
    KIRQL CurrentIrql;
    PKPRCB   pPRCB;
    ULONG mapBufferSize;
    ULONG mapBufferAddress;

    pPRCB = KeGetCurrentPrcb();

    if (Phase == 0) {

        HalpBusType = LoaderBlock->u.I386.MachineType & 0x00ff;
        HalpGetParameters (LoaderBlock);

        //
        // Verify Prcb version and build flags conform to
        // this image
        //

#if DBG
        if (!(pPRCB->BuildType & PRCB_BUILD_DEBUG)) {
            // This checked hal requires a checked kernel
            KeBugCheckEx (MISMATCHED_HAL,
                2, pPRCB->BuildType, PRCB_BUILD_DEBUG, 0);
        }
#else
        if (pPRCB->BuildType & PRCB_BUILD_DEBUG) {
            // This free hal requires a free kernel
            KeBugCheckEx (MISMATCHED_HAL, 2, pPRCB->BuildType, 0, 0);
        }
#endif
#ifndef NT_UP
        if (pPRCB->BuildType & PRCB_BUILD_UNIPROCESSOR) {
            // This MP hal requires an MP kernel
            KeBugCheckEx (MISMATCHED_HAL, 2, pPRCB->BuildType, 0, 0);
        }
#endif
        if (pPRCB->MajorVersion != PRCB_MAJOR_VERSION) {
            KeBugCheckEx (MISMATCHED_HAL,
                1, pPRCB->MajorVersion, PRCB_MAJOR_VERSION, 0);
        }

        //
        // Phase 0 initialization
        // only called by P0
        //

        //
        // Check to make sure the MCA HAL is not running on an ISA/EISA
        // system, and vice-versa.
        //
#if MCA
        if (HalpBusType != MACHINE_TYPE_MCA) {
            KeBugCheckEx (MISMATCHED_HAL,
                3, HalpBusType, MACHINE_TYPE_MCA, 0);
        }
#else
        if (HalpBusType == MACHINE_TYPE_MCA) {
            KeBugCheckEx (MISMATCHED_HAL,
                3, HalpBusType, 0, 0);
        }
#endif

#ifdef ACPI_HAL
        //
        // Make sure that this is really an ACPI machine and initialize
        // the ACPI structures.
        //
        HalpSetupAcpiPhase0(LoaderBlock);
#endif

        HalpInitializePICs(TRUE);

        //
        // Now that the PICs are initialized, we need to mask them to
        // reflect the current Irql
        //

        CurrentIrql = KeGetCurrentIrql();
        CurrentIrql = KfRaiseIrql(CurrentIrql);

        //
        // Initialize CMOS
        //

        HalpInitializeCmos();

        //
        // Fill in handlers for APIs which this hal supports
        //

        HalQuerySystemInformation = HaliQuerySystemInformation;
        HalSetSystemInformation = HaliSetSystemInformation;
        HalInitPnpDriver = HaliInitPnpDriver;
        HalGetDmaAdapter = HaliGetDmaAdapter;
        HalHaltSystem = HaliHaltSystem;
        HalResetDisplay = HalpBiosDisplayReset;

#if !defined( HAL_SP )
#ifdef ACPI_HAL
        HalGetInterruptTranslator = HalacpiGetInterruptTranslator;
#else
        HalGetInterruptTranslator = HaliGetInterruptTranslator;
#endif
#endif

#if !defined( HAL_SP ) && !(MCA)
        HalInitPowerManagement = HaliInitPowerManagement;
        HalLocateHiberRanges = HaliLocateHiberRanges;
#endif


        //
        // Register cascade vector
        //

        HalpRegisterVector (
            InternalUsage,
            PIC_SLAVE_IRQ + PRIMARY_VECTOR_BASE,
            PIC_SLAVE_IRQ + PRIMARY_VECTOR_BASE,
            HIGH_LEVEL );

        //
        // Keep track of which IRQs are level triggered.
        //
        if (HalpBusType == MACHINE_TYPE_EISA) {
            HalpRecordEisaInterruptVectors();
        }

        //
        // Register base IO space used by hal
        //

        HalpRegisterAddressUsage (&HalpDefaultPcIoSpace);
        
        if (HalpBusType == MACHINE_TYPE_EISA) {
            HalpRegisterAddressUsage (&HalpEisaIoSpace);
        }

        //
        // Note that HalpInitializeClock MUST be called after
        // HalpInitializeStallExecution, because HalpInitializeStallExecution
        // reprograms the timer.
        //

        HalpInitializeStallExecution(0);

        //
        // Init timer watchdog if enabled.
        //

        HalpInitTimerWatchdog(Phase);

        //
        // Setup the clock
        //

        HalpInitializeClock();

        //
        // Make sure profile is disabled
        //

        HalStopProfileInterrupt(0);

        //
        // Remove this for the sake of the graphical boot driver.  There is
        // no negative effect of this.  If the display isn't initialized, it
        // will be initialized during HalDisplayString.
        //
        // HalpInitializeDisplay();

        //
        // Initialize spinlock used by HalGetBusData hardware access routines
        //

        KeInitializeSpinLock(&HalpSystemHardwareLock);

        //
        // Initialize data structures used to chain dma adapters
        // together for debugging purposes
        //
        KeInitializeSpinLock(&HalpDmaAdapterListLock);
        InitializeListHead(&HalpDmaAdapterList);

#ifdef ACPI_HAL
        //
        // Initialize synchronzation event used to serialize
        // new adapter events on the ACPI HAL (which has no notion of bus
        // handlers)
        //

        KeInitializeEvent (&HalpNewAdapter, SynchronizationEvent, TRUE);
#endif
        //
        // Determine if there is physical memory above 16 MB.
        //

        LessThan16Mb = TRUE;

        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
            Descriptor = CONTAINING_RECORD( NextMd,
                                            MEMORY_ALLOCATION_DESCRIPTOR,
                                            ListEntry );

            if (Descriptor->MemoryType != LoaderFirmwarePermanent &&
                Descriptor->MemoryType != LoaderSpecialMemory  &&
                Descriptor->BasePage + Descriptor->PageCount > 0x1000) {
                LessThan16Mb = FALSE;
                break;
            }

            NextMd = Descriptor->ListEntry.Flink;
        }

#if !defined(_HALPAE_)

        HalpMapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;

        //
        // Allocate map buffers for the adapter objects
        //

        HalpMapBufferPhysicalAddress.LowPart =
            HalpAllocPhysicalMemory (LoaderBlock, MAXIMUM_PHYSICAL_ADDRESS,
                HalpMapBufferSize >> PAGE_SHIFT, TRUE);
        HalpMapBufferPhysicalAddress.HighPart = 0;


        if (!HalpMapBufferPhysicalAddress.LowPart) {

            //
            // There was not a satisfactory block.  Clear the allocation.
            //

            HalpMapBufferSize = 0;
        }

#else

        //
        // Initialize and allocate map buffers for the 24bit master adapter
        // object.
        //

        MasterAdapter24.MaxBufferPages =
            MAXIMUM_ISA_MAP_BUFFER_SIZE / PAGE_SIZE;

        mapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;
        mapBufferAddress =
            HalpAllocPhysicalMemory (LoaderBlock,
                                     MAXIMUM_PHYSICAL_ADDRESS,
                                     mapBufferSize >> PAGE_SHIFT,
                                     TRUE);

        if (mapBufferAddress == 0) {
            mapBufferSize = 0;
        }

        MasterAdapter24.MapBufferPhysicalAddress.LowPart = mapBufferAddress;
        MasterAdapter24.MapBufferPhysicalAddress.HighPart = 0;
        MasterAdapter24.MapBufferSize = mapBufferSize;

        if (HalPaeEnabled() != FALSE) {

            //
            // Initialize and allocate map buffers for the 32bit master adapter
            // object.  This should only be needed on a PAE-enabled system.
            //

            MasterAdapter32.MaxBufferPages =
                MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE;

            mapBufferSize = INITIAL_MAP_BUFFER_LARGE_SIZE;
            mapBufferAddress =
                HalpAllocPhysicalMemory (LoaderBlock,
                                         (ULONG)-1,
                                         mapBufferSize >> PAGE_SHIFT,
                                         TRUE);

            if (mapBufferAddress == 0) {
                mapBufferSize = 0;
            }

            MasterAdapter32.MapBufferPhysicalAddress.LowPart = mapBufferAddress;
            MasterAdapter32.MapBufferPhysicalAddress.HighPart = 0;
            MasterAdapter32.MapBufferSize = mapBufferSize;
        }

#endif

    } else {

        //
        // Phase 1 initialization
        //

        if (pPRCB->Number == 0) {

            //
            // Back-pocket some PTEs for DMA during low mem
            //
            HalpInitReservedPages();

#ifndef ACPI_HAL
            //
            //  If P0, then setup global vectors
            //

            HalpRegisterInternalBusHandlers ();
#else
            HalpInitNonBusHandler();
#endif

            //
            // Set feature bits
            //

            HalpFeatureBits = HalpGetFeatureBits();

            //
            // Use movnti routine to copy memory if Movnti support is detected
            //

#if !defined(_WIN64)
            if (HalpFeatureBits & HAL_WNI_PRESENT) {
                HalpMoveMemory = HalpMovntiCopyBuffer;
            }
#endif

            //
            // Init timer watchdog if enabled (allocate stack snapshot buffer).
            //

            HalpInitTimerWatchdog(Phase);


            HalpEnableInterruptHandler (
                DeviceUsage | InterruptLatched, // Report as device vector
                V2I (CLOCK_VECTOR),             // Bus interrupt level
                CLOCK_VECTOR,                   // System IDT
                CLOCK2_LEVEL,                   // System Irql
                HalpClockInterrupt,             // ISR
                Latched );

            HalpEnableInterruptHandler (
                DeviceUsage | InterruptLatched, // Report as device vector
                V2I (PROFILE_VECTOR),           // Bus interrupt level
                PROFILE_VECTOR,                 // System IDT
                PROFILE_LEVEL,                  // System Irql
                HalpProfileInterrupt,           // ISR
                Latched );


#ifdef ACPI_HAL
            //
            // Perf counter patch for non-compliant ACPI machines
            //
            HalpAcpiTimerPerfCountHack();
#endif

#if !defined(_WIN64)

            //
            // If 486, the FP error will be routed via trap10.  So we
            // don't enable irq13.  Otherwise (CPU=386), we will enable irq13
            // to handle FP error.
            //

            if (pPRCB->CpuType == 3) {
                HalpEnableInterruptHandler (
                    DeviceUsage,                // Report as device vector
                    V2I (I386_80387_VECTOR),    // Bus interrupt level
                    I386_80387_VECTOR,          // System IDT
                    I386_80387_IRQL,            // System Irql
                    HalpIrq13Handler,           // ISR
                    Latched );
            }
#endif
        }
    }

#ifndef NT_UP
    HalpInitMP (Phase, LoaderBlock);
#endif

    return TRUE;
}

ULONG
HalpGetFeatureBits (
    VOID
    )
{
    UCHAR   Buffer[50];
    ULONG   Junk, ProcessorFeatures, Bits;
    PKPRCB  Prcb;
    ULONGLONG ApicBits;

    Bits = 0;

    Prcb = KeGetCurrentPrcb();

    if (!Prcb->CpuID) {
        Bits |= HAL_NO_SPECULATION;
        return Bits;
    }

    //
    // Determine the processor type
    //

    HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
    Buffer[12] = 0;

    HalpCpuID (1, &Junk, &Junk, &Junk, &ProcessorFeatures);

    //
    // Determine which features are present.
    //

    if (strcmp (Buffer, HalpGenuineIntel) == 0) {

        //
        // Check Intel feature bits for HAL features needed
        //

        if (Prcb->CpuType == 6) {

            Bits |= HAL_PERF_EVENTS;

            //
            // Workaround for Pentium Pro Local APIC trap 0x0F and trap 0x00
            // spurious interrupt errata 5AP and 6AP. Disable the Local APIC
            // on UP Pentium Pro Systems. Interrupts are routed directly from
            // 8259 PIC to CPU.
            //

            ApicBits = RDMSR(APIC_BASE_MSR);

            if (ApicBits & APIC_ENABLED) {

                //
                // Local APIC is enabled - Disable it.
                //

                WRMSR(APIC_BASE_MSR, (ApicBits & ~APIC_ENABLED));
            }
        }

        if (Prcb->CpuType < 6) {
            Bits |= HAL_NO_SPECULATION;
        }
    }

    if (ProcessorFeatures & CPUID_MCA_MASK) {
        Bits |= HAL_MCA_PRESENT;
    }

    if (ProcessorFeatures & CPUID_MCE_MASK) {
        Bits |= HAL_MCE_PRESENT;
    }

    if (ProcessorFeatures & CPUID_VME_MASK) {
        Bits |= HAL_CR4_PRESENT;
    }

    if (ProcessorFeatures & CPUID_WNI_MASK) {
        Bits |= HAL_WNI_PRESENT;
    }
    return Bits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxstubs.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This implements the HAL routines which don't do anything on x86.

Author:

    John Vert (jvert) 11-Jul-1991

Revision History:

--*/
#include "nthal.h"
#include "arc.h"
#include "arccodes.h"

VOID
HalSaveState(
    VOID
    )

/*++

Routine Description:

    Saves the system state into the restart block.  Currently does nothing.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    DbgPrint("HalSaveState called - System stopped\n");

    KeBugCheck(0);
}


BOOLEAN
HalDataBusError(
    VOID
    )

/*++

Routine Description:

    Called when a data bus error occurs.  There is no way to fix this on
    x86.

Arguments:

    None

Return Value:

    FALSE

--*/

{
    return(FALSE);

}

BOOLEAN
HalInstructionBusError(
    VOID
    )

/*++

Routine Description:

    Called when an instruction bus error occurs.  There is no way to fix this
    on x86.

Arguments:

    None

Return Value:

    FALSE

--*/

{
    return(FALSE);

}

VOID
KeFlushWriteBuffer(
    VOID
    )

/*++

Routine Description:

    Flushes all write buffers and/or other data storing or reordering
    hardware on the current processor.  This ensures that all previous
    writes will occur before any new reads or writes are completed.

Arguments:

    None

Return Value:

    None.

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxbiosc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxbiosc.c

Abstract:

    This module implements the protect-mode routines necessary to make the
    transition to real mode and return to protected mode.

Author:

    John Vert (jvert) 29-Oct-1991


Environment:

    Kernel mode only.
    Probably a panic-stop, so we cannot use any system services.

Revision History:

--*/
#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpGetDisplayBiosInformation)
#endif // ALLOC_PRAGMA

//
// The IOPM should be mostly 0xff.  However it is possible a few
// bits may be cleared.  Build a table of what's not 0xff.
//

#define MAX_DIFFERENCES 10

typedef struct _IOPM_DIFF_ENTRY
{
    USHORT Entry;
    USHORT Value;
} IOPM_DIFF_ENTRY, *PIOPM_DIFF_ENTRY;

//
// Function definitions
//


ULONG
HalpBorrowTss(
    VOID
    );

VOID
HalpReturnTss(
    ULONG TssSelector
    );

VOID
HalpBiosCall(
    VOID
    );


VOID
HalpTrap06(
    VOID
    );


VOID
HalpTrap0D(
    VOID
    );


ULONG
HalpStoreAndClearIopm(
    PVOID Iopm,
    PIOPM_DIFF_ENTRY IopmDiffTable,
    ULONG MaxIopmTableEntries
    )

/*++

Routine Description:

    The primary function of this routine is to clear all the bits in the
    IOPM.  However, we will need to recover any of our changes later.

    It is very likely that the IOPM will be all 0xff's.  If there are
    deviations from this, they should be minimal.  So lets only store what's
    different.

Arguments:

    Iopm - Pointer to the IOPM to clear.

    IopmDiffTable - Pointer to the table of IOPM deviations from 0xff.

    MaxIopmTableEntries - The maximum number of entries in our table.

Returns:

    Number of entries added to the table.

--*/

{
    PUSHORT IoMap = Iopm;
    ULONG   IopmDiffTableEntries = 0;
    ULONG   i;

    for (i=0; i<(IOPM_SIZE / 2); i++) {

        if (*IoMap != 0xffff) {
            if (IopmDiffTableEntries < MaxIopmTableEntries) {
                IopmDiffTable[IopmDiffTableEntries].Entry = (USHORT) i;
                IopmDiffTable[IopmDiffTableEntries].Value = *IoMap;
                IopmDiffTableEntries++;
            } else {
                ASSERT(IopmDiffTableEntries < MaxIopmTableEntries);
            }
        }
        *IoMap++ = 0;
    }

    //
    // The end of the IOPM table must be followed by a string of FF's.
    //

    while (i < (PIOPM_SIZE / 2)) {
        *IoMap++ = 0xffff;
        i++;
    }

    return IopmDiffTableEntries;
}


VOID
HalpRestoreIopm(
    PVOID Iopm,
    PIOPM_DIFF_ENTRY IopmDiffTable,
    ULONG IopmTableEntries
    )

/*++

Routine Description:

    We expect that most IOPM's will be all FF's.  So we'll reset to that
    state, and then we'll apply any changes from our differences table.

Arguments:

    Iopm - Pointer to the IOPM to restore.

    IopmDiffTable - Pointer to the table of IOPM deviations from 0xff.

    IopmTableEntries - The number of entries in our table.

Returns:

    none

--*/

{
    PUSHORT IoMap = Iopm;

    memset(Iopm, 0xff, PIOPM_SIZE);

    while (IopmTableEntries--) {
        IoMap[IopmDiffTable[IopmTableEntries].Entry] =
            IopmDiffTable[IopmTableEntries].Value;
    }
}


VOID
HalpBiosDisplayReset(
    VOID
    )

/*++

Routine Description:

    Calls BIOS by putting the machine into V86 mode.  This involves setting up
    a physical==virtual identity mapping for the first 1Mb of memory, setting
    up V86-specific trap handlers, and granting I/O privilege to the V86
    process by editing the IOPM bitmap in the TSS.

Environment:

    Interrupts disabled.

Arguments:

    None

Return Value:

    None.

--*/

{
    HARDWARE_PTE OldPageTable;
    HARDWARE_PTE_X86PAE OldPageTablePae;
    ULONGLONG OldPageTablePfn;

    USHORT OldIoMapBase;
    ULONG OldEsp0;
    PHARDWARE_PTE Pte;
    PHARDWARE_PTE V86CodePte;
    ULONG OldTrap0DHandler;
    ULONG OldTrap06Handler;
    PUCHAR IoMap;
    ULONG Virtual;
    KIRQL OldIrql;
    ULONG OriginalTssSelector;
    extern PVOID HalpRealModeStart;
    extern PVOID HalpRealModeEnd;
    extern volatile ULONG  HalpNMIInProgress;
    PHARDWARE_PTE PointerPde;
    PHARDWARE_PTE IdtPte;
    ULONG   OldIdtWrite;
    ULONG   PageFrame;
    ULONG   PageFrameEnd;
    PKPCR   Pcr;
    IOPM_DIFF_ENTRY IopmDiffTable[MAX_DIFFERENCES];
    ULONG   IopmDiffTableEntries;

    //
    // Interrupts are off, but V86 mode might turn them back on again.
    //
    OldIrql = HalpDisableAllInterrupts ();
    Pcr = KeGetPcr();

    //
    // We need to set up an identity mapping in the first page table.  First,
    // we save away the old page table.
    //

    PointerPde = MiGetPdeAddress((PVOID)0);
    OldPageTablePfn = HalpGetPageFrameNumber( PointerPde );

    if (HalPaeEnabled() != FALSE) {

        OldPageTablePae = *(PHARDWARE_PTE_X86PAE)PointerPde;
        ((PHARDWARE_PTE_X86PAE)PointerPde)->reserved1 = 0;

    } else {

        OldPageTable = *PointerPde;

    }

    //
    // Now we put the HAL page table into the first slot of the page
    // directory.  Note that this page table is now the first and last
    // entries in the page directory.
    //

    Pte = MiGetPdeAddress((PVOID)0);

    HalpCopyPageFrameNumber( Pte,
                             MiGetPdeAddress( MM_HAL_RESERVED ));
    
    Pte->Valid = 1;
    Pte->Write = 1;
    Pte->Owner = 1;         // User-accessible
    Pte->LargePage = 0;

    //
    // Flush TLB
    //

    HalpFlushTLB();

    //
    // Map the first 1Mb of virtual memory to the first 1Mb of physical
    // memory
    //
    for (Virtual=0; Virtual < 0x100000; Virtual += PAGE_SIZE) {
        Pte = MiGetPteAddress((PVOID)Virtual);
        HalpSetPageFrameNumber( Pte, Virtual >> PAGE_SHIFT );
        Pte->Valid = 1;
        Pte->Write = 1;
        Pte->Owner = 1;         // User-accessible
    }

    //
    // Map our code into the virtual machine
    //

    Pte = MiGetPteAddress((PVOID)0x20000);
    PointerPde = MiGetPdeAddress(&HalpRealModeStart);

    if ( PointerPde->LargePage ) {

        //
        // Map real mode PTEs into virtual mapping.  The source PDE is
        // from the indenity large pte map, so map the virtual machine PTEs
        // based on the base of the large PDE frame.
        //

        PageFrame = MiGetPteIndex( &HalpRealModeStart );
        PageFrameEnd = MiGetPteIndex( &HalpRealModeEnd );
        do {

            HalpSetPageFrameNumber( Pte,
                                    HalpGetPageFrameNumber( PointerPde ) +
                                        PageFrame );

            HalpIncrementPte( &Pte );
            ++PageFrame;

        } while (PageFrame <= PageFrameEnd);

    } else {

        //
        // Map real mode PTEs into virtual machine PTEs, by copying the
        // page frames from the source to the virtual machine PTEs.
        //

        V86CodePte = MiGetPteAddress(&HalpRealModeStart);
        do {
            HalpCopyPageFrameNumber( Pte, V86CodePte );
            HalpIncrementPte( &Pte );
            HalpIncrementPte( &V86CodePte );
    
        } while ( V86CodePte <= MiGetPteAddress(&HalpRealModeEnd) );

    }

    //
    // Verify the IDT is writable
    //

    Pte = MiGetPteAddress(Pcr->IDT);
    PointerPde = MiGetPdeAddress(Pcr->IDT);
    IdtPte = PointerPde->LargePage ? PointerPde : Pte;

    OldIdtWrite = (ULONG)IdtPte->Write;
    IdtPte->Write = 1;

    //
    // Flush TLB
    //

    HalpFlushTLB();

    //
    // We need to replace the current TRAP D handler with our own, so
    // we can do instruction emulation for V86 mode
    //

    OldTrap0DHandler = KiReturnHandlerAddressFromIDT(0xd);
    KiSetHandlerAddressToIDT(0xd, HalpTrap0D);

    OldTrap06Handler = KiReturnHandlerAddressFromIDT(6);
    KiSetHandlerAddressToIDT(6, HalpTrap06);

    //
    // Make sure current TSS has IoMap space available.  If no, borrow
    // Normal TSS.
    //

    OriginalTssSelector = HalpBorrowTss();

    //
    // Overwrite the first access map with zeroes, so the V86 code can
    // party on all the registers.
    //
    IoMap = (PUCHAR)&(Pcr->TSS->IoMaps[0].IoMap);

    IopmDiffTableEntries =
        HalpStoreAndClearIopm(IoMap, IopmDiffTable, MAX_DIFFERENCES);

    OldIoMapBase = Pcr->TSS->IoMapBase;

    Pcr->TSS->IoMapBase = KiComputeIopmOffset(1);

    //
    // Save the current ESP0, as HalpBiosCall() trashes it.
    //
    OldEsp0 = Pcr->TSS->Esp0;

    //
    // Call the V86-mode code
    //
    HalpBiosCall();

    //
    // Restore the TRAP handlers
    //


    if ((HalpNMIInProgress == FALSE) ||
        ((*((PBOOLEAN)(*(PLONG)&KdDebuggerNotPresent)) == FALSE) &&
        (**((PUCHAR *)&KdDebuggerEnabled) != FALSE))) {

      // If we are here due to an NMI, the IRET performed in HalpBiosCall() 
      // allows a second NMI to occur.  The second NMI causes a trap 0d because
      // the NMI TSS is busy and proceeds to bugcheck which trashes the screen. 
      // Thus in this case we leave this trap 0d handler in place which will then
      // just spin on a jump to self if a second NMI occurs.

      KiSetHandlerAddressToIDT(0xd, OldTrap0DHandler);
    }

    KiSetHandlerAddressToIDT(6, OldTrap06Handler);
    IdtPte->Write = OldIdtWrite;

    //
    // Restore Esp0 value
    //
    Pcr->TSS->Esp0 = OldEsp0;

    //
    // Restore the IoMap to its previous state.
    //

    HalpRestoreIopm(IoMap, IopmDiffTable, IopmDiffTableEntries);

    Pcr->TSS->IoMapBase = OldIoMapBase;

    //
    // Return borrowed TSS if any.
    //

    if (OriginalTssSelector != 0) {
        HalpReturnTss(OriginalTssSelector);
    }

    //
    // Unmap the first 1Mb of virtual memory
    //
    for (Virtual = 0; Virtual < 0x100000; Virtual += PAGE_SIZE) {
        Pte = MiGetPteAddress((PVOID)Virtual);
        HalpSetPageFrameNumber( Pte, 0 );
        Pte->Valid = 0;
        Pte->Write = 0;
    }

    //
    // Restore the original page table that we replaced.
    //

    PointerPde = MiGetPdeAddress((PVOID)0);

    if (HalPaeEnabled() != FALSE) {

        *(PHARDWARE_PTE_X86PAE)PointerPde = OldPageTablePae;

    } else {

        *PointerPde = OldPageTable;

    }

    HalpSetPageFrameNumber( PointerPde, OldPageTablePfn );

    //
    // Flush TLB
    //

    HalpFlushTLB();

    //
    // Re-enable Interrupts
    //

    HalpReenableInterrupts(OldIrql);
}

HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    )
{
    // this hal uses native int-10

    return HalDisplayInt10Bios;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxmemory.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxmemory.c

Abstract:

    Provides routines to allow the HAL to map physical memory.

Author:

    John Vert (jvert) 3-Sep-1991

Environment:

    Phase 0 initialization only.

Revision History:

--*/

//
// This module is compatible with PAE mode and therefore treats physical
// addresses as 64-bit entities.
//

#if !defined(_PHYS64_)
#define _PHYS64_
#endif

#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpAllocPhysicalMemory)
#endif

#define EXTRA_ALLOCATION_DESCRIPTORS 64

MEMORY_ALLOCATION_DESCRIPTOR
    HalpAllocationDescriptorArray[ EXTRA_ALLOCATION_DESCRIPTORS ];

ULONG HalpUsedAllocDescriptors = 0;

//
// Almost all of the last 4Mb of memory are available to the HAL to map
// physical memory.  The kernel may use a couple of PTEs in this area for
// special purposes, so skip any which are not zero.
//
// Note that the HAL's heap only uses the last 3Mb.  This is so we can
// reserve the first 1Mb for use if we have to return to real mode.
// In order to return to real mode we need to identity-map the first 1Mb of
// physical memory.
//

#define HAL_VA_START ((PVOID)(((ULONG_PTR)MM_HAL_RESERVED) + 1024 * 1024))
PVOID HalpHeapStart=HAL_VA_START;


PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory
    reserved for the HAL.  It does this by directly inserting the PTE
    into the Page Table which the OS Loader has provided.

    N.B.  This routine does *NOT* update the MemoryDescriptorList.  The
          caller is responsible for either removing the appropriate
          physical memory from the list, or creating a new descriptor to
          describe it.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - Supplies the number of pages contained in the area of
                  physical memory to be mapped.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

    NULL - The requested block of physical memory could not be mapped.

--*/

{
    PHARDWARE_PTE PTE;
    ULONG PagesMapped;
    PVOID VirtualAddress;
    PVOID RangeStart;

    //
    // The OS Loader sets up hyperspace for us, so we know that the Page
    // Tables are magically mapped starting at V.A. 0xC0000000.
    //

    PagesMapped = 0;
    RangeStart = HalpHeapStart;

    while (PagesMapped < NumberPages) {

        //
        // Look for enough consecutive free ptes to honor mapping
        //

        PagesMapped = 0;
        VirtualAddress = RangeStart;

        //
        // If RangeStart has wrapped, there are not enough free pages
        // available.
        //

        if (RangeStart == NULL) {
            return NULL;
        }

        while (PagesMapped < NumberPages) {
            PTE=MiGetPteAddress(VirtualAddress);
            if (HalpIsPteFree(PTE) == FALSE) {

                //
                // Pte is not free, skip up to the next pte and start over
                //

                RangeStart = (PVOID) ((ULONG_PTR)VirtualAddress + PAGE_SIZE);
                break;
            }
            VirtualAddress = (PVOID) ((ULONG_PTR)VirtualAddress + PAGE_SIZE);
            PagesMapped++;
        }

    }


    VirtualAddress = (PVOID) ((ULONG_PTR) RangeStart |
                              BYTE_OFFSET (PhysicalAddress.LowPart));

    if (RangeStart == HalpHeapStart) {

        //
        // Push the start of heap beyond this range.
        //

        HalpHeapStart = (PVOID)((ULONG_PTR)RangeStart + (NumberPages * PAGE_SIZE));
    }

    while (PagesMapped) {
        PTE=MiGetPteAddress(RangeStart);

        HalpSetPageFrameNumber( PTE, PhysicalAddress.QuadPart >> PAGE_SHIFT );
        PTE->Valid = 1;
        PTE->Write = 1;

        PhysicalAddress.QuadPart += PAGE_SIZE;
        RangeStart   = (PVOID)((ULONG_PTR)RangeStart + PAGE_SIZE);

        --PagesMapped;
    }

    //
    // Flush TLB
    //
    HalpFlushTLB ();
    return(VirtualAddress);
}

PVOID
HalpMapPhysicalMemoryWriteThrough64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG            NumberPages
)
/*++

Routine Description:

    Maps a physical memory address into virtual space, same as
    HalpMapPhysicalMemory().  The difference is that this routine
    marks the pages as PCD/PWT so that writes to the memory mapped registers
    mapped here won't get delayed in the internal write-back caches.

Arguments:

    PhysicalAddress - Supplies a physical address of the memory to be mapped

    NumberPages - Number of pages to map

Return Value:

    Virtual address pointer to the requested physical address

--*/
{
    ULONG       Index;
    PHARDWARE_PTE   PTE;
    PVOID       VirtualAddress;

    VirtualAddress = HalpMapPhysicalMemory(PhysicalAddress, NumberPages);
    PTE = MiGetPteAddress(VirtualAddress);

    for (Index = 0; Index < NumberPages; Index++, HalpIncrementPte(&PTE)) {

            PTE->CacheDisable = 1;
            PTE->WriteThrough = 1;
    }

    return VirtualAddress;
}

PVOID
HalpRemapVirtualAddress64(
    IN PVOID VirtualAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN BOOLEAN WriteThrough
    )
/*++

Routine Description:

    This routine remaps a PTE to the physical memory address provided.

Arguments:

    PhysicalAddress - Supplies the physical address of the area to be mapped

    VirtualAddress  - Valid address to be remapped

    WriteThrough - Map as cachable or WriteThrough

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

    NULL - The requested block of physical memory could not be mapped.

--*/
{
    PHARDWARE_PTE PTE;

    PTE = MiGetPteAddress (VirtualAddress);
    HalpSetPageFrameNumber( PTE, PhysicalAddress.QuadPart >> PAGE_SHIFT );
    PTE->Valid = 1;
    PTE->Write = 1;

    if (WriteThrough) {
        PTE->CacheDisable = 1;
        PTE->WriteThrough = 1;
    }

    //
    // Flush TLB
    //
    HalpFlushTLB();
    return(VirtualAddress);

}

VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    )
/*++

Routine Description:

    This routine unmaps a PTE.

Arguments:

    VirtualAddress  - Valid address to be remapped

    NumberPages - No of pages to be unmapped

Return Value:

    None.

--*/
{
    PHARDWARE_PTE   Pte;
    PULONG          PtePtr;
    ULONG           Index;

    if (VirtualAddress < HAL_VA_START)
        return;

    VirtualAddress = (PVOID)((ULONG_PTR)VirtualAddress & ~(PAGE_SIZE - 1));

    Pte = MiGetPteAddress (VirtualAddress);
    for (Index = 0; Index < NumberPages; Index++, HalpIncrementPte(&Pte)) {
        HalpFreePte( Pte );
    }

    //
    // Flush TLB
    //

    HalpFlushTLB();

    //
    // Realign heap start so that VA space can be reused
    //

    if (HalpHeapStart > VirtualAddress) {
        HalpHeapStart = VirtualAddress;
    }
}

ULONG
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    )
/*++

Routine Description:

    Carves out N pages of physical memory from the memory descriptor
    list in the desired location.  This function is to be called only
    during phase zero initialization.  (ie, before the kernel's memory
    management system is running)

Arguments:

    MaxPhysicalAddress - The max address where the physical memory can be

    NoPages - Number of pages to allocate

    bAlignOn64k - Whether caller wants resulting pages to be allocated
                  on a 64k byte boundry

Return Value:

    The physical address or NULL if the memory could not be obtained.

--*/
{
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR NewDescriptor;
    PMEMORY_ALLOCATION_DESCRIPTOR TailDescriptor;
    PLIST_ENTRY NextMd;
    ULONG AlignmentOffset;
    ULONG MaxPageAddress;
    ULONG PhysicalAddress;

    MaxPageAddress = MaxPhysicalAddress >> PAGE_SHIFT;

    if ((HalpUsedAllocDescriptors + 2) > EXTRA_ALLOCATION_DESCRIPTORS) {

        //
        // This allocation will require one or more additional
        // descriptors, but we don't have that many in our static
        // array.  Fail the request.
        //
        // Note: Depending on the state of the existing descriptor
        //       list it is possible that this allocation would not
        //       need an two additional descriptor blocks.  However in
        //       the interest of repeatability and ease of testing we
        //       will fail the request now anyway, rather than a
        //       smaller number of configuration-dependent failures.
        //
    
        ASSERT(FALSE);
        return 0;
    }

    //
    // Scan the memory allocation descriptors and allocate map buffers
    //

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
        Descriptor = CONTAINING_RECORD(NextMd,
                                MEMORY_ALLOCATION_DESCRIPTOR,
                                ListEntry);

        AlignmentOffset = bAlignOn64k ?
            ((Descriptor->BasePage + 0x0f) & ~0x0f) - Descriptor->BasePage :
            0;

        //
        // Search for a block of memory which is contains a memory chuck
        // that is greater than size pages, and has a physical address less
        // than MAXIMUM_PHYSICAL_ADDRESS.
        //

        if ((Descriptor->MemoryType == LoaderFree ||
             Descriptor->MemoryType == MemoryFirmwareTemporary) &&
            (Descriptor->BasePage) &&
            (Descriptor->PageCount >= NoPages + AlignmentOffset) &&
            (Descriptor->BasePage + NoPages + AlignmentOffset < MaxPageAddress)) {

        PhysicalAddress =
           (Descriptor->BasePage + AlignmentOffset) << PAGE_SHIFT;
                break;
        }

        NextMd = NextMd->Flink;
    }

    //
    // Use the extra descriptor to define the memory at the end of the
    // original block.
    //


    ASSERT(NextMd != &LoaderBlock->MemoryDescriptorListHead);

    if (NextMd == &LoaderBlock->MemoryDescriptorListHead)
        return 0;

    //
    // The new descriptor will describe the memory being allocated as
    // having been reserved.
    //

    NewDescriptor =
        &HalpAllocationDescriptorArray[ HalpUsedAllocDescriptors];
    NewDescriptor->PageCount = NoPages;
    NewDescriptor->BasePage = Descriptor->BasePage + AlignmentOffset;
    NewDescriptor->MemoryType = LoaderHALCachedMemory;

    HalpUsedAllocDescriptors++;

    //
    // Adjust the existing memory descriptors and insert the new one
    // describing the allocation.
    //

    if (AlignmentOffset == 0) {

        //
        // Trim the source descriptor and insert the allocation
        // descriptor before it.
        //

        Descriptor->BasePage  += NoPages;
        Descriptor->PageCount -= NoPages;

        InsertTailList(
            &Descriptor->ListEntry,
            &NewDescriptor->ListEntry
            );

        if (Descriptor->PageCount == 0) {

            //
            // The whole block was allocated,
            // Remove the entry from the list completely.
            //
            // NOTE: This descriptor can't be recycled or freed since
            // we don't know the allocator.
            //

            RemoveEntryList(&Descriptor->ListEntry);

        }

    } else {

        if (Descriptor->PageCount - NoPages - AlignmentOffset) {

            // 
            // This allocation is coming out of the middle of a descriptor
            // block.  We can use the existing descriptor block to describe
            // the head portion, but we will need a new one to describe the
            // tail.
            //
            // Allocate one from the array in the data segment.  The check
            // at the top of the function ensures that one is available.
            //

            TailDescriptor =
                &HalpAllocationDescriptorArray[ HalpUsedAllocDescriptors];

            //
            // The extra descriptor is needed so intialize it and insert
            // it in the list.
            //

            TailDescriptor->PageCount =
                Descriptor->PageCount - NoPages - AlignmentOffset;

            TailDescriptor->BasePage =
                Descriptor->BasePage + NoPages + AlignmentOffset;

            TailDescriptor->MemoryType = MemoryFree;
            HalpUsedAllocDescriptors++;

            InsertHeadList(
                &Descriptor->ListEntry,
                &TailDescriptor->ListEntry
                );
        }


        //
        // Use the current entry as the descriptor for the first block.
        //

        Descriptor->PageCount = AlignmentOffset;

        //
        // Insert the allocation descriptor after the original
        // descriptor but before the tail descriptor if one was necessary.
        //

        InsertHeadList(
            &Descriptor->ListEntry,
            &NewDescriptor->ListEntry
            );
    }

    return PhysicalAddress;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxflshbf.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    xxflshbf.c

Abstract:

    This module implements i386 machine dependent kernel functions to flush
    write buffers.

Author:

    David N. Cutler (davec) 26-Apr-1990

Environment:

    Kernel mode only.

Revision History:

--*/

#include "nthal.h"

VOID
KeFlushWriteBuffer (
    VOID
    )

/*++

Routine Description:

    This function flushes the write buffer on the current processor.

Arguments:

    None.

Return Value:

    None.

--*/

{

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxioacc.asm ===
title  "ix ioaccess"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixioacc.asm
;
; Abstract:
;
;    Procedures to correctly touch I/O registers.
;
; Author:
;
;    Bryan Willman (bryanwi) 16 May 1990
;
; Environment:
;
;    User or Kernel, although privledge (IOPL) may be required.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
        .list

_TEXT$00   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; I/O port space read and write functions.
;
;  These have to be actual functions on the 386, because we need
;  to use assembler, but cannot return a value if we inline it.
;
;  This set of functions manipulates I/O registers in PORT space.
;  (Uses x86 in and out instructions)
;
;  WARNING: Port addresses must always be in the range 0 to 64K, because
;           that's the range the hardware understands.
;
;--



;++
;
;   UCHAR
;   READ_PORT_UCHAR(
;       PUCHAR  Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc _READ_PORT_UCHAR ,1
cPublicFpo 1, 0

        xor     eax, eax        ; Eliminate partial stall on return to caller

        mov     edx,[esp+4]             ; (dx) = Port
        in      al,dx
        stdRET    _READ_PORT_UCHAR

stdENDP _READ_PORT_UCHAR



;++
;
;   USHORT
;   READ_PORT_USHORT(
;       PUSHORT Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc _READ_PORT_USHORT ,1
cPublicFpo 1, 0

        xor     eax, eax        ; Eliminate partial stall on return to caller

        mov     edx,[esp+4]            ; (dx) = Port
        in      ax,dx
        stdRET    _READ_PORT_USHORT

stdENDP _READ_PORT_USHORT



;++
;
;   ULONG
;   READ_PORT_ULONG(
;       PULONG  Port
;       )
;
;   Arguments:
;       (esp+4) = Port
;
;   Returns:
;       Value in Port.
;
;--
cPublicProc _READ_PORT_ULONG ,1
cPublicFpo 1, 0

        mov     edx,[esp+4]            ; (dx) = Port
        in      eax,dx
        stdRET    _READ_PORT_ULONG

stdENDP _READ_PORT_ULONG



;++
;
;   VOID
;   READ_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_UCHAR ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insb
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_UCHAR

stdENDP _READ_PORT_BUFFER_UCHAR


;++
;
;   VOID
;   READ_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_USHORT ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insw
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_USHORT

stdENDP _READ_PORT_BUFFER_USHORT


;++
;
;   VOID
;   READ_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _READ_PORT_BUFFER_ULONG ,3
cPublicFpo 3, 0

        mov     eax, edi                ; Save edi

        mov     edx,[esp+4]             ; (dx) = Port
        mov     edi,[esp+8]             ; (edi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep insd
        mov     edi, eax
        stdRET    _READ_PORT_BUFFER_ULONG

stdENDP _READ_PORT_BUFFER_ULONG



;++
;
;   VOID
;   WRITE_PORT_UCHAR(
;       PUCHAR  Port,
;       UCHAR   Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_PORT_UCHAR ,2
cPublicFpo 2, 0

        mov     edx,[esp+4]             ; (dx) = Port
        mov     al,[esp+8]              ; (al) = Value
        out     dx,al
        stdRET    _WRITE_PORT_UCHAR

stdENDP _WRITE_PORT_UCHAR

;++
;
;   VOID
;   WRITE_PORT_USHORT(
;       PUSHORT Port,
;       USHORT  Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_PORT_USHORT ,2
cPublicFpo 2, 0

        mov     edx,[esp+4]             ; (dx) = Port
        mov     eax,[esp+8]             ; (ax) = Value
        out     dx,ax
        stdRET    _WRITE_PORT_USHORT

stdENDP _WRITE_PORT_USHORT



;++
;
;   VOID
;   WRITE_PORT_ULONG(
;       PULONG  Port,
;       ULONG   Value
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Value
;
;--
cPublicProc _WRITE_PORT_ULONG ,2
cPublicFpo 2, 0

        mov     edx,[esp+4]             ; (dx) = Port
        mov     eax,[esp+8]             ; (eax) = Value
        out     dx,eax
        stdRET    _WRITE_PORT_ULONG

stdENDP _WRITE_PORT_ULONG


;++
;
;   VOID
;   HalpIoDelay (
;      VOID
;        )
;
;   Arguments:
;   None
;
;   Notes: Used to program the DMA controller. There exist some legacy parts that require
;   a delay after write. The chip recognizes the jmp $+2 sequence and flushes internal
;   buffers.
;
;--



cPublicFastCall HalpIoDelay,0
        jmp   $+2
        jmp   $+2                           ;Stall for IO out
        fstRET   HalpIoDelay

fstENDP HalpIoDelay



;++
;
;   VOID
;   WRITE_PORT_BUFFER_UCHAR(
;       PUCHAR  Port,
;       PUCHAR  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_UCHAR ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsb
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_UCHAR

stdENDP _WRITE_PORT_BUFFER_UCHAR


;++
;
;   VOID
;   WRITE_PORT_BUFFER_USHORT(
;       PUSHORT Port,
;       PUSHORT Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_USHORT ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsw
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_USHORT

stdENDP _WRITE_PORT_BUFFER_USHORT


;++
;
;   VOID
;   WRITE_PORT_BUFFER_ULONG(
;       PULONG  Port,
;       PULONG  Buffer,
;       ULONG   Count
;       )
;
;   Arguments:
;       (esp+4) = Port
;       (esp+8) = Buffer address
;       (esp+12) = Count
;
;--
cPublicProc _WRITE_PORT_BUFFER_ULONG ,3
cPublicFpo 3, 0

        mov     eax,esi                 ; Save esi
        mov     edx,[esp+4]             ; (dx) = Port
        mov     esi,[esp+8]             ; (esi) = buffer
        mov     ecx,[esp+12]            ; (ecx) = transfer count
    rep outsd
        mov     esi,eax
        stdRET    _WRITE_PORT_BUFFER_ULONG

stdENDP _WRITE_PORT_BUFFER_ULONG

    .586p

;++
;ULONGLONG
;FASTCALL
;RDMSR(
;   IN  ULONG   MsrAddress
;   )
;   Routine Description:
;       This function reads an MSR
;
;   Arguments:
;       Msr:    The address of MSR to be read
;
;   Return Value:
;       Returns the low 32 bit of MSR in eax and high 32 bits of MSR in edx
;
;--
cPublicFastCall RDMSR,1

        rdmsr
        fstRET  RDMSR

fstENDP RDMSR

;++
;
;VOID
;WRMSR(
;   IN ULONG    MsrAddress,
;   IN ULONGLONG    MsrValue
;   )
;   Routine Description:
;       This function writes an MSR
;
;   Arguments:
;       Msr:    The address of MSR to be written
;       Data:   The value to be written to the MSR register
;
;   Return Value:
;       None
;
;--

cPublicProc _WRMSR,3

        mov     ecx, [esp + 4]  ; MsrAddress
        mov     eax, [esp + 8]  ; Low  32 bits of MsrValue
        mov     edx, [esp + 12] ; High 32 bits of MsrValue

        wrmsr
        stdRET  _WRMSR

stdENDP _WRMSR


_TEXT$00   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halx86\i386\xxtime.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxtime.c

Abstract:

    This module implements the HAL set/query realtime clock routines for
    an x86 system.

Author:

    David N. Cutler (davec) 5-May-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"

BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine queries the realtime clock.

    N.B. This routine assumes that the caller has provided any required
        synchronization to query the realtime clock information.

Arguments:

    TimeFields - Supplies a pointer to a time structure that receives
        the realtime clock information.

Return Value:

    If the power to the realtime clock has not failed, then the time
    values are read from the realtime clock and a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    HalpReadCmosTime(TimeFields);
    return TRUE;
}

BOOLEAN
HalSetRealTimeClock (
    IN PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine sets the realtime clock.

    N.B. This routine assumes that the caller has provided any required
        synchronization to set the realtime clock information.

Arguments:

    TimeFields - Supplies a pointer to a time structure that specifies the
        realtime clock information.

Return Value:

    If the power to the realtime clock has not failed, then the time
    values are written to the realtime clock and a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{
    HalpWriteCmosTime(TimeFields);
    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\inc\chiphacks.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    chiphacks.h
   
Abstract:

    Implements utilities for finding and hacking
    various chipsets

Author:

    Jake Oshins (jakeo) 10/02/2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"

#define PM_TIMER_HACK_FLAG          1
#define DISABLE_HIBERNATE_HACK_FLAG 2
#define SET_ACPI_IRQSTACK_HACK_FLAG 4
#define WHACK_ICH_USB_SMI_HACK_FLAG 8

NTSTATUS
HalpGetChipHacks(
    IN  USHORT  VendorId,
    IN  USHORT  DeviceId,
    IN  ULONG   Ssid OPTIONAL,
    OUT ULONG   *HackFlags
    );

BOOLEAN
HalpDoesChipNeedHack(
    IN  USHORT  VendorId,
    IN  USHORT  DeviceId,
    IN  ULONG   Ssid OPTIONAL,
    IN  ULONG   HackFlag
    );

VOID
HalpStopOhciInterrupt(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber
    );

VOID
HalpStopUhciInterrupt(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber,
    BOOLEAN             ResetHostController
    );

VOID
HalpSetAcpiIrqHack(
    ULONG   Value
    );

VOID
HalpWhackICHUsbSmi(
    ULONG               BusNumber,
    PCI_SLOT_NUMBER     SlotNumber
    );

VOID
HalpClearSlpSmiStsInICH(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\inc\hali.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    hali.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces for bus range support.

Author:

    David N. Cutler (davec) 28-Mar-95


Revision History:

--*/

#ifndef _HALI_
#define _HALI_


// define INVALID_HANDLE for HAL routines
#define INVALID_HANDLE      (HANDLE) -1

//
// Define type of memory for bus range allocations.
//

#define SPRANGEPOOL NonPagedPool

//
// General Pool Tag for HAL use (see pooltag.txt).
//

#define HAL_POOL_TAG    ' laH'

//
// Define bus range function prototypes.
//

PSUPPORTED_RANGES
HalpMergeRanges (
    IN PSUPPORTED_RANGES    Parent,
    IN PSUPPORTED_RANGES    Child
    );

VOID
HalpMergeRangeList (
    PSUPPORTED_RANGE    NewList,
    PSUPPORTED_RANGE    Source1,
    PSUPPORTED_RANGE    Source2
    );

PSUPPORTED_RANGES
HalpConsolidateRanges (
    PSUPPORTED_RANGES   Ranges
    );

PSUPPORTED_RANGES
HalpAllocateNewRangeList (
    VOID
    );

VOID
HalpFreeRangeList (
    PSUPPORTED_RANGES   Ranges
    );

PSUPPORTED_RANGES
HalpCopyRanges (
    PSUPPORTED_RANGES     Source
    );

VOID
HalpAddRangeList (
    IN OUT PSUPPORTED_RANGE DRange,
    OUT PSUPPORTED_RANGE    SRange
    );

VOID
HalpAddRange (
    PSUPPORTED_RANGE    HRange,
    ULONG               AddressSpace,
    LONGLONG            SystemBase,
    LONGLONG            Base,
    LONGLONG            Limit
    );

VOID
HalpRemoveRanges (
    IN OUT PSUPPORTED_RANGES    Minuend,
    IN PSUPPORTED_RANGES        Subtrahend
    );

VOID
HalpRemoveRangeList (
    IN OUT PSUPPORTED_RANGE     Minuend,
    IN PSUPPORTED_RANGE         Subtrahend
    );


VOID
HalpRemoveRange (
    PSUPPORTED_RANGE    HRange,
    LONGLONG            Base,
    LONGLONG            Limit
    );

VOID
HalpDisplayAllBusRanges (
    VOID
    );

#endif // _HALI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\inc\ntapic.inc ===
;/*++
;
;Module Name:
;
;    ntapic.inc
;
;Abstract:
;
;    This header file is intended to be included by any HAL
;    that uses APICs.
;
;Author:
;
;    Ron Mosgrove (Intel)
;
;Environment:
;
;    Kernel mode only.
;
;Revision History:
;
;    Separated out from pcmp_nt.inc -- 6-2-98 (jakeo)
;    
;
if 0        ; Begin C only code         */

//#define DEBUGGING       1

#ifndef DBGMSG
#ifdef DEBUGGING
extern CHAR Cbuf[];
#define DBGMSG(x) DbgPrint(x);
#else
#define DBGMSG(x)
#endif
#endif

//
//  To allow the user to specify command line options to the HAL.
//
#define USER_SETABLE_OPTIONS
// #define BUILD_FOR_OLD_IDW

//
//  Default BusType
//

#ifndef MCA
#define DEFAULT_PC_BUS      Eisa
#else
#define DEFAULT_PC_BUS      MicroChannel
#endif


//
//  Well known virtual address of local processor apic
//

#define LOCALAPIC   0xfffe0000
#define pLocalApic  ((volatile PULONG) LOCALAPIC)

//
//  Additional CpuFlags Bits used by NT in PC+MP Table
//
#define CPU_NT_STARTED      0x40    // CPU Has Been Started
#define CPU_NT_RUNNING      0x80    // CPU is Runing NT
#define MAX_PROCESSORS      32
#define MAX_CLUSTERS        15
#define MAX_IOAPICS         64

//
//  This OS specific structure holds useful MP information. This information
//  is obtained from the PC+MP table and stored here for convenience.
//
typedef struct HalpMpInfo {
    ULONG ApicVersion;      // 82489Dx or Not
    ULONG ProcessorCount;   // Number of Enabled Processors
    ULONG NtProcessors;     // Number of Running Processors
    ULONG BusCount;         // Number of buses in system
    ULONG IOApicCount;      // Number of Io Apics in system
    ULONG IntiCount;        // Number of Io Apic interrupt input entries
    ULONG LintiCount;       // Number of Local Apic interrupt input entries
    ULONG IMCRPresent;      // Indicates if the IMCR is present
    ULONG LocalApicBase;    // Base of local APIC
    PULONG IoApicBase[MAX_IOAPICS]; // The virtual addresses of the IoApics
    ULONG  IoApicPhys[MAX_IOAPICS]; // The physical addresses of the IoApics
#ifdef ACPI_HAL
    ULONG  IoApicIntiBase[MAX_IOAPICS];  // The 'number' of the first INTI  -- only used for ACPI
#else
    PPCMPPROCESSOR ProcessorEntryPtr;       // Ptr to 1st PC+MP processor entry
    PPCMPBUS       BusEntryPtr;             // Ptr to 1st PC+MP bus  entry
    PPCMPIOAPIC    IoApicEntryPtr;          // Ptr to 1st PC+MP IoApic entry
    PPCMPINTI      IntiEntryPtr;            // Ptr to 1st PC+MP Inti entry
    PPCMPLINTI     LintiEntryPtr;           // Ptr to 1st PC+MP Linti entry
    PMPS_EXTENTRY  ExtensionTable;          // Ptr to 1st extension table entry
    PMPS_EXTENTRY  EndOfExtensionTable;
#endif
} MP_INFO, *PMP_INFO;

typedef struct {
    PUCHAR                  PcMpType;
    BOOLEAN                 PhysicalInstance;
    UCHAR                   Level;
    INTERFACE_TYPE          NtType;
    PINSTALL_BUS_HANDLER    NewInstance;
    BUS_DATA_TYPE           NtConfig;
    ULONG                   BusExtensionSize;
} PCMPBUSTRANS, *PPCMPBUSTRANS;

#define CFG_MUST_BE         0x02
#define CFG_ERROR           0x80

#define CFG_HIGH            0x01
#define CFG_LOW             0x00

#define CFG_EDGE            0x00
#define CFG_LEVEL           0x01
#define CFG_MB_EDGE         (CFG_MUST_BE | CFG_EDGE)
#define CFG_MB_LEVEL        (CFG_MUST_BE | CFG_LEVEL)
#define CFG_ERR_EDGE        (CFG_ERROR | CFG_EDGE)
#define CFG_ERR_LEVEL       (CFG_ERROR | CFG_LEVEL)
#define CFG_ERR_MB_EDGE     (CFG_ERROR | CFG_MUST_BE | CFG_EDGE)
#define CFG_ERR_MB_LEVEL    (CFG_ERROR | CFG_MUST_BE | CFG_LEVEL)

#define CFG_TYPE(a)     (a & 1)

typedef union _INTERRUPT_DEST  {
    union _Cluster  {
        struct _Hw  {
            UCHAR   DestId:4;
            UCHAR   ClusterId:4;
        } Hw;
        UCHAR AsUchar;
    } Cluster;
    UCHAR   LogicalId;
} INTERRUPT_DEST, *PINTERRUPT_DEST;

//
// The kernel leaves some space (64 byte) of the PCR for the HAL to use
// as it needs.  Currently this space is used for some efficiency in
// some of the MP specific code and is highly implementation-dependent.
//
typedef struct _HALPCR {
    UCHAR PcrNumber;   // Processor's number
    UCHAR ShortDpc;    // Short circut dpc interrupt
    UCHAR DpcPending;  // Dpc interrupt pending
    UCHAR Reserved;    // force dword alignment

    //
    // The next three dwords are used to manipulate the APIC counter
    //
    ULONG ApicClockFreqHz;   // Counter Freq in Hertz
    ULONG ApicClockFreqKhz;  // Counter Freq in Khertz (rounded)
    ULONG ProfileCountDown;  // Current Countdown Interval

    ULONG TSCHz;             // Time stamp counter hertz low

    ULONG PerfCounterLow;    // PerProcessor Counter
    ULONG PerfCounterHigh;
} HALPCR, *PHALPCR;

//
// The kernel leaves some space (64 byte) of the PCRB for the HAL to use
// as it needs.  Currently this space is used for some efficiency in
// some of the MP specific code and is highly implementation-dependent.
//

typedef struct {
    UCHAR           PCMPApicID;
    UCHAR           na[3];
} HALPRCB, *PHALPRCB;


//
// interrupt vector definitions for C
//

#define ZERO_VECTOR             0x00    // IRQL 00 placeholder
#define APIC_SPURIOUS_VECTOR    0x1f    // IRQL    Spurious handler
#define APC_VECTOR              0x3D    // IRQL 01 APC
#define DPC_VECTOR              0x41    // IRQL 02 DPC
#define APIC_REBOOT_VECTOR      0x50    // IRQL    Vector used to reboot
#define APIC_GENERIC_VECTOR     0xC1    // IRQL 27 broadcast function call
#define APIC_CLOCK_VECTOR       0xD1    // IRQL 28 APIC INTI0 - CLOCK2_LEVEL

//
// If MP, define APIC_SYNCH_LEVEL as SYNCH_LEVEL, otherwise define
// to be the same as DPC_LEVEL.
//

#if (SYNCH_LEVEL != DISPATCH_LEVEL)

#define APIC_SYNCH_VECTOR       0xD1    // IRQL 28 IPI_LEVEL-1

#else

#define APIC_SYNCH_VECTOR       DPC_VECTOR // IRQL 02 if UNIPROCESSOR

#endif

#define APIC_IPI_VECTOR         0xE1    // IRQL 29 APIC IPI

#define APIC_FAULT_VECTOR       0xE3    //
#define POWERFAIL_VECTOR        0xEF    // IRQL 30 reserved. not used

#define APIC_PROFILE_VECTOR     0xFD    // IRQL 31
#define APIC_PERF_VECTOR        0xFE    // IRQL 31
#define NMI_VECTOR              0xFF    // IRQL 31

//
//  8259/ISP interrupt controller register addresses
//

#define PIC1_PORT0              0x20
#define PIC1_PORT1              0x21
#define PIC2_PORT0              0xA0
#define PIC2_PORT1              0xA1

#define PIC_SLAVE_IRQ           2
#define RTC_IRQ                 8

#define PIC1_ELCR_PORT          0x04D0  // ISP edge/level control registers
#define PIC2_ELCR_PORT          0x04D1

#define PIC1_SPURIOUS_VECTOR    0x37

//
// Defines for HalpFeatureBits
//

extern ULONG HalpFeatureBits;

//
//
//

ULONG FASTCALL HalpAcquireHighLevelLock(PKSPIN_LOCK);
VOID  FASTCALL HalpReleaseHighLevelLock(PKSPIN_LOCK, ULONG);
extern KSPIN_LOCK   HalpAccountingLock;
extern KAFFINITY    HalpActiveProcessors;

//
// Prototypes
//

#define MAX_INTI         (MAX_IOAPICS*32) // Max interrupt inputs from APICs
#define MAX_SOURCE_IRQS  MAX_INTI         // Max different interrupts supported

//
// HalVectorToIDTEntry(vector) is defined in i386.h, because the kernel needs
// it.
#define MAX_NODES                       MAX_PROCESSORS
#define HalpVectorToNode(vector)        ((vector)>>8)
#define HalpVector(node, idtentry)      ((node)<<8|(idtentry))

extern struct HalpMpInfo HalpMpInfoTable;
extern UCHAR  HalpMaxProcsPerCluster;

extern BOOLEAN  HalpELCRChecked;
extern USHORT   HalpGlobal8259Mask;
extern USHORT   HalpVectorToINTI[];
extern UCHAR    HalpInitLevel[4][4];
extern UCHAR    HalpDevPolarity[4][2];
extern UCHAR    HalpDevLevel[2][4];

//
// Initialized from MPS table
//

typedef struct _INTI_INFO {
    UCHAR   Type:4;
    UCHAR   Level:2;
    UCHAR   Polarity:2;
    UCHAR   Destinations;
    USHORT  Entry;
} INTI_INFO, *PINTI_INFO;

extern INTI_INFO    HalpIntiInfo[];
extern USHORT       HalpMaxApicInti[];
extern PCMPBUSTRANS HalpTypeTranslation[];

extern ULONG HalpIpiClock;

#define BusIrq2Id(bus,no,irq)           \
    ((bus << 16) | (no << 8) | irq)
    
#define Id2BusIrq(id)                   \
    (id & 0xff)

VOID
HalpInitIntiInfo (
    VOID
    );

ULONG
HalpGetIoApicId(
    ULONG   ApicNo
    );
    
VOID
HalpSet8259Mask(
    IN USHORT Mask
        );

VOID
HalpInitializeLocalUnit (
    VOID
    );

VOID
HalpInitializeIOUnits (
    VOID
    );

VOID
HalpRestoreIoApicRedirTable (
    VOID
    );

VOID
HalpEnableNMI (
    VOID
    );

VOID
HalpEnableLocalNmiSources(
    VOID
    );
    
VOID
HalpSet8259Mask(
    IN USHORT Mask
    );

BOOLEAN
HalpGetApicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PUSHORT PcMpInti
    );

VOID
HalpCheckELCR (
    VOID
    );

VOID
HalpSetInternalVector (
    IN ULONG    InternalVector,
    IN VOID   (*HalInterruptSerivceRoutine)(VOID)
    );

VOID
HalpGenericCall (
    VOID        (*Fnc)(ULONG),
    ULONG       Context,
    KAFFINITY   Processors
    );

VOID
HalpPollForBroadcast (
    VOID
    );

ULONG
FASTCALL
HalpWaitForPending (
    IN ULONG    Count,
    IN volatile ULONG *LuICR
    );

VOID
HalpPerfInterrupt(
    VOID
    );

VOID
HalpEnablePerfInterupt (
    ULONG Context
    );

VOID
HalpEnableNMI (
    VOID
    );

NTSTATUS
HalpSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    );
    
ULONG
HalpInti2BusInterruptLevel(
    ULONG   Inti
    );    

VOID
HalpUnMapIOApics(
    VOID
    );
    
VOID
HalpInitializeIOUnits (
    VOID
    );
    
VOID
HalpPostSleepMP(
    IN LONG           NumberProcessors,
    IN volatile PLONG Number
    );

VOID
HalpSetRedirEntry (
    IN USHORT InterruptInput,
    IN ULONG  Entry,
    IN ULONG  Destination
    );

VOID
HalpGetRedirEntry (
    IN USHORT InterruptInput,
    IN PULONG Entry,
    IN PULONG Destination
    );

/*
endif
;
;  Begin assembly part of the definitions
;

;
;  Well known virtual address of local processor apic
;

LOCALAPIC   equ     0fffe0000h
APIC        equ     ds:[LOCALAPIC]

DEBUGGING       equ 0


if DEBUGGING
IRQL_METRICS        equ     0
endif
;
;  To allow the user to specify command line options to the HAL.
;
USER_SETABLE_OPTIONS    equ 1

MAX_PROCESSORS equ 32
MAX_NODES equ MAX_PROCESSORS
MAX_IOAPICS equ 64
;
;  This OS specific structure holds useful MP information. This information
;  is obtained from the PC+MP table and stored here for convenience.
;

HalpMpInfo struc
    ApicVersion     dd  0   ; 82489Dx or Not
    ProcessorCount  dd  0   ; Number of Enabled Processors
    NtProcessors    dd  0   ; Number of Running Processors
    BusCount        dd  0   ; Number of buses in system
    IOApicCount     dd  0   ; Number of Io Apics in system
    IntiCount       dd  0   ; Num of Io Apic interrupt inputs
    LintiCount      dd  0   ; Num of Local Apic interrupt inputs
    IMCRPresent     dd  0   ; Indicates if the IMCR is present
    LocalApicBase   dd  0   ; Base of local apic
    IoApicBase      dd  MAX_IOAPICS  dup (0) ; Virtual addresses of IoApics
    IoApicPhys      dd  MAX_IOAPICS  dup (0) ; Physical addresses of IoApics
ifdef ACPI_HAL
    IoApicIntiBase dd MAX_IOAPICS  dup (0) ; ACPI only.  First GSIV.
else
    ProcessorEntryPtr   dd  0   ; Ptr to 1st PC+MP processor entry
    BusEntryPtr     dd  0   ; Ptr to 1st PC+MP bus  entry
    IoApicEntryPtr  dd  0   ; Ptr to 1st PC+MP IoApic entry
    IntiEntryPtr    dd  0   ; Ptr to 1st PC+MP Inti entry
    LintiEntryPtr   dd  0   ; Ptr to 1st PC+MP Linti entry
    ExtensionTable  dd  0   ; Ptr to 1st extension table entry
    EndExtensionTable dd  0 ; Ptr to 1st extension table entry
endif
HalpMpInfo ends


;
;  interrupt vector definitions for assembler
;

ZERO_VECTOR             equ     000h    ;  IRQL 00 placeholder
APIC_SPURIOUS_VECTOR    equ     01fh    ;  Vector used for spurious handler
APC_VECTOR              equ     03Dh    ;  IRQL 01 APC
DPC_VECTOR              equ     041h    ;  IRQL 02 DPC
APIC_REBOOT_VECTOR      equ     050h    ;  Vector used to reboot
DEVICE_LEVEL1           equ     051h
DEVICE_LEVEL2           equ     061h
DEVICE_LEVEL3           equ     071h
DEVICE_LEVEL4           equ     081h
DEVICE_LEVEL5           equ     091h
DEVICE_LEVEL6           equ     0A1h
DEVICE_LEVEL7           equ     0B1h
APIC_GENERIC_VECTOR     equ     0C1h    ;  IRQL 27 broadcast function call
APIC_CLOCK_VECTOR       equ     0D1h    ;  IRQL 28 APIC INTI0 - CLOCK2_LEVEL

if SYNCH_LEVEL-DISPATCH_LEVEL

APIC_SYNCH_VECTOR       equ     0D1h    ;  IRQL 28 IPI_LEVEL-1

else

APIC_SYNCH_VECTOR       equ     DPC_VECTOR

endif

APIC_IPI_VECTOR         equ     0E1h    ;  IRQL 29 APIC IPI

APIC_FAULT_VECTOR       equ     0E3h    ;
POWERFAIL_VECTOR        equ     0EFh    ;  IRQL 30 reserved

APIC_PROFILE_VECTOR     equ     0FDh    ;  IRQL 27
APIC_PERF_VECTOR        equ     0FEh    ;  IRQL 27
NMI_VECTOR              equ     0FFh    ;  IRQL 31

HAL_PROFILE_LEVEL       equ     HIGH_LEVEL

;
;  8259/ISP interrupt controller register addresses
;

PIC1_PORT0          equ     020H
PIC1_PORT1          equ     021H
PIC2_PORT0          equ     0A0H
PIC2_PORT1          equ     0A1H

PIC1_ELCR_PORT      equ     04D0H   ; ISP edge/level control registers
PIC2_ELCR_PORT      equ     04D1H

;
; Initialization control words for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_AUTO_EOI                   equ     002H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

PIC_SLAVE_IRQ                   equ     2

PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H
PIC_CLOCK_VECTOR                equ     30H
PIC_DMA_VECTOR                  equ     3DH
PIC1_SPURIOUS_VECTOR            equ     37H
PIC2_SPURIOUS_VECTOR            equ     3FH

;
;  Operation control words for the PICs
;

OCW2_NON_SPECIFIC_EOI   equ     020H
OCW2_SPECIFIC_EOI       equ     060H
OCW3_READ_ISR           equ     0BH
OCW3_READ_IRR           equ     0AH
OCW3_READ_POLLED        equ     0CH

;
; A couple of definitions that shouldn't change on a Compatible
;

TimerPicInti        equ     0
DmaPic2Inti         equ     5
SlavePicInti        equ     2
DmaPicInti          equ     13  ; DMA input relative to 0

cr                  equ 0ah
lf                  equ 0dh

;
; The kernel leaves some space (64 byte) of the PCR for the HAL to use
; as it needs.  Currently this space is used for some efficiency in
; some of the MP specific code and is highly implementation-dependent.
;


PcrE struc
    PcrNumber           db      0           ; Processor's number
    ShortDpc            db      0           ; Short circut dpc interrupt
    DpcPending          db      0           ; Dpc interrupt pending

                        db      0               ; force dword alignment
    ;
    ;   The next three dwords are used to manipulate the APIC counter
    ;

    ApicClockFreqHz     dd      0           ; Counter Freq in Hertz
    ApicClockFreqKhz    dd      0           ; Counter Freq in Khertz (rounded)
    ProfileCountDown    dd      0           ; Current Countdown Interval

    TSCHz               dd      0           ; Time stamp counter hertz low


    PerfCounterLow      dd      0           ; PerProcessor Counter
    PerfCounterHigh     dd      0           ;
    ; ProfileCountLast    dd      0
    
    OEMPcr              db      size OEMPcr dup(?)

PcrE ends

PrcbE struc
    PrcbPCMPApicID      db      0           ; Processor's PCMP ApicID
                        db      3 dup (0)       ; force dword alignment
PrcbE ends


MsrTSC  equ     10h

;++
;
;   STALL_WHILE_APIC_BUSY
;
;   Wait for the APIC DELIVERY_PENDING bit to be clear
;
;--

STALL_WHILE_APIC_BUSY macro
    local   a, b
if 0

        push    eax
        mov     eax, 5000h

a:      test    dword ptr APIC[LU_INT_CMD_LOW],DELIVERY_PENDING
        jz      short b

        dec     eax
        jnz     short a

        int 3
        jmp     short a

b:      pop     eax

else

a:      test    dword ptr APIC[LU_INT_CMD_LOW],DELIVERY_PENDING
        jnz     short a

endif
endm

;++
;
;   APICFIX
;
;   Macro Description:
;
;       For internal testing use
;
;   Arguments:
;
;       None
;
;--

APICFIX macro reg1
    ;    inc     dword ptr PCR[PcKernel]           ; Count # of times patched
endm

;++
;
;   CHECKTPR
;
;   Macro Description:
;
;       For internal testing use
;
;   Arguments:
;
;       None
;
;--

CHECKTPR macro reg1, reg2
if DBG
        cmp     reg1, reg2
        je      short @f
        int 3
@@:
endif
endm

;++
;
;   IODELAY
;
;   Macro Description:
;
;       This macro delays the CPU just a little so the PIC has time to settle
;       between IO port accesses.  Current mechanism is to read an APIC local
;       unit register (eax is saved).  Note that PUSHF/POPF is worth 10 clocks.
;
;   Arguments:
;
;       None
;
;--

IODELAY macro
        pushf
        popf
        jmp     $+2
endm

;++
;
;   SET_8259_MASK
;
;   Macro Description:
;
;       This macro sets the 8259 PIC interrupt mask register with the mask
;       passed from eax register.  Bits 7:0 are the mask for the master PIC
;       and bits 15:8 are the mask for the slave PIC.
;
;   Arguments:
;
;       (eax) = mask for setting 8259 PIC interrupt mask register
;
;--

SET_8259_MASK   macro

        out     PIC1_PORT1, al          ; set master 8259 mask
        shr     eax, 8                  ; shift slave 8259 mask to al
        out     PIC2_PORT1, al          ; set slave 8259 mask
endm

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\config\addfiltr.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    addfiltr.c

Abstract:

    Functions for adding/removing filter drivers
    on a given device stack

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Notes:

    - The filter is not checked for validity before it is added to the
        driver stack; if an invalid filter is added, the device may
        no longer be accessible.
    - All code works irrespective of character set (ANSI, Unicode, ...)
        //CPRINCE IS ^^^^^^ THIS STILL VALID ???
    - Some functions based on code by Benjamin Strautin (t-bensta)

Revision History:

--*/

#include "addfiltr.h"


#include <stdio.h>
#include <malloc.h>


// for all of the _t stuff (to allow compiling for both Unicode/Ansi)
#include <tchar.h>


#include "MultiSz.h"



#if DBG
#include <assert.h>
#define ASSERT(condition) assert(condition)
#else
#define ASSERT(condition)
#endif




//
// To add/remove filter drivers:
// -----------------------------
// 1. Use SetupDiGetClassDevs to get a list of devices
// 2. Use SetupDiEnumDeviceInfo to enumerate the items in that list and
//      obtain a SP_DEVINFO_DATA
// 3. Use SetupDiGetDeviceRegistryProperty to get a list of filter drivers
//      installed on some device
// 4. Add/remove items in this list of filter drivers
// 5. Use SetupDiSetDeviceRegistryProperty to put the (new) list back in place
//
//
// To restart a device:
// --------------------
// 1. Use SetupDiCallClassInstaller with DIF_PROPERTYCHANGE and DICS_STOP to
//      stop the device
// 2. Use SetupDiCallClassInstaller with DIF_PROPERTYCHANGE and DICS_START to
//      restart the device
//




/*
 * Returns a buffer containing the list of upper filters for the device.
 *
 * NOTE(S):  - The buffer must be freed by the caller.
 *           - If an error occurs, no buffer will be allocated, and NULL
 *             will be returned.
 * 
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
LPTSTR
GetUpperFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    )
{
    DWORD  regDataType;
    LPTSTR buffer = (LPTSTR) GetDeviceRegistryProperty( DeviceInfoSet,
                                                        DeviceInfoData,
                                                        SPDRP_UPPERFILTERS,
                                                        REG_MULTI_SZ,
                                                        &regDataType );

    return buffer;
}




/*
 * Adds the given filter driver to the list of upper filter drivers for the
 * device.
 *
 * After the call, the device must be restarted in order for the new setting to
 * take effect. This can be accomplished with a call to RestartDevice(), or by
 * rebooting the machine.
 *
 * Returns TRUE if successful, FALSE otherwise
 *
 * NOTE: The filter is prepended to the list of drivers, which will put it at
 * the bottom of the stack of upper filters
 *
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Filter         - the filter to add
 */
BOOLEAN
AddUpperFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter
    )
{
    size_t length = 0; // character length
    size_t size   = 0; // buffer size
    LPTSTR buffer = NULL;
    
    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    buffer = GetUpperFilters( DeviceInfoSet, DeviceInfoData );

    if( NULL == buffer )
    {
        // Some error occurred while trying to read the 'UpperFilters'
        // registry value.  So maybe no such value exists yet, or it's
        // invalid, or some other error occurred.
        //
        // In any case, let's just try to install a new registry value for
        // 'UpperFilters'

        // make room for the string, string null terminator, and multisz null
        // terminator
        length = _tcslen(Filter) + 2;
        size   = length*sizeof(_TCHAR);
        buffer = malloc( size );
        if( NULL == buffer )
        {
            // Error: Unable to allocate memory
            return FALSE ;
        }

        // copy the string into the new buffer
        _tcscpy(buffer, Filter);
        // make the buffer a properly formed multisz
        buffer[length-1]=_T('\0');
    }
    else
    {
        // add the driver to the driver list
        PrependSzToMultiSz(Filter, &buffer);
    }

    length = MultiSzLength(buffer);
    size   = length*sizeof(_TCHAR);

    // set the new list of filters in place
    if( !SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                           DeviceInfoData,
                                           SPDRP_UPPERFILTERS,
                                           (PBYTE)buffer,
                                           size )
        )
    {
        // Error: couldn't set device registry property
        free( buffer );
        return FALSE;
    }

    // no need for buffer anymore
    free( buffer );

    return TRUE;
}


/*
 * Removes all instances of the given filter driver from the list of upper
 * filter drivers for the device.
 *
 * After the call, the device must be restarted in order for the new setting to
 * take effect. This can be accomplished with a call to RestartDevice(), or by
 * rebooting the machine.
 *
 * Returns TRUE if successful, FALSE otherwise.
 *
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Filter - the filter to remove
 */
BOOLEAN
RemoveUpperFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter
    )
{
    size_t length = 0; // character length
    size_t size   = 0; // buffer size
    LPTSTR buffer;
    BOOL   success = FALSE;

    ASSERT(DeviceInfoData != NULL);
    ASSERT(Filter != NULL);

    buffer = GetUpperFilters( DeviceInfoSet, DeviceInfoData );

    if( NULL == buffer )
    {
        // if there is no such value in the registry, then there are no upper
        // filter drivers loaded, and we are done
        return TRUE;
    }
    else
    {
        // remove all instances of filter from driver list
        MultiSzSearchAndDeleteCaseInsensitive( Filter, buffer, &length );
    }

    length = MultiSzLength(buffer);

    ASSERT ( length > 0 );

    if( 1 == length )
    {
        // if the length of the list is 1, the return value from
        // MultiSzLength() was just accounting for the trailing '\0', so we can
        // delete the registry key, by setting it to NULL.
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_UPPERFILTERS,
                                                    NULL,
                                                    0 );
    }
    else
    {
        // set the new list of drivers into the registry
        size = length*sizeof(_TCHAR);
        success = SetupDiSetDeviceRegistryProperty( DeviceInfoSet,
                                                    DeviceInfoData,
                                                    SPDRP_UPPERFILTERS,
                                                    (PBYTE)buffer,
                                                    size );
    }

    // no need for buffer anymore
    free( buffer );

    if( !success )
    {
        // Error: couldn't set device registry property
        return FALSE;
    }

    return TRUE;
}




/*
 * A wrapper around SetupDiGetDeviceRegistryProperty, so that we don't have to
 * deal with memory allocation anywhere else, and so that we don't have to
 * duplicate a lot of error-checking code.
 *
 * If successful, returns pointer to newly allocated buffer containing the
 * requested registry property.  Otherwise returns NULL.
 *
 * NOTE: It is the caller's responsibility to free the buffer allocated here.
 *
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 *   Property       - Which property to get (SPDRP_XXX)
 *   ExpectedRegDataType - The type of registry property the caller is
 *                         expecting (or REG_NONE if don't care)
 *   pPropertyRegDataType - The type of registry property actually retrieved
 */
PBYTE
GetDeviceRegistryProperty(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN DWORD Property,
    IN DWORD    ExpectedRegDataType,
    OUT PDWORD pPropertyRegDataType
    )
{
    DWORD length = 0;
    PBYTE buffer = NULL;

    //
    // Get the required length of the buffer
    //
    if( SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                          DeviceInfoData,
                                          Property,
                                          NULL,   // registry data type
                                          NULL,   // buffer
                                          0,      // buffer size
                                          &length // [OUT] required size
        ) )
    {
        // We should not be successful at this point (since we passed in a
        // zero-length buffer), so this call succeeding is an error condition
        return NULL;
    }


    if( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        // This is an error condition we didn't expect.  Something must have
        // gone wrong when trying to read the desired device property, so...
        //
        // NOTE: caller can use GetLastError() for more info
        return NULL;
    }


    // 
    // We didn't have a buffer before (hence the INSUFFICIENT_BUFFER error).
    // Now that we know required size, let's allocate a buffer and try again.
    //
    buffer = malloc( length );
    if( NULL == buffer )
    {
/* CPRINCE: SHOULD WE INDICATE EXACTLY _WHAT_ ERROR WAS VIA A RETURN CODE ??? (IE INFO THAT'S MORE USEFUL) */
        // Error: not enough memory
        return NULL;
    }
    if( !SetupDiGetDeviceRegistryProperty( DeviceInfoSet,
                                           DeviceInfoData,
                                           Property,
                                           pPropertyRegDataType,
                                           buffer,
                                           length, // buffer size
                                           NULL
        ) )
    {
        // Oops, error when trying to read the device property
        free( buffer );
        return NULL;
    }


    //
    // Successfully retrieved the device registry property.  Let's make
    // sure it has the right type.
    //
    if( ExpectedRegDataType != REG_NONE
        &&  ExpectedRegDataType != (*pPropertyRegDataType)  )
    {
        // Registry property has a type different from what caller expected.
        // So an error has occurred somewhere.
        free( buffer );
        return NULL;
    }


    //
    // OK, got device registry property.  Return ptr to buffer containing it.
    //
    return buffer;
}


/*
 * Restarts the given device.
 *
 * Returns TRUE if the device is successfully restarted, or FALSE if the
 *   device cannot be restarted or an error occurs.
 *
 * Parameters:
 *   DeviceInfoSet  - The device information set which contains DeviceInfoData
 *   DeviceInfoData - Information needed to deal with the given device
 */
BOOLEAN
RestartDevice(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    )
{
    SP_PROPCHANGE_PARAMS params;
    SP_DEVINSTALL_PARAMS installParams;

    // For future compatibility; this will zero out the entire struct, rather
    // than just the fields which exist now
    memset(&params, 0, sizeof(SP_PROPCHANGE_PARAMS));

    // Initialize the SP_CLASSINSTALL_HEADER struct at the beginning of the
    // SP_PROPCHANGE_PARAMS struct, so that SetupDiSetClassInstallParams will
    // work
    params.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    params.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;

    // Initialize SP_PROPCHANGE_PARAMS such that the device will be stopped.
    params.StateChange = DICS_STOP;
    params.Scope       = DICS_FLAG_CONFIGSPECIFIC;
    params.HwProfile   = 0; // current profile

    // Prepare for the call to SetupDiCallClassInstaller (to stop the device)
    if( !SetupDiSetClassInstallParams( DeviceInfoSet,
                                       DeviceInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &params,
                                       sizeof(SP_PROPCHANGE_PARAMS)
        ) )
    {
        // Error: couldn't set install params
        return FALSE;
    }

    // Stop the device
    if( !SetupDiCallClassInstaller( DIF_PROPERTYCHANGE,
                                    DeviceInfoSet,
                                    DeviceInfoData )
        )
    {
        // Error: call to class installer (for STOP) failed
        return FALSE;
    }

    // Restarting the device
    params.StateChange = DICS_START;

    // Prepare for the call to SetupDiCallClassInstaller (to restart the device)
    if( !SetupDiSetClassInstallParams( DeviceInfoSet,
                                       DeviceInfoData,
                                       (PSP_CLASSINSTALL_HEADER) &params,
                                       sizeof(SP_PROPCHANGE_PARAMS)
        ) )
    {
        // Error: couldn't set install params
        return FALSE;
    }

    // Restart the device
    if( !SetupDiCallClassInstaller( DIF_PROPERTYCHANGE,
                                    DeviceInfoSet,
                                    DeviceInfoData )
        )
    {
        // Error: call to class installer (for START) failed
        return FALSE;
    }

    installParams.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    // Same as above, the call will succeed, but we still need to check status
    if( !SetupDiGetDeviceInstallParams( DeviceInfoSet,
                                        DeviceInfoData,
                                        &installParams )
        )
    {
        // Error: couldn't get the device install params
        return FALSE;
    }

    // See if the machine needs to be rebooted
    if( installParams.Flags & DI_NEEDREBOOT )
    {
        return FALSE;
    }

    // If we get this far, then the device has been stopped and restarted
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\config\addfiltr.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    addfiltr.h

Abstract:

    Functions for adding/removing filter drivers
    on a given device stack

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Notes:

    - The filter is not checked for validity before it is added to the
        driver stack; if an invalid filter is added, the device may
        no longer be accessible.
    - All code works irrespective of character set (ANSI, Unicode, ...)
        //CPRINCE IS ^^^^^^ THIS STILL VALID ???
    - Some functions based on code by Benjamin Strautin (t-bensta)

Revision History:

--*/


#ifndef __ADDFILTR_H__
#define __ADDFILTR_H__

#include <windows.h>

// the SetupDiXXX api (from the DDK)
#include <setupapi.h>



//
// FUNCTION PROTOTYPES
//

// ------ Upper-Filter Fuctions ------
LPTSTR
GetUpperFilters(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData
    );

BOOLEAN
AddUpperFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter
    );

BOOLEAN
RemoveUpperFilterDriver(
    IN HDEVINFO DeviceInfoSet,
    IN PSP_DEVINFO_DATA DeviceInfoData,
    IN LPTSTR Filter
    );



// ------ Other Fuctions ------
PBYTE
GetDeviceRegistryProperty(
    IN  HDEVINFO DeviceInfoSet,
    IN  PSP_DEVINFO_DATA DeviceInfoData,
    IN  DWORD Property,
    IN  DWORD   ExpectedRegDataType,
    OUT PDWORD pPropertyRegDataType
    );

BOOLEAN
RestartDevice(
    IN HDEVINFO DeviceInfoSet,
    IN OUT PSP_DEVINFO_DATA DeviceInfoData
    );



#endif // __ADDFILTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\inc\pcmp.inc ===
;/*
;++
;
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
;
;   Module Name:
;
;       pcmp.inc
;
;   Abstract:
;
;       include file for PC+MP system.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;       Ron Mosgrove and Rajesh Shah (Intel) 30-July-1993
;
;--
;

if 0        ; Begin C only code         */

#pragma pack(1)

//
//  IMCR (Interrupt Mode Control Register) access definitions
//
#define ImcrDisableApic         0x00
#define ImcrEnableApic          0x01
#define ImcrRegPortAddr         0x22
#if defined(NEC_98)
#define ImcrDataPortAddr        0x700
#else  // defined(NEC_98)
#define ImcrDataPortAddr        0x23
#endif // defined(NEC_98)
#define ImcrPort                0x70

// Physical location where the Extended BIOS Data Area segment adress is stored
#define EBDA_SEGMENT_PTR    0x40e
#define BASE_MEM_PTR        0x413

//
//  The PC+MP configuration table Possible Entry Types
//
#define ENTRY_PROCESSOR     0
#define ENTRY_BUS           1
#define ENTRY_IOAPIC        2
#define ENTRY_INTI          3
#define ENTRY_LINTI         4

#define HEADER_SIZE     0x2c

// Number of default configurations for PC+MP version 1.1 
#define NUM_DEFAULT_CONFIGS  7

//
//  Processor Entry definitions
//

typedef struct _CPUIDENTIFIER {
    ULONG Stepping : 4;
    ULONG Model : 4;
    ULONG Family : 4;
    ULONG Reserved : 20;
} CPUIDENTIFIER, *PCPUIDENTIFIER;

//
// Bits used in the CpuFlags field of the Processor entry
//
#define CPU_DISABLED        0x0   // 1 Bit  - CPU Disabled
#define CPU_ENABLED         0x1   // 1 Bit  - CPU Enabled
#define BSP_CPU             0x2   // Bit #2 - CPU is BSP

//
//  APIC Versions used by PC+MP systems - this is used in the
//  Processor entries and the IoApic Entries
//
#define APIC_INTEGRATED     0x10  // 8 Bits-Apic Version Register
#define APIC_82489DX        0x0   // 8 Bits-Apic Version Register

typedef struct _PcMpProcessorEntry {
    UCHAR EntryType;
    UCHAR LocalApicId;
    UCHAR LocalApicVersion;
    UCHAR CpuFlags;
    CPUIDENTIFIER CpuIdentification;      // CPU Identification
    ULONG FeatureFlags;
    UCHAR Reserved[8];
} PCMPPROCESSOR , *PPCMPPROCESSOR;

//
//  Bus Entry definitions
//

typedef struct _PcMpBusEntry {
    UCHAR EntryType;
    UCHAR BusId;
    CHAR BusType[6];
} PCMPBUS, *PPCMPBUS;

//
//  Io Apic Entry definitions
//
//  Valid IoApicFlag values
//
#define IO_APIC_ENABLED         0x1
#define IO_APIC_DISABLED        0x0

//
// Default value for Io Apic ID.
//
#define IOUNIT_APIC_ID          0xE

typedef struct _PcMpIoApicEntry  {
    UCHAR EntryType;
    UCHAR IoApicId;
    UCHAR IoApicVersion;
    UCHAR IoApicFlag;
    PVOID IoApicAddress;
} PCMPIOAPIC, *PPCMPIOAPIC;

//
//  Bits that define the Interrupt logically
//
typedef struct _PolarityAndLevel {
    USHORT Polarity : 2;
    USHORT Level : 2;
    USHORT Reserved : 12;
} POLARITYANDLEVEL, *PPOLARITYANDLEVEL;

typedef struct _PcMpApicIntiEntry {
    UCHAR EntryType;
    UCHAR IntType;
    POLARITYANDLEVEL Signal;
    UCHAR SourceBusId;
    UCHAR SourceBusIrq;
    UCHAR IoApicId;
    UCHAR IoApicInti;
} PCMPINTI, *PPCMPINTI;

//
//  Local Apic Interrupt Entry definitions
//
typedef struct _PcMpLintiEntry  {
    UCHAR EntryType;
    UCHAR IntType;
    POLARITYANDLEVEL Signal;
    UCHAR SourceBusId;
    UCHAR SourceBusIrq;
    UCHAR DestLocalApicId;
    UCHAR DestLocalApicInti;
} PCMPLINTI, *PPCMPLINTI;

//
//  The PC+MP table definition
//    

struct PcMpTable {
    //
    // PC+MP config table HEADER part (HEADER_SIZE bytes long)
    //

    ULONG Signature;        // Must contain "P","C","M","P"
    USHORT TableLength;     // Length including the header
    UCHAR Revision;         // Rev 1.0 == 1
    UCHAR Checksum;         // Entire table including checksum byte
    CHAR OemId[8];          // OEM defined
    CHAR OemProductId[12];  // OEM defined
    PVOID OemTablePtr;      // OEM specific data
    USHORT OemTableSize;    // length in bytes of the OEM table
    USHORT NumOfEntries;    // Number of entries in the data portion    
    PVOID LocalApicAddress; // Physical address of Local units
    USHORT ExtTableLength;  // Extension table size
    UCHAR ExtTableChecksum; // Complete checksum including extension table
    UCHAR Reserved;         // Not Used
};

//
//  PC+MP Signature used to verify the PC+MP table
//  as valid
//
//          "P"=50H,"C"=43H,"M"=4dH,"P"=50H
//
#define PCMP_SIGNATURE      0x504d4350

//
//  PC+MP Signature used to identify the floating pointer
//  structure (in extended BIOS data segment) that contains
//  a pointer to the PC+MP table.
//
//          "_"=5fH, "M"=4dH, "P"=50H, "_"=5fH
//
#define MP_PTR_SIGNATURE    0x5f504d5f

//
//  This is the floating pointer structure 
//

// For PC+MP version 1.0
struct PcMpTableLocator  {
    ULONG MpPtrSignature;   // Must be "_MP_" (0x5f504d5f)
    PUCHAR TablePtr;        // ptr to the PC+MP Table
    UCHAR MpTableLength;    // Floating pointer structure length
    UCHAR TableRevision;    // Rev 1.0 == 1
    UCHAR TableChecksum;    // Checksum of PcMpTableLocator
    UCHAR Pad;
    ULONG Reserved;
};


struct FloatPtrStruct  {
    ULONG MpPtrSignature;   // Must be "_MP_" (0x5f504d5f)
    PUCHAR TablePtr;        // ptr to the PC+MP Table
    UCHAR MpTableLength;    // Floating pointer structure length
    UCHAR TableRevision;    // Rev 1.0 == 1
    UCHAR TableChecksum;    // Checksum of PcMpTableLocator
    UCHAR MpFeatureInfoByte1;   // MP feature info. byte 1
    UCHAR MpFeatureInfoByte2;   // MP feature info. byte 2
    UCHAR Pad;
    USHORT Reserved;
};


//
// Extension table definitions
//

#define EXTTYPE_BUS_ADDRESS_MAP           128
#define EXTTYPE_BUS_HIERARCHY             129
#define EXTTYPE_BUS_COMPATIBLE_MAP        130
#define EXTTYPE_PERSISTENT_STORE          131

typedef struct {
    UCHAR   Type;
    UCHAR   Length;
    union {
        struct {
            UCHAR           BusId;
            UCHAR           Type;
            LONGLONG        Base;
            LONGLONG        Length;
        } AddressMap;

        struct {
            UCHAR           BusId;
            UCHAR           SubtractiveDecode:1;
            UCHAR           ParentBusId;
        } BusHierarchy;

        struct {
            LONGLONG        Address;
            LONGLONG        Length;
        } PersistentStore;

        struct {
            UCHAR           BusId;
            UCHAR           Modifier:1;
            UCHAR           Reserved:7;
            ULONG           List;
        } CompatibleMap;

    } u;
} MPS_EXTENTRY, *PMPS_EXTENTRY;


#define MPS_ADDRESS_MAP_IO                  0
#define MPS_ADDRESS_MAP_MEMORY              1
#define MPS_ADDRESS_MAP_PREFETCH_MEMORY     2
#define MPS_ADDRESS_MAP_UNDEFINED           9

//
//  The System configuration table as used by a PC_MP system
//
//
// The offset is relative to the BIOS starting at f0000H
//
#define PTR_OFFSET          0x0000e6f5
#define BIOS_BASE           0x000f0000

#define PCMP_IMPLEMENTED    0x01    // In MpFeatureInfoByte1
#define PCMP_CONFIG_MASK    0x0e    // In MpFeatureInfoByte1
#define IMCR_MASK           0x80    // In MpFeatureInfoByte2
#define MULT_CLOCKS_MASK    0x40    // In MpFeatureInfoByte2

struct SystemConfigTable {
    UCHAR Reserved[PTR_OFFSET];
    USHORT NumOfBytes;      // Table can be variable length.
    UCHAR ModelType;        // AT=0xfc, unknown board=0xff
    UCHAR SubModelType;
    UCHAR BIOSRevision;     // First release = 0x0
    UCHAR FeatureInfoByte[3];   // Standard AT features
    UCHAR MpFeatureInfoByte1;   // MP feature info. byte 1
    UCHAR MpFeatureInfoByte2;   // MP feature info. byte 2
} ;

#pragma pack()

NTSTATUS
HalpPci2MpsBusNumber(
    IN UCHAR PciBusNumber,
    OUT UCHAR *MpsBusNumber
    );

PBUS_HANDLER
HalpFindIdeBus(
    IN  ULONG   Vector
    );

BOOLEAN
HalpInterruptsDescribedByMpsTable(
    IN UCHAR MpsBusNumber
    );

NTSTATUS
HalpMpsGetParentBus(
    IN  UCHAR MpsBus,
    OUT UCHAR *ParentMpsBus
    );

BOOLEAN
HalpMpsBusIsRootBus(
    IN  UCHAR MpsBus
    );

VOID
HalpMPSPCIChildren (
    VOID
    );

/*
endif

;
;  IMCR (Interrupt Mode Control Register) access definitions
;

ImcrDisableApic     equ     00H
ImcrEnableApic      equ     01H
ImcrRegPortAddr     equ     22H
ifdef NEC_98
ImcrDataPortAddr    equ     700H
else  ; NEC_98
ImcrDataPortAddr    equ     23H
endif ; NEC_98
ImcrPort        equ     70H

;
;   MP Configuration Table - Built by an MP BIOS for OS Support

;
;  PC+MP Signature used to identify the floating pointer
;  structure (in extended BIOS data segment) that contains
;  a pointer to the PC+MP table.
;
;          "_"=5fH, "M"=4dH, "P"=50H, "_"=5fH
;
MP_PTR_SIGNATURE    equ 5f504d5fH

;
;  PC+MP Signature used to verify the PC+MP table
;  as valid
;
;          "P"=50H,"C"=43H,"M"=4dH,"P"=50H
;
PCMP_SIGNATURE      equ 504d4350H

;
;  The PC+MP configuration table Possible Entry Types
;
ENTRY_PROCESSOR     equ 0H
ENTRY_BUS           equ 1H
ENTRY_IOAPIC        equ 2H
ENTRY_INTI          equ 3H
ENTRY_LINTI         equ 4H

;
; Bits used in the CpuFlags field of the Processor entry
;
CPU_ENABLED         equ     01H      
CPU_DISABLED        equ     00H      
BSP_CPU             equ 02H  

;
;  APIC Versions used by PC+MP systems - this is used in the
;  Processor entries and the IoApic Entries
;
APIC_INTEGRATED     equ     10H
APIC_82489DX        equ     00H      


;
;  Macros used in table definitions
;
HEADER_SIZE             equ 2CH

; Number of default configurations for PC+MP version 1.1 
NUM_DEFAULT_CONFIGS equ 7

;
;  Io Apic Entry definitions
;
IO_APIC_ENABLED     equ     01H
IO_APIC_DISABLED    equ     00H

;
; Default value for Io Apic ID.
;
IOUNIT_APIC_ID      equ     0EH     ;   ID of the IO Unit

PcMpTable struc
    ; HEADER portion of the PC+MP config table
    ;
    Signature           db       4 dup (0)  ; Must be "P","C","M","P"
    TableLength     dw   0     ; Length in bytes of table
    Revision        db   0     ; Table revision #
    Checksum        db   0     ; Table checksum
    OemId       db   8 dup (0) ; OemId string
    OemProductId    db  12 dup (0) ; Oem product id
    OemTablePtr     dd   0     ; Ptr to OEM table
    OemTableSize    dw   0     ; Size of OEM table
    NumOfEntries    dw   0     ; # of entries in table
    LocalApicAddress    dd      0       ; Physical address of Local units
    ExtTableLength      dw      0       ; Extension table size
    ExtTableChecksum    db      0       ; Complete checksum including extension table
    Reserved            db      0       ; Not Used

PcMpTable ends

;
;  Bios Constants. The offset is relative to the BIOS starting at 
;  f0000H.
;

PTR_OFFSET          equ     0e6f5H
BIOS_BASE           equ     0f0000H
PCMP_IMPLEMENTED    equ     01H
PCMP_CONFIG_MASK    equ     0eH
IMCR_MASK           equ     80H
MULT_CLOCKS_MASK    equ     40H

PcMpTableLocator struc
    MpPtrSignature  dd  0   ; Must be "_MP_" (0x5f504d5f)
    TablePtr        dd  0
    MpTableLength   db  0
    TableRevision   db  0
    TableChecksum   db  0
    Pad         db  0
    Reserved        dd  0
PcMpTableLocator ends

SystemConfigTable struc

                    db  PTR_OFFSET dup (0) ;Skip to 0e6f5
NumOfBytes          db  2       ; Table Length
ModelType       db  0       ; AT=0fc, unknown=0ff
SubModelType        db  0
BIOSRevision        db  0       ; 00=first release
FeatureInfoByte     db  3 dup (0)   ; AT features
MpFeatureInfoByte1  db  0       ; MP feature info. byte 1
MpFeatureInfoByte2  db  0       ; MP feature info. byte 2

SystemConfigTable ends

; */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\config\resource.h ===
#ifndef __RESOURCE_H__
#define __RESOURCE_H__

#define IDC_STATIC                      (-1)

#define IDD_MAIN                        101
#define IDD_AFFINITY                    102

#define IDL_DEVICES                     1001
#define IDS_LOCATIONINFO                1002
#define IDS_DEVOBJNAME                  1003
#define IDL_UPPERFILTERS                1004
#define IDB_ADDFILTER                   1005
#define IDB_REMFILTER                   1006
#define IDC_DONTRESTART                 1007
#define IDB_SETAFFINITYMASK             1008
#define IDB_DELETEAFFINITYMASK          1009
#define IDS_CURRAFFINITYMASK            1010
#define IDB_DONE                        1011

#define IDC_CPU0                        2000
#define IDC_CPU1                        2001
#define IDC_CPU2                        2002
#define IDC_CPU3                        2003
#define IDC_CPU4                        2004
#define IDC_CPU5                        2005
#define IDC_CPU6                        2006
#define IDC_CPU7                        2007
#define IDC_CPU8                        2008
#define IDC_CPU9                        2009
#define IDC_CPU10                       2010
#define IDC_CPU11                       2011
#define IDC_CPU12                       2012
#define IDC_CPU13                       2013
#define IDC_CPU14                       2014
#define IDC_CPU15                       2015
#define IDC_CPU16                       2016
#define IDC_CPU17                       2017
#define IDC_CPU18                       2018
#define IDC_CPU19                       2019
#define IDC_CPU20                       2020
#define IDC_CPU21                       2021
#define IDC_CPU22                       2022
#define IDC_CPU23                       2023
#define IDC_CPU24                       2024
#define IDC_CPU25                       2025
#define IDC_CPU26                       2026
#define IDC_CPU27                       2027
#define IDC_CPU28                       2028
#define IDC_CPU29                       2029
#define IDC_CPU30                       2030
#define IDC_CPU31                       2031

#endif // __RESOURCE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\config\multisz.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    multisz.h

Abstract:

    Functions for manipulating MultiSz strings

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Notes:

    - Some functions based on code by Benjamin Strautin (t-bensta)

Revision History:

--*/


#ifndef __MULTISZ_H__
#define __MULTISZ_H__



#include <windows.h>



//
// FUNCTION PROTOTYPES
//

BOOLEAN
PrependSzToMultiSz(
    IN     LPCTSTR  SzToPrepend,
    IN OUT LPTSTR  *MultiSz
    );

size_t
MultiSzLength(
    IN LPCTSTR MultiSz
    );

size_t
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPCTSTR  szFindThis,
    IN  LPTSTR   mszFindWithin,
    OUT size_t  *NewStringLength
    );


BOOL
MultiSzSearch( IN LPCTSTR szFindThis,
               IN LPCTSTR mszFindWithin,
               IN BOOL    fCaseSensitive,
               OUT LPCTSTR * ppszMatch OPTIONAL
             );


#endif // __MULTISZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\config\intfiltr.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    intfiltr.c

Abstract:

    Utility for installing/uninstalling the Interrupt-Affinity Filter
    (IntFiltr) on a given device stack, and for configuring IntFiltr
    settings.

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Revision History:

--*/


#include <windows.h>

#include <setupapi.h>

#include <tchar.h>
#include <stdio.h>  // for certain sprintf functions
#include <stdlib.h>  // for malloc/free

#include "resource.h"

#include "addfiltr.h"
#include "MultiSz.h"



//CPRINCE: MIGHT BE GOOD TO PUT THE FOLLOWING GENERAL THINGS IN A "MAIN.H" FILE ???

#if DBG
#include <assert.h>
#define ASSERT(condition) assert(condition)
#else
#define ASSERT(condition)
#endif

#define  ARRAYSIZE(x)    ( sizeof((x)) / sizeof((x)[0]) )




//
// Defines
//
#define MAX_PROCESSOR   32    // I don't like this, but hey, it's what they do in TaskMgr...

#define FILTER_SERVICE_NAME    "InterruptAffinityFilter" /*CPRINCE: NEED TO UNICODE-IZE THIS ? (AND SHOULD WE USE #define FOR CONST STRING ?) */
#define FILTER_REGISTRY_VALUE  "IntFiltr_AffinityMask"   /*CPRINCE: NEED TO UNICODE-IZE THIS ? (AND SHOULD WE USE #define FOR CONST STRING ?) */

//
// SHARED/GLOBAL VARIABLES
//
HINSTANCE g_hInstance;
int       g_nDialogItems;
HCURSOR   g_hCursors[2];
DWORD     g_dwActiveProcessorMask;  // mask of CPUs in the system


//
// Function Prototypes
//
INT_PTR CALLBACK DlgProc_FilterConfig( HWND hwndDlg,
                                    UINT msg,
                                    WPARAM wParam,
                                    LPARAM lParam );
INT_PTR CALLBACK DlgProc_Affinity( HWND hwndDlg,
                                UINT uMsg,
                                WPARAM wParam,
                                LPARAM lParam );

void UI_UpdateAffinityMaskString( HWND hwndParentDlg,
                                  HDEVINFO hDevInfo,
                                  PSP_DEVINFO_DATA pDevInfoData );
void UI_UpdateUpperFilterList( HWND hwndParentDlg,
                               HDEVINFO hDevInfo,
                               PSP_DEVINFO_DATA pDevInfoData );
void UI_UpdateDevObjString( HWND hwndMainDlg,
                            HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData );
void UI_UpdateLocationInfoString( HWND hwndMainDlg,
                                  HDEVINFO hDevInfo,
                                  PSP_DEVINFO_DATA pDevInfoData );
void UI_PromptForDeviceRestart( HWND hwndMainDlg,
                                HDEVINFO hDevInfo,
                                PSP_DEVINFO_DATA pDevInfoData );
void UI_PromptForInstallFilterOnDevice( HWND hwndMainDlg,
                                        HDEVINFO hDevInfo,
                                        PSP_DEVINFO_DATA pDevInfoData );

void RestartDevice_WithUI( HWND hwndParentDlg,
                           HDEVINFO hDevInfo,
                           PSP_DEVINFO_DATA pDevInfoData );

BOOL SetFilterAffinityMask( HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData,
                            DWORD affinityMask );
BOOL GetFilterAffinityMask( HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData,
                            DWORD* pAffinityMask );
BOOL DeleteFilterAffinityMask( HDEVINFO hDevInfo,
                               PSP_DEVINFO_DATA pDevInfoData );


void AddRemoveFilterOnDevice( HWND hwndMainDlg,
                              HDEVINFO hDevInfo,
                              PSP_DEVINFO_DATA pDevInfoData,
                              BOOL fAddingFilter );


BOOL FilterIsInstalledOnDevice( HDEVINFO hDevInfo,
                                PSP_DEVINFO_DATA pDevInfoData );



void ExitProgram( HWND hwndDlg, HDEVINFO * phDevInfo );


// Misc Helper Funcs
LPARAM GetItemDataCurrentSelection( HWND hwndListBox );
void MessageBox_FromErrorCode( LONG systemErrorCode );





//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int nCmdShow )
{
    // Initialize various things
    g_hInstance = hInstance;

    g_hCursors[0] = LoadCursor( 0, IDC_ARROW );
    g_hCursors[1] = LoadCursor( 0, IDC_WAIT );

    {
        SYSTEM_INFO sysInfo;

        GetSystemInfo( &sysInfo );
        g_dwActiveProcessorMask = (DWORD)sysInfo.dwActiveProcessorMask;
    }


    // Create dialog box (everything is handled through it)
    DialogBox( g_hInstance,
               MAKEINTRESOURCE(IDD_MAIN),
               NULL,  // no parent window exists
               DlgProc_FilterConfig
             );


    // 'DialogBox()' func has returned, so user must be finished.
    return 0;
}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
INT_PTR CALLBACK DlgProc_FilterConfig( HWND hwndDlg, UINT msg,
                                    WPARAM wParam, LPARAM lParam )
{

    static HDEVINFO hDevInfo = INVALID_HANDLE_VALUE;
    HWND hwndDeviceList;
    PSP_DEVINFO_DATA pDevInfoData;  // needed by various cases here...



    hwndDeviceList = GetDlgItem( hwndDlg, IDL_DEVICES );


// CPRINCE:
//FOR all except WM_INITDIALOG, should return:
//  TRUE if we did process the message, -or-
//  FALSE if we didn't process the message
// END CPRINCE


    switch( msg )
    {
        case WM_CLOSE:
            ExitProgram( hwndDlg, &hDevInfo );
        return TRUE;


        case WM_INITDIALOG:
        {
/*CPRINCE: MAYBE MOVE THIS WHOLE CASE INTO A FUNC SOMEWHERE ELSE? */

            int              deviceIndex; // index for stepping thru devices
            SP_DEVINFO_DATA  devInfoData;


            //
            // Get a list of devices
            //
            hDevInfo = SetupDiGetClassDevs( NULL,
                                            NULL,
                                            NULL,
                                            DIGCF_ALLCLASSES
                                            | DIGCF_PRESENT
                                            | DIGCF_PROFILE
                                          );

            if( INVALID_HANDLE_VALUE == hDevInfo)
            {
                MessageBox( NULL,
                            "Unable to get a list of devices.",
                            "Error",
                            MB_OK | MB_ICONERROR  //CPRINCE: NEED TO MAKE ARGS HERE UNICODE-HAPPY ???
                          );
                SendMessage( hwndDlg, WM_CLOSE, 0, 0 );
                return TRUE;
            }


            //
            // Initialize the list box (i.e., fill it with entries)
            //

            // Step through the list of devices for this handle.
            // We use 'SetupDiEnumDeviceInfo' to get device info at each index; the
            // function returns FALSE when there is no device at the given index
            // (and thus no more devices).

            devInfoData.cbSize = sizeof(SP_DEVINFO_DATA);  // first, need init this

            g_nDialogItems = 0;

            for( deviceIndex=0 ;
                 SetupDiEnumDeviceInfo( hDevInfo, deviceIndex, &devInfoData ) ;
                 deviceIndex++
               )
            {
                LPTSTR  deviceName;
                DWORD   regDataType;


                deviceName =
                    (LPTSTR) GetDeviceRegistryProperty( hDevInfo,
                                                        &devInfoData,
                                                        SPDRP_DEVICEDESC,
                                                        REG_SZ,
                                                        &regDataType
                                                      );
                if( NULL == deviceName )
                {
                    // ERROR: device description doesn't exist, or we
                    // just can't access it
                    MessageBox( NULL,
                                "Error in accessing a device description.\n\n"
                                  "Device will not be added to list.",
                                "Error",
                                MB_OK | MB_ICONERROR
                              );
                }
                else
                {
                    void* pCopy_devInfoData;


                    // Add string to the list box
                    SendMessage( hwndDeviceList,
                                 LB_ADDSTRING,
                                 0,
                                 (LPARAM)deviceName
                               );


                    // Save a copy of the DeviceInfoData
                    pCopy_devInfoData = malloc( sizeof(SP_DEVINFO_DATA) );
                    if( NULL != pCopy_devInfoData )
                    {
                        memcpy( pCopy_devInfoData, &devInfoData, sizeof(SP_DEVINFO_DATA) );
                    }


                    // Associate a piece of data with that listbox entry
                    SendMessage( hwndDeviceList,
                                 LB_SETITEMDATA,
                                 g_nDialogItems,
                                 (LPARAM) pCopy_devInfoData   //CPRINCE CHECK: PROBLEM W/POINTERS AND 64-BIT MACHINES ???
                               );
    // CPRINCE NOTE! - STORING POINTERS IN LIST-BOX 'ITEMDATA' MIGHT NOT BE 64-BIT COMPATIBLE ?!?

                    g_nDialogItems++;

                    free( deviceName );


                }

            }


            //
            // Select one of the elements of the "Devices" listbox, and then
            // update elements of the UI that display info about that device.
            // (We do all this so that things displayed in the UI aren't
            // invalid when the user first starts our program.)
            //
            SendMessage( hwndDeviceList,
                         LB_SETCURSEL, 
                         0,  // index in list to select
                         0
                       );

            pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );
            if( NULL != pDevInfoData )
            {
                UI_UpdateAffinityMaskString( hwndDlg, hDevInfo, pDevInfoData );
                UI_UpdateUpperFilterList( hwndDlg, hDevInfo, pDevInfoData );
                UI_UpdateDevObjString( hwndDlg, hDevInfo, pDevInfoData );
                UI_UpdateLocationInfoString( hwndDlg, hDevInfo, pDevInfoData );
            }



            //
            // Set the focus to one of the dialog-box elements.
            // We return FALSE so the system doesn't also try to set
            // the default keyboard focus.
            //
            SetFocus( hwndDeviceList );
            return FALSE;
        }

        case WM_COMMAND:

            //
            // See what DialogBox item this WM_COMMAND affects...
            //
            switch( LOWORD(wParam) )
            {
                // command that affects the Devices listbox...
                case IDL_DEVICES:

                    switch( HIWORD(wParam) )
                    {
                        case LBN_SELCHANGE:  // curr. selection was changed
                        {
                            pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );

                            if( NULL == pDevInfoData )
                            {
                                // No DeviceInfoData available
                                SetDlgItemText( hwndDlg,
                                                IDS_DEVOBJNAME,
                                                "NO DEVICE INFO AVAILABLE"  // CPRINCE: NEED UNICODE-IZE THIS ???
                                             );
                            }
                            else
                            {
                                //
                                // Update various on-screen UI values
                                //
                                UI_UpdateAffinityMaskString( hwndDlg, hDevInfo, pDevInfoData );
                                UI_UpdateUpperFilterList( hwndDlg, hDevInfo, pDevInfoData );
                                UI_UpdateDevObjString( hwndDlg, hDevInfo, pDevInfoData );
                                UI_UpdateLocationInfoString( hwndDlg, hDevInfo, pDevInfoData );
                            }

                        }
                        return TRUE;

                      default:
                        return FALSE;
                    } //END: switch( HIWORD(wParam) )

                    break;


                case IDB_DONE:
                    // Exit
                    SendMessage( hwndDlg, WM_CLOSE, 0, 0 );
                return TRUE;


                case IDB_DELETEAFFINITYMASK:
                {
                    pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );
                    if( NULL == pDevInfoData )
                    {
//CPRINCE: PUT ERROR MSG HERE, TOO!
                        return TRUE;  // we're done handling this msg
                    }

                    // Delete the registry key
                    DeleteFilterAffinityMask( hDevInfo, pDevInfoData );
                    UI_UpdateAffinityMaskString( hwndDlg, hDevInfo, pDevInfoData );

                    //CPRINCE: Maybe should prompt user for restart-device
                    //  here (if filter installed), since change won't take
                    //  effect until device is restarted.
                    //
                    //  But shouldn't prompt user if affinity-mask wasn't
                    //  actually set when they tried to delete it, b/c then
                    //  there really hasn't been a change! (So would need
                    //  to know success/fail status of the
                    //  'DeleteFilterAffinityMask' call.)

                }
                return TRUE;


                case IDB_SETAFFINITYMASK:
                {
                    //
                    // User wants to set/change the interrupt-affinity-mask
                    // for currently selected device.
                    //
                    
                    DWORD dwAffinityMask;


                    pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );
                    if( NULL == pDevInfoData )
                    {
//CPRINCE: PUT ERROR MSG HERE, TOO!
                        return TRUE;  // we're done handling this msg
                    }


                    // Initially, set 'dwAffinityMask' to mask of the CPUs that
                    // are _currently_ selected in affinity-mask settings
                    if( ! GetFilterAffinityMask(hDevInfo, pDevInfoData, &dwAffinityMask) )
                    {
                        // Doesn't exist, or is invalid.  So by default,
                        // interrupt-filter assumes that _no_ interrupts are
                        // being masked off.
                        dwAffinityMask = -1;
                    }

                    // Pop up the dialog box
                    if( IDOK == DialogBoxParam( g_hInstance,
                                                MAKEINTRESOURCE(IDD_AFFINITY),
                                                hwndDlg,  // parent window
                                                DlgProc_Affinity,
                                                (LPARAM) &dwAffinityMask  ) )
                    {
                        // Now, 'dwAffinityMask' contains the interrupt affinity
                        // mask that user selected.  Make necessary changes.
                        SetFilterAffinityMask( hDevInfo, pDevInfoData, dwAffinityMask );
                        UI_UpdateAffinityMaskString( hwndDlg, hDevInfo, pDevInfoData );


                        // If the filter is installed on this device, then
                        // change to affinity mask won't take effect until
                        // device is restarted.  And if filter _isn't_
                        // installed, then changes won't matter, well, ever.
                        //
                        // So here we prompt user, to make sure they know
                        // what they're doing, and so they aren't confused
                        // when their changes they just made here don't
                        // have any immediate effect.

                        if( FilterIsInstalledOnDevice(hDevInfo,pDevInfoData) )
                        {
                            // Filter _is_ currently installed.
                            // See if the user wants to try to restart the
                            // device now (since changes to affinity mask
                            // won't take effect until device is restarted)
                            UI_PromptForDeviceRestart( hwndDlg, hDevInfo, pDevInfoData );
                        }
                        else
                        {
                            // Filter _isn't_ currently installed.
                            // See if the user wants to install the filter
                            // on the device now (since the interrupt-
                            // affinity mask is useless if the filter isn't
                            // installed on the device)
                            UI_PromptForInstallFilterOnDevice( hwndDlg, hDevInfo, pDevInfoData );
                        }
                    }
                    //ELSE:  User hit 'Cancel'. Don't need to make any changes.


                }
                return TRUE;


                case IDB_ADDFILTER:
                case IDB_REMFILTER:
                {
                    BOOL             fAddingFilter;

                    //
                    // Get selected device, so we know which
                    // device's filter settings to change.
                    //
                    pDevInfoData = (PSP_DEVINFO_DATA) GetItemDataCurrentSelection( hwndDeviceList );
                    if( NULL == pDevInfoData )
                    {
                        // No DeviceInfoData available
                        
;//CPRINCE: HANDLE THIS !
//
//CPRINCE: 'return' IF ERROR !?! (so we don't do the following stuff; maybe 'else' will work, too)
                    }


                    //
                    // Call function to add (or remove) the filter on selected device
                    //
                    if( IDB_ADDFILTER == LOWORD(wParam) )
                    {
                        // Add filter
                        AddRemoveFilterOnDevice( hwndDlg, hDevInfo, pDevInfoData, TRUE );
                        UI_UpdateUpperFilterList( hwndDlg, hDevInfo, pDevInfoData );
                    }
                    else
                    {
                        // see if filter is installed...
                        if( FilterIsInstalledOnDevice(hDevInfo, pDevInfoData) )
                        {
                            // Remove filter
                            AddRemoveFilterOnDevice( hwndDlg, hDevInfo, pDevInfoData, FALSE );
                            UI_UpdateUpperFilterList( hwndDlg, hDevInfo, pDevInfoData );
                        } else {
                            // filter isn't currently installed, so can't remove it!
                            MessageBox( hwndDlg,
                                        "Filter isn't currently installed, so can't remove it!",
                                        "Notice",
                                        MB_OK
                                      );
                        }
                        
                    }

                }
                return TRUE;


                default:
                  return FALSE;
            }

        break; //END: case WM_COMMAND


        default:
            return FALSE;

    } //END: switch( msg )


}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void UI_UpdateAffinityMaskString( HWND hwndParentDlg,
                                  HDEVINFO hDevInfo,
                                  PSP_DEVINFO_DATA pDevInfoData )
{
    DWORD dwAffinity;
    TCHAR szAffinityMask[64];  // BUGBUG (technically).  Fixed size, though this
                               // should be _way_ larger than we'll ever need.


    if( GetFilterAffinityMask(hDevInfo, pDevInfoData, &dwAffinity) )
    {
        // Got the affinity mask, so we'll display that
        _sntprintf( szAffinityMask, ARRAYSIZE(szAffinityMask), "0x%08X", dwAffinity );
    }
    else
    {
        // Didn't get an affinity mask; we'll display appropriate alternative
        _sntprintf( szAffinityMask, ARRAYSIZE(szAffinityMask), "N/A" );
    }

    szAffinityMask[ARRAYSIZE(szAffinityMask)-1] = _T('\0');  // be safe

    SetDlgItemText( hwndParentDlg,
                    IDS_CURRAFFINITYMASK,
                    szAffinityMask
                 );

}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void UI_UpdateUpperFilterList( HWND hwndParentDlg,
                               HDEVINFO hDevInfo,
                               PSP_DEVINFO_DATA pDevInfoData )
{
    HWND    hwndUpperFilterList;
    LPTSTR  pMultiSzUpperFilters;

    //
    // Get a handle to the upper-filter listbox
    //
    hwndUpperFilterList = GetDlgItem( hwndParentDlg, IDL_UPPERFILTERS );


    //
    // Empty the listbox...
    //
    while( LB_ERR != SendMessage(hwndUpperFilterList, LB_DELETESTRING, 0, 0) )
        NULL;


    //
    // Add new entries to the upper-filter listbox
    //
    pMultiSzUpperFilters = GetUpperFilters( hDevInfo, pDevInfoData );

    if( NULL != pMultiSzUpperFilters )
    {
        // Go through the MultiSz, adding each item to our listbox
        int    filterPosition = 0;
        LPTSTR pCurrString    = pMultiSzUpperFilters;


        while( *pCurrString != _T('\0') )
        {
            SendMessage( hwndUpperFilterList, LB_ADDSTRING, 0, (LPARAM)pCurrString );  // NOTE: item automatically gets added at end of list (unless list sorted)

            // increment pointer to next item in the MultiSz
            pCurrString += _tcslen(pCurrString) + 1;
            filterPosition++;
        }

        // Now free this buffer that was allocated for us
        free( pMultiSzUpperFilters );
    }





}


//--------------------------------------------------------------------------
//
//CPRINCE:  must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//--------------------------------------------------------------------------
void UI_UpdateDevObjString( HWND hwndMainDlg,
                            HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData )
{
    LPTSTR  szTemp;
    DWORD   regDataType;


    szTemp =
        (LPTSTR) GetDeviceRegistryProperty( hDevInfo,
                                            (PSP_DEVINFO_DATA) pDevInfoData,
                                            SPDRP_PHYSICAL_DEVICE_OBJECT_NAME,
                                            REG_SZ,
                                            &regDataType
                                          );
    if( NULL == szTemp )
    {
        // ERROR: registry property doesn't exist, or we can't access it
        SetDlgItemText( hwndMainDlg,
                        IDS_DEVOBJNAME,
                        "ERROR -- not accessible"  /* b/c this should be available for all devices */
                      );  //CPRINCE: DO WE NEED TO UNICODE-IZE THIS ???
    }
    else
    {
        // Use the data...
        SetDlgItemText( hwndMainDlg,
                        IDS_DEVOBJNAME,
                        szTemp
                      );

        // Free the buffer that was allocated for us
        free( szTemp );
    }

}


//--------------------------------------------------------------------------
//
//CPRINCE:  must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//--------------------------------------------------------------------------
void UI_UpdateLocationInfoString( HWND hwndMainDlg,
                                  HDEVINFO hDevInfo,
                                  PSP_DEVINFO_DATA pDevInfoData )
{
    LPTSTR  szTemp;
    DWORD   regDataType;


    szTemp =
        (LPTSTR) GetDeviceRegistryProperty( hDevInfo,
                                            (PSP_DEVINFO_DATA) pDevInfoData,
                                            SPDRP_LOCATION_INFORMATION,
                                            REG_SZ,
                                            &regDataType
                                          );
    if( NULL == szTemp )
    {
        // ERROR: registry property doesn't exist, or we can't access it
        SetDlgItemText( hwndMainDlg,
                        IDS_LOCATIONINFO,
                        "N/A"  /* b/c this might not be available for all devices */
                      );  //CPRINCE: DO WE NEED TO UNICODE-IZE THIS ???
    }
    else
    {
        // Use the data...
        SetDlgItemText( hwndMainDlg,
                        IDS_LOCATIONINFO,
                        szTemp
                      );

        // Free the buffer that was allocated for us
        free( szTemp );
    }

}


//--------------------------------------------------------------------------
//
//CPRINCE:  must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//--------------------------------------------------------------------------
void UI_PromptForDeviceRestart( HWND hwndMainDlg,
                                HDEVINFO hDevInfo,
                                PSP_DEVINFO_DATA pDevInfoData )
{

    if( BST_CHECKED == IsDlgButtonChecked(hwndMainDlg, IDC_DONTRESTART) )
    {
        // CheckBox indicates that user doesn't want to restart device.
        MessageBox( hwndMainDlg,
                    "Your changes will take effect the next time the device is restarted.",
                    "Notice",
                    MB_OK
                  );
    }
    else
    {
        int response;

        // Prompt the user to see if (s)he wants to restart the device
        // (in order for changes to take effect)
        response = MessageBox( hwndMainDlg,
                               "Your changes will not take effect until the device is restarted.\n\n"
                                 "Would you like to attempt to restart the device now?",
                               "Restart Device?",
                               MB_YESNO
                             );
        if( IDYES == response )
        {
            // Try to restart the device.
            RestartDevice_WithUI( hwndMainDlg, hDevInfo, pDevInfoData );
        }
        else if( IDNO == response )
        {
            // Don't try to restart the device.
            // (But let user know that changes won't take effect right away.)
            MessageBox( hwndMainDlg,
                        "Changes will take effect the next time you reboot.",
                        "Notice",
                        MB_OK );
        }
        else
        {
            // Some kind of error occurred.
            // Ignore it (what else can we do?)
        }
    }


}


//--------------------------------------------------------------------------
//CPRINCE NOTE: because of fact that we call UI_UpdateUpperFilterList(), we
//CPRINCE   must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//--------------------------------------------------------------------------
void UI_PromptForInstallFilterOnDevice( HWND hwndMainDlg,
                                        HDEVINFO hDevInfo,
                                        PSP_DEVINFO_DATA pDevInfoData )
{
    int response;

    // Prompt the user
    response = MessageBox( hwndMainDlg,
                           "Your changes will not have any effect unless the filter is "
                             "installed on this device.\n\n"
                             "Would you like to install the filter on this device now?",
                           "Install Filter On Device?",
                           MB_YESNO
                         );
    if( IDYES == response )
    {
        // Install the filter
        AddRemoveFilterOnDevice( hwndMainDlg, hDevInfo, pDevInfoData, TRUE );
        UI_UpdateUpperFilterList( hwndMainDlg, hDevInfo, pDevInfoData );
    }
    else if( IDNO == response )
    {
        // User said "No", so they probably know what they're doing.
        // So no response from us here.
    }
    else
    {
        // Some kind of error occurred.
        // Ignore it (what else can we do?)
    }

}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------
void RestartDevice_WithUI( HWND hwndParentDlg,
                           HDEVINFO hDevInfo,
                           PSP_DEVINFO_DATA pDevInfoData )
{
    BOOLEAN status;

    // Restart the device
    //   (but can take a while, so change cursor to
    //   hourglass while it's happening)
    SetCursor( g_hCursors[1] );  // hourglass
    status = RestartDevice( hDevInfo, pDevInfoData );
    SetCursor( g_hCursors[0] );  // back to normal

    if( status )
    {
        // Successfully restarted
        MessageBox( hwndParentDlg,
                    "Device successfully restarted.",
                    "Notice",
                    MB_OK );
//CPRINCE: NEED TO UNICODE-IZE ALL MessageBox CALLS, TOO ?!
//CPRINCE: SHOULD CHANGE hWndParent IN ALL MESSAGEBOX CALLS TO THE DIALOG BOX ???

    }
    else
    {
        // Couldn't restart; user must reboot for changes to take effect
        MessageBox( hwndParentDlg,
                    "Device could not be restarted.  Changes will take effect the next time you reboot.",
                    "Notice",
                    MB_OK );
    }

}




//--------------------------------------------------------------------------
//
// CPRINCE: THIS IS THE DIALOG-BOX CALLBACK FOR SETTING THE AFFINITY MASK
// <<NOTE: mostly ripped from TaskMgr>>
//
//--------------------------------------------------------------------------
INT_PTR CALLBACK DlgProc_Affinity( HWND hwndDlg,  UINT uMsg,
                                WPARAM wParam,  LPARAM lParam )
{
    static DWORD * pdwAffinity = NULL;      // One of the joys of single threadedness
    int i;

    switch( uMsg )
    {
        case WM_INITDIALOG:
        {
            pdwAffinity = (DWORD *) lParam;

            //
            // Initialize check-boxes in dialog box (to the correct
            // enabled/disabled and checked/unchecked states)
            //
            for( i=0 ; i<MAX_PROCESSOR ; i++ )
            {
                BOOL fIsActiveProcessor;  // CPU exists in system
                BOOL fIsSelectedProcessor;  // CPU is selected in affinity mask

                fIsActiveProcessor   = ( (g_dwActiveProcessorMask & (1 << i)) != 0 );
                fIsSelectedProcessor = ( (*pdwAffinity            & (1 << i)) != 0 );
                    
                EnableWindow( GetDlgItem(hwndDlg, IDC_CPU0 + i) ,
                              fIsActiveProcessor // enable or disable
                            );
                CheckDlgButton( hwndDlg,
                                IDC_CPU0 + i,
                                fIsActiveProcessor && fIsSelectedProcessor
                              );
            }
            return TRUE;
        }

        case WM_COMMAND:
        {
            switch( LOWORD(wParam) )
            {
                case IDCANCEL:
                    EndDialog( hwndDlg, IDCANCEL );
                    break;

                case IDOK:
                {
                    //
                    // Use user-selected CPUs to create affinity mask
                    //
                    *pdwAffinity = 0;
                    for( i=0 ; i<MAX_PROCESSOR ; i++ )
                    {
                        if( IsDlgButtonChecked(hwndDlg, IDC_CPU0 + i) )
                        {
                            ASSERT(  (1 << i) & g_dwActiveProcessorMask  );
                            *pdwAffinity |= (1 << i);
                        }
                    }

                    //
                    // Make sure affinity isn't set to "none" (don't want to allow that)
                    //
                    if( *pdwAffinity == 0 )
                    {
                        // Oops - user set affinity to "none"

                        TCHAR szTitle[] = _T("Invalid Option");
                        TCHAR szBody[]  = _T("The affinity mask must contain at least one processor.");
/* CPRINCE: THE FOLLOWING BLOCK IS THE ORIGINAL VERSION FROM TASKMGR -- CAN REMOVE IT, OR IS IT "BETTER" WAY TO DO THINGS ? (FOR LOCALIZATION, ETC)
                        TCHAR szTitle[MAX_PATH];
                        TCHAR szBody[MAX_PATH];


                        if( 0 == LoadString(g_hInstance, IDS_INVALIDOPTION, szTitle, ARRAYSIZE(szTitle)) ||
                            0 == LoadString(g_hInstance, IDS_NOAFFINITYMASK, szBody,  ARRAYSIZE(szBody))    )
                        {
                            break; // out of this switch statement
                        }
END CPRINCE */
                        MessageBox( hwndDlg, szBody, szTitle, MB_OK | MB_ICONERROR );
                    }
                    else
                    {
                        // OK, got valid affinity mask. We can exit
                        EndDialog( hwndDlg, IDOK );
                    }
                }
                break;

                //no Default case needed

            } //END: switch( LOWORD(wParam) )
        }
    }

    return FALSE;
}



//--------------------------------------------------------------------------
//
// Sets the interrupt-filter's affinity mask on a particular device.
//
// Return Value:
//   Returns TRUE if function succeeds, or FALSE if an error occurs.
//--------------------------------------------------------------------------
BOOL SetFilterAffinityMask( HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData,
                            DWORD affinityMask )
{
    HKEY hkeyDeviceParams;
    LONG lRetVal;
    BOOL fToReturn = TRUE;  // success


    //
    // Get a handle to the device's "Device Parameters" registry subkey
    //
    hkeyDeviceParams = SetupDiOpenDevRegKey( hDevInfo,
                                             pDevInfoData,
                                             DICS_FLAG_GLOBAL,  //CPRINCE: SHOULD (CAN?) USE 'DICS_FLAG_CONFIGSPECIFIC' INSTEAD ???
                                             0,
                                             DIREG_DEV,
                                             KEY_WRITE  // desired access
                                           );

    if( INVALID_HANDLE_VALUE == hkeyDeviceParams )
    {
        // Error opening device registry key...
        //
        // If error occurred because "Device Parameters" sub-key does
        // not exist, then try to create that sub-key.

        // NOTE: when we call GetLastError() here, we're getting an invalid
        // error code.  So let's just _assume_ (yeah, I know) that the error
        // was because the key does not exist, and try to create it here.

        hkeyDeviceParams = SetupDiCreateDevRegKey( hDevInfo,
                                                   pDevInfoData,
                                                   DICS_FLAG_GLOBAL,  //CPRINCE: SHOULD (CAN?) USE 'DICS_FLAG_CONFIGSPECIFIC' INSTEAD ???
                                                   0,
                                                   DIREG_DEV,
                                                   NULL,
                                                   NULL
                                                 );
        if( INVALID_HANDLE_VALUE == hkeyDeviceParams )
        {
            // OK, we can't open and can't create the key.  Let's
            // face it, we've failed, so return now.
            MessageBox_FromErrorCode( GetLastError() );
            return FALSE;
        }
        //ELSE: we were able to create the key, so keep going...
    }


    //
    // Set the desired registry value
    //
    lRetVal = RegSetValueEx( hkeyDeviceParams,
                             FILTER_REGISTRY_VALUE,
                             0,
                             REG_DWORD,
                             (BYTE*)&affinityMask,
                             sizeof(DWORD)
                           );

    if( ERROR_SUCCESS != lRetVal )
    {
        MessageBox_FromErrorCode( lRetVal );
        fToReturn = FALSE;  // failure
    }


    //
    // Close the registry key(s) we opened
    //
    lRetVal = RegCloseKey( hkeyDeviceParams );
    if( ERROR_SUCCESS != lRetVal )
    {
        MessageBox_FromErrorCode( lRetVal );
        fToReturn = FALSE;  // failure
    }


    return fToReturn;
}



//--------------------------------------------------------------------------
//
// Retrieves the interrupt-filter's affinity mask on a particular device.
//
// NOTE: If function fails (ie returns FALSE), then the value stored into
// the 'pAffinityMask' parameter should be considered invalid.
//
// Return Value:
//   Returns TRUE if function succeeds, or FALSE if an error occurs.
//--------------------------------------------------------------------------
BOOL GetFilterAffinityMask( HDEVINFO hDevInfo,
                            PSP_DEVINFO_DATA pDevInfoData,
                            DWORD* pAffinityMask )
{
    HKEY  hkeyDeviceParams;
    LONG  lRetVal;
    BOOL  fToReturn = TRUE;  // success
    DWORD regValueType;
    DWORD regValueSize;


    ASSERT( NULL != pAffinityMask );


    //
    // Get a handle to the device's "Device Parameters" registry subkey
    //
    hkeyDeviceParams = SetupDiOpenDevRegKey( hDevInfo,
                                             pDevInfoData,
                                             DICS_FLAG_GLOBAL,  //CPRINCE: SHOULD (CAN?) USE 'DICS_FLAG_CONFIGSPECIFIC' INSTEAD ???
                                             0,
                                             DIREG_DEV,
                                             KEY_QUERY_VALUE  // desired access
                                           );

    if( INVALID_HANDLE_VALUE == hkeyDeviceParams )
    {
        // Probably just means that the "Device Parameters" subkey
        // does not exist, so return, but _don't_ display error message.
        return FALSE;  // failure
    }


    //
    // Get the desired registry value
    //
    regValueSize = sizeof(DWORD);
    lRetVal = RegQueryValueEx( hkeyDeviceParams,
                               FILTER_REGISTRY_VALUE,
                               0,
                               &regValueType,
                               (BYTE*)pAffinityMask,
                               &regValueSize
                             );

    if( ERROR_SUCCESS != lRetVal )
    {
        if( ERROR_FILE_NOT_FOUND == lRetVal )
        {
            // Just means key didn't already exist.
            // So don't display error message.
        }
        else
        {
            MessageBox_FromErrorCode( lRetVal );
        }
        fToReturn = FALSE; // failure
    }
    else if( REG_DWORD != regValueType )
    {
        MessageBox( NULL,
                    "Registry value for affinity mask has unexpected type.",
                    "Error",
                    MB_OK | MB_ICONERROR
                  );
        fToReturn = FALSE;  // failure
    }


    //
    // Close the registry key(s) we opened
    //
    lRetVal = RegCloseKey( hkeyDeviceParams );
    if( ERROR_SUCCESS != lRetVal )
    {
        MessageBox_FromErrorCode( lRetVal );
        fToReturn = FALSE;  // failure
    }


    return fToReturn;
}


//--------------------------------------------------------------------------
//
// Deletes the interrupt-filter's affinity mask regkey for a particular device.
//
// Return Value:
//   Returns TRUE if regkey was successfully deleted (or never existed), or
//   FALSE otherwise.
//--------------------------------------------------------------------------
BOOL DeleteFilterAffinityMask( HDEVINFO hDevInfo,
                               PSP_DEVINFO_DATA pDevInfoData )
{
    HKEY hkeyDeviceParams;
    LONG lRetVal;
    BOOL fToReturn = TRUE;  // success


    //
    // Get a handle to the device's "Device Parameters" registry subkey
    //
    hkeyDeviceParams = SetupDiOpenDevRegKey( hDevInfo,
                                             pDevInfoData,
                                             DICS_FLAG_GLOBAL,  //CPRINCE: SHOULD (CAN?) USE 'DICS_FLAG_CONFIGSPECIFIC' INSTEAD ???
                                             0,
                                             DIREG_DEV,
                                             KEY_SET_VALUE  // desired access
                                           );

    if( INVALID_HANDLE_VALUE == hkeyDeviceParams )
    {
        // Probably means that the "Device Parameters" subkey
        // does not exist, so there wouldn't be any values stored
        // under this (non-existent) subkey.
        //
        // So return success, but display MessageBox just so
        // user knows we _did_ do something.
        MessageBox( NULL,
                    "There was no 'Device Parameters' registry key for this device.",
                    "Notice",
                    MB_OK );

        return TRUE;
    }


    //
    // Delete the desired registry key
    //
    lRetVal = RegDeleteValue( hkeyDeviceParams,
                              FILTER_REGISTRY_VALUE
                            );

    if( ERROR_SUCCESS != lRetVal )
    {
        // Was this truly an "error", or did we get
        // here because the RegVal just doesn't exist?
        if( ERROR_FILE_NOT_FOUND == lRetVal )
        {
            // RegVal just doesn't exist
            MessageBox( NULL,
                        "There was no interrupt-affinity-mask registry value for this device.",
                        "Notice",
                        MB_OK
                      );
        }
        else
        {
            // a "real" error
            MessageBox_FromErrorCode( lRetVal );
            fToReturn = FALSE;  // failure
        }
    }
    else
    {
        // MessageBox just so user gets some feedback, and knows 
        // that the deletion was successful (and actually occurred!)
        MessageBox( NULL,
                    "The interrupt-affinity-mask for this device was successully deleted from the registry.",
                    "Deletion Successful",
                    MB_OK
                  );
    }


    //
    // Close the registry key(s) we opened
    //
    lRetVal = RegCloseKey( hkeyDeviceParams );
    if( ERROR_SUCCESS != lRetVal )
    {
        MessageBox_FromErrorCode( lRetVal );
        fToReturn = FALSE;  // failure
    }


    return fToReturn;
}




//--------------------------------------------------------------------------
//
//CPRINCE:  must pass-in hwnd for Main dialog window here!!! (not just any
//          "parent" window.
//
// Parameters:
//   CPRINCE - NEED TO FILL IN THE REST OF THESE
//   fAddingFilter - set to TRUE to add filter, FALSE to remove filter
//--------------------------------------------------------------------------
void AddRemoveFilterOnDevice( HWND hwndMainDlg,
                              HDEVINFO hDevInfo,
                              PSP_DEVINFO_DATA pDevInfoData,
                              BOOL fAddingFilter )
{
    BOOLEAN (* fnChangeUpperFilter)( HDEVINFO, PSP_DEVINFO_DATA, LPTSTR );  // a convenient func ptr
    BOOLEAN status;


    //
    // Setup convenient value(s)
    //
    if( fAddingFilter )
        fnChangeUpperFilter = AddUpperFilterDriver;
    else
        fnChangeUpperFilter = RemoveUpperFilterDriver;


    //
    // Change the device's filter settings.
    // Then try to restart the device.
    //
    status = fnChangeUpperFilter( hDevInfo, pDevInfoData, FILTER_SERVICE_NAME );
    if( ! status )
    {
        // Unable to add (or remove) filter driver
        MessageBox( hwndMainDlg , "Unable to add/remove filter driver.", "Error", MB_OK | MB_ICONERROR );
    }
    else
    {
        // Filter successfully added/removed.
        // Now try to explicitly restart the device (if user wants to),
        // so that user doesn't need to reboot.
        if( BST_CHECKED == IsDlgButtonChecked(hwndMainDlg, IDC_DONTRESTART) )
        {
            // User has indicated that doesn't want to restart device when
            // filter is being added/removed, so don't try to restart the
            // device now.
            //
            // Thus nothing to do here.
        }
        else
        {
            MessageBox( hwndMainDlg,
                        "Filter driver has been successfully added/removed.  Will now attempt to restart device...",
                        "Success",
                        MB_OK );

            RestartDevice_WithUI( hwndMainDlg, hDevInfo, pDevInfoData );
        }

        //
        // Update (on-screen) the list of UpperFilters
        //
        UI_UpdateUpperFilterList( hwndMainDlg, hDevInfo, pDevInfoData );
    }

}





//--------------------------------------------------------------------------
//
// CPRINCE: RETRIEVES THE ITEM DATA ASSOCIATED WITH THE CURRENTLY SELECTED ITEM IN THE GIVEN LISTBOX
//--------------------------------------------------------------------------
LPARAM GetItemDataCurrentSelection( HWND hwndListBox )
{
    int    idxItem;

    idxItem = (int)SendMessage(hwndListBox, LB_GETCURSEL, 0, 0);
    return(  SendMessage(hwndListBox, LB_GETITEMDATA, idxItem, 0)  );
}


//--------------------------------------------------------------------------
//   MessageBox_FromErrorCode
//
// Given a system error code (such as that returned by 'GetLastError'),
// displays a MessageBox describing, in words, what the error was/means.
//--------------------------------------------------------------------------
void MessageBox_FromErrorCode( LONG systemErrorCode )
{
    void* pBuffer;

    FormatMessage(   FORMAT_MESSAGE_ALLOCATE_BUFFER
                       | FORMAT_MESSAGE_FROM_SYSTEM // using system error code
                       | FORMAT_MESSAGE_IGNORE_INSERTS // no translation of string
                   , NULL  // input string
                   , systemErrorCode // message ID
                   , 0   // language ID (0 == DontCare)
                   , (LPTSTR)(&pBuffer) // buffer for output
                   , 0
                   , NULL
                  );
    MessageBox( NULL, pBuffer, "Error", MB_OK | MB_ICONERROR );
    LocalFree( pBuffer );  // OK to pass null here
}




//--------------------------------------------------------------------------
//   FilterIsInstalledOnDevice
//
// Returns boolean value stating whether the filter is currently installed
// as an UpperFilter on the given device.
//
// Return Value:
//   Returns TRUE if installed, FALSE if not installed (or if error occurs)
//--------------------------------------------------------------------------
BOOL FilterIsInstalledOnDevice( HDEVINFO hDevInfo,
                                PSP_DEVINFO_DATA pDevInfoData )
{
    LPTSTR mszUpperFilterList;

    // Get MultiSz list of upper filters installed on device
    mszUpperFilterList = GetUpperFilters( hDevInfo, pDevInfoData );

    if( NULL == mszUpperFilterList )
    {
        return FALSE; // failure
    }

    // Search the list to see if our filter is there
    // (NOTE: filter names are case-INsensitive)
    if( MultiSzSearch(FILTER_SERVICE_NAME, mszUpperFilterList, FALSE, NULL) )
    {
        return TRUE; // found it!
    }
    //ELSE...
        return FALSE;  // not found, or error occurred
}


//--------------------------------------------------------------------------
//
//--------------------------------------------------------------------------

//CPRINCE: SHOULD HAVE BETTER NAME FOR THIS FUNCTION.... (PrepareForShutdown ???)
void ExitProgram( HWND hwndDlg, HDEVINFO* phDevInfo )
{
    int    i;
    HWND   hwndDeviceList;
    LPARAM itemData;

    
    hwndDeviceList = GetDlgItem( hwndDlg, IDL_DEVICES );



    //
    // Free all memory that was allocated for dialog-box list
    //
    for( i = 0  ;  i < g_nDialogItems  ;  i++ )
    {
        // Get item's associated data
        itemData = SendMessage( hwndDeviceList,
                                LB_GETITEMDATA,
                                i,
                                0
                              );
        // We stored pointer to alloc'd memory (or NULL, if error).
        // So free it now.
        free( (void*)itemData );    //CPRINCE CHECK: PROBLEM W/POINTERS AND 64-BIT MACHINES ???
    }


    //
    // Clean up the device list
    //
    if( *phDevInfo != INVALID_HANDLE_VALUE )
    {
        SetupDiDestroyDeviceInfoList( *phDevInfo );
//CPRINCE: WHAT TO DO IF THIS CALL FAILS ???  ANYTHING ???
        *phDevInfo = INVALID_HANDLE_VALUE;
    }



    //
    // Destroy the dialog box.
    //
    EndDialog( hwndDlg, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\config\multisz.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    multisz.c

Abstract:

    Functions for manipulating MultiSz strings

Author:

    Chris Prince (t-chrpri)

Environment:

    User mode

Notes:

    - Some functions based on code by Benjamin Strautin (t-bensta)

Revision History:

--*/


#include "MultiSz.h"

#include <stdlib.h>  // for malloc/free

// for all of the _t stuff (to allow compiling for both Unicode/Ansi)
#include <tchar.h>



#if DBG
#include <assert.h>
#define ASSERT(condition) assert(condition)
#else
#define ASSERT(condition)
#endif


//
// <CPRINCE> NOTE: a MultiSz cannot contain an empty string as one of its
// sub-strings (else could incorrectly interpret as end of MultiSz).
//
// Example:  string1 - "foo"
//           string2 - ""
//           string3 - "bar"
//
//           MultiSz - "foo\0\0bar\0\0"
//                         ^^^^
//                         This looks like end of MultiSz here -- but isn't!
//
// So can assume that won't have an empty (sub-)string in a MultiSz.
//








/*
 * Prepends the given string to a MultiSz.
 *
 * Returns TRUE if successful, FALSE if not (will only fail in memory
 * allocation)
 *
 * NOTE: This WILL allocate and free memory, so don't keep pointers to the
 * MultiSz passed in.
 *
 * Parameters:
 *   SzToPrepend - string to prepend
 *   MultiSz     - pointer to a MultiSz which will be prepended-to
 */
BOOLEAN
PrependSzToMultiSz(
    IN     LPCTSTR  SzToPrepend,
    IN OUT LPTSTR  *MultiSz
    )
{
    size_t szLen;
    size_t multiSzLen;
    LPTSTR newMultiSz = NULL;

    ASSERT( NULL != SzToPrepend );
    ASSERT( NULL != MultiSz );

    // get the size, in bytes, of the two buffers
    szLen = (_tcslen(SzToPrepend)+1)*sizeof(_TCHAR);
    multiSzLen = MultiSzLength(*MultiSz)*sizeof(_TCHAR);
    newMultiSz = (LPTSTR)malloc( szLen+multiSzLen );

    if( newMultiSz == NULL )
    {
        return FALSE;
    }

    // recopy the old MultiSz into proper position into the new buffer.
    // the (char*) cast is necessary, because newMultiSz may be a wchar*, and
    // szLen is in bytes.

    memcpy( ((char*)newMultiSz) + szLen, *MultiSz, multiSzLen );

    // copy in the new string
    _tcscpy( newMultiSz, SzToPrepend );

    free( *MultiSz );
    *MultiSz = newMultiSz;

    return TRUE;
}


/*
 * Returns the length (in characters) of the buffer required to hold this
 * MultiSz, INCLUDING the trailing null.
 *
 * Example: MultiSzLength("foo\0bar\0") returns 9
 *
 * NOTE: since MultiSz cannot be null, a number >= 1 will always be returned
 *
 * Parameters:
 *   MultiSz - the MultiSz to get the length of
 */
size_t
MultiSzLength(
    IN LPCTSTR MultiSz
    )
{
    size_t len = 0;
    size_t totalLen = 0;

    ASSERT( MultiSz != NULL );

    // search for trailing null character
    while( *MultiSz != _T('\0') )
    {
        len = _tcslen(MultiSz)+1;
        MultiSz += len;
        totalLen += len;
    }

    // add one for the trailing null character
    return (totalLen+1);
}


/*
 * Deletes all instances of a string from within a multi-sz.
 *
 * Return Value:
 *   Returns the number of instances that were deleted.
 *
 * Parameters:
 *   szFindThis      - the string to find and remove
 *   mszFindWithin   - the string having the instances removed
 *   NewStringLength - the new string length
 */
//CPRINCE: DO WE WANT TO MODIFY THIS TO TAKE ADVANTAGE OF MY "MultiSzSearch" FUNCTION ???
size_t
MultiSzSearchAndDeleteCaseInsensitive(
    IN  LPCTSTR  szFindThis,
    IN  LPTSTR   mszFindWithin,
    OUT size_t  *NewLength
    )
{
    LPTSTR search;
    size_t currentOffset;
    DWORD  instancesDeleted;
    size_t searchLen;

    ASSERT(szFindThis != NULL);
    ASSERT(mszFindWithin != NULL);
    ASSERT(NewLength != NULL);

    currentOffset = 0;
    instancesDeleted = 0;
    search = mszFindWithin;

    *NewLength = MultiSzLength(mszFindWithin);

    // loop while the multisz null terminator is not found
    while ( *search != _T('\0') )
    {
        // length of string + null char; used in more than a couple places
        searchLen = _tcslen(search) + 1;

        // if this string matches the current one in the multisz...
        if( _tcsicmp(search, szFindThis) == 0 )
        {
            // they match, shift the contents of the multisz, to overwrite the
            // string (and terminating null), and update the length
            instancesDeleted++;
            *NewLength -= searchLen;
            memmove( search,
                     search + searchLen,
                     (*NewLength - currentOffset) * sizeof(TCHAR) );
        }
        else
        {
            // they don't mactch, so move pointers, increment counters
            currentOffset += searchLen;
            search        += searchLen;
        }
    }

    return instancesDeleted;
}


//--------------------------------------------------------------------------
//
// Searches for a given string within a given MultiSz.
//
// Return Value:
//   Returns TRUE if string was found, or FALSE if not found or error occurs.
//
// Parameters:
//   szFindThis     - the string to look for
//   mszFindWithin  - the MultiSz to search within
//   fCaseSensitive - whether the search should be case-sensitive (TRUE==yes)
//   ppszMatch      - if search successful, will be set to point to first
//                      match in MultiSz; else undefined. (NOTE: is optional.
//                      If NULL, no value will be stored.)
//--------------------------------------------------------------------------
BOOL
MultiSzSearch( IN LPCTSTR szFindThis,
               IN LPCTSTR mszFindWithin,
               IN BOOL    fCaseSensitive,
               OUT LPCTSTR * ppszMatch OPTIONAL
             )
{
    LPCTSTR pCurrPosn;
    int (__cdecl * fnStrCompare)(const char *, const char *);  // convenient func ptr
    size_t  searchLen;


    ASSERT( NULL != szFindThis );
    ASSERT( NULL != mszFindWithin );


    // Setup function pointer
    if( fCaseSensitive )
    {
        fnStrCompare = _tcscmp;
    } else {
        fnStrCompare = _tcsicmp;
    }


    pCurrPosn   = mszFindWithin;

    // Loop until end of MultiSz is reached, or we find a match
    while( *pCurrPosn != _T('\0') )
    {
        if( 0 == fnStrCompare(pCurrPosn, szFindThis) )
        {
            break;  // exit loop
        }

        //
        // No match, so advance pointer to next string in the MultiSz
        //

        // length of string + null char
        searchLen = _tcslen(pCurrPosn) + 1;
        pCurrPosn += searchLen;
    }


    // If no match was found, can just return now.
    if( *pCurrPosn == _T('\0') )
    {
        return FALSE;  // no match
    }

    // Else match was found. Update 'ppszMatch', if caller wants that info.
    if( NULL != ppszMatch )
    {
        *ppszMatch = pCurrPosn;
    }


    return TRUE;  // found match
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\filter\filter.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    filter.c

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(INIT, DriverEntry)
        #pragma alloc_text(PAGE, VA_AddDevice)
        #pragma alloc_text(PAGE, VA_DriverUnload)
#endif


NTSTATUS DriverEntry(
                        IN PDRIVER_OBJECT DriverObject, 
                        IN PUNICODE_STRING RegistryPath
                    )
/*++

Routine Description:

    Installable driver initialization entry point.
    This entry point is called directly by the I/O system.

Arguments:

    DriverObject - pointer to the driver object

    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    ULONG i;

    PAGED_CODE();

    UNREFERENCED_PARAMETER(RegistryPath);

    DBGOUT(("DriverEntry")); 

    /*
     *  Route all IRPs on device objects created by this driver
     *  to our IRP dispatch routine.
     */
    for( i = 0 ; i <= IRP_MJ_MAXIMUM_FUNCTION ; i++ ) {
        DriverObject->MajorFunction[i] = VA_Dispatch; 
    }

    DriverObject->DriverExtension->AddDevice = VA_AddDevice;
    DriverObject->DriverUnload = VA_DriverUnload;

    return STATUS_SUCCESS;
}


NTSTATUS VA_AddDevice(
                        IN PDRIVER_OBJECT driverObj, 
                        IN PDEVICE_OBJECT physicalDevObj
                     )
/*++

Routine Description:

    The PlugPlay subsystem is handing us a brand new 
    PDO (Physical Device Object), for which we
    (by means of INF registration) have been asked to filter.

    We need to determine if we should attach or not.
    Create a filter device object to attach to the stack
    Initialize that device object
    Return status success.

    Remember: we can NOT actually send ANY non pnp IRPS to the given driver
    stack, UNTIL we have received an IRP_MN_START_DEVICE.

Arguments:

    driverObj - pointer to a device object.

    physicalDevObj -    pointer to a physical device object pointer 
                        created by the  underlying bus driver.

Return Value:

    NT status code.

--*/

{
    NTSTATUS status;
    PDEVICE_OBJECT filterDevObj = NULL;
    
    PAGED_CODE();

    DBGOUT(("VA_AddDevice: drvObj=%ph, pdo=%ph", driverObj, physicalDevObj)); 

    status = IoCreateDevice( driverObj, 
                             sizeof(struct DEVICE_EXTENSION),
                             NULL,            // name for this device
                             FILE_DEVICE_UNKNOWN, 
                             FILE_AUTOGENERATED_DEVICE_NAME,  // device characteristics
                             FALSE,           // not exclusive
                             &filterDevObj);  // our device object

    if( NT_SUCCESS(status) )
    {
        struct DEVICE_EXTENSION *devExt;

        ASSERT(filterDevObj);

        /*
         *  Initialize device extension for new device object
         */
        devExt = (struct DEVICE_EXTENSION *)filterDevObj->DeviceExtension;
        RtlZeroMemory(devExt, sizeof(struct DEVICE_EXTENSION));
        devExt->signature           = DEVICE_EXTENSION_SIGNATURE;
        devExt->state               = STATE_INITIALIZED;
        devExt->filterDevObj        = filterDevObj;
        devExt->physicalDevObj      = physicalDevObj;
        devExt->desiredAffinityMask = MAXULONG; // Default: won't change interrupt mask

        devExt->pendingActionCount = 0;
        KeInitializeEvent(&devExt->removeEvent, NotificationEvent, FALSE);
        KeInitializeEvent(&devExt->deviceUsageNotificationEvent, SynchronizationEvent, TRUE);


        /*
         *  Attach the new device object to the top of the device stack.
         */
        devExt->topDevObj = IoAttachDeviceToDeviceStack(filterDevObj, physicalDevObj);

        ASSERT(devExt->topDevObj);
        DBGOUT(("created filterDevObj %ph attached to %ph.", filterDevObj, devExt->topDevObj));



        //
        // As a filter driver, we do not want to change the power or I/O
        // behavior of the driver stack in any way.  Recall that a filter
        // driver should "appear" the same (almost) as the underlying device.
        // Therefore we must copy some bits from the device object _directly_
        // below us in the device stack (notice: DON'T copy from the PDO!)
        //


        /* Various I/O-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |= (devExt->topDevObj->Flags & DO_BUFFERED_IO);
        filterDevObj->Flags |= (devExt->topDevObj->Flags & DO_DIRECT_IO);

        /* Various Power-related flags which should be maintained */
        /* (copy from lower device object) */
        filterDevObj->Flags |= (devExt->topDevObj->Flags & DO_POWER_INRUSH); 
        filterDevObj->Flags |= (devExt->topDevObj->Flags & DO_POWER_PAGABLE);


        //
        // To determine whether some of our routines should initially be
        // pageable, we must consider the DO_POWER_xxxx flags of the
        // device object directly below us in the device stack.
        //
        // * We make ourselves pageable if:
        //     - that devobj has its PAGABLE bit set (so we know our power
        //       routines won't be called at DISPATCH_LEVEL)
        // -OR-
        //     - that devobj has its NOOP bit set (so we know we won't be
        //       participating in power-management at all)
        //
        // * Otherwise, we make ourselves non-pageable because either:
        //     - that devobj has its INRUSH bit set (so we also have to be
        //       INRUSH, and code that handles INRUSH irps can't be pageable)
        // -OR-
        //     - that devobj does NOT have its PAGABLE bit set (and NOOP isn't
        //       set, so some of our code might be called at DISPATCH_LEVEL)
        //
        if(    devExt->topDevObj->Flags & DO_POWER_PAGABLE )
        {
            // We're initially pageable.
            //
            // Don't need to do anything else here, for now.
        }
        else
        {
            // We're initially non-pageable.
            //
            // We need to lock-down the code for all routines
            // that could be called at IRQL >= DISPATCH_LEVEL.
            DBGOUT(( "LOCKing some driver code (non-pageable) (b/c init conditions)" ));
            devExt->initUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
            ASSERT( NULL != devExt->initUnlockHandle );
        }


        /*
         *  Clear the initializing bit from the new device object's flags.
         *  NOTE: must not do this until *after* setting DO_POWER_xxxx flags
         */
        filterDevObj->Flags &= ~DO_DEVICE_INITIALIZING;

        /*
         *  Remember our initial flag settings.
         *  (Need remember initial settings to correctly handle
         *  setting of PAGABLE bit later.)
         */
        devExt->initialFlags = filterDevObj->Flags;




        /*
         *  Read driver-configuration info from the device's registry area.
         *
         *  Note that you cannot make this call on devExt->filterDevObj
         *  because a filter device object does not have a devNode.
         *  We pass devExt->physicalDevObj, which is the device object
         *  for which this driver is a filter driver.
         */
        RegistryAccessConfigInfo( devExt, devExt->physicalDevObj );

    } 

    ASSERT(NT_SUCCESS(status));
    return status;
}


VOID VA_DriverUnload(IN PDRIVER_OBJECT DriverObject)
/*++

Routine Description:

    Free all the allocated resources, etc.

    Note:  Although the DriverUnload function often does nothing,
           the driver must set a DriverUnload function in 
           DriverEntry; otherwise, the kernel will never unload
           the driver.

Arguments:

    DriverObject - pointer to a driver object.

Return Value:

    VOID.

--*/
{

    PAGED_CODE();
    

    DBGOUT(("VA_DriverUnload")); 
}


NTSTATUS VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
/*++

Routine Description:

    Common entrypoint for all Io Request Packets

Arguments:

    DeviceObject - pointer to a device object.
    Irp - Io Request Packet

Return Value:

    NT status code.

--*/

{
    struct DEVICE_EXTENSION *devExt;
    PIO_STACK_LOCATION irpSp;
    BOOLEAN passIrpDown = TRUE;
    UCHAR majorFunc, minorFunc;
    NTSTATUS status;

    devExt = DeviceObject->DeviceExtension;
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    /*
     *  Get major/minor function codes in private variables
     *  so we can access them after the IRP is completed.
     */
    majorFunc = irpSp->MajorFunction;
    minorFunc = irpSp->MinorFunction;

    DBGOUT(( "VA_Dispatch: irp=[0x%X,0x%X]", 
             (ULONG)majorFunc, (ULONG)minorFunc )); 

    /*
     *  For all IRPs except REMOVE, we increment the PendingActionCount
     *  across the dispatch routine in order to prevent a race condition with
     *  the REMOVE_DEVICE IRP (without this increment, if REMOVE_DEVICE
     *  preempted another IRP, device object and extension might get
     *  freed while the second thread was still using it).
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        IncrementPendingActionCount(devExt);
    }

    if ((majorFunc != IRP_MJ_PNP) &&
        (majorFunc != IRP_MJ_CLOSE) &&
        ((devExt->state == STATE_REMOVING) ||
         (devExt->state == STATE_REMOVED))){

        /*
         *  While the device is being removed, 
         *  we only pass down the PNP and CLOSE IRPs.
         *  We fail all other IRPs.
         */
        status = Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        passIrpDown = FALSE;
    }
    else {
        switch (majorFunc){

            case IRP_MJ_PNP:
                status = VA_PnP(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_POWER:
                status = VA_Power(devExt, Irp);
                passIrpDown = FALSE;
                break;

            case IRP_MJ_CREATE:
            case IRP_MJ_CLOSE:
            case IRP_MJ_DEVICE_CONTROL:
            case IRP_MJ_SYSTEM_CONTROL:
            case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            default:
                /*
                 *  For unsupported IRPs, we simply send the IRP
                 *  down the driver stack.
                 */
                break;
        }
    }

    if (passIrpDown){
        IoSkipCurrentIrpStackLocation(Irp);
        status = IoCallDriver(devExt->topDevObj, Irp);
    }

    /*
     *  Balance the increment to PendingActionCount above.
     */
    if (!((majorFunc == IRP_MJ_PNP) && (minorFunc == IRP_MN_REMOVE_DEVICE))){
        DecrementPendingActionCount(devExt);
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\filter\filter.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    filter.h

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/


enum deviceState {
        STATE_INITIALIZED,
        STATE_STARTING,
        STATE_STARTED,
        STATE_START_FAILED,
        STATE_STOPPED,  // implies device was previously started successfully
        STATE_SUSPENDED,
        STATE_REMOVING,
        STATE_REMOVED
};

#define DEVICE_EXTENSION_SIGNATURE 'tlFI'

typedef struct DEVICE_EXTENSION {

    /*
     *  Memory signature of a device extension, for debugging.
     */
    ULONG signature;

    /*
     *  Plug-and-play state of this device object.
     */
    enum deviceState state;

    /*
     *  The device object that this filter driver created.
     */
    PDEVICE_OBJECT filterDevObj;

    /*
     *  The device object created by the next lower driver.
     */
    PDEVICE_OBJECT physicalDevObj;

    /*
     *  The device object at the top of the stack that we attached to.
     *  This is often (but not always) the same as physicalDevObj.
     */
    PDEVICE_OBJECT topDevObj;

    /*
     *  deviceCapabilities includes a
     *  table mapping system power states to device power states.
     */
    DEVICE_CAPABILITIES deviceCapabilities;

    /*
     *  Keep track of the number of paging/hibernation/crashdump
     *  files that are opened on this device.
     */
    ULONG  pagingFileCount, hibernationFileCount, crashdumpFileCount;
    KEVENT deviceUsageNotificationEvent;
    PVOID  pagingPathUnlockHandle;  /* handle to lock certain code as non-pageable */

    /*
     *  Also, might need to lock certain driver code as non-pageable, based on
     *  initial conditions (as opposed to paging-file considerations).
     */
    PVOID  initUnlockHandle;
    ULONG  initialFlags;

    /*
     *  pendingActionCount is used to keep track of outstanding actions.
     *  removeEvent is used to wait until all pending actions are
     *  completed before complete the REMOVE_DEVICE IRP and let the
     *  driver get unloaded.
     */
    LONG   pendingActionCount;
    KEVENT removeEvent;


    /*
     *  Various parameters used to configure this filter.  Parameters can be
     *  different for each device that this filter gets installed on top of.
     */
    ULONG desiredAffinityMask;  // interrupt affinity mask to use
};


/*
 *  Memory tag for memory blocks allocated by this driver
 *  (used in ExAllocatePoolWithTag() call).
 *  This DWORD appears as "IFlt" in a little-endian memory byte dump.
 */
#define FILTER_TAG (ULONG)'tlFI'


#if DBG
    #define DBGOUT(params_in_parentheses)   \
        {                                               \
            DbgPrint("'INTFILTR> "); \
            DbgPrint params_in_parentheses; \
            DbgPrint("\n"); \
        }
    #define TRAP(msg)  \
        {   \
            DBGOUT(("TRAP at file %s, line %d: '%s'.", __FILE__, __LINE__, msg)); \
            DbgBreakPoint(); \
        }
#else
    #define DBGOUT(params_in_parentheses)
    #define TRAP(msg)
#endif


typedef  unsigned char  BYTE;


/*
 *  Function externs
 */
NTSTATUS    DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    VA_AddDevice(IN PDRIVER_OBJECT driverObj, IN PDEVICE_OBJECT pdo);
VOID        VA_DriverUnload(IN PDRIVER_OBJECT DriverObject);
NTSTATUS    VA_Dispatch(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp);
NTSTATUS    VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    VA_PowerComplete(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID context);
NTSTATUS    GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt);
NTSTATUS    CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp);
NTSTATUS    CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp);
NTSTATUS    CallDriverSyncCompletion(IN PDEVICE_OBJECT devObj, IN PIRP irp, IN PVOID Context);
VOID        IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt);
VOID        RegistryAccessConfigInfo(struct DEVICE_EXTENSION *devExt, PDEVICE_OBJECT devObj);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\filter\util.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    util.c

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, CallNextDriverSync)
        #pragma alloc_text(PAGE, CallDriverSync)
        #pragma alloc_text(PAGE, RegistryAccessConfigInfo)  
#endif


NTSTATUS CallNextDriverSync(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

        Pass the IRP down to the next device object in the stack
        synchronously, and bump the pendingActionCount around
        the call to prevent the current device object from getting
        removed before the IRP completes.

Arguments:

    devExt - device extension of one of our device objects
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    NTSTATUS status;

    PAGED_CODE();

    IncrementPendingActionCount(devExt);
    status = CallDriverSync(devExt->topDevObj, irp);
    DecrementPendingActionCount(devExt);

    return status;
}



NTSTATUS CallDriverSync(PDEVICE_OBJECT devObj, PIRP irp)
/*++

Routine Description:

      Call IoCallDriver to send the irp to the device object;
      then, synchronize with the completion routine.
      When CallDriverSync returns, the action has completed
      and the irp again belongs to the current driver.

      NOTE:  In order to keep the device object from getting freed
             while this IRP is pending, you should call
             IncrementPendingActionCount() and 
             DecrementPendingActionCount()
             around the CallDriverSync call.

Arguments:

    devObj - targetted device object
    irp - Io Request Packet

Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();

    KeInitializeEvent(&event, NotificationEvent, FALSE);

    IoSetCompletionRoutine( irp, 
                            CallDriverSyncCompletion, 
                            &event,     // context
                            TRUE, TRUE, TRUE);

    status = IoCallDriver(devObj, irp);

    KeWaitForSingleObject(  &event,
                            Executive,      // wait reason
                            KernelMode,
                            FALSE,          // not alertable
                            NULL );         // no timeout

    status = irp->IoStatus.Status;

    ASSERT(NT_SUCCESS(status));

    return status;
}


NTSTATUS CallDriverSyncCompletion(
                                    IN PDEVICE_OBJECT devObjOrNULL, 
                                    IN PIRP irp, 
                                    IN PVOID context)
/*++

Routine Description:

      Completion routine for CallDriverSync.

Arguments:

    devObjOrNULL - 
            Usually, this is this driver's device object.
             However, if this driver created the IRP, 
             there is no stack location in the IRP for this driver;
             so the kernel has no place to store the device object;
             ** so devObj will be NULL in this case **.

    irp - completed Io Request Packet
    context - context passed to IoSetCompletionRoutine by CallDriverSync. 

    
Return Value:

    NT status code, indicates result returned by lower driver for this IRP.

--*/
{
    PKEVENT event = context;

    ASSERT(irp->IoStatus.Status != STATUS_IO_TIMEOUT);

    KeSetEvent(event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}



VOID IncrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Increment the pendingActionCount for a device object.
      This keeps the device object from getting freed before
      the action is completed.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedIncrement(&devExt->pendingActionCount);    
}



VOID DecrementPendingActionCount(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

      Decrement the pendingActionCount for a device object.
      This is called when an asynchronous action is completed
      AND ALSO when we get the REMOVE_DEVICE IRP.
      If the pendingActionCount goes to -1, that means that all
      actions are completed and we've gotten the REMOVE_DEVICE IRP;
      in this case, set the removeEvent event so we can finish
      unloading.

Arguments:

    devExt - device extension of device object

Return Value:

    VOID

--*/
{
    ASSERT(devExt->pendingActionCount >= 0);
    InterlockedDecrement(&devExt->pendingActionCount);    

    if (devExt->pendingActionCount < 0){
        /*
         *  All pending actions have completed and we've gotten
         *  the REMOVE_DEVICE IRP.
         *  Set the removeEvent so we'll stop waiting on REMOVE_DEVICE.
         */
        ASSERT((devExt->state == STATE_REMOVING) || 
               (devExt->state == STATE_REMOVED));
        KeSetEvent(&devExt->removeEvent, 0, FALSE);
    }
}



VOID RegistryAccessConfigInfo( struct DEVICE_EXTENSION *devExt,
                               PDEVICE_OBJECT devObj             )
/*++

Routine Description:

    Access device-specific registry key(s) containing driver-config info

Arguments:

    devExt - device extension (for our _filter_ device object)
    devObj - device object pointer
               NOTE: This must not be the functional device object
                     created by this filter driver, because that
                     device object does not have a devnode area
                     in the registry; pass the device object of
                     the device object for which this driver is
                     a filter.  This is the device object passed
                     to VA_AddDevice.

Return Value:

    VOID

--*/
{
    NTSTATUS status;
    HANDLE   hDeviceRegKey;

    PAGED_CODE();


    // Open the registry key for the given device object
    status = IoOpenDeviceRegistryKey( devObj, 
                                      PLUGPLAY_REGKEY_DEVICE, 
                                      KEY_READ, 
                                      &hDeviceRegKey);
    /*
     *  NOTE: The device-specific registry value(s) are stored in the
     *  "Device Parameters" sub-key of the Enum key for the device
     *  (and NOT in the Enum key itself)!
     */

    if (NT_SUCCESS(status)){
        UNICODE_STRING keyName;
        ULONG          actualLength;
        BYTE keyValueInfoBuffer[ sizeof(KEY_VALUE_PARTIAL_INFORMATION)
                                 + sizeof( ULONG )  // space for 'Data' field
                               ];


        
        // Setup a UNICODE_STRING containing name of reg-value we're interested in
        RtlInitUnicodeString( &keyName, L"IntFiltr_AffinityMask" );
        
        // Get value(s) from this device's registry key
        status = ZwQueryValueKey( hDeviceRegKey,
                                  &keyName,
                                  KeyValuePartialInformation, // type of info requested (see WDM.H for details)
                                  (PVOID)keyValueInfoBuffer,  // ptr to caller-allocated buffer to receive requested data
                                  sizeof(keyValueInfoBuffer), // size of buffer, in bytes
                                  &actualLength
                                );

        if( NT_SUCCESS(status) )
        {
            // Type-cast, for convenience...
            PKEY_VALUE_PARTIAL_INFORMATION pKeyValueInfo =
                (PKEY_VALUE_PARTIAL_INFORMATION) keyValueInfoBuffer;


            ASSERT( pKeyValueInfo->Type == REG_DWORD );
            ASSERT( pKeyValueInfo->DataLength == sizeof(ULONG) );

            // Store info in filter's device-extension so that it's
            // available to us later, when we need to use it
            devExt->desiredAffinityMask = *( (PULONG)(pKeyValueInfo->Data) );

            DBGOUT(( "RegistryAccessConfigInfo: got value IntFiltr_AffinityMask=0x%08X"
                     , devExt->desiredAffinityMask
                  ));
        }
        else
        {
            DBGOUT(( "ZwQueryValueKey failed with %xh.", status ));
        }


        ZwClose(hDeviceRegKey);
    }
    else
    {
        // Unable to open device registry key...
        DBGOUT(("IoOpenDeviceRegistryKey failed with %xh.", status));
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\filter\power.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    power.c

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/

#include <WDM.H>

#include "filter.h"

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGElock, VA_Power)
#endif


NTSTATUS VA_Power(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devExt - device extension for targetted device object
    irp - Io Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(("VA_Power, minorFunc = 0x%X ", (ULONG)irpSp->MinorFunction)); 


    switch (irpSp->MinorFunction){

        case IRP_MN_SET_POWER:

            switch (irpSp->Parameters.Power.Type) {

                case SystemPowerState:
                    /*
                     *  For system power states, just pass the IRP down.
                     */
                    break;

                case DevicePowerState:

                    switch (irpSp->Parameters.Power.State.DeviceState) {

                        case PowerDeviceD0:
                            /*
                             *  Resume from APM Suspend
                             *
                             *  Do nothing here; 
                             *  Send down the read IRPs in the completion
                             *  routine for this (the power) IRP.
                             */
                            break;

                        case PowerDeviceD1:
                        case PowerDeviceD2:
                        case PowerDeviceD3:
                            /*
                             *  Suspend
                             */
                            if (devExt->state == STATE_STARTED){
                                devExt->state = STATE_SUSPENDED;
                            }
                            break;

                    }
                    break;

            }
            break;

    }


    /*
     *  Send the IRP down the driver stack,
     *  using PoCallDriver (not IoCallDriver, as for non-power irps).
     */
    IncrementPendingActionCount(devExt);
    IoCopyCurrentIrpStackLocationToNext(irp);
    IoSetCompletionRoutine( irp, 
                            VA_PowerComplete, 
                            (PVOID)devExt,  // context
                            TRUE, 
                            TRUE, 
                            TRUE);
    status = PoCallDriver(devExt->topDevObj, irp);

    return status;
}


NTSTATUS VA_PowerComplete(
                            IN PDEVICE_OBJECT devObj, 
                            IN PIRP irp, 
                            IN PVOID context)
/*++

Routine Description:

      Completion routine for Power IRPs (MajorFunction == IRP_MJ_Power)

Arguments:

    devObj - targetted device object
    irp - Io Request Packet
    context - context value passed to IoSetCompletionRoutine by VA_Power

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    struct DEVICE_EXTENSION *devExt = (struct DEVICE_EXTENSION *)context;

    ASSERT(devExt);
    ASSERT(devExt->signature == DEVICE_EXTENSION_SIGNATURE); 

    /*
     *  If the lower driver returned PENDING, mark our stack location as
     *  pending also.
     */
    if( irp->PendingReturned )
    {
        DBGOUT(( "in PowerComplete -- irp was 'PendingReturned'!" ));
        IoMarkIrpPending(irp);
    }
    
    irpSp = IoGetCurrentIrpStackLocation(irp);
    ASSERT(irpSp->MajorFunction == IRP_MJ_POWER);

    if (NT_SUCCESS(irp->IoStatus.Status)){
        switch (irpSp->MinorFunction){

            case IRP_MN_SET_POWER:

                switch (irpSp->Parameters.Power.Type){

                    case DevicePowerState:
                        switch (irpSp->Parameters.Power.State.DeviceState){
                            case PowerDeviceD0:
                                if (devExt->state == STATE_SUSPENDED){
                                    devExt->state = STATE_STARTED;
                                }
                                break;
                        }
                        break;

                }
                break;
        }

    }


    /*
     *  Whether we are completing or relaying this power IRP,
     *  we must call PoStartNextPowerIrp.
     */
    PoStartNextPowerIrp(irp);
    
    /*
     *  Decrement the pendingActionCount, which we incremented in VA_Power.
     */
    DecrementPendingActionCount(devExt);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\intfilter\src\filter\pnp.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    Interrupt-affinity Filter
    (Roughly based on "NULL filter driver" in DDK, by ervinp and t-chrpri)

Author:

    t-chrpri

Environment:

    Kernel mode

Revision History:
    
--*/

#include <WDM.H>

#include "filter.h"


#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE, VA_PnP)
        #pragma alloc_text(PAGE, GetDeviceCapabilities)
#endif

            
NTSTATUS VA_PnP(struct DEVICE_EXTENSION *devExt, PIRP irp)
/*++

Routine Description:

    Dispatch routine for PnP IRPs (MajorFunction == IRP_MJ_PNP)

Arguments:

    devExt - device extension for the targetted device object
    irp - IO Request Packet

Return Value:

    NT status code

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN completeIrpHere = FALSE;
    BOOLEAN justReturnStatus = FALSE;

    PAGED_CODE();

    irpSp = IoGetCurrentIrpStackLocation(irp);

    DBGOUT(( "VA_PnP, (MnFunc=0x%X)", (ULONG)irpSp->MinorFunction )); 

    switch (irpSp->MinorFunction){

        case IRP_MN_START_DEVICE:
            DBGOUT(("START_DEVICE")); 

            devExt->state = STATE_STARTING;


            /*
             *  Look at the translated resource list, and modify the affinity
             *  mask for Interrupt resources, where desired.  As a result,
             *  lower drivers (which use entries in this resource list when
             *  setting up their ISRs) will have their ISRs installed only on
             *  the set of processors that we specify here.
             *  
             *  (NOTICE: must be done before pass-on this IRP to lower drivers)
             */
            if (    NULL != irpSp->Parameters.StartDevice.AllocatedResources
                 && NULL != irpSp->Parameters.StartDevice.AllocatedResourcesTranslated )
            {
                PCM_FULL_RESOURCE_DESCRIPTOR    pCurrFullResDesc; // ptr to an entry in AllocResTrans->List[]
                ULONG                           nFullResDesc;     // num entries in in AllocResTrans->List[]
                PCM_PARTIAL_RESOURCE_LIST       pPartialResList;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR pCurrPartialResDesc; // ptr to an entry in PartialDescriptors[]
                ULONG                           nPartialResDesc;     // num entries in PartialDescriptors[]
                ULONG                           i, j;

                //
                // NOTE: this structure consists of a (continguous) list of
                // non-fixed-size lists, so we need to traverse carefully.
                //


                // Loop through all the CM_FULL_RESOURCE_DESCRIPTORs
                nFullResDesc     =   irpSp->Parameters.StartDevice.AllocatedResourcesTranslated->Count;
                pCurrFullResDesc = &(irpSp->Parameters.StartDevice.AllocatedResourcesTranslated->List[0]);

                for( i = 0  ;  i < nFullResDesc  ;  i++ )
                {
                    DBGOUT(( "Traversing FullResDesc number %d (of %d)" 
                             , i+1
                             , nFullResDesc
                          ));

                    // Loop through all the CM_PARTIAL_RESOURCE_DESCRIPTORS
                    // inside the current CM_FULL_RESOURCE_DESCRIPTOR
                    pPartialResList = &(pCurrFullResDesc->PartialResourceList);

                    nPartialResDesc     =   pPartialResList->Count;
                    pCurrPartialResDesc = &(pPartialResList->PartialDescriptors[0]);

                    for( j=0 ; j<nPartialResDesc ; j++,pCurrPartialResDesc++ )
                    {
                        switch( pCurrPartialResDesc->Type )
                        {
                            case CmResourceTypeInterrupt:
                                DBGOUT(( "    found an INTERRUPT resource (affinity=%08X)"
                                         , pCurrPartialResDesc->u.Interrupt.Affinity
                                      ));

                                //
                                // Set the affinity mask to new value.
                                // Affects lower drivers in this stack.
                                //
                                DBGOUT(( "      +-> desiredAffinityMask=%08X"
                                         , devExt->desiredAffinityMask        ));

                                pCurrPartialResDesc->u.Interrupt.Affinity  &=  devExt->desiredAffinityMask;

                                DBGOUT(( "      +---> MASK NOW CHANGED TO affinity=%08X"
                                         , pCurrPartialResDesc->u.Interrupt.Affinity ));
                            break;

                            default:
                                DBGOUT(( "    found a resource we don't care about (Type==%d)"
                                         , pCurrPartialResDesc->Type
                                      ));
                                //
                                // Nothing to do; don't care about this resource type
                                //
                                ;
                        }
                    }


                    // Get pointer to the next CM_FULL_RESOURCE_DESCRIPTOR
                    // 
                    // Explanation: pCurrPartialResDesc points to first byte
                    // after the last CM_PARTIAL_RESOURCE_DESCRIPTOR in this
                    // CM_PARTIAL_RESOURCE_LIST.  Therefore it also points to
                    // first byte after current CM_FULL_RESOURCE_DESCRIPTOR.
                    //
                    // And since a CM_RESOURCE_LIST contains a _contiguous_
                    // list of CM_FULL_RESOURCE_DESCRIPTORs, we're pointing at
                    // the start of the next CM_FULL_RESOURCE_DESCRIPTOR in
                    // the list.  So just need to cast the pointer here to get
                    // at the next CM_FULL_RESOURCE_DESCRIPTOR.
                    pCurrFullResDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pCurrPartialResDesc;

                }
            }
            else
            {
                DBGOUT(( "WARNING: received NULL resource list in START_DEVICE!..." ));
                DBGOUT(( "...[ AllocResources(Translated) = 0x%08X (0x%08X) ]"
                         , irpSp->Parameters.StartDevice.AllocatedResources
                         , irpSp->Parameters.StartDevice.AllocatedResourcesTranslated
                      ));
            }


            /*
             *  Send the START_DEVICE irp down the stack
             *  synchronously to start the lower stack.
             *  We cannot do anything with our device object
             *  before propagating the START_DEVICE this way.
             */
            IoCopyCurrentIrpStackLocationToNext(irp);
            status = CallNextDriverSync(devExt, irp);

            if (NT_SUCCESS(status)){
                /*
                 *  Now that the lower stack is started,
                 *  do any initialization required by this device object.
                 */
                status = GetDeviceCapabilities(devExt);
                if (NT_SUCCESS(status)){
                    devExt->state = STATE_STARTED;
                }
                else {
                    devExt->state = STATE_START_FAILED;
                }
            }
            else {
                devExt->state = STATE_START_FAILED;
            }
            completeIrpHere = TRUE;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:
        case IRP_MN_QUERY_REMOVE_DEVICE:
            //
            // Need to fail these IRPs if a paging, hibernation, or crashdump
            // file is currently open on this device
            //
            if(    devExt->pagingFileCount      != 0
                || devExt->hibernationFileCount != 0
                || devExt->crashdumpFileCount   != 0 )
            {
                // Fail the IRP
                DBGOUT(( "Failing QUERY_(STOP,REMOVE)_DEVICE request b/c "
                         "paging, hiber, or crashdump file is present on device." ));
                status = STATUS_UNSUCCESSFUL;
                completeIrpHere = TRUE;
            }
            else
            {
                // We'll just pass this IRP down the driver stack.  But
                // first, must change the IRP's status to STATUS_SUCCESS
                // (default is STATUS_NOT_SUPPORTED)
                irp->IoStatus.Status = STATUS_SUCCESS;
            }

            break;

        case IRP_MN_STOP_DEVICE:
            if (devExt->state == STATE_SUSPENDED){
                status = STATUS_DEVICE_POWER_FAILURE;
                completeIrpHere = TRUE;
            }
            else {
                /*
                 *  Only set state to STOPPED if the device was
                 *  previously started successfully.
                 */
                if (devExt->state == STATE_STARTED){
                    devExt->state = STATE_STOPPED;
                }
            }
            break;

        case IRP_MN_SURPRISE_REMOVAL:
            DBGOUT(("SURPRISE_REMOVAL")); 

            /*
             *  We will pass this IRP down the driver stack.
             *  However, we need to change the default status
             *  from STATUS_NOT_SUPPORTED to STATUS_SUCCESS.
             */
            irp->IoStatus.Status = STATUS_SUCCESS;

            /*
             *  For now just set the STATE_REMOVING state so that
             *  we don't do any more IO.  We are guaranteed to get
             *  IRP_MN_REMOVE_DEVICE soon; we'll do the rest of
             *  the remove processing there.
             */
            devExt->state = STATE_REMOVING;

            break;

        case IRP_MN_REMOVE_DEVICE:
            /*
             *  Check the current state to guard against multiple
             *  REMOVE_DEVICE IRPs.
             */
            DBGOUT(("REMOVE_DEVICE")); 
            if (devExt->state != STATE_REMOVED){

                devExt->state = STATE_REMOVED;

                /*
                 *  Send the REMOVE IRP down the stack asynchronously.
                 *  Do not synchronize sending down the REMOVE_DEVICE
                 *  IRP, because the REMOVE_DEVICE IRP must be sent
                 *  down and completed all the way back up to the sender
                 *  before we continue.
                 */
                IoSkipCurrentIrpStackLocation(irp);
                status = IoCallDriver(devExt->topDevObj, irp);
                justReturnStatus = TRUE;

                DBGOUT(("REMOVE_DEVICE - waiting for %d irps to complete...",
                        devExt->pendingActionCount));  

                /*
                 *  We must for all outstanding IO to complete before
                 *  completing the REMOVE_DEVICE IRP.
                 *
                 *  First do an extra decrement on the pendingActionCount.
                 *  This will cause pendingActionCount to eventually
                 *  go to -1 once all asynchronous actions on this
                 *  device object are complete.
                 *  Then wait on the event that gets set when the
                 *  pendingActionCount actually reaches -1.
                 */
                DecrementPendingActionCount(devExt);
                KeWaitForSingleObject(  &devExt->removeEvent,
                                        Executive,      // wait reason
                                        KernelMode,
                                        FALSE,          // not alertable
                                        NULL );         // no timeout

                DBGOUT(("REMOVE_DEVICE - ... DONE waiting. ")); 


                /*
                 *  If we locked-down certain paged code sections earlier
                 *  because of this device, then need to unlock them now
                 *  (before calling IoDeleteDevice)
                 */
                if( NULL != devExt->pagingPathUnlockHandle )
                {
                    DBGOUT(( "UNLOCKing some driver code (non-pageable) (b/c paging path)" ));
                    MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                    devExt->pagingPathUnlockHandle = NULL;
                }

                if( NULL != devExt->initUnlockHandle )
                {
                    DBGOUT(( "UNLOCKing some driver code (non-pageable) (b/c init conditions)" ));
                    MmUnlockPagableImageSection( devExt->initUnlockHandle );
                    devExt->initUnlockHandle = NULL;
                }


                /*
                 *  Detach our device object from the lower 
                 *  device object stack.
                 */
                IoDetachDevice(devExt->topDevObj);

                /*
                 *  Delete our device object.
                 *  This will also delete the associated device extension.
                 */
                IoDeleteDevice(devExt->filterDevObj);
            }
            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
        {
            BOOLEAN fSetPagable = FALSE;  // whether we set the PAGABLE bit
                                          /// before we passed-on this IRP

            DBGOUT(( "DEVICE_USAGE_NOTIFICATION (Type==%d , InPath==%d)"
                     , irpSp->Parameters.UsageNotification.Type
                     , irpSp->Parameters.UsageNotification.InPath
                  ));
            DBGOUT(( "    [devExt=0x%08X fltrDevObj=0x%08X]", devExt, devExt->filterDevObj ));


            /*
             *  T-CHRPRI: currently, we keep track of the _number_ of
             *  hibernation and crashdump files.  But we don't take _all_
             *  the actions that should be taken when one of these files is
             *  installed on a device, because we assume that the driver
             *  we're on top of will do that (i.e., handling certain power
             *  state transitions, etc).  However, we _do_ handle paging
             *  files fully.
             */

            //
            // Make sure the Type of this UsageNotification is one that we handle
            //
            if(    irpSp->Parameters.UsageNotification.Type != DeviceUsageTypePaging
                && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeHibernation
                && irpSp->Parameters.UsageNotification.Type != DeviceUsageTypeDumpFile )
            {
                break; // out of the big switch statement (and just forward this IRP)
            }
    
            //
            // Wait on the paging path event (to prevent several instances of
            // this IRP from being processed at once)
            //
            status = KeWaitForSingleObject( &devExt->deviceUsageNotificationEvent
                                            , Executive    // wait reason
                                            , KernelMode
                                            , FALSE        // not alertable
                                            , NULL         // no timeout
                                          );


            /*
             * IMPORTANT NOTE: When to modify our DO_POWER_PAGABLE bit depends
             * on whether it needs to be set or cleared.  If the IRP indicates
             * our PAGABLE bit should be set, then we must set it _before_
             * forwarding the IRP down the driver stack (and possibly clear it
             * afterward, if lower drivers fail the IRP).  But if the IRP
             * indicates that our PAGABLE bit should be cleared, then we must
             * first forward the IRP to lower drivers, and then clear our bit
             * only if the lower drivers return STATUS_SUCCESS.
             */

            //
            // If removing last paging file from this device...
            //
            if(    irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging
                && !irpSp->Parameters.UsageNotification.InPath
                && devExt->pagingFileCount == 1       )
            {
                //
                // Set DO_POWER_PAGABLE bit (if it was set at startup).
                // If lower drivers fail this IRP, we'll clear it later.
                //
                DBGOUT(( "Removing last paging file..." ));

                if( devExt->initialFlags & DO_POWER_PAGABLE )
                {
                    DBGOUT(( "...so RE-setting PAGABLE bit" ));
                    devExt->filterDevObj->Flags |= DO_POWER_PAGABLE;
                    fSetPagable = TRUE;
                }
                else
                {
                    DBGOUT(( "...but PAGABLE bit wasn't set initially, so not setting it now." ));
                }

            }
    

            //
            // Forward the irp synchronously
            //
            IoCopyCurrentIrpStackLocationToNext( irp );
            status = CallNextDriverSync( devExt, irp );
    

            //
            // Now deal with the failure and success cases.
            //
            if( ! NT_SUCCESS(status) )
            {
                //
                // Lower drivers failed the IRP, so _undo_ any changes we
                // made before passing-on the IRP to those drivers.
                //
                if( fSetPagable )
                {
                    DBGOUT(( "IRP was failed, so UN-setting PAGABLE bit" ));
                    devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;
                }
            }
            else
            {
                //
                // Lower drivers returned SUCCESS, so we can do everything
                // that must be done in response to this IRP...
                //

                switch( irpSp->Parameters.UsageNotification.Type )
                {
                    case DeviceUsageTypeHibernation:

                        // Adjust counter
                        IoAdjustPagingPathCount( &devExt->hibernationFileCount,
                                                 irpSp->Parameters.UsageNotification.InPath );
                        DBGOUT(( "Num. Hibernation files is now %d", devExt->hibernationFileCount ));
                        ASSERT( devExt->hibernationFileCount >= 0 );
                    break;
    
                    case DeviceUsageTypeDumpFile:
                        
                        // Adjust counter
                        IoAdjustPagingPathCount( &devExt->crashdumpFileCount,
                                                 irpSp->Parameters.UsageNotification.InPath );
                        DBGOUT(( "Num. Crashdump files is now %d", devExt->crashdumpFileCount ));
                        ASSERT( devExt->crashdumpFileCount >= 0 );
                    break;
    
                    case DeviceUsageTypePaging:
                        
                        // Adjust counter
                        IoAdjustPagingPathCount( &devExt->pagingFileCount,
                                                 irpSp->Parameters.UsageNotification.InPath );
                        DBGOUT(( "Num. Paging files is now %d", devExt->pagingFileCount ));
                        ASSERT( devExt->pagingFileCount >= 0 );
    
                        //
                        // If we've just switched between being pageable<->nonpageable...
                        //
                        if(    irpSp->Parameters.UsageNotification.InPath
                            && devExt->pagingFileCount == 1  )
                        {
                            //
                            // Just added a paging file, so clear the PAGABLE
                            // flag, and lock-down the code for all routines
                            // that could be called at IRQL >= DISPATCH_LEVEL
                            // (so that they're _non-pageable_).
                            //
                            DBGOUT(( "Just added first paging file..." ));
                            DBGOUT(( "...so clearing PAGABLE bit" ));
                            devExt->filterDevObj->Flags &= ~DO_POWER_PAGABLE;
    
                            DBGOUT(( "LOCKing some driver code (non-pageable) (b/c paging path)" ));
                            devExt->pagingPathUnlockHandle = MmLockPagableCodeSection( VA_Power );  // some func that's inside the code section that we want to lock
                            ASSERT( NULL != devExt->pagingPathUnlockHandle );
                        }
                        else if (    !irpSp->Parameters.UsageNotification.InPath
                                  && devExt->pagingFileCount == 0  )
                        {
                            //
                            // Just removed the last paging file, but we
                            // already set the PAGABLE flag (if necessary)
                            // before forwarding IRP, so just remove the
                            // _paging-path_ lock from this driver. (NOTE:
                            // initial-condition lock might still be in place,
                            // but that's what we want.)
                            //
                            DBGOUT(( "UNLOCKing some driver code (pageable) (b/c paging path)" ));
                            ASSERT( NULL != devExt->pagingPathUnlockHandle );
                            MmUnlockPagableImageSection( devExt->pagingPathUnlockHandle );
                            devExt->pagingPathUnlockHandle = NULL;
                        }
                    break;
    
                    default:
                        ASSERT( FALSE );  // should never get here (b/c checked for invalid Type earlier)
    
                } //END: switch on Type of special-file


                //
                // Invalidate state, so that certain flags will get updated
                //
                IoInvalidateDeviceState( devExt->physicalDevObj );

            }//END: handling of irp success/failure cases


            //
            // Set event so that the next DEVICE_USAGE_NOTIFICATION IRP that
            // comes along can be processed.
            //
            KeSetEvent( &devExt->deviceUsageNotificationEvent
                        , IO_NO_INCREMENT
                        , FALSE
                      );
    
            //
            // Complete the irp
            //
            IoCompleteRequest( irp, IO_NO_INCREMENT );

            justReturnStatus = TRUE;
        }
        break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:
            //
            // If a paging, hibernation, or crashdump file is currently open
            // on this device, must set NOT_DISABLEABLE flag in DeviceState
            //
            if(    devExt->pagingFileCount      != 0
                || devExt->hibernationFileCount != 0
                || devExt->crashdumpFileCount   != 0  )
            {
                // Mark the device as not disableable
                PPNP_DEVICE_STATE pDeviceState;
                pDeviceState = (PPNP_DEVICE_STATE) &irp->IoStatus.Information;
                *pDeviceState |= PNP_DEVICE_NOT_DISABLEABLE;
            }

            //
            // We _did_ handle this IRP (as best we could), so set IRP's
            // status to STATUS_SUCCESS (default is STATUS_NOT_SUPPORTED)
            // before passing it down the driver stack
            //
            irp->IoStatus.Status = STATUS_SUCCESS;

            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        default:
            break;
    }



    if (justReturnStatus){
        /*
         *  We've already sent this IRP down the stack.
         */
    }
    else if (completeIrpHere){
        irp->IoStatus.Status = status;
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
    else {
        IoSkipCurrentIrpStackLocation(irp);
        status = IoCallDriver(devExt->topDevObj, irp);
    }

    return status;
}





NTSTATUS GetDeviceCapabilities(struct DEVICE_EXTENSION *devExt)
/*++

Routine Description:

    Function retrieves the DEVICE_CAPABILITIES descriptor from the device

Arguments:

    devExt - device extension for targetted device object

Return Value:

    NT status code

--*/
{
    NTSTATUS status;
    PIRP irp;

    PAGED_CODE();

    irp = IoAllocateIrp(devExt->topDevObj->StackSize, FALSE);

    if (irp){
        PIO_STACK_LOCATION nextSp = IoGetNextIrpStackLocation(irp);

        // must initialize DeviceCapabilities before sending...
        RtlZeroMemory(  &devExt->deviceCapabilities, 
                        sizeof(DEVICE_CAPABILITIES)  );
        devExt->deviceCapabilities.Size    = sizeof(DEVICE_CAPABILITIES);
        devExt->deviceCapabilities.Version = 1;

        // setup irp stack location...
        nextSp->MajorFunction = IRP_MJ_PNP;
        nextSp->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        nextSp->Parameters.DeviceCapabilities.Capabilities = 
                        &devExt->deviceCapabilities;

        /*
         *  For any IRP you create, you must set the default status
         *  to STATUS_NOT_SUPPORTED before sending it.
         */
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        status = CallNextDriverSync(devExt, irp);

        IoFreeIrp(irp);
    }
    else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ASSERT(NT_SUCCESS(status));
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\mcasample\imca\exe\mcalog.c ===
/*++

Module Name:

    MCALOG.C

Abstract:

    Sample Application for logging errors for Machine Check Architecture

Author:

    Anil Aggarwal (10/12/98)
    Intel Corporation

Revision History:

--*/

#include <windows.h>
#include <winioctl.h>
#include <stdio.h>
#include <stdlib.h>
#include <winbase.h>
#include <mce.h>
#include "imca.h"

//
// Variables for parsing command line arguments
//
extern int  opterr;
extern int  optind;
extern char *optarg;

//
// Print the usage information for MCA logging application
//

VOID
McaUsage(
    PCHAR Name
    )
{
    fprintf(stderr,"Usage\n\t%s: [-s] [-a]\n",Name);
    fprintf(stderr,"\n\t-s: Read Machine Check registers now\n");
    fprintf(stderr,"\n\t-a: Post asynchronous request for errors\n");

    ExitProcess(1);
}

//
// This routine prints the Machine Check registers
//

#if defined(_X86_)

VOID
PrintX86McaLog(
    PMCA_EXCEPTION  McaException
    )
{
    if (McaException->ExceptionType != HAL_MCA_RECORD) {
        fprintf(stderr, "Bad exception record type\n");
        //ExitProcess(1);
    }

    printf("Processor Number = %d\n", McaException->ProcessorNumber);

    printf("Bank Number = %d\n", (__int64)McaException->u.Mca.BankNumber);
    printf("Mci_Status %I64X\n", (__int64)McaException->u.Mca.Status.QuadPart);
    printf("Mci_Address %I64X\n", (__int64)McaException->u.Mca.Address.QuadPart);
    printf("Mci_Misc %I64X\n", (__int64)McaException->u.Mca.Misc);

} // PrintX86McaLog()

#define McaPrintLog   PrintX86McaLog

#endif // _X86_

#if defined(_IA64_)

#define ERROR_RECORD_HEADER_FORMAT \
             "MCA Error Record Header\n"            \
             "\tId        : 0x%I64x\n"              \
             "\tRevision  : 0x%x\n"                 \
             "\t\tMajor : %x\n"                     \
             "\t\tMinor : %x\n"                     \
             "\tSeverity  : 0x%x\n"                 \
             "\tValid     : 0x%x\n"                 \
             "\t\tPlatformId: %x\n"                 \
             "\tLength    : 0x%x\n"                 \
             "\tTimeStamp : 0x%I64x\n"              \
             "\t\tSeconds: %x\n"                    \
             "\t\tMinutes: %x\n"                    \
             "\t\tHours  : %x\n"                    \
             "\t\tDay    : %x\n"                    \
             "\t\tMonth  : %x\n"                    \
             "\t\tYear   : %x\n"                    \
             "\t\tCentury: %x\n"                    \
             "\tPlatformId: %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\n" 

VOID
PrintIa64ErrorRecordHeader(
   PERROR_RECORD_HEADER Header
   )
{
    printf( ERROR_RECORD_HEADER_FORMAT,
             (ULONGLONG) Header->Id,
             (ULONG)     Header->Revision.Revision,
             (ULONG)     Header->Revision.Major, (ULONG) Header->Revision.Minor,
             (ULONG)     Header->ErrorSeverity,
             (ULONG)     Header->Valid.Valid,
             (ULONG)     Header->Valid.OemPlatformID,
             (ULONG)     Header->Length,
             (ULONGLONG) Header->TimeStamp.TimeStamp,
             (ULONG)     Header->TimeStamp.Seconds,
             (ULONG)     Header->TimeStamp.Minutes,
             (ULONG)     Header->TimeStamp.Hours,
             (ULONG)     Header->TimeStamp.Day,
             (ULONG)     Header->TimeStamp.Month,
             (ULONG)     Header->TimeStamp.Year,
             (ULONG)     Header->TimeStamp.Century,
             (ULONG)     Header->OemPlatformId[0],
             (ULONG)     Header->OemPlatformId[1],
             (ULONG)     Header->OemPlatformId[2],
             (ULONG)     Header->OemPlatformId[3],
             (ULONG)     Header->OemPlatformId[4],
             (ULONG)     Header->OemPlatformId[5],
             (ULONG)     Header->OemPlatformId[6],
             (ULONG)     Header->OemPlatformId[7],
             (ULONG)     Header->OemPlatformId[8],
             (ULONG)     Header->OemPlatformId[9],
             (ULONG)     Header->OemPlatformId[10],
             (ULONG)     Header->OemPlatformId[11],
             (ULONG)     Header->OemPlatformId[12],
             (ULONG)     Header->OemPlatformId[13],
             (ULONG)     Header->OemPlatformId[14],
             (ULONG)     Header->OemPlatformId[15]
            );

    return;

} // PrintIa64ErrorRecordHeader()

VOID
PrintIa64McaLog(
    PMCA_EXCEPTION  McaException
    )
{

    //
    // Start by printing the record header.
    //

    PrintIa64ErrorRecordHeader( McaException );

    //
    // Then print and/or process error device specific information here.
    //
    
    return;

} // PrintIa64McaLog()

#define McaPrintLog   PrintIa64McaLog

#endif // _IA64_

//
// This routine prints a user friendly error message based on GetLastError()
//

VOID
McaPrintError(
    VOID
    )
{
    LPVOID lpMsgBuf;
    FormatMessage( 
        FORMAT_MESSAGE_ALLOCATE_BUFFER | 
        FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        GetLastError(),
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
        (LPTSTR) &lpMsgBuf,
        0,
        NULL 
    );

    fprintf(stderr, "%s\n", lpMsgBuf);

    LocalFree( lpMsgBuf );
} 

//
// Main entry point
//

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{
    CHAR            Option;
    BOOLEAN         ReadBanks = FALSE;
    BOOLEAN         PostAsyncRequest = FALSE;
    HANDLE          McaDeviceHandle;
    HANDLE          LogEvent;
    OVERLAPPED      Overlap;
    BOOL            ReturnStatus;
    DWORD           ActualCount;
    DWORD           WaitStatus;
    DWORD           NumberOfBytes;
    MCA_EXCEPTION   McaException;
    LONG            i;

    //
    // Process the command line arguments
    //
    for (i=1; i < argc; i++) {
        if (!((argv[i][0] == '-') || (argv[i][2] != 0)) ) {
            McaUsage(argv[0]);
        }

        Option = argv[i][1];

        switch (Option) {
            case 's':
                ReadBanks = TRUE;
                break;

            case 'a':
                PostAsyncRequest = TRUE;
                break;

            default:
                McaUsage(argv[0]);
        }
    }

    if ((ReadBanks != TRUE) && (PostAsyncRequest != TRUE)) {
        fprintf(stderr, "One of -s and -a options must be specified\n");
        ExitProcess(1);
    }

    if ((ReadBanks == TRUE) && (PostAsyncRequest == TRUE)) {
        fprintf(stderr, "Only one of -s and -a options can be specified\n");
        ExitProcess(1);
    }

    //
    // Open MCA device with overlap flag set
    //

    McaDeviceHandle = CreateFile(
                            MCA_DEVICE_NAME_WIN32,
                            GENERIC_READ|GENERIC_WRITE,
                            0,
                            (LPSECURITY_ATTRIBUTES)NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED, 
                            (HANDLE)NULL
                            );

    if (McaDeviceHandle == INVALID_HANDLE_VALUE)  {
        fprintf(stderr, "%s: Error 0x%lx opening MCA device\n",
                                        argv[0], GetLastError());
        ExitProcess(1);
    }

    if (ReadBanks == TRUE) {
        
            //
            // Read the error logs on all banks on all procs.
            // IOCTL_READ_BANKS will read only one error at a time. So
            // we need to keep issuing this ioctl till all the errors are read
            //
    
        do {
            ReturnStatus = DeviceIoControl(
                                McaDeviceHandle,
                                (ULONG)IOCTL_READ_BANKS,
                                NULL,
                                0,
                                &McaException,
                                sizeof(MCA_EXCEPTION),
                                &ActualCount,
                                NULL
                                );

            if (ReturnStatus == 0)  {
                //
                // Some error has occurred. Either there are no more machine
                // check errors present or the processor does not have 
                // support for Intel Machine Check Architecture
                //

                if (GetLastError() == ERROR_NOT_FOUND) {
                    fprintf(stderr, "No Machine Check errors present\n");
                } else if (GetLastError() == ERROR_FILE_NOT_FOUND) {
                    fprintf(stderr, "Intel Machine Check support not available\n");
                    ExitProcess(1);
                } else {
                    fprintf(stderr, "%s: Error 0x%lx in DeviceIoControl\n",
                                        argv[0], GetLastError());
                    ExitProcess(1);
                }

            } else {
                //
                // Successfully read the error. Print it.
                //
                McaPrintLog(&McaException);
            }

        } while (ReturnStatus != 0);
    
        //
        // We are done
        //
        return 1;
    }

    //
    // If we are here, we are supposed to post asynchronous calls to MCA driver
    //
    
    //
    // Set up structures for asynchronous call for reading the log
    // Create the event object
    //

    LogEvent = CreateEvent(
                            NULL,   // No Security Attributes
                            FALSE,  // Auto Reset Event
                            FALSE,  // Initial State = non-signaled 
                            NULL    // Unnamed object
                            );
        
    if (LogEvent == NULL) {
        fprintf(stderr, "%s: Error 0x%lx creating event\n",
                                        argv[0], GetLastError());
        ExitProcess(1);
    }

    //
    // Initialize the overlap structure
    //

    Overlap.hEvent = LogEvent; // Specify event for overlapped object
    Overlap.Offset = 0;        // Offset is zero for devices
    Overlap.OffsetHigh = 0;    // OffsetHigh is zero for devices
    
    ReturnStatus = DeviceIoControl(
                        McaDeviceHandle,
                        (ULONG)IOCTL_READ_BANKS_ASYNC,
                        NULL,
                        0,
                        &McaException,
                        sizeof(MCA_EXCEPTION),    
                        &ActualCount,
                        &Overlap
                        );

    if ((ReturnStatus == 0) && (GetLastError() != ERROR_IO_PENDING))  {
        fprintf(stderr, "%s: Error 0x%lx in IOCTL_READ_BANKS_ASYNC\n",
                    argv[0], GetLastError());
        ExitProcess(1);
    } 

    //
    // Either Ioctl was successful or IO is currently pending
    // If successful then display the log else wait for specified interval
    //
    if (ReturnStatus == TRUE) {
        //
        // Read log async returned succesfully. Display it
        //

        McaPrintLog(&McaException);

    }
            
    //
    // Wait forever to get an error
    //

    WaitStatus = WaitForSingleObject(
                                    LogEvent,
                                    INFINITE
                                    );

    if (WaitStatus == WAIT_OBJECT_0) {
                 
        //
        // The state of the event object is signalled 
        // check if the I/O operation was successful
        //

        ReturnStatus = GetOverlappedResult(
                                        McaDeviceHandle,
                                        &Overlap,
                                        &NumberOfBytes,
                                        FALSE        // Return immediately
                                        );
                                                
        if (ReturnStatus == 0) {

                fprintf(stderr, "%s: Error 0x%lx in GetOverlappedResult\n",
                                        argv[0], GetLastError());
                ExitProcess(1);
        }

        if (NumberOfBytes) {

                //
                // Print the results
                //

                McaPrintLog(&McaException);

        } else {

                //
                // Error as the I/O operation was signalled complete before 
                // timeout but no data transferred
                //

                fprintf(stderr, "%s: No data from GetOverlappedResult\n",
                                argv[0]);
                ExitProcess(1);
        }

    } else {
    
        //
        // We should not get any other return value 
        //

        fprintf(stderr, "%s: Unexpected return value from WaitForSingleObject()\n", argv[0]);
        ExitProcess(1);
    }

    CloseHandle(McaDeviceHandle);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\mcasample\imca\sys\imca.c ===
/*++

Module Name:

    mca.c

Abstract:

    Sample device driver to register itself with the HAL and log Machine Check
    Errors on a Intel Architecture Platform

Author:

Environment:

    Kernel mode

Notes:

Revision History:

--*/

#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include <ntddk.h>
#include "imca.h"

//
// Device names for the MCA driver 
//

#define MCA_DEVICE_NAME       "\\Device\\imca"      // ANSI Name
#define MCA_DEVICE_NAME_U     L"\\Device\\imca"     // Unicode Name
#define MCA_DEVICE_NAME_DOS   "\\DosDevices\\imca"  // Device Name for Win32 App

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
MCAOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
MCAClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MCAStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

ERROR_SEVERITY
MCADriverExceptionCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMCA_EXCEPTION InException
    );

VOID
MCADriverDpcCallback(
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemContext1,
    IN PVOID    SystemContext2
    );

NTSTATUS
MCACleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
McaCancelIrp(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp 
    );

NTSTATUS
MCADeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
MCAUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
MCACreateSymbolicLinkObject(
    VOID
    );

VOID
MCAProcessWorkItem(
    PVOID   Context
    );

//
// This temporary buffer holds the data between the Machine Check error 
// notification from HAL and the asynchronous IOCTL completion to the 
// application
//

typedef struct _MCA_DEVICE_EXTENSION {
    PDEVICE_OBJECT  DeviceObject;
    PIRP            SavedIrp;
    BOOLEAN         WorkItemQueued;
    WORK_QUEUE_ITEM WorkItem;
    // Place to log the exceptions. Whenever the exception callback 
    // routine is called by the HAL MCA component, record the exception here.
    // This can potentially be a link list.
    MCA_EXCEPTION   McaException; 

} MCA_DEVICE_EXTENSION, *PMCA_DEVICE_EXTENSION;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, MCACreateSymbolicLinkObject)
#endif // ALLOC_PRAGMA

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++
    Routine Description:
        This routine does the driver specific initialization at entry time

    Arguments:
        DriverObject:   Pointer to the driver object
        RegistryPath:   Path to driver's registry key

    Return Value:
        Success or failure

--*/

{
    UNICODE_STRING          UnicodeString;
    NTSTATUS                Status = STATUS_SUCCESS;
    PMCA_DEVICE_EXTENSION   Extension;
    PDEVICE_OBJECT          McaDeviceObject;
    MCA_DRIVER_INFO         McaDriverInfo;

    //
    // Create device object for MCA device.
    //

    RtlInitUnicodeString(&UnicodeString, MCA_DEVICE_NAME_U);

    //
    // Device is created as exclusive since only a single thread can send
    // I/O requests to this device
    //

    Status = IoCreateDevice(
                    DriverObject,
                    sizeof(MCA_DEVICE_EXTENSION),
                    &UnicodeString,
                    FILE_DEVICE_UNKNOWN,
                    0,
                    TRUE,
                    &McaDeviceObject
                    );

    if (!NT_SUCCESS( Status )) {
        DbgPrint("Mca DriverEntry: IoCreateDevice failed\n");
        return Status;
    }

    McaDeviceObject->Flags |= DO_BUFFERED_IO;

    Extension = McaDeviceObject->DeviceExtension;
    RtlZeroMemory(Extension, sizeof(MCA_DEVICE_EXTENSION));
    Extension->DeviceObject = McaDeviceObject;

    //
    // Make the device visible to Win32 subsystem
    //

    Status = MCACreateSymbolicLinkObject ();
    if (!NT_SUCCESS( Status )) {
        DbgPrint("Mca DriverEntry: McaCreateSymbolicLinkObject failed\n");
        return Status;
    }

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = MCAOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = MCAClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MCADeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CLEANUP] = MCACleanup;
    DriverObject->DriverUnload = MCAUnload;
    DriverObject->DriverStartIo = MCAStartIo;

    //
    // Register the driver with the HAL
    //

    McaDriverInfo.ExceptionCallback = MCADriverExceptionCallback;
    McaDriverInfo.DpcCallback = MCADriverDpcCallback;
    McaDriverInfo.DeviceContext = McaDeviceObject;

    Status = HalSetSystemInformation(
                    HalMcaRegisterDriver,
                    sizeof(MCA_DRIVER_INFO),
                    (PVOID)&McaDriverInfo
                    );

    if (!NT_SUCCESS( Status )) {
        DbgPrint("Mca DriverEntry: HalMcaRegisterDriver failed\n");
        //
        // Clean up whatever we have done so far
        //
        MCAUnload(DriverObject);
        return(STATUS_UNSUCCESSFUL);
    }

    //
    // This is the place where you would check non-volatile area (if any) for 
    // any Machine Check errros logged and process them.
    // ...
    //

    return STATUS_SUCCESS;
}

NTSTATUS
MCACreateSymbolicLinkObject(
    VOID
    )
/*++
    Routine Description:
        Makes MCA device visible to Win32 subsystem

    Arguments:
        None

    Return Value:
        Success or failure

--*/
{
    NTSTATUS        Status;
    STRING          DosString;
    STRING          NtString;
    UNICODE_STRING  DosUnicodeString;
    UNICODE_STRING  NtUnicodeString;

    //
    // Create a symbolic link for sharing. 
    //

    RtlInitAnsiString( &DosString, MCA_DEVICE_NAME_DOS );

    Status = RtlAnsiStringToUnicodeString(
                 &DosUnicodeString,
                 &DosString,
                 TRUE
                 );

    if ( !NT_SUCCESS( Status )) {
        return Status;
    }

    RtlInitAnsiString( &NtString, MCA_DEVICE_NAME );

    Status = RtlAnsiStringToUnicodeString(
                 &NtUnicodeString,
                 &NtString,
                 TRUE
                 );

    if ( !NT_SUCCESS( Status )) {
        return Status;
    }

    Status = IoCreateSymbolicLink(
        &DosUnicodeString,
        &NtUnicodeString
        );
    RtlFreeUnicodeString( &DosUnicodeString );
    RtlFreeUnicodeString( &NtUnicodeString );

    return (Status);
}

//
// Dispatch routine for close requests
//

NTSTATUS
MCAClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        Close dispatch routine

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        Success or failure

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;

    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = Status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return (Status);
}

NTSTATUS
MCAOpen(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        This routine is the dispatch routine for create/open requests.

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        Success or failure

--*/

{
    //
    // Complete the request and return status.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return (STATUS_SUCCESS);
}

ERROR_SEVERITY
MCADriverExceptionCallback(
    IN PDEVICE_OBJECT DeviceObject,
    IN PMCA_EXCEPTION InException
    )

/*++
    Routine Description:
        This is the callback routine for MCA exception. It was registered 
        by this driver at INIT time with the HAL as a callback when a 
        non-restartable error occurs. This routine simply copies the 
        information to a platform specific area

        NOTE: If the information needs to be saved in NVRAM, this is the place
        to do it.

        Once you return from this callback, the system is going to bugcheck.

    Arguments:
        DeviceObject:   Pointer to the device object
        InException:    Exception information record

    Return Value:
        None

--*/

{
    PMCA_DEVICE_EXTENSION   Extension = DeviceObject->DeviceExtension;
    PCHAR                   Destination, Source;
    UCHAR                   Bytes;

    //
    // An exception has occured on a processor.
    // Perform any vendor specific action here like saving stuff in NVRAM
    // NOTE : No system services of any kind can be used here.
    //

    //
    // Save the exception from HAL. May want to use link list for these 
    // exceptions. 
    //

    Destination = (PCHAR)&(Extension->McaException); // Put your platform 
                                                     // specific destination
    Source = (PCHAR)InException;

    //
    // Copy from source to destination here
    //

#if defined(_IA64_)

    //
    // Return information to the generic HAL MCA handler.
    //
    // Update it accordingly here, the default value being the ERROR_SEVERITY value
    // in the MCA exception.
    //

    return( InException->ErrorSeverity );

#endif // _IA64_

}

//
// DPC routine for IRP completion
//

VOID
MCADriverDpcCallback(
    IN PKDPC    Dpc,
    IN PVOID    DeferredContext,
    IN PVOID    SystemContext1,
    IN PVOID    SystemContext2
    )

/*++
    Routine Description:
        This is the DPC - callback routine for MCA exception. It was registered 
        by this driver at INIT time with the HAL as a DPC callback when a 
        restartable error occurs (which causes Machine Check exception)

    Arguments:
        Dpc:                The DPC Object itself
        DefferedContext:    Pointer to the device object
        SystemContext1:     Not used
        SystemContext2:     Not used

    Return Value:
        None

--*/

{
    PMCA_DEVICE_EXTENSION   Extension;

    Extension = ((PDEVICE_OBJECT)DeferredContext)->DeviceExtension;

    if (Extension->SavedIrp == NULL) {
        //
        // We got an MCA exception but no app was asking for anything.
        //
        return;
    }

    //
    // If we have reached this point, it means that the exception was
    // restartable. Since we cannot read the log at Dispatch level,
    // queue a work item to read the Machine Check log at Passive level
    //

    if (Extension->WorkItemQueued == FALSE) {

        //
        // Set a boolean to indicate that we have already queued a work item
        //
        Extension->WorkItemQueued = TRUE;

        //
        // Initialize the work item
        //
        ExInitializeWorkItem(&Extension->WorkItem, 
                             (PWORKER_THREAD_ROUTINE)MCAProcessWorkItem, 
                             (PVOID)DeferredContext
                             );

        //
        // Queue the work item for processing at PASSIVE level
        //
        ExQueueWorkItem(&Extension->WorkItem, CriticalWorkQueue);
    }

}

VOID
MCAProcessWorkItem(
    PVOID   Context
    )

/*++
    Routine Description:
        This routine gets invoked when a work item is queued from the DPC
        callback routine for a restartable machine check error.

        Its job is to read the machine check registers and copy the log
        to complete the asynchronous IRP

    Arguments:
        Context :  Pointer to the device object

    Return Value:
        None

--*/

{

    PMCA_DEVICE_EXTENSION   Extension;
    KIRQL                   CancelIrql;
    ULONG                   ReturnedLength;
    NTSTATUS                Status;

    Extension = ((PDEVICE_OBJECT)Context)->DeviceExtension;

    //
    // Mark this IRP as non-cancellable
    //
    IoAcquireCancelSpinLock(&CancelIrql);
    if (Extension->SavedIrp->Cancel == TRUE) {
        
        IoReleaseCancelSpinLock(CancelIrql);
        
    } else {
        
        IoSetCancelRoutine(Extension->SavedIrp, NULL);
        IoReleaseCancelSpinLock(CancelIrql);
        
	    //
	    // Call HalQuerySystemInformation() to obtain MCA log.
	    //
	
	    Status = HalQuerySystemInformation(
	                HalMcaLogInformation,
	                sizeof(MCA_EXCEPTION),
	                Extension->SavedIrp->AssociatedIrp.SystemBuffer,
	                &ReturnedLength
	                );
	
	    ASSERT(Status != STATUS_NO_SUCH_DEVICE);
	    ASSERT(Status != STATUS_NOT_FOUND);
	
	    IoStartPacket(((PDEVICE_OBJECT)Context), Extension->SavedIrp, 0, NULL);
	
	    Extension->SavedIrp = NULL;
	    Extension->WorkItemQueued = FALSE;
    }
}

VOID
MCAStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        This routine completes the async call from the app

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        None

--*/

{
    //
    // The system Buffer has already been setup
    //

    Irp->IoStatus.Information = sizeof(MCA_EXCEPTION);
    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    IoStartNextPacket(DeviceObject, TRUE);  
}

VOID
McaCancelIrp(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP Irp 
    )

/*++

    Routine Description:
        This function gets called when the IRP is cancelled. When this routine 
        is called, we hold the cancel spin lock and we are at DISPATCH level

    Arguments:
        DeviceObject and the Irp to be cancelled.

    Return Value:
        None.

--*/

{
    ((PMCA_DEVICE_EXTENSION)(DeviceObject->DeviceExtension))->SavedIrp = NULL;

    Irp->IoStatus.Status = STATUS_CANCELLED;
    Irp->IoStatus.Information = 0;

    IoReleaseCancelSpinLock(Irp->CancelIrql);

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
}

NTSTATUS
MCADeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        This routine is the dispatch routine for the IOCTL requests to driver. 
        It accepts an I/O Request Packet, performs the request, and then 
        returns with the appropriate status.

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        Success or failure

--*/

{
    NTSTATUS                Status;
    PIO_STACK_LOCATION      IrpSp;
    PMCA_DEVICE_EXTENSION   Extension = DeviceObject->DeviceExtension;
    KIRQL                   CancelIrql;
    ULONG                   ReturnedLength;
    ULONG                   PhysicalAddress;
    KIRQL                   OldIrql;

    //
    // Get a pointer to the current stack location in the IRP.  This is 
    // where the function codes and parameters are stored.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // The individual IOCTLs will return errors if HAL MCA is not installed
    //

    //
    // Switch on the IOCTL code that is being requested by the user.  If the
    // operation is a valid one for this device do the needful.
    //

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

        case IOCTL_READ_BANKS: 

            //
            // we need a user buffer for this call to complete
            // Our user buffer is in SystemBuffer 
            //
            if (Irp->AssociatedIrp.SystemBuffer == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }


            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                    sizeof(MCA_EXCEPTION)) {

                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            
            //
            // Call HalQuerySystemInformation() to obtain MCA log.
            // This call can also fail if the processor does not support
            // Intel Machine Check Architecture
            //

            Status = HalQuerySystemInformation(
                        HalMcaLogInformation,
                        sizeof(MCA_EXCEPTION),
                        Irp->AssociatedIrp.SystemBuffer,
                        &ReturnedLength
                        );

            if (NT_SUCCESS(Status)) {
                Irp->IoStatus.Information = ReturnedLength;
            } else {

                if (Status == STATUS_NO_SUCH_DEVICE) {
                    //
                    // MCA support not available\n");
                    //
                    NOTHING;
                }

                if (Status == STATUS_NOT_FOUND) {
                    //
                    // No machine check errors present\n");
                    //
                    NOTHING;
                }

                Irp->IoStatus.Information = 0;
            }

            break;

        case IOCTL_READ_BANKS_ASYNC: 

            if (Irp->AssociatedIrp.SystemBuffer == NULL) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }

            if (IrpSp->Parameters.DeviceIoControl.OutputBufferLength !=
                    sizeof(MCA_EXCEPTION)) {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
            
            //
            // Implementation Note:
            //
            // Our Async model is such that the next DeviceIoControl
            // does not start from the app until the previous one
            // completes (asynchronously). Since there is no inherent
            // parallelism that is needed here, we do not have to worry
            // about protecting data integrity in the face of more than
            // one app level ioctls active at the same time. 
            //

            // 
            // asynchronous reads provide a mechanism for the
            // app to asynchronously get input from the HAL on an
            // exception. This request is marked as pending at this time
            // but it will be completed when an MCA exception occurs.
            //

            IoMarkIrpPending(Irp);

            //
            // Complete the processing in StartIo Dispatch routine
            // ASSERT: at any given time there is only 1 async call pending
            // So just save the pointer
            //

            if (Extension->SavedIrp == NULL) {
                Extension->SavedIrp = Irp;
            } else {
                //
                // We can have ONLY one outstanding ASYNC request
                //
                Status = STATUS_DEVICE_BUSY;
                break;
            }

            //
            // Set the IRP to cancellable state
            //
            IoAcquireCancelSpinLock(&CancelIrql);
            IoSetCancelRoutine(Irp, McaCancelIrp);
            IoReleaseCancelSpinLock(CancelIrql);

            return(STATUS_PENDING);

            break;

        default:

            //
            // This should not happen
            //
                
            DbgPrint("MCA driver: Bad ioctl\n");
            Status = STATUS_NOT_IMPLEMENTED;

            break;
    }

    //
    // Copy the final status into the return status, complete the request and
    // get out of here.
    //

    if (Status != STATUS_PENDING) {
        
        //
        // Complete the Io Request
        //

        Irp->IoStatus.Status = Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return (Status);
}

NTSTATUS
MCACleanup(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++
    Routine Description:
        This is the dispatch routine for cleanup requests.
        All queued IRPs are completed with STATUS_CANCELLED.

    Arguments:
        DeviceObject:   Pointer to the device object
        Irp:            Incoming Irp

    Return Value:
        Success or failure

--*/

{
    PIRP                    CurrentIrp;
    PMCA_DEVICE_EXTENSION   Extension = DeviceObject->DeviceExtension;

    //
    // Complete all queued requests with STATUS_CANCELLED.
    //

    if (Extension->SavedIrp != NULL) {

        CurrentIrp = Extension->SavedIrp;

        //
        // Acquire the Cancel Spinlock
        //

        IoAcquireCancelSpinLock(&CurrentIrp->CancelIrql);

        Extension->SavedIrp = NULL;

        if (CurrentIrp->Cancel == TRUE) {

            //
            // Cancel routine got called for this one.
            // No need to do anything else
            //

            IoReleaseCancelSpinLock(CurrentIrp->CancelIrql);

        } else {

            if (CurrentIrp->CancelRoutine == NULL) {
                //
                // Release the Cancel Spinlock
                //

                IoReleaseCancelSpinLock(CurrentIrp->CancelIrql);


            } else {
                (CurrentIrp->CancelRoutine)(DeviceObject, CurrentIrp );
            }
        }

    }

    //
    // Complete the Cleanup Dispatch with STATUS_SUCCESS
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return(STATUS_SUCCESS);
}

VOID
MCAUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++
    Routine Description:
        Dispatch routine for unloads

    Arguments:
        DeviceObject:   Pointer to the device object

    Return Value:
        None

--*/

{
    NTSTATUS        Status;
    STRING          DosString;
    UNICODE_STRING  DosUnicodeString;

    //
    // Delete the user visible device name. 
    //

    RtlInitAnsiString( &DosString, MCA_DEVICE_NAME_DOS );

    Status = RtlAnsiStringToUnicodeString(
                 &DosUnicodeString,
                 &DosString,
                 TRUE
                 );

    if ( !NT_SUCCESS( Status )) {
        DbgPrint("MCAUnload: Error in RtlAnsiStringToUnicodeString\n");
        return;
    }
    
    Status = IoDeleteSymbolicLink(
                    &DosUnicodeString
                    );
               
    RtlFreeUnicodeString( &DosUnicodeString );
    
    //
    // Delete the device object
    //

    IoDeleteDevice(DriverObject->DeviceObject);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\cpqosb.c ===
/*
 *  CPQOSB.C - COMPAQ OSB PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from COMPAQ OSB Data Sheet
 *
 */

#include "local.h"

/****************************************************************************
 *
 *  CPQOSBSetIRQ - Set a CPQOSB PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQOSBSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOldValue, bOldIndex;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Convert link to index.
    //
    bLink+=3;

    //
    // Save the old index value.
    //
    bOldIndex=READ_PORT_UCHAR((PUCHAR)0xC00);

    //
    // Setup to process the desired link.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bLink);

    //
    // Read the old IRQ value.
    //
    bOldValue=(UCHAR)(READ_PORT_UCHAR((PUCHAR)0xC01) & 0xf0);

    bOldValue|=bIRQNumber;
    
    //
    // Set the OSB IRQ register.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC01, bOldValue);

    //
    // Restore the old index value.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bOldIndex);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  CPQOSBGetIRQ - Get the IRQ of a CPQOSB PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQOSBGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOldValue, bOldIndex;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Convert link to index.
    //
    bLink+=3;

    //
    // Save the old index value.
    //
    bOldIndex=READ_PORT_UCHAR((PUCHAR)0xC00);

    //
    // Setup to read the correct link.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bLink);

    bOldValue=READ_PORT_UCHAR((PUCHAR)0xC01);
    
    *pbIRQNumber=bOldValue&0x0f;

    //
    // Restore the old index value.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bOldIndex);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  CPQOSBValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
CPQOSBValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, CPQOSBValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
CPQOSBValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    //
    // If any link is above 4, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>4)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\cpq1000.c ===
/*
 *  CPQ1000.C - COMPAQ 1000 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from COMPAQ 1000 Data Sheet
 *
 */

#include "local.h"

const UCHAR LinkToIndex[]={0, 1, 6, 7, 4, 5};

/****************************************************************************
 *
 *  CPQ1000SetIRQ - Set a CPQ1000 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQ1000SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOldValue, bOldIndex, bIndex;
    //
    // Validate link number.
    //
    if (bLink > 6) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Get the index from the link.
    //
    bIndex=LinkToIndex[bLink-1];

    //
    // Save the old index value.
    //
    bOldIndex=READ_PORT_UCHAR((PUCHAR)0xC00);
    
    //
    // Setup to process the desired link.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bIndex);

    //
    // Read the old IRQ value.
    //
    bOldValue=(UCHAR)(READ_PORT_UCHAR((PUCHAR)0xC01) & 0x0f);

    bOldValue|=(bIRQNumber<<4);
    
    //
    // Set the VESUVIUS IRQ register.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC01, bOldValue);

    //
    // Restore the old index value.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bOldIndex);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  CPQ1000GetIRQ - Get the IRQ of a CPQ1000 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
CPQ1000GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOldValue, bOldIndex, bIndex;
    //
    // Validate link number.
    //
    if (bLink > 6) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Get the index from the link.
    //
    bIndex=LinkToIndex[bLink-1];

    //
    // Save the old index value.
    //
    bOldIndex=READ_PORT_UCHAR((PUCHAR)0xC00);

    //
    // Setup to read the correct link.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bIndex);

    bOldValue=READ_PORT_UCHAR((PUCHAR)0xC01);
    
    *pbIRQNumber=(bOldValue>>4);

    //
    // Restore the old index value.
    //
    WRITE_PORT_UCHAR((PUCHAR)0xC00, bOldIndex);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  CPQ1000ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
CPQ1000ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, CPQ1000ValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
CPQ1000ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    //
    // If any link is above 6, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>6)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\cx5520.c ===
/*
 *  Cx5520.C - Cyrix Cx5520 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from Cyrix Cx5520 Data Sheet
 *
 */

#include "local.h"

/****************************************************************************
 *
 *  Cx5520SetIRQ - Set a Cx5520 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Cx5520SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR bOldValue, bNewValue, bOffset;
    
    //
    // Validate link number.
    //
    if (bLink > 4)
        return(PCIMP_INVALID_LINK);

    bOffset = (UCHAR)(((bLink - 1) / 2) + 0x5C);
    
    bOldValue = ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink & 1)
    {
        bNewValue = (UCHAR)((bOldValue & 0xF0) | (bIRQNumber & 0x0F));  
    }
    else
    {
        bNewValue = (UCHAR)((bOldValue & 0x0F) | (bIRQNumber << 4));        
    }
    
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bNewValue);
    
    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Cx5520GetIRQ - Get the IRQ of a Cx5520 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Cx5520GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR bOldValue, bOffset;
    
    //
    // Validate link number.
    //
    if (bLink > 4)
        return(PCIMP_INVALID_LINK);
    
    bOffset = (UCHAR)(((bLink - 1) / 2) + 0x5C);
    
    bOldValue = ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (!(bLink & 1))
    {
        bOldValue >>= 4;
    }
    
    *pbIRQNumber = (UCHAR)(bOldValue & 0x0F);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Cx5520ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
Cx5520ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, Cx5520ValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
Cx5520ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    return ((GetMaxLink(piihIRQInfoHeader) > 4)? PCIMP_FAILURE : PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\compaq3.c ===
/*
 *  Comap3.C - Compaq MISC 3 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from Compaq MISC 3 Data Sheet
 *
 */

#include "local.h"

/****************************************************************************
 *
 *  Compaq3SetIRQ - Set a MISC 3 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Compaq3SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bBus, bDevFunc;

    //
    // Validate link number.
    //
    if (bLink >= 10 && bLink <= 12) {
        bLink -= 10;
        bBus = (UCHAR)bBusPIC;
        bDevFunc = (UCHAR)bDevFuncPIC;
    }
    else if (bLink >= 20 && bLink <= 25) {
        bLink -= 20;
        bBus = 0;
        bDevFunc = 0x78;
    }
    else {
        return(PCIMP_INVALID_LINK);
    }

    //
    // Write to the Interrupt Index Register (offset AE)
    //
    WriteConfigUchar(bBus, bDevFunc, (UCHAR)0xAE, bLink);

    //
    // Are we enabling/disabling IRQ?
    //
    if (bIRQNumber==0)
        bIRQNumber|=1;  // Disable IRQ.
    else
        bIRQNumber<<=4; // Enable the specified IRQ.

    //
    // Write to the interrupt map register.
    //
    WriteConfigUchar(bBus, bDevFunc, (UCHAR)0xAF, bIRQNumber);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Compaq3GetIRQ - Get the IRQ of a MISC 3 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
Compaq3GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bBus, bDevFunc;

    //
    // Validate link number.
    //
    if (bLink >= 10 && bLink <= 12) {
        bLink-=10;
        bBus = (UCHAR)bBusPIC;
        bDevFunc = (UCHAR)bDevFuncPIC;
    }
    else if (bLink >= 20 && bLink <= 25) {
        bLink -= 20;
        bBus = 0;
        bDevFunc = 0x78;
    }
    else {
        return(PCIMP_INVALID_LINK);
    }
    
    //
    // Write to the Interrupt Index Register.
    //
    WriteConfigUchar(bBus, bDevFunc, (UCHAR)0xAE, bLink);

    //
    // Read the old MISC 3 IRQ register.
    //
    *pbIRQNumber=(ReadConfigUchar(bBus, bDevFunc, (UCHAR)0xAF)>>4);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Compaq3ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
Compaq3ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, Compaq3ValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
Compaq3ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PIRQINFO    pii=(PIRQINFO)(((PUCHAR) piihIRQInfoHeader)+sizeof(IRQINFOHEADER));
    ULONG       i, j;
    ULONG       cEntries=(piihIRQInfoHeader->TableSize-sizeof(IRQINFOHEADER))/sizeof(IRQINFO);

    PAGED_CODE();

    for (i=0; i<cEntries; i++) {

        for (j=0; j<4; j++) {

            if (    pii->PinInfo[j].Link == 0 ||
                (pii->PinInfo[j].Link >= 8 && pii->PinInfo[j].Link <= 12) ||
                (pii->PinInfo[j].Link >= 20 && pii->PinInfo[j].Link <= 25))

                continue;

            return PCIMP_FAILURE;
        }
        pii++;
    }

    return(i? PCIMP_SUCCESS : PCIMP_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\mcasample\imca\sys\imca.h ===
/*++

Module Name:

    appmca.h

Abstract:

	Defines related to MCA for app and driver - device names, function codes 
	and ioctls

Author:

Revision History:


--*/

#ifndef APPMCA_H
#define APPMCA_H

//
// 16 bit device type definition.
// Device types 0-32767 are reserved by Microsoft.
//

#define FILE_DEVICE_MCA                     0xb000

//
// 12 bit function codes
// Function codes 0-2047 are reserved by Microsoft.
//

#define FUNCTION_READ_BANKS         0xb00
#define FUNCTION_READ_BANKS_ASYNC   0xb01

#define IOCTL_READ_BANKS  (CTL_CODE(FILE_DEVICE_MCA, FUNCTION_READ_BANKS,\
  		(METHOD_BUFFERED),(FILE_READ_ACCESS|FILE_WRITE_ACCESS)))

#define IOCTL_READ_BANKS_ASYNC  (CTL_CODE(FILE_DEVICE_MCA, \
  		FUNCTION_READ_BANKS_ASYNC,(METHOD_BUFFERED), \
  		(FILE_READ_ACCESS|FILE_WRITE_ACCESS)))

//
// IA64 uses MCA log terminology instead of banks.
//

#define FUNCTION_READ_MCALOG        FUNCTION_READ_BANKS
#define FUNCTION_READ_MCALOG_ASYNC  FUNCTION_READ_BANKS_ASYNC

#define IOCTL_READ_MCALOG  (CTL_CODE(FILE_DEVICE_MCA, FUNCTION_READ_MCALOG,\
  		(METHOD_BUFFERED),(FILE_READ_ACCESS|FILE_WRITE_ACCESS)))

#define IOCTL_READ_MCALOG_ASYNC  (CTL_CODE(FILE_DEVICE_MCA, \
  		FUNCTION_READ_MCALOG_ASYNC,(METHOD_BUFFERED), \
  		(FILE_READ_ACCESS|FILE_WRITE_ACCESS)))

#if defined(_X86_)

//
// HalMcaRegisterDriver:
//  Define x86 ERROR_SEVERITY as VOID for compatibility with IA64 prototype.
//  
// 10/21/2000:
//  It is being proposed to modify PDRIVER_EXCPTN_CALLBACK definition for x86 to match
//  the IA64 definition as a function pointer type returning an ERROR_SEVERITY value.
//  This change was created to allow OEM MCA handlers to return information to the HAL 
//  as a hint how to continue the processing of the MCA event.
//

#define ERROR_SEVERITY VOID

#endif // _X86_

//
// Name that Win32 front end will use to open the MCA device
//

#define MCA_DEVICE_NAME_WIN32      "\\\\.\\imca"

#endif // APPMCA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\eagle.c ===
/*
 *  EAGLE.C - VLSI Eagle PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from VLSI VL82C534 Spec
 *
 */

#include "local.h"

#define NUM_EAGLE_LINKS 8

const UCHAR rgbIRQToBit[16] = {
//  IRQ=   0  1     2  3   4   5   6   7   8   9   10  11  12   13  14  15
    0xFF, 8, 0xFF, 9, 10, 11, 12,  0,  1,  2,  3,  4,  5, 0xFF,  6,  7,
};
const UCHAR rgbBitToIRQ[16] = {
//  Bit=0  1  2  3   4   5   6   7    8   9  10  11  12  13    14    15
    7, 8, 9, 10, 11, 12, 14, 15,  1,  3,  4,  5,  6, 0xFF, 0xFF, 0xFF, 
};

/****************************************************************************
 *
 *  EagleUpdateSerialIRQ - Set or Reset the Eagle Serial IRQ registers
 *
 *  Not exported.
 *
 *  ENTRY:  bIRQ is the IRQ to modify.
 *
 *      fSet is TRUE to set bit, FALSE to reset bit.
 *
 *  EXIT:   None.
 *
 ***************************************************************************/
static void CDECL
EagleUpdateSerialIRQ(UCHAR bIRQ, ULONG fSet)
{
    UCHAR   bBitIndex, bReg;
    USHORT  wBit, wSerialIRQConnection;

    //
    // Validate bIRQ as a serial IRQ.
    //
    if (!bIRQ)
        return;
    bBitIndex=rgbIRQToBit[bIRQ];
    if (bBitIndex==0xFF)
        return;
    wBit=1<<bBitIndex;

    for (bReg=0x70; bReg<=0x72; bReg+=2) {

        wSerialIRQConnection=ReadConfigUshort(  bBusPIC, bDevFuncPIC,
                            bReg);

        if (fSet)
            wSerialIRQConnection|=wBit;
        else
            wSerialIRQConnection&=~wBit;

        WriteConfigUshort(  bBusPIC, bDevFuncPIC, bReg,
                    wSerialIRQConnection);
    }
}

/****************************************************************************
 *
 *  VLSIEagleSetIRQ - Set an Eagle PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    ULONG   ulEagleRegister;
    UCHAR   bOldIRQ;
    ULONG   fUsingOldIRQ;
    ULONG   i;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink >= NUM_EAGLE_LINKS) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // First, set the Eagle Interrupt Connection Register.
    //
    ulEagleRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x74);
    bOldIRQ=(UCHAR)((ulEagleRegister >> (bLink*4))&0xF);
    ulEagleRegister&=~(0xF << (bLink*4));
    ulEagleRegister|=(bIRQNumber << (bLink*4));
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x74, ulEagleRegister);

    //
    // Determine if we are still using the old IRQ.
    //
    fUsingOldIRQ=FALSE;
    for (i=0; i<NUM_EAGLE_LINKS; i++) {
        
        if ((ulEagleRegister >> (bLink*4))==bOldIRQ) {

            fUsingOldIRQ=TRUE;
        }
    }

    //
    // If not using old IRQ, enable the serial IRQs.
    //
    if (!fUsingOldIRQ) {

        EagleUpdateSerialIRQ(bOldIRQ, FALSE);
    }

    //
    // Prevent serial IRQs on the new IRQ.
    //
    EagleUpdateSerialIRQ(bIRQNumber, TRUE);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIEagleGetIRQ - Get the IRQ of an Eagle PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    ULONG   ulEagleRegister;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink >= NUM_EAGLE_LINKS) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Read in the Eagle Interrupt Connection Register.
    //
    ulEagleRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x74);

    //
    // Find the link's IRQ value.
    //
    *pbIRQNumber=(UCHAR)((ulEagleRegister >> (bLink*4)) & 0xF);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIEagleSetTrigger - Set the IRQ triggering values for the Eagle.
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleSetTrigger(ULONG ulTrigger)
{
    USHORT  wAssertionRegister;
    ULONG   i;
    UCHAR   bBitIndex;

    wAssertionRegister=0;

    //
    // For each IRQ...
    //
    for (i=0; i<16; i++)
    {
        //
        // If this is to be set level...
        //
        if (ulTrigger & (1<<i)) {

            //
            // If this is not a levelable IRQ, bail.
            //
            bBitIndex=rgbIRQToBit[i];
            if (bBitIndex==0xFF)
                return(PCIMP_INVALID_IRQ);

            //
            // Set the corresponding bit in our new mask.
            //
            wAssertionRegister|=1<<bBitIndex;
        }
    }

    //
    // Set the Assertion Register.
    //
    WriteConfigUshort(bBusPIC, bDevFuncPIC, 0x88, wAssertionRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIEagleGetTrigger - Get the IRQ triggering values for the Eagle.
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   TRUE if successful.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIEagleGetTrigger(PULONG pulTrigger)
{
    USHORT  wAssertionRegister;
    ULONG   i;

    //
    // Read in the Interrupt Assertion Level register.
    //
    wAssertionRegister=ReadConfigUshort(bBusPIC, bDevFuncPIC, 0x88);

    //
    // Clear the return buffer.
    //
    *pulTrigger = 0;

    //
    // For each bit...
    //
    for (i=0; i<16; i++)
    {
        //
        // If the bit set, and this bit corresponds to an IRQ...
        //
        if (    (wAssertionRegister & (1 << i)) &&
            (rgbBitToIRQ[i]!=0xFF))
        {
            //
            // Set the corresponding bit in the
            // return buffer.
            //
            *pulTrigger |= 1 << rgbBitToIRQ[i];
        }
    }

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIEagleValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
VLSIEagleValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, VLSIEagleValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
VLSIEagleValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if (GetMaxLink(piihIRQInfoHeader)>NUM_EAGLE_LINKS) {

        return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\m1523.c ===
/*
 *  M1523.C - ALI M1523 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from ALI M1523 Data Sheet
 *
 */

#include "local.h"

LOCAL_DATA  const UCHAR IrqToMaskTable[]={  0x00,0x00,0x00,0x02,
                                        0x04,0x05,0x07,0x06,
                                        0x00,0x01,0x03,0x09,
                                        0x0b,0x00,0x0d, 0x0f};

LOCAL_DATA  const UCHAR MaskToIRQTable[]={  0x00,0x09,0x03,0x0a,
                                        0x04,0x05,0x07,0x06,
                                        0x00,0x0b,0x00,0x0c,
                                        0x00, 0x0e,0x00,0x0f};

/****************************************************************************
 *
 *  M1523SetIRQ - Set a M1523 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1523SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 8) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Get the IRQ number from the look-up table.
    //
    bIRQNumber=IrqToMaskTable[bIRQNumber&0x0f];

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x48;

    //
    // Read the old M1523 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the M1523 IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bOldValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  M1523GetIRQ - Get the IRQ of a M1523 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1523GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 8) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x48;

    //
    // Read the old M1523 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=MaskToIRQTable[bOldValue&0x0f];

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  M1523ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
M1523ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, M1523ValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
M1523ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    //
    // If any link is above 8, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>8)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\m1533.c ===
/*
 *  M1533.C - ALI M1533 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from ALI M1533 Data Sheet
 *
 */

#include "local.h"

LOCAL_DATA  const UCHAR IrqToMaskTable[]={  0x00,0x00,0x00,0x02,
                        0x04,0x05,0x07,0x06,
                        0x00,0x01,0x03,0x09,
                        0x0b,0x00,0x0d, 0x0f};

LOCAL_DATA  const UCHAR MaskToIRQTable[]={      0x00,0x09,0x03,0x0a,
                        0x04,0x05,0x07,0x06,
                        0x00,0x0b,0x00,0x0c,
                        0x00, 0x0e,0x00,0x0f};

/****************************************************************************
 *
 *  M1533SetIRQ - Set a M1533 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1533SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 8 && bLink != 0x59) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Get the IRQ number from the look-up table.
    //
    bIRQNumber=IrqToMaskTable[bIRQNumber&0x0f];

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x48;

    //
    // Read the old M1533 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the M1533 IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bOldValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  M1533GetIRQ - Get the IRQ of a M1533 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
M1533GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 8 && bLink != 0x59) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x48;

    //
    // Read the old M1533 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=MaskToIRQTable[bOldValue&0x0f];

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  M1533ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
M1533ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, M1533ValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
M1533ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    UCHAR bMaxLink = GetMaxLink(piihIRQInfoHeader);
    
    PAGED_CODE();

    if (bMaxLink <= 0x08)
        return PCIMP_SUCCESS;

    if (bMaxLink == 0x59)
        return PCIMP_SUCCESS;

    return PCIMP_FAILURE;       
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\mercury.c ===
/*
 *  MERCURY.C - Intel Mercury PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from Intel 82420/82430 PCISet EISA Bridge doc,
 *  82374EB/SB EISA System Component (ESC) spec.
 *
 */

#include "local.h"

/****************************************************************************
 *
 *  MercurySetIRQ - Set a Mercury PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
MercurySetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Use 0x80 to disable.
    //
    if (!bIRQNumber)
        bIRQNumber=0x80;

    //
    // Start talking to interrupt controller.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, 0x02);
    WRITE_PORT_UCHAR((PUCHAR)0x23, 0x0f);

    //
    // Set our link to the new IRQ.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, (UCHAR)(bLink+0x60));
    WRITE_PORT_UCHAR((PUCHAR)0x23, bIRQNumber);

    //
    // Done talking to interrupt controller.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, 0x02);
    WRITE_PORT_UCHAR((PUCHAR)0x23, 0x00);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  MercuryGetIRQ - Get the IRQ of a Mercury PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
MercuryGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Start talking to interrupt controller.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, 0x02);
    WRITE_PORT_UCHAR((PUCHAR)0x23, 0x0f);

    //
    // Get our link's IRQ.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, (UCHAR)(bLink+0x60));
    *pbIRQNumber=READ_PORT_UCHAR((PUCHAR)0x23);

    //
    // Done talking to interrupt controller.
    //
    WRITE_PORT_UCHAR((PUCHAR)0x22, 0x02);
    WRITE_PORT_UCHAR((PUCHAR)0x23, 0x00);

    //
    // Return 0 if disabled.
    //
    if (*pbIRQNumber & 0x80)
        *pbIRQNumber=0;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  MercuryValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
MercuryValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, MercuryValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
MercuryValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    UCHAR bMin=GetMinLink(piihIRQInfoHeader);
    UCHAR bMax=GetMaxLink(piihIRQInfoHeader);

    PAGED_CODE();

    if (bMax<=0x04) {

        return(PCIMP_SUCCESS);
    }

    if ((bMin<0x60) || (bMax>0x63)) {

        return(PCIMP_FAILURE);
    }

    NormalizeLinks(piihIRQInfoHeader, (UCHAR)(0-0x5F));

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\nec.c ===
/*
 *  NEC.C - NEC C98Bus Bridge chipset routines.
 *
 */

#include "local.h"
 
/****************************************************************************
 *
 *  NECSetIRQ - Set a Triton PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    //
    // Validate link number.
    //
    if (bLink < 0x60) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Use 0x80 to disable.
    //
    if (!bIRQNumber)
        bIRQNumber=0x80;

    //
    // Set the Triton IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bLink, bIRQNumber);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NECGetIRQ - Get the IRQ of a Triton PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    //
    // Validate link number.
    //
    if (bLink < 0x60) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Store the IRQ value.
    //
    *pbIRQNumber=ReadConfigUchar(bBusPIC, bDevFuncPIC, bLink);

    //
    // Return 0 if disabled.
    //
    if (*pbIRQNumber & 0x80)
        *pbIRQNumber=0;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NECSetTrigger - Set the IRQ triggering values for an Intel system.
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECSetTrigger(ULONG ulTrigger)
{
    // PC-9800 can not handle IRQ trigger.
    // we have nothing to do.

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NECGetTrigger - Get the IRQ triggering values for an Intel system.
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NECGetTrigger(PULONG pulTrigger)
{
    // PC-9800 can not handle IRQ trigger.
    // We fake IRQ triggering value so that PCI.VXD works fine.

    *pulTrigger = 0xffff;
    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NECValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
NECValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, NECValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
NECValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if ((ulFlags & PCIMP_VALIDATE_SOURCE_BITS)==PCIMP_VALIDATE_SOURCE_PCIBIOS) {

        //
        // If all links are above 60, we they are config space.
        //
        if (GetMinLink(piihIRQInfoHeader)>=0x60)
            return(PCIMP_SUCCESS);

        //
        // If there are links above 4, we are clueless.
        //
        if (GetMaxLink(piihIRQInfoHeader)>0x04)
            return(PCIMP_FAILURE);

        //
        // Assume 1,2,3,4 are the 60,61,62,63 links.
        //
        NormalizeLinks(piihIRQInfoHeader, 0x5F);
        
    } else {

        //
        // Validate that all config space addresses are above 60.
        //
        if (GetMinLink(piihIRQInfoHeader)<0x60)
            return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\ns87560.c ===
/*
 *  NS87560.C - NS NS87560 PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from National Semiconductor NS87560 Data Sheet
 *
 */

#include "local.h"

/****************************************************************************
 *
 *  NS87560SetIRQ - Set a NS87560 PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x6C;

    //
    // Read the old NS87560 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the NS87560 IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bOldValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NS87560GetIRQ - Get the IRQ of a NS87560 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bOffset, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Zero based.
    //
    bLink--;

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x6C;

    //
    // Read the old NS87560 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=bOldValue&0x0f;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NS87560SetTrigger - Set the IRQ triggering values for the NS87560
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560SetTrigger(ULONG ulTrigger)
{
    WriteConfigUchar(bBusPIC, bDevFuncPIC, 0x67, (UCHAR)ulTrigger);
    WriteConfigUchar(bBusPIC, bDevFuncPIC, 0x68, (UCHAR)(ulTrigger >> 8));

    return (PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NS87560GetTrigger - Get the IRQ triggering values for the NS87560
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
NS87560GetTrigger(PULONG pulTrigger)
{
    //
    // Assume all edge.
    //
    *pulTrigger = 0;

    *pulTrigger |= ReadConfigUchar(bBusPIC, bDevFuncPIC, 0x67);
    *pulTrigger |= (ReadConfigUchar(bBusPIC, bDevFuncPIC, 0x68) << 8);

    return (PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  NS87560ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
NS87560ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, NS87560ValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
NS87560ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    //
    // If any link is above 4, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>4)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\misc.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    misc.c

Abstract:

    This contains the misc support functions used by the 
    PCI IRQ Miniport library.

Author:

    Santosh Jodh (santoshj) 09-June-1998

Environment:

    kernel mode only

Revision History:

--*/

#include "local.h"

NTSTATUS    
EisaGetTrigger (
    OUT PULONG Trigger
    )

/*++

Routine Description:

    This routine gets the EISA Irq trigger mask (1 - Level, 0 - Edge).
    
Parameters:

    Trigger - Trigger mask is returned in this argument.

Return Value:

    PCIIRQMP_STATUS_SUCCESS.

Notes:

--*/
         
{
    UCHAR   LowPart;
    UCHAR   HighPart;

    //
    // Read the edge\level mask for Irq 0-7.
    //
    
    LowPart = READ_PORT_UCHAR((PUCHAR)0x4D0);

    //
    // Allow delay before another I/O.
    //
    
    IO_Delay();

    //
    // Read the edge\level mask for Irq 8-15.
    //
    
    HighPart = READ_PORT_UCHAR((PUCHAR)0x4D1);

    //
    // Combine set the trigger to the mask for Irq 0-15.
    //
    
    *Trigger = (ULONG)((HighPart << 8) + LowPart) & 0xFFFF;
    
    return (PCIMP_SUCCESS);    
}

NTSTATUS
EisaSetTrigger (
    IN ULONG Trigger
    )

/*++

Routine Description:

    This routine sets the EISA Irq trigger mask (1 - Level, 0 - Edge).
    
Parameters:

    Trigger - Trigger mask to be set.

Return Value:

    PCIIRQMP_STATUS_SUCCESS.

Notes:

--*/
     
{
    //
    // Program the EISA edge\level control for Irq 0-7.
    //
    
    WRITE_PORT_UCHAR((PUCHAR)0x4D0, (CHAR)Trigger);

    //
    // Allow delay before another I/O.
    //
    
    IO_Delay();

    //
    // Program the EISA edge\level control for Irq 8-15.
    //
    
    WRITE_PORT_UCHAR((PUCHAR)0x4D1, (CHAR)(Trigger >> 8));

    return (PCIMP_SUCCESS);
}

UCHAR
ReadConfigUchar (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    )

/*++

Routine Description:

    This routine calls the HAL to read the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being read.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be read.

Return Value:

    Value read from the specified offset in the config space.

Notes:

--*/
         
{
    UCHAR   Data;
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);
    
    //
    // Initialize data to invalid values.
    //
    
    Data = 0xFF;

    //
    // Call the HAL to do the actual reading.
    //
    
    HalGetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));

    //
    // Return data read to the caller.
    //
    
    return(Data);
}

USHORT
ReadConfigUshort (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    )

/*++

Routine Description:

    This routine calls the HAL to read the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being read.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be read.

Return Value:

    Value read from the specified offset in the config space.

Notes:

--*/
         
{
    USHORT  Data;
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Initialize data to invalid values.
    //
    
    Data = 0xFFFF;

    //
    // Call the HAL to do the actual reading.
    //
    
    HalGetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));

    //
    // Return data read to the caller.
    //
    
    return(Data);
}

ULONG
ReadConfigUlong (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    )

/*++

Routine Description:

    This routine calls the HAL to read the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being read.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be read.

Return Value:

    Value read from the specified offset in the config space.

Notes:

--*/
         
{
    ULONG   Data;
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Initialize data to invalid values.
    //
    
    Data = 0xFFFFFFFF;

    //
    // Call the HAL to do the actual reading.
    //
    
    HalGetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));

    //
    // Return data read to the caller.
    //
    
    return(Data);
}

VOID
WriteConfigUchar (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN UCHAR           Data
    )

/*++

Routine Description:

    This routine calls the HAL to write to the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being written to.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be written.

    Data - Value to be written.

Return Value:

    None.

Notes:

--*/
     
{
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Call the HAL to do the actual writing.
    //
    
    HalSetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));
}

VOID
WriteConfigUshort (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN USHORT          Data
    )

/*++

Routine Description:

    This routine calls the HAL to write to the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being written to.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be written.

    Data - Value to be written.

Return Value:

    None.

Notes:

--*/
     
{
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Call the HAL to do the actual writing.
    //

    HalSetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));
}

VOID
WriteConfigUlong (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN ULONG           Data
    )

/*++

Routine Description:

    This routine calls the HAL to write to the Pci config space.
    
Parameters:

    BusNumber - Bus number of the Pci device being written to.    

    DevFunc - Slot number of the Pci device being read (Dev (7:3), Func(2:0)).

    Offset - Offset in the config space to be written.

    Data - Value to be written.

Return Value:

    None.

Notes:

--*/
     
{
    ULONG   slotNumber;

    slotNumber = (DevFunc >> 3) & 0x1F;
    slotNumber |= ((DevFunc & 0x07) << 5);

    //
    // Call the HAL to do the actual writing.
    //
    
    HalSetBusDataByOffset(  PCIConfiguration,
                            BusNumber,
                            slotNumber,
                            &Data,
                            Offset,
                            sizeof(Data));
}

UCHAR
GetMinLink (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable
    )

/*++

Routine Description:

    This routine finds and returns the minimum link value in the 
    given Pci Irq Routing Table.
    
Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table to be processed.    

Return Value:

    Minimum link value in the table.

Notes:

--*/
        
{
    UCHAR       MinLink;
    PPIN_INFO   PinInfo;
    PPIN_INFO   LastPin;
    PSLOT_INFO  SlotInfo;
    PSLOT_INFO  LastSlot;

    //
    // Start by setting the maximum link to the maximum possible value.
    //

    MinLink = 0xFF;

    //
    // Process all slots in this table.
    //

    SlotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
    LastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);    

    while (SlotInfo < LastSlot)
    {
        //
        // Process all pins for this slot.
        //
     
        PinInfo = &SlotInfo->PinInfo[0];
        LastPin = &SlotInfo->PinInfo[NUM_IRQ_PINS];

        while (PinInfo < LastPin)
        {
            //
            // Update the min link found so far if the current link is
            // valid and smaller.
            //
    
            if (    PinInfo->Link &&
                    PinInfo->Link < MinLink)
            {
                MinLink = PinInfo->Link;
            }

            //
            // Next link.
            //
            
            PinInfo++;
        }

        //
        // Next slot.
        //
        
        SlotInfo++;
    }

    //
    // If we failed to find the minimum value, set the minimum to zero.
    //
    
    if (MinLink == 0xFF)
        MinLink = 0;

    //
    // Return the minimum link in the table to the caller.
    //
    
    return (MinLink);
}

UCHAR
GetMaxLink (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable
    )

/*++

Routine Description:

    This routine finds and returns the maximum link value in the 
    given Pci Irq Routing Table.
    
Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table to be processed.

Return Value:

    Maximum link value in the table.

Notes:

--*/
        
{
    UCHAR       MaxLink;
    PPIN_INFO   PinInfo;
    PPIN_INFO   LastPin;
    PSLOT_INFO  SlotInfo;
    PSLOT_INFO  LastSlot;

    //
    // Start by setting the maximum link to the smallest possible value.
    //
    
    MaxLink = 0;
    
    //
    // Process all slots in this table.
    //

    SlotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
    LastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);    

    while (SlotInfo < LastSlot)
    {
        //
        // Process all pins for this slot.
        //
        
        PinInfo = &SlotInfo->PinInfo[0];
        LastPin = &SlotInfo->PinInfo[NUM_IRQ_PINS];

        while (PinInfo < LastPin)
        {
            //
            // Update the max link found so far if the current link is
            // valid and larger.
            //
            
            if (    PinInfo->Link &&
                    PinInfo->Link > MaxLink)
            {
                MaxLink = PinInfo->Link;
            }

            //
            // Next pin.
            //
            
            PinInfo++;
        }

        //
        // Next slot.
        //
        
        SlotInfo++;
    }

    //
    // Return the maximum link in the table to the caller.
    //
    
    return (MaxLink);
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, NormalizeLinks)
#endif //ALLOC_PRAGMA

VOID
NormalizeLinks (
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    IN UCHAR                   Adjustment
    )

/*++

Routine Description:

    This routine normalizes all link values in the Pci Irq Routing Table by
    adding the adjustment to all the links.

Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table to be normalized.

    Adjustment - Amount to be added to each link.

Return Value:

    None.

Notes:

--*/
    
{
    PPIN_INFO   PinInfo;
    PPIN_INFO   LastPin;
    PSLOT_INFO  SlotInfo;
    PSLOT_INFO  LastSlot;

    PAGED_CODE();

    //
    // Process all slots in this table.
    //

    SlotInfo = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + sizeof(PCI_IRQ_ROUTING_TABLE));
    LastSlot = (PSLOT_INFO)((PUCHAR)PciIrqRoutingTable + PciIrqRoutingTable->TableSize);

    while (SlotInfo < LastSlot)
    {    
        //
        // Process all pins.
        //
        
        PinInfo = &SlotInfo->PinInfo[0];
        LastPin = &SlotInfo->PinInfo[NUM_IRQ_PINS];

        while (PinInfo < LastPin)
        {        
            //
            // Only normalize valid link values.
            //
            
            if(PinInfo->Link)
            {
               PinInfo->Link += Adjustment; 
            }

            //
            // Next pin.
            //
            
            PinInfo++;
        }

        //
        // Next slot.
        //
        
        SlotInfo++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\optifire.c ===
/*
 *  OptiFireStar.C - OPTI FIRESTAR PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from OPTI FIRESTAR Data Sheet
 *  Opti contact: William@unixgate.opti.com     
 *
 */

#include "local.h"

/****************************************************************************
 *
 *  OptiFireStarSetIRQ - Set a OPTI FIRESTAR PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bData, bOffset;
    
    switch (bLink & 0x07)
    {
        case 0:
        
            if (bLink == 0)
                return (PCIMP_FAILURE);
            else
                return (PCIMP_INVALID_LINK);
        case 1: 

            //
            // FireStar IRQ 
            //
            bLink = (UCHAR)((bLink & 0x70) >> 4);
            bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0 + bLink));   
            bData = (bData & 0xf0) | bIRQNumber;
            if (bIRQNumber)
                bData |= 0x10;
            WriteConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0 + bLink), bData);
            
            return (PCIMP_SUCCESS);
            
        case 2:

            //
            // FireStar PIO or Serial IRQ
            //
        case 3:

            //
            // FireBridge INTs
            //
            bOffset = (UCHAR)((bLink >> 5) & 1) + 0xB8;
            bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);
            if (bLink & (1<<4)) {
                bData &= 0x0f;
                bData |= (bIRQNumber<<4);
            }
            else {
                bData &= 0xf0;
                bData |= bIRQNumber;
            }
            WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bData);
            
            return (PCIMP_SUCCESS);
            
        default:
            return (PCIMP_INVALID_LINK);
    }   
    
    return (PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  OptiFireStarGetIRQ - Get the IRQ of a OPTI FIRESTAR PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bData, bOffset;
    
    switch (bLink & 0x07)
    {
        case 0:
            //
            // Valid link?
            //
            if (bLink == 0)
                return (PCIMP_FAILURE);
            else
                return (PCIMP_INVALID_LINK);
                
        case 1: 
            //
            // FireStar IRQ 
            //
            bLink = (UCHAR)((bLink & 0x70) >> 4);
            bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0 + bLink));   
            *pbIRQNumber = (bData & 0x0f);
            
            return (PCIMP_SUCCESS);
            
        case 2:
            //
            // FireStar PIO or Serial IRQ
            //
            
        case 3:
            //
            // FireBridge INTs
            //
            bOffset = (UCHAR)((bLink >> 5) & 1) + 0xB8;
            bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);
            if (bLink & (1<<4)) 
                bData >>= 4;

            *pbIRQNumber = bData & 0x0f;
            
            return (PCIMP_SUCCESS);
            
        default:
            return (PCIMP_INVALID_LINK);
    }   
    
    return (PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  OptiViperSetTrigger - Set the IRQ triggering values for the OptiViper
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarSetTrigger(ULONG ulTrigger)
{
    ULONG i;
    UCHAR bData;

    for (i = 0; i < 8; i++) 
    {
        UCHAR bTemp;
        bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0+i)); 
        bTemp = bData & 0x0F;
        if (bTemp && (ulTrigger & (1 << bTemp)))
        {
            bData |= 0x10;          
        }
        else
        {
            bData &= ~0x10;
        }
        WriteConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0+i), bData);
    }
    
    return (PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperGetTrigger - Get the IRQ triggering values for the OptiViper
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiFireStarGetTrigger(PULONG pulTrigger)
{
    ULONG i;
    UCHAR bData;
    
    //
    // Assume all are edge.
    //
    *pulTrigger = 0;

    //
    // Check PCIDV1 registers B0-B7.
    //
    for (i = 0; i < 8; i++)
    {
        bData = (UCHAR)(ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB0 + i)) & 0x1F);
        if (bData & 0x10)               
            *pulTrigger |= (1 << (bData & 0x0f));       
    }

    //
    // Check PCIDV1 registers B8-B9.
    //
    for (i = 0; i < 2; i++)
    {
        bData = ReadConfigUchar(bBusPIC, bDevFuncPIC, (UCHAR)(0xB8 + i));
        *pulTrigger |= (1 << (bData & 0x0F));
        bData >>= 4;
        *pulTrigger |= (1 << (bData & 0x0F));
    }
    
    return (PCIMP_SUCCESS); 
}

/****************************************************************************
 *
 *  OptiFireStarValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
OptiFireStarValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, OptiFireStarValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
OptiFireStarValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PIRQINFO    pii=(PIRQINFO)(((PUCHAR) piihIRQInfoHeader)+sizeof(IRQINFOHEADER));
    ULONG       i, j;
    ULONG       cEntries=(piihIRQInfoHeader->TableSize-sizeof(IRQINFOHEADER))/sizeof(IRQINFO);

    PAGED_CODE();

    for (i=0; i<cEntries; i++) {

        for (j=0; j<4; j++) {

            switch (pii->PinInfo[j].Link & 0x07)
            {
                case 0:
                    //
                    // Valid link?
                    //
                    if (pii->PinInfo[j].Link & 0x70)
                        return (PCIMP_FAILURE);
                    break;
                    
                case 1:
                    //
                    // FireStar IRQ 
                    //              
                    break;                  

                case 2:
                    //
                    // FireStar PIO or Serial IRQ
                    //
                    
                case 3:
                    //
                    // FireBridge INTs
                    //
                    if ((pii->PinInfo[j].Link & 0x70) > 0x30)
                        return (PCIMP_FAILURE);
                    break;
                default:
                
                    return (PCIMP_FAILURE);
            }           
        }
        pii++;
    }

    return(i? PCIMP_SUCCESS : PCIMP_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\local.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    local.h

Abstract:

    This contains the private header information (function prototypes,
    data and type declarations) for the PCI IRQ Miniport library.

Author:

    Santosh Jodh (santoshj) 09-June-1998

Revision History:

--*/
#include "nthal.h"
#include "hal.h"
#include "pci.h"
#include "pciirqmp.h"

#if DBG

#define PCIIRQMPPRINT(x) {                      \
        DbgPrint("PCIIRQMP: ");                 \
        DbgPrint x;                             \
        DbgPrint("\n");                         \
    }
    
#else

#define PCIIRQMPPRINT(x)

#endif

//
// Typedefs to keep source level compatibility with W9x
//

typedef PCI_IRQ_ROUTING_TABLE IRQINFOHEADER;
typedef PPCI_IRQ_ROUTING_TABLE PIRQINFOHEADER;
typedef SLOT_INFO IRQINFO;
typedef PSLOT_INFO PIRQINFO;
#define CDECL   
#define LOCAL_DATA  static
#define GLOBAL_DATA

//
// Bus number of the Pci Irq Router device.
//

extern ULONG    bBusPIC;

//
// Slot number of Pci Irq Router device (Bits 7:3 Dev, 2:0 Func).
//

extern ULONG    bDevFuncPIC;

#define CATENATE(x, y)  x ## y
#define XCATENATE(x, y) CATENATE(x, y)

#define DECLARE_MINIPORT_FUNCTION(x, y)  XCATENATE(x, y)

#define IO_Delay()

//
// Prototype for misc utility functions.
//

NTSTATUS    
EisaGetTrigger (
    OUT PULONG Trigger
    );    

NTSTATUS
EisaSetTrigger (
    IN ULONG Trigger
    );

UCHAR
ReadConfigUchar (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    );

USHORT
ReadConfigUshort (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    );

ULONG
ReadConfigUlong (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset
    );

VOID
WriteConfigUchar (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN UCHAR           Data
    );

VOID
WriteConfigUshort (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN USHORT          Data
    );

VOID
WriteConfigUlong (
    IN ULONG           BusNumber,
    IN ULONG           DevFunc,
    IN UCHAR           Offset,
    IN ULONG           Data
    );

UCHAR
GetMinLink (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable
    );

UCHAR
GetMaxLink (
    IN PPCI_IRQ_ROUTING_TABLE PciIrqRoutingTable
    );

VOID
NormalizeLinks (
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    IN UCHAR                   Adjustment
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\triton.c ===
/*
 *  TRITON.C - Intel Triton PCI chipset routines.
 *
 *  Notes:
 *	Algorithms from Intel Triton 82430FX PCISET Data Sheet
 *	(Intel Secret) 82371FB PCI ISA IDE Xcelerator spec.
 *
 */

#include "local.h"

/****************************************************************************
 *
 *	TritonSetIRQ - Set a Triton PCI link to a specific IRQ
 *
 *	Exported.
 *
 *	ENTRY:	bIRQNumber is the new IRQ to be used.
 *
 *		bLink is the Link to be set.
 *
 *	EXIT:	Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
TritonSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
	//
	// Validate link number.
	//
	if (bLink < 0x40) {

		return(PCIMP_INVALID_LINK);
	}

	//
	// Use 0x80 to disable.
	//
	if (!bIRQNumber)
		bIRQNumber=0x80;

	//
	// Set the Triton IRQ register.
	//
	WriteConfigUchar(bBusPIC, bDevFuncPIC, bLink, bIRQNumber);

	return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *	TritonGetIRQ - Get the IRQ of a Triton PCI link
 *
 *	Exported.
 *
 *	ENTRY:	pbIRQNumber is the buffer to fill.
 *
 *		bLink is the Link to be read.
 *
 *	EXIT:	Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
TritonGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
	//
	// Validate link number.
	//
	if (bLink < 0x40) {

		return(PCIMP_INVALID_LINK);
	}

	//
	// Store the IRQ value.
	//
	*pbIRQNumber=ReadConfigUchar(bBusPIC, bDevFuncPIC, bLink);

	//
	// Return 0 if disabled.
	//
	if (*pbIRQNumber & 0x80)
		*pbIRQNumber=0;

	return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *	TritonValidateTable - Validate an IRQ table
 *
 *	Exported.
 *
 *	ENTRY:	piihIRQInfoHeader points to an IRQInfoHeader followed
 *		by an IRQ Routing Table.
 *
 *		ulFlags are PCIMP_VALIDATE flags.
 *
 *	EXIT:	Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
TritonValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
	if ((ulFlags & PCIMP_VALIDATE_SOURCE_BITS)==PCIMP_VALIDATE_SOURCE_PCIBIOS) {

		//
		// If all links are above 40, we they are config space.
		//
		if (GetMinLink(piihIRQInfoHeader)>=0x40)
			return(PCIMP_SUCCESS);

		//
		// If there are links above 4, we are clueless.
		//
		if (GetMaxLink(piihIRQInfoHeader)>0x04)
			return(PCIMP_FAILURE);

		//
		// Assume 1,2,3,4 are the 60,61,62,63 links.
		//
		NormalizeLinks(piihIRQInfoHeader, 0x5F);
		
	} else {

		//
		// Validate that all config space addresses are above 40.
		//
		if (GetMinLink(piihIRQInfoHeader)<0x40)
			return(PCIMP_FAILURE);
	}

	return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\vlsi.c ===
/*
 *  VLSI.C - VLSI Wildcat PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from VLSI VL82C596/7 spec.
 *
 */

#include "local.h"

#define NUM_VLSI_IRQ    (sizeof(rgbIndexToIRQ)/sizeof(rgbIndexToIRQ[0]))

const UCHAR rgbIndexToIRQ[]  = { 3, 5, 9, 10, 11, 12, 14, 15 };

#define INDEX_UNUSED    ((ULONG)-1)

/****************************************************************************
 *
 *  VLSISetIRQ - Set a VLSI PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSISetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    ULONG   ulNewIRQIndex;
    ULONG   rgbIRQSteering[NUM_IRQ_PINS];
    ULONG   ulMask;
    ULONG   ulUnusedIndex;
    ULONG   ulVLSIRegister;
    ULONG   ulIRQIndex;
    ULONG   i;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Find the VLSI index of the new IRQ.
    //
    if (bIRQNumber) {

        //
        // Look through the list of valid indicies.
        //
        for (ulNewIRQIndex=0; ulNewIRQIndex<NUM_VLSI_IRQ; ulNewIRQIndex++)
        {
            if (rgbIndexToIRQ[ulNewIRQIndex] == bIRQNumber)
                break;
        }

        //
        // If there is no VLSI equivalent, bail.
        //
        if (ulNewIRQIndex==NUM_VLSI_IRQ) {

            return(PCIMP_INVALID_IRQ);
        }

    } else {

        //
        // Blowing away this interrupt.
        //
        ulNewIRQIndex = INDEX_UNUSED;
    }

    //
    // Read in the VLSI Interrupt Steering Register.
    //
    ulVLSIRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x74);

    //
    // Compute the complete IRQ mapping.
    //
    for (i=0, ulMask=0x07; i<NUM_IRQ_PINS; i++, ulMask<<=4)
    {
        ulIRQIndex = (ulVLSIRegister & ulMask) >> (i * 4);

        if ((ulVLSIRegister & (1 << (ulIRQIndex + 16))) != 0)
        {
            rgbIRQSteering[i] = ulIRQIndex;
        }
        else
        {
            rgbIRQSteering[i] = INDEX_UNUSED;
        }
    }

    //
    // Update the IRQ Mapping with the new IRQ.
    //
    rgbIRQSteering[bLink] = ulNewIRQIndex;

    //
    // Find an unused IRQ index.
    //
    for (ulUnusedIndex=0; ulUnusedIndex<NUM_VLSI_IRQ; ulUnusedIndex++)
    {
        for (i=0; i<NUM_IRQ_PINS; i++)
        {
            if (rgbIRQSteering[i] == ulUnusedIndex)
                break;
        }
        if (i == NUM_IRQ_PINS)
            break;
    }

    //
    // Compute the new VLSI Interrupt Steering Register.
    //
    ulVLSIRegister = 0x00000000;
    for (i=0; i<NUM_IRQ_PINS; i++)
    {
        if (rgbIRQSteering[i] == INDEX_UNUSED)
        {
            ulVLSIRegister |= ulUnusedIndex << (4*i);
        }
        else
        {
            ulVLSIRegister |= rgbIRQSteering[i] << (4*i);
            ulVLSIRegister |= 1 << (rgbIRQSteering[i] + 16);
        }
    }

    //
    // Write out the new VLSI Interrupt Steering Register.
    //
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x74, ulVLSIRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIGetIRQ - Get the IRQ of a VLSI PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    ULONG   ulVLSIRegister;
    ULONG   ulIndex;
    UCHAR   bIRQ;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Read in the VLSI Interrupt Steering Register.
    //
    ulVLSIRegister=ReadConfigUchar(bBusPIC, bDevFuncPIC, 0x74);

    //
    // Find the link's IRQ value.
    //
    ulIndex = (ulVLSIRegister >> (bLink*4)) & 0x7;
    bIRQ = rgbIndexToIRQ[ulIndex];

    //
    // Make sure the IRQ is marked as in use.
    //
    if ((ulVLSIRegister & (1 << (ulIndex + 16))) == 0)
    {
        bIRQ = 0;
    }

    //
    // Set the return buffer.
    //
    *pbIRQNumber = bIRQ;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSISetTrigger - Set the IRQ triggering values for the VLSI.
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSISetTrigger(ULONG ulTrigger)
{
    ULONG   ulAssertionRegister;
    ULONG   ulPMAssertionRegister;
    ULONG   i;

    //
    // Read in the Interrupt Assertion Level register.
    //
    ulAssertionRegister = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x5C);

    //
    // Clear off the old edge/level settings.
    //
    ulAssertionRegister &= ~0xff;

    //
    // For each VLSI interrupt...
    //
    for (i=0; i<NUM_VLSI_IRQ; i++)
    {
        //
        // If the corresponding bit is set to level...
        //

        if (ulTrigger & (1 << rgbIndexToIRQ[i]))
        {
            //
            // Set the corresponding bit in the
            // Assertion Register.
            //
            ulAssertionRegister |= 1 << i;

            //
            // And clear the bit from ulTrigger.
            //
            ulTrigger &= ~(1 << rgbIndexToIRQ[i]);
        }
    }

    //
    // If the caller wanted some non-VLSI IRQs level, bail.
    //
    if (ulTrigger)
    {
        return(PCIMP_INVALID_IRQ);
    }

    //
    // Set the Assertion Register.
    //
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x5C, ulAssertionRegister);

    //
    // Read in the Power Mgmt edge/level setting.
    //
    ulPMAssertionRegister = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x78);

    //
    // Clear off the old edge/level settings.
    //
    ulPMAssertionRegister &= ~0xff;

    //
    // Copy the new edge/level settings.
    //
    ulPMAssertionRegister |= ulAssertionRegister & 0xff;

    //
    // Set the Power Mgmt Assertion Register.
    //
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x78, ulPMAssertionRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIGetTrigger - Get the IRQ triggering values for the VLSI.
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   TRUE if successful.
 *
 ***************************************************************************/
PCIMPRET CDECL
VLSIGetTrigger(PULONG pulTrigger)
{
    ULONG   ulAssertionRegister;
    ULONG   i;

    //
    // Read in the Interrupt Assertion Level register.
    //
    ulAssertionRegister = ReadConfigUchar(bBusPIC, bDevFuncPIC, 0x5C);

    //
    // Clear the return buffer.
    //
    *pulTrigger = 0;

    //
    // For each VLSI interrupt...
    //
    for (i=0; i<NUM_VLSI_IRQ; i++)
    {
        //
        // If the corresponding bit is set to level...
        //
        if (ulAssertionRegister & (1 << i))
        {
            //
            // Set the corresponding bit in the
            // return buffer.
            //
            *pulTrigger |= 1 << rgbIndexToIRQ[i];
        }
    }

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VLSIValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
VLSIValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, VLSIValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
VLSIValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if (GetMaxLink(piihIRQInfoHeader)>0x04) {

        return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\optivip.c ===
/*
 *  OPTIVIP.C - OPTi Viper-M PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from OPTi Viper-M 82C556M/82C557M/82C558M doc,
 *  82C558M spec.
 *
 */

#include "local.h"

//                  IRQ =   0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15
const UCHAR rgbIRQToBig[16]   = { 0, 0, 0, 0, 0, 1, 0, 0, 0, 2, 3, 4, 5, 0, 6, 7 };
const UCHAR rgbIRQToSmall[16] = { 0, 0, 0, 1, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0 };

const UCHAR rgbBigToIRQ[8]   = { 0, 5, 9, 10, 11, 12, 14, 15 };
const UCHAR rgbSmallToIRQ[8] = { 0, 3, 4, 7 };

/****************************************************************************
 *
 *  OptiViperSetIRQ - Set a OptiViper PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    ULONG   ulIRQRegister;

    //
    // If not an OPTi IRQ, bail.
    //
    if (bIRQNumber &&   (!rgbIRQToBig[bIRQNumber] &&
                 !rgbIRQToSmall[bIRQNumber]))
    {
        return(PCIMP_INVALID_IRQ);
    }

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Read in the big IRQ Register,
    // clear the old IRQ index for the link,
    // set the new IRQ index,
    // and write it back.
    //
    ulIRQRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x40);
    ulIRQRegister &= ~(0x7 << (3 * bLink));
    ulIRQRegister |= rgbIRQToBig[bIRQNumber] << (3 * bLink);
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x40, ulIRQRegister);

    //
    // Read in the small IRQ register,
    // clear the old IRQ index for the link,
    // set the new IRQ index,
    // and write it back.
    //
    ulIRQRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x50);
    ulIRQRegister &= ~(0x3 << (2 * bLink));
    ulIRQRegister |= rgbIRQToSmall[bIRQNumber] << (2 * bLink);
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x50, ulIRQRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperGetIRQ - Get the IRQ of a OptiViper PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    ULONG   ulIRQRegister;
    ULONG   ulIndex;

    //
    // Make link number 0 based, and validate.
    //
    bLink--;
    if (bLink > 3) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Read in the big IRQ Register.
    //
    ulIRQRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x40);

    //
    // If we have a big IRQ, we're done.
    //
    ulIndex = (ulIRQRegister >> (bLink * 3)) & 0x7;
    if ((*pbIRQNumber = rgbBigToIRQ[ulIndex]) != 0)
    {
        return(PCIMP_SUCCESS);
    }

    //
    // Read in the small IRQ register.
    //
    ulIRQRegister=ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x50);

    //
    // Set the buffer to the small IRQ's value.
    //
    ulIndex = (ulIRQRegister >> (bLink * 2)) & 0x3;
    *pbIRQNumber = rgbSmallToIRQ[ulIndex];

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperSetTrigger - Set the IRQ triggering values for the OptiViper
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperSetTrigger(ULONG ulTrigger)
{
    ULONG   ulBigIRQRegister;
    ULONG   ulSmallIRQRegister;
    ULONG   i;

    //
    // Read in the big & small IRQ registers,
    // setting all IRQs to edge.
    //
    ulBigIRQRegister   = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x40) & ~0x00FE0000;
    ulSmallIRQRegister = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x50) & ~0x00000700;

    //
    // For each IRQ...
    //
    for (i=0; i<16; i++)
    {
        //
        // If we want this to be level triggered...
        //
        if (ulTrigger & (1 << i))
        {

            if (rgbIRQToBig[i])
            {
                //
                // If it's a big IRQ, set the
                // corresponding bit in the
                // big register.
                //
                ulBigIRQRegister |= 1 << (16 + rgbIRQToBig[i]);
            }
            else if (rgbIRQToSmall[i])
            {
                //
                // If it's a small IRQ, set the
                // corresponding bit in the
                // small register.
                //
                ulSmallIRQRegister |= 1 << (11 - rgbIRQToSmall[i]);
            }
            else
            {
                //
                // Trying to level set an unsupported IRQ.
                //
                return(PCIMP_INVALID_IRQ);
            }
        }
    }

    //
    // Write the new IRQ register values.
    //
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x40, ulBigIRQRegister);
    WriteConfigUlong(bBusPIC, bDevFuncPIC, 0x50, ulSmallIRQRegister);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperGetTrigger - Get the IRQ triggering values for the OptiViper
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
OptiViperGetTrigger(PULONG pulTrigger)
{
    ULONG   ulBigIRQRegister;
    ULONG   ulSmallIRQRegister;
    ULONG   i;

    //
    // Assume all edge.
    //
    *pulTrigger = 0;

    //
    // Read in the big&small IRQ registers.
    //
    ulBigIRQRegister   = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x40);
    ulSmallIRQRegister = ReadConfigUlong(bBusPIC, bDevFuncPIC, 0x50);

    //
    // For each IRQ...
    //
    for (i=0; i<16; i++)
    {
        //
        // If it's a big IRQ and it's level triggered,
        // or if it's a small IRQ and it's level triggered,
        // set the corresponding bit in pulTrigger.
        //
        if (    ((rgbIRQToBig[i]) &&
             (ulBigIRQRegister & (1 << (16 + rgbIRQToBig[i])))) ||
            ((rgbIRQToSmall[i]) &&
             (ulSmallIRQRegister & (1 << (11 - rgbIRQToSmall[i])))))
        {
            *pulTrigger |= 1 << i;
        }
    }

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  OptiViperValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
OptiViperValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, OptiViperValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
OptiViperValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if (GetMaxLink(piihIRQInfoHeader)>0x04) {

        return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\vt586.c ===
/*
 *  VT586.C - VIA Technologies PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from VIATECH 82C586B Data Sheet
 *  Compaq contact:     
 *
 */

#include "local.h"

/****************************************************************************
 *
 *  VT586SetIRQ - Set a VIATECH 82C586B PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VT586SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR bOffset, bOldValue;
    
    switch (bLink)
    {
        case 1: case 2:
        case 3: case 5:

            break;
            
        default:
        
            return (PCIMP_INVALID_LINK);
    }

    //
    // Compute the offset in config space.
    //
    bOffset=(bLink/2)+0x55;

    //
    // Read the old VT82C586 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the VT82C586B IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bOffset, bOldValue);
        
    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VT586GetIRQ - Get the IRQ of a VIATECH 82C586B PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VT586GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR bOffset, bOldValue;
    
    switch (bLink)
    {
        case 1: case 2:
        case 3: case 5:

            break;
            
        default:
        
            return (PCIMP_INVALID_LINK);
    }

    //
    // Set various values.
    //
    bOffset=(bLink/2)+0x55;

    //
    // Read the old VT82C586 IRQ register.
    //
    bOldValue=ReadConfigUchar(bBusPIC, bDevFuncPIC, bOffset);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=bOldValue&0x0f;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VT586ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
VT586ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, VT586ValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
VT586ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PIRQINFO    pii=(PIRQINFO)(((PUCHAR) piihIRQInfoHeader)+sizeof(IRQINFOHEADER));
    ULONG       i, j;
    ULONG       cEntries=(piihIRQInfoHeader->TableSize-sizeof(IRQINFOHEADER))/sizeof(IRQINFO);

    PAGED_CODE();

    for (i=0; i<cEntries; i++, pii++) {

        for (j=0; j<4; j++) {

            if (pii->PinInfo[j].Link<=3 || pii->PinInfo[j].Link==5)
                continue;
                
            return (PCIMP_FAILURE);                 
        }       
    }

    return(i? PCIMP_SUCCESS : PCIMP_FAILURE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\pciirqmp.c ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    pciirqmp.c

Abstract:

    This is the PCI IRQ Miniport library.

Author:

    Santosh Jodh (santoshj) 09-June-1998

Environment:

    kernel mode only

Revision History:

--*/

#include "local.h"

//
// Macro to declare a table of function pointers for the chipset
// module.
//

#define DECLARE_CHIPSET(x)                                  \
    {   DECLARE_MINIPORT_FUNCTION(x, ValidateTable),        \
        DECLARE_MINIPORT_FUNCTION(x, GetIRQ),               \
        DECLARE_MINIPORT_FUNCTION(x, SetIRQ),               \
        DECLARE_MINIPORT_FUNCTION(x, GetTrigger),           \
        DECLARE_MINIPORT_FUNCTION(x, SetTrigger)            \
    }

//
// Macro to declare a table of function pointers for EISA
// compatible chipset module.
//

#define DECLARE_EISA_CHIPSET(x)                             \
    {   DECLARE_MINIPORT_FUNCTION(x, ValidateTable),        \
        DECLARE_MINIPORT_FUNCTION(x, GetIRQ),               \
        DECLARE_MINIPORT_FUNCTION(x, SetIRQ),               \
        EisaGetTrigger,                                     \
        EisaSetTrigger                                      \
    }

//
// Macro to declare the functions to be provided by the chipset
// module.
//

#define DECLARE_IRQ_MINIPORT(x)                             \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, ValidateTable) (               \
    IN PPCI_IRQ_ROUTING_TABLE   PciIrqRoutingTable,         \
    IN ULONG                    Flags                       \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, GetIRQ) (                      \
    OUT PUCHAR  Irq,                                        \
    IN  UCHAR   Link                                        \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION( x, SetIRQ) (                     \
    IN UCHAR Irq,                                           \
    IN UCHAR Link                                           \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, GetTrigger) (                  \
    OUT PULONG Trigger                                      \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, SetTrigger) (                  \
    IN ULONG Trigger                                        \
    );

//
// Macro to declare the functions to be provided by the EISA
// compatible chipset.
//

#define DECLARE_EISA_IRQ_MINIPORT(x)                        \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, ValidateTable) (               \
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,          \
    IN ULONG                   Flags                        \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION(x, GetIRQ) (                      \
    OUT PUCHAR  Irq,                                        \
    IN  UCHAR   Link                                        \
    );                                                      \
NTSTATUS                                                    \
DECLARE_MINIPORT_FUNCTION( x, SetIRQ) (                     \
    IN UCHAR Irq,                                           \
    IN UCHAR Link                                           \
    );

//
// Function prototypes for functions that every chipset module
// has to provide.
//

typedef
NTSTATUS
(*PIRQMINI_VALIDATE_TABLE) (
    PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    ULONG                   Flags
    );

typedef
NTSTATUS
(*PIRQMINI_GET_IRQ) (
    OUT PUCHAR  Irq,
    IN  UCHAR   Link
    );

typedef
NTSTATUS
(*PIRQMINI_SET_IRQ) (
    IN UCHAR Irq,
    IN UCHAR Link
    );

typedef
NTSTATUS
(*PIRQMINI_GET_TRIGGER) (
    OUT PULONG Trigger
    );

typedef
NTSTATUS
(*PIRQMINI_SET_TRIGGER) (
    IN ULONG Trigger
    );

//
// Chipset specific data contains a table of function pointers
// to program the chipset.
//

typedef struct _CHIPSET_DATA {
        PIRQMINI_VALIDATE_TABLE ValidateTable;
        PIRQMINI_GET_IRQ        GetIrq;
    PIRQMINI_SET_IRQ        SetIrq;
        PIRQMINI_GET_TRIGGER    GetTrigger;
        PIRQMINI_SET_TRIGGER    SetTrigger;
} CHIPSET_DATA, *PCHIPSET_DATA;


//
// Declare all miniports here.
//

DECLARE_EISA_IRQ_MINIPORT(Mercury)
DECLARE_EISA_IRQ_MINIPORT(Triton)
DECLARE_IRQ_MINIPORT(VLSI)
DECLARE_IRQ_MINIPORT(OptiViper)
DECLARE_EISA_IRQ_MINIPORT(SiS5503)
DECLARE_IRQ_MINIPORT(VLSIEagle)
DECLARE_EISA_IRQ_MINIPORT(M1523)
DECLARE_IRQ_MINIPORT(NS87560)
DECLARE_EISA_IRQ_MINIPORT(Compaq3)
DECLARE_EISA_IRQ_MINIPORT(M1533)
DECLARE_IRQ_MINIPORT(OptiFireStar)
DECLARE_EISA_IRQ_MINIPORT(VT586)
DECLARE_EISA_IRQ_MINIPORT(CPQOSB)
DECLARE_EISA_IRQ_MINIPORT(CPQ1000)
DECLARE_EISA_IRQ_MINIPORT(Cx5520)
DECLARE_IRQ_MINIPORT(Toshiba)
DECLARE_IRQ_MINIPORT(NEC)
DECLARE_IRQ_MINIPORT(VESUVIUS)

//
// Table of chipset drivers.
//

const CHIPSET_DATA rgChipData[] = {
    DECLARE_EISA_CHIPSET(Mercury),          // Intel 82374EB\SB (80860482)
    DECLARE_EISA_CHIPSET(Triton),           // Intel 82430FX (8086122E)
    DECLARE_CHIPSET(VLSI),                  // VLSI VL82C596/7
    DECLARE_CHIPSET(OptiViper),             // OPTi Viper-M
    DECLARE_EISA_CHIPSET(SiS5503),          // SIS P54C
    DECLARE_CHIPSET(VLSIEagle),             // VLSI VL82C534
    DECLARE_EISA_CHIPSET(M1523),            // ALi M1523
    DECLARE_CHIPSET(NS87560),               // Nat Semi NS87560
    DECLARE_EISA_CHIPSET(Compaq3),          // Compaq MISC 3
    DECLARE_EISA_CHIPSET(M1533),            // ALi M1533
    DECLARE_CHIPSET(OptiFireStar),          // OPTI FIRESTAR
    DECLARE_EISA_CHIPSET(VT586),            // VIATECH 82C586B
    DECLARE_EISA_CHIPSET(CPQOSB),           // Conpaq OSB
    DECLARE_EISA_CHIPSET(CPQ1000),          // Conpaq 1000
    DECLARE_EISA_CHIPSET(Cx5520),           // Cyrix 5520
    DECLARE_CHIPSET(Toshiba),               // Toshiba
    DECLARE_CHIPSET(NEC),                   // NEC PC9800
    DECLARE_CHIPSET(VESUVIUS)               //
};

#define NUMBER_OF_CHIPSETS  (sizeof(rgChipData) / sizeof(CHIPSET_DATA))

//
// Global variables shared by all modules.
//

ULONG           bBusPIC     = -1;
ULONG           bDevFuncPIC    = -1;
CHIPSET_DATA const* rgChipSet = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PciirqmpInit)
#pragma alloc_text(PAGE, PciirqmpExit)
#pragma alloc_text(PAGE, PciirqmpValidateTable)
#endif //ALLOC_PRAGMA

NTSTATUS
PciirqmpInit (
    ULONG   Instance,
    ULONG   RouterBus,
    ULONG   RouterDevFunc
    )

/*++

Routine Description:

    This routine initializes calls the individual chipset handler
    to validate the Pci Irq Routing Table.

Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table.

    Flags - Flags specifying source of the Pci Irq Routing Table.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
	PAGED_CODE();

    //
    // Check to make sure that we are not already initialized.
    //

    if (rgChipSet != NULL)
    {
        PCIIRQMPPRINT(("IRQ miniport already initialized!"));
        return (PCIIRQMP_STATUS_ALREADY_INITIALIZED);
    }

    //
    // Check for invalid instance.
    //

    if (Instance >= NUMBER_OF_CHIPSETS)
    {
        PCIIRQMPPRINT(("Invalid IRQ miniport instance %08X", Instance));
        return (PCIIRQMP_STATUS_INVALID_INSTANCE);
    }

    //
    // Save our global data.
    //

    rgChipSet = &rgChipData[Instance];
    bBusPIC = RouterBus;
    bDevFuncPIC = RouterDevFunc;

    return (PCIMP_SUCCESS);
}

NTSTATUS
PciirqmpExit (
    VOID
    )

/*++

Routine Description:

    This routine cleans up after the Pci Irq Routing miniport library.

Parameters:

    None.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
	PAGED_CODE();

    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Cannot exit without having been initialized!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Clean up.
    //

    rgChipSet = NULL;
    bBusPIC = -1;
    bDevFuncPIC = -1;

    return (PCIMP_SUCCESS);
}

NTSTATUS
PciirqmpValidateTable (
    IN PPCI_IRQ_ROUTING_TABLE  PciIrqRoutingTable,
    IN ULONG                   Flags
    )

/*++

Routine Description:

    This routine normalizes calls the individual chipset handler
    to validate the Pci Irq Routing Table.

Parameters:

    PciIrqRoutingTable - Pci Irq Routing Table.

    Flags - Flags specifying source of the Pci Irq Routing Table.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
	PAGED_CODE();

    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler.
    //

    return (rgChipSet->ValidateTable(PciIrqRoutingTable, Flags));
}

NTSTATUS
PciirqmpGetIrq (
    OUT PUCHAR  Irq,
    IN  UCHAR   Link
    )

/*++

Routine Description:

    This routine calls the individual chipset handler
    to set the link to the specified Irq.

Parameters:

    Irq - Variable that receives the Irq.

    Link - Link to be read.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler.
    //

    return (rgChipSet->GetIrq(Irq, Link));
}

NTSTATUS
PciirqmpSetIrq (
    IN UCHAR   Irq,
    IN UCHAR   Link
    )

/*++

Routine Description:

    This routine calls the individual chipset handler
    to set the link to the specified Irq.

Parameters:

    Irq - Irq to be set.

    Link - Link to be programmed.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler.
    //

    return (rgChipSet->SetIrq(Irq, Link));
}

NTSTATUS
PciirqmpGetTrigger (
    OUT PULONG  Trigger
    )

/*++

Routine Description:

    This routine calls the individual chipset handler
    to get the interrupt edge\level mask.

Parameters:

    Trigger - Variable that receives edge\level mask.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler.
    //

    return (rgChipSet->GetTrigger(Trigger));
}

NTSTATUS
PciirqmpSetTrigger (
    IN ULONG   Trigger
    )

/*++

Routine Description:

    This routine calls the individual chipset handler
    to set the interrupt edge\level mask.

Parameters:

    Trigger - Edge\level mask to be set.

Return Value:

    Standard Pci Irq Miniport return value.

Notes:

--*/

{
    //
    // Were we ever initialized?
    //

    if (rgChipSet == NULL)
    {
        PCIIRQMPPRINT(("Not initialized yet!"));
        return (PCIIRQMP_STATUS_NOT_INITIALIZED);
    }

    //
    // Call the chipset handler and return the result.
    //

    return (rgChipSet->SetTrigger(Trigger));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\sis5503.c ===
/*
 *  SIS5503.C - SiS5503 PCI System I/O chipset routines
 *
 *  Notes:
 *  Algorithms from SiS Pentium/P54C PCI/ISA Chipset databook.
 *
 */

#include "local.h"

/****************************************************************************
 *
 *  SiS5503SetIRQ - Set an SiS PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
SiS5503SetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR bRegValue;
    
    //
    // Validate link number.
    //
    if (bLink < 0x40) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Use 0x80 to disable.
    //
    if (!bIRQNumber)
        bIRQNumber=0x80;

    //
    // Preserve other bits.
    //  
    bRegValue= (ReadConfigUchar(bBusPIC, bDevFuncPIC, bLink)&(~0x8F))|(bIRQNumber&0x0F);
    
    //
    // Set the SiS IRQ register.
    //
    WriteConfigUchar(bBusPIC, bDevFuncPIC, bLink, bRegValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  SiS5503GetIRQ - Get the IRQ of an SiS5503 PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
SiS5503GetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    //
    // Validate link number.
    //
    if (bLink < 0x40) {

        return(PCIMP_INVALID_LINK);
    }

    //
    // Store the IRQ value.
    //
    *pbIRQNumber=(ReadConfigUchar(bBusPIC, bDevFuncPIC, bLink)&0x8F);

    //
    // Return 0 if disabled.
    //
    if (*pbIRQNumber & 0x80)
        *pbIRQNumber=0;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  Sis5503ValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
SiS5503ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, SiS5503ValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
SiS5503ValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    if ((ulFlags & PCIMP_VALIDATE_SOURCE_BITS)==PCIMP_VALIDATE_SOURCE_PCIBIOS) {

        //
        // If all links are above 40, we they are config space.
        //
        if (GetMinLink(piihIRQInfoHeader)>=0x40)
            return(PCIMP_SUCCESS);

        //
        // If there are links above 4, we are clueless.
        //
        if (GetMaxLink(piihIRQInfoHeader)>0x04)
            return(PCIMP_FAILURE);

        //
        // Assume 1,2,3,4 are the 41,42,43,44 links.
        //
        NormalizeLinks(piihIRQInfoHeader, 0x40);
        
    } else {

        //
        // Validate that all config space addresses are above 40.
        //
        if (GetMinLink(piihIRQInfoHeader)<0x40)
            return(PCIMP_FAILURE);
    }

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\toshiba.c ===
/*
 *  TOSHIBA.C - Toshiba Tecra IRQ routing spec
 *
 *  Notes:
 *  Algorithms from TECS-1010-1001
 *
 */

#include "local.h"

GLOBAL_DATA ULONG   SMIPort=0xB2;

/****************************************************************************
 *
 *  CallSMI - Get into SMI
 *
 *  Not exported.
 *
 *  ENTRY:  rAX is the value for AX as input.
 *
 *      rBX is the value for BX as input.
 *
 *      rCX is the value for CX as input.
 *
 *      prCX is filled with the returned CX, if not NULL.
 *
 *  EXIT:   TRUE iff no error.
 *
 ***************************************************************************/
BOOLEAN CDECL
CallSMI(ULONG rAX, ULONG rBX, ULONG rCX, PULONG prCX)
{
    ULONG   ulAX, ulCX;

    _asm    mov eax, rAX
    _asm    mov ebx, rBX
    _asm    mov ecx, rCX
    _asm    mov edx, SMIPort
    _asm    in  al, dx
    _asm    movzx   ecx, cx
    _asm    mov ulCX, ecx
    _asm    movzx   eax, ah
    _asm    mov ulAX, eax

    if (prCX)
        *prCX=ulCX;

    return(ulAX==0);
}

/****************************************************************************
 *
 *  ToshibaSetIRQ - Set a Toshiba PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    //
    // Use 0xFF to disable.
    //
    if (!bIRQNumber)
        bIRQNumber=0xFF;

    //
    // Ask SMI to set the link.
    //
    return(CallSMI( 0xFF44,
            0x0701,
            (bLink<<8)+bIRQNumber,
            NULL) ?
                PCIMP_SUCCESS :
                PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  ToshibaGetIRQ - Get the IRQ of a Toshiba PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    ULONG   ulCX;

    //
    // Ask SMI to get the link.
    //
    if (!CallSMI(   0xFE44,
            0x0701,
            bLink<<8,
            &ulCX))
        return(PCIMP_FAILURE);

    //
    // Get the byte only.
    //
    ulCX&=0xFF;

    //
    // Use 0xFF to disable.
    //
    if (ulCX==0xFF)
        ulCX=0;

    //
    // Store the IRQ value.
    //
    *pbIRQNumber=(UCHAR)ulCX;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  ToshibaSetTrigger - Set the IRQ triggering values for the Toshiba
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaSetTrigger(ULONG ulTrigger)
{
    //
    // Ask SMI to set the triggering mechanism.
    //
    return(CallSMI( 0xFF44,
            0x0702,
            ulTrigger,
            NULL) ?
                PCIMP_SUCCESS :
                PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  ToshibaGetTrigger - Get the IRQ triggering values for the Toshiba
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
ToshibaGetTrigger(PULONG pulTrigger)
{
    //
    // Assume all edge.
    //
    *pulTrigger = 0;

    //
    // Ask SMI to get the triggering mechanism.
    //
    return(CallSMI( 0xFE44,
            0x0702,
            0,
            pulTrigger) ?
                PCIMP_SUCCESS :
                PCIMP_FAILURE);
}

/****************************************************************************
 *
 *  ToshibaValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
ToshibaValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, ToshibaValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
ToshibaValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    SMIPort=*(((PUSHORT)&(piihIRQInfoHeader->MiniportData))+1);

    return(((ulFlags & PCIMP_VALIDATE_SOURCE_BITS)==PCIMP_VALIDATE_SOURCE_PCIBIOS) ?
        PCIMP_FAILURE : PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\pciirqmp\i386\vesuvius.c ===
/*
 *  VESUVIUS.C - NS VESUVIUS PCI chipset routines.
 *
 *  Notes:
 *  Algorithms from NS VESUVIUS Data Sheet
 *
 */

#include "local.h"

LOCAL_DATA  PIRQINFOHEADER gpiihIRQInfoHeader=NULL;

UCHAR
ReadIndexRegisterByte(UCHAR bIndex)
{
    UCHAR bOldIndex, bResult;

    bOldIndex=READ_PORT_UCHAR((PUCHAR)0x24);

    WRITE_PORT_UCHAR((PUCHAR)0x24, bIndex);

    bResult=READ_PORT_UCHAR((PUCHAR)0x26);

    WRITE_PORT_UCHAR((PUCHAR)0x24, bOldIndex);

    return(bResult);
}

VOID
WriteIndexRegisterByte(UCHAR bIndex, UCHAR bValue)
{
    UCHAR bOldIndex;

    bOldIndex=READ_PORT_UCHAR((PUCHAR)0x24);

    WRITE_PORT_UCHAR((PUCHAR)0x24, bIndex);

    WRITE_PORT_UCHAR((PUCHAR)0x26, bValue);

    WRITE_PORT_UCHAR((PUCHAR)0x24, bOldIndex);
}

/****************************************************************************
 *
 *  VESUVIUSSetIRQ - Set a VESUVIUS PCI link to a specific IRQ
 *
 *  Exported.
 *
 *  ENTRY:  bIRQNumber is the new IRQ to be used.
 *
 *      bLink is the Link to be set.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSSetIRQ(UCHAR bIRQNumber, UCHAR bLink)
{
    UCHAR   bIndex, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Zero based.
    //
    bLink--;
    //
    // Set various values.
    //
    bIndex=(bLink/2)+0x10;

    //
    // Read the old VESUVIUS IRQ register.
    //
    bOldValue=ReadIndexRegisterByte(bIndex);

    if (bLink&1) {
        bOldValue&=0x0f;
        bOldValue|=(bIRQNumber<<4);
    }
    else {
        bOldValue&=0xf0;
        bOldValue|=bIRQNumber;
    }

    //
    // Set the VESUVIUS IRQ register.
    //
    WriteIndexRegisterByte(bIndex, bOldValue);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VESUVIUSGetIRQ - Get the IRQ of a VESUVIUS PCI link
 *
 *  Exported.
 *
 *  ENTRY:  pbIRQNumber is the buffer to fill.
 *
 *      bLink is the Link to be read.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSGetIRQ(PUCHAR pbIRQNumber, UCHAR bLink)
{
    UCHAR   bIndex, bOldValue;
    //
    // Validate link number.
    //
    if (bLink > 4) {

        return(PCIMP_INVALID_LINK);
    }
    //
    // Zero based.
    //
    bLink--;
    //
    // Set various values.
    //
    bIndex=(bLink/2)+0x10;
    //
    // Read the old VESUVIUS IRQ register.
    //
    bOldValue=ReadIndexRegisterByte(bIndex);

    if (bLink&1)
        bOldValue>>=4;

    *pbIRQNumber=bOldValue&0x0f;

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VESUVIUSSetTrigger - Set the IRQ triggering values for the VESUVIUS
 *
 *  Exported.
 *
 *  ENTRY:  ulTrigger has bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSSetTrigger(ULONG ulTrigger)
{
    ULONG i;
    UCHAR bMask;

    bMask=(UCHAR)(ReadIndexRegisterByte(0x12)&0x0f);

    for (i=0; i<4; i++)
    {
        UCHAR bIRQ=ReadIndexRegisterByte((UCHAR)((i/2)+0x10));
        if (i&1)
            bIRQ>>=4;
        bIRQ&=0x0f;

        //
        // PCI interrupts go through L-E conversion.
        //
        if(bIRQ && (ulTrigger & (1<<bIRQ)))
        {
            bMask&=~(1<<i);
            ulTrigger&=~(1<<bIRQ);
        }
    }

    //
    // Return error if PCI is goofing up.
    //
    if (ulTrigger)
        return (PCIMP_FAILURE);

    WriteIndexRegisterByte(0x12, bMask);

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VESUVIUSGetTrigger - Get the IRQ triggering values for the VESUVIUS
 *
 *  Exported.
 *
 *  ENTRY:  pulTrigger will have bits set for Level triggered IRQs.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
PCIMPRET CDECL
VESUVIUSGetTrigger(PULONG pulTrigger)
{
    UCHAR   bMask;
    ULONG   i;

    *pulTrigger=0;

    bMask=(UCHAR)(ReadIndexRegisterByte(0x12)&0x0f);

    for (i=0; i<4; i++)
    {
        if (!(bMask&(1<<i)))
        {
            UCHAR bIRQ=ReadIndexRegisterByte((UCHAR)((i/2)+0x10));
            if (i&1)
                bIRQ>>=4;
            bIRQ&=0x0f;
            if (bIRQ)
                *pulTrigger|=(1<<bIRQ);
        }
    }

    return(PCIMP_SUCCESS);
}

/****************************************************************************
 *
 *  VESUVIUSValidateTable - Validate an IRQ table
 *
 *  Exported.
 *
 *  ENTRY:  piihIRQInfoHeader points to an IRQInfoHeader followed
 *      by an IRQ Routing Table.
 *
 *      ulFlags are PCIMP_VALIDATE flags.
 *
 *  EXIT:   Standard PCIMP return value.
 *
 ***************************************************************************/
#ifdef ALLOC_PRAGMA
PCIMPRET CDECL
VESUVIUSValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags);
#pragma alloc_text(PAGE, VESUVIUSValidateTable)
#endif //ALLOC_PRAGMA

PCIMPRET CDECL
VESUVIUSValidateTable(PIRQINFOHEADER piihIRQInfoHeader, ULONG ulFlags)
{
    PAGED_CODE();

    gpiihIRQInfoHeader=piihIRQInfoHeader;
    //
    // If any link is above 4, it is an error.
    //
    if (GetMaxLink(piihIRQInfoHeader)>4)
        return(PCIMP_FAILURE);

    return(PCIMP_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk6\amdk6.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    amdk6.c

Abstract:

    This module implements code specific to the AMDK6-2 processor


Author:

    Todd Carpenter (7/20/00) - create file

Environment:

    Kernel mode

Notes:

  DeviceInst  = "ACPI\AuthenticAMD_-_x86_Family_5_Model_13"
  ServiceName = "amdk6"

Revision History:


--*/
#include "amdk6.h"
#include "..\lib\processor.h"

#if DBG
PUCHAR DebugName = "AmdK6.sys";
#endif

PFDO_DATA DeviceExtensions[MAX_SUPPORTED_PROCESSORS];
UCHAR DevExtIndex;

extern GLOBALS Globals;
extern LEGACY_GEMINI_SMI LegacyInterface;


#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeNonAcpiPerformanceStates)
#pragma alloc_text (PAGE, InitializeAcpi2PStates)
#pragma alloc_text (PAGE, InitializeAcpi2Cstates)
#pragma alloc_text (PAGE, MergePerformanceStates)
#endif


NTSTATUS
InitializeDriver(
  PUNICODE_STRING ServiceKeyRegPath
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  return STATUS_SUCCESS;
}

NTSTATUS
 InitializeNonAcpiPerformanceStates(
  IN PFDO_DATA DeviceExtension
  )
/*++

Routine Description:

    This function tries to gather as much information as it can about what
    states are available.  It puts a table in the device extension that
    describes the available states.  Unfortunately, we might not have enough
    information to fill in the state table, as the BIOS doesn't tell us much.
    We try to run through all the states, figuring out what we can about them
    as we pass through them.  But some states may not be available at the
    moment, particularly if we are running on DC power at the moment.  So some
    states may have zeros in the table.

Arguments:

   FdoData - pointer to the device extension

Return Value:

    NT status code


--*/
{
  LARGE_INTEGER   perfCounterOld, perfCounterNew;
  LARGE_INTEGER   perfFreq, latency;
  ULONG           newState, maxFreq, currentFreq;
  ULONG           currentlatency, maxTransitionLatency = 0;
  ULONG           perfStatesSize;
  UCHAR           i;
  NTSTATUS        status;

  PLEGACY_GEMINI_SMI info = &LegacyInterface;

  DebugEnter();
  PAGED_CODE();


  //
  // We automatically fail to use the Legacy Interface
  //
  
  if (Globals.HackFlags & DISABLE_LEGACY_INTERFACE_FLAG) {
    DebugPrint((ERROR, " Legacy Interface Disabled\n"));
    return STATUS_NOT_FOUND;
  }
  

  //
  // Find and gather legacy interface info
  //

  status = InitializeLegacyInterface();

  if (!NT_SUCCESS(status)) {
    DebugExitStatus(status);
    return status;
  }

  //
  // Found Legacy Interface, and is available to use.
  //

  DeviceExtension->LegacyInterface = TRUE;

  if (info->CurrentlyAvailableStates == 0) {
    status = STATUS_NOT_FOUND;
    DebugPrint((ERROR, "  Found Legacy Interface, but no perfstates.\n"));
    DebugExitStatus(status);
    return status;
  }

  //
  // if there were already PerfStates, they were probably acpi 1.0 type
  // throttling, so we will blow them away, because they will be recreated
  // in MergePerformanceStates()
  //

  if (DeviceExtension->PerfStates) {
    ExFreePool(DeviceExtension->PerfStates);
  }

  perfStatesSize = sizeof(PROCESSOR_PERFORMANCE_STATES) +
                     (sizeof(PROCESSOR_PERFORMANCE_STATE) *
                     (info->CurrentlyAvailableStates - 1));


  DeviceExtension->PerfStates = ExAllocatePoolWithTag(PagedPool,
                                                      perfStatesSize,
                                                      PROCESSOR_POOL_TAG);


  if (!DeviceExtension->PerfStates) {

    status = STATUS_INSUFFICIENT_RESOURCES;
    goto InitalizeNonAcpiPerformanceStatesExit;

  }

  RtlZeroMemory(DeviceExtension->PerfStates, perfStatesSize);


  //
  // Jump through each state so that we can figure out how to fill in
  // the table.  Start by jumping to the low state.
  //

  DebugPrint((INFO, "Perf States available: 0x%x  Current State: 0x%x\n",
              info->CurrentlyAvailableStates,
              info->CurrentState));


  if (info->CurrentlyAvailableStates >= 1) {

    if (info->CurrentState != 0) {

      TRAP();

      //
      // Go to the highest state available
      //

      status = AcpiPerfStateTransition(DeviceExtension, 0);
                      
      if (!NT_SUCCESS(status)) {
        goto InitalizeNonAcpiPerformanceStatesExit;
      }
    }

    maxFreq = GetMaxProcFrequency(DeviceExtension);
    DebugAssert(maxFreq != 0);

    //
    // Get Perf Counter Frequency
    //
    KeQueryPerformanceCounter(&perfFreq);

    for (i = 0; i < info->CurrentlyAvailableStates; i++) {

      newState = info->CurrentlyAvailableStates - i - 1;

      perfCounterOld = KeQueryPerformanceCounter(NULL);
      status = AcpiPerfStateTransition(DeviceExtension, newState); 
      perfCounterNew = KeQueryPerformanceCounter(NULL);


      if (!NT_SUCCESS(status)) {
        goto InitalizeNonAcpiPerformanceStatesExit;
      }


      //
      // Calculate transition latency.
      //
      currentlatency = (ULONG)((perfCounterNew.QuadPart - perfCounterOld.QuadPart) *
                       1000000 / perfFreq.QuadPart);

      //
      // Save highest transition latency
      //
      maxTransitionLatency = MAX(maxTransitionLatency, currentlatency);

      DebugPrint((INFO, "Jumped to state 0x%x in %d microseconds\n",
                  newState,
                  currentlatency));


      //
      // Get current speed.
      //

      GetCpuFrequency(newState, &currentFreq);
      DebugAssert(currentFreq != 0);
      
      DeviceExtension->PerfStates->State[newState].Frequency = currentFreq;
      DeviceExtension->PerfStates->State[newState].PercentFrequency = (UCHAR)
        PERCENT_TO_PERF_LEVEL((currentFreq * 100) / maxFreq);
        

      //
      // Mark this as a Perf State
      //
      
      DeviceExtension->PerfStates->State[newState].Flags = PROCESSOR_STATE_TYPE_PERFORMANCE;

    }
  }

  DeviceExtension->PerfStates->TransitionLatency  = maxTransitionLatency;
  DeviceExtension->PerfStates->TransitionFunction = SetPerfLevel;
  DeviceExtension->PerfStates->Count = (UCHAR) info->CurrentlyAvailableStates;
  DeviceExtension->LowestPerfState = info->CurrentlyAvailableStates - 1;


  
  //
  // Return to orginal perf state.
  //
  
  status = AcpiPerfStateTransition(DeviceExtension, info->CurrentState); 
 
  if (!NT_SUCCESS(status)) {
    goto InitalizeNonAcpiPerformanceStatesExit;
  }

  //
  // Check to ensure that state 0 is higher than lowest perf state.
  //

  DebugAssert(DeviceExtension->PerfStates->State[0].Frequency >
              DeviceExtension->PerfStates->State[DeviceExtension->LowestPerfState].Frequency);


  //
  // Merge Perf states with other states we may have.
  //

  DumpProcessorPerfStates(DeviceExtension->PerfStates);
  status = MergePerformanceStates(DeviceExtension);


  InitalizeNonAcpiPerformanceStatesExit:

  if (!NT_SUCCESS(status)) {

    if (DeviceExtension->PerfStates) {
      ExFreePool(DeviceExtension->PerfStates);
    }

    DeviceExtension->PerfStates = NULL;
    DeviceExtension->LegacyInterface = FALSE;
  }
  
  DebugExitStatus(status);
  return status;
}


NTSTATUS
AcpiLegacyPerfStateTransition(
  IN PFDO_DATA    DeviceExtension,
  IN ULONG        State
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  //return SetCurrentStateSmm(State);
  return SetCurrentStateMSR(State);
}


NTSTATUS
FASTCALL
SetPerfLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();


  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }
  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetPerfLevelGeneric(Throttle, DeviceExtension);

}

NTSTATUS
FASTCALL
SetThrottleLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();

  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }

  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];
  

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return SetThrottleLevelGeneric(Throttle, DeviceExtension);

}


NTSTATUS
InitializeAcpi2PStates(
  IN PFDO_DATA DevExt
  )
/*++

  Routine Description:
 

  Arguments:
  

  Return Value:


--*/
{
  NTSTATUS status;

  status = InitializeAcpi2PStatesGeneric(DevExt);

  //
  // Make sure we didn't find any NON I/O or MEM addresses
  //
  
  if (NT_SUCCESS(status)) {
  
    if (((DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceIO) ||
         (DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceMemory)) ||
        ((DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceIO) ||
         (DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceMemory))) {

      DebugPrint((WARN, "ONLY Memory & I/O _PCT addresses are supported\n"));
      DebugPrint((WARN, "NOT using Acpi 2.0 Performance States\n"));

      //
      // Undo what InitializeAcpi2PStatesGeneric() did
      //

      if (DevExt->PssPackage) {
        ExFreePool(DevExt->PssPackage);
        DevExt->PssPackage = NULL;
      }
      
      return STATUS_NOT_SUPPORTED;
    }

    //
    // Walk through _PSS states to calculate latency values
    //
    
    ValidatePssLatencyValues(DevExt);

    //
    // Need to merge this new data with our perfstates
    //
  
    MergePerformanceStates(DevExt);

  }

  return status;
}

NTSTATUS
InitializeAcpi2Cstates(
    PFDO_DATA DevExt
    )
/*++

Routine Description:

    This function looks to see if there is an ACPI 2.0 _CST object in the
    namespace, and, if there is, it replaces the functions found by
    InitializeAcpi1Cstates.

    Further note:  This function leaves the filling in of throttling functions
    to the InitializePerformanceStates functions.

Arguments:

    DeviceExtension

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
  ULONG  apicId;
  ULONG  index = 0;

  DebugEnter();

  
  //
  // Record the address of this processor's DeviceExtension, as the
  // throttling API doesn't give it to us.
  //

  if (!Globals.SingleProcessorProfile) {

    //
    // save the index into the DeviceExtension[] for later retrieval based
    // on APIC Id.
    //
    
    apicId = Globals.ProcInfo.ProcIdToApicId[DevExt->ProcObjInfo.PhysicalID];  
    Globals.ProcInfo.ApicIdToDevExtIndex[apicId] = DevExtIndex;

    index = DevExtIndex++;
    
  }

  
  //
  // save Device Extension pointer
  //
  
  DeviceExtensions[index] = DevExt;
  


  //
  //  This processor driver only supports I/O Space based Cstates.
  //  InitializeAcpi2IoSpaceCstates() will fail if it finds Cstates with
  //  non AcpiGenericSpaceIO type addresses.
  //

  return InitializeAcpi2IoSpaceCstates(DevExt);

}

NTSTATUS
MergePerformanceStates (
  IN  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:

      This routine looks at the performance states stored in the device extension.

  Arguments:

      DeviceExtension


  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

  NOTE:

      - The caller must hold PerfStateLock.

      - This is called during START_DEVICE, and after recieving a Notify(0x80)
        on the processor.

--*/
{

  DebugEnter();

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return MergePerformanceStatesGeneric(DeviceExtension);

}


NTSTATUS
Acpi2PerfStateTransition(
  IN PFDO_DATA DeviceExtension,
  IN ULONG     State
  )
/*++

Routine Description:

    This routine changes the performance state of the processor
    based on ACPI 2.0 performance state objects.

Arguments:

    State - Index into _PSS object

Return Value:

    none

--*/
{

  //
  // Since this driver does not support Functional Fixed Hardware, we
  // use generic method.
  //

  return Acpi2PerfStateTransitionGeneric(DeviceExtension, State);

}


NTSTATUS
ProcessResumeFromSleepState(
  SYSTEM_POWER_STATE PreviousState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugEnter();

  //
  // if we are resuming from Hibernate, and this is an Acpi 2.0 system,
  // we must re-claim perf state and cstate control from the bios.
  //

  if (PreviousState == PowerSystemHibernate) {

    if (DeviceExtension->PssPackage) {
    
      AssumeProcessorPerformanceControl();
    }
    
    if (DeviceExtension->CstPresent) {
      AssumeCStateControl();
    }
    
  }

  //
  // Reinit the legacy interface
  //

  if (DeviceExtension->LegacyInterface) {
    EnableGeminiTransitionsMSR(&LegacyInterface.EpmIoAddress);
  }

  //
  // restore previous state
  //

  return RestoreToSavedPerformanceState(DeviceExtension);

}


NTSTATUS
ProcessSuspendToSleepState(
  SYSTEM_POWER_STATE TargetState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{ 
  DebugEnter();

  //
  // save current state, transition to lowest non-throttled perf state
  //

  return SaveCurrentStateGoToLowVolts(DeviceExtension);
}


NTSTATUS
GetProcessorBrandString (
  PUCHAR BrandString,
  PULONG Size
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:


--*/
{
  //
  // This processor family supports CPUID Brand String
  //
  
  return GetCPUIDProcessorBrandString(BrandString, Size);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\processor\amdk7\amdk7.c ===
/*++

  Copyright (c) 2000  Microsoft Corporation
  
  Module Name:
  
    amdk7.c
  
  Abstract:
  
    This module implements code specific to the AMDK7 processor
  
  
  Author:
  
    Todd Carpenter (1/30/01) - create file
  
  Environment:
  
    Kernel mode
  
  Notes:
  
    DeviceInst  = "ACPI\AuthenticAMD_-_x86_Family_6_Model_6"
    ServiceName = "amdk7"
    
  Revision History:


--*/
#include "..\lib\processor.h"
#include "amdk7.h"

#if DBG
PUCHAR DebugName = "AmdK7.sys";
#endif

PFDO_DATA DeviceExtensions[MAX_SUPPORTED_PROCESSORS];
UCHAR DevExtIndex;
ULONG AmdK7HackFlags;

extern GLOBALS Globals;


#ifdef ALLOC_PRAGMA
#pragma alloc_text (PAGE, InitializeDriver)
#pragma alloc_text (PAGE, GetProcessorBrandString)
#pragma alloc_text (PAGE, InitializeAcpi2PStates)
#pragma alloc_text (PAGE, InitializeAcpi2Cstates)
#pragma alloc_text (PAGE, MergePerformanceStates)
#endif


NTSTATUS
InitializeDriver(
  PUNICODE_STRING ServiceKeyRegPath
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  //
  // Get AmdK7 Hack Flags
  //

  GetRegistryDwordValue((PWCHAR) AMDK7_PARAMETERS_KEY, 
                        L"HackFlags", 
                        &AmdK7HackFlags);
  
  return STATUS_SUCCESS;
}


NTSTATUS
FASTCALL
SetPerfLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();


  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }
  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];

  //
  // This driver only supports FFH addresses, but SetPerfLevelGeneric
  // only finds the correct state, it will then call Acpi2PerfStateTransition
  //

  return SetPerfLevelGeneric(Throttle, DeviceExtension);

}

NTSTATUS
FASTCALL
SetThrottleLevel(
  IN UCHAR Throttle
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  PFDO_DATA   DeviceExtension;
  ULONG       apicId;
  ULONG       index = 0;

  DebugEnter();

  //
  // Get APIC Id and retrieve Device Extension index
  //

  if (!Globals.SingleProcessorProfile) {
    apicId = GetApicId();
    index = Globals.ProcInfo.ApicIdToDevExtIndex[apicId];
  }

  
  //
  // Get the DeviceExtension.
  //
  
  DeviceExtension = DeviceExtensions[index];
  

  //
  // This driver supports Acpi 1.0b style of throttling, use
  // generic function
  //

  return SetThrottleLevelGeneric(Throttle, DeviceExtension);

}


NTSTATUS
GetProcessorBrandString (
  PUCHAR BrandString,
  PULONG Size
  )
/*++

  Routine Description:
  
  Arguments:
  
  Return Value:

--*/
{
  //
  // This processor supports the CpuId based brand string
  //
  
  return GetCPUIDProcessorBrandString(BrandString, Size);
}


NTSTATUS
InitializeAcpi2PStates(
  IN PFDO_DATA DevExt
  )
/*++

  Routine Description:
  

  Arguments:
  

  Return Value:


--*/
{
  NTSTATUS status;

  status = InitializeAcpi2PStatesGeneric(DevExt);

  if (NT_SUCCESS(status)) {
  
    if ((DevExt->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceFixedFunction) ||
        (DevExt->PctPackage.Status.AddressSpaceID != AcpiGenericSpaceFixedFunction)) {

      DebugPrint((WARN, "ONLY Acpi 2.0 FFH addresses are supported\n"));
      DebugPrint((WARN, "NOT using Acpi 2.0 Performance States\n"));

      //
      // Undo what InitializeAcpi2PStatesGeneric() did
      //

      if (DevExt->PssPackage) {
        ExFreePool(DevExt->PssPackage);
        DevExt->PssPackage = NULL;
      }
      
      return STATUS_NOT_SUPPORTED;
    }

    //
    // Walk through _PSS states to calculate latency values
    //
    
    ValidatePssLatencyValues(DevExt);

    //
    // Need to merge this new data with our perfstates
    //
  
    MergePerformanceStates(DevExt);
    
  }

  return status;
}


NTSTATUS
InitializeAcpi2Cstates(
  PFDO_DATA DevExt
  )
/*++

Routine Description:

    This function looks to see if there is an ACPI 2.0 _CST object in the
    namespace, and, if there is, it replaces the functions found by
    InitializeAcpi1Cstates.

    Further note:  This function leaves the filling in of throttling functions
    to the InitializePerformanceStates functions.

Arguments:

    DeviceExtension

Return Value:

    A NTSTATUS code to indicate the result of the initialization.

--*/
{
  ULONG  apicId;
  ULONG  index = 0;

  DebugEnter();

  
  //
  // Record the address of this processor's DeviceExtension, as the
  // throttling API doesn't give it to us.
  //

  if (!Globals.SingleProcessorProfile) {

    //
    // save the index into the DeviceExtension[] for later retrieval based
    // on APIC Id.
    //
    
    apicId = Globals.ProcInfo.ProcIdToApicId[DevExt->ProcObjInfo.PhysicalID];  
    Globals.ProcInfo.ApicIdToDevExtIndex[apicId] = DevExtIndex;

    index = DevExtIndex++;
    
  }

  
  //
  // save Device Extension pointer
  //
  
  DeviceExtensions[index] = DevExt;
  


  //
  //  This processor driver only supports I/O Space based Cstates.
  //  InitializeAcpi2IoSpaceCstates() will fail if it finds Cstates with
  //  non AcpiGenericSpaceIO type addresses.
  //

  return InitializeAcpi2IoSpaceCstates(DevExt);

}

NTSTATUS
MergePerformanceStates(
  IN  PFDO_DATA DeviceExtension
  )
/*++

  Routine Description:

      This routine looks at the performance states stored in the device extension.

  Arguments:

      DeviceExtension


  Return Value:

      A NTSTATUS code to indicate the result of the initialization.

  NOTE:

      - The caller must hold PerfStateLock.

      - This is called during START_DEVICE, and after recieving a Notify(0x80)
        on the processor.

--*/
{
  NTSTATUS status;
  NTSTATUS findStatus;
  ULONG    pssState = 0xdeadbeef;
  
  DebugEnter();

  //
  // This function just merges available _PSS and stop clock throttle states
  //

  status = MergePerformanceStatesGeneric(DeviceExtension);

  //
  // With amdk7.sys, the order of transition execution differs if going from a
  // higher state to a lower state when compared to going from a lower state to
  // a higher state... Therefore, it is important that we set the current state 
  // before registering new performance states with the kernel.
  //
  // NOTE: MergePerformanceStatesGeneric() will invalidate CurrentPerfState,
  //       so it must be set here.
  //
  
  if (NT_SUCCESS(status)) {

    findStatus = FindCurrentPssPerfState(DeviceExtension->PssPackage, &pssState);

    if (NT_SUCCESS(findStatus)) {
      DebugAssert(pssState < DeviceExtension->PssPackage->NumPStates);
      DeviceExtension->CurrentPerfState = pssState;
    }
  }

  return status;
}


NTSTATUS
Acpi2PerfStateTransition(
  IN PFDO_DATA DeviceExtension,
  IN ULONG     NewState
  )
/*++

Routine Description:

    This routine changes the performance state of the processor
    based on ACPI 2.0 performance state objects.

Arguments:

    State - Index into _PSS object

Return Value:

    none

--*/
{
  NTSTATUS status = STATUS_SUCCESS;
  ULONG    transitionStatus;
  ULONG    pssControl;
  ULONG64  fidControl;
  ULONG64  vidControl;
  ULONG64  fidVidStatus;
    
  DebugEnter();
  DebugAssert(DeviceExtension->PssPackage)
  DebugAssert(NewState >= DeviceExtension->PpcResult);
  DebugAssert(NewState < DeviceExtension->PssPackage->NumPStates);
  DebugAssert(DeviceExtension->PssPackage->State[NewState].Control);

  
  if (DeviceExtension->PctPackage.Control.AddressSpaceID != AcpiGenericSpaceFixedFunction) {
    DebugAssert(!"Acpi2PerfStateTransition ONLY understands FFH addresses");
    status = STATUS_UNSUCCESSFUL;
    goto Acpi2PerfStateTransitionExit;
  }

  if (NewState == DeviceExtension->CurrentPssState) {
    DebugPrint((WARN, "Acpi2PerfStateTransition() CurrentState == TargetState, exiting...\n"));
    goto Acpi2PerfStateTransitionExit;
  }
  
  //
  // Transitioning the Mobile Athlon Processor requires two steps:
  //
  // If transitioning from a higher state to a lower state, then:
  // 1) core frequency transition
  // 2) core voltage transition
  //
  // If transitioning from a lower state to a higher state, then:
  // 1) core voltage transition
  // 2) core frequency transition
  //

  //
  // Get Frequency and Voltage value to write to MSR
  //
  
  pssControl = DeviceExtension->PssPackage->State[NewState].Control;
  fidControl = ConvertPssControlToFidVidControl(pssControl, TRUE);
  vidControl = ConvertPssControlToFidVidControl(pssControl, FALSE);

  if (NewState > DeviceExtension->CurrentPssState) {

    //
    // High -> Low
    //

    DebugPrint((TRACE, "Perf Transition: state %u -> state %u\n", DeviceExtension->CurrentPssState, NewState));
    DebugPrint((TRACE, "FidControl = 0x%I64x, VidControl = 0x%I64x\n", fidControl, vidControl));
    AmdK7FidVidTransition(fidControl);
    AmdK7FidVidTransition(vidControl);


  } else {

    //
    // Low -> High
    //

    DebugPrint((TRACE, "Perf Transition: state %u -> state %u\n", DeviceExtension->CurrentPssState, NewState));
    DebugPrint((TRACE, "VidControl = 0x%I64x, FidControl = 0x%I64x\n", vidControl, fidControl));
    AmdK7FidVidTransition(vidControl);
    AmdK7FidVidTransition(fidControl);

  }
  
  
  //
  // check status
  //

  fidVidStatus = ReadMSR(AMDK7_FID_VID_STATUS_MSR);
  transitionStatus = ConvertFidVidStatusToPssStatus(fidVidStatus);
  
  if (transitionStatus == DeviceExtension->PssPackage->State[NewState].Status) {

    DeviceExtension->CurrentPssState = NewState;

  } else {

    DebugPrint((ERROR, "ERROR! Expected 0x%x status value, recieved 0x%x\n",
                DeviceExtension->PssPackage->State[NewState].Status,
                transitionStatus));

    DebugPrint((ERROR, "_PSS[%u]->Status:\n", NewState));
    DumpPssStatus(DeviceExtension->PssPackage->State[NewState].Status);

    DebugPrint((ERROR, "FidVidStatus MSR:\n", fidVidStatus));
    DumpFidVidStatus(fidVidStatus);

    status = STATUS_UNSUCCESSFUL;
      
  }

  
Acpi2PerfStateTransitionExit:

  DebugExitStatus(status);
  return status;
  
}


NTSTATUS
ProcessResumeFromSleepState(
  SYSTEM_POWER_STATE PreviousState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugEnter();

  //
  // if we are resuming from Hibernate, and this is an Acpi 2.0 system,
  // we must re-claim perf state and cstate control from the bios.
  //

  if (PreviousState == PowerSystemHibernate) {

    if (DeviceExtension->PssPackage) {
      AssumeProcessorPerformanceControl();
    }
    
    if (DeviceExtension->CstPresent) {
      AssumeCStateControl();
    }
    
  }

  //
  // restore previous state
  //

  return RestoreToSavedPerformanceState(DeviceExtension);

}


NTSTATUS
ProcessSuspendToSleepState(
  SYSTEM_POWER_STATE TargetState,
  PFDO_DATA          DeviceExtension
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


--*/
{
  DebugEnter();

  //
  // save previous state, transition to lowest non-throttled perf state
  //

  return SaveCurrentStateGoToLowVolts(DeviceExtension);
}


ULONG64
ConvertPssControlToFidVidControl(
  ULONG PssControlValue,
  BOOLEAN Fid
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


  NOTES:

  _PSS Control field:
  
   Bit   Name
   ----  ----
    4:0  FID
    9:5  VID
   29:10 SGTC
   31:30 Reserved


  FidVidCtl:
  
  Bit   Name Function
  ----  ---- --------
   4:0  FID[4:0] New 5-bit FID to transition to
   7:5  reserved
  12:8  VID[4:0] New 5-bit VID to transition to
  15:13 reserved
  16    FIDC FID Control bit
  17    VIDC VID Control bit
  19:18 reserved
  20    FidChgRatio Fid Change Ratio (always set to 1)
  31:21 reserved
  51:32 SGTC[19:0] Stop-Grant Timeout Count (write only)
  63:52 reserved

--*/
{
  FID_VID_CONTROL fidVidControl = {0};
  PSS_CONTROL     pssControl;

  //DebugEnter();
  DebugAssert(PssControlValue);

  pssControl.AsDWord = PssControlValue;
  fidVidControl.Fid  = pssControl.Fid;
  fidVidControl.Vid  = pssControl.Vid;
  fidVidControl.FidChngRatio = 1;

  //
  // The timeout needed for the Frequency Transion (FID) is exactly half that 
  // needed by the Voltage Transion (VID).  We do this because of the latency
  // savings
  //
  
  if (Fid) {
  
    fidVidControl.SGTC = pssControl.SGTC / 2;
    fidVidControl.FidControl = 1;

  } else {

    fidVidControl.SGTC = pssControl.SGTC;
    fidVidControl.VidControl = 1;

  }
  
  return fidVidControl.AsQWord;
  
}


ULONG
ConvertFidVidStatusToPssStatus(
  ULONG64 FidVidStatusValue
  )
/*++

  Routine Description:


  Arguments:


  Return Value:


  NOTES:

    FidVidStatus:
   
    Bit   Name      Function
    ----  ----      --------
     4:0  CFID[4:0] Current 5-bit FID
     7:5  reserved
    12:8  SFID[4:0] Startup 5-bit FID
    15:13 reserved
    20:16 MFID[4:0] Maximum 5-bit FID
    31:21 reserved
    36:32 CVID[4:0] Current 5-bit VID
    39:37 reserved
    44:40 SVID[4:0] Startup 5-bit VID
    47:45 