E;
    CRegistry   creg;
    char        szUninstallKey[MAX_PATH] = "";
    WCHAR       wszUninstallKey[MAX_PATH] = L"";
    WCHAR       wszUninstallCommand[MAX_PATH] = L"";
    HKEY        hKey = NULL;

    //
    // Get the path for the uninstall key from the INF
    //
    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "UninstallKey",
                                szUninstallKey,
                                sizeof(szUninstallKey),
                                NULL);

    if (!fReturn) {
        return FALSE;
    }

    pAnsiToUnicode(szUninstallKey, wszUninstallKey, MAX_PATH);

    //
    // Attempt to create the key or open if it already exists
    //
    hKey = creg.CreateKey(HKEY_LOCAL_MACHINE,
                          wszUninstallKey,
                          KEY_SET_VALUE);

    if (NULL == hKey) {
        Print(ERROR, L"[InstallWriteUninstallKey] Failed to create key\n");
        return FALSE;
    }

    //
    // Set the DisplayName
    //
    fReturn = creg.SetString(hKey, 
                             NULL,
                             REG_DISPLAY_NAME,
                             g_si.lpwPrettyAppName,
                             FALSE);

    if (!fReturn) {
        Print(ERROR, L"[InstallWriteUninstallKey] Failed to set DisplayName\n");
        return FALSE;
    }

    //
    // Build the uninstall string
    //
    wsprintf(wszUninstallCommand, L"%s\\%s.exe %s", g_si.lpwInstallDirectory,
             g_si.lpwEventLogSourceName, UNINSTALL_SWITCH);

    //
    // Set the Uninstall string
    //
    fReturn = creg.SetString(HKEY_LOCAL_MACHINE,
                             wszUninstallKey,
                             REG_UNINSTALL_STRING,
                             wszUninstallCommand,
                             TRUE);

    if (!fReturn) {
        Print(ERROR, L"[InstallWriteUninstallKey] Failed to set UninstallString\n");
        return FALSE;
    }

    return TRUE;
}

/*++

  Routine Description:

    Run any EXEs specified in the INF file

  Arguments:

    None
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallRunINFProcesses()
{
    char        szFileName[MAX_PATH] = "";
    WCHAR       wszExpFileName[MAX_PATH] = L"";
    WCHAR       wszFileName[MAX_PATH] = L"";
    BOOL        fReturn = FALSE;
    INFCONTEXT  InfContext;

    //
    // Loop through all the lines in the ProcessesToRun section,
    // spawning off each one
    //
    fReturn = SetupFindFirstLineA(g_si.hInf, INF_PROCESSES_TO_RUN, NULL,
                                  &InfContext) &&
              SetupGetLineTextA(&InfContext,
                                NULL, NULL, NULL,
                                szFileName, MAX_PATH, NULL);
    
    while (fReturn) {

        pAnsiToUnicode(szFileName, wszFileName, MAX_PATH);

        //
        // Spawn the EXE and ignore any errors returned
        //
        ExpandEnvironmentStrings(wszFileName,
                                 wszExpFileName,
                                 MAX_PATH);
        
        LaunchProcessAndWait(wszExpFileName, NULL);
        
        fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szFileName, MAX_PATH, NULL);
    }
    
    return TRUE;
}



/*++

  Routine Description:

    Sets up the specified directory for use

  Arguments:

    lpwDirectoryPath    -   Full path to the directory
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallPrepareDirectory(
    IN LPWSTR lpwDirectoryPath,
    IN DWORD  dwAttributes
    )
{
    BOOL        fReturn = FALSE;
    LPWSTR      lpwParentPath = NULL, lpwEnd = NULL;

    //
    // See if the directory exists
    //
    if (GetFileAttributes(lpwDirectoryPath) == -1) {

        //
        // Didn't exist - attempt to create the directory
        //
        if (!CreateDirectory(lpwDirectoryPath, NULL)) {
            
            Print(ERROR, L"[InstallPrepareDirectory] Failed to create directory %s\n",
                  lpwDirectoryPath);
            return FALSE;
        }
    }

    //
    // Build a path to the parent based on it's child
    //    
    lpwParentPath = (LPWSTR) MALLOC((wcslen(lpwDirectoryPath)+1)*sizeof(WCHAR));

    if (NULL == lpwParentPath) {
        return FALSE;
    }

    wcscpy(lpwParentPath, lpwDirectoryPath);

    lpwEnd = wcsrchr(lpwParentPath, '\\');

    if (lpwEnd) {
        *lpwEnd = 0;
    }

    //
    // Adjust the permissions on the new directory
    // to match the parent
    //
    fReturn = MirrorDirectoryPerms(lpwParentPath,
                                   lpwDirectoryPath);

    if (!fReturn) {

        Print(ERROR,
              L"[InstallPrepareDirectory] Failed to mirror permissions from %s to %s\n",
              lpwParentPath, lpwDirectoryPath);
        return FALSE;
    }

    SetFileAttributes(lpwDirectoryPath, dwAttributes);

    return TRUE;
}

/*++

  Routine Description:

    Performs the backup of files that get
    replaced during install

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallBackupFiles()
{
    WCHAR       wszBackupDir[MAX_PATH] = L"";
    WCHAR       wszSourceFileName[MAX_PATH] = L"";
    WCHAR       wszBackupFileName[MAX_PATH] = L"";
    char        szEntry[MAX_PATH] = "";
    WCHAR       wszEntry[MAX_PATH] = L"";
    char        szFileName[MAX_PATH] = "";
    WCHAR       wszFileName[MAX_PATH] = L"";
    WCHAR       wszRestoreSection[MAX_PATH] = L"";
    WCHAR       wszKey[10] = L"";
    BOOL        fReturn = FALSE, fResult = FALSE;
    LPWSTR      lpwDestDir = NULL;
    UINT        uCount = 0;
    INFCONTEXT  InfContext;

    //
    // Remove any previous backup directories
    // Don't check the return as it's not critical
    // that this happen successfully
    //
    wsprintf(wszBackupDir, L"%s\\Backup", g_si.lpwInstallDirectory);

    CommonRemoveDirectoryAndFiles(wszBackupDir, (PVOID) FALSE, FALSE, FALSE);

    wszBackupDir[0] = 0;

    wsprintf(wszBackupDir,
             L"%s\\%s",
             g_si.lpwInstallDirectory,
             g_si.lpwUninstallDirectory);

    CommonRemoveDirectoryAndFiles(wszBackupDir, (PVOID) FALSE, FALSE, FALSE);

    //
    // Prepare the new backup directory
    //
    fReturn = InstallPrepareDirectory(wszBackupDir,
                                      FILE_ATTRIBUTE_HIDDEN);

    if (!fReturn) {
        return FALSE;
    }

    //
    // Step through each entry in the queue
    //
    while (g_si.BackupFileQueue.GetSize()) {

        g_si.BackupFileQueue.Dequeue(wszEntry, MAX_PATH - 1, FALSE);

        pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);

        //
        // Get the destination directory
        //
        GetNextToken(wszEntry, L".");
        GetNextToken(NULL, L".");
        lpwDestDir = GetNextToken(NULL, L".");

        if (NULL == lpwDestDir) {
            return FALSE;
        }

        //
        // Loop through all the lines in the backup files section(s),
        // and perform the backup
        //
        fReturn = SetupFindFirstLineA(g_si.hInf, szEntry, NULL,
                                      &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szFileName, MAX_PATH, NULL);


        while (fReturn) {

            pAnsiToUnicode(szFileName, wszFileName, MAX_PATH);            

            //
            // Build the path to the source file
            //
            wsprintf(wszSourceFileName,
                     L"%s\\%s\\%s", 
                     g_si.lpwWindowsDirectory,
                     lpwDestDir,
                     wszFileName);

            //
            // Ensure that the source file exists
            //
            fResult = PathFileExists(wszSourceFileName);

            if (fResult) {                
            
                //
                // Ensure that this file is not under WFP
                //
                fResult = IsFileProtected(wszSourceFileName);

                //
                // Build a path to the backup file
                //
                wsprintf(wszBackupFileName,
                         L"%s\\%s",
                         wszBackupDir,
                         wszFileName);

                //
                // Backup the file - be sensitive to WFP
                // 
                if (fResult) {
            
                    fResult = ForceCopy(wszSourceFileName, wszBackupFileName);

                    if (!fResult) {
                        Print(ERROR, L"[InstallBackupFiles] Failed to copy %s to %s\n",
                              wszSourceFileName, wszBackupFileName);
                        return FALSE;
                    }

                } else {

                    fResult = ForceMove(wszSourceFileName, wszBackupFileName);

                    if (!fResult) {
                        Print(ERROR, L"[InstallBackupFiles] Failed to move %s to %s\n",
                              wszSourceFileName, wszBackupFileName);
                        return FALSE;
                    }
                }            

                //
                // Now save an entry to the INF
                //
                wsprintf(wszRestoreSection, L"Restore.Files.%s", lpwDestDir);
                wsprintf(wszKey, L"%u", ++uCount);

                SaveEntryToINF(wszRestoreSection,
                               wszKey,
                               wszFileName,
                               g_si.lpwUninstallINFPath);
            }

            fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szFileName, MAX_PATH, NULL);
        
        }

    }

    return TRUE;
}

/*++

  Routine Description:

    Performs a backup of the specified registry
    keys during install

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallBackupRegistryKeys()
{
    BOOL        fReturn = FALSE, fResult = FALSE;
    HKEY        hKeyRoot = NULL;
    char        szEntry[MAX_PATH] = "";
    WCHAR       wszEntry[MAX_PATH] = L"";
    char        szKeyPath[MAX_PATH*3] = "";
    WCHAR       wszKeyPath[MAX_PATH*3] = L"";
    WCHAR       wszBackupFile[MAX_PATH] = L"";
    WCHAR       wszKey[10] = L"";
    WCHAR       wszEntryToSave[MAX_PATH*2] = L"";
    LPWSTR      lpwKeyPart = NULL, lpwKeyRoot = NULL;
    UINT        uCount = 0;
    CRegistry   creg;
    INFCONTEXT  InfContext;

    //
    // Step through each entry in the queue
    //
    while (g_si.BackupRegistryQueue.GetSize()) {

        g_si.BackupRegistryQueue.Dequeue(wszEntry, MAX_PATH - 1, FALSE);

        pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);

        //
        // Loop through all the lines in the backup registry section(s),
        // and perform the backup
        //
        fReturn = SetupFindFirstLineA(g_si.hInf, szEntry, NULL,
                                      &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szKeyPath, MAX_PATH, NULL);


        while (fReturn) {

            pAnsiToUnicode(szKeyPath, wszKeyPath, MAX_PATH*3);

            //
            // Split the key path into two separate parts
            //
            lpwKeyRoot = GetNextToken(wszKeyPath, L",");
            
            if (NULL == lpwKeyRoot) {
                break;
            }

            if (!_wcsicmp(lpwKeyRoot, L"HKLM")) {
                hKeyRoot = HKEY_LOCAL_MACHINE;

            } else if (!_wcsicmp(lpwKeyRoot, L"HKCR")) {
                hKeyRoot = HKEY_CLASSES_ROOT;
            
            } else if (!_wcsicmp(lpwKeyRoot, L"HKCU")) {
                hKeyRoot = HKEY_CURRENT_USER;
            
            } else if (!_wcsicmp(lpwKeyRoot, L"HKU")) {
                hKeyRoot = HKEY_USERS;
            
            } else {
                break;
            }

            lpwKeyPart = GetNextToken(NULL, L",");

            if (NULL == lpwKeyPart) {
                break;
            }

            //
            // Verify that the specified key exists
            //
            fResult = creg.IsRegistryKeyPresent(hKeyRoot, lpwKeyPart);

            if (fResult) {            

                //
                // Build a path to the file for the backup
                // and backup the key
                //
                wsprintf(wszBackupFile, 
                         L"%s\\%s\\Regbkp%u",
                         g_si.lpwInstallDirectory,
                         g_si.lpwUninstallDirectory,
                         ++uCount);

                fResult = creg.BackupRegistryKey(hKeyRoot, lpwKeyPart, wszBackupFile, TRUE);

                if (!fResult) {
                    Print(ERROR,
                          L"[InstallBackupRegistryKeys] Failed to backup key %s to %s\n",
                          lpwKeyPart, wszBackupFile);

                    return FALSE;
                }
            
                //
                // Now save an entry to the queue for the uninstall INF
                // We need one for deletion and restoration
                //
                wsprintf(wszEntryToSave, L"%s,%s", lpwKeyRoot, lpwKeyPart);
                wsprintf(wszKey, L"%u", ++uCount);

                SaveEntryToINF(INF_DELETE_REGISTRYW,
                               wszKey,
                               wszEntryToSave,
                               g_si.lpwUninstallINFPath);

                wsprintf(wszEntryToSave, L"%s,%s,%s", lpwKeyRoot, lpwKeyPart, wszBackupFile);

                SaveEntryToINF(INF_RESTORE_REGISTRYW,
                               wszKey,
                               wszEntryToSave,
                               g_si.lpwUninstallINFPath);
            }

            fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szKeyPath, MAX_PATH, NULL);
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Performs the file copy operations

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallCopyFiles()
{
    WCHAR       wszBackupDir[MAX_PATH] = L"";
    WCHAR       wszDestFileName[MAX_PATH] = L"";
    WCHAR       wszSourceFileName[MAX_PATH] = L"";
    char        szEntry[MAX_PATH] = "";
    WCHAR       wszEntry[MAX_PATH] = L"";
    char        szFileName[MAX_PATH] = "";
    WCHAR       wszFileName[MAX_PATH] = L"";
    BOOL        fReturn = FALSE, fResult = FALSE;
    LPWSTR      lpwDestDir = NULL;
    DWORDLONG   dwlSourceVersion = 0, dwlDestVersion = 0;
    INFCONTEXT  InfContext;
    
    //
    // Step through each entry in the queue
    //
    while (g_si.CopyFileQueue.GetSize()) {

        g_si.CopyFileQueue.Dequeue(wszEntry, MAX_PATH - 1, FALSE);

        pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);

        //
        // Get the destination directory
        //
        GetNextToken(wszEntry, L".");
        GetNextToken(NULL, L".");
        lpwDestDir = GetNextToken(NULL, L".");

        if (NULL == lpwDestDir) {
            break;
        }

        //
        // Loop through all the lines in the copy files section(s),
        // and perform the copy
        //
        fReturn = SetupFindFirstLineA(g_si.hInf, szEntry, NULL,
                                      &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szFileName, MAX_PATH, NULL);
        
        while (fReturn) {

            pAnsiToUnicode(szFileName, wszFileName, MAX_PATH);            

            //
            // Build the path to the destination file
            //
            wsprintf(wszDestFileName,
                     L"%s\\%s\\%s", 
                     g_si.lpwWindowsDirectory,
                     lpwDestDir,
                     wszFileName);

            //
            // Build the path to the source file
            //
            wsprintf(wszSourceFileName,
                     L"%s\\%s",
                     g_si.lpwExtractPath,
                     wszFileName);

            //
            // Get version information from the source and destination
            //
            if (!GetVersionInfoFromImage(wszSourceFileName, &dwlSourceVersion)) {
                Print(TRACE, L"[InstallCopyFiles] Failed to get version info from %s\n",
                      wszSourceFileName);
                dwlSourceVersion = 0;
            }

            if (!GetVersionInfoFromImage(wszDestFileName, &dwlDestVersion)) {
                Print(TRACE, L"[InstallCopyFiles] Failed to get version info from %s\n",
                      wszDestFileName);
                dwlDestVersion = 0;
            }

            //
            // If neither file had version information, perform the copy.
            // If the target version is less than the source version,
            // perform the copy.
            // Otherwise, move to the next file
            //
            if ((dwlSourceVersion == 0 && dwlDestVersion == 0) ||
               (dwlDestVersion <= dwlSourceVersion)) {

                //
                // Ensure that this file is not under WFP
                //
                fResult = IsFileProtected(wszDestFileName);
    
                //
                // Copy the file - be sensitive to WFP
                // 
                if (fResult) {

                    Print(TRACE,
                          L"[InstallCopyFiles] Preparing to install WFP file from %s to %s\n",
                          wszSourceFileName, wszDestFileName);

                    fResult = CommonEnableProtectedRenames();

                    if (!fResult) {
                        return FALSE;
                    }
                
                    fResult = InstallWFPFile(wszSourceFileName,
                                             wszFileName,
                                             wszDestFileName,
                                             g_si.fUpdateDllCache);

                    if (!fResult) {
                        return FALSE;
                    }
    
                } else {

                    Print(TRACE,
                          L"[InstallCopyFiles] Preparing to install file from %s to %s\n",
                          wszSourceFileName, wszDestFileName);
    
                    fResult = ForceCopy(wszSourceFileName, wszDestFileName);

                    if (!fResult) {
                        Print(ERROR,
                          L"[InstallCopyFiles] Failed to install file from %s to %s\n",
                          wszSourceFileName, wszDestFileName);
                        return FALSE;
                    }
                }
            
            } else {
                break;
            }

            fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szFileName, MAX_PATH, NULL);
        
        }

    }

    return TRUE;
}

/*++

  Routine Description:

    Installs a file that is protected
    by WFP

  Arguments:

    lpwSourceFileName       -   Path to the source file
    lpwDestFileName         -   Name of the destination file
    lpwDestFileNamePath     -   Name & path to the destination file
    fUpdateDllCache         -   A flag to indicate if the file
                                should be placed in the DllCache directory

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallWFPFile(
    IN LPCWSTR lpwSourceFileName,
    IN LPCWSTR lpwDestFileName,
    IN LPCWSTR lpwDestFileNamePath,
    IN BOOL    fUpdateDllCache
    )
{
    LPWSTR      lpwCachePath = NULL;
    LPWSTR      lpwExpandedCachePath = NULL;
    LPWSTR      lpwTempFileName = NULL;
    DWORD       cbSize = 0;
    WCHAR       wszDllCachePath[MAX_PATH] = L"";
    WCHAR       wszExtraFilePath[MAX_PATH] = L"";
    WCHAR       wszExtraFileName[MAX_PATH] = L"";
    WCHAR       wszOldSourcesPath[MAX_PATH] = L"";
    CRegistry   creg;
    BOOL        fAddedToReg = FALSE, fReturn = FALSE;

    if (fUpdateDllCache) {
        
        //
        // Try to get the dllcache directory path from
        // the registry
        //
        lpwCachePath = creg.GetString(HKEY_LOCAL_MACHINE,
                                      REG_WINFP_PATH,
                                      L"SfcDllCacheDir",
                                      TRUE);
    
        if (lpwCachePath) {
            
            if (cbSize = ExpandEnvironmentStrings(lpwCachePath, 
                                                  lpwExpandedCachePath, 
                                                  0)) {
                
                lpwExpandedCachePath = (LPWSTR) MALLOC(cbSize*sizeof(WCHAR));
    
                if (lpwExpandedCachePath) {
                    
                    if (ExpandEnvironmentStrings(lpwCachePath,
                                                 lpwExpandedCachePath,
                                                 cbSize)) {
                            
                        //
                        // Build a full path to \%windir%\system32\dllcache\filename.xxx
                        //
                        wsprintf(wszDllCachePath,
                                 L"%s\\%s", 
                                 lpwExpandedCachePath, 
                                 lpwDestFileName);
                        
                    }
                }
            }
        }
    
        //
        // If we couldn't get it from that key, try another
        //
        if (NULL == lpwExpandedCachePath) {
    
            lpwCachePath = creg.GetString(HKEY_LOCAL_MACHINE,
                                          REG_WINLOGON_PATH,
                                          L"SfcDllCacheDir",
                                          TRUE);
    
            if (lpwCachePath) {
            
                if (cbSize = ExpandEnvironmentStrings(lpwCachePath, 
                                                      lpwExpandedCachePath, 
                                                      0)) {
                    
                    lpwExpandedCachePath = (LPWSTR) MALLOC(cbSize*sizeof(WCHAR));
        
                    if (lpwExpandedCachePath) {
                        
                        if (ExpandEnvironmentStrings(lpwCachePath,
                                                     lpwExpandedCachePath,
                                                     cbSize)) {
                                
                            //
                            // Build a full path to \%windir%\system32\dllcache\filename.xxx
                            //
                            wsprintf(wszDllCachePath,
                                     L"%s\\%s", 
                                     lpwExpandedCachePath, 
                                     lpwDestFileName);
                        }
                    }
                }
            }
        }
    
        //
        // If neither key worked, build the path manually
        //
        if (NULL == lpwExpandedCachePath) {
            
            wsprintf(wszDllCachePath,
                     L"%s\\DllCache\\%s",
                     g_si.lpwSystem32Directory,
                     lpwDestFileName);
        }
    
        //
        // Replace the file in the DllCache directory
        //
        if (!CopyFile(lpwSourceFileName, wszDllCachePath, FALSE)) {
            
            Print(ERROR, 
                  L"[InstallWFPFile] Failed to copy %s to %s\n",
                  lpwSourceFileName, wszDllCachePath);
            goto cleanup;
            return FALSE;
        }
    }

    //
    // Put an additional copy in 'Sources' under the install dir
    // The return is not critical for this operation
    //
    wsprintf(wszExtraFilePath, L"%s\\$Sources$", g_si.lpwInstallDirectory);

    wsprintf(wszOldSourcesPath, L"%s\\Sources", g_si.lpwInstallDirectory);

    CommonRemoveDirectoryAndFiles(wszExtraFilePath, (PVOID) FALSE, FALSE, FALSE);

    InstallPrepareDirectory(wszExtraFilePath,
                            FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    wcscpy(wszExtraFileName, wszExtraFilePath);
    wcscat(wszExtraFileName, L"\\");
    wcscat(wszExtraFileName, lpwDestFileName);

    if (!CopyFile(lpwSourceFileName, wszExtraFileName, FALSE)) {
        
        Print(ERROR,
              L"[InstallWFPFile] Failed to copy %s to %s\n",
              lpwSourceFileName, wszExtraFileName);
    }
       
    if (!g_si.fSourceDirAdded) {

        //
        // Remove any old source path that may exist
        //
        creg.RemoveStringFromMultiSz(HKEY_LOCAL_MACHINE,
                                     REG_INSTALL_SOURCES,
                                     L"Installation Sources",
                                     wszOldSourcesPath,
                                     TRUE);

        creg.RemoveStringFromMultiSz(HKEY_LOCAL_MACHINE,
                                     REG_INSTALL_SOURCES,
                                     L"Installation Sources",
                                     wszExtraFilePath,
                                     TRUE);

        fReturn = creg.AddStringToMultiSz(HKEY_LOCAL_MACHINE,
                                          REG_INSTALL_SOURCES,
                                          L"Installation Sources",
                                          wszExtraFilePath,
                                          TRUE);

        if (!fReturn) {
            Print(ERROR,
                  L"[InstallWFPFile] Failed to add %s to registry\n",
                  wszExtraFilePath);
        }

        g_si.fSourceDirAdded = TRUE;
        
    }
    
    //
    // The catalog file won't vouch for WFP files until
    // the next reboot. Put the file down and let the
    // Session Manager rename them
    //
    lpwTempFileName = CopyTempFile(lpwSourceFileName,
                                   g_si.lpwSystem32Directory);
    
    if (NULL == lpwTempFileName) {
        
        Print(ERROR, L"[InstallWFPFile] Failed to get temp file\n");
        goto cleanup;
        return FALSE;
    }
    
    if (!MoveFileEx(lpwTempFileName,
                    lpwDestFileNamePath, 
                    MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT)) {
    
        Print(ERROR, L"[InstallWFPFile] Failed to delay replace from %s to %s\n",
              lpwTempFileName, lpwDestFileNamePath);
        goto cleanup;
        return FALSE;
    }

cleanup:

    if (lpwTempFileName) {
        FREE(lpwTempFileName);
    }

    if (lpwExpandedCachePath) {
        FREE(lpwExpandedCachePath);
    }

    return TRUE;
}

/*++

  Routine Description:

    Retrieves the section names from the installation
    INF file. This dictates what operations will be
    performed during install

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallGetSectionsFromINF()
{
    BOOL        fReturn = FALSE;
    DWORD       dwType = 0;
    char        szSectionName[MAX_QUEUE_SIZE] = "";
    char        *pSectionName;
    WCHAR       wszDirective[MAX_PATH] = L"";
    INFCONTEXT  InfContext;

    //
    // Loop through all the lines in the Sections section(s),    
    //
    fReturn = SetupFindFirstLineA(g_si.hInf, INF_MASTER_SECTIONS, NULL,
                                  &InfContext) &&
              SetupGetLineTextA(&InfContext,
                                NULL, NULL, NULL,
                                szSectionName, MAX_QUEUE_SIZE, NULL);

    while (fReturn) {

        //
        // Determine which section we're working with
        //
        if (strstr(szSectionName, INF_BACKUP_FILES)) {
            dwType = dwBackupFiles;
        
        } else if (strstr(szSectionName, INF_BACKUP_REGISTRY)) {
            dwType = dwBackupRegistry;
                   
        } else if (strstr(szSectionName, INF_DELETE_REGISTRY)) {
            dwType = dwDeleteRegistry;
    
        } else if (strstr(szSectionName, INF_COPY_FILES)) {
            dwType = dwCopyFiles;
    
        } else if (strstr(szSectionName, INF_REGISTRATIONS)) {
            dwType = dwRegistrations;
    
        } else if (strstr(szSectionName, INF_EXCLUDE)) {
            dwType = dwExclusionsInstall;
        
        } else if (strstr(szSectionName, INF_ADD_REGISTRY)) {
            dwType = dwAddRegistry;
    
        } else {
            Print(ERROR,
                  L"[InstallGetSectionsFromINF] Illegal section name passed %s\n",
                  szSectionName);
            return FALSE; // illegal section name
        }

        pSectionName = strtok(szSectionName, ",");

        do {
            
            pAnsiToUnicode(pSectionName, wszDirective, MAX_PATH);

            //
            // Loop through each section name and add it to the
            // appropriate queue
            //
            switch (dwType) {
                case dwBackupFiles:
                    g_si.BackupFileQueue.Enqueue(wszDirective);
                    break;

                case dwBackupRegistry:
                    g_si.BackupRegistryQueue.Enqueue(wszDirective);
                    break;

                case dwDeleteRegistry:
                    g_si.DeleteRegistryQueue.Enqueue(wszDirective);
                    break;

                case dwCopyFiles:
                    g_si.CopyFileQueue.Enqueue(wszDirective);
                    break;

                case dwRegistrations:
                    g_si.RegistrationQueue.Enqueue(wszDirective);
                    break;

                case dwExclusionsInstall:
                    g_si.ExclusionQueue.Enqueue(wszDirective);
                    break;

                case dwAddRegistry:
                    g_si.AddRegistryQueue.Enqueue(wszDirective);
                    break;

                default:
                    return FALSE;   // illegal section name
            }

            pSectionName = strtok(NULL, ",");

        } while (NULL != pSectionName);

        fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szSectionName, MAX_QUEUE_SIZE, NULL);
    }
    
    return TRUE;
}

/*++

  Routine Description:

    Merges the registry data from the INF
    into the registry

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
InstallRegistryData()
{
    BOOL        fReturn = FALSE;
    char        szEntry[MAX_PATH] = "";
    WCHAR       wszEntry[MAX_PATH] = L"";

    //
    // Step through each entry in the queue
    //
    while (g_si.AddRegistryQueue.GetSize()) {

        g_si.AddRegistryQueue.Dequeue(wszEntry, MAX_PATH - 1, FALSE);

        pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);
        
        //
        // Merge all the registry data from the INF
        //
        fReturn = SetupInstallFromInfSectionA(NULL,
                                              g_si.hInf,
                                              szEntry,
                                              SPINST_REGISTRY,
                                              NULL,
                                              NULL,
                                              0,
                                              NULL,
                                              NULL,
                                              NULL,
                                              NULL);

        if (!fReturn) {
            Print(ERROR, L"[InstallRegistryData] Failed to merge registry data\n");
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\wuuninst.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Duuninst.cpp

  Abstract:

    Contains the main uninstallation code
    used by the app.

  Notes:

    Unicode only.

  History:

    03/02/2001      rparsons    Created
    
--*/

#include "precomp.h"

extern SETUP_INFO g_si;

/*++

  Routine Description:

    Removes the specified registry key
    Assumes HKEY_LOCAL_MACHINE

  Arguments:
  
    lpwKey      -   Path of the key to open
    lpwSubKey   -   Path of the subkey to delete
    
  Return Value:

    None

--*/
void
UninstallDeleteSubKey(
    IN LPCWSTR lpwKey,
    IN LPCWSTR lpwSubKey
    )
{
    CRegistry   creg;

    //
    // Remove the key from the registry
    //
    creg.DeleteRegistryKey(HKEY_LOCAL_MACHINE,
                           lpwKey,
                           lpwSubKey,
                           TRUE,
                           TRUE);
    
    return;
}

/*++

  Routine Description:

    Retrieves the section names from the uninstall
    INF file. This dictates what operations will be
    performed during uninstall

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
UninstallGetSectionsFromINF()
{
    BOOL        fReturn = FALSE;
    DWORD       dwType = 0;
    char        szSectionName[MAX_QUEUE_SIZE] = "";
    char        *pSectionName;
    WCHAR       wszDirective[MAX_PATH] = L"";
    INFCONTEXT  InfContext;

    //
    // Loop through all the lines in the Sections section(s),    
    //
    fReturn = SetupFindFirstLineA(g_si.hInf, INF_MASTER_SECTIONS, NULL,
                                  &InfContext) &&
              SetupGetLineTextA(&InfContext,
                                NULL, NULL, NULL,
                                szSectionName, MAX_QUEUE_SIZE, NULL);

    while (fReturn) {

        //
        // Determine which section we're working with
        //
        if (strstr(szSectionName, INF_RESTORE_FILES)) {
            dwType = dwRestoreFiles;
                   
        } else if (strstr(szSectionName, INF_DELETE_REGISTRY)) {
            dwType = dwDeleteRegistry;
    
        } else if (strstr(szSectionName, INF_RESTORE_REGISTRY)) {
            dwType = dwRestoreRegistry;
    
        } else if (strstr(szSectionName, INF_UNREGISTRATIONS)) {
            dwType = dwUnRegistrations;
    
        } else if (strstr(szSectionName, INF_EXCLUDE)) {
            dwType = dwExclusionsUninstall;
    
        } else {
            Print(ERROR,
                  L"[UninstallGetSectionsFromINF] Illegal section name passed %s\n",
                  szSectionName);
            return FALSE; // illegal section name
        }

        pSectionName = strtok(szSectionName, ",");

        do {
            
            pAnsiToUnicode(pSectionName, wszDirective, MAX_PATH);

            //
            // Loop through each section name and add it to the
            // appropriate queue
            //
            switch (dwType) {
                case dwRestoreFiles:
                    g_si.RestoreFileQueue.Enqueue(wszDirective);
                    break;

                case dwDeleteRegistry:
                    g_si.DeleteRegistryQueue.Enqueue(wszDirective);
                    break;

                case dwRestoreRegistry:
                    g_si.RestoreRegistryQueue.Enqueue(wszDirective);
                    break;

                case dwUnRegistrations:
                    g_si.RegistrationQueue.Enqueue(wszDirective);
                    break;

                case dwExclusionsUninstall:
                    g_si.ExclusionQueue.Enqueue(wszDirective);
                    break;

                default:
                    return FALSE;   // illegal section name
            }

            pSectionName = strtok(NULL, ",");

        } while (NULL != pSectionName);

        fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szSectionName, MAX_QUEUE_SIZE, NULL);
    }
    
    return TRUE;
}

/*++

  Routine Description:

    Restores registry keys that were saved
    during the install

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
UninstallRestoreRegistryKeys()
{
    BOOL        fReturn = FALSE, fResult = FALSE;
    HKEY        hKeyRoot = NULL;
    char        szEntry[MAX_QUEUE_SIZE] = "";
    WCHAR       wszEntry[MAX_QUEUE_SIZE] = L"";
    char        szKeyPath[MAX_PATH*3] = "";
    WCHAR       wszKeyPath[MAX_PATH*3] = L"";
    LPWSTR      lpwSubKey = NULL, lpwFilePath = NULL, lpwKeyRoot = NULL;
    UINT        uCount = 0;
    CRegistry   creg;
    INFCONTEXT  InfContext;

    //
    // The entry in the uninstall INF will have the following format:
    // HKxx,SubKeyPath,PathToBackupFile
    //

    //
    // Step through each entry in the queue
    //
    while (g_si.RestoreRegistryQueue.GetSize()) {

        g_si.RestoreRegistryQueue.Dequeue(wszEntry, MAX_PATH - 1, FALSE);

        pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);

        //
        // Loop through all the lines in the restore registry section(s),
        // and perform the restore
        //
        fReturn = SetupFindFirstLineA(g_si.hInf, szEntry, NULL,
                                      &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szKeyPath, MAX_PATH*3, NULL);


        while (fReturn) {

            pAnsiToUnicode(szKeyPath, wszKeyPath, MAX_PATH*3);

            //
            // Split the key path into three separate parts
            //
            lpwKeyRoot = GetNextToken(wszKeyPath, L",");
            
            if (NULL == lpwKeyRoot) {
                break;
            }

            Print(TRACE, L"[UninstallRestoreRegistryKeys] Key root: %s\n", lpwKeyRoot);

            if (!_wcsicmp(lpwKeyRoot, L"HKLM")) {
                hKeyRoot = HKEY_LOCAL_MACHINE;

            } else if (!_wcsicmp(lpwKeyRoot, L"HKCR")) {
                hKeyRoot = HKEY_CLASSES_ROOT;
            
            } else if (!_wcsicmp(lpwKeyRoot, L"HKCU")) {
                hKeyRoot = HKEY_CURRENT_USER;
            
            } else if (!_wcsicmp(lpwKeyRoot, L"HKU")) {
                hKeyRoot = HKEY_USERS;
            
            } else {
                break;
            }

            //
            // Get the subkey path
            //
            lpwSubKey = GetNextToken(NULL, L",");

            if (NULL == lpwSubKey) {
                break;
            }

            Print(TRACE, L"[UninstallRestoreRegistryKeys] Subkey path: %s\n", lpwSubKey);

            //
            // Get the file name with full path
            //
            lpwFilePath = GetNextToken(NULL, L",");

            if (NULL == lpwFilePath) {
                break;
            }
            
            Print(TRACE, L"[UninstallRestoreRegistryKeys] File path: %s\n", lpwFilePath);

            //
            // Restore the key
            //
            fResult = creg.RestoreKey(hKeyRoot, lpwSubKey, lpwFilePath, TRUE);

            if (!fResult) {
                Print(ERROR,
                      L"[UninstallRestoreRegistryKeys] Failed to restore key\n");
                return FALSE;
            }

            fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szKeyPath, MAX_PATH*3, NULL);
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Removes files from the installation directory

  Arguments:
  
    None
    
  Return Value:

    None

--*/
BOOL
UninstallRemoveFiles()
{
    CEnumDir    ced;

    //
    // Remove files from the installation directory,
    // but leave subdirectories alone
    //
    ced.EnumerateDirectoryTree(g_si.lpwInstallDirectory,
                               DeleteOneFile,
                               FALSE,
                               (PVOID) TRUE);

    return TRUE;
}

/*++

  Routine Description:

    Restores files that were backed up during the install

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
UninstallRestoreFiles()
{
    WCHAR       wszBackupDir[MAX_PATH] = L"";
    WCHAR       wszDestFileName[MAX_PATH] = L"";
    WCHAR       wszSourceFileName[MAX_PATH] = L"";
    char        szEntry[MAX_PATH] = "";
    WCHAR       wszEntry[MAX_PATH] = L"";
    char        szFileName[MAX_PATH] = "";
    WCHAR       wszFileName[MAX_PATH] = L"";
    BOOL        fReturn = FALSE, fResult = FALSE;
    LPWSTR      lpwDestDir = NULL;
    DWORDLONG   dwlSourceVersion = 0, dwlDestVersion = 0;
    INFCONTEXT  InfContext;
    
    //
    // Step through each entry in the queue
    //
    while (g_si.RestoreFileQueue.GetSize()) {

        g_si.RestoreFileQueue.Dequeue(wszEntry, MAX_PATH - 1, FALSE);

        pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);

        //
        // Get the destination directory
        //
        GetNextToken(wszEntry, L".");
        GetNextToken(NULL, L".");
        lpwDestDir = GetNextToken(NULL, L".");

        if (NULL == lpwDestDir) {
            break;
        }

        //
        // Loop through all the lines in the restore files section(s),
        // and perform the copy
        //
        fReturn = SetupFindFirstLineA(g_si.hInf, szEntry, NULL,
                                      &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szFileName, MAX_PATH, NULL);
        
        while (fReturn) {

            pAnsiToUnicode(szFileName, wszFileName, MAX_PATH);            

            //
            // Build the path to the destination file
            //
            wsprintf(wszDestFileName,
                     L"%s\\%s\\%s", 
                     g_si.lpwWindowsDirectory,
                     lpwDestDir,
                     wszFileName);

            //
            // Build the path to the source file
            //
            wsprintf(wszSourceFileName,
                     L"%s\\%s\\%s",
                     g_si.lpwExtractPath,
                     g_si.lpwUninstallDirectory,
                     wszFileName);
            
            //
            // Ensure that this file is not under WFP
            //
            fResult = IsFileProtected(wszDestFileName);
    
            //
            // Copy the file - be sensitive to WFP
            // 
            if (fResult) {
                
                Print(TRACE,
                      L"[UninstallRestoreFiles] Preparing to restore WFP file from %s to %s\n",
                      wszSourceFileName, wszDestFileName);

                fResult = CommonEnableProtectedRenames();

                if (!fResult) {
                    Print(ERROR,
                          L"[UninstallRestoreFiles] Failed to enable protected renames\n");
                    return FALSE;
                }

                Print(TRACE,
                      L"[UninstallRestoreFiles] Preparing to install WFP file from %s to %s\n",
                      wszSourceFileName, wszDestFileName);
            
                fResult = UninstallWFPFile(wszSourceFileName,
                                           wszFileName,
                                           wszDestFileName,
                                           g_si.fUpdateDllCache);

                if (!fResult) {
                        Print(ERROR,
                              L"[UninstallRestoreFiles] Failed to install WFP file %s\n",
                              wszFileName);
                    return FALSE;
                }
                
            } else {

                Print(TRACE,
                      L"[UninstallRestoreFiles] Preparing to restore file from %s to %s\n",
                      wszSourceFileName, wszDestFileName);

                fResult = ForceMove(wszSourceFileName, wszDestFileName);

                if (!fResult) {
                    Print(ERROR,
                          L"[UninstallRestoreFiles] Failed to restore file from %s to %s. GLE = %d\n",
                          wszSourceFileName, wszDestFileName, GetLastError());
                    return FALSE;
                }
                
            }        

        fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szFileName, MAX_PATH, NULL);
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Restores a file that is protected
    by WFP

  Arguments:

    lpwSourceFileName       -   Path to the source file
    lpwDestFileName         -   Name of the destination file
    lpwDestFileNamePath         Name & path to the destination file
    fUpdateDllCache         -   A flag to indicate if the file
                                should be placed in the DllCache directory

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
UninstallWFPFile(
    IN LPCWSTR lpwSourceFileName,
    IN LPCWSTR lpwDestFileName,
    IN LPCWSTR lpwDestFileNamePath,
    IN BOOL    fUpdateDllCache
    )
{
    LPWSTR      lpwCachePath = NULL;
    LPWSTR      lpwExpandedCachePath = NULL;
    LPWSTR      lpwTempFileName = NULL;
    DWORD       cbSize = 0;
    WCHAR       wszDllCachePath[MAX_PATH] = L"";
    CRegistry   creg;

    if (g_si.fUpdateDllCache) {

        Print(TRACE,
              L"[UninstallWFPFile] Restoring %s to DllCache dir\n",
              lpwSourceFileName);
        
        //
        // Try to get the dllcache directory path from
        // the registry
        //
        lpwCachePath = creg.GetString(HKEY_LOCAL_MACHINE,
                                      REG_WINFP_PATH,
                                      L"SfcDllCacheDir",
                                      TRUE);
    
        if (lpwCachePath) {
            
            if (cbSize = ExpandEnvironmentStrings(lpwCachePath, 
                                                  lpwExpandedCachePath, 
                                                  0)) {
                
                lpwExpandedCachePath = (LPWSTR) MALLOC(cbSize*sizeof(WCHAR));
    
                if (lpwExpandedCachePath) {
                    
                    if (ExpandEnvironmentStrings(lpwCachePath,
                                                 lpwExpandedCachePath,
                                                 cbSize)) {
                            
                        //
                        // Build a full path to \%windir%\system32\dllcache\filename.xxx
                        //
                        wsprintf(wszDllCachePath,
                                 L"%s\\%s", 
                                 lpwExpandedCachePath, 
                                 lpwDestFileName);
                        
                    }
                }
            }
        }
    
        //
        // If we couldn't get it from that key, try another
        //
        if (NULL == lpwExpandedCachePath) {
    
            lpwCachePath = creg.GetString(HKEY_LOCAL_MACHINE,
                                          REG_WINLOGON_PATH,
                                          L"SfcDllCacheDir",
                                          TRUE);
    
            if (lpwCachePath) {
            
                if (cbSize = ExpandEnvironmentStrings(lpwCachePath, 
                                                      lpwExpandedCachePath, 
                                                      0)) {
                    
                    lpwExpandedCachePath = (LPWSTR) MALLOC(cbSize*sizeof(WCHAR));
        
                    if (lpwExpandedCachePath) {
                        
                        if (ExpandEnvironmentStrings(lpwCachePath,
                                                     lpwExpandedCachePath,
                                                     cbSize)) {
                                
                            //
                            // Build a full path to \%windir%\system32\dllcache\filename.xxx
                            //
                            wsprintf(wszDllCachePath,
                                     L"%s\\%s", 
                                     lpwExpandedCachePath, 
                                     lpwDestFileName);
                            
                        }
                    }
                }
            }
        }
    
        //
        // If neither key worked, build the path manually
        //
        if (NULL == lpwExpandedCachePath) {
            
            wsprintf(wszDllCachePath,
                     L"%s\\DllCache\\%s",
                     g_si.lpwSystem32Directory,
                     lpwDestFileName);
        }
    
        //
        // Replace the file in the DllCache directory
        //
        if (!CopyFile(lpwSourceFileName, wszDllCachePath, FALSE)) {
            
            Print(ERROR, 
                  L"[UninstallWFPFile] Failed to copy %s to %s\n",
                  lpwSourceFileName, wszDllCachePath);
            goto cleanup;
            return FALSE;
        }
    }

    //
    // This is semi-custom, but because some of the 
    // WFPs will be in use, we'll delay replace them
    // and let the Session Manager rename them
    //
    lpwTempFileName = CopyTempFile(lpwSourceFileName,
                                   g_si.lpwSystem32Directory);
    
    if (NULL == lpwTempFileName) {
        
        Print(ERROR, L"[UninstallWFPFile] Failed to get temp file\n");
        goto cleanup;
        return FALSE;
    }
    
    if (!MoveFileEx(lpwTempFileName,
                    lpwDestFileNamePath, 
                    MOVEFILE_REPLACE_EXISTING | MOVEFILE_DELAY_UNTIL_REBOOT)) {
    
        Print(ERROR, L"[UninstallWFPFile] Failed to delay replace from %s to %s\n",
              lpwTempFileName, lpwDestFileNamePath);
        goto cleanup;
        return FALSE;
    }

    cleanup:

        if (lpwTempFileName) {
            FREE(lpwTempFileName);
        }

        if (lpwExpandedCachePath) {
            FREE(lpwExpandedCachePath);
        }

    return TRUE;
}

/*++

  Routine Description:

    Custom worker routine for uninstall

  Arguments:

    None

  Return Value:

    None

--*/
void
UninstallCustomWorker()
{
    //
    // This is where determine if we should remove
    // any regsvr32s that we did during install.
    // We also remove the $Sources$ directory,
    // if necessary.
    // Our method of detection is to see if our
    // Guid is present under the Active Setup
    // key. If not, it's safe to assume that
    // no package is currently installed
    //

    BOOL        fReturn = FALSE;
    CRegistry   creg;
    char        szActiveSetupKey[MAX_PATH] = "";
    WCHAR       wszActiveSetupKey[MAX_PATH] = L"";
    WCHAR       wszSourcesDir[MAX_PATH] = L"";       

    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "ActiveSetupKey",
                                szActiveSetupKey,
                                sizeof(szActiveSetupKey),
                                NULL);

    if (!fReturn) {
        return;
    }

    pAnsiToUnicode(szActiveSetupKey, wszActiveSetupKey, MAX_PATH);

    fReturn = creg.IsRegistryKeyPresent(HKEY_LOCAL_MACHINE,
                                        wszActiveSetupKey);

    if (!fReturn) {
        wsprintf(wszSourcesDir, L"%s\\$Sources$", g_si.lpwInstallDirectory);
        CommonRemoveDirectoryAndFiles(wszSourcesDir, (PVOID) FALSE, TRUE, FALSE);
        CommonRegisterServers(FALSE);
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\wulog.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Dulog.cpp

  Abstract:

    Implements the event logging functions.
    Note that the C++ class provides the
    functionality for event logging.

  Notes:

    Unicode only.

  History:

    03/02/2001      rparsons    Created
    
--*/

#include "precomp.h"

extern SETUP_INFO g_si;

/*++

  Routine Description:

    Logs an event to the event log and optionally displays the message.
    Note that we use this function when writing to the event log
    for non-error related stuff 
    
  Arguments:
  
    wType           -       The type of message we're logging
    dwEventID       -       An event ID for our message    
    fDisplayErr     -       A flag to indicate if we
                            should display an error
    fCritical       -       Indicates if we should display a message
                            from the string table
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
LogEventDisplayError(
    IN WORD  wType,
    IN DWORD dwEventID,
    IN BOOL  fDisplayErr,
    IN BOOL  fCritical
    )
{
    WORD        wNumStrings = 0;
    LPWSTR      lpwMessageArray[2];
    LPWSTR      lpwSourceFile = NULL;
    int         nLen = 0;
    CEventLog   cel;

    //
    // If the Critical flag is set, an error occured while
    // trying to get strings from somewhere. Report the event
    // without registering a source
    //
    if (fCritical) {

        WCHAR           wszMessageBoxTitle[MAX_PATH] = L"";
        WCHAR           wszPrettyAppName[MAX_PATH] = L"";
        WCHAR           wszEventLogSourceName[MAX_PATH] = L"";
        WCHAR           wszTemp[MAX_PATH] = L"";
        WCHAR           wszCriticalError[MAX_PATH] = L"";
        HANDLE          hEventLog;
        const WCHAR     *pwMessage[1];

        LoadString(g_si.hInstance,
                   IDS_MB_TITLE,
                   wszMessageBoxTitle,
                   MAX_PATH);

        LoadString(g_si.hInstance,
                   g_si.fOnWin2K ? IDS_APP_NAME_WIN2K :
                   IDS_APP_NAME_XP,
                   wszPrettyAppName,
                   MAX_PATH);

        LoadString(g_si.hInstance,
                   IDS_EL_SOURCE_NAME,
                   wszEventLogSourceName,
                   MAX_PATH);

        LoadString(g_si.hInstance,
                   IDS_CRITICAL_ERROR,
                   wszTemp,
                   MAX_PATH);

        wsprintf(wszCriticalError, wszTemp, wszPrettyAppName);

        pwMessage[0] = wszCriticalError;

        hEventLog = RegisterEventSource(NULL, wszEventLogSourceName);

        if (hEventLog) {

            ReportEvent(hEventLog,
                        EVENTLOG_ERROR_TYPE,
                        0,
                        1001,
                        NULL,
                        1,
                        0,
                        pwMessage,
                        NULL);
        }

        if (!g_si.fQuiet) {
            MessageBox(GetDesktopWindow(),
                       wszCriticalError,
                       wszMessageBoxTitle,
                       MB_ICONERROR | MB_OK);
        }

        DeregisterEventSource(hEventLog);

        return TRUE;
    }

    //
    // Determine if we've already created our event source
    //
    if (!g_si.fEventSourceCreated) {

        //
        // Build a path to our source file and register
        // the event source
        //
        nLen += wcslen(g_si.lpwEventLogSourceName);
        nLen += wcslen(g_si.lpwInstallDirectory);

        lpwSourceFile = (LPWSTR) MALLOC((nLen*sizeof(WCHAR))*2);

        if (NULL == lpwSourceFile) {
            return FALSE;
        }

        wcscpy(lpwSourceFile, g_si.lpwInstallDirectory);
        wcscat(lpwSourceFile, L"\\");
        wcscat(lpwSourceFile, g_si.lpwEventLogSourceName);
        wcscat(lpwSourceFile, L".exe");

        cel.CreateEventSource(lpwSourceFile,
                              g_si.lpwEventLogSourceName,
                              dwApplication);

        g_si.fEventSourceCreated = TRUE;

        FREE(lpwSourceFile);
    }
    
    lpwMessageArray[wNumStrings++] = (LPWSTR) g_si.lpwPrettyAppName;

    //
    // Place the event in the event log
    //
    cel.LogEvent(g_si.lpwEventLogSourceName,
                 NULL,
                 wType,
                 dwEventID,
                 1,
                 (LPCWSTR*) lpwMessageArray);

    if (fDisplayErr) {

        if (!g_si.fQuiet) {

            DisplayErrMsg(NULL, dwEventID, (LPWSTR) lpwMessageArray);
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Logs an event to the event log

  Arguments:

    wType           -       Type of message
    dwEventID       -       Event ID
    wNumStrings     -       Number of insertion strings
    lpwStrings      -       Array of strings

  Return Value:

    None

--*/
void
LogWUEvent(
    IN WORD    wType,
    IN DWORD   dwEventID,
    IN WORD    wNumStrings,
    IN LPCWSTR *lpwStrings
    )
{
    HANDLE      hES = NULL;
    LPVOID      lpMsgBuf = NULL;
    LPWSTR      lpwSourceFile = NULL;
    int         nLen = 0;
    CEventLog   cel;

    //
    // Determine if we've already created our event source
    // in the registry
    //
    if (!g_si.fEventSourceCreated) {
        
        //
        // Build a path to our source file and register
        // the event source
        //
        nLen += wcslen(g_si.lpwEventLogSourceName);
        nLen += wcslen(g_si.lpwInstallDirectory);

        lpwSourceFile = (LPWSTR) MALLOC((nLen*sizeof(WCHAR))*2);

        if (NULL == lpwSourceFile) {
            return;
        }        

        wcscpy(lpwSourceFile, g_si.lpwInstallDirectory);
        wcscat(lpwSourceFile, L"\\");
        wcscat(lpwSourceFile, g_si.lpwEventLogSourceName);
        wcscat(lpwSourceFile, L".exe");

        cel.CreateEventSource(lpwSourceFile,
                              g_si.lpwEventLogSourceName,
                              dwApplication);

        g_si.fEventSourceCreated = TRUE;

        FREE(lpwSourceFile);
    }

    if (wNumStrings) {

        //
        // Report the event with insertion strings
        //
        cel.LogEvent(g_si.lpwEventLogSourceName,
                     NULL,
                     wType,
                     dwEventID,
                     0,
                     NULL);
    
    } else {

        //
        // Report the event with no strings
        //
        cel.LogEvent(g_si.lpwEventLogSourceName,
                     NULL,
                     wType,
                     dwEventID,
                     wNumStrings,
                     (LPCWSTR*) lpwStrings);
    }
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\wumain.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Duinst.cpp

  Abstract:

    Contains the entry point for the Dynamic
    Update package and the install and
    uninstall main functions.

  Notes:

    Unicode only.

  History:

    03/02/2001      rparsons    Created
    
--*/

#include "precomp.h"
#include "systemrestore.h"

SETUP_INFO g_si;

/*++

  Routine Description:

    Application entry point

  Arguments:

    hInstance       -   App instance handle
    hPrevInstance   -   Always NULL
    lpCmdLine       -   Pointer to the command line
    nCmdShow        -   Window show flag

  Return Value:

    -1 on failure, 0 on success

--*/
int APIENTRY
WinMain(
    IN HINSTANCE hInstance,
    IN HINSTANCE hPrevInstance,
    IN LPSTR     lpCmdLine,
    IN int       nCmdShow
    )
{
    int     nReturn = -1;
    BOOL    fReturn = FALSE;

    Print(TRACE, L"[WinMain] Application is started\n");

    //
    // Ensure that two separate instances of the app
    // are not running
    //
    if (IsAnotherInstanceRunning(L"WUINST")) {
        return -1;
    }

    //
    // Parse the command line and save app-related
    // data away
    //
    if (!ParseCommandLine()) {
        Print(ERROR, L"[WinMain] Call to ParseCommandLine failed\n");
        LogEventDisplayError(NULL, EVENTLOG_ERROR_TYPE, ID_PARSE_CMD_LINE, TRUE);
        goto eh;
    }

    g_si.hInstance = hInstance;

    //
    // Determine the action to take
    //
    if (g_si.fInstall) {

        //
        // Start system restore point
        //
        if (!SystemRestorePointStart(TRUE)) {
            Print(ERROR, L"[WinMain] Call to SystemRestorePointStart failed\n");
            LogEventDisplayError(NULL, EVENTLOG_ERROR_TYPE, ID_INIT_FAILED, TRUE);
            goto eh;
        }

        if (!WUInitialize()) {

            Print(ERROR, L"[WinMain] Call to WUInitialize failed\n");
            LogEventDisplayError(NULL, EVENTLOG_ERROR_TYPE, ID_INIT_FAILED, TRUE);
            goto eh;
        }

        fReturn = DoInstallation();
    
    } else if (!g_si.fInstall) {

        //
        // Start system restore point
        //
        if (!SystemRestorePointStart(FALSE)) {
            Print(ERROR, L"[WinMain] Call to SystemRestorePointStart failed\n");
            LogEventDisplayError(NULL, EVENTLOG_ERROR_TYPE, ID_SYSTEM_RESTORE_FAIL, TRUE);
            goto eh;
        }

        if (!WUInitialize()) {
            
            Print(ERROR, L"[WinMain] Call to WUInitialize failed\n");
            LogEventDisplayError(NULL, EVENTLOG_ERROR_TYPE, ID_INIT_FAILED, TRUE);
            goto eh;
        }
    
        fReturn = DoUninstallation();
    
    } else {
        goto eh;
    }

    nReturn = 0;

eh:
    //
    // Perform cleanup
    //
    WUCleanup();
    
    if (nReturn == 0) {
        if (!SystemRestorePointEnd()) {
            Print(ERROR, L"[WinMain] Call to SystemRestorePointEnd failed\n");
            LogEventDisplayError(NULL, EVENTLOG_ERROR_TYPE, ID_SYSTEM_RESTORE_FAIL, TRUE);
        }
    } else {
        if (!SystemRestorePointCancel()) {
            Print(ERROR, L"[WinMain] Call to SystemRestorePointCancel failed\n");
            LogEventDisplayError(NULL, EVENTLOG_ERROR_TYPE, ID_SYSTEM_RESTORE_FAIL, TRUE);
        }
    }

    return nReturn;
}

/*++

  Routine Description:

    Performs the grunt work of the installation

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
DoInstallation()
{
    int     nReturn = 0;
    WCHAR   wszError[1024] = L"";
    WCHAR   wszTemp[MAX_PATH] = L"";
    WCHAR   wszBegin[MAX_PATH] = L"";
    WCHAR   wszDestFileName[MAX_PATH] = L"";
    WORD    wNumStrings = 0;
    LPWSTR  lpwMessageArray[2];

    Print(TRACE, L"[DoInstallation] Installation is starting\n");

    //
    // Display the prompt for installation if we're
    // not in quiet mode
    //
    if (!g_si.fQuiet) {

        LoadString(g_si.hInstance, IDS_INSTALL_PROMPT, wszTemp, MAX_PATH);

        wsprintf(wszBegin, wszTemp, g_si.lpwPrettyAppName);

        if (MessageBox(NULL, 
                       wszBegin,
                       g_si.lpwMessageBoxTitle,
                       MB_YESNO | MB_ICONQUESTION)!=IDYES)
        {
            return TRUE;
        }
    }

    //
    // Log an event that the install is starting
    //
    LogEventDisplayError(EVENTLOG_INFORMATION_TYPE,
                         ID_INSTALL_START,
                         FALSE,
                         FALSE);

    //
    // If we're not forcing an installation, check the
    // version number
    //
    if (!g_si.fForceInstall) {
        
        nReturn = InstallCheckVersion();
    }

    if (0 == nReturn) {

        //
        // This indicates that a newer package is installed
        // on the user's PC. Warn them if we're not in quiet
        // mode
        //
        Print(TRACE,
              L"[DoInstallation] Newer package is installed\n");

        if (!g_si.fQuiet) {

            LoadString(g_si.hInstance, IDS_NEWER_VERSION, wszTemp, MAX_PATH);

            wsprintf(wszError,
                     wszTemp,
                     g_si.lpwPrettyAppName,
                     g_si.lpwPrettyAppName);                    

            if (MessageBox(NULL,
                           wszError,
                           g_si.lpwMessageBoxTitle,
                           MB_YESNO | MB_ICONEXCLAMATION | MB_DEFBUTTON2)!=IDYES)
                {
                    return TRUE;
                }
        
        } else {

            //
            // If we're in quiet mode, log an event to the event log
            //
            LogEventDisplayError(EVENTLOG_INFORMATION_TYPE,
                                 ID_NO_ACTION_TAKEN,
                                 FALSE,
                                 FALSE);
            return TRUE;
        }
    }

    //
    // Attempt to verify if our target directory exists
    // If not, try to create it
    //
    if (GetFileAttributes(g_si.lpwInstallDirectory)== -1) {

        if (!CreateDirectory(g_si.lpwInstallDirectory, NULL)) {
            
            wNumStrings = 0;
            lpwMessageArray[wNumStrings++] = (LPWSTR) g_si.lpwPrettyAppName;
            lpwMessageArray[wNumStrings++] = (LPWSTR) g_si.lpwInstallDirectory;
    
            LogWUEvent(EVENTLOG_ERROR_TYPE,
                       ID_NO_APPPATCH_DIR,
                       2,
                       (LPCWSTR*) lpwMessageArray);
            
    
            if (!g_si.fQuiet) {

                DisplayErrMsg(GetDesktopWindow(),
                              ID_NO_APPPATCH_DIR,
                              (LPWSTR) lpwMessageArray);
            }

            Print(ERROR, L"[DoInstallation] Failed to create installation directory\n");

            return FALSE;
        }
    }
    
    //
    // If we need to adjust permissions on our target directory, do it
    //
    if (g_si.fNeedToAdjustACL) {
    
        if (!AdjustDirectoryPerms(g_si.lpwInstallDirectory)) {
            
            wNumStrings = 0;
            lpwMessageArray[wNumStrings++] = (LPWSTR) g_si.lpwPrettyAppName;
            lpwMessageArray[wNumStrings++] = (LPWSTR) g_si.lpwInstallDirectory;

            LogWUEvent(EVENTLOG_ERROR_TYPE,
                       ID_ACL_APPPATCH_FAILED,
                       2,
                       (LPCWSTR*) lpwMessageArray);
        

            if (!g_si.fQuiet) {
                
                DisplayErrMsg(GetDesktopWindow(),
                              ID_ACL_APPPATCH_FAILED,
                              (LPWSTR) lpwMessageArray);
            }

            Print(ERROR,
                  L"[DoInstallation] Failed to apply ACL to installation directory\n");

            return FALSE;
        
        }
    }

    //
    // Get section names from the INF
    //
    if (!InstallGetSectionsFromINF()) {

        Print(ERROR, L"[DoInstallation] Failed to get section names from INF\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_INF_SCAN_FAILED, TRUE, FALSE);
        return FALSE;
    }

    //
    // Install catalog files
    //
    if (!InstallCatalogFiles(g_si.hInf, g_si.lpwExtractPath)) {

        Print(ERROR, L"[DoInstallation] Failed to install catalog file\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_CATALOG_INSTALL_FAILED, TRUE, FALSE);
        return FALSE;

    }

    //
    // If we're allowing an uninstall, backup files listed in the INF
    //
    if (!g_si.fNoUninstall) {

        if (!InstallBackupFiles()) {

            Print(ERROR, L"[DoInstallation] Failed to backup files from INF\n");
            LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_FILE_BACKUP_FAILED, TRUE, FALSE);
            g_si.fCanUninstall = FALSE;
        }
    }

    //
    // If we're allowing an uninstall and the backup of files worked,
    // backup registry keys listed in the INF
    //
    if (!g_si.fNoUninstall) {

        if (g_si.fCanUninstall) {

            if (!InstallBackupRegistryKeys()) {

                Print(ERROR, L"[DoInstallation] Failed to backup registry keys from INF\n");
                LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_REG_BACKUP_FAILED, TRUE, FALSE);
                g_si.fCanUninstall = FALSE;
            }
        }
    }

    //
    // Remove any registry keys specified in the INF
    //
    CommonDeleteRegistryKeys();

    //
    // Remove files from the installation directory
    //
    CommonRemoveDirectoryAndFiles(g_si.lpwInstallDirectory,
                                  (PVOID) TRUE,
                                  FALSE,
                                  FALSE);

    //
    // Copy files specified in the INF
    //
    if (!InstallCopyFiles()) {

        Print(ERROR, L"[DoInstallation] Failed to copy files from INF\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_FILE_COPY_FAILED, TRUE, FALSE);
        return FALSE;
    }

    //
    // Merge any registry data specified in the INF
    //
    if (!InstallRegistryData()) {

        Print(ERROR, L"[DoInstallation] Failed to install registry data from INF\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_REG_MERGE_FAILED, TRUE, FALSE);
        return FALSE;
    }

    //
    // Perform any server registrations specified in the INF
    //
    if (!CommonRegisterServers(TRUE)) {

        Print(ERROR, L"[DoInstallation] Failed to register servers from INF\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_REGSVR32_FAILED, TRUE, FALSE);
    }

    //
    // Run any processes specified in the INF
    //
    InstallRunINFProcesses();

    //
    // If the backup operations worked, write out the uninstall key
    // In addition, put our uninstall INF in the installation directory
    //
    if (g_si.fCanUninstall) {
        InstallWriteUninstallKey();
        
        wsprintf(wszDestFileName,
                 L"%s\\%s",
                 g_si.lpwInstallDirectory,
                 UNINST_INF_FILE_NAMEW);

        ForceCopy(g_si.lpwUninstallINFPath, wszDestFileName);
    }

    //
    // Perform a reboot
    //
    if (!g_si.fQuiet && !g_si.fNoReboot) {
        
        LoadString(g_si.hInstance, IDS_REBOOT_NEEDED, wszTemp, MAX_PATH);        
            
        nReturn = MessageBox(NULL,
                             wszTemp,
                             g_si.lpwMessageBoxTitle,
                             MB_YESNO | MB_ICONQUESTION);

        if (nReturn == IDYES) {

            if (!ShutdownSystem(FALSE, TRUE)) {

                // The shutdown failed - prompt the user for a manual one
                LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_INS_REBOOT_FAILED, TRUE, FALSE);
            
            } else {

                // The shutdown was successful - write a message to the event log
                LogEventDisplayError(EVENTLOG_INFORMATION_TYPE, ID_INSTALL_SUCCESSFUL, FALSE, FALSE);
            }
        
        } else {

            // Interactive mode - the user said no to the reboot - write it to the event log
            // Don't display a message.
            LogEventDisplayError(EVENTLOG_WARNING_TYPE, ID_INS_QREBOOT_NEEDED, FALSE, FALSE);
            
        }
    
    } else {
        
        // Quiet mode - A reboot is needed - write it to event log
        LogEventDisplayError(EVENTLOG_WARNING_TYPE, ID_INS_QREBOOT_NEEDED, FALSE, FALSE);
    }

    Print(TRACE, L"[DoInstallation] Installation is complete\n");

    return TRUE;
}

/*++

  Routine Description:

    Performs the grunt work of the uninstall

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
DoUninstallation()
{
    WCHAR   wszTemp[MAX_PATH] = L"";
    WCHAR   wszBegin[MAX_PATH] = L"";
    WCHAR   wszBackupDir[MAX_PATH] = L"";
    char    szGuid[80] = "";
    WCHAR   wszGuid[80] = L"";
    BOOL    fReturn = FALSE;
    int     nReturn = 0;

    Print(TRACE, L"[DoUninstallation] Uninstall is starting\n");

    //
    // Display the prompt for installation if we're
    // not in quiet mode
    //
    if (!g_si.fQuiet) {

        LoadString(g_si.hInstance, IDS_UNINSTALL_PROMPT, wszTemp, MAX_PATH);

        wsprintf(wszBegin, wszTemp, g_si.lpwPrettyAppName);

        if (MessageBox(NULL, 
                       wszBegin,
                       g_si.lpwMessageBoxTitle,
                       MB_YESNO | MB_ICONQUESTION)!=IDYES)
        {
            return TRUE;
        }
    }

    //
    // Log an event that the uninstall is starting
    //
    LogEventDisplayError(EVENTLOG_INFORMATION_TYPE,
                         ID_UNINSTALL_START,
                         FALSE,
                         FALSE);

    //
    // Get section names from the INF
    //
    if (!UninstallGetSectionsFromINF()) {

        Print(ERROR, L"[DoUninstallation] Failed to get section names from INF\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_INF_SCAN_FAILED, TRUE, FALSE);
        return FALSE;
    }

    //
    // Remove the Uninstall key
    // If we replaced it during install, it will be restored
    // below. If not, no package was installed previously
    //
    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "GUID",
                                szGuid,
                                sizeof(szGuid),
                                NULL);

    if (!fReturn) {
        Print(ERROR, L"[DoUninstallation] Failed to get GUID from INF\n");
        LogEventDisplayError(NULL, EVENTLOG_ERROR_TYPE, ID_GET_INF_FAIL, TRUE);
        return FALSE;
    }

    pAnsiToUnicode(szGuid, wszGuid, 80);

    UninstallDeleteSubKey(REG_UNINSTALL, wszGuid);
    UninstallDeleteSubKey(REG_ACTIVE_SETUP, wszGuid);

    //
    // Delete any registry keys in prep for restore
    //
    if (!CommonDeleteRegistryKeys()) {

        Print(ERROR, L"[DoUninstallation] Failed to delete registry keys\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_REG_DELETE_FAILED, TRUE, FALSE);
        return FALSE;
    }

    //
    // Restore registry keys we replaced
    //
    if (!UninstallRestoreRegistryKeys()) {

        Print(ERROR, L"[DoUninstallation] Failed to restore registry keys from INF\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_REG_RESTORE_FAILED, TRUE, FALSE);
        return FALSE;
    }

    //
    // The routine below does some custom things
    //
    UninstallCustomWorker();

    //
    // Remove files under the installation directory
    //
    UninstallRemoveFiles();

    //
    // Restore any files we replaced
    //
    if (!UninstallRestoreFiles()) {
        Print(ERROR, L"[DoUninstallation] Failed to restore files from INF\n");
        LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_FILE_RESTORE_FAILED, TRUE, FALSE);
        return FALSE;
    }

    //
    // Remove the '$Uninstall$ directory and delete the uninstall INF file
    //
    wsprintf(wszBackupDir,
             L"%s\\%s",
             g_si.lpwInstallDirectory,
             g_si.lpwUninstallDirectory);

    Print(TRACE, L"[DoUninstallation] Path to Uninstall dir: %s\n", wszBackupDir);

    CommonRemoveDirectoryAndFiles(wszBackupDir, (PVOID) FALSE, TRUE, FALSE);

    SetupCloseInfFile(g_si.hInf);

    DeleteFile(g_si.lpwUninstallINFPath);
    
    //
    // Perform a reboot
    //
    if (!g_si.fQuiet) {
        
        LoadString(g_si.hInstance, IDS_REBOOT_NEEDED, wszTemp, MAX_PATH);
            
        // Prompt the user to reboot
        nReturn = MessageBox(NULL,
                             wszTemp,
                             g_si.lpwMessageBoxTitle,
                             MB_YESNO | MB_ICONQUESTION);

        if (nReturn == IDYES) {

            if (!ShutdownSystem(FALSE, TRUE)) {

                // The shutdown failed - prompt the user for a manual one
                LogEventDisplayError(EVENTLOG_ERROR_TYPE, ID_UNINS_REBOOT_FAILED, TRUE, FALSE);
            
            } else {

                // The shutdown was successful - write a message to the event log
                LogEventDisplayError(EVENTLOG_INFORMATION_TYPE, ID_UNINSTALL_SUCCESSFUL, FALSE, FALSE);
            }
        
        } else {

            // Interactive mode - the user said no to the reboot - write it to the event log
            // Don't display a message.
            LogEventDisplayError(EVENTLOG_WARNING_TYPE, ID_UNINS_QREBOOT_NEEDED, FALSE, FALSE);
        }
    
    } else {

        // Quiet mode - A reboot is needed - write it to event log
        LogEventDisplayError(EVENTLOG_WARNING_TYPE, ID_UNINS_QREBOOT_NEEDED, FALSE, FALSE);
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\cstest\ind_keyb.cxx ===
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//

#include "precomp.hxx"

#define NUM_OFFSET      0
#define ALPHA_OFFSET    10
#define BA_OFFSET       36
#define DB_OFFSET       43

typedef struct kbd KBD, *PKBD;

struct kbd {
    unsigned short *pcharMap;
    unsigned short *pshiftCharMap;
    unsigned short *pctrlCharMap;
    unsigned short *paltGrCharMap;
    unsigned short *pshiftAltGrCharMap;
};

unsigned short nullMap[][4] = {
    {0, 0, 0, 0},// 0
    {0, 0, 0, 0},// 1
    {0, 0, 0, 0},// 2
    {0, 0, 0, 0},// 3
    {0, 0, 0, 0},// 4
    {0, 0, 0, 0},// 5
    {0, 0, 0, 0},// 6
    {0, 0, 0, 0},// 7
    {0, 0, 0, 0},// 8
    {0, 0, 0, 0},// 9 - 10 entries
    {0, 0, 0, 0},// A
    {0, 0, 0, 0},// B
    {0, 0, 0, 0},// C
    {0, 0, 0, 0},// D
    {0, 0, 0, 0},// E
    {0, 0, 0, 0},// F
    {0, 0, 0, 0},// G
    {0, 0, 0, 0},// H
    {0, 0, 0, 0},// I
    {0, 0, 0, 0},// J
    {0, 0, 0, 0},// K
    {0, 0, 0, 0},// L
    {0, 0, 0, 0},// M
    {0, 0, 0, 0},// N
    {0, 0, 0, 0},// O
    {0, 0, 0, 0},// P
    {0, 0, 0, 0},// Q
    {0, 0, 0, 0},// R
    {0, 0, 0, 0},// S
    {0, 0, 0, 0},// T
    {0, 0, 0, 0},// U
    {0, 0, 0, 0},// V
    {0, 0, 0, 0},// W
    {0, 0, 0, 0},// X
    {0, 0, 0, 0},// Y
    {0, 0, 0, 0},// Z - 36 entries (not used)
    {0, 0, 0, 0},// ;(0xba)
    {0, 0, 0, 0},// =(0xbb)
    {0, 0, 0, 0},// ,(0xbc)
    {0, 0, 0, 0},// -(0xbd)
    {0, 0, 0, 0},// .(0xbe)
    {0, 0, 0, 0},// /(0xbf)
    {0, 0, 0, 0},// `(0xc0) - 43 entries
    {0, 0, 0, 0},// [(0xdb)
    {0, 0, 0, 0},// \(0xdc)
    {0, 0, 0, 0},// ](0xdd)
    {0, 0, 0, 0}// '(0xde) - 47 entries
};

unsigned short ctrlCharMap[][4] = {
    {0, 0, 0, 0},// 0
    {1, 0x200d, 0, 0},// 1 ZWJ
    {1, 0x200c, 0, 0},// 2 ZWNJ
    {0, 0, 0, 0},// 3
    {0, 0, 0, 0},// 4
    {0, 0, 0, 0},// 5
    {0, 0, 0, 0},// 6
    {0, 0, 0, 0},// 7
    {0, 0, 0, 0},// 8
    {0, 0, 0, 0},// 9 - 10 entries
    {0, 0, 0, 0},// A
    {0, 0, 0, 0},// B
    {0, 0, 0, 0},// C
    {0, 0, 0, 0},// D
    {0, 0, 0, 0},// E
    {0, 0, 0, 0},// F
    {0, 0, 0, 0},// G
    {0, 0, 0, 0},// H
    {0, 0, 0, 0},// I
    {0, 0, 0, 0},// J
    {0, 0, 0, 0},// K
    {0, 0, 0, 0},// L
    {0, 0, 0, 0},// M
    {0, 0, 0, 0},// N
    {0, 0, 0, 0},// O
    {0, 0, 0, 0},// P
    {0, 0, 0, 0},// Q
    {0, 0, 0, 0},// R
    {0, 0, 0, 0},// S
    {0, 0, 0, 0},// T
    {0, 0, 0, 0},// U
    {0, 0, 0, 0},// V
    {0, 0, 0, 0},// W
    {0, 0, 0, 0},// X
    {0, 0, 0, 0},// Y
    {0, 0, 0, 0},// Z - 36 entries (not used)
    {0, 0, 0, 0},// ;(0xba)
    {0, 0, 0, 0},// =(0xbb)
    {0, 0, 0, 0},// ,(0xbc)
    {0, 0, 0, 0},// -(0xbd)
    {0, 0, 0, 0},// .(0xbe)
    {0, 0, 0, 0},// /(0xbf)
    {0, 0, 0, 0},// `(0xc0) - 43 entries
    {0, 0, 0, 0},// [(0xdb)
    {0, 0, 0, 0},// \(0xdc)
    {0, 0, 0, 0},// ](0xdd)
    {0, 0, 0, 0}// '(0xde) - 47 entries
};

unsigned short devCharMap[][4] = {
    {1, 0x0030, 0, 0},// 0
    {1, 0x0031, 0, 0},// 1
    {1, 0x0032, 0, 0},// 2
    {1, 0x0033, 0, 0},// 3
    {1, 0x0034, 0, 0},// 4
    {1, 0x0035, 0, 0},// 5
    {1, 0x0036, 0, 0},// 6
    {1, 0x0037, 0, 0},// 7
    {1, 0x0038, 0, 0},// 8
    {1, 0x0039, 0, 0},// 9 - 10 entries
    {1, 0x094b, 0, 0},// A
    {1, 0x0935, 0, 0},// B
    {1, 0x092e, 0, 0},// C
    {1, 0x094d, 0, 0},// D
    {1, 0x093e, 0, 0},// E
    {1, 0x093f, 0, 0},// F
    {1, 0x0941, 0, 0},// G
    {1, 0x092a, 0, 0},// H
    {1, 0x0917, 0, 0},// I
    {1, 0x0930, 0, 0},// J
    {1, 0x0915, 0, 0},// K
    {1, 0x0924, 0, 0},// L
    {1, 0x0938, 0, 0},// M
    {1, 0x0932, 0, 0},// N
    {1, 0x0926, 0, 0},// O
    {1, 0x091c, 0, 0},// P
    {1, 0x094c, 0, 0},// Q
    {1, 0x0940, 0, 0},// R
    {1, 0x0947, 0, 0},// S
    {1, 0x0942, 0, 0},// T
    {1, 0x0939, 0, 0},// U
    {1, 0x0928, 0, 0},// V
    {1, 0x0948, 0, 0},// W
    {1, 0x0902, 0, 0},// X
    {1, 0x092c, 0, 0},// Y
    {1, 0x0946, 0, 0},// Z - 36 entries
    {1, 0x091a, 0, 0},// ;(0xba)
    {1, 0x0943, 0, 0},// =(0xbb)
    {0, 0, 0, 0},// ,(0xbc)
    {1, 0X002D, 0, 0},// -(0xbd)
    {1, 0X002E, 0, 0},// .(0xbe)
    {1, 0x092f, 0, 0},// /(0xbf)
    {1, 0x094a, 0, 0},// `(0xc0) - 43 entries
    {1, 0x0921, 0, 0},// [(0xdb)
    {1, 0x0949, 0, 0},// \(0xdc)
    {1, 0x093c, 0, 0},// ](0xdd)
    {1, 0x091f, 0, 0}// '(0xde) - 47 entries
};

unsigned short devShiftCharMap[][4] = {
    {1, 0X0029, 0, 0},// 0
    {1, 0x090d, 0, 0},// 1
    {1, 0x0945, 0, 0},// 2
    {2, 0x094d, 0x0930, 0},// 3
    {2, 0x0930, 0x094d, 0},// 4
    {3, 0x091c, 0x094d, 0x091e},// 5
    {3, 0x0924, 0x094d, 0x0930},// 6
    {3, 0x0915, 0x094d, 0x0937},// 7
    {3, 0x0936, 0x094d, 0x0930},// 8
    {1, 0X0028, 0, 0},// 9
    {1, 0x0913, 0, 0},// A
    {1, 0X0934, 0, 0},// B
    {1, 0x0923, 0, 0},// C
    {1, 0x0905, 0, 0},// D
    {1, 0x0906, 0, 0},// E
    {1, 0x0907, 0, 0},// F
    {1, 0x0909, 0, 0},// G
    {1, 0x092b, 0, 0},// H
    {1, 0x0918, 0, 0},// I
    {1, 0x0931, 0, 0},// J
    {1, 0x0916, 0, 0},// K
    {1, 0x0925, 0, 0},// L
    {1, 0x0936, 0, 0},// M
    {1, 0x0933, 0, 0},// N
    {1, 0x0927, 0, 0},// O
    {1, 0x091d, 0, 0},// P
    {1, 0x0914, 0, 0},// Q
    {1, 0x0908, 0, 0},// R
    {1, 0x090f, 0, 0},// S
    {1, 0x090a, 0, 0},// T
    {1, 0x0919, 0, 0},// U
    {1, 0X0929, 0, 0},// V
    {1, 0x0910, 0, 0},// W
    {1, 0x0901, 0, 0},// X
    {1, 0x092d, 0, 0},// Y
    {1, 0x90E, 0, 0},// Z - 36 entries (not used)
    {1, 0x091b, 0, 0},// ;(0xba)
    {1, 0x090b, 0, 0},// =(0xbb)
    {1, 0x0937, 0, 0},// ,(0xbc)
    {1, 0x0903, 0, 0},// -(0xbd)
    {1, 0x0964, 0, 0},// .(0xbe)
    {1, 0X095f, 0, 0},// /(0xbf)
    {1, 0x0912, 0, 0},// `(0xc0) - 43 entries
    {1, 0x0922, 0, 0},// [(0xdb)
    {1, 0x0911, 0, 0},// \(0xdc)
    {1, 0x091e, 0, 0},// ](0xdd)
    {1, 0x0920, 0, 0}// '(0xde) - 47 entries
};

unsigned short devAltGrCharMap[][4] = {
    {1, 0x0966, 0, 0},// 0
    {1, 0x0967, 0, 0},// 1
    {1, 0x0968, 0, 0},// 2
    {1, 0x0969, 0, 0},// 3
    {1, 0x096a, 0, 0},// 4
    {1, 0x096b, 0, 0},// 5
    {1, 0x096c, 0, 0},// 6
    {1, 0x096d, 0, 0},// 7
    {1, 0x096e, 0, 0},// 8
    {1, 0x096f, 0, 0},// 9 - 10 entries
    {0, 0, 0, 0},// A
    {0, 0, 0, 0},// B
    {1, 0X0954, 0, 0},// C
    {0, 0, 0, 0},// D
    {0, 0, 0, 0},// E
    {1, 0x0962, 0, 0},// F
    {0, 0, 0, 0},// G
    {0, 0, 0, 0},// H
    {1, 0x095a, 0, 0},// I
    {0, 0, 0, 0},// J
    {1, 0x0958, 0, 0},// K
    {0, 0, 0, 0},// L
    {0, 0, 0, 0},// M
    {0, 0, 0, 0},// N
    {0, 0, 0, 0},// O
    {1, 0x095b, 0, 0},// P
    {0, 0, 0, 0},// Q
    {1, 0x0963, 0, 0},// R
    {0, 0, 0, 0},// S
    {0, 0, 0, 0},// T
    {0, 0, 0, 0},// U
    {0, 0, 0, 0},// V
    {0, 0, 0, 0},// W
    {0, 0, 0, 0},// X
    {0, 0, 0, 0},// Y
    {1, 0X0953, 0, 0},// Z - 36 entries (not used)
    {1, 0x0952, 0, 0},// ;(0xba)
    {1, 0x0944, 0, 0},// =(0xbb)
    {1, 0x0970, 0, 0},// ,(0xbc)
    {0, 0, 0, 0},// -(0xbd)
    {1, 0X0965, 0, 0},// .(0xbe)
    {0, 0, 0, 0},// /(0xbf)
    {0, 0, 0, 0},// `(0xc0) - 43 entries
    {1, 0x095c, 0, 0},// [(0xdb)
    {0, 0, 0, 0},// \(0xdc)
    {0, 0, 0, 0},// ](0xdd)
    {0, 0, 0, 0}// '(0xde) - 47 entries
};

unsigned short devShiftAltGrCharMap[][4] = {
    {0, 0, 0, 0},// 0
    {0, 0, 0, 0},// 1
    {0, 0, 0, 0},// 2
    {0, 0, 0, 0},// 3
    {0, 0, 0, 0},// 4
    {0, 0, 0, 0},// 5
    {0, 0, 0, 0},// 6
    {0, 0, 0, 0},// 7
    {0, 0, 0, 0},// 8
    {0, 0, 0, 0},// 9
    {0, 0, 0, 0},// A
    {0, 0, 0, 0},// B
    {0, 0, 0, 0},// C
    {0, 0, 0, 0},// D
    {0, 0, 0, 0},// E
    {1, 0x090c, 0, 0},// F
    {0, 0, 0, 0},// G
    {1, 0x095e, 0, 0},// H
    {0, 0, 0, 0},// I
    {0, 0, 0, 0},// J
    {1, 0x0959, 0, 0},// K
    {0, 0, 0, 0},// L
    {0, 0, 0, 0},// M
    {0, 0, 0, 0},// N
    {0, 0, 0, 0},// O
    {0, 0, 0, 0},// P
    {0, 0, 0, 0},// Q
    {1, 0x0961, 0, 0},// R
    {0, 0, 0, 0},// S
    {0, 0, 0, 0},// T
    {0, 0, 0, 0},// U
    {0, 0, 0, 0},// V
    {0, 0, 0, 0},// W
    {1, 0x0950, 0, 0},// X
    {0, 0, 0, 0},// Y
    {0, 0, 0, 0},// Z - 36 entries (not used)
    {0, 0, 0, 0},// ;(0xba)
    {1, 0x0960, 0, 0},// =(0xbb)
    {0, 0, 0, 0},// ,(0xbc)
    {0, 0, 0, 0},// -(0xbd)
    {1, 0x093d, 0, 0},// .(0xbe)
    {0, 0, 0, 0},// /(0xbf)
    {0, 0, 0, 0},// `(0xc0) - 43 entries
    {1, 0x095d, 0, 0},// [(0xdb)
    {0, 0, 0, 0},// \(0xdc)
    {0, 0, 0, 0},// ](0xdd)
    {1, 0x0951, 0, 0}// '(0xde) - 47 entries
};

unsigned short tamCharMap[][4] = {
    {1, 0x0030, 0, 0},// 0
    {1, 0x0031, 0, 0},// 1
    {1, 0x0032, 0, 0},// 2
    {1, 0x0033, 0, 0},// 3
    {1, 0x0034, 0, 0},// 4
    {1, 0x0035, 0, 0},// 5
    {1, 0x0036, 0, 0},// 6
    {1, 0x0037, 0, 0},// 7
    {1, 0x0038, 0, 0},// 8
    {1, 0x0039, 0, 0},// 9 - 10 entries
    {1, 0x0bcb, 0, 0},// A
    {1, 0x0bb5, 0, 0},// B
    {1, 0x0bae, 0, 0},// C
    {1, 0x0bcd, 0, 0},// D
    {1, 0x0bbe, 0, 0},// E
    {1, 0x0bbf, 0, 0},// F
    {1, 0x0bc1, 0, 0},// G
    {1, 0x0baa, 0, 0},// H
    {1, 0x0b95, 0, 0},// I
    {1, 0x0bb0, 0, 0},// J
    {1, 0x0b95, 0, 0},// K
    {1, 0x0ba4, 0, 0},// L
    {1, 0x0bb8, 0, 0},// M
    {1, 0x0bb2, 0, 0},// N
    {1, 0x0ba4, 0, 0},// O
    {1, 0x0b9c, 0, 0},// P
    {1, 0x0bcc, 0, 0},// Q
    {1, 0x0bc0, 0, 0},// R
    {1, 0x0bc7, 0, 0},// S
    {1, 0x0bc2, 0, 0},// T
    {1, 0x0bb9, 0, 0},// U
    {1, 0x0ba8, 0, 0},// V
    {1, 0x0bc8, 0, 0},// W
    {0, 0, 0, 0},// X
    {1, 0x0baa, 0, 0},// Y
    {1, 0x0bc6, 0, 0},// Z - 36 entries
    {1, 0x0b9b, 0, 0},// ;(0xba)
    {3, 0x0bcd, 0x0bb0, 0x0bbf},// =(0xbb)
    {0, 0, 0, 0},// ,(0xbc)
    {1, 0X0b83, 0, 0},// -(0xbd)
    {1, 0X002E, 0, 0},// .(0xbe)
    {1, 0x0baf, 0, 0},// /(0xbf)
    {1, 0x0bca, 0, 0},// `(0xc0) - 43 entries
    {1, 0x0b9f, 0, 0},// [(0xdb)
    {1, 0x0b86, 0, 0},// \(0xdc)
    {1, 0x0b9e, 0, 0},// ](0xdd)
    {1, 0x0b9f, 0, 0}// '(0xde) - 47 entries
};

unsigned short tamShiftCharMap[][4] = {
    {1, 0X0029, 0, 0},// 0
    {0, 0, 0, 0},// 1
    {1, 0xbbe, 0, 0},// 2
    {0, 0, 0, 0},// 3
    {0, 0, 0, 0},// 4
    {0, 0, 0, 0},// 5
    {3, 0x0ba4, 0x0bcd, 0x0bb0},// 6
    {3, 0x0b95, 0x0bcd, 0x0bb7},// 7
    {3, 0x0bb7, 0x0bcd, 0x0bb0},// 8
    {1, 0X0028, 0, 0},// 9
    {1, 0x0b93, 0, 0},// A
    {1, 0X0bb4, 0, 0},// B
    {1, 0x0ba3, 0, 0},// C
    {1, 0x0b85, 0, 0},// D
    {1, 0x0b86, 0, 0},// E
    {1, 0x0b87, 0, 0},// F
    {1, 0x0b89, 0, 0},// G
    {1, 0x0baa, 0, 0},// H
    {1, 0x0b95, 0, 0},// I
    {1, 0x0bb1, 0, 0},// J
    {1, 0x0b95, 0, 0},// K
    {1, 0x0ba4, 0, 0},// L
    {1, 0x0bb7, 0, 0},// M
    {1, 0x0bb3, 0, 0},// N
    {1, 0x0ba4, 0, 0},// O
    {1, 0x0b9a, 0, 0},// P
    {1, 0x0b94, 0, 0},// Q
    {1, 0x0b88, 0, 0},// R
    {1, 0x0b8f, 0, 0},// S
    {1, 0x0b8a, 0, 0},// T
    {1, 0x0b99, 0, 0},// U
    {1, 0X0ba9, 0, 0},// V
    {1, 0x0b90, 0, 0},// W
    {0, 0, 0, 0},// X
    {1, 0x092d, 0, 0},// Y
    {1, 0xb8E, 0, 0},// Z - 36 entries (not used)
    {1, 0x0b9a, 0, 0},// ;(0xba)
    {0, 0, 0, 0},// =(0xbb)
    {1, 0x0bb7, 0, 0},// ,(0xbc)
    {0, 0, 0, 0},// -(0xbd)
    {1, 0x002e, 0, 0},// .(0xbe)
    {1, 0X0baf, 0, 0},// /(0xbf)
    {1, 0x0b92, 0, 0},// `(0xc0) - 43 entries
    {1, 0x0b9f, 0, 0},// [(0xdb)
    {1, 0x0bbe, 0, 0},// \(0xdc)
    {1, 0x093c, 0, 0},// ](0xdd)
    {0, 0, 0, 0}// '(0xde) - 47 entries
};

unsigned short tamAltGrCharMap[][4] = {
    {0, 0, 0, 0},// 0
    {0, 0x0be7, 0, 0},// 1
    {1, 0x0be8, 0, 0},// 2
    {1, 0x0be9, 0, 0},// 3
    {1, 0x0bea, 0, 0},// 4
    {1, 0x0beb, 0, 0},// 5
    {1, 0x0bec, 0, 0},// 6
    {1, 0x0bed, 0, 0},// 7
    {1, 0x0bee, 0, 0},// 8
    {1, 0x0bef, 0, 0},// 9
    {0, 0, 0, 0},// A
    {0, 0, 0, 0},// B
    {0, 0, 0, 0},// C
    {0, 0, 0, 0},// D
    {0, 0, 0, 0},// E
    {0, 0, 0, 0},// F
    {0, 0, 0, 0},// G
    {0, 0, 0, 0},// H
    {0, 0, 0, 0},// I
    {0, 0, 0, 0},// J
    {0, 0, 0, 0},// K
    {0, 0, 0, 0},// L
    {0, 0, 0, 0},// M
    {0, 0, 0, 0},// N
    {0, 0, 0, 0},// O
    {0, 0, 0, 0},// P
    {0, 0, 0, 0},// Q
    {0, 0, 0, 0},// R
    {0, 0, 0, 0},// S
    {0, 0, 0, 0},// T
    {0, 0, 0, 0},// U
    {0, 0, 0, 0},// V
    {0, 0, 0, 0},// W
    {0, 0, 0, 0},// X
    {0, 0, 0, 0},// Y
    {0, 0, 0, 0},// Z - 36 entries (not used)
    {0, 0, 0, 0},// ;(0xba)
    {0, 0, 0, 0},// =(0xbb)
    {0, 0, 0, 0},// ,(0xbc)
    {0, 0, 0, 0},// -(0xbd)
    {0, 0, 0, 0},// .(0xbe)
    {0, 0, 0, 0},// /(0xbf)
    {0, 0, 0, 0},// `(0xc0) - 43 entries
    {0, 0, 0, 0},// [(0xdb)
    {0, 0, 0, 0},// \(0xdc)
    {0, 0, 0, 0},// ](0xdd)
    {0, 0, 0, 0}// '(0xde) - 47 entries
};

unsigned short telCharMap[][4] = {
    {1, 0x0030, 0, 0},// 0
    {1, 0x0031, 0, 0},// 1
    {1, 0x0032, 0, 0},// 2
    {1, 0x0033, 0, 0},// 3
    {1, 0x0034, 0, 0},// 4
    {1, 0x0035, 0, 0},// 5
    {1, 0x0036, 0, 0},// 6
    {1, 0x0037, 0, 0},// 7
    {1, 0x0038, 0, 0},// 8
    {1, 0x0039, 0, 0},// 9 - 10 entries
    {1, 0x0c4b, 0, 0},// A
    {1, 0x0c35, 0, 0},// B
    {1, 0x0c2e, 0, 0},// C
    {1, 0x0c4d, 0, 0},// D
    {1, 0x0c3e, 0, 0},// E
    {1, 0x0c3f, 0, 0},// F
    {1, 0x0c41, 0, 0},// G
    {1, 0x0c2a, 0, 0},// H
    {1, 0x0c17, 0, 0},// I
    {1, 0x0c30, 0, 0},// J
    {1, 0x0c15, 0, 0},// K
    {1, 0x0c24, 0, 0},// L
    {1, 0x0c38, 0, 0},// M
    {1, 0x0c32, 0, 0},// N
    {1, 0x0c26, 0, 0},// O
    {1, 0x0c1c, 0, 0},// P
    {1, 0x0c4c, 0, 0},// Q
    {1, 0x0c40, 0, 0},// R
    {1, 0x0c47, 0, 0},// S
    {1, 0x0c42, 0, 0},// T
    {1, 0x0c39, 0, 0},// U
    {1, 0x0c28, 0, 0},// V
    {1, 0x0c48, 0, 0},// W
    {1, 0x0c02, 0, 0},// X
    {1, 0x0c2c, 0, 0},// Y
    {1, 0x0c46, 0, 0},// Z - 36 entries
    {1, 0x0c1a, 0, 0},// ;(0xba)
    {1, 0x0C43, 0, 0},// =(0xbb)
    {0, 0, 0, 0},// ,(0xbc)
    {1, 0X002D, 0, 0},// -(0xbd)
    {1, 0X002E, 0, 0},// .(0xbe)
    {0, 0, 0, 0},// /(0xbf)
    {1, 0x0c4a, 0, 0},// `(0xc0) - 43 entries
    {1, 0x0c21, 0, 0},// [(0xdb)
    {1, 0x0c49, 0, 0},// \(0xdc)
    {0, 0, 0, 0},// ](0xdd)
    {1, 0X0c1f, 0, 0}// '(0xde) - 47 entries
};

unsigned short telShiftCharMap[][4] = {
    {1, 0X0029, 0, 0},// 0
    {0, 0x0, 0, 0},// 1
    {0, 0x0, 0, 0},// 2
    {2, 0x0c4d, 0x0c30, 0},// 3
    {0, 0, 0, 0},// 4
    {3, 0x0c1c, 0x0c4d, 0x0c1e},// 5
    {3, 0x0c24, 0x0c4d, 0x0c30},// 6
    {3, 0x0c15, 0x0c4d, 0x0c37},// 7
    {3, 0x0c36, 0x0c4d, 0x0c30},// 8
    {1, 0X0028, 0, 0},// 9
    {1, 0x0c13, 0, 0},// A
    {0, 0, 0, 0},// B
    {1, 0x0c23, 0, 0},// C
    {1, 0x0c05, 0, 0},// D
    {1, 0x0c06, 0, 0},// E
    {1, 0x0c07, 0, 0},// F
    {1, 0x0c09, 0, 0},// G
    {1, 0x0c2b, 0, 0},// H
    {1, 0x0c18, 0, 0},// I
    {1, 0x0c31, 0, 0},// J
    {1, 0x0c16, 0, 0},// K
    {1, 0x0c25, 0, 0},// L
    {1, 0x0c36, 0, 0},// M
    {1, 0x0c33, 0, 0},// N
    {1, 0x0c27, 0, 0},// O
    {1, 0x0c1d, 0, 0},// P
    {1, 0x0c14, 0, 0},// Q
    {1, 0x0c08, 0, 0},// R
    {1, 0x0c0f, 0, 0},// S
    {1, 0x0c0a, 0, 0},// T
    {1, 0x0c19, 0, 0},// U
    {1, 0x0c28, 0, 0},// V
    {1, 0x0c10, 0, 0},// W
    {1, 0x0c01, 0, 0},// X
    {0, 0, 0, 0},// Y
    {1, 0x0c0E, 0, 0},// Z - 36 entries (not used)
    {1, 0x0c1b, 0, 0},// ;(0xba)
    {1, 0x0c0b, 0, 0},// =(0xbb)
    {1, 0x0c37, 0, 0},// ,(0xbc)
    {1, 0x029, 0, 0},// -(0xbd)
    {0, 0, 0, 0},// .(0xbe)
    {1, 0x0c2f, 0, 0},// /(0xbf)
    {1, 0x0c12, 0, 0},// `(0xc0) - 43 entries
    {1, 0x0c22, 0, 0},// [(0xdb)
    {1, 0x0c2f, 0, 0},// \(0xdc)
    {1, 0x0c1e, 0, 0},// ](0xdd)
    {1, 0x0c20, 0, 0}// '(0xde) - 47 entries
};

unsigned short telAltGrCharMap[][4] = {
    {1, 0x0c66, 0, 0},// 0
    {1, 0x0c67, 0, 0},// 1
    {1, 0x0c68, 0, 0},// 2
    {1, 0x0c69, 0, 0},// 3
    {1, 0x0c6a, 0, 0},// 4
    {1, 0x0c6b, 0, 0},// 5
    {1, 0x0c6c, 0, 0},// 6
    {1, 0x0c6d, 0, 0},// 7
    {1, 0x0c6e, 0, 0},// 8
    {1, 0x0c6f, 0, 0},// 9 - 10 entries
    {0, 0, 0, 0},// A
    {0, 0, 0, 0},// B
    {0, 0x0, 0, 0},// C
    {0, 0, 0, 0},// D
    {0, 0, 0, 0},// E
    {1, 0x0c0c, 0, 0},// F
    {0, 0, 0, 0},// G
    {0, 0, 0, 0},// H
    {0, 0, 0, 0},// I
    {0, 0, 0, 0},// J
    {0, 0, 0, 0},// K
    {0, 0, 0, 0},// L
    {0, 0, 0, 0},// M
    {0, 0, 0, 0},// N
    {0, 0, 0, 0},// O
    {0, 0, 0, 0},// P
    {0, 0, 0, 0},// Q
    {1, 0x0c61, 0, 0},// R
    {0, 0, 0, 0},// S
    {0, 0, 0, 0},// T
    {0, 0, 0, 0},// U
    {0, 0, 0, 0},// V
    {1, 0x0c56, 0, 0},// W
    {0, 0, 0, 0},// X
    {0, 0, 0, 0},// Y
    {0, 0, 0, 0},// Z - 36 entries (not used)
    {0, 0, 0, 0},// ;(0xba)
    {1, 0x0c44, 0, 0},// =(0xbb)
    {0, 0, 0, 0},// ,(0xbc)
    {0, 0, 0, 0},// -(0xbd)
    {0, 0, 0, 0},// .(0xbe)
    {0, 0, 0, 0},// /(0xbf)
    {0, 0, 0, 0},// `(0xc0) - 43 entries
    {0, 0, 0, 0},// [(0xdb)
    {0, 0, 0, 0},// \(0xdc)
    {0, 0, 0, 0},// ](0xdd)
    {0, 0, 0, 0}// '(0xde) - 47 entries
};

KBD devKbd = {
    (unsigned short *)devCharMap,
    (unsigned short *)devShiftCharMap,
    (unsigned short *)ctrlCharMap,
    (unsigned short *)devAltGrCharMap,
    (unsigned short *)devShiftAltGrCharMap
};

KBD tamKbd = {
    (unsigned short *)tamCharMap,
    (unsigned short *)tamShiftCharMap,
    (unsigned short *)ctrlCharMap,
    (unsigned short *)tamAltGrCharMap,
    (unsigned short *)nullMap
};

KBD telKbd = {
    (unsigned short *)telCharMap,
    (unsigned short *)telShiftCharMap,
    (unsigned short *)ctrlCharMap,
    (unsigned short *)telAltGrCharMap,
    (unsigned short *)nullMap
};

PKBD pKbd = &devKbd;

BOOL IndicTranslate(CONST MSG *lpMsg){
    unsigned short shiftKey;
    unsigned short capsKey;
    unsigned short altGr;
    unsigned short ctrl;
    unsigned short *ptrMap;
    unsigned short keyCode;
    int offset;
    int msgCount;
    int i;

    // Translate only WM_KEYDOWN messages
    switch(lpMsg->message){
    case WM_KEYDOWN:
    case WM_SYSKEYDOWN:
        break;
    default:
        return FALSE;
    }

    //Check shift key state
    capsKey = (unsigned short)(0x1 & GetKeyState(VK_CAPITAL));
    if (!capsKey){
        return FALSE;
    }
    //Check altGr key state
    altGr = (unsigned short)(0x8000 & GetKeyState(VK_RMENU));
    if (lpMsg->message == WM_SYSKEYDOWN && !altGr){
        return FALSE;
    }

    //Retrieve key code
    keyCode = (unsigned short)lpMsg->wParam;

    //Check ctrl key state
    ctrl = (unsigned short)(0x8000 & GetKeyState(VK_CONTROL));

    //Check shift key state
    shiftKey = (unsigned short)(0x8000 & GetKeyState(VK_SHIFT));
    
    if(ctrl && shiftKey)
    {
        switch(keyCode){
        case '1':
            pKbd = &devKbd;
            break;
        case '2':
            pKbd = &tamKbd;
            break;
        case '3':
            pKbd = &telKbd;
            break;
        }
        return TRUE;
    }

    //Choose appropriate mapping table
    if(shiftKey){
        if (altGr){
            ptrMap = pKbd->pshiftAltGrCharMap;
        }
        else {
            ptrMap = pKbd->pshiftCharMap;
        }
    }
    else if (altGr){
        ptrMap = pKbd->paltGrCharMap;
    }
    else if (ctrl){
        ptrMap = pKbd->pctrlCharMap;
    }
    else{
        ptrMap = pKbd->pcharMap;
    }

    //Index into selected mapping table and generate WM_CHAR Messages
    if(0xdb <= keyCode &&  0xde >= keyCode){
        offset = DB_OFFSET + keyCode - 0xdb;
    }
    else if (0xba <= keyCode &&  0xc0 >= keyCode){
        offset = BA_OFFSET + keyCode - 0xba;
    }
    else if (0x41  <= keyCode &&  0x5a >= keyCode){
        offset = ALPHA_OFFSET + keyCode - 0x41;
    }
    else if (0x30  <= keyCode &&  0x39 >= keyCode){
        offset = NUM_OFFSET + keyCode - 0x30;
    }
    else{
        return FALSE;
    }

    offset *= 4;//pre-calculate one dimensional index
    msgCount = ptrMap[offset];
    
    //if this key cannot be translated
    if(msgCount == 0){
        MessageBeep(0xFFFFFFFF);
        return TRUE;
    }

    //translate key
    for (i=1; i<= msgCount; i++)
        PostMessage(lpMsg->hwnd, WM_CHAR, ptrMap[offset+i], lpMsg->lParam);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\appcompat\windowsupdate\installer\wufns.cpp ===
/*++

  Copyright (c) 2001 Microsoft Corporation

  Module Name:

    Dufns.cpp

  Abstract:

    Functions used throughout the app.

  Notes:

    Unicode only.

  History:

    03/02/2001      rparsons    Created
    
--*/

#include "precomp.h"

extern SETUP_INFO g_si;

/*++

  Routine Description:

    Parses the command line and fills in our
    structure that contains app-related data 

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
ParseCommandLine()
{
    int     nArgc = 0;
    int     nCount = 0;
    LPWSTR  *lpwCommandLine = NULL;

    //
    // Initialize structure members to defaults
    //
    g_si.fQuiet                 =   FALSE;
    g_si.fInstall               =   TRUE;
    g_si.fForceInstall          =   FALSE;
    g_si.nErrorLevel            =   ERROR;
    g_si.fNoReboot              =   FALSE;
    g_si.fNoUninstall           =   FALSE;
    g_si.fNeedToAdjustACL       =   FALSE;
    g_si.fOnWin2K               =   FALSE;
    g_si.fUpdateDllCache        =   TRUE;
    g_si.fCanUninstall          =   TRUE;
    g_si.nErrorLevel            =   ERROR;
    
    //
    // Get the command line
    //
    lpwCommandLine = CommandLineToArgvW(GetCommandLine(), &nArgc);

    if (NULL == lpwCommandLine) {
        return FALSE;
    }    

    for (nCount = 1; nCount < nArgc; nCount++) {

      if ((lpwCommandLine[nCount][0] == L'-') || 
          (lpwCommandLine[nCount][0] == L'/')) {
          
          switch (lpwCommandLine[nCount][1]) {
    
            case 'q':
            case 'Q':
                g_si.fQuiet = TRUE;
            break;

            case 'i':
            case 'I':
                g_si.fInstall = TRUE;
            break;

            case 'u':
            case 'U':
                g_si.fInstall = FALSE;
            break;

            case 'f':
            case 'F':
                g_si.fForceInstall = TRUE;
            break;

            case 'd':
            case 'D':
                g_si.nErrorLevel = TRACE;
            break;

            case 'z':
            case 'Z':
              g_si.fNoReboot = TRUE;
            break;

            case 'n':
            case 'N':
              g_si.fNoUninstall = TRUE;
            break;
          }
      }
    }

    GlobalFree(lpwCommandLine);
    
    return TRUE;
}

/*++

  Routine Description:

    Determines if another instance of the
    application is running 

  Arguments:

    lpwInstanceName     -   Name of the instance to look for

  Return Value:

    TRUE if another instance is present, FALSE otherwise

--*/
BOOL
IsAnotherInstanceRunning(
    IN LPCWSTR lpwInstanceName
    )
{
    HANDLE  hMutex = NULL;
    DWORD   dwLastError = 0;

    //
    // Attempt to create a mutex with the given name
    //
    hMutex = CreateMutex(NULL, FALSE, lpwInstanceName);

    if (NULL != hMutex) {

        //
        // See if it was created by another instance
        //
        dwLastError = GetLastError();

        if (ERROR_ALREADY_EXISTS == dwLastError) {
            CloseHandle(hMutex);
            return TRUE;
        
        } else {

            CloseHandle(hMutex);
            return FALSE;
        }
    }

    return FALSE;
}

/*++

  Routine Description:

    Obtains the path that the EXE is currently
    running from. This memory is allocated
    with the MALLOC macro and should be released
    with the FREE macro
    
  Arguments:

    None
    
  Return Value:

    On success, a pointer to our current directory
    On failure, NULL
    The directory path will not contain a trailing
    backslash

--*/
LPWSTR 
GetCurWorkingDirectory()
{
    WCHAR   wszFullPath[MAX_PATH];
    LPWSTR  lpwEnd = NULL, lpwReturn = NULL;
    DWORD   dwLen = 0;    

    //
    // Retrieve the full path where we're running from
    //
    dwLen = GetModuleFileName(NULL, wszFullPath, MAX_PATH);

    if (dwLen <= 0) {
        return NULL;
    }

    //
    // Allocate memory and store the path
    //    
    lpwReturn = (LPWSTR) MALLOC((wcslen(wszFullPath)+1)*sizeof(WCHAR));

    if (NULL == lpwReturn) {
        return NULL;
    }

    wcscpy(lpwReturn, wszFullPath);

    //
    // Find the last backslash
    //
    lpwEnd = wcsrchr(lpwReturn, '\\');

    if (NULL == lpwEnd) {
        return NULL;
    }
    
    //
    // Trim off the EXE name
    //
    if (lpwEnd){
        *lpwEnd = '\0';
    }

    return (lpwReturn);
}

/*++

  Routine Description:

    Obtains a non-string value from the given
    INF file
    
  Arguments:

    hInf            -       Handle to the INF
    lpSectionName   -       Name of the section
    lpKeyName       -       Name of the key
    pdwValue        -       Receives the value

    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
GetInfValue(
    IN  HINF    hInf,
    IN  LPCSTR  lpSectionName,
    IN  LPCSTR  lpKeyName,
    OUT PDWORD  pdwValue
    )
{
    BOOL    fReturn = FALSE;
    char    szBuffer[MAX_PATH] = "";

    fReturn = SetupGetLineTextA(NULL,
                                hInf,
                                lpSectionName,
                                lpKeyName, 
                                szBuffer,
                                sizeof(szBuffer),
                                NULL);
    
    *pdwValue = strtoul(szBuffer, NULL, 0);

    return (fReturn);
}

/*++

  Routine Description:

    Determines if the user is an administrator

  Arguments:

    None
    
  Return Value:

    -1 on failure
    1 if the user is an admin
    0 if they are not

--*/
int 
IsUserAnAdministrator()
{
    HANDLE                      hToken;
    DWORD                       dwStatus = 0, dwAccessMask = 0;
    DWORD                       dwAccessDesired = 0, dwACLSize = 0;
    DWORD                       dwStructureSize = sizeof(PRIVILEGE_SET);
    PACL                        pACL = NULL;
    PSID                        psidAdmin = NULL;
    BOOL                        fReturn = FALSE;
    int                         nReturn = -1;
    PRIVILEGE_SET               ps;
    GENERIC_MAPPING             GenericMapping;
    PSECURITY_DESCRIPTOR        psdAdmin           = NULL;
    SID_IDENTIFIER_AUTHORITY    SystemSidAuthority = SECURITY_NT_AUTHORITY;

    __try {
    
        // AccessCheck() requires an impersonation token
        if (!ImpersonateSelf(SecurityImpersonation)) {
            __leave;
        }
    
        // Attempt to access the token for the current thread
        if (!OpenThreadToken(GetCurrentThread(),
                             TOKEN_QUERY,
                             FALSE,
                             &hToken)) {
            
            if (GetLastError() != ERROR_NO_TOKEN) {
                 __leave;
            }
        
            // If the thread does not have an access token, we'll 
            // examine the access token associated with the process.
            if (!OpenProcessToken(GetCurrentProcess(),
                                  TOKEN_QUERY,
                                  &hToken)) __leave;
            
        }
    
        // Build a SID for administrators group
        if (!AllocateAndInitializeSid(&SystemSidAuthority,
                                      2,
                                      SECURITY_BUILTIN_DOMAIN_RID,
                                      DOMAIN_ALIAS_RID_ADMINS,
                                      0, 0, 0, 0, 0, 0,
                                      &psidAdmin)) __leave;
        
        // Allocate memory for the security descriptor
        psdAdmin = MALLOC(SECURITY_DESCRIPTOR_MIN_LENGTH);

        if (psdAdmin == NULL) {
             __leave;
        }
        
        // Initialize the new security descriptor
        if (!InitializeSecurityDescriptor(psdAdmin,
                                          SECURITY_DESCRIPTOR_REVISION)) {
             __leave;
        }
        
        // Compute size needed for the ACL
        dwACLSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) +
                    GetLengthSid(psidAdmin) - sizeof(DWORD);
    
        // Allocate memory for ACL
        pACL = (PACL) MALLOC(dwACLSize);

        if (pACL == NULL) {
             __leave;
        }
        
        // Initialize the new ACL
        if (!InitializeAcl(pACL,
                           dwACLSize,
                           ACL_REVISION2)) {
             __leave;
        }
        
        dwAccessMask = ACCESS_READ | ACCESS_WRITE;
    
        // Add the access-allowed ACE to the DACL
        if (!AddAccessAllowedAce(pACL,
                                 ACL_REVISION2,
                                 dwAccessMask,
                                 psidAdmin)) {
             __leave;
        }
        
        // Set our DACL to the security descriptor
        if (!SetSecurityDescriptorDacl(psdAdmin,
                                       TRUE,
                                       pACL,
                                       FALSE)) {
             __leave;
        }
        
        // AccessCheck is sensitive about the format of the
        // security descriptor; set the group & owner
        SetSecurityDescriptorGroup(psdAdmin, psidAdmin, FALSE);
        SetSecurityDescriptorOwner(psdAdmin, psidAdmin, FALSE);
    
        // Ensure that the SD is valid
        if (!IsValidSecurityDescriptor(psdAdmin)) {
             __leave;
        }
        
        dwAccessDesired = ACCESS_READ;
    
        // Initialize GenericMapping structure even though we
        // won't be using generic rights.
        GenericMapping.GenericRead    = ACCESS_READ;
        GenericMapping.GenericWrite   = ACCESS_WRITE;
        GenericMapping.GenericExecute = 0;
        GenericMapping.GenericAll     = ACCESS_READ | ACCESS_WRITE;
    
        // After all that work, it boils down to this call
        if (!AccessCheck(psdAdmin,
                         hToken,
                         dwAccessDesired,
                         &GenericMapping,
                         &ps,
                         &dwStructureSize,
                         &dwStatus,
                         &fReturn)) {
            __leave;
        }
        
        RevertToSelf();

        // Everything was a success
        nReturn = (int) fReturn;

    } // try

    __finally {

        if (pACL) {
            FREE(pACL);
        }
        
        if (psdAdmin){
            FREE(psdAdmin);
        }
            
        if (psidAdmin){
            FreeSid(psidAdmin);
        }
        
    } // finally

    return (nReturn);
}

/*++

  Routine Description:

    Gets the amount of available disk space
    on the drive that contains the Windows
    system files (boot partition)

  Arguments:
    
    None

  Return Value:

    A 64-bit value containing the free space
    available on success, 0 on failure

--*/
DWORDLONG
GetDiskSpaceFreeOnNTDrive()
{
    UINT                nLen = 0;
    BOOL                fUseHeap = FALSE, fReturn = FALSE;
    WCHAR               wszSysDir[MAX_PATH] = L"";
    WCHAR               wszDiskName[4] = {'x',':','\\','\0'};
    LPWSTR              lpwSysDir = NULL;
    DWORDLONG           dwlReturn = 0;
    unsigned __int64    i64FreeBytesToCaller = 0,
                        i64TotalBytes = 0,
                        i64TotalFreeBytes = 0;

    nLen = GetSystemDirectory(wszSysDir, MAX_PATH);

    if (0 == nLen) {
        return 0;
    }

    if (nLen > MAX_PATH) {

        //
        // Allocate a buffer that will hold the return
        //
        lpwSysDir = (LPWSTR) MALLOC(nLen*sizeof(WCHAR));

        if (NULL == lpwSysDir) {
            return 0;
        }

        GetSystemDirectory(lpwSysDir, nLen*sizeof(WCHAR));

        fUseHeap = TRUE;
    }

    if (!fUseHeap) {
        
        wszDiskName[0] = wszSysDir[0];
    
    } else {

        wszDiskName[0] = lpwSysDir[0];
    }

    fReturn = GetDiskFreeSpaceEx(wszDiskName,
                                 (PULARGE_INTEGER) &i64FreeBytesToCaller,
                                 (PULARGE_INTEGER) &i64TotalBytes,
                                 (PULARGE_INTEGER) &i64TotalFreeBytes);

    if (FALSE == fReturn) {
        return 0;
    }

    //
    // Calculate free MBs on drive
    //
    dwlReturn = i64FreeBytesToCaller / 0x100000;

    if (lpwSysDir) {
        FREE(lpwSysDir);
    }

    return (dwlReturn);
}

/*++

  Routine Description:

    Displays a formated error to the screen

  Arguments:

    hWnd                -       Handle to the parent window
    dwMessageId         -       Message identifier
    lpwMessageArray     -       An array of insertion strings
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
DisplayErrMsg(
    IN HWND   hWnd,
    IN DWORD  dwMessageId, 
    IN LPWSTR lpwMessageArray
    )
{
    LPVOID  lpMsgBuf = NULL;
    DWORD   dwReturn = 0;
    int     nReturn = 0;
    WCHAR   wszError[MAX_PATH] = L"";

    dwReturn = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE |
                             FORMAT_MESSAGE_ARGUMENT_ARRAY |
                             FORMAT_MESSAGE_ALLOCATE_BUFFER,
                             g_si.hInstance,
                             dwMessageId,
                             MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                             (LPWSTR) &lpMsgBuf,
                             0,
                             (va_list*) lpwMessageArray);

    if (0 == dwReturn) {
        
        //
        // We can't let it go without displaying an error message
        // to the user
        //
        nReturn = LoadString(g_si.hInstance,
                             IDS_FORMAT_MESSAGE_FAILED,
                             wszError,
                             MAX_PATH);

        if (0 == nReturn) {

            //
            // Major problems - can't pull a string from the EXE
            //
            MessageBox(hWnd,
                       LOAD_STRING_FAILED,
                       g_si.lpwMessageBoxTitle,
                       MB_OK | MB_ICONERROR);

            return FALSE;
        }

        MessageBox(hWnd,
                   wszError,
                   g_si.lpwMessageBoxTitle,
                   MB_OK | MB_ICONERROR);

        return FALSE;
    }

    //
    // Display the intended message to the user
    //
    MessageBox(hWnd,
               (LPCWSTR) lpMsgBuf,
               g_si.lpwMessageBoxTitle,
               MB_OK | MB_ICONERROR);

    LocalFree(lpMsgBuf);
            
    return TRUE;
}

/*++

Routine Description:

    Given a version string, convert it to a long DWORD. This string will
    be in the form of aa,bb,cc,dd

Arguments:

    lpwVersionString    -   The string to convert
    lpVersionNumber     -   Receives the converted version

Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
VersionStringToNumber(
    IN LPCWSTR        lpwVersionString,
    IN OUT DWORDLONG *lpVersionNumber
    )
{
    DWORDLONG       dwVersion = 0;
    DWORD           dwSubVersion;
    int             nIndex;

    for (nIndex = 0; nIndex < 4; nIndex++) {

        if (*lpwVersionString == '\0') {
            return FALSE;            
        }

        dwSubVersion = 0;

        while ((*lpwVersionString >= '0') && (*lpwVersionString <= '9')) {

            dwSubVersion *= 10;
            dwSubVersion += ( *lpwVersionString - '0' );

            if (dwSubVersion > 0x0000FFFF) {
                return FALSE;
                
            }

            lpwVersionString++;            
        }

        if (*lpwVersionString == ',') {
            lpwVersionString++;
            
        } else if (*lpwVersionString != '\0') {
            return FALSE;            
        }

        dwVersion <<= 16;
        dwVersion += dwSubVersion;
        
    }

    if (lpVersionNumber != NULL) {
        *lpVersionNumber = dwVersion;        
    }

    return TRUE;
}

/*++

  Routine Description:

    Converts a UNICODE string to an ANSI one 

  Arguments:

    lpwUnicodeString    -   The UNICODE string
    lpAnsiString        -   Receives the ANSI string
    nLen                -   The size of the ANSI buffer

  Return Value:

    None

--*/
void
pUnicodeToAnsi(
    IN     LPCWSTR lpwUnicodeString,
    IN OUT LPSTR   lpAnsiString,
    IN     int     nLen
    )
{
    WideCharToMultiByte(CP_ACP,
                        0,
                        lpwUnicodeString,
                        -1,
                        lpAnsiString,
                        nLen,
                        NULL,
                        NULL);
    return;
}

/*++

  Routine Description:

    Converts an ANSI string to a UNICODE one 

  Arguments:
    
    lpAnsiString        -   The ANSI string
    lpwUnicodeString    -   Receives the UNICODE string
    nLen                -   The size of the UNICODE buffer

  Return Value:

    None

--*/
void
pAnsiToUnicode(
    IN     LPCSTR lpAnsiString,
    IN OUT LPWSTR lpwUnicodeString,
    IN     int     nLen
    )
{

    MultiByteToWideChar(CP_ACP,
                        0,
                        lpAnsiString,
                        -1,
                        lpwUnicodeString,
                        nLen);
    return;
}

/*++

  Routine Description:

    Initializes frequently used strings,
    paths, etc. 

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
WUInitialize()
{
    BOOL            fReturn = FALSE;
    int             nReturn = 0;
    LPWSTR          lpwCurrentDirectory = NULL;
    char            szTemp[MAX_PATH] = "";
    WCHAR           wszTemp[MAX_PATH] = L"";
    WCHAR           wszInstInfFileName[MAX_PATH] = L"";
    char            szInstInfFileName[MAX_PATH] = "";
    WCHAR           wszUninstInfFileName[MAX_PATH] = L"";
    char            szUninstInfFileName[MAX_PATH] = "";
    char            szMessageBoxTitle[MAX_PATH] = "";
    WCHAR           wszMessageBoxTitle[MAX_PATH] = L"";
    char            szComponentName[MAX_PATH] = "";
    WCHAR           wszComponentName[MAX_PATH] = L"";
    char            szEventLogSourceName[MAX_PATH] = "";
    WCHAR           wszEventLogSourceName[MAX_PATH] = L"";
    char            szDestDir[MAX_PATH] = "";
    WCHAR           wszDestDir[MAX_PATH] = L"";
    char            szUninstallDir[MAX_PATH] = "";
    WCHAR           wszUninstallDir[MAX_PATH] = L"";
    WCHAR           wszSysDir[MAX_PATH] = L"";
    WCHAR           wszWinDir[MAX_PATH] = L"";
    UINT            uDirLen = 0;
    DWORD           dwNoReboot = 0, dwNoUninstall = 0, dwQuiet = 0;
    DWORD           dwAdjustACL = 0, dwUpdateDllCache = 0;
    DWORDLONG       dwlFreeSpace = 0;
    OSVERSIONINFOEX osviex;
    
    //
    // Perform a version check - Windows 2000 or greater
    //
    ZeroMemory(&osviex, sizeof(OSVERSIONINFOEX));
    osviex.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    GetVersionEx((OSVERSIONINFO *) &osviex);
    
    if ((osviex.dwPlatformId == VER_PLATFORM_WIN32_NT) && 
        (osviex.dwMajorVersion == 5) &&
        (osviex.dwMinorVersion == 0)) {

        g_si.fOnWin2K = TRUE;

    } else if ((osviex.dwPlatformId != VER_PLATFORM_WIN32_NT) &&
               (osviex.dwMajorVersion < 5)) {
        return FALSE;
    }

    //
    // Determine where we're running from and save it
    //
    lpwCurrentDirectory = GetCurWorkingDirectory();

    if (NULL == lpwCurrentDirectory) {
        return FALSE;
    }

    g_si.lpwExtractPath = (LPWSTR) MALLOC((wcslen(lpwCurrentDirectory)+1)*sizeof(WCHAR));

    if (NULL == g_si.lpwExtractPath) {
        return FALSE;
    }

    wcscpy(g_si.lpwExtractPath, lpwCurrentDirectory);

    //
    // Set up the path to the install INF, make it ANSI, and save it
    //
    wsprintf(wszInstInfFileName, L"%s\\%s", lpwCurrentDirectory, INF_FILE_NAMEW);
    pUnicodeToAnsi(wszInstInfFileName, szInstInfFileName, MAX_PATH);
    
    g_si.lpwInstallINFPath = (LPWSTR) MALLOC((wcslen(wszInstInfFileName)+1)*sizeof(WCHAR));

    if (NULL == g_si.lpwInstallINFPath) {
        return FALSE;
    }

    wcscpy(g_si.lpwInstallINFPath, wszInstInfFileName);

    //
    // Set up the path to the uninstall INF, make it ANSI, and save it
    //
    wsprintf(wszUninstInfFileName, L"%s\\%s", lpwCurrentDirectory, UNINST_INF_FILE_NAMEW);
    pUnicodeToAnsi(wszUninstInfFileName, szUninstInfFileName, MAX_PATH);
    FREE(lpwCurrentDirectory);

    g_si.lpwUninstallINFPath = (LPWSTR) MALLOC((wcslen(wszUninstInfFileName)+1)*sizeof(WCHAR));

    if (NULL == g_si.lpwUninstallINFPath) {
        return FALSE;
    }

    wcscpy(g_si.lpwUninstallINFPath, wszUninstInfFileName);

    //
    // We need to grab some strings from the INF
    //
    g_si.hInf = SetupOpenInfFileA(g_si.fInstall ? szInstInfFileName : szUninstInfFileName,
                                  NULL,
                                  INF_STYLE_WIN4,
                                  NULL);

    if ((NULL == g_si.hInf) || (INVALID_HANDLE_VALUE == g_si.hInf)) {
        Print(ERROR, L"[WUInitialize] Failed to open INF\n");
        return FALSE;
    }

    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "MessageBoxTitle",
                                szMessageBoxTitle,
                                sizeof(szMessageBoxTitle),
                                NULL);

    if (!fReturn) {
        return FALSE;
    }

    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "ComponentName",
                                szComponentName,
                                sizeof(szComponentName),
                                NULL);

    if (!fReturn) {
        return FALSE;
    }

    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "EventLogSourceName",
                                szEventLogSourceName,
                                sizeof(szEventLogSourceName),
                                NULL);

    if (!fReturn) {
        return FALSE;
    }

    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "DestDir",
                                szTemp,
                                sizeof(szTemp),
                                NULL);

    if (!fReturn) {
        return FALSE;
    }    

    fReturn = SetupGetLineTextA(NULL,
                                g_si.hInf,
                                "Strings",
                                "UninstallDirName",
                                szUninstallDir,
                                sizeof(szUninstallDir),
                                NULL);

    if (!fReturn) {
        return FALSE;
    }

    if (g_si.fInstall) {

        fReturn = GetInfValue(g_si.hInf, 
                              "Version",
                              "RequiredFreeSpaceNoUninstall",
                              &g_si.dwRequiredFreeSpaceNoUninstall);

        if (!fReturn) {
            return FALSE;
        }

        fReturn = GetInfValue(g_si.hInf,
                              "Version",
                              "RequiredFreeSpaceWithUninstall",
                              &g_si.dwRequiredFreeSpaceWithUninstall);

        if (!fReturn) {
            return FALSE;
        }
        
        GetInfValue(g_si.hInf, "Version", "NoReboot", &dwNoReboot);
        GetInfValue(g_si.hInf, "Version", "NoUninstall", &dwNoUninstall);    
        GetInfValue(g_si.hInf, "Version", "AdjustACLOnTargetDir", &dwAdjustACL);
        GetInfValue(g_si.hInf, "Version", "UpdateDllCache", &dwUpdateDllCache);
    }

    GetInfValue(g_si.hInf, "Version", "RunQuietly", &dwQuiet);

    if (dwNoReboot) {
        g_si.fNoReboot = TRUE;
    }

    if (dwNoUninstall) {
        g_si.fNoUninstall = TRUE;
    }
    
    if (dwQuiet) {
        g_si.fQuiet = TRUE;
    }

    if (dwAdjustACL) {
        g_si.fNeedToAdjustACL = TRUE;
    }

    if (!dwUpdateDllCache) {
        g_si.fUpdateDllCache = FALSE;
    }

    //
    // Expand the directory string
    //
    pAnsiToUnicode(szTemp, wszTemp, MAX_PATH);
    ExpandEnvironmentStrings(wszTemp, wszDestDir, MAX_PATH);

    //
    // Save the strings for later use
    //
    pAnsiToUnicode(szMessageBoxTitle, wszMessageBoxTitle, MAX_PATH);
    pAnsiToUnicode(szComponentName, wszComponentName, MAX_PATH);
    pAnsiToUnicode(szEventLogSourceName, wszEventLogSourceName, MAX_PATH);
    pAnsiToUnicode(szUninstallDir, wszUninstallDir, MAX_PATH);

    uDirLen = GetSystemDirectory(wszSysDir, MAX_PATH);

    if (0 == uDirLen) {
        return FALSE;
    }

    uDirLen = GetWindowsDirectory(wszWinDir, MAX_PATH);

    if (0 == uDirLen) {
        return FALSE;
    }

    g_si.lpwMessageBoxTitle    = (LPWSTR) MALLOC((wcslen(wszMessageBoxTitle)+1)*sizeof(WCHAR));
    g_si.lpwPrettyAppName      = (LPWSTR) MALLOC((wcslen(wszComponentName)+1)*sizeof(WCHAR));
    g_si.lpwEventLogSourceName = (LPWSTR) MALLOC((wcslen(wszEventLogSourceName)+1)*sizeof(WCHAR));
    g_si.lpwInstallDirectory   = (LPWSTR) MALLOC((wcslen(wszDestDir)+1)*sizeof(WCHAR));
    g_si.lpwUninstallDirectory = (LPWSTR) MALLOC((wcslen(wszUninstallDir)+1)*sizeof(WCHAR));
    g_si.lpwSystem32Directory  = (LPWSTR) MALLOC((wcslen(wszSysDir)+1)*sizeof(WCHAR));
    g_si.lpwWindowsDirectory   = (LPWSTR) MALLOC((wcslen(wszWinDir)+1)*sizeof(WCHAR));

    if ((NULL == g_si.lpwMessageBoxTitle) || (NULL == g_si.lpwPrettyAppName) ||
       (NULL == g_si.lpwEventLogSourceName) || (NULL == g_si.lpwInstallDirectory) ||
       (NULL == g_si.lpwUninstallDirectory) || (NULL == g_si.lpwSystem32Directory) ||
       (NULL == g_si.lpwWindowsDirectory)) {
       return FALSE;
    }

    wcscpy(g_si.lpwMessageBoxTitle, wszMessageBoxTitle);
    wcscpy(g_si.lpwPrettyAppName, wszComponentName);
    wcscpy(g_si.lpwEventLogSourceName, wszEventLogSourceName);
    wcscpy(g_si.lpwInstallDirectory, wszDestDir);
    wcscpy(g_si.lpwUninstallDirectory, wszUninstallDir);
    wcscpy(g_si.lpwSystem32Directory, wszSysDir);
    wcscpy(g_si.lpwWindowsDirectory, wszWinDir);

    //
    // Ensure that the user has administrator rights
    //
    nReturn = IsUserAnAdministrator();

    if (0 == nReturn) {

        //
        // The user is not an admin
        //
        LogEventDisplayError(EVENTLOG_ERROR_TYPE,
                             ID_NOT_ADMIN,
                             TRUE,
                             FALSE);

        return FALSE;
    
    } else if (-1 == nReturn) {

        //
        // The access check failed. Assume that problems occured
        // during the check and continue. The worst thing that will
        // happen is the user will see an error later on
        //
        LogEventDisplayError(EVENTLOG_WARNING_TYPE,
                             ID_ADMIN_CHECK_FAILED,
                             FALSE,
                             FALSE);

        return FALSE;
    }
    
    //
    // Verify that we have enough disk space for the install
    //
    if (g_si.fInstall) {
        
        dwlFreeSpace = GetDiskSpaceFreeOnNTDrive();

        if (dwlFreeSpace < g_si.dwRequiredFreeSpaceNoUninstall) {

            //
            // Not enough space available to complete
            //
            LogEventDisplayError(EVENTLOG_WARNING_TYPE,
                                 ID_NOT_ENOUGH_DISK_SPACE,
                                 TRUE,
                                 FALSE);

            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Releases any memory used throughout the app

  Arguments:

    None

  Return Value:

    None

--*/
void
WUCleanup()
{
    if (NULL != g_si.lpwEventLogSourceName) {
        FREE(g_si.lpwEventLogSourceName);
    }

    if (NULL != g_si.lpwExtractPath) {
        FREE(g_si.lpwExtractPath);
    }

    if (NULL != g_si.lpwInstallDirectory) {
        FREE(g_si.lpwInstallDirectory);
    }

    if (NULL != g_si.lpwInstallINFPath) {
        FREE(g_si.lpwInstallINFPath);
    }

    if (NULL != g_si.lpwUninstallINFPath) {
        FREE(g_si.lpwUninstallINFPath);
    }

    if (NULL != g_si.lpwMessageBoxTitle) {
        FREE(g_si.lpwMessageBoxTitle);
    }

    if (NULL != g_si.lpwPrettyAppName) {
        FREE(g_si.lpwPrettyAppName);
    }

    if (NULL != g_si.lpwSystem32Directory) {
        FREE(g_si.lpwSystem32Directory);
    }

    if (NULL != g_si.lpwUninstallDirectory) {
        FREE(g_si.lpwUninstallDirectory);
    }

    if (NULL != g_si.lpwWindowsDirectory) {
        FREE(g_si.lpwWindowsDirectory);
    }

    if (NULL != g_si.hInf) {
        SetupCloseInfFile(g_si.hInf);
    }

    return;
}

/*++

  Routine Description:

    Takes the DACL from a given directory and
    applies it to another directory

  Arguments:

    lpwSourceDir    -   The directory to get the DACL from
    lpwDestDir      -   The directory to apply the DACL to

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
MirrorDirectoryPerms(
    IN LPWSTR lpwSourceDir,
    IN LPWSTR lpwDestDir
    )
{
    DWORD                   dwResult = 0;
    BOOL                    fResult = FALSE;
    PACL                    pDACL = NULL;    
    PSECURITY_DESCRIPTOR    pSD = NULL;
    PSID                    pOwnerSid;

    __try {

        //
        // Get the DACL from the source directory
        // 
        dwResult = GetNamedSecurityInfo(lpwSourceDir,
                                        SE_FILE_OBJECT,
                                        DACL_SECURITY_INFORMATION |
                                        OWNER_SECURITY_INFORMATION,
                                        &pOwnerSid,
                                        NULL,
                                        &pDACL,
                                        NULL,
                                        &pSD);
        
        if (ERROR_SUCCESS != dwResult) {
            __leave;
        }

        //
        // Attach the DACL to the destination directory
        //
        dwResult = SetNamedSecurityInfo(lpwDestDir,
                                        SE_FILE_OBJECT,
                                        DACL_SECURITY_INFORMATION |
                                        OWNER_SECURITY_INFORMATION,
                                        pOwnerSid,
                                        NULL,
                                        pDACL,
                                        NULL);
        
        if (ERROR_SUCCESS != dwResult) {
            __leave;
        }

        fResult = TRUE;
    
    } //try

    __finally {

        if (NULL != pSD) {
            LocalFree((HLOCAL) pSD);
        }
    
    } //finally

    return (fResult);
}

/*++

  Routine Description:

    Adjusts permissions on the given directory

  Arguments:

    lpwDirPath      -       Directory to modify

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
AdjustDirectoryPerms(
    IN LPWSTR lpwDirPath
    )
{
    DWORD                       dwResult = 0;
    PSID                        pSid = NULL;
    BOOL                        fReturn = FALSE, fResult = FALSE;
    PACL                        pOldDACL = NULL, pNewDACL = NULL;    
    EXPLICIT_ACCESS             ea;
    PSECURITY_DESCRIPTOR        pSD = NULL;
    SID_IDENTIFIER_AUTHORITY    sia =  SECURITY_NT_AUTHORITY;

    __try {

        //
        // Get the DACL for the directory
        // 
        dwResult = GetNamedSecurityInfo(lpwDirPath,
                                        SE_FILE_OBJECT,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        &pOldDACL,
                                        NULL,
                                        &pSD);
        
        if (ERROR_SUCCESS != dwResult) {
            __leave;
        }
        
        //
        // Build a SID to the local Users group
        //
        fReturn = AllocateAndInitializeSid(&sia, 2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_USERS, 0, 0, 0, 0, 0, 0,
                     &pSid);

        if (!fReturn) {
            __leave;
        }

        //
        // Ensure that the SID is valid
        //
        fReturn = IsValidSid(pSid);

        if (!fReturn) { 
            __leave;
        }
        
        //
        // Initialize an EXPLICIT_ACCESS structure for the new ACE
        //
        ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));
    
        ea.grfAccessPermissions     = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE;
        ea.grfAccessMode            = GRANT_ACCESS;
        ea.grfInheritance           = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ea.Trustee.TrusteeForm      = TRUSTEE_IS_SID;
        ea.Trustee.ptstrName        = (LPTSTR) pSid;
    
        //
        // Create a new ACL that merges the new ACE
        // into the existing DACL
        //
        dwResult = SetEntriesInAcl(1, &ea, pOldDACL, &pNewDACL);
    
        if (ERROR_SUCCESS != dwResult) {
            __leave;
        }
                
        //
        // Attach the new ACL as the object's DACL
        //
        dwResult = SetNamedSecurityInfo(lpwDirPath,
                                        SE_FILE_OBJECT,
                                        DACL_SECURITY_INFORMATION,
                                        NULL,
                                        NULL,
                                        pNewDACL,
                                        NULL);
        
        if (ERROR_SUCCESS != dwResult) {
            __leave;
        }

        // Everything was a success
        fResult = TRUE;
    
    } // try

    __finally {

        if (NULL != pSD) {
            LocalFree((HLOCAL) pSD);
        }

        if (NULL != pNewDACL) {
            LocalFree((HLOCAL) pNewDACL);
        }

        if (NULL != pSid) {
            FreeSid(pSid);
        }
    
    } //finally
        
    return (fResult);
}

/*++

  Routine Description:

    Retrieves version information from a catalog file
    
  Arguments:

    lpwCatName      -       The catalog file to check
    
  Return Value:

    A DWORD which contains a version number for the catalog

--*/
DWORD 
GetCatVersion(
    IN LPWSTR lpwCatName
    )
{
    char                szVersionString[MAX_PATH] = "";
    HANDLE              hCat = NULL;
    DWORD               dwVer = 0;
    CRYPTCATATTRIBUTE   *pSpCatAttr = NULL;
    NTSTATUS            Status;

    __try {
    
        hCat = CryptCATOpen(lpwCatName, 0, 0, 0, 0);

        if (NULL == hCat) {
            __leave;
        }
    
        pSpCatAttr = CryptCATGetCatAttrInfo(hCat, L"SPAttr");
    
        if ((pSpCatAttr == NULL) || (pSpCatAttr->pbValue == NULL)) {
            __leave;
        }
    
        pUnicodeToAnsi((LPWSTR)pSpCatAttr->pbValue, szVersionString, MAX_PATH);
        
        Status = RtlCharToInteger(szVersionString, 10, (PULONG)&dwVer);
        
        if (!NT_SUCCESS(Status)) { 
            __leave;   
        }

    } // try

    __finally {

        if (hCat) {
            CryptCATClose(hCat);
        }
    
    } // finally

    return (dwVer);
}

/*++

  Routine Description:

    Wraps CreateProcess and WaitForSingleObject

  Arguments:

    lpwCommandLine  -   Command line to execute
    pdwReturnCode   -   Receives a return code from the process
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
LaunchProcessAndWait(
    IN  LPCWSTR lpwCommandLine,
    OUT PDWORD  pdwReturnCode
    )
{
    PROCESS_INFORMATION     pi;
    STARTUPINFO             si;
    BOOL                    fReturn = FALSE;
    LPWSTR                  lpwCmdLine = NULL;

    //
    // CreateProcess requires a non-const command line
    //
    lpwCmdLine = (LPWSTR) MALLOC((wcslen(lpwCommandLine)+1)*sizeof(WCHAR));

    if (NULL == lpwCmdLine) {
        return FALSE;
    }

    wcscpy(lpwCmdLine, lpwCommandLine);

    ZeroMemory(&si, sizeof(si));

    si.cb           =   sizeof(si);
    si.dwFlags      =   STARTF_USESHOWWINDOW;
    si.wShowWindow  =   SW_HIDE;

    fReturn = CreateProcess(NULL,
                            lpwCmdLine,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &si,
                            &pi);

    if (!fReturn) {
        return FALSE;
    }

    WaitForSingleObject(pi.hProcess, INFINITE);

    if (NULL != pdwReturnCode) {
        GetExitCodeProcess(pi.hProcess, pdwReturnCode);
    }

    if (NULL != lpwCmdLine) {
        FREE(lpwCmdLine);
    }

    CloseHandle(pi.hProcess);
    CloseHandle(pi.hThread);

    return TRUE;
}

/*++

  Routine Description:

    Callback function for our directory enumeration routine

  Arguments:

    lpwPath                 -       Path of the directory or filename
    pFindFileData           -       Pointer to WIN32_FIND_DATA struct
                                    containing information about lpwPath
    pEnumerateParameter     -       A 32-bit enumeration parameter

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
DeleteOneFile(
    IN LPCWSTR          lpwPath,
    IN PWIN32_FIND_DATA pFindFileData,
    IN PVOID            pEnumerateParameter
    )
{
    WCHAR       wszTempPath[MAX_PATH] = L"";
    char        szFileName[MAX_PATH] = "";
    WCHAR       wszFileName[MAX_PATH] = L"";
    char        szEntry[MAX_QUEUE_SIZE] = "";
    WCHAR       wszEntry[MAX_QUEUE_SIZE] = L"";
    WCHAR       wszTestPath[MAX_PATH] = L"";
    BOOL        fCheckQueue = FALSE, fReturn = FALSE, fDelete = TRUE;
    LPWSTR      lpwDestDir = NULL;
    int         nLen = 0;
    LONG        cLines = 0;
    INFCONTEXT  InfContext;

    if (pFindFileData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
        return TRUE;
    }

    //
    // Note: This may seem a little complex, but because there could
    // multiple entries in a section, we have to run through them
    // each time this function gets called.
    //

    //
    // See if there's anything in the exclusion queue
    //
    fCheckQueue = (BOOL) pEnumerateParameter;
        
    if (fCheckQueue) {

        nLen = g_si.ExclusionQueue.GetSize();

        while (nLen != 0) {

            //
            // Walk through the queue and make sure
            // we don't delete files we shouldn't
            //
            g_si.ExclusionQueue.Dequeue(wszEntry, MAX_QUEUE_SIZE - 1, TRUE);

            pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);

            //
            // Get the destination directory
            //
            GetNextToken(wszEntry, L".");
            lpwDestDir = GetNextToken(NULL, L".");
    
            if (NULL == lpwDestDir) {
                return FALSE;
            }

            //
            // Get the number of files in the section
            //
            cLines = SetupGetLineCountA(g_si.hInf, szEntry);

            //
            // Loop through all the lines in the exclusion section(s),
            // and do a comparison
            //
            fReturn = SetupFindFirstLineA(g_si.hInf, szEntry, NULL,
                                          &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szFileName, MAX_PATH, NULL);
    
            while (fReturn) {

                while (cLines != 0) {
    
                    pAnsiToUnicode(szFileName, wszFileName, MAX_PATH);

                    //
                    // Put the path together
                    //
                    wsprintf(wszTestPath, L"%s\\%s", lpwDestDir, wszFileName);
                    wcscpy(wszTempPath, lpwPath);
                    CharLower(wszTestPath);                    
                    CharLower(wszTempPath);

                    //
                    // See if the paths match
                    //
                    if (wcsstr(wszTempPath, wszTestPath)) {
                        
                        fDelete = FALSE;
                        break;  // paths match, move to the next file
                    }

                    SetupFindNextLine(&InfContext, &InfContext);
                    SetupGetLineTextA(&InfContext,
                                      NULL, NULL, NULL,
                                      szFileName, MAX_PATH, NULL);

                    --cLines;
                }

                if (fDelete) {
                    ForceDelete(lpwPath);                    
                    fDelete = TRUE;  // reset the flag
                }                
            
                fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                          SetupGetLineTextA(&InfContext,
                                            NULL, NULL, NULL,
                                            szFileName, MAX_PATH, NULL);
            }

            nLen--;
        }
    
    } else {

        //
        // Don't worry about the queue, delete the file
        //
        ForceDelete(lpwPath);
    }

    return TRUE;
}



/*++

  Routine Description:

    Retrieves a token, given a separator.
    Basically a wrapper for strtok 

  Arguments:

    lpwSourceString     -   The source string to parse
    lpwSeparator        -   The separator string that specifies
                            the delimiter

  Return Value:

    A pointer to the return string

--*/
LPWSTR
GetNextToken(
    IN LPWSTR lpwSourceString,
    IN LPCWSTR lpwSeparator
    )
{
    LPWSTR  lpwReturn = NULL;

    lpwReturn = wcstok(lpwSourceString, lpwSeparator);

    return (lpwReturn);
}

/*++

  Routine Description:

    Attempts to move a file.
    If it's in use, replace it on reboot

  Arguments:

    lpwSourceFileName     -       The source file name
    lpwDestFileName       -       The destination file name
        
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
ForceMove(
    IN LPCWSTR lpwSourceFileName,
    IN LPCWSTR lpwDestFileName
    )
{
    WCHAR   wszTempPath[MAX_PATH] = L"";
    WCHAR   wszDelFileName[MAX_PATH] = L"";    

    if (!lpwSourceFileName || !lpwDestFileName) {
        return FALSE;
    }

    if (!MoveFileEx(lpwSourceFileName,
                    lpwDestFileName,
                    MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {

        Print(TRACE,
              L"[ForceMove] First call to MoveFileEx failed. GLE = %d\n",
              GetLastError());
        
        if (!GetTempPath(MAX_PATH, wszTempPath)) {
            return FALSE;
        }
        
        if (!GetTempFileName(wszTempPath, L"DEL", 0, wszDelFileName)) {
            return FALSE;
        }

        if (!MoveFileEx(lpwDestFileName,
                        wszDelFileName,
                        MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {

            Print(ERROR,
                  L"[ForceMove] Second call to MoveFileEx failed. GLE = %d\n",
                  GetLastError());
            return FALSE;
        }
        
        if (!MoveFileEx(wszDelFileName,
                        NULL,
                        MOVEFILE_DELAY_UNTIL_REBOOT)) {

            Print(ERROR,
                  L"[ForceMove] Third call to MoveFileEx failed. GLE = %d\n",
                  GetLastError());
            return FALSE;
        }

        if (!MoveFileEx(lpwSourceFileName,
                        lpwDestFileName,
                        MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {

            Print(ERROR,
                  L"[ForceMove] Second call to MoveFileEx failed. GLE = %d\n",
                  GetLastError());
            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Attempts to delete a file.
    If it's in use, delete it on reboot

  Arguments:

    lpwFileName     -       The file name to delete
        
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
ForceDelete(
    IN LPCWSTR lpwFileName
    )
{
    WCHAR   *pTempFile = NULL;
    WCHAR   *pExt = NULL;

    //
    // Attempt to delete the specified file
    //
    SetFileAttributes(lpwFileName, FILE_ATTRIBUTE_NORMAL);

    if (!DeleteFile(lpwFileName)) {

        //
        // The file is most likely in use
        // Attempt to rename it
        //

        pTempFile = _wcsdup(lpwFileName);

        pExt = PathFindExtension(pTempFile);

        if (pExt) {
            wcscpy(pExt, L"._wu");
        }

        if (MoveFile(lpwFileName, pTempFile)) {
            
            //
            // We renamed the target - delete it on reboot
            //
            MoveFileEx(pTempFile, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        
        } else {

            //
            // Couldn't rename it - mark it for deletion on reboot
            //
            MoveFileEx(lpwFileName, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
        }

        free(pTempFile);
    }

    return TRUE;
}

/*++

  Routine Description:

    Attempts to copy a file
    If it's in use, move it and replace on reboot

  Arguments:

    lpwSourceFileName     -       The source file name
    lpwDestFileName       -       The destination file name
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
ForceCopy(
    IN LPCWSTR lpwSourceFileName,
    IN LPCWSTR lpwDestFileName
    )
{
    WCHAR   wszTempPath[MAX_PATH] = L"";
    WCHAR   wszDelFileName[MAX_PATH] = L"";

    if (!lpwSourceFileName || !lpwDestFileName) {
        return FALSE;
    }

    if (!CopyFile(lpwSourceFileName, lpwDestFileName, FALSE)) {
        
        if (!GetTempPath(MAX_PATH, wszTempPath)) {
            return FALSE;
        }
            
        if (!GetTempFileName(wszTempPath, L"DEL", 0, wszDelFileName)) {
            return FALSE;
        }
            
        if (!MoveFileEx(lpwDestFileName,
                        wszDelFileName,
                        MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {
            return FALSE;
        }
            
        if (!MoveFileEx(wszDelFileName,
                        NULL,
                        MOVEFILE_COPY_ALLOWED | MOVEFILE_DELAY_UNTIL_REBOOT)) {
            return FALSE;
        }
            
        if (!CopyFile(lpwSourceFileName, lpwDestFileName, FALSE)) {
            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Routine Description:

	Determines if a file is protected by WFP

  Arguments:

	lpwFileName     -       Name of the file

  Return Value:

	TRUE if the file is protected, FALSE otherwise

--*/
BOOL
IsFileProtected(
    IN LPCWSTR lpwFileName
    )
{
    BOOL    fReturn = FALSE;

    if (lpwFileName == NULL) {
        return FALSE;
    }

    return (SfcIsFileProtected(NULL, lpwFileName));
}

/*++

Routine Description:

    Retrieve file version and language info from a file

    The version is specified in the dwFileVersionMS and dwFileVersionLS fields
    of a VS_FIXEDFILEINFO, as filled in by the win32 version APIs. For the
    language we look at the translation table in the version resources and assume
    that the first langid/codepage pair specifies the language

    If the file is not a coff image or does not have version resources,
    the function fails. The function does not fail if we are able to retrieve
    the version but not the language

Arguments:

    lpwFileName     -   Supplies the full path of the file
                        whose version data is desired

    pdwVersion      -   Receives the version stamp of the file.
                        If the file is not a coff image or does not contain
                        the appropriate version resource data, the function fails

Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
GetVersionInfoFromImage(
    IN LPCWSTR     lpwFileName,
    OUT PDWORDLONG pdwVersion
    )
{
    DWORD   nSize = 0L, dwIgnored = 0L;
    UINT    nDataLength = 0;
    BOOL    fResult = FALSE;
    PVOID   pVersionBlock = NULL;
    VS_FIXEDFILEINFO *FixedVersionInfo;

    //
    // Get the size of version info block
    //
    nSize = GetFileVersionInfoSize((LPWSTR)lpwFileName, &dwIgnored);

    if (nSize) {
        
        //
        // Allocate memory block of sufficient size to hold version info block
        //
        pVersionBlock = MALLOC(nSize*sizeof(WCHAR));
        
        if (pVersionBlock) {

            //
            // Get the version block from the file.
            //
            if (GetFileVersionInfo((LPWSTR)lpwFileName,
                                    0,
                                    nSize*sizeof(WCHAR),
                                    pVersionBlock)) {
                
                //
                // Get fixed version info
                //
                if (VerQueryValue(pVersionBlock,
                                  L"\\",
                                  (LPVOID*) &FixedVersionInfo,
                                   &nDataLength)) {

                    //
                    // Return version to caller
                    //
                    *pdwVersion = (((DWORDLONG)FixedVersionInfo->dwFileVersionMS) << 32)
                             + FixedVersionInfo->dwFileVersionLS;

                    fResult = TRUE;
                    
                }
                
            }

            FREE(pVersionBlock);
        }
    }

    return (fResult);
}

/*++

  Routine Description:

    Copies the specified file giving it a temporary name

  Arguments:

    lpwFileName     -   The full path & name of the file
    
  Return Value:

    A pointer to the full path & name of the file
    The caller is responsible for freeing the memory

--*/
LPWSTR
CopyTempFile(
    IN LPCWSTR lpwSrcFileName,
    IN LPCWSTR lpwDestDir
    )
{
    LPWSTR  lpwTempFileName = NULL;

    lpwTempFileName = (LPWSTR) MALLOC(MAX_PATH * sizeof(WCHAR));

    if (NULL == lpwTempFileName) {
        return NULL;
    }

    if (!GetTempFileName(lpwDestDir, L"_wu", 0, lpwTempFileName)) {        
        FREE(lpwTempFileName);
        return NULL;
    
    } else {

        //
        // Copy the source file down to the destination directory
        // using the name we just got
        //
        if (!CopyFile(lpwSrcFileName, lpwTempFileName, FALSE)) {            
            FREE(lpwTempFileName);
            return NULL;
        }
    }

    return (lpwTempFileName);    
}

/*++

  Routine Description:

    Prints formatted debug strings

  Arguments:

    uLevel      -   A flag to indicate if the message should be displayed
    
    lpwFmt      -   A string to be displayed
    
    ...         -   A variable length argument list of insertion strings
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
#if DBG
void Print(
    IN UINT   uLevel,
    IN LPWSTR lpwFmt,
    IN ...
    )
{
    va_list arglist;
    
    if (g_si.nErrorLevel < uLevel) {
        return;
    }

    va_start(arglist, lpwFmt);

    _vsnwprintf(g_si.wszDebugOut, 2047, lpwFmt, arglist);

    g_si.wszDebugOut[2047] = 0;

    va_end(arglist);

    OutputDebugString(g_si.wszDebugOut);

    return;
}
#endif

/*++

  Routine Description:

    Reboots the system

  Arguments:

    fForceClose     -       A flag to indicate if apps should be forced
                            to close
                            
    fReboot         -       A flag to indicate if we should reboot
                            after shutdown                       
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
ShutdownSystem(
    IN BOOL fForceClose,
    IN BOOL fReboot
    )
{
    BOOL    fResult = FALSE;

    if (!ModifyTokenPrivilege(L"SeShutdownPrivilege", TRUE)) {
        return FALSE;
    }

    fResult = InitiateSystemShutdown(NULL,              // machinename
                                     NULL,              // shutdown message
                                     0,                 // delay
                                     fForceClose,       // force apps close
                                     fReboot            // reboot after shutdown
                                     );

    ModifyTokenPrivilege(L"SeShutdownPrivilege", FALSE);

    return (fResult);
}

/*++

  Routine Description:

    Enables or disables a specified privilege

  Arguments:

    lpwPrivilege    -   The name of the privilege
    
    fEnable         -   A flag to indicate if the
                        privilege should be enabled
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL 
ModifyTokenPrivilege(
    IN LPCWSTR lpwPrivilege,
    IN BOOL    fEnable
    )
{
    HANDLE           hToken = NULL;
    LUID             luid;
    BOOL             fResult = FALSE;
    TOKEN_PRIVILEGES tp;

    if (NULL == lpwPrivilege) {
        return FALSE;
    }

    __try {
    
        //
        // Get a handle to the access token associated with the current process
        //
        OpenProcessToken(GetCurrentProcess(), 
                         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                         &hToken);
    
        if (NULL == hToken) {
            __leave;
        }
        
        //
        // Obtain a LUID for the specified privilege
        //
        if (!LookupPrivilegeValue(NULL, lpwPrivilege, &luid)) {
            __leave;
        }
        
        tp.PrivilegeCount           = 1;
        tp.Privileges[0].Luid       = luid;
        tp.Privileges[0].Attributes = fEnable ? SE_PRIVILEGE_ENABLED : 0;
    
        //
        // Modify the access token
        //
        if (!AdjustTokenPrivileges(hToken,
                                   FALSE,
                                   &tp,
                                   sizeof(TOKEN_PRIVILEGES),
                                   NULL,
                                   NULL)) {
            __leave;
        }
        
        fResult = TRUE;
    
    } // try

    __finally {

        if (hToken) {
            CloseHandle(hToken);
        }
    
    } // finally

    return (fResult);
}

/*++

  Routine Description:

    Saves the specified information to the file
    that will be used by the uninstaller

  Arguments:

    lpwSectionName      -       The name of the section where our entry
                                will be saved
    lpwKeyName          -       A 1-based number in a string. It should
                                be unique for each entry in the section
    lpwEntryName        -       The value or entry to save
    lpwFileName         -       The file to save our changes to
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL SaveEntryToINF(
    IN LPCWSTR lpwSectionName,
    IN LPCWSTR lpwKeyName,
    IN LPCWSTR lpwEntryName,
    IN LPCWSTR lpwFileName
    )
{
    BOOL    fReturn = FALSE;
    
    //
    // Write the entry to the INF
    //
    fReturn = WritePrivateProfileString(lpwSectionName,
                                        lpwKeyName,
                                        lpwEntryName,
                                        lpwFileName);

    if (!fReturn) {
        Print(ERROR,
              L"[SaveEntryToINF] Failed to save entry: Section: %\nKey Name: %s\n Entry: %s\n File: %s\n");
    }

    return (fReturn ? TRUE : FALSE);
}

/*++

  Routine Description:

    Deletes the specified registry
    keys during install

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CommonDeleteRegistryKeys()
{
    BOOL        fReturn = FALSE, fResult = FALSE;
    HKEY        hKeyRoot = NULL;
    char        szEntry[MAX_PATH] = "";
    WCHAR       wszEntry[MAX_PATH] = L"";
    char        szKeyPath[MAX_PATH*3] = "";
    WCHAR       wszKeyPath[MAX_PATH*3] = L"";
    LPWSTR      lpwKeyRoot = NULL, lpwSubKey = NULL;
    UINT        uCount = 0;
    CRegistry   creg;
    INFCONTEXT  InfContext;

    //
    // Step through each entry in the queue
    //
    while (g_si.DeleteRegistryQueue.GetSize()) {

        g_si.DeleteRegistryQueue.Dequeue(wszEntry, MAX_PATH - 1, FALSE);

        pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);

        //
        // Loop through all the lines in the delete registry section(s),
        // and perform the deletion
        //
        fReturn = SetupFindFirstLineA(g_si.hInf, szEntry, NULL,
                                      &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szKeyPath, MAX_PATH, NULL);


        while (fReturn) {

            pAnsiToUnicode(szKeyPath, wszKeyPath, MAX_PATH*3);

            //
            // Split the key path into two separate parts
            //
            lpwKeyRoot = GetNextToken(wszKeyPath, L",");
            
            if (NULL == lpwKeyRoot) {
                break;
            }

            Print(TRACE, L"[CommonDeleteRegistryKeys] Key root: %s\n", lpwKeyRoot);

            if (!_wcsicmp(lpwKeyRoot, L"HKLM")) {
                hKeyRoot = HKEY_LOCAL_MACHINE;

            } else if (!_wcsicmp(lpwKeyRoot, L"HKCR")) {
                hKeyRoot = HKEY_CLASSES_ROOT;
            
            } else if (!_wcsicmp(lpwKeyRoot, L"HKCU")) {
                hKeyRoot = HKEY_CURRENT_USER;
            
            } else if (!_wcsicmp(lpwKeyRoot, L"HKU")) {
                hKeyRoot = HKEY_USERS;
            
            } else {
                break;
            }

            lpwSubKey = GetNextToken(NULL, L",");

            if (NULL == lpwSubKey) {
                break;
            }

            Print(TRACE, L"[CommonDeleteRegistryKeys] Subkey path %s\n", lpwSubKey);

            //
            // Verify that the specified key exists
            //
            fResult = creg.IsRegistryKeyPresent(hKeyRoot, lpwSubKey);

            if (fResult) {

                //
                // Do a recursive delete on the key
                //
                SHDeleteKey(hKeyRoot, lpwSubKey);
            }

            fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szKeyPath, MAX_PATH, NULL);
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Based on the flag, performs a server
    registration or performs a server
    removal (unregistration)

  Arguments:

    fRegister       -   A flag to indicate if we should
                        perform a register server
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CommonRegisterServers(
    IN BOOL fRegister
    )
{
    int         nLen = 0;
    char        szFileName[MAX_PATH] = "";
    WCHAR       wszFileToRun[MAX_PATH] = L"";
    WCHAR       wszFileName[MAX_PATH] = L"";
    char        szEntry[MAX_PATH] = "";
    WCHAR       wszEntry[MAX_PATH] = L"";
    WCHAR       wszEntryToSave[MAX_PATH*2] = L"";
    WCHAR       wszKey[10] = L"";
    WCHAR       wszSectionName[MAX_PATH] = L"";
    BOOL        fReturn = FALSE;
    UINT        uCount = 0;
    LPWSTR      lpwDestDir = NULL;
    INFCONTEXT  InfContext;

    //
    // Step through each entry in the queue
    //
    while (g_si.RegistrationQueue.GetSize()) {

        g_si.RegistrationQueue.Dequeue(wszEntry, MAX_PATH - 1, FALSE);

        pUnicodeToAnsi(wszEntry, szEntry, MAX_PATH);

        //
        // Get the destination directory
        //
        GetNextToken(wszEntry, L".");
        lpwDestDir = GetNextToken(NULL, L".");

        if (NULL == lpwDestDir) {
            return FALSE;
        }

        //
        // Loop through all the lines in the approriate section,
        // spawning off each one
        //
        fReturn = SetupFindFirstLineA(g_si.hInf, szEntry, NULL,
                                      &InfContext) &&
                  SetupGetLineTextA(&InfContext,
                                    NULL, NULL, NULL,
                                    szFileName, MAX_PATH, NULL);
        
        while (fReturn) {
    
            pAnsiToUnicode(szFileName, wszFileName, MAX_PATH);

            //
            // Set up the path to the file to (un)register and run it
            //
            if (fRegister) {
                
                wsprintf(wszFileToRun,
                         L"regsvr32.exe /s \"%s\\%s\\%s\"",
                         g_si.lpwWindowsDirectory,
                         lpwDestDir,
                         wszFileName);
            
            } else {
                
                wsprintf(wszFileToRun,
                         L"regsvr32.exe /s /u \"%s\"",
                         wszFileName);
            }

            Print(TRACE, L"[CommonRegisterServers] Preparing to launch %s\n",
                  wszFileToRun);
            
            LaunchProcessAndWait(wszFileToRun, NULL);

            if (fRegister) {

                //
                // Now save an entry to the queue
                //
                wsprintf(wszEntryToSave,
                         L"%s\\%s\\%s",
                         g_si.lpwWindowsDirectory,
                         lpwDestDir,
                         wszFileName);
    
                wsprintf(wszKey, L"%u", ++uCount);

                wsprintf(wszSectionName,
                         L"%s.%s",
                         INF_UNREGISTRATIONSW,
                         lpwDestDir);
    
                SaveEntryToINF(wszSectionName,
                               wszKey,
                               wszEntryToSave,
                               g_si.lpwUninstallINFPath);
            }
                
            fReturn = SetupFindNextLine(&InfContext, &InfContext) &&
                      SetupGetLineTextA(&InfContext,
                                        NULL, NULL, NULL,
                                        szFileName, MAX_PATH, NULL);
        }
    }
    
    return TRUE;
}

/*++

  Routine Description:

    Removes all files from the specified directory,
    then removes the directory

  Arguments:

    lpwDirectoryPath        -   Full path to the directory
    pEnumerateParameter     -   A parameter for misc storage
    fRemoveDirectory        -   A flag to indicate if we should
                                remove the directory    
    fRemoveSubDirs          -   A flag to indicate if we should
                                remove subdirectories
    
  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CommonRemoveDirectoryAndFiles(
    IN LPCWSTR lpwDirectoryPath,
    IN PVOID   pEnumerateParameter,
    IN BOOL    fRemoveDirectory,
    IN BOOL    fRemoveSubDirs
    )
{
    CEnumDir    ced;

    //
    // Remove any files from the directory
    //
    ced.EnumerateDirectoryTree(lpwDirectoryPath,
                               DeleteOneFile,
                               fRemoveSubDirs,
                               pEnumerateParameter);

    //
    // Now try to remove the directory itself
    //
    if (fRemoveDirectory) {

        SetFileAttributes(lpwDirectoryPath, FILE_ATTRIBUTE_NORMAL);
        
        if (!RemoveDirectory(lpwDirectoryPath)) {
        
            Print(ERROR,
                  L"[CommonRemoveDirectoryAndFiles] Failed to remove directory %s\n",
                lpwDirectoryPath);
            return FALSE;
        }
    }

    return TRUE;
}

/*++

  Routine Description:

    Enables protected renames in the registry

  Arguments:

    None

  Return Value:

    TRUE on success, FALSE otherwise

--*/
BOOL
CommonEnableProtectedRenames()
{
    CRegistry   creg;
    BOOL        fReturn = FALSE;

    fReturn = creg.SetDword(HKEY_LOCAL_MACHINE,
                            REG_SESSION_MANAGER,
                            REG_PROT_RENAMES,
                            (DWORD) 1,
                            TRUE);

    return (fReturn);
}

/*++

  Routine Description:

    Installs a catalog file

  Arguments:

    lpwCatalogFullPath      -   Full path to the catalog file
    lpwNewBaseName          -   Name catalog should get when
                                it's installed in the store
    
  Return Value:

    NO_ERROR on success

--*/
#ifdef WIN2KSE
DWORD
pInstallCatalogFile(
    IN LPCWSTR lpwCatalogFullPath,
    IN LPCWSTR lpwNewBaseName
    )
{
    DWORD   dwError = 0;

    dwError = VerifyCatalogFile(lpwCatalogFullPath);
            
    if (dwError == NO_ERROR) {
                
        dwError = InstallCatalog(lpwCatalogFullPath, lpwNewBaseName, NULL);
    }
    
    return (dwError);
}
#else
DWORD
pInstallCatalogFile(
    IN LPCWSTR lpwCatalogFullPath,
    IN LPCWSTR lpwNewBaseName
    )
{
    DWORD   dwError = 0;

    dwError = pSetupVerifyCatalogFile(lpwCatalogFullPath);
            
    if (dwError == NO_ERROR) {
                
        dwError = pSetupInstallCatalog(lpwCatalogFullPath, lpwNewBaseName, NULL);
    }
    
    return (dwError);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\inc\afxres.h ===
//
//      Copyright(c) 1996 - 1999. Microsoft Corporation.
//

// afxres.h

#include <windows.h>
#undef _WIN32
#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC              (-1)     // all static controls
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\cstest\textdisp.cxx ===
////    TEXTDISP.C - Text display
//
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//



#include "precomp.hxx"
#include "uspglob.hxx"

#pragma warning(disable:4702)   // Unreachable code


int  iFirstLine;        // Position at start of first line displayed






void SelectStyle(HDC hdc, int iStyle, int *piLineHeight, int *piTop, HFONT *phOldFont) {

    HFONT        hOldFont;
    HFONT        hFont;
    TEXTMETRICA  tma;


    hOldFont = NULL;
    if (ss[iStyle].fInUse) {
        hFont = CreateFontIndirectA(&ss[iStyle].rs.lf);
        if (hFont) {
            hOldFont = (HFONT) SelectObject(hdc, hFont);
            if (!*phOldFont) {
                *phOldFont = hOldFont;
            } else {
                DeleteObject(hOldFont);
            }
        }
    }

    GetTextMetricsA(hdc, &tma);

    if (!*piLineHeight) {
        *piLineHeight = ((tma.tmAscent + tma.tmDescent) * 133) / 100;
    }

    *piTop = ((*piLineHeight * 60) / 100) - tma.tmAscent;
}






BOOL PaintText(HDC hdc, int irs, int iY, PRECT prc, PWCH pwc, int iLen, PINT piLineHeight) {

    const BOOL fValidate = TRUE;

    BOOL     fResult;
    HFONT    hOldFont = NULL;
    int      iTop;
    int      iX;
#ifdef LPK_TEST
    HRESULT  hr;
    SCRIPT_STRING_ANALYSIS ssa;
    int      iBuf[200];
    POINT    point;
    int      i;
    SCRIPT_CONTROL  ScriptControl;
    SCRIPT_STATE    ScriptState;
    int      iClipWidth;
    BOOL     fValid;
#endif

    SelectStyle(hdc, irs, piLineHeight, &iTop, &hOldFont);
    SetTextColor(hdc, g_iTextColor);

    if (fRight) {

        iX = prc->right - 1;
        SetTextAlign(hdc, TA_RIGHT);

    } else {

        iX = prc->left;
        SetTextAlign(hdc, TA_LEFT);
    }


#ifdef LPK_TEST

    if (bUseLpk) {

        // Use LPK entrypoints

        memset(&ScriptControl, 0, sizeof(ScriptControl));
        memset(&ScriptState,   0, sizeof(ScriptState));

        ScriptControl.uDefaultLanguage = PrimaryLang;
        ScriptControl.fContextDigits   = ContextDigits;

        ScriptState.fDigitSubstitute   = (WORD) DigitSubstitute;
        ScriptState.fArabicNumContext  = (WORD) ArabicNumContext;
        ScriptState.fDisplayZWG        = (WORD) fDisplayZWG;

        iClipWidth = prc->right - prc->left - *piLineHeight;

        if (fFit  ||  fClip) {
            if (fRight) {
                MoveToEx(hdc, iX - iClipWidth, 0, NULL);
                LineTo(hdc,   iX - iClipWidth, prc->bottom);
            } else {
                MoveToEx(hdc, iX + iClipWidth, 0, NULL);
                LineTo(hdc,   iX + iClipWidth, prc->bottom);
            }
        }

        hr = ScriptStringAnalyse(
                hdc, pwc, iLen, 0, -1,
                  SSA_GLYPHS
                | SSA_LINK
                | (fRTL      ? SSA_RTL      : 0)
                | (fClip     ? SSA_CLIP     : 0)
                | (fFit      ? SSA_FIT      : 0)
                | (fFallback ? SSA_FALLBACK : 0)
                | (fTab      ? SSA_TAB      : 0)
                | (fHotkey   ? SSA_HOTKEY   : 0)
                | (fPassword ? SSA_PASSWORD : 0)
                | (fValidate ? SSA_BREAK    : 0),
                iClipWidth,
                fNullState   ? NULL : &ScriptControl,
                fNullState   ? NULL : &ScriptState,
                NULL,
                NULL, NULL, &ssa);

        if (SUCCEEDED(hr)) {

            if (fPiDx) {

                // Hack a test of piDx. Generate a second analysis using the
                // Logical widths gleaned from the first analysis, but with
                // the first logical character doubled in width.

                ScriptStringGetLogicalWidths(ssa, iBuf);
                ScriptStringFree(&ssa);

                iBuf[0] *= 2;

                hr = ScriptStringAnalyse(
                        hdc, pwc, iLen, 0, -1,
                          SSA_GLYPHS
                        | SSA_LINK
                        | (fRTL      ? SSA_RTL      : 0)
                        | (fClip     ? SSA_CLIP     : 0)
                        | (fFit      ? SSA_FIT      : 0)
                        | (fFallback ? SSA_FALLBACK : 0)
                        | (fTab      ? SSA_TAB      : 0)
                        | (fHotkey   ? SSA_HOTKEY   : 0)
                        | (fPassword ? SSA_PASSWORD : 0)
                        | (fValidate ? SSA_BREAK    : 0),
                        iClipWidth,
                        fNullState   ? NULL : &ScriptControl,
                        fNullState   ? NULL : &ScriptState,
                        iBuf,
                        NULL, NULL, &ssa);
            }
        }


        if (SUCCEEDED(hr)) {

            ScriptStringGetLogicalWidths(ssa, iBuf);

            if (fVertical) {
                hr = ScriptStringOut(ssa, *piLineHeight+iY+iTop, iX, 0, prc, 0, 0, FALSE);
            } else {
                hr = ScriptStringOut(ssa, iX, iY+iTop, 0, prc, 0, 0, FALSE);
            }

            fValid = ScriptStringValidate(ssa);

            switch (fValid) {
                case S_OK:    ExtTextOutA(hdc, 0, iY, 0, NULL, "+", 1, NULL); break;
                case S_FALSE: ExtTextOutA(hdc, 0, iY, 0, NULL, "x", 1, NULL); break;
                default:      ASSERTHR(fValid, ("PaintText -- ScriptStringValidate"));
            }

            if (iLen > sizeof(iBuf) / sizeof(iBuf[0])) {
                iLen = sizeof(iBuf) / sizeof(iBuf[0]);
            }
            ScriptStringGetLogicalWidths(ssa, iBuf);

            if (fRight) {
                iX = prc->right - ScriptString_pSize(ssa)->cx;
            } else {
                iX = prc->left;
            }

            MoveToEx(hdc, iX, iY+iTop, &point);
            LineTo(hdc, iX+ScriptString_pSize(ssa)->cx, iY+iTop);

            MoveToEx(hdc, iX, iY+iTop, &point);
            LineTo(hdc, iX, iY+iTop+10);

            for (i=0; i<*ScriptString_pcOutChars(ssa); i++) {
                iX += iBuf[i];
                MoveToEx(hdc, iX, iY+iTop, &point);
                LineTo(hdc, iX, iY+iTop+10);
            }

            ScriptStringFree(&ssa);
        }


        fResult = SUCCEEDED(hr);

    } else {

#endif
        // Call GDI directly

        if (fRTL) {
            SetTextAlign(hdc, GetTextAlign(hdc) | TA_RTLREADING);
        }

        if (fVertical) {

            fResult = ExtTextOutW(hdc, *piLineHeight + iY+iTop, iX, 0, prc, pwc, iLen, NULL);

        } else {

            fResult = ExtTextOutW(hdc, iX, iY+iTop, 0, prc, pwc, iLen, NULL);
        }

#ifdef LPK_TEST
    }
#endif


    if (fRight) {
        SetTextAlign(hdc, TA_LEFT);
    }

    if (hOldFont) {
        DeleteObject(SelectObject(hdc, hOldFont));
    }

    return fResult;
}






////    ParseRun - Parse forward to next markup / end of line / end of text
//
//      Returns P_MARKUP or P_CRLF or P_EOT in *piType.


BOOL ParseRun(int iPos, PINT piLen, PINT piType, PINT piMLen, PINT piMVal) {

    int iT;     // Parse type
    int iL;     // Parse length
    int iV;     // Parse value
    int i;

    i = iPos;
    if (!textParseForward(i, &iL, &iT, &iV)) {
        return FALSE;
    }
    while (iT != P_CRLF && iT != P_EOT && iT != P_MARKUP) {
        i += iL;
        if (!textParseForward(i, &iL, &iT, &iV)) {
            return FALSE;
        }
    }

    *piLen  = i - iPos;
    *piType = iT;
    *piMLen = iL;
    *piMVal = iV;
    return TRUE;
}






////    PaintLineLogical
//
//      Simply paints each run separately, to the right of the previous run.


BOOL PaintLineLogical(HDC hdc, int iPos, int iY, PRECT prc, PINT piLineHeight) {

    int  iType;     // Item type
    int  iML;       // Markup length
    int  iMV;       // Markup value
    int  iLen;      // Length to markup
    int  irs;       // Run style


    irs = 0;

    while (ParseRun(iPos, &iLen, &iType, &iML, &iMV)) {

        // Process any text up to the markup point

        if (iLen) {
            if (!PaintText(hdc, 0, iY, prc, textpChar(iPos), iLen, piLineHeight)) {
                return FALSE;
            }
            iPos += iLen;
        }


        // Now process markup

        switch(iType) {

            case P_MARKUP:
                irs = iMV;
                break;

            case P_CRLF:
            case P_EOT:
                return TRUE;
        }

        iPos += iML;
    }

    return FALSE;
}






struct RUN {
    struct RUN       *pNext;
    int               iCharPos;
    int               iLen;
    SCRIPT_ANALYSIS   a;
    int               iStyle;     // Index to style sheet (global 'ss').
};


////    ParseLine - Parse forward to next end of line / end of text
//
//      Returns a linked list of RUNs.


BOOL ParseLine(int iPos, int *piLen, int *piT, struct RUN **ppRun) {

    int          iL;     // Parse length
    int          iV;     // Parse value
    int          i;

    struct RUN  **ppLastRun = ppRun;
    struct RUN  *pRun = NULL;
    int          iRunStart;
    int          iRunStyle;

    i         = iPos;
    iRunStart = iPos;
    iRunStyle = 0;   // Initial style is default style

    while (textParseForward(i, &iL, piT, &iV)) {

        if (*piT != P_CHAR) {

            // Record current run
            if (ppRun && i > iRunStart) {
                pRun = new RUN;
                pRun->iCharPos = iRunStart - iPos;
                pRun->iLen     = i - iRunStart;
                pRun->iStyle   = iRunStyle;
                pRun->pNext    = NULL;
                (*ppLastRun)   = pRun;
                ppLastRun      = &pRun->pNext;
            }

            switch (*piT) {
                case P_MARKUP:
                    iRunStyle = iV;
                    iRunStart = i+iL;
                    break;

                case P_CRLF:
                case P_EOT:
                    *piLen = i-iPos;
                    return TRUE;
            }
        }

        i += iL;
    }

    // If we dropped out of the loop, we failed.

    return FALSE;
}






////    DrawArrow
//
//      Draws an arrow under a single run indicating it's extent and direction.


void DrawArrow(
    HDC     hdc,
    int     x,
    int     y,
    ABC     abc,
    BOOL    fRTL,
    int     iLevel,
    BOOL    bFallback,
    BOOL    bScriptUndef) {

    POINT   p;
    HFONT   hFont;
    HFONT   hOldFont;
    char    sLevel[10];
    int     iLen;
    SIZE    size;
    int     iOldBkMode;
    HPEN    hPen;
    HPEN    hOldPen;

    hFont = CreateFontA(-12, 0, 0, 0, 400, 0, 0, 0, DEFAULT_CHARSET,
                       0, 0, 0, 0, "Small Fonts");
    hOldFont = (HFONT) SelectObject(hdc, hFont);
    if (fRTL) {
        iLen = wsprintfA(sLevel, "< %d", iLevel);
    } else {
        iLen = wsprintfA(sLevel, "%d >", iLevel);
    }
    GetTextExtentPoint32A(hdc, sLevel, iLen, &size);
    iOldBkMode = SetBkMode(hdc, TRANSPARENT);


    hPen = CreatePen(PS_SOLID, 0, bScriptUndef ? RGB(255,0,0) : (bFallback ? RGB(0,0,255) : RGB(0,0,0)));
    hOldPen = HPEN(SelectObject(hdc, hPen));

    MoveToEx(hdc, x,                            y+12, &p);
    LineTo  (hdc, x+abc.abcA,                   y);
    LineTo  (hdc, x+abc.abcA+abc.abcB,          y);
    LineTo  (hdc, x+abc.abcA+abc.abcB+abc.abcC, y+12);

    ExtTextOutA(hdc, x+abc.abcA+(abc.abcB-size.cx)/2, y, 0, NULL, sLevel, iLen, NULL);

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
    SelectObject(hdc, hOldFont);
    DeleteObject(hFont);
    SetBkMode(hdc, iOldBkMode);
}






////    PaintLineVisual
//
//      Parses each run separately and passes them to visual.c to display
//
//      Creates a buffer with one byte per character in the input line containing
//      the style index for that character.
//
//      Markup characters are given style -1 to indicate that they're not part
//      of the line.
//
//      The line and style buffers are passed out to visual.c for display and cursor
//      position analysis.
//
//      PaintLineVisual processes any pending mouse click in a displayed run
//      and updates global iCharpos accordingly.
//
//      PaintLineVisual also sets the GDI caret position if it displays a
//      run containing iCharPos.
//
//      *pfCharPosDirty is usually returned FALSE. When the user clicks in
//      a run, the sequence of processing in PaintLineVisual will usually
//      display the cursor subsequent to detecting the mouse click position.
//      However, when the user clicks in the leading half of the first
//      character of a run, the caret is displayed on the trailing edge of
//      the logically preceeding character. If that character has already
//      been displayed in a prior run, PaintLineVisual will exit with
//      *pdCharPosDirty TRUE - in this case it must be called a second time
//      to display the correct cursor position.



BOOL PaintLineVisual(HDC hdc, int iPos, int iY, PRECT prc, PINT piLineHeight, BOOL *pfCharPosDirty) {


    int             iType;         // Item type
    int             iStyle;        // Run style
    int             iOriginalStyle;// Fallback support
    int             iStylePos;
    int             iTextPos;
    int             iLineLen;
    int             iRealLen;      // Actual characters (excluding markup, CRLF etc).
    int             i,j;
    int             iX;
    WCHAR          *pRealString;  // Actual string (excluding markup)
    struct RUN     *pFirstRun;
    struct RUN     *pRun;
    struct RUN     *pNewRun;
    WCHAR          *pwc;
    SCRIPT_CONTROL  ScriptControl;
    SCRIPT_STATE    ScriptState;
    #define MAX_ITEM 100
    SCRIPT_ITEM     Items[MAX_ITEM];
    int             cItems;
    int             iItem;
    int             iItemLen;
    BYTE            bLevel[MAX_ITEM];
    int             iLogical[MAX_ITEM];
    struct RUN     *pRunVisual[MAX_ITEM];
    int             cRuns;
    #define MAX_GLYPHS 200
    WORD            glyphs[MAX_GLYPHS];
    WORD            wClusters[MAX_ITEM];
    SCRIPT_VISATTR  visattrs[MAX_GLYPHS];
    int             iAdvance[MAX_GLYPHS];
    GOFFSET         Goffset[MAX_GLYPHS];
    int             cGlyphs;
    ABC             abc;
    HRESULT         hr;
    int             iCaretX;
    HFONT           hOldFont;
    int             iTop;


    iTextPos  = iPos;
    iStyle    = 0;
    *pfCharPosDirty = FALSE;

    if (fRight) {
        iX = prc->right;
    } else {
        iX = prc->left;
    }


    // Establish line length in characters and allocate buffers

    ParseLine(iPos, &iLineLen, &iType, &pFirstRun);
    if (iLineLen == 0) {
        // Empty line!
        return TRUE;
    }


    // Establish real characters in the line

    iRealLen = 0;
    pRun     = pFirstRun;
    while (pRun) {
        iRealLen += pRun->iLen;
        pRun = pRun->pNext;
    }


    // Copy the real characters to a private buffer

    pRealString = (WCHAR *) malloc(sizeof(WCHAR) * iRealLen);
    pRun = pFirstRun;
    pwc = pRealString;
    while (pRun) {
        memcpy((void *)pwc, wcBuf+iPos+pRun->iCharPos, pRun->iLen * sizeof(WCHAR));
        pwc += pRun->iLen;
        pRun = pRun->pNext;
    }


    // Itemize by script

    memset(&ScriptControl, 0, sizeof(ScriptControl));
    memset(&ScriptState, 0,   sizeof(ScriptState));

    ScriptControl.uDefaultLanguage = PrimaryLang;
    ScriptControl.fContextDigits   = ContextDigits;

    ScriptState.fDigitSubstitute   = (WORD) DigitSubstitute;
    ScriptState.fArabicNumContext  = (WORD) ArabicNumContext;
    ScriptState.fDisplayZWG        = (WORD) fDisplayZWG;

    if (fRTL) {
        ScriptState.uBidiLevel = 1;     // Start at an odd level for RTL
    }

    hr = ScriptItemize(
        pRealString,
        iRealLen,
        MAX_ITEM,
        fNullState   ? NULL : &ScriptControl,
        fNullState   ? NULL : &ScriptState,
        Items,
        &cItems);

    ASSERTHR(hr, ("ScriptItemize failed"));
    if (FAILED(hr)) {
        free(pRealString);
        return FALSE;
    }


    // Merge script items into runs

    pRun = pFirstRun;
    iItem = 0;
    iItemLen = Items[iItem+1].iCharPos - Items[iItem].iCharPos;

    while (iItem < cItems && pRun) {

        pRun->a  = Items[iItem].a;  // Record script analysis

        if (iItemLen < pRun->iLen) {

            // This item is shorter than this run: split this run in two

            pNewRun           = new RUN;
            pNewRun->pNext    = pRun->pNext;
            pNewRun->iCharPos = pRun->iCharPos + iItemLen;
            pNewRun->iLen     = pRun->iLen - iItemLen;
            pNewRun->iStyle   = pRun->iStyle;
            pRun->iLen        = iItemLen;
            pRun->pNext       = pNewRun;

            iItem++;
            iItemLen = Items[iItem+1].iCharPos - Items[iItem].iCharPos;

        } else if (iItemLen > pRun->iLen) {

            // This item is longer than this run: advance run leaving remainder for next run

            iItemLen -= pRun->iLen;

        } else {

            // Run matches item
            iItem++;
            iItemLen = Items[iItem+1].iCharPos - Items[iItem].iCharPos;
        }

        pRun = pRun->pNext;
    }


    // Each run is now a single script, and includes the SCRIPT_ANALYSIS flags.
    // Build layout array

    i = 0;
    pRun = pFirstRun;
    while (pRun && i<MAX_ITEM) {
        bLevel[i++] = (BYTE) pRun->a.s.uBidiLevel;
        pRun = pRun->pNext;
    }
    cRuns = i;
    hr = ScriptLayout(cRuns, bLevel, NULL, iLogical);
    ASSERTHR(hr, ("ScriptLayout failed"));
    if (FAILED(hr)) {
        free(pRealString);
        return FALSE;
    }

    pRun = pFirstRun;

    if (fRight) {
        // Create right aligned in reverse order
        for (i=0; i<cRuns; i++) {
            pRunVisual[cRuns-1-iLogical[i]] = pRun;
            pRun = pRun->pNext;
        }
    } else {
        for (i=0; i<cRuns; i++) {
            pRunVisual[iLogical[i]] = pRun;
            pRun = pRun->pNext;
        }
    }


    // Process runs one at a time, in visual order for left aligned,
    // reverse visual order for right aligned.

    hOldFont = NULL;

        SetBkMode(hdc, TRANSPARENT);

    for (i=0; i<cRuns; i++) {

        pRun   = pRunVisual[i];
        iStyle = pRun->iStyle;
        iOriginalStyle = iStyle;

        SelectStyle(hdc, iStyle, piLineHeight, &iTop, &hOldFont);

        pRun->a.fLogicalOrder = (WORD) fLogicalOrder;

        hr = ScriptShape(
            hdc,
            &ss[iStyle].rs.sc,
            wcBuf+iPos+pRun->iCharPos,
            pRun->iLen,
            MAX_GLYPHS,
            &pRun->a,
            glyphs,
            wClusters,
            visattrs,
            &cGlyphs);

        if (hr == USP_E_SCRIPT_NOT_IN_FONT) {

            // Font association - loop round all available styles

            iStyle = 0;
            while (hr == USP_E_SCRIPT_NOT_IN_FONT  &&  iStyle < MAX_STYLES) {
                if (iStyle != iOriginalStyle) {
                    SelectStyle(hdc, iStyle, piLineHeight, &iTop, &hOldFont);
                    hr = ScriptShape(
                        hdc,
                        &ss[iStyle].rs.sc,
                        wcBuf+iPos+pRun->iCharPos,
                        pRun->iLen,
                        MAX_GLYPHS,
                        &pRun->a,
                        glyphs,
                        wClusters,
                        visattrs,
                        &cGlyphs);
                }
                iStyle++;
            }
            iStyle--;
        }


        if (FAILED(hr)) {

            if (hr == USP_E_SCRIPT_NOT_IN_FONT) {
                TRACEMSG(("No font supports run %d", i));
            } else {
                ASSERTHR(hr, ("PaintLineVisual -- ScriptShape run %d style %d",
                         i, iOriginalStyle));
            }

            // Use Style 0 with SCRIPT_UNDEFINED
            iStyle = 0;
            SelectStyle(hdc, iStyle, piLineHeight, &iTop, &hOldFont);
            pRun->a.eScript = SCRIPT_UNDEFINED;
            hr = ScriptShape(
                hdc,
                &ss[iStyle].rs.sc,
                wcBuf+iPos+pRun->iCharPos,
                pRun->iLen,
                MAX_GLYPHS,
                &pRun->a,
                glyphs,
                wClusters,
                visattrs,
                &cGlyphs);
            ASSERTHR(hr, ("Run %d failed even with SCRIPT_UNDEFINED", i));
            if (FAILED(hr)) {
                free(pRealString);
                if (hOldFont) {
                    DeleteObject(SelectObject(hdc, hOldFont));
                }
                return FALSE;
            }
        }


        //// For debugging, treat e or period followed by any char as a cluster

        for (j=0; j<pRun->iLen-1; j++) {
            if (   wcBuf[iPos+pRun->iCharPos+j] == 'e'
                || wcBuf[iPos+pRun->iCharPos+j] == '.') {
                visattrs[wClusters[j+1]].fClusterStart = FALSE;
                wClusters[j+1] = wClusters[j];
            }
        }


        hr = ScriptPlace(
            hdc,
            &ss[iStyle].rs.sc,
            glyphs,
            cGlyphs,
            visattrs,
            &pRun->a,
            iAdvance,
            Goffset,
            &abc);
        ASSERTHR(hr, ("ScriptPlace failed"));
        if (FAILED(hr)) {
            free(pRealString);
            if (hOldFont) {
                DeleteObject(SelectObject(hdc, hOldFont));
            }
            return FALSE;
        }

        if (fRight) {
            iX -= abc.abcA + abc.abcB + abc.abcC;
        }

        hr = ScriptTextOut(
            hdc,
            &ss[iStyle].rs.sc,
            fVertical ? *piLineHeight + iY+iTop : iX,
            fVertical ? iX : iY+iTop,
            NULL,
            NULL,
            &pRun->a,
            wcBuf+iPos+pRun->iCharPos,  // original string (required only for metafiles)
            pRun->iLen,
            glyphs,
            cGlyphs,
            iAdvance,
            NULL,                       // No justification
            Goffset);
        ASSERTHR(hr, ("ScriptTextOut: "));
        if (FAILED(hr)) {
            free(pRealString);
            if (hOldFont) {
                DeleteObject(SelectObject(hdc, hOldFont));
            }
            return FALSE;
        }


        // Test for ScriptXtoCP limit handling

        BOOL fTrailing;
        int  iCP;
        hr = ScriptXtoCP(
            10000,
            pRun->iLen,
            cGlyphs,
            wClusters,
            visattrs,
            iAdvance,
            &pRun->a,
            &iCP,
            &fTrailing);

        // Test for ScriptCPtoX limit handling

        int iTestX;
        hr = ScriptCPtoX(
            10000,
            FALSE,
            pRun->iLen,
            cGlyphs,
            wClusters,
            visattrs,
            iAdvance,
            &pRun->a,
            &iTestX);



        // Process any pending mouse click in this run

        if (   Click.fNew
            && Click.yPos >= iY
            && Click.yPos <  iY+*piLineHeight
            && Click.xPos >  iX
            && Click.xPos <= iX+(int)(abc.abcA + abc.abcB + abc.abcC)) {

            // Mouse click in this run

            Click.fNew = FALSE;

            int  iCP;
            BOOL fTrailing;

            if (pRun->a.fLogicalOrder && pRun->a.fRTL) {

                // RTL logical order offsets are from right end

                hr = ScriptXtoCP(
                    abc.abcA + abc.abcB + abc.abcC - (Click.xPos - iX),
                    pRun->iLen,
                    cGlyphs,
                    wClusters,
                    visattrs,
                    iAdvance,
                    &pRun->a,
                    &iCP,
                    &fTrailing);

            } else {

                hr = ScriptXtoCP(
                    Click.xPos - iX,
                    pRun->iLen,
                    cGlyphs,
                    wClusters,
                    visattrs,
                    iAdvance,
                    &pRun->a,
                    &iCP,
                    &fTrailing);

            }

            ASSERTHR(hr, ("ScriptXtoCP failed"));
            if (FAILED(hr)) {
                free(pRealString);
                if (hOldFont) {
                    DeleteObject(SelectObject(hdc, hOldFont));
                }
                return FALSE;
            }

            iCurChar = iPos + pRun->iCharPos + iCP + fTrailing;
            *pfCharPosDirty = TRUE;
        }


        // Process caret display in this run

        if (   iCurChar >  iPos + pRun->iCharPos
            && iCurChar <= iPos + pRun->iCharPos + pRun->iLen) {
            // Caret is somewhere within this run
            if (gCaretToStart) {
                hr = ScriptCPtoX(
                    -1,
                    TRUE,   // Trailing edge of virtual character before run
                    pRun->iLen,
                    cGlyphs,
                    wClusters,
                    visattrs,
                    iAdvance,
                    &pRun->a,
                    &iCaretX);
                gCaretToStart = FALSE;
            } else if (gCaretToEnd) {
                hr = ScriptCPtoX(
                    pRun->iLen,
                    FALSE,   // Leading edge of virtual character after run
                    pRun->iLen,
                    cGlyphs,
                    wClusters,
                    visattrs,
                    iAdvance,
                    &pRun->a,
                    &iCaretX);
                gCaretToEnd = FALSE;
            } else {
                hr = ScriptCPtoX(
                    iCurChar - (iPos+pRun->iCharPos) - 1,
                    TRUE,   // Yes, want trailing edge of character
                    pRun->iLen,
                    cGlyphs,
                    wClusters,
                    visattrs,
                    iAdvance,
                    &pRun->a,
                    &iCaretX);
            }
            ASSERTHR(hr, ("ScriptCPtoX failed"));
            if (FAILED(hr)) {
                free(pRealString);
                if (hOldFont) {
                    DeleteObject(SelectObject(hdc, hOldFont));
                }
                return FALSE;
            }

            if (pRun->a.fLogicalOrder && pRun->a.fRTL) {

                // RTL logical order offsets are from right end

                SetCaretPos(iX + abc.abcA + abc.abcB + abc.abcC - iCaretX, iY);

            } else {

                SetCaretPos(iX+iCaretX, iY);

            }
            *pfCharPosDirty = FALSE;

        }


        // Superimpose run extent, direction and bidi level markings

        DrawArrow(hdc, iX, iY, abc, pRun->a.fRTL, pRun->a.s.uBidiLevel,
                  iStyle != iOriginalStyle, pRun->a.eScript == SCRIPT_UNDEFINED);

        if (!fRight) {
            iX += abc.abcA + abc.abcB + abc.abcC;
        }
    }


    free(pRealString);

    if (hOldFont) {
        DeleteObject(SelectObject(hdc, hOldFont));
    }


    // If the caret is at the start of the line, set it's position now.

    if (iCurChar == iPos) {
        if (fRTL) {
            if (fRight) {
                SetCaretPos(prc->right, iY);
            } else {
                SetCaretPos(iX, iY);
            }
        } else {
            if (fRight) {
                SetCaretPos(iX, iY);
            } else {
                // LTR, Left aligned
                SetCaretPos(prc->left, iY);
            }
        }
        *pfCharPosDirty = FALSE;
    }




    return TRUE;

    UNREFERENCED_PARAMETER(prc);
    UNREFERENCED_PARAMETER(iStylePos);
}






////    dispPaint - Display current text range
//


BOOL dispPaint(HDC hdc, PRECT prc) {

    int  iPos;
    int  iType;
    int  iY;
    int  iLen;
    int  iLineHeight;
    BOOL fCharPosDirty;

    iPos = 0;
    iLineHeight = 0;
    iY = 0;

    while (ParseLine(iPos, &iLen, &iType, NULL)) {

        if (iLen) {
            if (!PaintText(hdc, 0, iY, prc, textpChar(iPos), iLen, &iLineHeight)) {
                TRACEMSG(("CSTEST.dispPaint: PaintText failed"));
            }
        }
        iY += iLineHeight;


#ifdef LOGICAL_LINES
        if (iLen) {
            PaintLineLogical(hdc, iPos, iY, prc, &iLineHeight);
        }
        iY += iLineHeight;
#endif


        if (iLen) {
            PaintLineVisual(hdc, iPos, iY, prc, &iLineHeight, &fCharPosDirty);
            if (fCharPosDirty) {
                // Redisplay to correct caret position
                PaintLineVisual(hdc, iPos, iY, prc, &iLineHeight, &fCharPosDirty);
            }
        }
        iY += iLineHeight * 5 / 4;



        if (iY > prc->bottom) {
            return TRUE;
        }

        switch (iType) {

            case P_EOT:
                return TRUE;

            case P_CRLF:
                iPos += iLen + 2;
                break;
        }
    }


    return FALSE;
}






////    dispInvalidate
//
//


BOOL dispInvalidate(HWND hWnd, int iPos) {
    InvalidateRect(hWnd, NULL, TRUE);
    return TRUE;

    UNREFERENCED_PARAMETER(iPos);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\inc\otlcbdef.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLCBDEF.H  ********
*
*            OTL Services Library Callback Function Definitions
*
*       The OTL Services Library calls back to the functions defined
*       in this file for operating system rescources.        - deanb
*
*       Copyright 1996 - 1997. Microsoft Corporation.
*
*       Jun 13, 1996    v 0.2   First release
*       Sep 25, 1996    v 0.3   Rename to OTL, trimmed to core
*       Jan 15, 1997    v 0.4   Portability renaming, etc.
*       Mar 14, 1997    v 0.5   Table tag param for FreeTable
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************


/***********************************************************************
*
*           Resource Management Callback Function Type Definitions
*   
***********************************************************************/

typedef enum 
{
	otlDestroyContent	= 0,
	otlPreserveContent	= 1
}
otlReallocOptions;

#ifdef __cplusplus

class IOTLClient
{
public:

	virtual BYTE* GetOtlTable 
	(
		const	otlTag		tagTableName        // truetype table name tag 
	) = 0;

	virtual void FreeOtlTable 
	(
		BYTE*				pvTable,			// in: in case client needs it
		const otlTag		tagTableName        // in: truetype table name tag 
	) = 0;

	virtual otlErrCode ReallocOtlList
	(
		otlList*			pList,				// in/out 
		USHORT				cbNewDataSize,		// in 
		USHORT				celmNewMaxLen,		// in 
		otlReallocOptions	optPreserveContent	// in; if set, client may assert  
												//   cbNewDataSize == cbDataSize
	) = 0;

	virtual otlErrCode GetDefaultGlyphs 
	(
		const otlList*		pliChars,			// in: characters 
		otlList*			pliGlyphInfo		// out: glyphs 
												// (fill in the "glyph" field only) 
	) = 0;

	virtual otlErrCode GetDefaultAdv 
	(
		const otlList*		pliGlyphInfo,	// in: glyphs 
		otlList*			pliduGlyphAdv	// out:	default glyph advances 
	) = 0;

	virtual otlErrCode GetGlyphPointCoords 
	(
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement**		prgplc				// out: x, y coords of points 
	) = 0;

	virtual otlErrCode FreeGlyphPointCoords
	(
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement*		rgplc				// in: point coord array to free
	) = 0;

};

#else // !defined(__cplusplus)

typedef struct 
{
  const IOTLClientVtbl* lpVtbl;
} 
IOTLClient;


typedef struct 
{
  	BYTE* (OTL_PUBLIC * GetOtlTable) 
	(
		IOTLClient*			This,
		const	otlTag		tagTableName        // truetype table name tag 
	);

	void (OTL_PUBLIC * FreeOtlTable) 
	(
		IOTLClient*			This,
		BYTE*				pvTable,			// in: in case client needs it
		const otlTag		tagTableName        // in: truetype table name tag 
	);

	otlErrCode (OTL_PUBLIC * ReallocOtlList)
	(
		IOTLClient*			This,
		otlList*			pList,				// in/out 
		USHORT				cbNewDataSize,		// in 
		USHORT				celmNewMaxLen,		// in 
		otlReallocOptions	optPreserveContent	// in; if set, client may assert  
												//   cbNewDataSize == cbDataSize
	);

	otlErrCode (OTL_PUBLIC * GetDefaultGlyphs) 
	(
		IOTLClient*			This,
		const otlList*		pliChars,			// in: characters 
		otlList*			pliGlyphInfo		// out: glyphs 
												// (fill in the "glyph" field only) 
	);

	otlErrCode (OTL_PUBLIC * GetDefaultAdv) 
	(
		IOTLClient*			This,
		const otlList*		pliGlyphInfo,		// in: glyphs 
		otlList*			pliduGlyphAdv		// out:	default glyph advances 
	);

	otlErrCode (OTL_PUBLIC * GetGlyphPointCoords) 
	(
		IOTLClient*			This,
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement**		prgplc				// out: x, y coords of points 
	);

	otlErrCode (OTL_PUBLIC * FreeGlyphPointCoords)
	(
		IOTLClient*			This,
		const otlGlyphID	glyph,				// in: glyph ID 
		otlPlacement*		rgplc				// in: point coord array to free
	);

}
IOTLClientVtbl;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\inc\otltypes.inl ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLTYPES.INL  ********
*
*              Open Type Layout Services Library Header File
*
*       This module contains inline functions for handling basic OTL structures
*
*       Copyright 1997. Microsoft Corporation.
*
*       July 27, 1997    v 0.9		AndreiB		Created
*
************************************************************************
***********************************************************************/

/***********************************************************************
*   
*       otlList inline helper functions 
*
***********************************************************************/

#include <assert.h>
#include <string.h>

// otlList inline functions

void otlList::reset(void* pvNewData, USHORT cbNewDataSize, 
					USHORT celmNewLength, USHORT celmNewMaxLen)
{
	assert(pvNewData != NULL || celmNewMaxLen == 0);
	assert(celmNewLength <= celmNewMaxLen);

	pvData = pvNewData;
	cbDataSize = cbNewDataSize;
	celmLength = celmNewLength;
	celmMaxLen = celmNewMaxLen;
}


inline BYTE* otlList::elementAt(unsigned short index)
{
	assert(index < celmLength);
	return (BYTE*)pvData + index * cbDataSize;
}

inline const BYTE* otlList::readAt(unsigned short index) const
{
	assert(index < celmLength);
	return (BYTE*)pvData + index * cbDataSize;
}

inline void otlList::insertAt(unsigned short index, unsigned short celm)
{
	assert(index <= celmLength);
	assert(celmMaxLen >= celmLength + celm);

	memmove((BYTE*)pvData + (index + celm) * cbDataSize,
			(BYTE*)pvData + index * cbDataSize, 
			(celmLength - index) * cbDataSize);

	celmLength += celm;
}

inline void otlList::deleteAt(unsigned short index, unsigned short celm)
{
	assert(index <= celmLength);
	assert(celmLength - celm >= 0);

	memmove((BYTE*)pvData + index * cbDataSize,
			(BYTE*)pvData + (index + celm) * cbDataSize, 
			(celmLength - index - celm) * cbDataSize);

	celmLength -= celm;
}

inline void otlList::append(const BYTE* element)
{
	assert(celmMaxLen > celmLength);
	memcpy((BYTE*)pvData + celmLength * cbDataSize, element, cbDataSize);
	++celmLength;
}


// type-specific primitives to avoid constant casting

// otlTag
inline otlTag readOtlTag(const otlList* pliTag, USHORT i)
{
	assert(pliTag->dataSize() == sizeof(otlTag));
	return *(const otlTag*)pliTag->readAt(i);
}


// otlGlyphInfo
inline const otlGlyphInfo* readOtlGlyphInfo(const otlList* pliGlyphInfo, USHORT i)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	return (const otlGlyphInfo*)pliGlyphInfo->readAt(i);
}

inline otlGlyphInfo* getOtlGlyphInfo(otlList* pliGlyphInfo, USHORT i)
{
	assert(pliGlyphInfo->dataSize() == sizeof(otlGlyphInfo));
	return (otlGlyphInfo*)pliGlyphInfo->elementAt(i);
}


// wchar
inline WCHAR readOtlChar(const otlList* pliChars, USHORT i)
{
	assert(pliChars->dataSize() == sizeof(WCHAR));
	return *(const WCHAR*)pliChars->readAt(i);
}


// iGlyph
inline USHORT readOtlGlyphIndex(const otlList* pliGlyphMap, USHORT i)
{
	assert(pliGlyphMap->dataSize() == sizeof(USHORT));
	return *(const USHORT*)pliGlyphMap->readAt(i);
}

inline USHORT* getOtlGlyphIndex(otlList* pliGlyphMap, USHORT i)
{
	assert(pliGlyphMap->dataSize() == sizeof(USHORT));
	return (USHORT*)pliGlyphMap->elementAt(i);
}


// otlPlacement
inline const otlPlacement* readOtlPlacement(const otlList* pliPlacement, USHORT i)
{
	assert(pliPlacement->dataSize() == sizeof(otlPlacement));
	return (const otlPlacement*)pliPlacement->readAt(i);
}

inline otlPlacement* getOtlPlacement(otlList* pliPlacement, USHORT i)
{
	assert(pliPlacement->dataSize() == sizeof(otlPlacement));
	return (otlPlacement*)pliPlacement->elementAt(i);
}


// advance widths
inline const long readOtlAdvance(const otlList* pliAdvance, USHORT i)
{
	assert(pliAdvance->dataSize() == sizeof(long));
	return *(const long*)pliAdvance->readAt(i);
}

inline long* getOtlAdvance(otlList* pliAdvance, USHORT i)
{
	assert(pliAdvance->dataSize() == sizeof(long));
	return (long*)pliAdvance->elementAt(i);
}


// otlFeatureDef (no read-only mode)
inline otlFeatureDef* getOtlFeatureDef(otlList* pliFDef, USHORT i)
{
	assert(pliFDef->dataSize() == sizeof(otlFeatureDef));
	return (otlFeatureDef*)pliFDef->elementAt(i);
}


// otlFeatureDesc (read-only - never modify)
inline const otlFeatureDesc* readOtlFeatureDesc(const otlList* pliFDesc, USHORT i)
{
	assert(pliFDesc->dataSize() == sizeof(otlFeatureDesc));
	return (const otlFeatureDesc*)pliFDesc->readAt(i);
}


// otlFeatureResult (no read-only mode)
inline otlFeatureResult* getOtlFeatureResult(otlList* pliFRes, USHORT i)
{
	assert(pliFRes->dataSize() == sizeof(otlFeatureResult));
	return (otlFeatureResult*)pliFRes->elementAt(i);
}


// otlBaseline (no read-only mode)
inline otlBaseline* getOtlBaseline(otlList* pliBaseline, USHORT i)
{
	assert(pliBaseline->dataSize() == sizeof(otlBaseline));
	return (otlBaseline*)pliBaseline->elementAt(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\cstest\usptest.cxx ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright  1994-1997  Microsoft Corporation.  All Rights Reserved.
//
// PROGRAM: GCPdemo.c
//
// PURPOSE: Example of use of GetCharacterPlacement API
//
// PLATFORMS:  Windows 95, Windows NT
//


#include "precomp.hxx"


#define GLOBALSHERE 1

#include "uspglob.hxx"
#include <string.h>




// Common #defines

#define APPNAME  "USPTest"
#define APPTITLE "USPTest - Uniscribe test harness"

char szAppTitle[300];






////    About - process messages for "About" dialog box
//


LRESULT CALLBACK About(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:
            ShowWindow (hDlg, SW_SHOW);
            return TRUE;

        case WM_COMMAND:
            if (LOWORD(wParam) == IDOK || LOWORD(wParam) == IDCANCEL) {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
    }

    return FALSE;

    UNREFERENCED_PARAMETER(lParam);
}






////    ClientRightButtonDown
//
//

void ClientRightButtonDown(HWND hWnd, int x, int y) {
    POINT p;
    HMENU hMenu;

    p.x = x;
    p.y = y;

    ClientToScreen(hWnd, &p);
    // This is where you would determine the appropriate 'context'
    // menu to bring up. Since this app has no real functionality,
    // we will just bring up the 'Help' menu:
    hMenu = GetSubMenu (GetMenu (hWnd), 2);
    if (hMenu) {
        TrackPopupMenu (hMenu, 0, p.x, p.y, 0, hWnd, NULL);
    } else {
        // Couldn't find the menu...
        MessageBeep(0);
    }
}






////    ClientPaint - redraw part or all of client area
//
//


void ClientPaint(HWND hWnd) {

    PAINTSTRUCT ps;
    HDC         hdc;
    RECT        rc;

    hdc = BeginPaint (hWnd, &ps);

    GetWindowRect (hWnd, &rc);
    rc.right  -= rc.left + 20;  rc.left = 10;
    rc.bottom -= rc.top  + 16;  rc.top  = 8;

    dispPaint(hdc, &rc);

    EndPaint (hWnd, &ps);
}




void toggleMenuSetting(HWND hWnd, UINT uItem) {

    BOOL fSetting=TRUE;

    switch(uItem) {
        case ID_EDIT_NULLSTATE:        fNullState       = ! fNullState;       fSetting = fNullState;       break;
        case ID_EDIT_RTL:              fRTL             = ! fRTL;             fSetting = fRTL;             break;
        case ID_EDIT_RIGHT:            fRight           = ! fRight;           fSetting = fRight;           break;
        case ID_EDIT_CONTEXTDIGITS:    ContextDigits    = ! ContextDigits;    fSetting = ContextDigits;    break;
        case ID_EDIT_DIGITSUBSTITUTE:  DigitSubstitute  = ! DigitSubstitute;  fSetting = DigitSubstitute;  break;
        case ID_EDIT_ARABICNUMCONTEXT: ArabicNumContext = ! ArabicNumContext; fSetting = ArabicNumContext; break;
        case ID_EDIT_LOGICALORDER:     fLogicalOrder    = ! fLogicalOrder;    fSetting = fLogicalOrder;    break;
        case ID_EDIT_DISPLAYZWG:       fDisplayZWG      = ! fDisplayZWG;      fSetting = fDisplayZWG;      break;

#ifdef LPK_TEST
        case ID_EDIT_CLIP:             fClip            = ! fClip;            fSetting = fClip;            break;
        case ID_EDIT_FIT:              fFit             = ! fFit;             fSetting = fFit;             break;
        case ID_EDIT_FALLBACK:         fFallback        = ! fFallback;        fSetting = fFallback;        break;
        case ID_EDIT_TAB:              fTab             = ! fTab;             fSetting = fTab;             break;
        case ID_EDIT_PIDX:             fPiDx            = ! fPiDx;            fSetting = fPiDx;            break;
        case ID_EDIT_HOTKEY:           fHotkey          = ! fHotkey;          fSetting = fHotkey;          break;
        case ID_EDIT_PASSWORD:         fPassword        = ! fPassword;        fSetting = fPassword;        break;
#endif

        case ID_EDIT_VERTICAL:         fVertical        = ! fVertical;        fSetting = fVertical;
            editFreeCaches();
            editClear();
            break;


        default: fSetting = FALSE;
    }
    CheckMenuItem(GetMenu(hWnd), uItem, fSetting ? MF_CHECKED : MF_UNCHECKED);
    dispInvalidate(hWnd, 0);
}





#ifdef LPK_TEST
void toggleLpkUsage(HWND hWnd, UINT uItem) {

    bUseLpk = !bUseLpk;

    CheckMenuItem(GetMenu(hWnd), uItem, bUseLpk ? MF_CHECKED : MF_UNCHECKED);
    dispInvalidate(hWnd, 0);
}
#endif





void setPrimaryLang(HWND hWnd, UINT uItem) {

    MENUITEMINFOA   mii;
    CHAR           *psTitle;


    PrimaryLang = LANGID(uItem - ID_EDIT_LANG);
    dispInvalidate(hWnd, 0);

    switch (PrimaryLang) {
        case LANG_NEUTRAL:      psTitle = "Primary langauge (Neutral)";     break;
        case LANG_AFRIKAANS:    psTitle = "Primary langauge (Afrikaans)";   break;
        case LANG_ALBANIAN:     psTitle = "Primary langauge (Albanian)";    break;
        case LANG_ARABIC:       psTitle = "Primary langauge (Arabic)";      break;
        case LANG_BASQUE:       psTitle = "Primary langauge (Basque)";      break;
        case LANG_BELARUSIAN:   psTitle = "Primary langauge (Belarusian)";  break;
        case LANG_BENGALI:      psTitle = "Primary langauge (Bengali)";     break;
        case LANG_BULGARIAN:    psTitle = "Primary langauge (Bulgarian)";   break;
        //case LANG_BURMESE:      psTitle = "Primary langauge (Burmese)";     break;
        case LANG_CATALAN:      psTitle = "Primary langauge (Catalan)";     break;
        case LANG_CHINESE:      psTitle = "Primary langauge (Chinese)";     break;
        //case LANG_CROATIAN:
        case LANG_SERBIAN:      psTitle = "Primary langauge (Croatian/Serbian)";break;
        case LANG_CZECH:        psTitle = "Primary langauge (Czech)";       break;
        case LANG_DANISH:       psTitle = "Primary langauge (Danish)";      break;
        case LANG_DUTCH:        psTitle = "Primary langauge (Dutch)";       break;
        case LANG_ENGLISH:      psTitle = "Primary langauge (English)";     break;
        case LANG_ESTONIAN:     psTitle = "Primary langauge (Estonian)";    break;
        case LANG_FAEROESE:     psTitle = "Primary langauge (Faeroese)";    break;
        case LANG_FARSI:        psTitle = "Primary langauge (Farsi)";       break;
        case LANG_FINNISH:      psTitle = "Primary langauge (Finnish)";     break;
        case LANG_FRENCH:       psTitle = "Primary langauge (French)";      break;
        case LANG_GERMAN:       psTitle = "Primary langauge (German)";      break;
        case LANG_GREEK:        psTitle = "Primary langauge (Greek)";       break;
        case LANG_GUJARATI:     psTitle = "Primary langauge (Gujarati)";    break;
        case LANG_HEBREW:       psTitle = "Primary langauge (Hebrew)";      break;
        case LANG_HINDI:        psTitle = "Primary langauge (Hindi)";       break;
        case LANG_HUNGARIAN:    psTitle = "Primary langauge (Hungarian)";   break;
        case LANG_ICELANDIC:    psTitle = "Primary langauge (Icelandic)";   break;
        case LANG_INDONESIAN:   psTitle = "Primary langauge (Indonesian)";  break;
        case LANG_ITALIAN:      psTitle = "Primary langauge (Italian)";     break;
        case LANG_JAPANESE:     psTitle = "Primary langauge (Japanese)";    break;
        case LANG_KANNADA:      psTitle = "Primary langauge (Kannada)";     break;
        //case LANG_KHMER:        psTitle = "Primary langauge (Khmer)";       break;
        case LANG_KOREAN:       psTitle = "Primary langauge (Korean)";      break;
        //case LANG_LAO:          psTitle = "Primary langauge (Lao)";         break;
        case LANG_LATVIAN:      psTitle = "Primary langauge (Latvian)";     break;
        case LANG_LITHUANIAN:   psTitle = "Primary langauge (Lithuanian)";  break;
        case LANG_MACEDONIAN:   psTitle = "Primary langauge (Macedonian)";  break;
        case LANG_MALAY:        psTitle = "Primary langauge (Malay)";       break;
        case LANG_MALAYALAM:    psTitle = "Primary langauge (Malayalam)";   break;
        //case LANG_MONGOLIAN:    psTitle = "Primary langauge (Mongolian)";   break;
        case LANG_NORWEGIAN:    psTitle = "Primary langauge (Norweigan)";   break;
        case LANG_ORIYA:        psTitle = "Primary langauge (Oriya)";       break;
        case LANG_POLISH:       psTitle = "Primary langauge (Polish)";      break;
        case LANG_PORTUGUESE:   psTitle = "Primary langauge (Portuguese)";  break;
        case LANG_PUNJABI:      psTitle = "Primary langauge (Punjabi)";     break;
        case LANG_ROMANIAN:     psTitle = "Primary langauge (Romanian)";    break;
        case LANG_RUSSIAN:      psTitle = "Primary langauge (Russian)";     break;
        case LANG_SLOVAK:       psTitle = "Primary langauge (Slovak)";      break;
        case LANG_SLOVENIAN:    psTitle = "Primary langauge (Slovenian)";   break;
        case LANG_SPANISH:      psTitle = "Primary langauge (Spanish)";     break;
        case LANG_SWAHILI:      psTitle = "Primary langauge (Swahili)";     break;
        case LANG_SWEDISH:      psTitle = "Primary langauge (Swedish)";     break;
        case LANG_TAMIL:        psTitle = "Primary langauge (Tamil)";       break;
        case LANG_TELUGU:       psTitle = "Primary langauge (Telugu)";      break;
        case LANG_THAI:         psTitle = "Primary langauge (Thai)";        break;
        //case LANG_TIBETAN:      psTitle = "Primary langauge (Tibetan)";     break;
        case LANG_TURKISH:      psTitle = "Primary langauge (Turkish)";     break;
        case LANG_UKRAINIAN:    psTitle = "Primary langauge (Ukrainian)";   break;
        case LANG_URDU:         psTitle = "Primary langauge (Urdu)";        break;
        case LANG_VIETNAMESE:   psTitle = "Primary langauge (Vietnamese)";  break;
        default:                psTitle = "Primary language (Unknown)";     break;
    }


    // reset primary language menu name to include current setting

    memset(&mii, 0, sizeof(mii));
    mii.cbSize     = sizeof(mii);
    mii.fMask      = MIIM_TYPE;
    mii.fType      = MFT_STRING;
    mii.dwTypeData = psTitle;
    mii.cch        = (UINT) strlen(psTitle);
    SetMenuItemInfoA(GetSubMenu(GetMenu(hWnd), 1), 19, TRUE, &mii);
}







////    WndProc - Main window message handler and dispatcher
//


LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {

        case WM_COMMAND:

            switch (LOWORD(wParam)) {

                case IDM_ABOUT:
                    DialogBox(hInstance, "AboutBox", hWnd, (DLGPROC)About);
                    break;

                case IDM_EXIT:
                    DestroyWindow(hWnd);
                    break;

                case ID_EDIT_STYLE0: editStyle(hWnd, 0); break;
                case ID_EDIT_STYLE1: editStyle(hWnd, 1); break;
                case ID_EDIT_STYLE2: editStyle(hWnd, 2); break;
                case ID_EDIT_STYLE3: editStyle(hWnd, 3); break;
                case ID_EDIT_STYLE4: editStyle(hWnd, 4); break;

                case ID_EDIT_NULLSTATE:
                case ID_EDIT_RTL:
                case ID_EDIT_RIGHT:
                case ID_EDIT_VERTICAL:
                case ID_EDIT_CONTEXTDIGITS:
                case ID_EDIT_DIGITSUBSTITUTE:
                case ID_EDIT_ARABICNUMCONTEXT:
                case ID_EDIT_LOGICALORDER:
                case ID_EDIT_DISPLAYZWG:
#ifdef LPK_TEST
                case ID_EDIT_CLIP:
                case ID_EDIT_FIT:
                case ID_EDIT_FALLBACK:
                case ID_EDIT_TAB:
                case ID_EDIT_PIDX:
                case ID_EDIT_HOTKEY:
                case ID_EDIT_PASSWORD:
#endif
                     toggleMenuSetting(hWnd, LOWORD(wParam)); break;

                case ID_EDIT_CARETSTART:
                     gCaretToStart = TRUE;  dispInvalidate(hWnd, 0);  break;

                case ID_EDIT_CARETEND:
                     gCaretToEnd   = TRUE;  dispInvalidate(hWnd, 0);  break;

                case ID_EDIT_UNICODE:
                     editInsertUnicode(); break;

#ifdef LPK_TEST
                case ID_EDIT_LPK:
                     toggleLpkUsage(hWnd, LOWORD(wParam)); break;
#endif

                default:
                    if (LOWORD(wParam) >= ID_EDIT_LANG  &&  LOWORD(wParam) < ID_EDIT_LANG+2048) {
                        setPrimaryLang(hWnd, LOWORD(wParam));
                    } else {
                        return DefWindowProc(hWnd, message, wParam, lParam);
                    }
            }
            break;


        case WM_CHAR:
            editChar(hWnd, LOWORD(wParam));
            break;


        case WM_KEYDOWN:
            editKeyDown(hWnd, LOWORD(wParam));
            break;


        case WM_LBUTTONDOWN:
            Click.fNew = TRUE;
            Click.xPos = LOWORD(lParam);  // horizontal position of cursor
            Click.yPos = HIWORD(lParam);  // vertical position of cursor
            dispInvalidate(hWnd, 0);
            break;

        case WM_RBUTTONDOWN:        // RightClick in windows client area...
            ClientRightButtonDown(hWnd, LOWORD(lParam), HIWORD(lParam));
            break;


        case WM_SETFOCUS:
            CreateCaret(hWnd, NULL, 0, 72);
            SetCaretPos(0,0);
            ShowCaret(hWnd);
            break;
        case WM_KILLFOCUS:
            DestroyCaret();
            break;


        case WM_PAINT:
            ClientPaint(hWnd);
            break;


        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(hWnd, message, wParam, lParam);
    }

    return 0;
}






////    InitInstance - instance specific initialisation
//
//      Create main window
//      Save instance and window handles in application global variables


BOOL InitInstance(HINSTANCE hInst, int nCmdShow)
{
    hInstance = hInst; // Store instance handle in our global variable

    hWnd  = CreateWindow(APPNAME, szAppTitle, WS_OVERLAPPEDWINDOW,
                        CW_USEDEFAULT, 0, CW_USEDEFAULT, 0,
                        NULL, NULL, hInstance, NULL);

    if (!hWnd) {
        return FALSE;
    }

    ShowWindow(hWnd, nCmdShow);
    UpdateWindow(hWnd);

    return TRUE;
}





////    GetUniscribeVersionInfo
//
//      Extracts both the string and binary version info from usp.dll



void CatVersion(char *szAppTitle, WCHAR* fn) {

    void              *pvVerBuf;
    int                cbVerBuf;
    UINT               cbBuf;
    VS_FIXEDFILEINFO  *pFileInfo;
    WCHAR             *pwcFileVersion;
    char               szTitle[80];

    pvVerBuf = 0;

    cbVerBuf = GetFileVersionInfoSizeW(fn, NULL);
    if (!cbVerBuf) {
        return;
    }


    pvVerBuf = malloc(cbVerBuf);
    if (!pvVerBuf) {
        return;
    }


    if (!GetFileVersionInfoW(fn, NULL, cbVerBuf, pvVerBuf)) {
        free(pvVerBuf);
        return;
    }


    if (!VerQueryValueW(pvVerBuf, L"\\", (void**)&pFileInfo, &cbBuf)) {
        free(pvVerBuf);
        return;
    }
    wsprintf(szTitle, ".  '%S' version  %-4.4x %-4.4x %-4.4x %-4.4x  -  ",
             fn,
             HIWORD(pFileInfo->dwFileVersionMS),
             LOWORD(pFileInfo->dwFileVersionMS),
             HIWORD(pFileInfo->dwFileVersionLS),
             LOWORD(pFileInfo->dwFileVersionLS));

    strcat(szAppTitle, szTitle);

    if (!VerQueryValueW(pvVerBuf, L"\\StringFileInfo\\040904B0\\FileVersion", (void**)&pwcFileVersion, &cbBuf)) {
        free(pvVerBuf);
        return;
    }
    WideCharToMultiByte(1256, 0, pwcFileVersion, cbBuf, szTitle, sizeof(szTitle), NULL, NULL);
    strcat(szAppTitle, szTitle);

    free(pvVerBuf);


}






////    InitApplication - common initialisation for all instances
//
//      Initialize window class by filling out a WNDCLASS and
//      calling RegisterClass.


BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS wc;
    HWND     hwnd;


    strcpy(szAppTitle, APPTITLE);


    // Get Uniscribe version info

    CatVersion(szAppTitle, L"lpk.dll");
    CatVersion(szAppTitle, L"usp10.dll");


    // Check for another instance of ourselves

    hwnd = FindWindow (APPNAME, szAppTitle);
    if (hwnd) {
        // We found another version of ourself. Lets defer to it:
        if (IsIconic(hwnd)) {
            ShowWindow(hwnd, SW_RESTORE);
        }
        SetForegroundWindow (hwnd);
        return FALSE;
    }


    // Define application window class

    wc.style         = CS_HREDRAW | CS_VREDRAW;
    wc.lpfnWndProc   = (WNDPROC)WndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon (hInstance, APPNAME);
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
    wc.lpszMenuName  = APPNAME;
    wc.lpszClassName = APPNAME;

    return RegisterClass(&wc);
}








////    WinMain - Application entry point and dispatch loop
//
//


int APIENTRY WinMain(HINSTANCE hInst,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    MSG    msg;
    HANDLE hAccelTable;


    hInstance = hInst;  // Global hInstance

    // Common application initialisation

    if (!InitApplication(hInstance)) {
        return FALSE;
    }


    textClear();
    editClear();


    // Instance initialisation

    if (!InitInstance(hInstance, nCmdShow)) {
        return FALSE;
    }

    hAccelTable = LoadAccelerators (hInstance, APPNAME);



    // Main message loop:

    while (GetMessage(&msg, (HWND) NULL, 0, 0) > 0) {
        if(!IndicTranslate(&msg)){
            TranslateMessage(&msg);
        }
        DispatchMessage(&msg);
    }

    editFreeCaches();

    return (int)msg.wParam;

    hPrevInstance; lpCmdLine; // Prevent 'unused formal parameter' warnings
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk.h ===
/*++

   Copyright (c) 1998-1999 Microsoft Corporation.

*/

#ifndef __lpk__
#define __lpk__
#if _MSC_VER > 1000
#pragma once
#endif

#include <windows.h>
#ifdef __cplusplus
extern "C" {
#endif


/////   LPK.H - Internal header
//
//
#include "usp10.h"
#include "usp10p.h"
#include "lpk_glob.h"


/////   LpkStringAnalyse
//
//      Build Uniscribe input flag structures


HRESULT LpkStringAnalyse(
    HDC               hdc,       //In  Device context (required)
    const void       *pString,   //In  String in 8 or 16 bit characters
    int               cString,   //In  Length in characters
    int               cGlyphs,   //In  Required glyph buffer size (default cString*3/2 + 1)
    int               iCharset,  //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD             dwFlags,   //In  Analysis required
    int               iDigitSubstitute,
    int               iReqWidth, //In  Required width for fit and/or clip
    SCRIPT_CONTROL   *psControl, //In  Analysis control (optional)
    SCRIPT_STATE     *psState,   //In  Analysis initial state (optional)
    const int        *piDx,      //In  Requested logical dx array
    SCRIPT_TABDEF    *pTabdef,   //In  Tab positions (optional)
    BYTE             *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)

    STRING_ANALYSIS **ppsa);     //Out Analysis of string






/////   ftsWordBreak - Support full text search wordbreaker
//
//
//      Mar 9,1997 - [wchao]
//


BOOL WINAPI ftsWordBreak (
    PWSTR  pInStr,
    INT    cchInStr,
    PBYTE  pResult,
    INT    cchRes,
    INT    charset);






/////   Shared definitions for USER code

#define IS_ALTDC_TYPE(h)    (LO_TYPE(h) != LO_DC_TYPE)



/////   LpkInternalPSMtextOut
//
//      Called from LPK_USRC.C

int LpkInternalPSMTextOut(
    HDC           hdc,
    int           xLeft,
    int           yTop,
    const WCHAR  *pwcInChars,
    int           nCount,
    DWORD         dwFlags);






/////   LpkBreakAWord
//
//      Called from LPK_USRC.C

int LpkBreakAWord(
    HDC     hdc,
    LPCWSTR lpchStr,
    int     cchStr,
    int     iMaxWidth);






/////   LpkgetNextWord
//
//      Called from LPK_USRC.C

int LpkGetNextWord(
    HDC      hdc,
    LPCWSTR  lpchStr,
    int      cchCount,
    int      iCharset);






/////   LpkCharsetDraw
//
//      Called from LPK_USRC.C
//
//      Note: Doesn't implement user defined tabstops

int LpkCharsetDraw(
    HDC             hdc,
    int             xLeft,
    int             cxOverhang,
    int             iTabOrigin,
    int             iTabLength,
    int             yTop,
    PCWSTR          pcwString,
    int             cchCount,
    BOOL            fDraw,
    DWORD           dwFormat,
    int             iCharset);






/////   InternalTextOut
//
//

BOOL InternalTextOut(
    HDC           hdc,
    int           x,
    int           y,
    UINT          uOptions,
    const RECT   *prc,
    const WCHAR  *pStr,
    UINT          cbCount,
    const int    *piDX,
    int           iCharset,
    int          *piWidth,
    int           iRequiredWidth);






///// ReadNLSScriptSettings

BOOL ReadNLSScriptSettings(
    void);






/////   InitNLS

BOOL InitNLS();






/////   NLSCleanup

BOOL NLSCleanup(
    void);






/////   Shaping engins IDs.

#define BIDI_SHAPING_ENGINE_DLL     1<<0
#define THAI_SHAPING_ENGINE_DLL     1<<1
#define INDIAN_SHAPING_ENGINE_DLL   1<<4


#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\inc\otllib.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLLIB.H  ********
*
*              Open Type Layout Services Library Header File
*
*       The OTL Services Library is a collection of functions which 
*       assist text processing clients with the task of text layout
*       using the information in OpenType fonts.            - deanb
*
*       Copyright 1996 - 1997. Microsoft Corporation.
*
*       Apr 01, 1996    v 0.1   First release
*       Jul 03, 1996    v 0.2   Sec prop uses feature bit mask, etc.
*       Aug 01, 1996    v 0.2a  OTLTextOut removed from API
*       Oct 11, 1996    v 0.3   Rename to OTL, trimmed to core
*       Jan 15, 1997    v 0.4   Portability renaming, etc.
*       Mar 18, 1997    v 0.5   Param changes, FreeTable, workspace
*       Apr 02, 1997    v 0.6   Feature handles
*       Apr 10, 1997    v 0.7   Otltypes.h, CharsAtPos, funits
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************
***********************************************************************/

/***********************************************************************
*   
*   The Goals of OTL Services 
* 
*   To expose the full functionality of OpenType fonts
*   To be platform independent, but pay particular attention to Windows
*   To support, not take over, text processing with helper functions
*
***********************************************************************/

/***********************************************************************
*   
*   Application Program Interface Overview
*
*   Font Information Functions
*       GetOtlVersion ( )           Returns current library version
*       GetOtlScriptList ( )        Enumerate scripts in a font
*       GetOtlLangSysList ( )       Enumerate language systems in a script
*       GetOtlFeatureDefs ( )       Enumerate features in a language system
*
*   Resource Management Functions
*       FreeOtlResources ( )        Frees all OTL tables and client memory
*
*   Text Information Functions
*       GetOtlLineSpacing ( )       Line spacing for a text run
*       GetOtlBaselineOffset ( )    Baseline adjustment between two scripts
*       GetOtlCharAtPosition ( )    What character is at given (x,y)
*       GetOtlExtentOfChars ( )     What is location of character range
*       GetOtlFeatureParams ( )     Find feature params within a run
*
*   Text Layout Functions
*       SubstituteOtlChars ( )      Do glyph subs according to features
*       SubstituteOtlGlyphs ( )     Do glyph subs according to features
*       PositionOtlGlyphs ( )       Do glyph positioning according to features
*
************************************************************************/

#include "otltypes.h"               // basic type definitions  
#include "otlcbdef.h"               // platform resource function typedefs  

#ifdef __cplusplus
#include "otltypes.inl"             // inline functions to work with OTL Types
#endif

/***********************************************************************
************************************************************************
*   
*           Application Program Interface Data Types
*
*   otlList             General expandable list structure
*   otlRunProp          Description of a font/size/script/langsys
*   otlFeatureDef       Defines features in a font
*   otlFeatureDesc      Describes how a feature is used
*   otlFeatureParam     Reports feature parameters
*   otlFeatureResults   Reports results of layout functions
*   IOTLClient          Client callback interface
*
***********************************************************************
***********************************************************************/


/***********************************************************************
*
*           Run Properties
*
*   This describes font/script/laguage system information for an entire
*   run of text. Multiple runs of text may point to the same properties
*   structure.
*
***********************************************************************/

typedef struct      // shared by multiple lines                                 
{
    IOTLClient*     pClient;        // ptr to client callback interface 
    long            lVersion;       // client expects / library supports 

    otlTag          tagScript;      // this run's script tag 
    otlTag          tagLangSys;     // set to 'dflt' for default LangSys 

    otlMetrics      metr;           // writing direction and font metrics
}
otlRunProp;                       // Hungarian: rp   


/***********************************************************************
************************************************************************
*   
*       Application Program Interface Functions
*
*   
*   Font Information Functions
*   Text Information Functions
*   Text Layout Functions
*
************************************************************************
***********************************************************************/


/***********************************************************************
*
*                       Font Information Functions
*
***********************************************************************/

/***********************************************************************
*
*   GetOtlVersion ( )       Returns current library version
*
*   Output: plVersion       Major version in top 16 bits, minor in bottom
*                           e.g. 0x00010002 = version 1.2
*
*   The client should put the smaller of this value and the version for
*   which it was written into the prpRunProp-lVersion field.
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlVersion 
( 
    long* plVersion
);


/***********************************************************************
*
*   GetOtlScriptList ( )        Enumerate scripts in a font
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pClient      Client callback data
*           pliWorkspace            Workspace memory: initialize zero-length
*
*   Output: plitagScripts          List of script tags supported in font
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlScriptList 
( 
    const otlRunProp*   pRunProps,   
    otlList*            pliWorkspace,    
    otlList*            plitagScripts
);


/***********************************************************************
*
*   GetOtlLangSysList ( )       Enumerate language systems in a script
*
*   Input:  pRunProps->lVersion    Highest shared version
*           pRunProps->pClient     Client callback data
*           pRunProps->tagScript   Script tag
*           pliWorkspace           Workspace memory: initialize zero-length
*
*   Output: plitagLangSys          List of language systems supported in script
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlLangSysList 
( 
    const otlRunProp*   pRunProps,    
    otlList*            pliWorkspace,    
    otlList*            plitagLangSys
);


/***********************************************************************
*
*   GetOtlFeatureDefs ( )       Enumerate features in a language system 
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pClient      Client callback interface
*           pRunProps->tagScript    Script tag
*           pRunProps->tagLangSys   Set to 'dflt' for default langsys
*           pliWorkspace            Workspace memory: initialize zero-length
*
*   Output: pliFDefs           List of features supported by langsys
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlFeatureDefs 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,    
    otlList*            pliFDefs
);


/***********************************************************************
*
*                       Resource Management Functions
*
***********************************************************************/

/***********************************************************************
*
*   FreeOtlResources ( )       Free OTL tables and client memory 
*
*   Input:  pRunProps->lVersion     Highest shared version
*           pRunProps->pvClient     Client callback data
*           pliWorkspace            Workspace
*
*   Frees all OTL Tables and pointer to client memory that may be stored 
*   in run workspace
*
***********************************************************************/

OTL_EXPORT otlErrCode FreeOtlResources 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace   
);


/***********************************************************************
*
*                       Text Information Functions
*
***********************************************************************/

/***********************************************************************
*
*   GetOtlLineSpacing ( )       Line spacing for a text run
*
*   Input:  pRunProps           Text run properties (script & langsys)
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply (may affect spacing)
*
*   Output: pdvMax               Typographic ascender (horiz layout)
*           pdvMin               Typographic descender (horiz layout)
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlLineSpacing 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,
    
    long* pdvMax, 
    long* pdvMin
);


/***********************************************************************
*
*   GetOtlBaselineOffsets ( )   Baseline adjustment between two scripts
*
*   Input:  pRunProps           Text run properties (script & langsys)
*           pliWorkspace        Workspace memory: initialize zero-length
*
*   Output: pliBaselines        List of baseline tags and values
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlBaselineOffsets 
( 
    const otlRunProp*   pRunProps,   
    otlList*            pliWorkspace,    
    otlList*            pliBaselines
);


/***********************************************************************
*
*   GetOtlCharAtPosition ( )    What character is at given position
*
*   Input:  pRunProps           Text run properties (horiz/vert layout)
*           pliWorkspace        Workspace memory: initialize zero-length
*           pliCharMap          Unicode chars --> glyph indices mapping
*           pliGlyphInfo        Glyphs and flags
*           pliduGlyphAdv       Advance array
*
*           duAdv               Hit coordinate in advance direction
*   
*   Output: piChar              Index of character at position
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlCharAtPosition 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,    

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    long                duAdv,

    USHORT*             piChar
);


/***********************************************************************
*
*   GetOtlExtentOfChars ( )   What is location of character range
*
*   Input:  pRunProp          Text run properties (horiz/vert layout)
*           pliWorkspace      Workspace memory: initialize zero-length
*           pliCharMap        Unicode chars --> glyph indices mapping
*           pliGlyphInfo      Glyphs and flags list
*           pliduGlyphAdv     Advance array in layout direction
*           ichFirstChar      Index of first character
*           ichLastChar       Index of last character
*   
*   Output: piglfStartIdx        Index into Glyph list for first char
*           piglfEndIdx          Index into Glyph list for last char
*           pduStartPos          Left or Top of first char (right for RTL)
*           pduEndPos            Right or Bottom of last char (left for RTL)
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlExtentOfChars 
( 
    const otlRunProp*   pRunProp,
    otlList*            pliWorkspace,    

    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,
    const otlList*      pliduGlyphAdv,

    USHORT              ichFirstChar,
    USHORT              ichLastChar,
    
    long*               pduStartPos,
    long*               pduEndPos
);


/***********************************************************************
*
*   GetOtlFeatureParams ( )     Used to find glyph variants or feature parameter
*
*   Input:  pRunProps          Text run properties
*           pliWorkspace       Workspace memory: initialize zero-length
*           pliCharMap         Unicode chars --> glyph indices mapping
*           pliGlyphInfo       Text glyph list and glyph flag list 
*                               (chars/glyph and type)
*           tagFeature         Feature to examine
*
*   Output: plGlobalParam      Feature wide parameter
*           pliFeatureParams   List of character level feature params
*
*   Note:   Reserved for future use
*
***********************************************************************/

OTL_EXPORT otlErrCode GetOtlFeatureParams 
( 
    const otlRunProp*   pRunProps,
    otlList*            pliWorkspace,   

    const otlList*      pliChars,
    const otlList*      pliCharMap,
    const otlList*      pliGlyphInfo,

    otlTag              tagFeature,
    
    long*               plGlobalParam,
    otlList*            pliFeatureParams
);


/***********************************************************************
*
*                       Text Layout Functions
*
***********************************************************************/


/***********************************************************************
*
*   SubstituteOtlChars ( )      Do glyph subs according to features
*   SubstituteOtlGlyphs ( )     Do glyph subs according to features
*
*   Input:  pRunProps           Text run properties
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply

*           pliChars            Unicode chars in a text run

*           pliCharMap          Unicode chars  --> glyph indices mapping
*           pliGlyphInfo        Glyphs in a text run and properties
*                               (for SubstituteOtlGlyphs -- in/out)
*
*   Output: pliCharMap
*           pliGlyphInfo        Modified by substitution
*           pliFResults         Results per feature descriptor(length = size of FSet)
*
***********************************************************************/

OTL_EXPORT otlErrCode SubstituteOtlChars 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    const otlList*          pliChars,

    otlList*                pliCharMap,
    otlList*                pliGlyphInfo,
    otlList*                pliFResults
);

OTL_EXPORT otlErrCode SubstituteOtlGlyphs 
( 
    const otlRunProp*       pRunProp,
    otlList*                liWorkspace,   
    const otlFeatureSet*    pFSet,

    otlList*                pliCharMap,
    otlList*                pliGlyphInfo,
    otlList*                pliFResults
);


/***********************************************************************
*
*   PositionOtlGlyphs ( )       Do glyph positioning according to features
*   RePositionOtlGlyphs ( )     Adjust glyph positioning according to features
*
*   Input:  pRunProps           Text run properties
*           pliWorkspace        Workspace memory: initialize zero-length
*           pFSet               Which features apply
*           pliCharMap          Unicode chars  --> glyph indices mapping
*           pliGlyphInfo        Post-substituted glyphs and flags
*
*   Output: pliduGlyphAdv       Glyph advances 
*                               (RePositionOtlGlyphs -- in/out)
*           pliGlyphPlacement   Horizontal and vertical glyph placement
*                               (RePositionOtlGlyphs -- in/out)
*           pliFResults         Results per feature descriptor
*
***********************************************************************/

OTL_EXPORT otlErrCode PositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,

    otlList*            pliduGlyphAdv,
    otlList*            pliplcGlyphPlacement,

    otlList*            pliFResults
);


OTL_EXPORT otlErrCode RePositionOtlGlyphs 
( 
    const otlRunProp*       pRunProps,
    otlList*                pliWorkspace,    
    const otlFeatureSet*    pFSet,

    otlList*            pliCharMap,
    otlList*            pliGlyphInfo,

    otlList*            pliduGlyphAdv,
    otlList*            pliplcGlyphPlacement,

    otlList*            pliFResults
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\cstest\textrep.cxx ===
////    TEXTREP - Text representation
//
//      For this demonstration, text representation is rather simple
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//



#include "precomp.hxx"
#include "uspglob.hxx"




////    textClear - Initialise text buffer
//
//

BOOL textClear() {


    HMODULE    hmod;
    HRSRC      hrsrc;
    HGLOBAL    hglob;
    WCHAR     *pwcIt;  // Initial text
    int        i;

    hmod    = GetModuleHandle(NULL);
    hrsrc   = FindResource(hmod, (LPCSTR)110, "INITIALTEXT");
    hglob   = LoadResource(hmod, hrsrc);
    iBufLen = SizeofResource(hmod, hrsrc) - 2;  // Remove leading byte order mark
    pwcIt   = (WCHAR*) LockResource(hglob);

    if (!hmod  ||  !hrsrc  ||  !hglob  ||  !pwcIt  ||  !iBufLen) {
        ASSERTS(hmod,    "GetModuleHandle(usptest.exe) failed");
        ASSERTS(hrsrc,   "FindResource(110, INITIALTEXT) failed");
        ASSERTS(hglob,   "LoadResource(110, INITIALTEXT) failed");
        ASSERTS(pwcIt,   "LockResource(110, INITIALTEXT) failed");
        ASSERTS(iBufLen, "INITIALTEXT length zero");
    }

    if (iBufLen >= sizeof(wcBuf)) {
        iBufLen = sizeof(wcBuf);
    }

    memcpy(wcBuf, pwcIt+1, iBufLen);
    iBufLen <<= 1;  // Bytes to characters

    i = 0;
    while (i < iBufLen  &&  wcBuf[i]) {
        i++;
    }
    iBufLen = i;


    return TRUE;
}






////    textInsert - Insert new characters in the buffer at the given insertion point
//


BOOL textInsert(int iPos, PWCH pwc, int iLen) {

    if (   iPos < 0
        || iLen < 0
        || iPos + iLen >= MAX_TEXT
        || iPos > iBufLen) {
        return FALSE;
    }


    // Shift text above iPos up the buffer

    if (iPos < iBufLen) {
        memmove(wcBuf+iPos+iLen, wcBuf+iPos, sizeof(WCHAR)*(iBufLen-iPos));
    }


    // Copy new text into buffer

    memcpy(wcBuf+iPos, pwc, sizeof(WCHAR)*iLen);
    iBufLen += iLen;



    return TRUE;
}






////    textDelete - Delete text from buffer
//


BOOL textDelete(int iPos, int iLen) {

    if (   iPos < 0
        || iLen < 0
        || iPos + iLen >= MAX_TEXT
        || iPos > iBufLen) {
        return FALSE;
    }


    if (iPos + iLen >= iBufLen) {
        iBufLen = iPos;
        return TRUE;
    }


    memcpy(wcBuf + iPos, wcBuf + iPos + iLen, sizeof(WCHAR) * (iBufLen - (iPos + iLen)));
    iBufLen -= iLen;

    return TRUE;
}






////    ParseForward
//
//      Returns type and length of next character, end of line, or markup
//
//      entry   iPos = index of first character of item to parse


BOOL textParseForward(int iPos, PINT piLen, PINT piType, PINT piVal) {

    int i;
    int v;

    if (   iPos < 0
        || iPos > iBufLen) {
        return FALSE;
    }

    if (iPos == iBufLen) {
        *piLen  = 0;
        *piType = P_EOT;
        return TRUE;
    }

    switch (wcBuf[iPos]) {

        case '[':
            i = iPos+1;
            v = 0;
            while (   i < iBufLen
                   && wcBuf[i] >= '0'
                   && wcBuf[i] <= '9') {
                v *= 10;
                v += wcBuf[i] - '0';
                i++;
            }
            if (i < iBufLen && wcBuf[i] == ']') {
                *piType = P_MARKUP;
                *piVal  = v;
                *piLen  = i+1 - iPos;
            } else {
                *piType = P_CHAR;
                *piLen = 1;
            }
            break;

        case 0x000D:
            if (iPos+1 < iBufLen && wcBuf[iPos+1] == 0x000A) {
                *piType = P_CRLF;
                *piLen  = 2;
            } else {
                *piType = P_CHAR;
                *piLen  = 1;
            }
            break;

        default:
            *piType = P_CHAR;
            *piLen  = 1;
            break;
    }

    return TRUE;
}






////    ParseBackward
//
//      Returns type and length of previous character, end of line, or markup
//
//      entry   iPos = index of first character after item to parse


BOOL textParseBackward(int iPos, PINT piLen, PINT piType, PINT piVal) {

    int i;
    int v;
    int m; // Multiplier

    if (   iPos < 0
        || iPos > iBufLen) {
        return FALSE;
    }

    if (iPos == 0) {
        *piLen  = 0;
        *piType = P_BOT;
        return TRUE;
    }

    iPos--;

    switch (wcBuf[iPos]) {

        case ']':
            i = iPos-1;
            v = 0;
            m = 1;
            while (   i >= 0
                   && wcBuf[i] >= '0'
                   && wcBuf[i] <= '9') {
                v += m * (wcBuf[i] - '0');
                m *= 10;
                i--;
            }
            if (i >= 0 && wcBuf[i] == '[') {
                *piType = P_MARKUP;
                *piVal  = v;
                *piLen  = iPos - i + 1;
            } else {
                *piType = P_CHAR;
                *piLen = 1;
            }
            break;

        case 0x000A:
            if (iPos-1 >= 0 && wcBuf[iPos-1] == 0x000D) {
                *piType = P_CRLF;
                *piLen  = 2;
            } else {
                *piType = P_CHAR;
                *piLen  = 1;
            }
            break;

        default:
            *piType = P_CHAR;
            *piLen  = 1;
            break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\cstest\textedit.cxx ===
////    TEXTEDIT.C
//
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//



#include "precomp.hxx"
#include "uspglob.hxx"





void SetLogFont(PLOGFONTA plf, int iHeight, int iWeight, int iItalic, char *pcFaceName) {
    plf->lfHeight = iHeight;
    plf->lfWeight = iWeight;
    plf->lfItalic = (BYTE) iItalic;
    lstrcpy(plf->lfFaceName, pcFaceName);
    plf->lfOutPrecision   = OUT_STROKE_PRECIS;
    plf->lfClipPrecision  = CLIP_STROKE_PRECIS;
    plf->lfQuality        = DRAFT_QUALITY;
    plf->lfPitchAndFamily = VARIABLE_PITCH;
    if (fVertical) {
        plf->lfEscapement     = 2700;
        plf->lfOrientation    = 2700;
    } else {
        plf->lfEscapement     = 0;
        plf->lfOrientation    = 0;
    }
}





void initStyle(int iStyle, int iHeight, int iWeight, int iItalic, char *pcFaceName) {

    SetLogFont(&ss[iStyle].rs.lf, iHeight, iWeight, iItalic, pcFaceName);
    ss[iStyle].rs.hf = CreateFontIndirect(&ss[iStyle].rs.lf);
    ss[iStyle].rs.sc = NULL;
    ss[iStyle].fInUse = TRUE;
}






void editClear() {

    iCurChar   = 0;
    Click.fNew = FALSE;

    // Initialise all styles

    initStyle(0, 72, 400, 0, "Times New Roman");
    initStyle(1, 72, 400, 1, "Times New Roman");
    initStyle(2, 48, 400, 0, "Arial");
    initStyle(3, 72, 400, 1, "Arial");
    initStyle(4, 72, 400, 0, "Cordia New");
}






void editFreeCaches() {
    int i;
    for (i=0; i<5; i++) {
        if (ss[i].rs.sc) {
            ScriptFreeCache(&ss[i].rs.sc);
        }
    }
}






BOOL NewLine(HWND hWnd) {

    if (!textInsert(iCurChar, L"\r\n", 2)) {
        return FALSE;
    }

    dispInvalidate(hWnd, iCurChar);
    iCurChar+=2;

    return TRUE;
}






BOOL editKeyDown(HWND hWnd, WCHAR wc) {

    int iLen;
    int iType;
    int iVal;


    switch(wc) {

        case VK_LEFT:
            if (iCurChar) {
                if (!textParseBackward(iCurChar, &iLen, &iType, &iVal))
                    return FALSE;
                iCurChar -= iLen;
                dispInvalidate(hWnd, iCurChar);
            }
            break;

        case VK_RIGHT:
            if (iCurChar < textLen()) {
                if (!textParseForward(iCurChar, &iLen, &iType, &iVal))
                    return FALSE;
                iCurChar += iLen;
                dispInvalidate(hWnd, iCurChar);
            }
            break;

        case VK_HOME:
            iCurChar = 0;
            dispInvalidate(hWnd, iCurChar);
            break;

        case VK_END:
            iCurChar = textLen();
            dispInvalidate(hWnd, iCurChar);
            break;

        case VK_DELETE:
            if (iCurChar < textLen()) {
                if (!textParseForward(iCurChar, &iLen, &iType, &iVal))
                    return FALSE;
                if (iLen) {
                    if (!textDelete(iCurChar, iLen))
                        return FALSE;
                    dispInvalidate(hWnd, iCurChar);
                }
            }
            break;
    }

    return TRUE;
}






////    HexToInt
//
//


int HexToInt(char szHex[]) {

    int i;
    int h;
    //int d;

    i = 0;
    h = 0;
    //d = 0;

    while (szHex[i]) {

        if (szHex[i] >= '0'  &&  szHex[i] <= '9') {

            h = h*16 + szHex[i] - '0';
            //d = d*10 + szHex[i] - '0';

        } else if (szHex[i] >= 'a'  &&  szHex[i] <= 'f') {

            h = h*16 + 10 + szHex[i] - 'a';

        } else if (szHex[i] >= 'A'  &&  szHex[i] <= 'F') {

            h = h*16 + 10 + szHex[i] - 'A';

        } else if (szHex[i] != ' '  &&  szHex[i] != ',') {

            return -1;
        }

        i++;
    }


    return h;
}






////    UnicodeDlgProc
//
//      Support insertion of Unicode characters


INT_PTR CALLBACK UnicodeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam) {

    char  szCodePoint[20];
    int   iCodePoint;

    switch (uMsg) {

        case WM_INITDIALOG:
            ShowWindow (hDlg, SW_SHOW);
            return TRUE;

        case WM_COMMAND:

            switch (LOWORD(wParam)) {

                case IDOK:

                    GetDlgItemTextA(hDlg, IDC_CODEPOINT, szCodePoint, sizeof(szCodePoint));
                    iCodePoint = (WORD) HexToInt(szCodePoint);

                    if (iCodePoint >= 0) {
                        textInsert(iCurChar, (WCHAR*)&iCodePoint, 1);
                        dispInvalidate(hWnd, iCurChar);
                        iCurChar++;
                    }

                    // FALL THROUGH

                case IDCANCEL:
                    EndDialog(hDlg, TRUE);
                    return TRUE;
            }
            break;
    }

    return FALSE;

    UNREFERENCED_PARAMETER(lParam);
}






////    editInsertUnicode
//
//      Allow entry of any Unicode character by offering a simple dialog


void editInsertUnicode() {

    DialogBox(hInstance, "Unicode", hWnd, UnicodeDlgProc);
}






void TranslateCharToUnicode(PWCH pwc) {

    int  iCP;
    char   c;

    switch (PRIMARYLANGID(LOWORD(GetKeyboardLayout(NULL)))) {
        case LANG_ARABIC:   iCP = 1256;   break;
        case LANG_HEBREW:   iCP = 1255;   break;
        case LANG_THAI:     iCP =  874;   break;
        case LANG_HINDI:    return;  // Hindi we don't touch
        default:            iCP = 1252;   break;
    }

    c = (char) *pwc;
    MultiByteToWideChar(iCP, 0, &c, 1, pwc, 1);
}






BOOL editChar(HWND hWnd, WCHAR wc) {

    int iLen;
    int iType;
    int iVal;

    switch(wc) {

        case VK_RETURN:
            if (!textInsert(iCurChar, L"\r\n", 2))
                return FALSE;
            dispInvalidate(hWnd, iCurChar);
            iCurChar+=2;
            break;

        case VK_BACK:
            if (iCurChar) {
                if (!textParseBackward(iCurChar, &iLen, &iType, &iVal))
                    return FALSE;
                if (iLen) {
                    iCurChar -= iLen;
                    if (!textDelete(iCurChar, iLen))
                        return FALSE;
                    dispInvalidate(hWnd, iCurChar);
                }
            }
            break;

        default:

            if(!((wc >= 0x0900 && wc < 0x0d80)
                  || wc == 0x200c
                  || wc == 0x200d)){
                TranslateCharToUnicode(&wc);
            }

            if (!textInsert(iCurChar, &wc, 1)) {
                return FALSE;
            }
            dispInvalidate(hWnd, iCurChar);
            iCurChar++;
            break;
    }

    return TRUE;
}






////    editStyle
//
//      Use Choosefont dialog to set style


BOOL editStyle(HWND hWnd, int irs) {
    ss[irs].rs.cf.lStructSize = sizeof(ss[irs].rs.cf);
    ss[irs].rs.cf.lpLogFont = &ss[irs].rs.lf;
    ss[irs].rs.cf.Flags =
        CF_EFFECTS |
        CF_SCREENFONTS |
        CF_INITTOLOGFONTSTRUCT;

    if (ChooseFontA(&ss[irs].rs.cf)) {
        ss[irs].fInUse = TRUE;
        DeleteObject(ss[irs].rs.hf);
        if (fVertical) {
            ss[irs].rs.lf.lfEscapement     = 2700;
            ss[irs].rs.lf.lfOrientation    = 2700;
        }
        ss[irs].rs.hf = CreateFontIndirect(&ss[irs].rs.lf);
    } else {
        ss[irs].fInUse = FALSE;
    }

    ScriptFreeCache(&ss[irs].rs.sc);

    dispInvalidate(hWnd, iCurChar);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\inc\otltypes.h ===
/***********************************************************************
************************************************************************
*
*                    ********  OTLTYPES.H  ********
*
*              Open Type Layout Services Library Header File
*
*       This module contains basic OTL type and structure definitions.
*
*       Copyright 1997. Microsoft Corporation.
*
*       Apr 10, 1997    v 0.7   First release
*       Jul 28, 1997    v 0.8   hand off
*
************************************************************************
***********************************************************************/

/***********************************************************************
*
*           OTL Basic Type Definitions
*
***********************************************************************/

typedef  unsigned short	otlGlyphID;            // hungarian: glf  
typedef  unsigned short	otlGlyphFlags;         // hungarian: gf  
typedef  signed long	otlTag;                // hungarian: tag   
typedef  signed long	otlErrCode;            // hungarian: erc 

#ifndef		BYTE
#define		BYTE	unsigned char
#endif

#ifndef		WCHAR
#define		WCHAR	unsigned short
#endif

#ifndef		USHORT
#define		USHORT	unsigned short
#endif

#ifndef		ULONG
#define		ULONG	unsigned long
#endif

#ifndef     NULL
#define     NULL    (void*)0
#endif

#ifndef     FALSE
#define     FALSE   0
#endif
#ifndef     TRUE
#define     TRUE    -1
#endif

#define		OTL_MAX_CHAR_COUNT	        32000
#define     OTL_CONTEXT_NESTING_LIMIT   100

#define     OTL_PRIVATE     static
#define     OTL_PUBLIC      
#define     OTL_EXPORT      __declspec( dllexport ) /* needs portability work	*/

#define     OTL_DEFAULT_TAG     0x746C6664

#define     OTL_GSUB_TAG        0x42555347
#define     OTL_GPOS_TAG        0x534F5047
#define     OTL_JSTF_TAG        0x4654534A
#define     OTL_BASE_TAG        0x45534142
#define     OTL_GDEF_TAG        0x46454447


/***********************************************************************
*
*                               OTL List
*
*   This is used to represent a number of different lists of data (such
*   as characters, glyphs, attributes, coordinates) that make up a text run
*
***********************************************************************/

#ifdef __cplusplus

class otlList							
{
private:

    void*   pvData;					// data pointer  
    USHORT  cbDataSize;				// bytes per list element 
    USHORT  celmMaxLen;             // allocated list element count   
    USHORT  celmLength;             // current list element count   

public:
		otlList (void* data, USHORT size, USHORT len, USHORT maxlen)
			: pvData(data), cbDataSize(size), celmLength(len), celmMaxLen(maxlen)
		{}
		
		inline BYTE* elementAt(USHORT index);
		inline const BYTE* readAt(USHORT index) const;

		inline void insertAt(USHORT index, USHORT celm);
		inline void deleteAt(USHORT index, USHORT celm);
		inline void append(const BYTE* element);
   
		void empty() { celmLength = 0; }   
   
		USHORT length() const { return celmLength; }
 		USHORT maxLength() const {return celmMaxLen; } 
		USHORT dataSize() const {return cbDataSize; }
		const void*  data() const {return pvData; }

		inline void reset(void* pv, USHORT cbData, USHORT celmLen, USHORT celmMax);
	 
};									// Hungarian: lixxx  

#else 

typedef struct otlList							
{

    void*   pvData;					// data pointer  
    USHORT  cbDataSize;				// bytes per list element 
    USHORT  celmMaxLen;             // allocated list element count   
    USHORT  celmLength;             // current list element count   

}
otlList; 

#endif

/*
 *  When an OTL List is used for a function input parameter, 
 *  the celmMaxLength field is not used. When an OTL List is
 *  used for a function output parameter, the celmMaxLength
 *  field is used to determine the memory available for the
 *  output data. If more memory is required than available,
 *  the function returns an OTL_ERR_INSUFFICIENT_MEMORY error
 *  message, and the celmLength field is set the the required
 *  memory size.
 *
 *  AndreiB(5-29-98) We're gonna switch to the model where OTL Services
 *  can request the client to realocate the list to the right size.
 *
 */

/**********************************************************************/


/***********************************************************************
*
*           Shared Structure Definitions
*
***********************************************************************/

typedef struct
{
	otlGlyphID		glyph;			// glyph ID
	otlGlyphFlags	grf;			// glyph flags
	
	USHORT			iChar;			// starting character index
	USHORT			cchLig;			// how many characters it maps to
} 
otlGlyphInfo;					// Hungarian glinf  


/***********************************************************************
*
*           GlyphFlags masks and settings
*
***********************************************************************/

#define     OTL_GFLAG_CLASS		0x000F      // Base, mark, ligature, component 
 
#define     OTL_GFLAG_SUBST     0x0010      // Glyph was substituted  
#define     OTL_GFLAG_POS       0x0020      // Glyph was positioned 

#define     OTL_GFLAG_RESERVED	0xFF00      // reserved

typedef enum 
{
	otlUnassigned		= 0,
	otlBaseGlyph		= 1,
	otlLigatureGlyph 	= 2,
	otlMarkGlyph		= 3,
	otlComponentGlyph	= 4
}
otlGlyphClass;

/***********************************************************************
*
*           Positioning structures
*
*   These structures (along with advance widths) are used in positioning
*	methods to relay font metrics/writing direction information and get 
*	glyph positions back.
* 
***********************************************************************/

typedef enum
{
	otlRunLTR	=	0,
	otlRunRTL	=	1,
	otlRunTTB	=	2,
	otlRunBTT	=	3
}
otlLayout;

typedef struct
{
    otlLayout		layout;		// horiz/vert left/right layout 

    USHORT			cFUnits;        // font design units per Em 
    USHORT			cPPEmX;         // horizontal pixels per Em 
    USHORT			cPPEmY;         // vertical pixels per Em 

} 
otlMetrics;						// Hungarian: metr

typedef struct
{
	long			dx;
	long			dy;

} 
otlPlacement;					// Hungarian: plc  

/***********************************************************************
*
*           Feature Definition
*
*   These are returned by the GetOtlFeatureDefs call to identify
*   the set of features in a font, and are included in the Run
*   Property to identify the feature set
* 
***********************************************************************/

typedef struct
{             
    otlTag          tagFeature;             // feature tag  
    USHORT			grfDetails;             // details of this feature  
} 
otlFeatureDef;									// Hungarian: fdef  

#define     OTL_FEAT_FLAG_GSUB      0x0001    // does glyph substitution 
#define     OTL_FEAT_FLAG_GPOS      0x0002    // does glyph positioning 

/* The following flags are reserved for future use
*/
#define     OTL_FEAT_FLAG_ALTER     0x0004    // has alternate glyphs 
#define     OTL_FEAT_FLAG_PARAM     0x0008    // uses a feature parameter 

#define     OTL_FEAT_FLAG_EXP       0x0010    // may expand the glyph string 
#define     OTL_FEAT_FLAG_SPEC      0x0020    // uses special processing 


/***********************************************************************
*
*           Feature Description
*
*   This structure describes the use of one feature within a text run
* 
***********************************************************************/

typedef struct
{             
    otlTag          tagFeature;             // feature tag 
    long            lParameter;             // 1 to enable, 0 to disable, 
											// n for param 
    USHORT			ichStart;				// start of feature range 
    USHORT			cchScope;				// size of feature range 
} 
otlFeatureDesc;								// Hungarian: fdsc 


/***********************************************************************
*
*           Feature Set
*
*   This structure describes the set of features applied to a text run
* 
***********************************************************************/
#ifdef __cplusplus

struct otlFeatureSet
{             
    otlList         liFeatureDesc;		// list of feature descriptions 
    USHORT			ichStart;           // offset into character list 
    USHORT			cchScope;           // size of text run 

    otlFeatureSet() 
    : liFeatureDesc(NULL, 0, 0, 0), ichStart(0), cchScope(0) 
    {}

};								// Hungarian: fset 

#else

typedef struct 
{             
    otlList         liFeatureDesc;		// list of feature descriptions 
    USHORT			ichStart;           // offset into character list 
    USHORT			cchScope;           // size of text run 

} otlFeatureSet;								// Hungarian: fset 

#endif
/***********************************************************************
*
*           Feature Result
*
*   This structure is used to report results from applying a feature
*	descriptor
* 
***********************************************************************/

typedef struct
{             
    const otlFeatureDesc*	pFDesc;					// feature descriptor 
	USHORT					cResActions;			// out: count of actions undertaken 
} 
otlFeatureResult;								// Hungarian: fres 


/***********************************************************************
*
*           Feature Parameter
*
*   This structures are returned by GetOtlFeatureParams to report 
*	character level feature parameters
* 
***********************************************************************/

typedef struct
{             
    long            lParameter;             // feature parameter  
    USHORT			ichStart;				// character start  
    USHORT			cchScope;				// character length  
} 
otlFeatureParam;								// Hungarian: fprm  



/***********************************************************************
*
*           Base Value
*
*   This structure returns the tag and coordinate of one baseline
* 
***********************************************************************/

typedef struct
{             
    otlTag      tag;					// baseline tag 
    long        lCoordinate;            // baseline coordinate 
} 
otlBaseline;							// Hungarian: basl  



/***********************************************************************
*   
*       Application Program Interface Function Return Codes 
*
***********************************************************************/

inline USHORT ERRORLEVEL(otlErrCode erc) { return (USHORT)((erc & 0xFF00) >> 8); }

#define		OTL_ERRORLEVEL_MINOR			1

#define     OTL_SUCCESS						0x0000
#define		OTL_ERROR						0xFFFF

#define     OTL_ERR_TABLE_NOT_FOUND         0x0101
#define     OTL_ERR_SCRIPT_NOT_FOUND        0x0102
#define     OTL_ERR_LANGSYS_NOT_FOUND       0x0103
#define     OTL_ERR_FEATURE_NOT_FOUND       0x0104

#define		OTL_ERR_VERSION_OUT_OF_DATE		0x0301
#define		OTL_ERR_BAD_FONT_TABLE			0x0302
#define     OTL_ERR_CONTEXT_NESTING_TOO_DEEP 0x0303

#define     OTL_ERR_INCONSISTENT_RUNLENGTH  0x0401
#define     OTL_ERR_BAD_INPUT_PARAM         0x0402
#define     OTL_ERR_POS_OUTSIDE_TEXT        0x0403

#define     OTL_ERR_INSUFFICIENT_MEMORY     0x0501
#define     OTL_ERR_GLYPHIDS_NOT_FOUND      0x0502
#define     OTL_ERR_ADVANCE_NOT_FOUND       0x0503

#define		OTL_ERR_CANNOT_REENTER			0x0901

#define     OTL_ERR_UNDER_CONSTRUCTION      0x1001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_edit.c ===
////    LPK_EDIT - Edit control support - C interface
//
//      Handles all callouts from the standard US edit control.
//
//      David C Brown (dbrown) 17th Nov 1996.
//
//      Copyright (c) 1996-1997 Microsoft Corporation. All right reserved.




/*
 * Core NT headers
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#define NONTOSPINTERLOCK
#include <ntosp.h>

/*
 * Standard C runtime headers
 */
#include <limits.h>
#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

/*
 * NtUser Client specific headers
 */
#include "usercli.h"

#include <ntsdexts.h>
#include <windowsx.h>
#include <newres.h>
#include <asdf.h>

/*
 * Complex script language pack
 */
#include "lpk.h"
#include "lpk_glob.h"


// Don't link directly to NtUserCreateCaret
#undef CreateCaret

///     Unicode control characters
//

#define U_TAB   0x0009
#define U_FS    0x001C
#define U_GS    0x001D
#define U_RS    0x001E
#define U_US    0x001F
#define U_ZWNJ  0x200C
#define U_ZWJ   0x200D
#define U_LRM   0x200E
#define U_RLM   0x200F
#define U_LRE   0x202A
#define U_RLE   0x202B
#define U_PDF   0x202C
#define U_LRO   0x202D
#define U_RLO   0x202E
#define U_ISS   0x206A
#define U_ASS   0x206B
#define U_IAFS  0x206C
#define U_AAFS  0x206D
#define U_NADS  0x206E
#define U_NODS  0x206F


#define TRACE(a,b)
#define ASSERTS(a,b)
#define ASSERTHR(a,b)






/***************************************************************************\
* BOOL ECIsDBCSLeadByte( PED ped, BYTE cch )
*
*   IsDBCSLeadByte for Edit Control use only.
*
* History: 18-Jun-1996 Hideyuki Nagase
\***************************************************************************/

BOOL ECIsDBCSLeadByte(PED ped, BYTE cch)
{
    int i;

    if (!ped->fDBCS || !ped->fAnsi)
        return (FALSE);

    for (i = 0; ped->DBCSVector[i]; i += 2) {
        if ((ped->DBCSVector[i] <= cch) && (ped->DBCSVector[i+1] >= cch))
            return (TRUE);
    }

    return (FALSE);
}


////    GetEditAnsiConversionCharset - Figure a proper charset to MBTWC ANSI edit control's data
//
//      In some Far East settings, they associate the symbol font to their ANSI codepage for
//      backward compatibility (this is not the case for Japanese though), otherwise we convert
//      using page 0. Currently Uniscribe glyph table maps SYMBOLIC_FONT to 3 pages - U+00xx,
//      U+F0xx and the system's ACP page.
//
//      For Unicode control returns -1


int GetEditAnsiConversionCharset(PED ped)
{
    int iCharset = ped->fAnsi ? ped->charSet : -1;

    if (iCharset == SYMBOL_CHARSET || iCharset == OEM_CHARSET)
    {
        iCharset = ANSI_CHARSET;    // assume page U+00xx

    }

    if (iCharset == ANSI_CHARSET && ped->fDBCS)
    {
        // In Chinese system, there is font association to map symbol to ACP
        // (QueryFontAssocStatus returns non-null). More detail please refer
        // to USER's ECGetDBCSVector(...)

        CHARSETINFO csi;

        if (TranslateCharsetInfo((DWORD*)UIntToPtr(g_ACP), &csi, TCI_SRCCODEPAGE))
            iCharset = csi.ciCharset;
    }

    return iCharset;
}




////    MBCPtoWCCP - Translate multi-byte caret position to wide char caret position
//
//      Translates from a multibyte caret position specified as a byte offset
//      into an 8 bit string, to a widechar caret position, returned as a
//      word offset into a 16 bit character string.
//
//      If the codepage isn't a DBCS, the imput offset is returned unchanged.
//
//      Returns E_FAIL if icpMbStr addresses the second byte of a double byte character


HRESULT MBCPtoWCCP(
    PED     ped,            // In  - Edit control structure
    BYTE   *pbMbStr,        // In  - Multi byte string
    int     icpMbStr,       // In  - Byte offset of caret in multibyte string
    int    *picpWcStr) {    // Out - Wide char caret position


    if (!ped->fDBCS  || !ped->fAnsi) {

        *picpWcStr = icpMbStr;
        return S_OK;
    }


    // Scan through DBCS string counting characters

    *picpWcStr = 0;
    while (icpMbStr > 0) {

        if (ECIsDBCSLeadByte(ped, *pbMbStr)) {

            // Character takes two bytes

            icpMbStr -= 2;
            pbMbStr  += 2;

        } else {

            // Character takes one byte

            icpMbStr--;
            pbMbStr++;
        }

        (*picpWcStr)++;
    }

    return icpMbStr == 0 ? S_OK : E_FAIL;
}





////    WCCPtoMBCP - Translate wide char caret position to multi-byte caret position
//
//      Translates from a widechar caret position specified as a word offset
//      into a 16 bit string, to a multibyte caret position, returned as a
//      byte offset into an 8 bit character string.


HRESULT WCCPtoMBCP(
    PED     ped,            // In  - Edit control structure
    BYTE   *pbMbStr,        // In  - Multi byte string
    int     icpWcStr,       // In  - Wide char caret position
    int    *picpMbStr) {    // Out - Byte offset of caret in multibyte string


    if (!ped->fDBCS  || !ped->fAnsi) {

        *picpMbStr = icpWcStr;
        return S_OK;
    }


    // Scan through DBCS string counting characters

    *picpMbStr = 0;
    while (icpWcStr > 0) {

        if (ECIsDBCSLeadByte(ped, *pbMbStr)) {

            // Character takes two bytes

            (*picpMbStr) += 2;
            pbMbStr      += 2;

        } else {

            // Character takes one byte

            (*picpMbStr)++;
            pbMbStr++;
        }

        icpWcStr--;
    }

    return S_OK;
}






////    LeftEdgeX
//
//      Returns the visual x offset (i.e. from the left edge of the window)
//      to the left edge of a line of width iWidth given the current
//      formatting state of the edit control, .format and .xOffset.



int LeftEdgeX(PED ped, INT iWidth) {

    INT iX;


    // First generate logical iX - offset forward from leading margin.

    iX = 0;

    switch (ped->format) {

        case ES_LEFT:           // leading margin alignment
            if (ped->fWrap) {
                iX = 0;
            } else {
                iX = -(INT)ped->xOffset;
            }
            break;

        case ES_CENTER:
            iX = (ped->rcFmt.right - ped->rcFmt.left - iWidth) / 2;
            break;

        case ES_RIGHT:          // far margin alignment
            iX = ped->rcFmt.right - ped->rcFmt.left - iWidth;
            break;
    }


    // iX is logical offset from leading margin to leading edge of string
    if (ped->format != ES_LEFT && iX < 0) {
        iX = !ped->fWrap ? -(INT)ped->xOffset : 0;
    }

    // Now adjust for right to left origin and incorporate left margin

    if (ped->fRtoLReading) {
        iX = ped->rcFmt.right - (iX+iWidth);
    } else {
        iX += ped->rcFmt.left;
    }

    TRACE(EDIT, ("LeftEdgeX iWidth=%d, format=%d, xOffset=%d, fWrap=%d, fRtoLReading=%d, right-left=%d, returning %d",
                 iWidth, ped->format, ped->xOffset, ped->fWrap, ped->fRtoLReading, ped->rcFmt.right - ped->rcFmt.left, iX));

    return iX;
}




/////   Shaping engins IDs.

#define BIDI_SHAPING_ENGINE_DLL     1<<0
#define THAI_SHAPING_ENGINE_DLL     1<<1
#define INDIAN_SHAPING_ENGINE_DLL   1<<4


///


////    EditCreate
//
//      Called from edecrare.c ECCreate.
//
//      Return TRUE if create succeeded


BOOL EditCreate(PED ped, HWND hWnd) {

    LONG_PTR dwExStyle, dwStyle;

    TRACE(EDIT, ("EditCreate called."));


    // Check if BIDI shaping engine is loaded then
    // allow the edit control to switch its direction.

    if (g_dwLoadedShapingDLLs & BIDI_SHAPING_ENGINE_DLL) {
        ped->fAllowRTL = TRUE;
    } else {
        ped->fAllowRTL = FALSE;
    }


    // Process WS_EX flags

    dwExStyle = GetWindowLongPtr(hWnd, GWL_EXSTYLE);

    if (dwExStyle & WS_EX_LAYOUTRTL) {
        dwExStyle = dwExStyle & ~WS_EX_LAYOUTRTL;
        dwExStyle = dwExStyle ^ (WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR);
        SetWindowLongPtr(hWnd, GWL_EXSTYLE, dwExStyle);

        dwStyle = GetWindowLongPtr(hWnd, GWL_STYLE);
        if (!(dwStyle & ES_CENTER)) {
            dwStyle = dwStyle ^ ES_RIGHT;
            SetWindowLongPtr(hWnd, GWL_STYLE, dwStyle);
        }
    }


    if (dwExStyle & WS_EX_RIGHT && ped->format == ES_LEFT) {
        ped->format = ES_RIGHT;
    }

    if (dwExStyle & WS_EX_RTLREADING) {
        ped->fRtoLReading = TRUE;
        switch (ped->format) {
            case ES_LEFT:   ped->format = ES_RIGHT;  break;
            case ES_RIGHT:  ped->format = ES_LEFT;   break;
        }
    }

    return TRUE;
}






////    EditStringAnalyse
//
//      Creates standard analysis parameters from the PED

HRESULT EditStringAnalyse(
    HDC             hdc,
    PED             ped,
    PSTR            pText,
    int             cch,
    DWORD           dwFlags,
    int             iMaxExtent,
    STRING_ANALYSIS **ppsa){


    HRESULT         hr;
    SCRIPT_TABDEF   std;
    int             iTabExtent;

    if (!ped->pTabStops)
    {
        std.cTabStops  = 1;
        std.iScale     = 4;
        std.pTabStops  = &iTabExtent;
        std.iTabOrigin = 0;
        iTabExtent     = ped->aveCharWidth * 8;
    }
    else
    {
        std.cTabStops  = *ped->pTabStops;
        std.iScale     = 4;                 // Tabstops are already in device units
        std.pTabStops  = ped->pTabStops + 1;
        std.iTabOrigin = 0;
    }


    hr = LpkStringAnalyse(
         hdc,
         ped->charPasswordChar ? (char*)&ped->charPasswordChar : pText,
         cch, 0,
         GetEditAnsiConversionCharset(ped),
         dwFlags | SSA_FALLBACK | SSA_TAB
         | (ped->fRtoLReading     ? SSA_RTL      : 0)
         | (ped->fDisplayCtrl     ? SSA_DZWG     : 0)
         | (ped->charPasswordChar ? SSA_PASSWORD : 0),
         -1, iMaxExtent,
         NULL, NULL,    // Control, State
         NULL,          // Overriding Dx array
         &std,          // Tab definition
         NULL,          // Input class overrides
         ppsa);

    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditStringAnalyse - LpkStringAnalyse"));
    }

    return hr;
}


////    HScroll
//
//      Checks wether the cursor is visible withing the rcFormat
//      area, and if not, updates xOffset so that it's 1/4 of the
//      way from the edge it was closest to.
//
//      However, it never leaves whitespace between the leading margin
//      and the leading edge of the string, nor will it leave whitespace
//      between the trailing edge and the trailing margin when there's
//      enough text in the string to fill the whole window.
//
//      Implemented for the single line edit control.


BOOL EditHScroll(PED ped, HDC hdc, PSTR pText) {

    int       ichCaret;
    int       dx;       // Distance to move RIGHTWARDS (i.e. visually)
    int       cx;       // Original visual cursor position
    int       tw;       // Text width
    int       rw;       // Rectangle width
    int       ix;       // ScriptCPtoX result
    UINT      uOldXOffset;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (!ped->cch || ped->ichCaret > ped->cch) {
        ped->xOffset = 0;
        return FALSE;
    }


    hr = EditStringAnalyse(hdc, ped, pText, ped->cch, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditHScroll - EditStringAnalyse"));
        return FALSE;
    }

    MBCPtoWCCP(ped, pText, ped->ichCaret, &ichCaret);


    uOldXOffset = ped->xOffset;
    tw = psa->size.cx;                              // Text width
    rw = ped->rcFmt.right-ped->rcFmt.left;          // Window rectangle width
    #ifdef CURSOR_ABSOLUTE_HOME_AND_END
        if (ichCaret <= 0) {
            cx = ped->fRtoLReading ? psa->size.cx : 0;
        } else if (ichCaret >= psa->cInChars) {
            cx = ped->fRtoLReading ? 0: psa->size.cx;
        } else {
            cx = ScriptCursorX(psa, ichCaret-1);
        }
        cx += LeftEdgeX(ped, tw);
    #else
        if (ichCaret <= 0) {
            hr = ScriptStringCPtoX(psa, ichCaret, FALSE, &ix);
        } else {
            hr = ScriptStringCPtoX(psa, ichCaret-1, TRUE, &ix);
        }

        if (FAILED(hr)) {
            ASSERTHR(hr, ("EditHScroll - ScriptStringCPtoX"));
            ScriptStringFree(&psa);
            return FALSE;
        }

        cx = LeftEdgeX(ped, tw) + ix;
    #endif

    if (cx < ped->rcFmt.left) {

        // Bring cursor position to left quartile
        dx = rw/4 - cx;

    } else if (cx > ped->rcFmt.right) {

        // Bring cursor position to right quartile
        dx = (3*rw)/4 - cx;

    } else
        dx = 0;


    // Adjust visual position change to logical - relative to reading order

    if (ped->fRtoLReading) {
        dx = - dx;
    }


    // Avoid unnecessary leading or trailing whitespace

    if (tw - ((INT)ped->xOffset - dx) < rw && tw > rw ) {

        // No need to have white space at the end if there's enough text
        ped->xOffset = (UINT)(tw-rw);

    } else if ((INT)ped->xOffset < dx) {

        // No need to have white space at beginning of line
        ped->xOffset = 0;

    } else {

        // Move cursor directly to chosen quartile
        ped->xOffset -= (UINT) dx;
    }


    TRACE(EDIT, ("HScroll format=%d, fWrap=%d, fRtoLReading=%d, right-left=%d, new xOffset %d",
                 ped->format, ped->fWrap, ped->fRtoLReading, ped->rcFmt.right - ped->rcFmt.left, ped->xOffset));

    ScriptStringFree(&psa);

    return ped->xOffset != uOldXOffset ? TRUE : FALSE;
}







////    IchToXY
//
//      Converts a character position to the corresponding x coordinate
//      offset from the left end of the text of the line.


int EditIchToXY(PED ped, HDC hdc, PSTR pText, ICH ichLength, ICH ichPos) {

    INT       iResult;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (ichLength == 0) {
        return LeftEdgeX(ped, 0);
    }


    hr = EditStringAnalyse(hdc, ped, pText, ichLength, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditIchToXY - EditStringAnalyse"));
        return LeftEdgeX(ped, 0);
    }

    MBCPtoWCCP(ped, pText, ichPos, &ichPos);

    #ifdef CURSOR_ABSOLUTE_HOME_AND_END
        if (ichPos <= 0) {
            iResult = ped->fRtoLReading ? psa->size.cx : 0;
        } else if (ichPos >= psa->cInChars) {
            iResult = ped->fRtoLReading ? 0 : psa->size.cx;
        } else {
            iResult = ScriptStringCPtoX(psa, ichPos-1);
        }
    #else
        if (ichPos <= 0) {
            hr = ScriptStringCPtoX(psa, ichPos, FALSE, &iResult);
        } else {
            hr = ScriptStringCPtoX(psa, ichPos-1, TRUE, &iResult);
        }
        if (FAILED(hr)) {
            ASSERTHR(hr, ("EditIchToXY - ScriptStringCPtoX"));
            iResult = 0;
        }
    #endif

    iResult += LeftEdgeX(ped, psa->size.cx);

    ScriptStringFree(&psa);

    return (int) iResult;
}







////    EditDrawText - draw one line for MLDrawText
//
//      Draws the text at offset ichStart from pText length ichLength.
//
//      entry   pwText    - points to beginning of line to display
//              iMinSel,  - range of characters to be highlighted. May
//              iMaxSel     be -ve or > cch.
//
//      Uses ED structure fields as follows:
//
//      rcFmt       - drawing area
//      xOffset     - distance from leading margin to leading edge of text.
//                    (May be negative if the text is horizontally scrolled).
//      RtoLReading - determines leading margin/edge.
//      format      - ES_LEFT   - leading edge aligned (may be scrolled horizontally)
//                  - ES_CENTRE - centred between margins. (can't be scrolled horizontally)
//                  - ES_RIGHT  - trailing margin aligned (can't be scrolled horizontally)


void EditDrawText(PED ped, HDC hdc, PSTR pText, INT iLength, INT iMinSel, INT iMaxSel, INT iY) {

    INT       iX;               // x position to start display at
    INT       iWidth;           // Width of line
    RECT      rc;               // Locally updated copy of rectangle
    int       xFarOffset;
    HRESULT   hr;
    STRING_ANALYSIS *psa;


    // Establish where to display the line

    rc         = ped->rcFmt;
    rc.top     = iY;
    rc.bottom  = iY + ped->lineHeight;
    xFarOffset = ped->xOffset + rc.right - rc.left;

    // Include left or right margins in display unless clipped
    // by horizontal scrolling.
    if (ped->wLeftMargin) {
        if (!(   ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
              && (   (!ped->fRtoLReading && ped->xOffset > 0)  // LTR and first char not fully in view
                  || ( ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) { //RTL and last char not fully in view
            rc.left  -= ped->wLeftMargin;
        }
    }
    if (ped->wRightMargin) {
        if (!(   ped->format == ES_LEFT     // Only ES_LEFT (Nearside alignment) can get clipped
              && (   ( ped->fRtoLReading && ped->xOffset > 0)  // RTL and first char not fully in view
                  || (!ped->fRtoLReading && xFarOffset < ped->maxPixelWidth)))) { // LTR and last char not fully in view
            rc.right += ped->wRightMargin;
        }
    }



    if (iMinSel < 0)       iMinSel = 0;
    if (iMaxSel > iLength) iMaxSel = iLength;


    if (ped->fSingle) {
        // The single line edit control always applies the background color
        SetBkMode(hdc, OPAQUE);
    }

    if (iLength <= 0) {
        if ((iMinSel < iMaxSel) || (GetBkMode(hdc) == OPAQUE)) {
            // Empty line, just clear it on screen
            ExtTextOutW(hdc, 0,iY, ETO_OPAQUE, &rc, NULL, 0, NULL);
        }
        return;
    }


    hr = EditStringAnalyse(hdc, ped, pText, iLength, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditDrawText - EditStringAnalyse"));
        return;
    }

    MBCPtoWCCP(ped, pText, iMinSel, &iMinSel);
    MBCPtoWCCP(ped, pText, iMaxSel, &iMaxSel);

    iWidth = psa->size.cx;
    iX = LeftEdgeX(ped, iWidth);    // Visual x where left edge of string should be.


    ScriptStringOut(
        psa,
        iX,
        iY,
        ETO_CLIPPED
        | (GetBkMode(hdc) == OPAQUE    ? ETO_OPAQUE     : 0),
        &rc,
        iMinSel,
        ped->fNoHideSel || ped->fFocus ? iMaxSel : iMinSel,
        ped->fDisabled);


    ScriptStringFree(&psa);
}







////    EditMouseToIch
//
//      Returns the logical character offset corresponding to
//      a specified x offset.
//
//      entry   iX - Window (visual) x position



ICH EditMouseToIch(PED ped, HDC hdc, PSTR pText, ICH ichCount, INT iX) {

    ICH       iCh;
    BOOL      fTrailing;
    int       iWidth;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (ichCount == 0) {
        return 0;
    }


    hr = EditStringAnalyse(hdc, ped, pText, ichCount, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditMouseToIch - EditStringAnalyse"));
        return 0;
    }


    iWidth = psa->size.cx;

    // Take horizontal scroll position into consideration.

    iX -= LeftEdgeX(ped, iWidth);

    // If the user clicked beyond the edge of the string, treat it as a logical
    // start or end of string request.

    if (iX < 0) {

        iCh = ped->fRtoLReading ? ichCount : 0;

    } else if (iX > iWidth) {

        TRACE(POSN, ("LpkEditMouseToIch iX beyond right edge: iX %d, psa->piOutVW %x, psa->nOutGlyphs %d, psa->piDx[psa->nOutGlyphs-1] %d",
                iX, psa->piOutVW, psa->nOutGlyphs, iWidth));

        iCh = ped->fRtoLReading ? 0 : ichCount;

    } else {

        // Otherwise it's in the string. Find the logical character whose centre is nearest.

        ScriptStringXtoCP(psa, iX, &iCh, &fTrailing);
        iCh += fTrailing;   // Snap to nearest character edge

        WCCPtoMBCP(ped, pText, iCh, &iCh);
    }

    ScriptStringFree(&psa);

    TRACE(POSN, ("EditMouseToIch iX %d returns ch %d", iX, iCh));

    return iCh;
}







////    EditGetLineWidth
//
//      Returns width of line in pixels


INT EditGetLineWidth(PED ped, HDC hdc, PSTR pText, ICH cch) {

    INT       iResult;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (cch == 0) {
        return 0;
    }

    if (cch > MAXLINELENGTH) {
        cch = MAXLINELENGTH;
    }


    hr = EditStringAnalyse(hdc, ped, pText, cch, SSA_GLYPHS, 0, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditGetLineWidth - EditStringAnalyse"));
        return 0;
    }

    iResult = psa->size.cx;

    ScriptStringFree(&psa);

    TRACE(EDIT, ("EditGetLineWidth width %d returns %d", cch, iResult))

    return iResult;
}







////    EditCchInWidth
//
//      Returns number of characters that will fit in width pixels.


ICH  EditCchInWidth(PED ped, HDC hdc, PSTR pText, ICH cch, int width) {

    ICH       ichResult;
    HRESULT   hr;
    STRING_ANALYSIS *psa;

    if (cch > MAXLINELENGTH) {
        cch = MAXLINELENGTH;
    } else if (cch == 0) {
        return 0;
    }


    hr = EditStringAnalyse(hdc, ped, pText, cch, SSA_GLYPHS | SSA_CLIP, width, &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("EditCchInWidth - EditStringAnalyse"));
        return 0;
    }

    ichResult = psa->cOutChars;

    WCCPtoMBCP(ped, pText, ichResult, &ichResult);

    ScriptStringFree(&psa);


    TRACE(EDIT, ("EditCchInWidth width %d returns %d", width, ichResult))

    return ichResult;
}







////    EditMoveSelection
//
//      Returns nearest character position backward or forward from current position.
//
//      Position is restricted according to language rules. For example, in Thai it is
//      not possible to position the cursor between a base consonant and it's
//      associated vowel or tone mark.


ICH EditMoveSelection(PED ped, HDC hdc, PSTR pText, ICH ich, BOOL fBackward) {


    #define SP  0x20
    #define TAB 0x09
    #define CR  0x0D
    #define LF  0x0A
    #define EDWCH(ich)     (ped->fAnsi ? (WCHAR)pText[ich] : ((PWSTR)pText)[ich])
    #define EDWCBLANK(ich) ((BOOL) (EDWCH(ich) == SP || EDWCH(ich) == TAB))
    #define EDWCCR(ich)    ((BOOL) (EDWCH(ich) == CR))
    #define EDWCLF(ich)    ((BOOL) (EDWCH(ich) == LF))
    #define EDSTARTWORD(ich) (   (ich == 0)                   \
                              || (    (    EDWCBLANK(ich-1)   \
                                       ||  EDWCLF(ich-1))     \
                                  &&      !EDWCBLANK(ich))    \
                              || (    !EDWCCR(ich-1)          \
                                  &&  EDWCCR(ich)))


    ICH  ichNonblankStart;  // Leading character of nonblank run containing potential caret position
    ICH  ichNonblankLimit;  // First character beyond nonblank run containing potential caret position
    int  iOffset;           // Offset into nonblank run of ich measued in logical characters

    STRING_ANALYSIS  *psa;
    HRESULT           hr;


    // Handle simple special cases:
    // o  At very beginning or end of buffer
    // o  When target position is blank or start or end of line


    if (fBackward) {

        if (ich <= 1) {
            return 0;
        }

        ich--;

        if (EDWCBLANK(ich)) {
            return ich;
        }

        if (EDWCLF(ich)) {
            while (    ich > 0
                   &&  EDWCCR(ich-1)) {
                ich--;
            }
            return ich;
        }

    } else {

        if (ich >= ped->cch-1) {
            return ped->cch;
        }

        ich++;

        if (EDWCBLANK(ich)) {
            return ich;
        }

        if (EDWCCR(ich-1)) {

            // Moving forward from a CR.

            if (    ich < ped->cch
                &&  EDWCCR(ich)) {
                ich++;
            }
            if (    ich < ped->cch
                &&  EDWCLF(ich)) {
                ich++;
            }

            return ich;
        }
    }


    // Identify nonblank run containing target position

    ichNonblankStart = ich;
    ichNonblankLimit = ich+1;


    // Move ichNonblankStart back to real start of blank delimited run

    while (    ichNonblankStart > 0
           &&  !(EDSTARTWORD(ichNonblankStart))) {
        ichNonblankStart--;
    }

    // Include one leading space if any

    if (    ichNonblankStart > 0
        &&  EDWCBLANK(ichNonblankStart - 1)) {

        ichNonblankStart--;
    }


    // Move ichNonblankLimit on to real end of blank delimited run

    while (    ichNonblankLimit < ped->cch
           &&  !EDWCBLANK(ichNonblankLimit)
           &&  !EDWCCR(ichNonblankLimit)) {

        ichNonblankLimit++;
    }


    // Obtain a break analysis of the identified nonblank run

     hr = LpkStringAnalyse(
          hdc,
          pText + ichNonblankStart * ped->cbChar,
          ichNonblankLimit - ichNonblankStart,
          0,
          GetEditAnsiConversionCharset(ped),
          SSA_BREAK,
          -1, 0,
          NULL, NULL, NULL, NULL, NULL,
          &psa);


     if (SUCCEEDED(hr)) {

        // Use the charstop flags in the logical attributes to correct ich

        if (ich <= ichNonblankStart) {
            iOffset = 0;
        } else {
            hr = MBCPtoWCCP(ped, pText+ichNonblankStart*ped->cbChar, ich-ichNonblankStart, &iOffset);
            if (hr == E_FAIL) {
                // ich was the second byte of a double byte character.
                // In this case MBCPtoWCCP has returned the subsequent character
                if (fBackward) {
                    iOffset--;
                }
            }
        }


        if (fBackward) {

            while (    iOffset > 0
                   &&  !psa->pLogAttr[iOffset].fCharStop) {
                iOffset--;
            }

        } else {

            while (    iOffset < psa->cInChars
                   &&  !psa->pLogAttr[iOffset].fCharStop) {
                iOffset++;
            }
        }

        ScriptStringFree(&psa);

        WCCPtoMBCP(ped, pText+ichNonblankStart*ped->cbChar, iOffset, &ich);

        return ichNonblankStart + ich;

    } else {

        ASSERTHR(hr, ("EditMoveSelection - LpkStringAnalyse"));

        // Analysis not possible - ignore content of complex scripts.

        return ich;
    }
}





void EditGetNextBoundaries(
    PED       ped,
    HDC       hdc,
    PSTR      pText,
    ICH       ichStart,
    BOOL      fLeft,
    ICH      *pichMin,
    ICH      *pichMax,
    BOOL      fWordStop)
{


    ICH       sd,ed;     // Start and end of blank delimited run
    ICH       sc,ec;     // Star and end of complex script word within sd,se
    HRESULT   hr;
    STRING_ANALYSIS *psa;


    // Identify left end of nearest delimited word (see diagram above)

    sd = ichStart;

    if (fLeft) {

        // Going left

        if (sd) {
            sd--;

            while (!(EDSTARTWORD(sd))) {
                sd--;
            }
        }

    } else {

        // Going right

        if (EDWCBLANK(sd)) {

            // Move right to first character of word

            if (sd < ped->cch) {
                sd++;
                while (sd < ped->cch && !EDSTARTWORD(sd)) {
                    sd++;
                }
            }

        } else {

            // Move left to first character of this word

            while (!EDSTARTWORD(sd)) {
                sd--;
            }
        }
    }



    // Position 'e' on first character of next word

    ed = sd;
    if (ed < ped->cch) {
        ed++;
        while (ed<ped->cch && !EDSTARTWORD(ed)) {
            ed++;
        }
    }


    // Obtain an analysis of the identified word

     hr = LpkStringAnalyse(
          hdc, pText  + sd * ped->cbChar, ed - sd, 0,
          GetEditAnsiConversionCharset(ped),
          SSA_BREAK,
          -1, 0,
          NULL, NULL, NULL, NULL, NULL,
          &psa);

     if (SUCCEEDED(hr)) {

        // Use the start of word (linebreak) flags in the logical attribute
        // to narrow the word where appropriate to complex script handling

        if (ichStart > sd) {
            MBCPtoWCCP(ped, pText+sd*ped->cbChar, ichStart-sd, &sc);
        } else {
            sc = 0;
        }

        // Change ed from byte offset to codepoint index relative to sd

        MBCPtoWCCP(ped, pText+sd*ped->cbChar, ed-sd, &ed);


        if (fLeft && sc) // Going left
            sc--;

        if (fWordStop) {
            while (sc && !psa->pLogAttr[sc].fSoftBreak)
                sc--;
        }
        else {
            while (sc && !psa->pLogAttr[sc].fCharStop)
                sc--;
        }

        // Set ichMax to next stop

        ec = sc;

        if (ec < ed) {
            ec++;
            if (fWordStop) {
                while (ec < ed && !psa->pLogAttr[ec].fSoftBreak)
                    ec++;
            }
            else {
                while (ec < ed && !psa->pLogAttr[ec].fCharStop)
                    ec++;
            }
        }

        WCCPtoMBCP(ped, pText+sd*ped->cbChar, sc, &sc);
        WCCPtoMBCP(ped, pText+sd*ped->cbChar, ec, &ec);

        if (pichMin) *pichMin = sd + sc;
        if (pichMax) *pichMax = sd + ec;

        ScriptStringFree(&psa);

    } else {

        ASSERTHR(hr, ("EditGetNextBoundaries - LpkStringAnalyse"));

        // Analysis not possible - ignore content of complex scripts.

        if (pichMin) *pichMin = sd;
        if (pichMax) *pichMax = ed;
    }
}


////    EditNextWord - find adjacent word start and end points
//
//      Duplicates the behaviour of US notepad.
//
//      First stage identify word range using standard
//      blank/tab as delimiter.
//
//      Second stage - analyse this run and use the logical
//      attributes to narrow down on words identified by
//      contextual processing in the complex script shaping
//      engines.
//
//
//      The following diagram describes the identification
//      of the initial character of the nearest word:
//
//      GOING LEFT:
//
//      Words        WWWW    WWWW    WWWW
//      from any of           xxxxxxxx
//      to                   x
//
//      (Notice that the result is always to the left of the initial
//      position).
//
//
//      GOING RIGHT:
//
//      Words        WWWW    WWWW    WWWW
//      from any of      xxxxxxxx
//      to                   x
//
//
//      Note that CRLF and CRCRLF are treated as words even if not
//      delimited by blanks.


void EditNextWord(
    PED       ped,
    HDC       hdc,
    PSTR      pText,
    ICH       ichStart,
    BOOL      fLeft,
    ICH      *pichMin,
    ICH      *pichMax)
{
    EditGetNextBoundaries(ped, hdc, pText, ichStart, fLeft, pichMin, pichMax, TRUE);
}





////    IsVietnameseSequenceValid
//
//      Borrow this code from richedit. The logic was provided by Chau Vu.
//
//      April 26, 1999  [wchao]

BOOL IsVietnameseSequenceValid (WCHAR ch1, WCHAR ch2)
{

    #define IN_RANGE(n1, b, n2)     ((unsigned)((b) - (n1)) <= (unsigned)((n2) - (n1)))

    int i;
    static const BYTE vowels[] = {0xF4, 0xEA, 0xE2, 'y', 'u', 'o', 'i', 'e', 'a'};


    if (!IN_RANGE(0x300, ch2, 0x323) ||     // Fast out
        !IN_RANGE(0x300, ch2, 0x301) && ch2 != 0x303 && ch2 != 0x309 && ch2 != 0x323)
    {
        return TRUE;                        // Not Vietnamese tone mark
    }

    for(i = sizeof(vowels) / sizeof(vowels[0]); i--;)
        if((ch1 | 0x20) == vowels[i])       // Vietnamese tone mark follows
            return TRUE;                    // vowel

    return IN_RANGE(0x102, ch1, 0x103) ||   // A-breve, a-breve
           IN_RANGE(0x1A0, ch1, 0x1A1) ||   // O-horn,  o-horn
           IN_RANGE(0x1AF, ch1, 0x1B0);     // U-horn,  u-horn
}





////    EditStringValidate
//
//      Validate the string sequence from the insertion point onward.
//      Return S_FALSE if any character beyond the insertion point produces fInvalid.
//
//      April 5,1999     [wchao]

HRESULT EditStringValidate (STRING_ANALYSIS* psa, int ichInsert)
{
    BOOL    fVietnameseCheck = PRIMARYLANGID(THREAD_HKL()) == LANG_VIETNAMESE;
    int     iItem;
    int     i;
    int     l;


    if (!psa->pLogAttr)
        return E_INVALIDARG;


    for (iItem = 0; iItem < psa->cItems; iItem++)
    {
        if (g_ppScriptProperties[psa->pItems[iItem].a.eScript]->fRejectInvalid)
        {
            i = psa->pItems[iItem].iCharPos;
            l = psa->pItems[iItem + 1].iCharPos - i;

            while (l)
            {
                if (i >= ichInsert && psa->pLogAttr[i].fInvalid)
                    return S_FALSE;
                i++;
                l--;
            }
        }
        else if (fVietnameseCheck && g_ppScriptProperties[psa->pItems[iItem].a.eScript]->fCDM)
        {
            // Vietnamese specific sequence check

            i = psa->pItems[iItem].iCharPos;
            l = psa->pItems[iItem + 1].iCharPos - i;

            while (l)
            {
                if (i > 0 && i >= ichInsert && !IsVietnameseSequenceValid(psa->pwInChars[i-1], psa->pwInChars[i]))
                    return S_FALSE;
                i++;
                l--;
            }
        }
    }

    return S_OK;
}






////    EditVerifyText
//
//      Verify the sequence of input text at the insertion point by calling
//      shaping engine that will return output flag pLogAttr->fInvalid in
//      the invalid position of text. Return 0 if the insert text has invalid
//      combination.
//
//      Mar 31,1997     [wchao]

INT EditVerifyText (PED ped, HDC hdc, PSTR pText, ICH ichInsert, PSTR pInsertText, ICH cchInsert) {

    ICH      ichRunStart;
    ICH      ichRunEnd;
    ICH      ichLineStart;
    ICH      ichLineEnd;
    ICH      cchVerify;
    PSTR     pVerify;
    INT      iResult;
    UINT     cbChar;
    BOOL     fLocateChar;
    HRESULT  hr;
    STRING_ANALYSIS *psa;

    ASSERTS(cchInsert > 0  &&  pInsertText != NULL  &&  pText != NULL,  ("Invalid parameters!"));

    if (cchInsert > 1)
        // What we concern here is about how should we handle a series of characters
        // forming invalid combination(s) that gets updated to the backing store as one
        // operation (e.g. pasting). We chose to not handle it and the logic is that to
        // -only- validate a given input char against the current state of the backing store.
        //
        // Notice that i use the value 1 so we're safe if inserted text is a DBCS character.
        //
        // [Dec 10, 98, wchao]
        return TRUE;

    if (ped->fSingle) {
        ichLineStart = 0;
          ichLineEnd = ped->cch;
    } else {
        ichLineStart = ped->chLines[ped->iCaretLine];
        ichLineEnd = ped->iCaretLine == ped->cLines-1 ? ped->cch : ped->chLines[ped->iCaretLine+1];
    }

    ichRunEnd = ichRunStart = ichInsert;    // insertion point

    // Are we at the space?
    fLocateChar = EDWCH(ichInsert) == SP ? TRUE : FALSE;

    // Locate a valid char
    while ( ichRunStart > ichLineStart && fLocateChar && EDWCH(ichRunStart) == SP ) {
        ichRunStart--;
    }

    // Locate run starting point

    // Find space
    while (ichRunStart > ichLineStart && EDWCH(ichRunStart - 1) != SP) {
        ichRunStart--;
    }

    // Cover leading spaces
    while (ichRunStart > ichLineStart && EDWCH(ichRunStart - 1) == SP) {
        ichRunStart--;
    }

    // Locate a valid char
    while ( ichRunEnd < ichLineEnd && fLocateChar && EDWCH(ichRunEnd) == SP ) {
        ichRunEnd++;
    }

    // Locate run ending point
    while (ichRunEnd < ichLineEnd && EDWCH(ichRunEnd) != SP) {
        ichRunEnd++;
    }

    ASSERTS(ichRunStart <= ichRunEnd, "Invalid run length!");

    // Merge insert text with insertion point run.

    cchVerify = ichRunEnd - ichRunStart + cchInsert;
    cbChar    = ped->cbChar;
    pVerify   = (PSTR) GlobalAlloc(GMEM_FIXED, cchVerify * cbChar);

    if (pVerify) {

        PSTR    pv;
        UINT    cbCopy;

        pv = pVerify;

        cbCopy = (ichInsert - ichRunStart) * cbChar;
        memcpy (pv, pText + ichRunStart * cbChar, cbCopy);
        pv += cbCopy;

        cbCopy = cchInsert * cbChar;
        memcpy (pv, pInsertText, cbCopy);
        pv += cbCopy;

        cbCopy = (ichRunEnd - ichInsert) * cbChar;
        memcpy (pv, pText + ichInsert * cbChar, cbCopy);

    } else {

        ASSERTS(pVerify, "EditVerifyText: Assertion failure: Could not allocate merge text buffer");
        return 1;   // can do nothing now just simply accept it.
    }

    psa      = NULL;
    iResult  = TRUE;    // assume verification pass.

    // Do the real work.
    // This will call to shaping engine and proceed item by item.
    //

    hr = LpkStringAnalyse(
         hdc, pVerify, cchVerify, 0,
         GetEditAnsiConversionCharset(ped),
         SSA_BREAK
         | (ped->charPasswordChar ? SSA_PASSWORD : 0)
         | (ped->fRtoLReading     ? SSA_RTL      : 0),
         -1, 0,
         NULL, NULL, NULL, NULL, NULL,
         &psa);

    if (SUCCEEDED(hr)) {

        MBCPtoWCCP(ped, pVerify, ichInsert - ichRunStart, &ichInsert);

        hr = EditStringValidate(psa, ichInsert);

        if (hr == S_FALSE) {

            MessageBeep((UINT)-1);
            iResult = FALSE;

        } else if (FAILED(hr)) {

            ASSERTHR(hr, ("EditVerifyText - EditStringValidate"));
        }

        ScriptStringFree(&psa);

    } else {
        ASSERTHR(hr, ("EditVerifyText - LpkStringAnalyse"));
    }

    GlobalFree((HGLOBAL) pVerify);
    return iResult;
}







////    EditProcessMenu
//
//      Process LPK context menu commands.
//
//      April 18, 1997     [wchao]
//


INT EditProcessMenu (PED ped, UINT idMenuItem)
{
    HWND    hwnd;
    INT     iResult;

    iResult = TRUE;

    switch (idMenuItem) {

        case ID_CNTX_RTL:
            hwnd = ped->hwnd;
            SetWindowLongPtr(hwnd, GWL_STYLE, GetWindowLongPtr(hwnd, GWL_STYLE) & ~ES_FMTMASK);
            if (!ped->fRtoLReading) {
                SetWindowLongPtr(hwnd, GWL_EXSTYLE, GetWindowLongPtr(hwnd, GWL_EXSTYLE)
                              | (WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR));
            }
            else {
                SetWindowLongPtr(hwnd, GWL_EXSTYLE, GetWindowLongPtr(hwnd, GWL_EXSTYLE)
                              & ~(WS_EX_RTLREADING | WS_EX_RIGHT | WS_EX_LEFTSCROLLBAR));
            }
            break;


        case ID_CNTX_DISPLAYCTRL:
            hwnd = ped->hwnd;
            ped->fDisplayCtrl = !ped->fDisplayCtrl;

            if (ped->fFlatBorder) {

                RECT    rcT;
                int     cxBorder, cyBorder;

                GetClientRect(hwnd, &rcT);
                cxBorder = GetSystemMetrics (SM_CXBORDER);
                cyBorder = GetSystemMetrics (SM_CYBORDER);
                InflateRect(&rcT, -cxBorder, -cyBorder);
                InvalidateRect(hwnd, &rcT, TRUE);
            }
            else {
                InvalidateRect(hwnd, NULL, TRUE);
            }
            break;

        case ID_CNTX_ZWNJ:
            if (ped->fAnsi) {
                SendMessageA(ped->hwnd, WM_CHAR, 0x9D, 0);
            } else {
                SendMessageW(ped->hwnd, WM_CHAR, U_ZWNJ, 0);
            }
            break;

        case ID_CNTX_ZWJ:
            if (ped->fAnsi) {
                SendMessageA(ped->hwnd, WM_CHAR, 0x9E, 0);
            } else {
                SendMessageW(ped->hwnd, WM_CHAR, U_ZWJ, 0);
            }
            break;

        case ID_CNTX_LRM:
            if (ped->fAnsi) {
                SendMessageA(ped->hwnd, WM_CHAR, 0xFD, 0);
            } else {
                SendMessageW(ped->hwnd, WM_CHAR, U_LRM, 0);
            }
            break;

        case ID_CNTX_RLM:
            if (ped->fAnsi) {
                SendMessageA(ped->hwnd, WM_CHAR, 0xFE, 0);
            } else {
                SendMessageW(ped->hwnd, WM_CHAR, U_RLM, 0);
            }
            break;

        case ID_CNTX_LRE:  SendMessageW(ped->hwnd, WM_CHAR, U_LRE,  0); break;
        case ID_CNTX_RLE:  SendMessageW(ped->hwnd, WM_CHAR, U_RLE,  0); break;
        case ID_CNTX_LRO:  SendMessageW(ped->hwnd, WM_CHAR, U_LRO,  0); break;
        case ID_CNTX_RLO:  SendMessageW(ped->hwnd, WM_CHAR, U_RLO,  0); break;
        case ID_CNTX_PDF:  SendMessageW(ped->hwnd, WM_CHAR, U_PDF,  0); break;
        case ID_CNTX_NADS: SendMessageW(ped->hwnd, WM_CHAR, U_NADS, 0); break;
        case ID_CNTX_NODS: SendMessageW(ped->hwnd, WM_CHAR, U_NODS, 0); break;
        case ID_CNTX_ASS:  SendMessageW(ped->hwnd, WM_CHAR, U_ASS,  0); break;
        case ID_CNTX_ISS:  SendMessageW(ped->hwnd, WM_CHAR, U_ISS,  0); break;
        case ID_CNTX_AAFS: SendMessageW(ped->hwnd, WM_CHAR, U_AAFS, 0); break;
        case ID_CNTX_IAFS: SendMessageW(ped->hwnd, WM_CHAR, U_IAFS, 0); break;
        case ID_CNTX_RS:   SendMessageW(ped->hwnd, WM_CHAR, U_RS,   0); break;
        case ID_CNTX_US:   SendMessageW(ped->hwnd, WM_CHAR, U_US,   0); break;
    }

    return iResult;
}






////    EditSetMenu - Set menu state
//
//


void EditSetMenu(PED ped, HMENU hMenu) {


    EnableMenuItem(hMenu, ID_CNTX_RTL, MF_BYCOMMAND | MF_ENABLED);
    CheckMenuItem (hMenu, ID_CNTX_RTL, MF_BYCOMMAND | (ped->fRtoLReading ? MF_CHECKED : MF_UNCHECKED));


    if (!ped->fAnsi || ped->charSet == ARABIC_CHARSET || ped->charSet == HEBREW_CHARSET) {

        // It's unicode, Arabic or Hebrew - we can display and enter at least some control characters

        EnableMenuItem(hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND | MF_ENABLED);
        CheckMenuItem (hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND | (ped->fDisplayCtrl ? MF_CHECKED : MF_UNCHECKED));
        EnableMenuItem(hMenu, ID_CNTX_INSERTCTRL, MF_BYCOMMAND | MF_ENABLED);

        EnableMenuItem(hMenu, ID_CNTX_LRM,  MF_BYCOMMAND  | MF_ENABLED);
        EnableMenuItem(hMenu, ID_CNTX_RLM,  MF_BYCOMMAND  | MF_ENABLED);


        if (!ped->fAnsi || ped->charSet == ARABIC_CHARSET) {

            // Controls characters in Unicode and ANSI Arabic only

            EnableMenuItem(hMenu, ID_CNTX_ZWJ,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_ZWNJ, MF_BYCOMMAND | MF_ENABLED);
        }

        if (!ped->fAnsi) {

            // These control characters are specific to the Unicode bidi algorithm

            EnableMenuItem(hMenu, ID_CNTX_LRE,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_RLE,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_LRO,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_RLO,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_PDF,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_NADS, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_NODS, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_ASS,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_ISS,  MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_AAFS, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_IAFS, MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_RS,   MF_BYCOMMAND | MF_ENABLED);
            EnableMenuItem(hMenu, ID_CNTX_US,   MF_BYCOMMAND | MF_ENABLED);
        }
    } else {

        // No opportunity to enter control characters

        EnableMenuItem(hMenu, ID_CNTX_INSERTCTRL,  MF_BYCOMMAND | MF_GRAYED);
        EnableMenuItem(hMenu, ID_CNTX_DISPLAYCTRL, MF_BYCOMMAND | MF_GRAYED);
    }
}





////    EditCreateCaretFromFont
//
//      Create one of the special caret shapes for complex script languages.
//
//      returns FALSE if it couldn't create the caret for example in low
//      memory situations.


#define CURSOR_USA   0xffff
#define CURSOR_LTR   0xf00c
#define CURSOR_RTL   0xf00d
#define CURSOR_THAI  0xf00e


BOOL EditCreateCaretFromFont(
    PED    ped,
    HDC    hdc,
    INT    nWidth,
    INT    nHeight,
    WCHAR  wcCursorCode
)
{
    BOOL      fResult = FALSE;  // Assume the worst
    HBITMAP   hbmBits;
    HDC       hcdcBits;
    HFONT     hArrowFont;
    ABC       abcWidth;
    COLORREF  clrBk;
    WORD      gidArrow;
    UINT      uiWidthBits;
    HBITMAP   hOldBitmap;



    // Create caret from the Arial font

    hcdcBits = CreateCompatibleDC (hdc);
    if (!hcdcBits)
    {
        return FALSE;
    }


    // create Arrow font then select into compatible DC

    // Bitmap will be XORed with the background color before caret starts blinking.
    // Therefore, we need to set our bitmap background to be opposite with the DC
    // actual background in order to generate caret properly.

    clrBk = GetBkColor(hdc);
    SetBkColor (hcdcBits, ~clrBk);

    // Creating the caret with white pattern to be consistant with User-edit field.

    clrBk = RGB(255, 255 , 255); // White
    SetTextColor (hcdcBits, clrBk);

    hArrowFont = CreateFontW ( nHeight, 0, 0, 0, nWidth > 1 ? 700 : 400, 0L, 0L, 0L, 1L,
                     0L, 0L, 0L, 0L, L"Microsoft Sans Serif" );

    if (!hArrowFont)
    {
        goto error;
    }


    SelectObject (hcdcBits, hArrowFont);


    // textout the Arrow char to get its bitmap

    if (!GetCharABCWidthsW (hcdcBits, wcCursorCode, wcCursorCode, &abcWidth))
    {
        goto error;
    }

    if (!GetGlyphIndicesW (hcdcBits, &wcCursorCode, 1, &gidArrow, 0))
    {
        goto error;
    }

    uiWidthBits = (((abcWidth.abcB)+15)/16)*16; // bitmap width must be WORD-aligned

    hbmBits = CreateCompatibleBitmap (hdc, uiWidthBits, nHeight);
    if (!hbmBits)
    {
        goto error;
    }

    hOldBitmap = SelectObject(hcdcBits, hbmBits);

    if (!ExtTextOutW (hcdcBits, -abcWidth.abcA, 0, ETO_OPAQUE | ETO_GLYPH_INDEX, NULL, &gidArrow, 1, NULL))
    {
        DeleteObject(SelectObject(hcdcBits, hOldBitmap));
        goto error;
    }


    // free current caret bitmap handle if we have one

    if (ped->hCaretBitmap) {
        DeleteObject (ped->hCaretBitmap);
    }

    ped->hCaretBitmap = hbmBits;

    if (wcCursorCode == CURSOR_RTL) {
        // RTL cursor has vertical stroke on right hand side. Overlap LTR and RTL
        // positions by one pixel so cursor doesn't go outside the edit control
        // at small sizes.
        ped->iCaretOffset  = 1 - (int) abcWidth.abcB;  // (Allow one pixel overlap between ltr & rtl)

    } else {

        ped->iCaretOffset = 0;
    }

    fResult = CreateCaret (ped->hwnd, hbmBits, 0, 0);


error:
    // release allocated objects

    if (hArrowFont)
    {
        DeleteObject(hArrowFont);
    }

    if (hcdcBits)
    {
        DeleteDC(hcdcBits);
    }

    return fResult;
}







////    EditCreateCaret
//
//      Create locale specific caret shape
//
//      April 25, 1997  [wchao]
//      May 1st,  1997  [samera] Added traditional BiDi cursor under #ifdef
//      Aug 15th, 2000  [dbrown] Fix prefix bug 43057 - no handling for low memory
//
//      Note
//      Complex script carets are mapped in the private area of Unicode in the font.
//      LTR cursor          0xf00c
//      RTL cursor          0xf00d
//      Thai cursor         0xf00e
//


#define LANG_ID(x)      ((DWORD)(DWORD_PTR)x & 0x000003ff);


INT EditCreateCaret(
    PED       ped,
    HDC       hdc,
    INT       nWidth,
    INT       nHeight,
    UINT      hklCurrent) {

    UINT      uikl;
    ULONG     ulCsrCacheCount;
    WCHAR     wcCursorCode;


    ped->iCaretOffset = 0;

    if (!hklCurrent) {
        uikl = LANG_ID(GetKeyboardLayout(0L));
    } else {
        uikl = LANG_ID(hklCurrent);
    }


    // Choose caret shape - use either the standard US caret, or a
    // special shape from the Arial font.

    wcCursorCode = CURSOR_USA;

    switch (uikl) {

        case LANG_THAI:    wcCursorCode = CURSOR_THAI;  break;

        //
        // we may need to call GetLocaleInfo( FONT_SIGNATURE ...) to
        // properly detect RTL languages.
        //

        case LANG_ARABIC:
        case LANG_FARSI:
        case LANG_URDU:
        case LANG_HEBREW:  wcCursorCode = CURSOR_RTL;   break;

        default:

            // Make sure the NLS settings are cached before checking on g_UserBidiLocale. it happens!

            if (    g_ulNlsUpdateCacheCount==-1
                &&  (ulCsrCacheCount = NlsGetCacheUpdateCount()) != g_ulNlsUpdateCacheCount) {

                 TRACE(NLS, ("LPK : Updating NLS cache from EditCreateCaret, lpkNlsCacheCount=%ld, CsrssCacheCount=%ld",
                            g_ulNlsUpdateCacheCount ,ulCsrCacheCount));

                 g_ulNlsUpdateCacheCount = ulCsrCacheCount;

                 // Update the cache now
                 ReadNLSScriptSettings();
            }

            if (g_UserBidiLocale) {
                // Other keyboards have a left-to-right pointing caret
                // in Bidi locales.
                wcCursorCode = CURSOR_LTR;
            }
    }


    if (wcCursorCode != CURSOR_USA)
    {
        // Try to create a caret from the Arial font

        if (!EditCreateCaretFromFont(ped, hdc, nWidth, nHeight, wcCursorCode))
        {
            // Caret from font failed - low memory perhaps
            wcCursorCode = CURSOR_USA;  // Fall back to USA cursor
        }
    }


    if (wcCursorCode == CURSOR_USA) {

        // Use Windows default caret

        return CreateCaret (ped->hwnd, NULL, nWidth, nHeight);

    } else {

        return TRUE;

    }
}






////    EditAdjustCaret
//
//      Adjust caret after insertion/deletion to avoid the caret in between a cluster,
//      very common in Indic e.g.
//
//          1. Deleting the space "X| Y" and it becomes "X|y".
//          2. Inserting 'X' at "|Y" and it becomes "X|y".
//
//      May 3,1999        [wchao]
//

INT EditAdjustCaret (
    PED     ped,
    HDC     hdc,
    PSTR    pText,
    ICH     ich)
{
#if 0
    //
    // Indiannt unanimously request this feature to be removed for final product.
    // (wchao - 7/12/99)
    //
    ICH     ichMin;
    ICH     ichMax;

    if (ich < ped->cch)
    {
        EditGetNextBoundaries(ped, hdc, pText, ich, FALSE, &ichMin, &ichMax, FALSE);

        if (ich > ichMin)
            ich = ichMax;
    }
#endif
    UNREFERENCED_PARAMETER(ped);
    UNREFERENCED_PARAMETER(hdc);
    UNREFERENCED_PARAMETER(pText);

    return ich;
}






////    Edit callout
//
//      The LPK edit support functions are acessed by the edit
//      control code through a struct defined in user.h.
//
//      Here we initialise that struct with the addresses
//      of the callout functions.


LPKEDITCALLOUT LpkEditControl = {
    EditCreate,
    EditIchToXY,
    EditMouseToIch,
    EditCchInWidth,
    EditGetLineWidth,
    EditDrawText,
    EditHScroll,
    EditMoveSelection,
    EditVerifyText,
    EditNextWord,
    EditSetMenu,
    EditProcessMenu,
    EditCreateCaret,
    EditAdjustCaret
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_glob.h ===
#ifndef __LPKGLOBAL__
#define __LPKGLOBAL__

/////   LPK_GLOB - LPK Global variable structure
//
//      The following data is global to each process.
//
//      This structure is instantiated with the name G by GAD.C. hence
//      any code can refer to these variables as G.xxx.
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//




#include <windows.h>
#include <usp10.h>
#include <wingdip.h>




#ifdef __cplusplus
extern "C" {
#endif




#ifdef LPKGLOBALHERE
#define LPKGLOBAL
#else
#define LPKGLOBAL extern
#endif

LPKGLOBAL  UINT                     g_ACP;                   // System default codepage

LPKGLOBAL  LCID                     g_UserLocale;            // User default locale
LPKGLOBAL  LANGID                   g_UserPrimaryLanguage;   // Primary language for user default locale
LPKGLOBAL  BOOL                     g_UserBidiLocale;        // Whether User default locale is Bidi

LPKGLOBAL  SCRIPT_DIGITSUBSTITUTE   g_DigitSubstitute;       // Users choice of digit substitution

LPKGLOBAL  HKEY                     g_hCPIntlInfoRegKey;     // Handle to Control Panel\International Registry Key
LPKGLOBAL  HANDLE                   g_hNLSWaitThread;        // Thread Handle
LPKGLOBAL  int                      g_iUseFontLinking;       // Set when GDI supports font linking


LPKGLOBAL  const SCRIPT_PROPERTIES **g_ppScriptProperties;   // Array of pointers to properties
LPKGLOBAL  int                      g_iMaxScript;
LPKGLOBAL  ULONG                    g_ulNlsUpdateCacheCount; // NLS Update Cache Count

LPKGLOBAL  DWORD                    g_dwLoadedShapingDLLs;   // Each shapping engin has a bit in this dwword.


/////   FontIDCache
//
//      Used to cache the font ID with flag tells if the font has Western Script.
//      This cache will be used in the optimization for ETO and GTE.
#define   MAX_FONT_ID_CACHE         30
LPKGLOBAL  CRITICAL_SECTION csFontIdCache;


typedef struct _tagFontIDCache
{
    UINT   uFontFileID;              // Unique ID number
    BOOL   bHasWestern;              // Falgs for the specified font.
} FONTIDCACHE;

LPKGLOBAL  FONTIDCACHE g_FontIDCache[MAX_FONT_ID_CACHE];
LPKGLOBAL  LONG        g_cCachedFontsID;       // # of cahced font ID.
LPKGLOBAL  LONG        g_pCurrentAvailablePos; // where can we cache next font ID.


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_gdi.cxx ===
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Module Name : LPK_GDI.c                                                 //
//                                                                          //
//  Entry points (formal interfaces) for GDI32 to call                      //
//  and route their APIs, so that we can implement our language-specific    //
//  features.                                                               //
//                                                                          //
//  Created : Oct 24, 1996                                                  //
//  Author  : Mohamed AbdEl Hamid  [mhamid]                                 //
//                                                                          //
//  Copyright (c) 1996, Microsoft Corporation. All rights reserved.         //
//////////////////////////////////////////////////////////////////////////////

#include "precomp.hxx"


////    FontHasWesternScript
//
//      Detect if the current selected font in the hdc has Western script or not by using
//      the cached data g_FontIDCache. and also add the selected font to the cache it it is
//      not cached before.
//      All calles used inside this function is Client-mode calls except if the font will be
//      cached then calling GetGlyphIndices (Kernel-mode call) will take place.
//      This function used in the optimization checking for ExtTextOut and GetTextExtent.
//
//      entry   hdc      - Device context
//
//      return value:    TRUE if font has western script. FALSE otherwise.
//

BOOL FontHasWesternScript(HDC hdc)
{
   REALIZATION_INFO ri;
   int              i;
   WORD             Glyphs[4];
   BOOL             fRet;

   if (!GdiRealizationInfo(hdc, &ri)) {
      return FALSE;
   }

   EnterCriticalSection(&csFontIdCache);

   if (g_cCachedFontsID > 0) {
      for (i=0 ; i<g_cCachedFontsID ; i++) {
         if (ri.uFontFileID == g_FontIDCache[i].uFontFileID) {
            fRet = g_FontIDCache[i].bHasWestern;
            LeaveCriticalSection(&csFontIdCache);
            return (fRet);
         }
      }
   }

   if ((GetGlyphIndicesW(hdc , L"dMr\"" , 4 , Glyphs , GGI_MARK_NONEXISTING_GLYPHS) == 4) &&
       (Glyphs[0] != 0xFFFF && Glyphs[1] != 0xFFFF && Glyphs[2] != 0xFFFF && Glyphs[3] != 0xFFFF)) {

      g_FontIDCache[g_pCurrentAvailablePos].bHasWestern     = fRet = TRUE;
   } else {
      g_FontIDCache[g_pCurrentAvailablePos].bHasWestern     = fRet = FALSE;
   }
   g_FontIDCache[g_pCurrentAvailablePos].uFontFileID  = ri.uFontFileID        ;

   g_pCurrentAvailablePos++;
   if (g_pCurrentAvailablePos >= MAX_FONT_ID_CACHE) {
       g_pCurrentAvailablePos = 0;
   }
   if (g_cCachedFontsID < MAX_FONT_ID_CACHE) {
      g_cCachedFontsID++;
   }
   LeaveCriticalSection(&csFontIdCache);
   return (fRet);
}



////    InternalTextOut
//
//      Display text with possible font association
//
//      entry   hdc      - Device context
//              x,y      - Starting coords (Unless TA_UPDATECP)
//              uOptions - Flags (see below)
//              prc      - Pointer to clipping rectangle
//              pString  - Unicode string
//              cbCount  - String length in unicode characters
//              pdx      - Overriding logical dx array
//              iCharset  - Original ANSI iCharset, or -1 if unicode
//
//      exit    TRUE if string drawn OK
//
//      options ETO_CLIPPED    - Clip to clipping rectangle
//              ETO_OPAQUE     - Extend background colour to bounds of clipping rectangle
//              ETO_RTLREADING - Render text with right to left reading order
//              ETO_NUMERICSLOCAL
//              ETO_NUMERICSLATIN
//              ETO_PDY        - lpdx array contains DX,DY pairs - causes LPK to be bypassed
//
//      note    LpkExtTextOut also obeys options set by SetTextAlign:
//              TA_LEFT       - x,y is position of left edge of displayed glyphs
//              TA_CENTRE     - x,y is position at centre of diplayed glyphs
//              TA_RIGHT      - x,y is position at right edge of displayed glyphs
//              TA_RTLREADING - Render text with right to left reading order
//              TA_UPDATECP   - Get x,y from current position, ignoring x,y parameters,
//                              update current position following textout.
//
//      history Oct 22, 1996 -by- Samer Arafeh [samera]
//              Oct 24, 1996 -by- Mohamed AbdEl Hamid [mhamid]
//              Feb 18, 1887 dbrown - Support font association






/////   InternalTextOut
//
//

BOOL InternalTextOut(
    HDC           hdc,
    int           x,
    int           y,
    UINT          uOptions,
    const RECT   *prc,
    const WCHAR  *pStr,
    UINT          cbCount,
    const int    *piDX,
    int           iCharset,
    int          *piWidth,
    int           iRequiredWidth) {

    BOOL          fRTLreading;
    int           iDigitSubstitute;
    int           iTextAlign;
    HRESULT       hr;
    DWORD         dwObjType;
    DWORD         dwSicFlags;   // Flags for ScriptIsComplex
    int           iCurrentCharSet;
    STRING_ANALYSIS *psa;

    UNREFERENCED_PARAMETER(iRequiredWidth) ;


    if (!cbCount || !pStr) {

        // Empty string - no glyph processing required. Optimise ...

        return ExtTextOutW(hdc, x, y, uOptions|ETO_GLYPH_INDEX, prc,
                           pStr, cbCount, piDX);
    }


    // ETO_PDY is not relevant for complex script strings. Let GDI
    // handle it. (APps wanting to adjust the y coordinate of glyphs in
    // complex script strings should use Uniscribe and manipulate the
    // pGoffset parameter to ScriptTextOut.

    if (uOptions & ETO_PDY) {
        return ExtTextOutW(hdc, x, y, uOptions | ETO_IGNORELANGUAGE, prc,
                       pStr, cbCount, piDX);
    }

    // Establish Bidi reading order.
    //
    // Note, it is possible for us to be passed an hdc that does not
    // support GetTextAlign, in which case GetTextAlign will return -1.
    // Treat this as left to right reading order.

    fRTLreading =     ((uOptions & ETO_RTLREADING)
                  ||  (((iTextAlign = GetTextAlign(hdc)) & TA_RTLREADING) && (iTextAlign != -1)))
                  ?   TRUE : FALSE;


    //  Interpret ETO_NUMERICS* flags:
    //  If both bits are set, the digit substitute = context. This is a win95
    //  compatability issue and is used mainly by Access.

    if ((uOptions&(ETO_NUMERICSLOCAL|ETO_NUMERICSLATIN)) == (ETO_NUMERICSLOCAL|ETO_NUMERICSLATIN)) {
        iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_CONTEXT;
    } else if (uOptions & ETO_NUMERICSLOCAL) {
        iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_TRADITIONAL;
    } else if (uOptions & ETO_NUMERICSLATIN) {
        iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_NONE;
    } else {
        iDigitSubstitute = -1;
    }

    uOptions = uOptions & ~(ETO_NUMERICSLOCAL | ETO_NUMERICSLATIN);


    // Check for plain text that can bypass the LPK entirely

    dwSicFlags = SIC_COMPLEX;

    if (    iDigitSubstitute == SCRIPT_DIGITSUBSTITUTE_CONTEXT
        ||  iDigitSubstitute == SCRIPT_DIGITSUBSTITUTE_TRADITIONAL
        ||  g_DigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE) {
        dwSicFlags |= SIC_ASCIIDIGIT;
    }

    if (fRTLreading != !!(GetLayout(hdc) & LAYOUT_RTL)) {
        dwSicFlags |= SIC_NEUTRAL;
    }

    if ((   ScriptIsComplex(pStr,cbCount,dwSicFlags) == S_FALSE
        && FontHasWesternScript(hdc)) 
        || GetTextCharacterExtra(hdc) != 0)
    {
        // No complex script processing required

        return ExtTextOutW(hdc, x, y, uOptions | ETO_IGNORELANGUAGE, prc,
                       pStr, cbCount, piDX);
    }


    dwObjType = GetObjectType(hdc);

    // Analyse the string

    hr = LpkStringAnalyse(
            hdc, pStr, cbCount, 0, -1,
              SSA_GLYPHS
            | (dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_DONTGLYPH : 0)
            | (iCharset==-1 || GdiIsPlayMetafileDC(hdc) ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
            | (fRTLreading  ? SSA_RTL : 0),
            iDigitSubstitute, iRequiredWidth,
            NULL, NULL,
            piDX,
            NULL, NULL,
            &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("InternalTextOut - LpkStringAnalyse"));
        return FALSE;
    }


    // Return string width if required (for DrawText)

    if (piWidth) {
        *piWidth = psa->size.cx;
    }


    hr = ScriptStringOut(psa, x, y, uOptions, prc, 0, 0, FALSE);

    ScriptStringFree((void**)&psa);

    if (SUCCEEDED(hr)) {
        return TRUE;
    } else {
        ASSERTHR(hr, ("InternalTextOut - ScriptStringOut"));
        return FALSE;
    }
}






BOOL LpkExtTextOut(
    HDC         hdc,
    int         x,
    int         y,
    UINT        uOptions,
    CONST RECT *prc,
    PCWSTR      pStr,
    UINT        cbCount,
    CONST INT  *pDx,
    int         iCharset) {

    return InternalTextOut(hdc, x, y, uOptions, prc, pStr, cbCount, pDx, iCharset, NULL, -1);
}


//////////////////////////////////////////////////////////////////////////////
// GDI32 GetTextExtentExPoint will call this function for supporting        //
// Multilingual Text handling.                                              //
//                                                                          //
// LpkGetTextExtentExPoint( HDC hdc, PWSTR pStr, int cchString,             //
//     int nMaxExtent, PINT pnFit, PINT pDx, PSIZE pSize, int iCharset)     //
//                                                                          //
// hDC          Identifies the device context                               //
// pStr         Points to string for which extents are to be retrieved.     //
// cchString    Count of characters in input string                         //
// nMaxExtent   Specifies the maximum allowable width, in logical units,    //
//              of the formatted string.                                    //
// pnFit        Maximum characters that fit in the formatted string         //
//              When the pnFit parameter is NULL, the nMaxExtent parameter  //
//              is ignored.                                                 //
//                                                                          //
// pDx          address of array for partial string widths                  //
// pSize        Address for string dimension                                //
// fl           ????                                                        //
// iCharset      Indicates character set of codes. to optimizing the work. ??//
//                                                                          //
// Return                                                                   //
//      If the function succeeds, the return value is TRUE.                 //
//      If the function fails, the return value is FALSE.                   //
//      And we seted the error by call SetLastError.                        //
//      To get extended error information, call GetLastError.               //
//                                                                          //
// History                                                                  //
//   Oct 22, 1996 -by- Samer Arafeh [samera]                                //
//   Oct 25, 1996 -by- MOhammed Abdul Hammed [mhamid]                       //
//////////////////////////////////////////////////////////////////////////////

BOOL LpkGetTextExtentExPoint(
    HDC    hdc,
    PCWSTR pStr,
    int    cchString,
    int    nMaxExtent,
    PINT   pnFit,
    PINT   pDx,
    PSIZE  pSize,
    FLONG  fl,
    int    iCharset)
{
    int         iTextAlign;
    BOOL        fRTLreading;
    int         i;
    HRESULT     hr;
    DWORD       dwObjType;
    DWORD       dwSicFlags;   // Flags for ScriptIsComplex
    int         iCurrentCharSet;
    STRING_ANALYSIS  *psa;
    STRING_ANALYSIS  *psaFit;
    UNREFERENCED_PARAMETER(fl) ;


    // Check required parameters

    if (!hdc  ||  !pSize) {

        ASSERTS(hdc,   ("LpkGetTextExtentPoint - required parameter hdc is NULL"));
        ASSERTS(pSize, ("LpkGetTextExtentPoint - required parameter pSize is NULL"));
        return FALSE;
    }


    //Do we have a string
    if (!cchString || !pStr) {
        //no then go away
        pSize->cx = 0;
        pSize->cy = 0;
        if (pnFit) {
            *pnFit = 0;
        }
        return TRUE;
    }


    iTextAlign = GetTextAlign(hdc);
    fRTLreading = (iTextAlign & TA_RTLREADING) && (iTextAlign != -1);


    // Check for plain text that can bypass the LPK entirely

    dwSicFlags = SIC_COMPLEX;

    if (g_DigitSubstitute.DigitSubstitute != SCRIPT_DIGITSUBSTITUTE_NONE) {
        dwSicFlags |= SIC_ASCIIDIGIT;
    }

    if (fRTLreading != !!(GetLayout(hdc) & LAYOUT_RTL)) {
        dwSicFlags |= SIC_NEUTRAL;
    }

    if ((   ScriptIsComplex(pStr, cchString, dwSicFlags) == S_FALSE
        && FontHasWesternScript(hdc))
        || GetTextCharacterExtra(hdc) != 0)
    {
        // No complex script processing required

        return GetTextExtentExPointWPri(hdc, pStr, cchString, nMaxExtent, pnFit, pDx, pSize);
    }


    dwObjType = GetObjectType(hdc);

    // Analyse the string

    hr = LpkStringAnalyse(
            hdc, pStr, cchString, 0, -1,
              SSA_GLYPHS
            // if the DC is Meta-File DC, we should enable the FallBack because it is enabled for ETOA while playing any Meta-File.
            | (iCharset==-1 || dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
            | (fRTLreading  ? SSA_RTL  : 0)
            | (pnFit        ? SSA_FULLMEASURE : 0),
            -1, nMaxExtent,
            NULL, NULL, NULL, NULL, NULL,
            &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("LpkGetTextExtentExPoint - LpkStringAnalyse"));
        return FALSE;
    }


    if (pDx) {

        // if we have pnFit and psa->cOutChars>=cchString so we should fill lpDx.
        if (!pnFit || psa->cOutChars>=cchString) {
            ScriptStringGetLogicalWidths(psa, pDx);
        }

        // we need to update the width of last fit glyph.
        if (pnFit && psa->cOutChars<cchString && psa->cOutChars>0) {
            hr = LpkStringAnalyse(
                    hdc, pStr, psa->cOutChars, 0, -1,
                      SSA_GLYPHS
                    // if the DC is Meta-File DC, we should enable the FallBack because it is enabled for ETOA while playing any Meta-File.
                    | (iCharset==-1 || dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
                    | (fRTLreading  ? SSA_RTL  : 0),
                    -1, 0,
                    NULL, NULL, NULL, NULL, NULL,
                    &psaFit);

            if (FAILED(hr)) {
                ScriptStringFree((void**)&psa);
                ASSERTHR(hr, ("LpkGetTextExtentExPoint - LpkStringAnalyse"));
                return FALSE;
            }
            ScriptStringGetLogicalWidths(psaFit, pDx);
            ScriptStringFree((void**)&psaFit);
        }

        // Accumulate extents
        for (i=1; i<(pnFit==NULL?cchString:psa->cOutChars); i++) {
            pDx[i] += pDx[i-1];
        }
    }

    if (pnFit) {
        *pnFit = psa->cOutChars;
    }

    *pSize = psa->size;

    ScriptStringFree((void**)&psa);

    return TRUE;
}







////    GetCharacterPlacement support
//
//




////    GCPgenerateOutString
//
//      Creates a reordered copy of the input string


void GCPgenerateOutString(
    STRING_ANALYSIS  *psa,
    WCHAR            *pwOutString) {

    int     i,j;
    int     iItem;
    int     iStart;
    int     iLen;
    WCHAR  *pwch;


    // Copy items one by one in visual order

    for (i=0; i<psa->cItems; i++) {

        iItem  = psa->piVisToLog[i];
        iStart = psa->pItems[iItem].iCharPos;
        iLen   = psa->pItems[iItem+1].iCharPos - iStart;

        if (psa->pItems[iItem].a.fRTL) {

            // Right to left item

            pwch = psa->pwInChars + iStart + iLen - 1;
            for (j=0; j<iLen; j++) {
                *pwOutString++ = *pwch--;
            }

        } else {

            // Left to right item

            memcpy(pwOutString, psa->pwInChars+iStart, sizeof(WCHAR) * iLen);
            pwOutString += iLen;
        }
    }
}







////    GCPgenerateClass
//
//      Creates an array of character classifications using
//      GetCharacterPlacement legacy definitons


void GCPgenerateClass(
    STRING_ANALYSIS  *psa,
    BYTE             *pbClass) {

    int  iItem;
    int  iStart;
    int  iLen;
    int  iClass;
    int  iChar;


    // Map LogClust entries item by item in logical order

    for (iItem=0; iItem<psa->cItems; iItem++) {

        iStart     = psa->pItems[iItem].iCharPos;
        iLen       = psa->pItems[iItem+1].iCharPos - iStart;

        if (g_ppScriptProperties[psa->pItems[iItem].a.eScript]->fNumeric) {

            if (psa->pItems[iItem].a.fLayoutRTL) {
                iClass = GCPCLASS_LOCALNUMBER;
            } else {
                iClass = GCPCLASS_LATINNUMBER;
            }

        } else {

            if (psa->pItems[iItem].a.fLayoutRTL) {
                iClass = GCPCLASS_ARABIC;  // (Same constant as GCPCLASS_HEBREW)
            } else {
                iClass = GCPCLASS_LATIN;
            }
        }

        memset(pbClass, iClass, iLen);
        pbClass += iLen;
    }
}






////    GCPgenerateCaretPos
//


void GCPgenerateCaretPos(
    STRING_ANALYSIS  *psa,
    int                     *piCaretPos) {

    int  i;

    // This is the easy way to generate lpCaretPos

    for (i=0; i<psa->cOutChars; i++) {

        ScriptStringCPtoX(psa, i, FALSE, piCaretPos + i);
    }
}


/******************************Public*Routine******************************\
* GCPJustification
*
* Justifies text according to piJustify and returns proper pwgi and piDx
* arrays.
*
* IMPORTANT : Caller should free (USPFREE(*ppwgi)) allocated buffer if
* the fn succeeds (SUCCEEDED(hr)) and return code isn't S_FALSE.
* S_FALSE means no justification is to be applied here since the piJustify and
* piDx are either identical or the total width to justify for is less than the
* min kashida width.
*
* All param are DWORD aligned.
*
* History :
*
*   Mar 23, 1998 -by-      Samer Arafeh [samera]
* wrote it
\**************************************************************************/
#define BlankPriority   10
HRESULT GCPJustification( WORD **ppwgi,                   // Out Output buffer width justified glyphs
                        int **ppiJustifyDx,               // Out Newly generated piDx buffer
                        WORD *pwgi,                       // In  Incoming GIs
                        const int *piAdvWidth,            // In  Advance wdiths
                        const SCRIPT_VISATTR *pVisAttr,   // In  Visual attributes
                        int *piJustify,                   // In  Justification advanced widths
                        int cGlyphs,                      // In  number of glyphs
                        int iKashidaWidth,                // In  Minimum width of kashida
                        int *pcJustifiedGlyphs,           // Out Receives the total # of glyphs in output buf
                        DWORD dwgKashida,                 // In Kashida GI
                        DWORD dwgSpace)                   // In Space GI
{
  DWORD dwSize;
  int iInsert=0L, iGlyph, iAmount, iJustDx;
  int cNewGlyphs = cGlyphs;
  WORD *pwNewGlyph;
  int *piNewAdvWidth;
  int   cMaxGlyphs = *pcJustifiedGlyphs;
  int cNonArabicGlyph;
  int cNonBlank;
  int iDelta;
  HRESULT hr;
  INT iPartialKashida;

  //
  // Point to caller's data initially
  //
  *ppwgi = pwgi;
  *ppiJustifyDx = (INT *)piJustify;
  *pcJustifiedGlyphs = cGlyphs;

  //
  // If Kashida width is less than or equal 0, then justify with spaces only.
  //
  if(iKashidaWidth <= 0L) {
    iKashidaWidth = -1;
  }

  //
  // 1- Analyze input buffer to see how many kashida to insert, If Kashida is used.
  //
  if (iKashidaWidth != -1 ) {
     cNonArabicGlyph = 0;
     cNonBlank       = 0;
     iDelta = 0;

     for( iGlyph=cGlyphs-1 ; iGlyph >= 0L ; iGlyph-- )
     {
        if( (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_NONE) ||
            (pVisAttr[iGlyph].uJustification >= SCRIPT_JUSTIFY_ARABIC_NORMAL)) {

            iAmount = piJustify[iGlyph]-piAdvWidth[iGlyph];
            if (iAmount > 0 && cNewGlyphs < cMaxGlyphs){
               iPartialKashida = iAmount % iKashidaWidth;
               iAmount /= iKashidaWidth;
               if (iPartialKashida > 0 && iAmount>0)
               {
                iAmount++;
               }
               if (cNewGlyphs + iAmount > cMaxGlyphs) {
                  iAmount = (cMaxGlyphs - cNewGlyphs) * iKashidaWidth;
                  cNewGlyphs = cMaxGlyphs;
                  iDelta += piJustify[iGlyph] - piAdvWidth[iGlyph] - iAmount;
                  piJustify[iGlyph] = piAdvWidth[iGlyph] + iAmount;
               } else {
                  cNewGlyphs += iAmount;
               }
            } else {
               iDelta += iAmount;
               piJustify[iGlyph] = piAdvWidth[iGlyph];
            }
        } else {

            if( (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_ARABIC_BLANK) ||
                (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_BLANK)) {
                cNonBlank++;
            } else {
                cNonArabicGlyph++;
            }
        }
     }

     if (iDelta > 0 && cNonArabicGlyph+cNonBlank>0) {
        // The Space has 10-times higher priority than Latin characters.
        iAmount = iDelta / (cNonArabicGlyph + (cNonBlank * BlankPriority));

        for( iGlyph=0  ; iGlyph < cGlyphs ; iGlyph++ )
        {
           if( (pVisAttr[iGlyph].uJustification != SCRIPT_JUSTIFY_NONE) &&
               (pVisAttr[iGlyph].uJustification < SCRIPT_JUSTIFY_ARABIC_NORMAL)) {


               if( (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_ARABIC_BLANK) ||
                   (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_BLANK)) {

                   piJustify[iGlyph] += BlankPriority * iAmount;
                   iDelta -= BlankPriority * iAmount;
               } else {
                   piJustify[iGlyph] += iAmount;
                   iDelta -= iAmount;
               }
               cNonArabicGlyph = iGlyph;
           }

        }
        if (iDelta > 0) {
          piJustify[cNonArabicGlyph] += iDelta;
        }
     }
  }

  //
  // 2- Allocate for new glyphs and piDx
  //

  dwSize = (cNewGlyphs * (sizeof(INT)+sizeof(WORD)));
  hr = USPALLOCTEMP( dwSize , (void **)&pwNewGlyph );
  if(FAILED(hr))
  {
    ASSERTHR(hr, ("Not ennough memory for JustifiyArabicStringWithKashida()"));
    return hr;
  }
  piNewAdvWidth = (INT *)(pwNewGlyph+cNewGlyphs);


  //
  // 3- Begin inserting and formulating the justified buffer
  //
  int iJustReminder = 0;

  for( iGlyph=cGlyphs-1, iInsert=cNewGlyphs-1; iGlyph >= 0L && iInsert>=0; iGlyph-- )
  {
    iJustDx = (piJustify[iGlyph] - piAdvWidth[iGlyph]) + iJustReminder;

    iJustReminder = 0;

    if( iJustDx > 0)
    {
      if( (pVisAttr[iGlyph].uJustification == SCRIPT_JUSTIFY_NONE) ||
          (pVisAttr[iGlyph].uJustification >= SCRIPT_JUSTIFY_ARABIC_NORMAL))
      {
        //Arabic glyph then justify with kashida
        if(( iJustDx >= iKashidaWidth ) && (iKashidaWidth != -1))
        {

          pwNewGlyph[iInsert] = pwgi[iGlyph];
          piNewAdvWidth[iInsert] = piAdvWidth[iGlyph];
          iInsert--;

          while( (iJustDx >= iKashidaWidth) && (iInsert >= 0L) )
          {
            pwNewGlyph[iInsert] = (WORD)dwgKashida;
            piNewAdvWidth[iInsert] = iKashidaWidth;
            iInsert--;

            iJustDx -= iKashidaWidth;
          }

          if(( iJustDx > 0L ) && (iInsert >= 0L))
          {
            pwNewGlyph[iInsert] = (WORD)dwgKashida;
            piNewAdvWidth[iInsert] = iJustDx;
            iInsert--;
            iJustDx = 0L;
          }
        }
        else
        {
          pwNewGlyph[iInsert] = pwgi[iGlyph];
          piNewAdvWidth[iInsert] = piAdvWidth[iGlyph];
          iJustReminder = iJustDx;
          iInsert--;
        }
      }
      else
      {
        pwNewGlyph[iInsert] = pwgi[iGlyph];
        piNewAdvWidth[iInsert] = piAdvWidth[iGlyph] + iJustDx;
        iInsert--;
      }
    }
    else
    {
      pwNewGlyph[iInsert] = pwgi[iGlyph];
      piNewAdvWidth[iInsert] = piJustify[iGlyph];
      iInsert--;
    }
  }

  //
  // In case there is a space glyph, it will be expanded in locatio rather
  // than inserting kashida GIs
  //
  while( iInsert >= 0L )
  {
    piNewAdvWidth[iInsert] = 0L;
    pwNewGlyph[iInsert] = (WORD)dwgSpace;
    iInsert--;
  }

  //
  // 4- Update results
  //
  *ppwgi = pwNewGlyph;
  *ppiJustifyDx = piNewAdvWidth;
  *pcJustifiedGlyphs = cNewGlyphs;

  return S_OK;
}


//////////////////////////////////////////////////////////////////////////////
// GDI32 GetCharacterPlacement will call this function for                  //
// supporting Multilingual Text handling.                                   //
//                                                                          //
// LpkGetCharacterPlacement( HDC hdc, PWSTR pStr, int nCount,               //
//        int nMaxExtent, LPGCP_RESULTSW pResults, DWORD dwFlags,           //
//                                                  int iCharset)           //
//                                                                          //
// hDC        : Handle to device context                                    //
// pStr       : Input string                                                //
// nCount     : Count of characters in input string                         //
// nMaxExtent : Maximum width for formatting string                         //
// pResults   : Pointer to GCP_RESULTS strucutre for output                 //
// dwFlags    : GCP Processing Flags                                        //
// iCharset   : Origianl character set of pStr                              //
//                                                                          //
// Return                                                                   //
//  If the function succeeds, the return value is Width an the Height       //
//      of the string                                                       //
//  If the function fails, the return value is 0.                           //
//      And we seted the error by call SetLastError.                        //
//      To get extended error information, call GetLastError.               //
//                                                                          //
// History :                                                                //
//   Oct 22, 1996 -by- Samer Arafeh [samera]                                //
//   Oct 29, 1996 -by- MOhammed Abdul Hammed [mhamid]                       //
//   Jan 13, 1997 -by- David C Brown (dbrown)                               //
//                        New justification widths buffer                   //
//                        ANALYSE field name changes                        //
//////////////////////////////////////////////////////////////////////////////

DWORD LpkGetCharacterPlacement(
    HDC              hdc,
    const WCHAR     *pwcInChars,
    int              cInChars,
    int              nMaxExtent,
    GCP_RESULTSW    *pResults,
    DWORD            dwFlags,
    int              iCharset) {

    UINT                   uBufferOptions;
    int                    iDigitSubstitute, i, cMaxGlyphs;
    int                    *pLocalDX;
    DWORD                  dwRet = 0;
    HRESULT                hr;
    DWORD                  dwSSAflags;
    SCRIPT_CONTROL         scriptControl = {0}; // Analysis control
    SCRIPT_STATE           scriptState   = {0}; // Initial state
    STRING_ANALYSIS        *psa;
    SCRIPT_FONTPROPERTIES  sfp;
    WORD                   *pwLocalGlyphs;



    TRACE(GDI, ("LpkGetCharacterPlacement begins"));


    //////////////////////////////////////////////////////////////////////////
    //                          1-Check parameters                          //
    //////////////////////////////////////////////////////////////////////////

    // Check required parameters
    ASSERTS(hdc,   ("LpkGetCharacterPlacement - required parameter hdc is NULL"));

    //GCP_MAXEXTENT and no nMaxExtent
    if ((dwFlags & GCP_MAXEXTENT) && (nMaxExtent < 0)) {
        TRACEMSG(("LpkGetCharacterPlacement: Invalid parameter - GCP_MAXEXTENT and no nMaxExtent"));
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    //GCP_CLASSIN set and no pClass
    if ((dwFlags & GCP_CLASSIN) && !(pResults->lpClass)) {
        TRACEMSG(("LpkGetCharacterPlacement: Invalid parameter - GCP_CLASSIN set and no pClass"));
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }


    //////////////////////////////////////////////////////////////////////////
    //                    2 - Interpret control flags                       //
    //////////////////////////////////////////////////////////////////////////


    switch (dwFlags & (GCP_NUMERICSLOCAL|GCP_NUMERICSLATIN)) {

        case GCP_NUMERICSLOCAL:
            iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_TRADITIONAL;
            break;

        case GCP_NUMERICSLOCAL|GCP_NUMERICSLATIN:
            iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_CONTEXT;
            break;

        case GCP_NUMERICSLATIN:
            iDigitSubstitute = SCRIPT_DIGITSUBSTITUTE_NONE;
            break;

        default:
            iDigitSubstitute = -1;
    }


    dwSSAflags = 0;

    if (dwFlags & GCP_REORDER) {
        if (GetTextAlign(hdc) & TA_RTLREADING ? 1 : 0) {
            dwSSAflags |= SSA_RTL;
        }
    } else {
        scriptState.fOverrideDirection = TRUE;
    }

    if (dwFlags & GCP_DISPLAYZWG)       scriptState.fDisplayZWG        = TRUE;
    if (!(dwFlags & GCP_LIGATE))        scriptState.fInhibitLigate     = TRUE;
    if (dwFlags & GCP_SYMSWAPOFF)       scriptState.fInhibitSymSwap    = TRUE;
    if (dwFlags & GCP_NEUTRALOVERRIDE)  scriptControl.fNeutralOverride = TRUE;
    if (dwFlags & GCP_NUMERICOVERRIDE)  scriptControl.fNumericOverride = TRUE;

    if (pResults->lpGlyphs) {
        scriptControl.fLinkStringBefore = pResults->lpGlyphs[0] & GCPGLYPH_LINKBEFORE  ? TRUE : FALSE;
        scriptControl.fLinkStringAfter  = pResults->lpGlyphs[0] & GCPGLYPH_LINKAFTER   ? TRUE : FALSE;
    }

    if (dwFlags & GCP_MAXEXTENT) {
        dwSSAflags |= SSA_CLIP;
        if (dwFlags & GCP_JUSTIFY) {
            dwSSAflags |= SSA_FIT;
            if (!(dwFlags & GCP_KASHIDA) || !(dwFlags & (GCP_GLYPHSHAPE | GCP_LIGATE))) {
                dwSSAflags |= SSA_NOKASHIDA;
            }
        }
    }

    if (dwFlags & GCP_CLASSIN) {
        if (((const BYTE *)pResults->lpClass)[0] & (GCPCLASS_PREBOUNDLTR | GCPCLASS_PREBOUNDRTL)) {
            scriptControl.fInvertPreBoundDir =    (((const BYTE *)pResults->lpClass)[0] & GCPCLASS_PREBOUNDRTL ? 1 : 0)
                                               ^  (dwSSAflags & SSA_RTL ? 1 : 0);
        }

        if (((const BYTE *)pResults->lpClass)[0] & (GCPCLASS_POSTBOUNDLTR | GCPCLASS_POSTBOUNDRTL)) {
            scriptControl.fInvertPostBoundDir =    (((const BYTE *)pResults->lpClass)[0] & GCPCLASS_POSTBOUNDRTL ? 1 : 0)
                                                ^  (dwSSAflags & SSA_RTL ? 1 : 0);
        }
    }


    //////////////////////////////////////////////////////////////////////////
    //               3-Call LPK_ANA to do Layout and Shaping                //
    //////////////////////////////////////////////////////////////////////////

    if (dwFlags & GCP_CLASSIN) {
        hr = LpkStringAnalyse(
                hdc, pwcInChars, cInChars, pResults->nGlyphs, -1,
                dwSSAflags | SSA_GLYPHS | SSA_GCP,
                iDigitSubstitute, nMaxExtent,
                &scriptControl, &scriptState,
                NULL,
                NULL,
                (BYTE*)pResults->lpClass,
                &psa);
    } else {
        hr = LpkStringAnalyse(
                hdc, pwcInChars, cInChars, pResults->nGlyphs, -1,
                dwSSAflags | SSA_GLYPHS | SSA_GCP,
                iDigitSubstitute, nMaxExtent,
                &scriptControl, &scriptState,
                NULL,
                NULL,
                NULL,
                &psa);
    }
    if (FAILED(hr)) {
        ASSERTHR(hr, ("LpkGetTextExtentExPoint - LpkStringAnalyse"));
        return FALSE;
    }

    //
    // If the user's suppled buffer isn't sufficient to hold the
    // output, then let's truncate it.
    //
    if (pResults->nGlyphs < (UINT) psa->cOutGlyphs) {
        psa->cOutGlyphs = (UINT) pResults->nGlyphs;
    }

    if (pResults->lpOutString) {
        GCPgenerateOutString(psa, pResults->lpOutString);
    }


    if (pResults->lpOrder) {
        ScriptStringGetOrder(psa, pResults->lpOrder);
    }


    if (pResults->lpClass) {
        GCPgenerateClass(psa, (PBYTE) pResults->lpClass);
    }

    BOOL bGlyphsCopied = FALSE;

    if (pResults->lpDx) {
        if (psa->piJustify  && (dwFlags & GCP_JUSTIFY)) {
            sfp.cBytes = sizeof(SCRIPT_FONTPROPERTIES);
            hr = ScriptGetFontProperties(hdc,
                                         &psa->sc[0],
                                         &sfp);
            if(SUCCEEDED(hr)) {
                if (!(dwFlags & GCP_KASHIDA) || !(dwFlags & (GCP_GLYPHSHAPE | GCP_LIGATE)))
                    sfp.iKashidaWidth = -1;
                else {
                    ASSERTS(sfp.wgKashida,   ("LpkGetCharacterPlacement - ther is no Kashida glyph"));
                }

                cMaxGlyphs = pResults->nGlyphs;

                hr = GCPJustification( (WORD **)&pwLocalGlyphs,
                                       (int **)&pLocalDX,
                                       (WORD *)psa->pwGlyphs,
                                       (int *)psa->piAdvance,
                                       psa->pVisAttr,
                                       psa->piJustify,
                                       psa->cOutGlyphs,
                                       sfp.iKashidaWidth,
                                       &cMaxGlyphs,
                                       sfp.wgKashida,
                                       sfp.wgBlank);
                if(SUCCEEDED(hr)) {
                    int iOffset = 0;
                    if (cMaxGlyphs > (int)pResults->nGlyphs) {
                        iOffset = cMaxGlyphs - pResults->nGlyphs;
                        cMaxGlyphs = pResults->nGlyphs;
                    }

                    psa->cOutGlyphs = cMaxGlyphs;

                    if (pResults->lpGlyphs) {
                        memcpy (pResults->lpGlyphs, (LPVOID)(pwLocalGlyphs+iOffset), sizeof(WORD) * cMaxGlyphs);
                        bGlyphsCopied = TRUE;
                    }

                    psa->size.cx = 0;
                    for (i=0; i<cMaxGlyphs; i++) {
                        pResults->lpDx[i] = pLocalDX[i+iOffset];
                        psa->size.cx += pLocalDX[i+iOffset];
                    }
                    USPFREE((LPVOID)pwLocalGlyphs);
                }
            }

        } else {
            memcpy(pResults->lpDx,  psa->piAdvance,  sizeof(int) * psa->cOutGlyphs);
        }
    }

    if (!bGlyphsCopied && pResults->lpGlyphs) {
        memcpy(pResults->lpGlyphs,  psa->pwGlyphs,  sizeof(WORD) * psa->cOutGlyphs);
    }


    if (dwFlags & (GCP_GLYPHSHAPE | GCP_LIGATE))
        pResults->nGlyphs = psa->cOutGlyphs;
    else
        pResults->nGlyphs = cInChars;

    pResults->nMaxFit = psa->cOutChars;


    // If there was justification we may have zero glyphs

    if (!psa->cOutGlyphs) {

        pResults->nGlyphs = 0;

        ScriptStringFree((void**)&psa);


        // Weird Middle East Win95 compatability rules

        if (    (dwFlags & GCP_MAXEXTENT)
            || !(dwFlags & GCP_GLYPHSHAPE)
            || !pResults->lpGlyphs) {

            return 1;

        } else {

            return 0;
        }
    }


    //////////////////////////////////////////////////////////////////////////
    //                      4-Generate lpCaretPos                           //
    //////////////////////////////////////////////////////////////////////////

    if (pResults->lpCaretPos) {
        char   *pbClass   = NULL;
        INT    *piAdvance = pResults->lpDx  ? pResults->lpDx : psa->piAdvance;
        UINT   *puiOrder  = NULL;
        INT    *pCaretCalc;
        INT     iWidth    = 0;
        UINT    i, uOrder;
        HRESULT hr;

        hr = USPALLOC(sizeof(INT)*pResults->nGlyphs, (void **)&pCaretCalc);

        if(FAILED(hr)) {
            ScriptStringFree((void**)&psa);
            return 0;
        }

        // Allocate for pbClass if pResults->lpClass is NULL otherwise us it.
        if (pResults->lpClass == NULL) {
            hr = USPALLOC(sizeof(char)*cInChars, (void **)&pbClass);
            if(FAILED(hr)) {
                USPFREE(pCaretCalc);
                ScriptStringFree((void**)&psa);
                return 0;
            }
            GCPgenerateClass(psa, (PBYTE) pbClass);
        } else {
            pbClass = pResults->lpClass;
        }

        // Allocate for puiOrder if pResults->lpOrder is NULL otherwise us it.
        if (pResults->lpOrder == NULL) {
            hr = USPALLOC(sizeof(UINT)*cInChars, (void **)&puiOrder);
            if(FAILED(hr)) {
                if (pResults->lpClass == NULL) {
                    USPFREE(pbClass);
                }
                USPFREE(pCaretCalc);
                ScriptStringFree((void**)&psa);
                return 0;
            }
            ScriptStringGetOrder(psa, puiOrder);
        } else {
            puiOrder = pResults->lpOrder;
        }

        // simple-minded loop used to generate glyph-offsets
        // as the same code used in NT4/MET.

        for( i=0 ; i<pResults->nGlyphs ; i++ ) {
            if (pbClass[i] == GCPCLASS_ARABIC) {
                iWidth += piAdvance[i];
                pCaretCalc[i] = iWidth - 1;
                if (iWidth == 0) {
                    pCaretCalc[i] = 0;
                }
            } else {
                pCaretCalc[i] = iWidth;
                iWidth += piAdvance[i];
            }
        }

        // Convert to char-indexing. We need to take care if the
        // user supplied in sufficient visual buffers
        for( i=0 ; i<(UINT)cInChars ; i++ ) {
            uOrder = puiOrder[i];
            if ((uOrder+1) > (UINT)psa->cOutGlyphs) {
                uOrder = 0;
            }
            pResults->lpCaretPos[i] = pCaretCalc[uOrder];
        }

        if (pResults->lpOrder == NULL) {
            USPFREE(puiOrder);
        }
        if (pResults->lpClass == NULL) {
            USPFREE(pbClass);
        }
        USPFREE(pCaretCalc);
    }


    //////////////////////////////////////////////////////////////////////////
    //                      5 - Return width and height                     //
    //////////////////////////////////////////////////////////////////////////


    dwRet = (psa->size.cx & 0xffff) + (psa->size.cy << 16);


    //////////////////////////////////////////////////////////////////////////
    //                      6 - Free allocated memory and exit              //
    //////////////////////////////////////////////////////////////////////////


    ScriptStringFree((void**)&psa);

    return dwRet;
}


/******************************Public*Routine******************************\
*
* BOOL LpkUseGDIWidthCache( HDC hDC , LPCSTR psz , int count ,
*                           LONG fl , BOOL fUnicode)
*
* Checks whether the LPK can use GDI cached widths for the ASCII (0<=x<=127)
* by inspecting the following variables :
* - System numeric shape setting
* - DC Align state
* - The selected font has Western script
* - The string code points in range 0<=x<=127 with Ansi calls
*
* Returns TRUE if it is OK to use GDI width cache, otherwise FALSE
*
* History:
*  28-Aug-1997 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/
BOOL LpkUseGDIWidthCache( HDC hDC , LPCSTR psz , int count , LONG fl , BOOL fUnicode)
{
    BOOL bRet;
    int   i;
    BYTE  cTest;
    LPSTR pstr;

    //
    // Let's make sure that :
    // 1- Text is LTR Reading
    // 2- Digits shape setting is Arabic
    // 3- if Unicode call, make sure the font has Western script
    //    if Ansi call check if all code points less than 0x80 and font has Wetern script.

    bRet =      (!!(fl & TA_RTLREADING) == !!(GetLayout(hDC) & LAYOUT_RTL))
            &&  g_DigitSubstitute.DigitSubstitute == SCRIPT_DIGITSUBSTITUTE_NONE;

    TRACE( GDI, ("LpkUseGDIWidthCache: g_DigitSubstitute.DigitSubstitute=%x, bRet=%x",
                 g_DigitSubstitute.DigitSubstitute, bRet));


    if (bRet) {

       // We don't need this check for Unicdoe calls because it is done in GDI.
       if (!fUnicode) {
          cTest = 0;
          i = count;
          pstr = (LPSTR) psz;

          unroll_here:
          switch(i)
          {
              default:
                  cTest |= pstr[9];
              case 9:
                  cTest |= pstr[8];
              case 8:
                  cTest |= pstr[7];
              case 7:
                  cTest |= pstr[6];
              case 6:
                  cTest |= pstr[5];
              case 5:
                  cTest |= pstr[4];
              case 4:
                  cTest |= pstr[3];
              case 3:
                  cTest |= pstr[2];
              case 2:
                  cTest |= pstr[1];
              case 1:
                  cTest |= pstr[0];
          }

          if ((i > 10) && !(cTest & 0x80))
          {
              i -= 10;
              pstr += 10;
              goto unroll_here;
          }

          bRet = !(cTest & 0x80);
       }

       return (bRet && FontHasWesternScript(hDC));
    }

    return bRet ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_glob.c ===
/////   LPK_GLOB - LPK Global variable structure
//
//      The following data is global to each process.
//
//      This structure is instantiated with the name G by GAD.C. hence
//      any code can refer to these variables as G.xxx.
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//




#define LPKGLOBALHERE


#include "lpk_glob.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_user.cxx ===
//////////////////////////////////////////////////////////////////////////////
//                                                                          //
//  Module Name : LPK_USER.c                                                //
//                                                                          //
//  Entry points (formal interfaces) for GDI32 to call                      //
//  and route their APIs, so that we can implement our language-specific    //
//  features.                                                               //
//                                                                          //
//  Created : Nov 6, 1996                                                   //
//  Author  : Mohamed AbdEl Hamid  [mhamid]                                 //
//                                                                          //
//  Copyright (c) 1996, Microsoft Corporation. All rights reserved.         //
//////////////////////////////////////////////////////////////////////////////

#include "precomp.hxx"




/////   Shared definitions for USER code

#define IS_ALTDC_TYPE(h)    (LO_TYPE(h) != LO_DC_TYPE)



///

#undef TRACE
#define TRACE(a,b)



//////////////////////////////////////////////////////////////////////////////
// USER32 TabbedTextOut will call this function for supporting Multilingual //
//          Tabbed Text handling.                                           //
// LpkTabbedTextOut( HDC hdc , int x, int y, LPCWSTR lpstring, UINT nCount, //
//                  int nTabPositions, LPINT lpTabPositions, int iTabOrigin,//
//                  BOOL fDrawTheText, int cxCharWidth, int cyCharHeight,   //
//                  int charSet)                                            //
// hDC              :   Handle of device context                            //
// x                :   x-coordinate of text to render                      //
// y                :   y-coordinate of text to render                      //
// lpstring         :   Input string                                        //
// nCount           :   Count of characters in input string                 //
// nTabPositions    :   Specifies the number of values in the array of      //
//                      tab-stop positions.                                 //
// lpTabPositions   :   The tab-stop positions array (increasing order)(+/-)//
// iTabOrigin       :   The X-coordinate position to start expand tabs      //
// fDrawTheText     :   Draw the Text or expand tha tabs only               //
// cxCharWidth      :   Character width to be use to expand the tabs        //
// cxCharHeight     :   Character Height to be use to expand the tabs       //
// charSet   :  Indicates character set of codes. to optimizing the work. ??//
//                                                                          //
// Return       :                                                           //
//      If the function succeeds, return the string dimensions              //
//      Else, the return value is 0.                                        //
//          And we seted the error by call SetLastError.                    //
//                                                                          //
// History :                                                                //
//   Nov 6, 1996 -by- Mohamed AbdEl Hamid [mhamid]                          //
//////////////////////////////////////////////////////////////////////////////
LONG LpkTabbedTextOut(
    HDC         hdc,
    int         x,
    int         y,
    WCHAR      *pwcInChars,
    int         nCount,
    int         nTabPositions,
    int        *pTabPositions,
    int         iTabOrigin,
    BOOL        fDrawTheText,
    int         cxCharWidth,
    int         cyCharHeight,
    int         iCharset) {


    SIZE        textextent;
    SIZE        viewextent;
    SIZE        windowextent;
    int         initialx = x;
    int         cch;
    WCHAR      *pwc;
    int         iOneTab = 0;
    RECT        rc;
    UINT        uOpaque;
    BOOL        fStrStart = TRUE;
    BOOL        fRTLreading;
    int         ySign = 1;     //Assume y increases in down direction.
    UINT        OldTextAlign;
    HRESULT     hr;
    DWORD       dwObjType;
    RECT        rcRTL;

    STRING_ANALYSIS *psa;


    uOpaque = (GetBkMode(hdc) == OPAQUE) ? ETO_OPAQUE : 0;


    /*
    * If no tabstop positions are specified, then use a default of 8 system
    * font ave char widths or use the single fixed tab stop.
    */
    if (!pTabPositions) {
        // no tab stops specified -- default to a tab stop every 8 characters
        iOneTab = 8 * cxCharWidth;
    } else if (nTabPositions == 1) {
        // one tab stop specified -- treat value as the tab increment, one
        // tab stop every increment
        iOneTab = pTabPositions[0];

        if (!iOneTab) {
            iOneTab = 1;
        }
    }


    // Calculate if the y increases or decreases in the down direction using
    // the ViewPortExtent and WindowExtents.
    // If this call fails, hdc must be invalid

    if (!GetViewportExtEx(hdc, &viewextent)) {
        TRACEMSG(("LpkTabbedTextOut: GetViewportExtEx failed"));
        return 0;
    }

    GetWindowExtEx(hdc, &windowextent);
    if ((viewextent.cy ^ windowextent.cy) & 0x80000000) {
        ySign = -1;
    }

    OldTextAlign = GetTextAlign(hdc);
    fRTLreading  = OldTextAlign & TA_RTLREADING;

    SetTextAlign(hdc, (OldTextAlign & ~(TA_CENTER|TA_RIGHT)) | TA_LEFT);

    rc.left = initialx;
    rc.right= initialx;

    rc.top = y;

    if (OldTextAlign & TA_BOTTOM) {
        rc.bottom = rc.top;
    } else {
        rc.bottom = rc.top + (ySign * cyCharHeight);
    }

    while (TRUE) {

        // count the number of characters until the next tab character
        // this set of characters (substring) will be the working set for
        // each iteration of this loop

        for (cch = nCount, pwc = pwcInChars; cch && (*pwc != TEXT('\t')); pwc++, cch--) {
        }

        // Compute the number of characters to be drawn with textout.
        cch = nCount - cch;

        // Compute the number of characters remaining.
        nCount -= cch;       // + 1;

        // get height and width of substring
        if (cch == 0) {

            textextent.cx = 0;
            textextent.cy = cyCharHeight;
            psa = NULL;

        } else {

            dwObjType = GetObjectType(hdc);
            hr = LpkStringAnalyse(
                    hdc, pwcInChars, cch, 0, -1,
                      SSA_GLYPHS
                    | (dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_METAFILE : 0)
                    | (iCharset==-1 || GdiIsPlayMetafileDC(hdc) ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
                    | (fRTLreading  ? SSA_RTL : 0),
                    -1, 0,
                    NULL, NULL, NULL, NULL, NULL,
                    &psa);
            if (FAILED(hr)) {
                ASSERTHR(hr, ("LpkTabbedTextOut - LpkStringAnalyse"));
                return FALSE;
            }

            textextent = psa->size;
        }

        if (fStrStart) {
            // first iteration should just spit out the first substring
            // no tabbing occurs until the first tab character is encountered
            fStrStart = FALSE;
        } else {
            // not the first iteration -- tab accordingly

            int xTab;
            int i;

            if (!iOneTab) {
                // look thru tab stop array for next tab stop after existing
                // text to put this substring
                for (i = 0; i != nTabPositions; i++) {
                    xTab = pTabPositions[i];

                    if (xTab < 0) {
                        // calc length needed to use this right justified tab
                        xTab = iTabOrigin - xTab - textextent.cx;
                    } else {
                        // calc length needed to use this left  justified tab
                        xTab = iTabOrigin + xTab;
                    }
                    if ((xTab - x) > 0) {
                        // we found a tab with enough room -- let's use it
                        x = xTab;
                        break;
                    }
                }
                if (i == nTabPositions) {
                    // we've exhausted all of the given tab positions
                    // go back to default of a tab stop every 8 characters
                    iOneTab = 8 * cxCharWidth;
                }
            }

            // we have to recheck iOneTab here (instead of just saying "else")
            // because iOneTab will be set if we've run out of tab stops
            if (iOneTab) {
                if (iOneTab < 0) {
                    // calc next available right justified tab stop
                    xTab = x + textextent.cx - iTabOrigin;
                    xTab = ((xTab / iOneTab) * iOneTab) - iOneTab - textextent.cx + iTabOrigin;
                } else {
                    // calc next available left justified tab stop
                    xTab = x - iTabOrigin;
                    xTab = ((xTab / iOneTab) * iOneTab) + iOneTab + iTabOrigin;
                }
                x = xTab;
            }
        }

        if (fDrawTheText && (cch!=0)) {
            /*
            * Output all text up to the tab (or end of string) and get its
            * extent.
            */
            rc.right = x + textextent.cx;

            // All the calculations are made as if it is LTR and we flip the coordinates
            // if we have RTL.
            if (fRTLreading) {
                rcRTL = rc;
                rcRTL.left = (2 * initialx) - rc.right;
                rcRTL.right= rcRTL.left + (rc.right - rc.left) ;
                ScriptStringOut(psa, rcRTL.left , y, uOpaque, &rcRTL, 0, 0, FALSE);
            } else {

                ScriptStringOut(psa, x, y, uOpaque, &rc, 0, 0, FALSE);
            }
            rc.left = rc.right;
        }

        if (cch) {
            ScriptStringFree((void**)&psa);
        }

        // Skip over the tab and the characters we just drew.
        x = x + textextent.cx;

        // Skip over the characters we just drew.
        pwcInChars += cch;

        // See if we have more to draw OR see if this string ends in
        // a tab character that needs to be drawn.
        if ((nCount > 0) && (*pwcInChars == TEXT('\t'))) {
            pwcInChars++;  // Skip over the tab
            nCount--;
            continue;
        } else {
            break;        // Break from the loop.
        }
    }

    // if we have at the end of the text some Tabs then wen need to drae the background
    // for it.
    if (fDrawTheText && x>rc.right && uOpaque)
    {
        rc.right = x;

        if (fRTLreading) {
            rcRTL = rc;
            rcRTL.left = (2 * initialx) - rc.right;
            rcRTL.right= rcRTL.left + (rc.right - rc.left) ;
            ExtTextOutW(hdc, rcRTL.left, y, uOpaque|ETO_IGNORELANGUAGE, &rcRTL, L"", 0, NULL);
        } else {
            ExtTextOutW(hdc, rc.left, y, uOpaque|ETO_IGNORELANGUAGE, &rc, L"", 0, NULL);
        }
    }

    SetTextAlign(hdc, OldTextAlign);

    return MAKELONG((x - initialx), (short)textextent.cy);
}







//////////////////////////////////////////////////////////////////////////////
// USER32 PSMTextOut will call this function for supporting Multilingual    //
//          Menu handling.                                                  //
// LpkPSMTextOut( HDC hdc, int xLeft, int yTop, LPCWSTR  lpString,          //
//                  int  nCount)                                            //
// hDC              :   Handle of device context                            //
// xLeft            :   x-coordinate of text to render                      //
// yTop             :   y-coordinate of text to render                      //
// lpString         :   Input string                                        //
// nCount           :   Count of characters in input string                 //
//                                                                          //
// Return           :   Nothing                                             //
//                                                                          //
// History :                                                                //
//   Nov 6, 1996 -by- Mohamed AbdEl Hamid [mhamid]                          //
//////////////////////////////////////////////////////////////////////////////


/////   LpkInternalPSMtextOut
//
//      Called from LPK_USRC.C

int LpkInternalPSMTextOut(
    HDC           hdc,
    int           xLeft,
    int           yTop,
    const WCHAR  *pwcInChars,
    int           nCount,
    DWORD         dwFlags) {


    HRESULT       hr;
    int           iTextAlign;
    STRING_ANALYSIS  *psa;
    int           iWidth;
    DWORD         dwObjType;


    if (!nCount || !pwcInChars) {

        // No action required

        TRACE(GDI, ("LpkPSMTextOut: No string: nCount %d, pwcInChars %x",
                     nCount, pwcInChars));
        return 0;   // That was easy!
    }


    dwObjType = GetObjectType(hdc);


    hr = LpkStringAnalyse(
        hdc, pwcInChars, nCount, 0, -1,
          SSA_GLYPHS
        |    (dwFlags & DT_NOPREFIX ? 0
           : (dwFlags & DT_HIDEPREFIX ? SSA_HIDEHOTKEY
           : (dwFlags & DT_PREFIXONLY ? SSA_HOTKEYONLY : SSA_HOTKEY)))
        | (dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_METAFILE : 0)
        | SSA_FALLBACK
        | ((((iTextAlign = GetTextAlign(hdc)) & TA_RTLREADING) && (iTextAlign != -1)) ? SSA_RTL : 0),
        -1, 0,
        NULL, NULL, NULL, NULL, NULL,
        &psa);

    if (SUCCEEDED(hr)) {

        iWidth = psa->size.cx;
        ScriptStringOut(psa, xLeft, yTop, 0, NULL, 0, 0, FALSE);
        ScriptStringFree((void**)&psa);

    } else {

        iWidth = 0;
        ASSERTHR(hr, ("LpkInternalPSMTextOut - LpkStringAnalyse"));
        psa = NULL;

    }

    return iWidth;
}





#ifdef LPKBREAKAWORD

//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// LpkBreakAWord : DrawText calls this routine when the length of a word    //
//                 is longer than the line width.                           //
//                                                                          //
// return - character position to break a non-breakable word                //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////


/////   LpkBreakAWord
//
//      Called from LPK_USRC.C

int LpkBreakAWord(
    HDC     hdc,
    LPCWSTR lpchStr,
    int     cchStr,
    int     iMaxWidth) {

    if (!lpchStr || cchStr <= 0 || iMaxWidth <= 0)
        return 0;


    STRING_ANALYSIS*    psa;
    int                 cOutChars;
    HRESULT             hr;


    hr = LpkStringAnalyse(
         hdc, lpchStr, cchStr, 0, -1,
         SSA_GLYPHS | SSA_CLIP,
         -1, iMaxWidth,
         NULL, NULL, NULL, NULL, NULL,
         &psa);

    if (FAILED(hr)) {
        ASSERTHR(hr, ("LpkBreakAWord - qLpkStringAnalyse"));
        return 0;
    }

    cOutChars = psa->cOutChars;

    ScriptStringFree((void**)&psa);

    return max(0, cOutChars);
}

#endif





//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// LpkGetNextWord                                                           //
// return - offset to the next word                                         //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////
#define CR  0x000D
#define LF  0x000A


/////   LpkgetNextWord
//
//      Called from LPK_USRC.C

int LpkGetNextWord(
    HDC      hdc,
    LPCWSTR  lpchStr,
    int      cchCount,
    int      iCharset) {

    WCHAR   *pRun;
    WCHAR   *pRunEnd;
    int      cchRun;
    int      i=0;
    WCHAR    wchRun;
    HRESULT  hr;
    STRING_ANALYSIS *psa;


    // instantly advance 1 if current char located at whitespaces.

    if (*lpchStr == '\t' || *lpchStr == ' ') {
        return 1;
    }


    // try to find the shortest text run that are going to be analysed

    cchRun = 0;
    pRun = (PWSTR)lpchStr;
    pRunEnd = (PWSTR)(lpchStr + cchCount);
    while (pRun < pRunEnd) {
        wchRun = *pRun;
        if (wchRun == CR || wchRun == LF ||
            wchRun == '\t' || wchRun == ' ') {
            break;
        }
        pRun++;
        cchRun++;
    }

    if (cchRun == 0) {
        return 0;
    }

    hr = LpkStringAnalyse(
         hdc, lpchStr, cchRun, 0, -1,
         SSA_BREAK,
         -1, 0,
         NULL, NULL, NULL, NULL, NULL,
         &psa);
    if (FAILED(hr)) {
        ASSERTHR(hr, ("LpkGetNextWord - qLpkStringAnalyse"));
        return 0;
    }

    // We only return next wordbreak if the first item is a breakable one.
    if (g_ppScriptProperties[psa->pItems->a.eScript]->fComplex) {
        for (i=1; i < cchRun; i++) {
            if (psa->pLogAttr[i].fSoftBreak )
                break;
        }
    }

    ScriptStringFree((void**)&psa);

    return i;
}

//////////////////////////////////////////////////////////////////////////////
// USER32 DrawTextEx will call this function for supporting Multilingual    //
//          DrawTextEx handling.                                            //
// LpkDrawTextEx(HDC hdc, int xLeft, int yTop,LPCWSTR pwcInChars, int cchCount//
//                  , BOOL fDraw, WORD wFormat, LPDRAWTEXTDATA lpDrawInfo,  //
//                  UNIT bAction)                                           //
// hDC              :   Handle of device context                            //
// xLeft            :   x-coordinate of text to render                      //
// yTop             :   y-coordinate of text to render                      //
// lpchStr          :   Input string                                        //
// cchCount         :   Count of characters in input string                 //
// fDraw            :   Draw the Text or expand tha tabs only               //
// wFormat          :   Same as dwDTFormat options for DrawTextEx           //
// lpDrawInfo       :   Internal Structure                                  //
// bAction          :   DT_CHARSETDRAW OR DT_GETNEXTWORD                    //
//                                                                          //
// Return       : Nothing                                                   //
//                                                                          //
// History :                                                                //
//   Nov 15, 1996 -by- Mohamed AbdEl Hamid [mhamid]                         //
//   Mar 26, 1997 Adding DT_GETNEXTWORD  -[wchao]                           //
//////////////////////////////////////////////////////////////////////////////


/////   LpkCharsetDraw
//
//      Called from LPK_USRC.C
//
//      Note: Doesn't implement user defined tabstops

int LpkCharsetDraw(
    HDC             hdc,
    int             xLeft,
    int             cxOverhang,
    int             iTabOrigin,
    int             iTabLength,
    int             yTop,
    PCWSTR          pcwString,
    int             cchCount,
    BOOL            fDraw,
    DWORD           dwFormat,
    int             iCharset) {


    HRESULT           hr;
    int               iTextAlign;
    int               iWidth;
    STRING_ANALYSIS  *psa;
    SCRIPT_TABDEF     std;
    DWORD             dwObjType;


    if (cchCount <= 0) {
        return 0;   // That was easy!
    }


    if (dwFormat & DT_EXPANDTABS) {

        std.cTabStops  = 1;
        std.pTabStops  = &iTabLength;
        std.iTabOrigin = 0;
        std.iScale     = 4;        // Tab stops in pixels (avg ch width already applied in USER)
    }

    dwObjType = GetObjectType(hdc);


    hr = LpkStringAnalyse(
        hdc, pcwString, cchCount, 0, -1,
          SSA_GLYPHS
        |    (dwFormat & DT_NOPREFIX ? 0
           : (dwFormat & DT_HIDEPREFIX ? SSA_HIDEHOTKEY
           : (dwFormat & DT_PREFIXONLY ? SSA_HOTKEYONLY : SSA_HOTKEY)))
        | (dwFormat & DT_EXPANDTABS                               ? SSA_TAB      : 0)
        | (dwObjType == OBJ_METADC || dwObjType == OBJ_ENHMETADC ? SSA_METAFILE : 0)
        | (iCharset==-1 || GdiIsPlayMetafileDC(hdc) ? SSA_FALLBACK : SSA_LPKANSIFALLBACK)
        | (    dwFormat & DT_RTLREADING
           ||  (((iTextAlign = GetTextAlign(hdc)) & TA_RTLREADING) && (iTextAlign != -1))
           ?   SSA_RTL : 0),
        -1, 0,
        NULL, NULL, NULL,
        dwFormat & DT_EXPANDTABS ? &std : NULL,
        NULL,
        &psa);

    if (SUCCEEDED(hr)) {

        iWidth = psa->size.cx;

        if (fDraw && (!(dwFormat & DT_CALCRECT))) {
            ScriptStringOut(psa, xLeft, yTop, 0, NULL, 0, 0, FALSE);
        }

        ScriptStringFree((void**)&psa);

    } else {

        iWidth = 0;
        ASSERTHR(hr, ("LpkCharsetDraw - LpkStringAnalyse"));
        psa = NULL;
    }

    return iWidth;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_init.cxx ===
/********************************************************************
 *
 *  Module Name : lpk_init.cxx
 *
 *  The module handles the Dll entry point and intialization routines.
 *
 *  Created : Oct 21, 1996
 *  Author  : Samer Arafeh  [samera]
 *
 *  Copyright (c) 1996, Microsoft Corporation. All rights reserved.
 *
 **********************************************************************/


#include "precomp.hxx"






/***************************************************************************\
* FindStartOfString
*
* Searches the unicode res string for the specified pattern.
*
* History:
* 2-Jan-1998 SamerA    Created.
\***************************************************************************/


PWSTR FindStartOfString(
    PWSTR pwszToFind,
    ULONG uLenToFind,
    PWSTR pResourceData,
    ULONG uSearchLen)
{
    ULONG i=0,j=0;
    PWSTR pwszMatch=pResourceData ;

  
    if ( uLenToFind > uSearchLen ) {
        return NULL;
    }

    while ( i<uSearchLen ) {

        if ( (pwszToFind[j] == pwszMatch[i]) &&
            ((uSearchLen-i+1) >= uLenToFind ) ) {
            while ( j<uLenToFind ) {
                if ( pwszToFind[j] != pwszMatch[i] ) {
                    j=0;
                    break;
                }
                ++j;
                ++i;
            }

            if (j == uLenToFind) {
                //
                // Clear NULLs
                //
                while ( pwszMatch[i] == L'\0' )
                    ++i;
                return &pwszMatch[i];
            }

            continue;
        }
        ++i;
    }

    return NULL;
}

/***************************************************************************\
* LpkCheckForMirrorSignature
*
* Reetreives a pointer to the version resource section of the
* current executable. It checks if the 'FileDescription' field
* contains double LRM at the beginning to indicate a localized Mirrored
* App that requires mirroring. If signature is found, then
* SetProcessDefaultLayout is automatically called to apply mirroring for
* the current process.
*
* History:
* 2-Jan-1998 SamerA    Created.
\***************************************************************************/
BOOL LpkCheckForMirrorSignature( void )
{

    NTSTATUS                   status = STATUS_UNSUCCESSFUL;
    PVOID                      pImageBase,pResourceData;
    PIMAGE_RESOURCE_DATA_ENTRY pImageResource;
    ULONG                      uResourceSize;
    ULONG_PTR                   resIdPath[ 3 ];
    WCHAR                     *pwchDescritpion;
    WCHAR                      wchVersionVar[] = L"FileDescription";


    //
    // Get the current executable handle
    //
    pImageBase = NtCurrentPeb()->ImageBaseAddress;
    if ( NULL == pImageBase ) {
        return NT_SUCCESS(status);
    }

    //
    // Find the version resource. Search for neutral resource, this way
    // the MUI resource redirection code is activated, and the MUI
    // resource will be selected, if available.
    //
    resIdPath[0] = (ULONG_PTR) RT_VERSION ;
    resIdPath[1] = (ULONG_PTR) 1;
    resIdPath[2] = (ULONG_PTR) MAKELANGID( LANG_NEUTRAL , SUBLANG_NEUTRAL );
//    try {
    //
    // Bug #246044 WeiWu 12/07/00
    // Due to #173609 bug fix, resource loader no longer by default redirects 
    // version resource searching to MUI alternative modules
    // So, we have to use LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION to force version redirection
    //
    status = LdrFindResourceEx_U( 
                LDR_FIND_RESOURCE_LANGUAGE_REDIRECT_VERSION,
                pImageBase,
                resIdPath,
                3,
                &pImageResource
                );
//    }
//    except( EXCEPTION_EXECUTE_HANDLER )
//    {
//        status = GetExceptionCode();
//    }

    if ( NT_SUCCESS(status) ) {
        //
        // Load the resource into memory
        //
//        try {
            status = LdrAccessResource( pImageBase ,
                         pImageResource,
                         &pResourceData,
                         &uResourceSize
                         );
//        }
//        except( EXCEPTION_EXECUTE_HANDLER )
//        {
//            status = GetExceptionCode();
//        }

        if ( NT_SUCCESS(status) ) {

            //
            // Now we have the Version Info of the current
            // executable.
            //
            // Let's  read the FileDescription and check
            // if this image needs to be mirrored by
            // calling NtUserSetProcessDefaultLayout()
            //

            pwchDescritpion = FindStartOfString( wchVersionVar ,
                                  (sizeof(wchVersionVar)/sizeof(WCHAR)) ,
                                  (WCHAR*)pResourceData ,
                                  uResourceSize/sizeof(WCHAR));

            if ( pwchDescritpion &&
                (0x200e == pwchDescritpion[0]) &&
                (0x200e == pwchDescritpion[1]) ) {
                SetProcessDefaultLayout( LAYOUT_RTL );
            }

        }
    }


    //
    // return status of operation
    //

    return NT_SUCCESS(status);
}







/************************************************************
 LpkCleanup( void )

 Actual termination and cleanup procedure code for the LPK.DLL
 is done here.

 History :
   Oct 21, 1996 -by- Samer Arafeh [samera]
   Dec 31, 1996 -by- Samer Arafeh [samera] Cleanup width cache allocation
   Feb 13, 1996 -by- Dave Brown   [dbrown] Cache cleanup now in Gad
 ************************************************************/
BOOL WINAPI LpkCleanup( void )
{

  NLSCleanup();
  return TRUE ;
}







/*************************************************************
 *
 *   LPK Dll Initialization Routines
 *
 **************************************************************/

/**********************************************************************
 LpkDllInitialize( HANDLE hDll , DWORD dwReason , PVOID pvSituation )

 hDll         : Handle to Dll
 dwReason     : Process attach, thread attach, ...etc
 pvSituation  : Load-time or Run-time Dynalink

 This is the initialization procedure called when LPK.DLL gets loaded
 into a process address space

 History :
   Oct 21, 1996 -by- Samer Arafeh [samera]
 ***********************************************************************/
extern "C" BOOL LpkDllInitialize(HINSTANCE hDll, DWORD dwReason, PVOID pvSituation)
{
  BOOL bRet = TRUE ;
  UNREFERENCED_PARAMETER(pvSituation) ;
  switch( dwReason )
  {
    /* Process Attachment : when a process first maps the LPK.DLL to its address space,
       do the one time initialization. */
    case DLL_PROCESS_ATTACH:
      {
        // Disable calling our DLL when new threads are created within the process
        // context that we are mapped in. This is a useful optimization since
        // we are not handlling DLL_THREAD_ATTACH
        DisableThreadLibraryCalls( hDll ) ;
        LpkPresent();   // Tell Uniscribe that the LPK is present.
      }
    break ;

    case DLL_THREAD_ATTACH:
    break ;

    case DLL_THREAD_DETACH:
    break ;

    /* Process Detachment : Do last time clean up operation */
    case DLL_PROCESS_DETACH:
      {
        LpkCleanup() ;
      }
    break ;
  }

  return bRet ;
}



//////////////////////////////////////////////////////////////////////////////
//   GDI32 will call this function at loading time and should return TRUE   //
//////////////////////////////////////////////////////////////////////////////





BOOL LpkInitialize (DWORD dwLPKShapingDLLs) {

    HRESULT hr;

    hr = ScriptGetProperties(&g_ppScriptProperties, &g_iMaxScript);
    if (FAILED(hr)) {
        return FALSE;
    }

    hr = InitNLS();
    if (FAILED(hr)) {
        return FALSE;
    }

    LpkCheckForMirrorSignature();

    g_dwLoadedShapingDLLs = dwLPKShapingDLLs;
    // We don't call the GDI intialization for the font linking here because in the CSRSS
    // process the LPK intailization will be done before the Gre GDI intailization.
    g_iUseFontLinking = -1; 

    g_ACP = GetACP();

    // Prepare the FontID cache.
    g_cCachedFontsID       = 0;             // # of cahced font ID.
    g_pCurrentAvailablePos = 0;             // where can we cache next font ID.
    InitializeCriticalSection(&csFontIdCache);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_nls.cxx ===
/*++

  Copyright (c) 1997-1999,  Microsoft Corporation  All rights reserved.

  Module Name  :

    lpk_nls.c

  Abstract:

    This module picks up any changes to the NLS data which happen to the
    registry. A thread is dispatched from the LPK and waits for an event
    of a registry-change notification. This is a HELL-OF overhead, since it
    envolves a thread overhead/process as long as the LPK is attached
    to each process.

    Current NLS information being set :
      - Numeric Style (Native + Substitution). Currently for Beta-1 timeframe,
        we'll just set the registry entry at setup time, and if user wants to change it,
        he should go CURRENT_USER\Control Panel\International and change the value of
        sNativeDigits and iDigitSubstitution.

  Author:

    Samer Arafeh (SamerA) 27-Feb-1997    @ 5:04 pm

  Revision History:
    [samera] Apr 3rd, 1997, Dispatch NLS thread to wait on Control Panel\Internationl Reg Notification Change
    [DBrown] Dec 4th, 1997, Update for NT5 LPK and Uniscribe

--*/






#include "precomp.hxx"






/************************************************************
 BOOL ReadNLSScriptSettings


 Reads script related registry settings from
      HKEY_CURRENT_USER\Control Panel\International

 History :
   Samera    Created   Feb 18, 1997
 ************************************************************/

///// ReadNLSScriptSettings

BOOL ReadNLSScriptSettings(
    void) {

    #define       MAXWCBUF  80

    WCHAR         wcBuf[MAXWCBUF];   // Registry read buffer
    int           cBuf;
    SCRIPT_ITEM   item[2];
    int           cItems;
    HRESULT       hr;


    // User locale information

    g_UserLocale          = GetUserDefaultLCID();
    g_UserPrimaryLanguage = PRIMARYLANGID(LANGIDFROMLCID(g_UserLocale));

    cBuf = GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_FONTSIGNATURE, wcBuf, MAXWCBUF);
    g_UserBidiLocale      = (cBuf  &&  wcBuf[7] & 0x0800) ? TRUE : FALSE;


    // Establish users digit substitution settings

    hr = ScriptRecordDigitSubstitution(LOCALE_USER_DEFAULT, &g_DigitSubstitute);
    if (FAILED(hr)) {
        return FALSE;
    }


    return TRUE ;
}






/************************************************************
 BOOL InitNLS()

 Initializes all NLS related info in LPK Globals and fetches
 out the registry Control Panel\International for Numeric settings.

 History :
   Dbrown    Created
   Samera    Feb 18, 1997 Read NLS at init
 ************************************************************/

/////   InitNLS

BOOL InitNLS() {


    // Initialize Thread-NLS-Pickup

    g_hCPIntlInfoRegKey = NULL;
    g_hNLSWaitThread    = NULL;


    // Always update our NLS cache at initialization.
    g_ulNlsUpdateCacheCount = -1;

    return TRUE;
}



/************************************************************
 BOOL NLSCleanup( void )

 NLS Cleanup code

 History :
   Samera    Created   Apr 3, 1997
 ************************************************************/

/////   NLSCleanup

BOOL NLSCleanup(
    void) {

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_usp.cxx ===
////    LPK_USP - Interface to Uniscribe String APIs
//
//      Dave C Brown (dbrown) 13th December 1997.
//
//      Copyright (c) 1996-7, Microsoft Corporation. All rights reserved.






////    LPK_ANA provides the main analysis entrypoint for the script engine
//
//      ScriptStringAnalyse creates and returns a structure containing a
//      variety of information about the string, optionally including:
//
//          Glyphs and glyph attributes
//          Glyph positions
//          Cursor and word positions


#include "precomp.hxx"

#include "winnlsp.h"    // import NlsGetCacheUpdateCount()

extern "C" WINGDIAPI BOOL WINAPI AnyLinkedFonts();  // GDI exports this but doesn't provide a header



/////   LPK.H - Internal header
//
//
//. #include "usp10.h"
//. #include "usp10p.h"
//. #include "lpk_glob.h"


/////   LpkStringAnalyse
//
//      Build Uniscribe input flag structures


HRESULT LpkStringAnalyse(
    HDC               hdc,       //In  Device context (required)
    const void       *pString,   //In  String in 8 or 16 bit characters
    int               cString,   //In  Length in characters
    int               cGlyphs,   //In  Required glyph buffer size (default cString*3/2 + 1)
    int               iCharset,  //In  Charset if an ANSI string, -1 for a Unicode string
    DWORD             dwFlags,   //In  Analysis required
    int               iDigitSubstitute,
    int               iReqWidth, //In  Required width for fit and/or clip
    SCRIPT_CONTROL   *psControl, //In  Analysis control (optional)
    SCRIPT_STATE     *psState,   //In  Analysis initial state (optional)
    const int        *piDx,      //In  Requested logical dx array
    SCRIPT_TABDEF    *pTabdef,   //In  Tab positions (optional)
    BYTE             *pbInClass, //In  Legacy GetCharacterPlacement character classifications (deprecated)

    STRING_ANALYSIS **ppsa) {    //Out Analysis of string


    const SCRIPT_CONTROL emptySc = {0};
    const SCRIPT_STATE   emptySs = {0};

    HRESULT                 hr;
    SCRIPT_CONTROL          sc;
    SCRIPT_STATE            ss;
    ULONG                   ulCsrCacheCount;
    SCRIPT_DIGITSUBSTITUTE  sds;


    ASSERTS(cString!=0, "LpkStringAnalyse: input string must contain at least one character");

    TIMEENTRY(LSA, cString);

    if (psControl) {
        sc = *psControl;
    } else {
        sc = emptySc;
    }

    if (psState) {
        ss = *psState;
    } else {
        ss = emptySs;
    }


    // Check to see if we need to update our NLS cached data

    if ((ulCsrCacheCount=NlsGetCacheUpdateCount()) != g_ulNlsUpdateCacheCount) {

        TRACE(NLS, ("LPK : Updating NLS cache, lpkNlsCacheCount=%ld, CsrssCacheCount=%ld",
                     g_ulNlsUpdateCacheCount ,ulCsrCacheCount));

        g_ulNlsUpdateCacheCount = ulCsrCacheCount;

        // Update the cache now
        ReadNLSScriptSettings();
    }


    // Select required digit substitution

    if (iDigitSubstitute < 0) {

        // Use NLS digit subtitution as selected by user through control panel

        ScriptApplyDigitSubstitution(&g_DigitSubstitute, &sc, &ss);

    } else {

        // Override digit subtitution

        sds = g_DigitSubstitute;
        sds.DigitSubstitute = iDigitSubstitute;
        ScriptApplyDigitSubstitution(&sds, &sc, &ss);
    }


    // On Arabic systems, RTL fields start with the ENtoAN rule active.

    if (   (dwFlags & SSA_RTL)
        && (   g_ACP == 1256
            || g_UserPrimaryLanguage == LANG_ARABIC))
    {
        ss.fArabicNumContext = TRUE;
    }


    // When font linking is activated, it takes precedence over font fallback
    // for non-complex scripts.

    if (g_iUseFontLinking == -1) {
      g_iUseFontLinking = (int) AnyLinkedFonts();
    }

    if (g_iUseFontLinking) {
        dwFlags |= SSA_LINK;

    }


    sc.fLegacyBidiClass = TRUE;     // All legacy APIs use legacy plus, minus, solidus classifications


    //TRACEMSG(("LpkStringAnalyse: g_uLocaleLanguage %d, LANG_ARABIC %d, dwFlags & SSA_RTL %x, ss.fArabicNumContext %x",
    //          g_uLocaleLanguage, LANG_ARABIC, dwFlags & SSA_RTL, ss.fArabicNumContext));


    hr = ScriptStringAnalyse(
        hdc,
        pString,
        cString,
        cGlyphs,
        iCharset,
        dwFlags,
        iReqWidth,
        &sc,
        &ss,
        piDx,
        pTabdef,
        pbInClass,
        (SCRIPT_STRING_ANALYSIS*)ppsa);


    TIMEEXIT(LSA);
    return hr;
}







/////   ftsWordBreak - Support full text search wordbreaker
//
//
//      Mar 9,1997 - [wchao]
//


extern "C" BOOL WINAPI ftsWordBreak (
    PWSTR  pInStr,
    INT    cchInStr,
    PBYTE  pResult,
    INT    cchRes,
    INT    charset) {

    int      ich;
    int      ichRes;
    int      ichPrev;
    HRESULT  hr;
    STRING_ANALYSIS *psa;

    UNREFERENCED_PARAMETER(cchRes) ;

    // set up ED structure to prefer BasicAnalysis
    //

    hr = LpkStringAnalyse(
         NULL, pInStr, cchInStr, 0,
         charset,
         SSA_BREAK,
         -1, 0,
         NULL, NULL, NULL, NULL, NULL,
         &psa);

    if (SUCCEEDED(hr)) {

        for (ich=1, ichRes=0, ichPrev=0; ich < cchInStr; ich++) {
            if (psa->pLogAttr[ich].fSoftBreak) {
                pResult[ichRes] = ich - ichPrev;
                ichPrev = ich;
                ichRes++;
            }
        }
        pResult[ichRes] = 0;
        ScriptStringFree((void**)&psa);

    } else {

        ASSERTHR(hr, ("ftsWordBreak - LpkStringAnalyse"));

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\makefile.inc ===
###     Include developer makefile
#
#       The following file causes a perl script to build lpk.h
#       on developer machines enlisted in the Uniscribe SLM
#       tree (\\letterbox\slm) only. On the NT SLM tree, lpk.h
#       is always checked in and makefile.dev is a dummy.


!include makefile.dev
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\lpk_usrc.c ===
///     lpk_usrc.c - 'c' language interface to USER
//
//
//      Copyright(c) 1997 - 1999. Microsoft Corporation.
//
//


/*
 * Core NT headers
 */
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrdll.h>
#include <ntcsrsrv.h>
#define NONTOSPINTERLOCK
#include <ntosp.h>
/*
 * Standard C runtime headers
 */
#include <limits.h>
#include <memory.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>

/*
 * NtUser Client specific headers
 */
#include "usercli.h"

#include <ntsdexts.h>
#include <windowsx.h>
#include <newres.h>
#include <asdf.h>

/*
 * Complex script language pack
 */
#include "lpk.h"



#ifdef LPKBREAKAWORD
// Remove this after checking in the change in user.h (wchao :- 5-27-99)
#ifndef DT_BREAKAWORD
#define DT_BREAKAWORD   5
#endif
#endif



int WINAPI LpkDrawTextEx(
    HDC             hdc,
    int             xLeft,
    int             yTop,
    PCWSTR          pcwString,
    int             cchCount,
    BOOL            fDraw,
    DWORD           dwFormat,
    LPDRAWTEXTDATA  pDrawInfo,
    UINT            uAction,
    int             iCharSet) {

    switch (uAction) {

        case DT_GETNEXTWORD:
            return LpkGetNextWord(hdc, pcwString, cchCount, iCharSet);

#ifdef LPKBREAKAWORD
        case DT_BREAKAWORD:
            return LpkBreakAWord(hdc, pcwString, cchCount, pDrawInfo->cxMaxWidth);
#endif

        case DT_CHARSETDRAW:
        default: // Default equivalent to DT_CHARSETDRAW to duplicate NT4 behaviour
            return LpkCharsetDraw(
                hdc,
                xLeft,
                pDrawInfo->cxOverhang,
                pDrawInfo->rcFormat.left,   // Tab origin
                pDrawInfo->cxTabLength,
                yTop,
                pcwString,
                cchCount,
                fDraw,
                dwFormat,
                iCharSet);
    }
}






void LpkPSMTextOut(
    HDC           hdc,
    int           xLeft,
    int           yTop,
    const WCHAR  *pwcInChars,
    int           nCount,
    DWORD         dwFlags)
{
    LpkInternalPSMTextOut(hdc, xLeft, yTop, pwcInChars, nCount, dwFlags);

    UNREFERENCED_PARAMETER(dwFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\cslpk\lpk\sources.inc ===
MAJORCOMP=windows
MINORCOMP=LPK

TARGETNAME=lpk
TARGETTYPE=DYNLINK

!include sources.dev

DLLENTRY=LpkDllInitialize

TARGETPATH=$(_OBJ_DIR)
TARGETPATHLIB=$(_OBJ_DIR)


TARGETLIBS=$(SDK_LIB_PATH)\kernel32.lib \
           $(WINDOWS_LIB_PATH)\gdi32p.lib   \
           $(WINDOWS_LIB_PATH)\user32p.lib  \
           $(SDK_LIB_PATH)\kernl32p.lib \
           $(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\ntdll.lib    \
           $(SDK_LIB_PATH)\usp10.lib    \
           $(WINDOWS_LIB_PATH)\usp10p.lib


!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

#####
##    LPK-Profiling thru ICAP.DLL
!ifdef PROFILE_CSLPK
TARGETLIBS=$(TARGETLIBS) \
           $(SDK_LIB_PATH)\icap.lib
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /Gh
!endif

!if ! $(FREEBUILD)
# Disable optimizations to help debugging, but do generate intrinsic functions
MSC_OPTIMIZATION = /Od /Oi
!  endif


INCLUDES=..;                                        \
         ..\..\inc;                                 \
         $(NTUSER_PATH)\client;                     \
         $(NTUSER_PATH)\inc;                        \
         $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);    \
         $(WINCORE_PATH)\w32inc;                    \
         $(WINCORE_PATH)\w32inc\$(O);               \
         $(BASE_INC_PATH);                          \
         $(NTGDI_PATH)\inc;                         \
         $(WINDOWS_INC_PATH);


USE_NTDLL=1
NT_UP=0

C_DEFINES=$(C_DEFINES) $(USER_C_DEFINES) -D_USER32_ -DUNICODE -DUSE_MIRRORING -DLANGPACK

DLLDEF=..\lpk.def

SOURCES= ..\lpk.rc           \
         ..\lpk_usrc.c       \
         ..\lpk_edit.c       \
         ..\lpk_glob.c       \
         ..\lpk_init.cxx     \
         ..\lpk_gdi.cxx      \
         ..\lpk_user.cxx     \
         ..\lpk_nls.cxx      \
         ..\lpk_usp.cxx      \


LINKER_FLAGS = $(LINKER_FLAGS) -mapinfo:exports -verbose:lib
NTDBGFILES=1
USE_MAPSYM=1

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddagp.cxx ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "precomp.hxx"

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

#define PAGE_COUNT(Bytes) (((Bytes) + (PAGE_SIZE - 1)) / PAGE_SIZE)
#define PAGE_ROUND(Bytes) (((Bytes) + (PAGE_SIZE - 1)) & ~(PAGE_SIZE - 1))

//
// AGP memory policy parameters.
//

// Maximum amount of AGP memory to use.  Currently 32MB.
// Recomputed when the DirectDraw interface is created.
DWORD dwAGPPolicyMaxBytes = 32 * 1024 * 1024;

// Amount of memory to commit when a commit is needed.
// Reset when the DirectDraw interface is created.
DWORD dwAGPPolicyCommitDelta = DEFAULT_AGP_COMMIT_DELTA;


DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  PVOID *ppvReservation )
{
    DWORD dwNumPages;
    
    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != dwSize );
    DDASSERT( NULL                 != pfpLinStart );
    DDASSERT( NULL                 != pliDevStart );
    DDASSERT( NULL                 != ppvReservation );

    /*
     * The first thing to do is make sure our AGP policy is respected.
     * The easy way to do that is to limit how much we reserve...
     */
    dwSize = min(dwSize, dwAGPPolicyMaxBytes);

    /*
     * DDraw will attempt to reserve space for the heap, but if that fails,
     * we'll ratchet down the reservation by 4 megs at a time until it works.
     * This is a defensive move that should prevent a few problems for AGP
     * aware drivers on memphis: they cannot know how large an aperture to
     * claim (cuz of weird OS restraints like the fact that
     * half the ap is reserved for UC and the other half WC etc, plus
     * random BIOS limitations.
     * We arbitrarily decide that 4 megs is the legal minimum.
     */
    while (dwSize >= 0x400000 )
    {
        dwNumPages = PAGE_COUNT(dwSize);
        if ( OsAGPReserve( hdev, dwNumPages, fIsUC, fIsWC,
                           pfpLinStart, pliDevStart, ppvReservation ) )
        {
            return dwSize;
        }

        /*
         * If the driver asked for WC but the processor doesn't support WC,
         * then OsAGPReserve will have failed. The best thing to do is try
         * again with UC...
         * If the aperture size is the problem, then this will still fail
         * and we'll back off and try again WC.
         */
        if (fIsWC)
        {
            if ( OsAGPReserve( hdev, dwNumPages, TRUE, FALSE,
                               pfpLinStart, pliDevStart, ppvReservation ) )
            {
                return dwSize;
            }
        }

        /*
         * Subtract 4 megs and try again
         */
        dwSize -= 0x400000;
    }

    return 0;
} /* AGPReserve */

#define IS_CHUNK_COMMITTED(x,y)  \
            ((x)[(y)/BITS_IN_BYTE] & (1 << ((y) % BITS_IN_BYTE)))

#define MARK_CHUNK_COMMITTED(x,y)  \
            (x)[(y)/BITS_IN_BYTE] |= (1 << ((y) % BITS_IN_BYTE))

/*
 * Initially we implemented this where each page had a bit indicating whether it
 * was committed or not, but we decided to change it so that each bit indicates
 * whether 16 pages are mapped or not for the following reasons:
 *
 * 1. In AGPCommitVirtual, we walk the entire mask everytime we create a
 *    surface.  For performance reasons, we want to keep this mask small.
 * 
 * 2. The miniport always virtually commits everything in 16 page chunks and
 *    physically commits everything in 64 page chunks regardless of what we 
 *    pass to them, so there is no real reason for page granularity.
 */

// x = byte offset
#define CHUNK_INDEX(x)                                  \
    ((x) / (DDLOCAL_AGP_MAPPING_PAGES * PAGE_SIZE))

#define PAGE_FROM_CHUNK(x)                              \
    ((x) * DDLOCAL_AGP_MAPPING_PAGES)

#define NUM_CHUNKS(x)                                   \
    ((PAGE_COUNT(x) + (DDLOCAL_AGP_MAPPING_PAGES - 1)) / DDLOCAL_AGP_MAPPING_PAGES)

// x = start chunk
// y = chunk past the end (not included in the total)
// z = heap size in bytes
#define NUM_PAGES_FROM_CHUNK(x,y,z)                     \
    (((y) == NUM_CHUNKS(z)) ?                      \
        (PAGE_COUNT(z) - PAGE_FROM_CHUNK(x)) :          \
        (((y) - (x)) * DDLOCAL_AGP_MAPPING_PAGES))


BOOL AGPCommit( HANDLE hdev, PVOID pvReservation,
                DWORD dwOffset, DWORD dwSize,
                BYTE* pAgpCommitMask,
                DWORD* pdwCommittedSize,
                DWORD dwHeapSize)
{
    DWORD         dwChunk;
    DWORD         dwLastChunk;
    BOOL          bRet = TRUE;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( NULL                 != pvReservation );
    DDASSERT( 0UL                  != dwSize );

    *pdwCommittedSize = 0;

    if( pAgpCommitMask == NULL )
    {
        return FALSE;
    }

    dwChunk = CHUNK_INDEX(dwOffset);
    dwLastChunk = CHUNK_INDEX(dwOffset + dwSize - 1);

    ASSERTGDI((dwOffset + dwSize <= dwHeapSize), 
        "Attempting to allocate beyond the heap size");

    /*
     * Now walk through all of the 16 page chunks and determine if they are
     * already committed, and if not, commit them.
     */
    while( ( dwChunk <= dwLastChunk ) && bRet )
    {
        if( IS_CHUNK_COMMITTED( pAgpCommitMask,dwChunk ) )
        {
            // Chunk is already committed.
            dwChunk++;
        }
        else
        {
            DWORD   dwEndChunk;

            // The page is not already committed, so figure out how many 
            // non-committed pages we have and we will commit them all at once.
            dwEndChunk = dwChunk + 1;
            while( ( dwEndChunk <= dwLastChunk ) &&
                   !IS_CHUNK_COMMITTED( pAgpCommitMask, dwEndChunk ) )
            {
                dwEndChunk++;
            }

            bRet = OsAGPCommit( hdev, 
                pvReservation,
                PAGE_FROM_CHUNK(dwChunk), 
                NUM_PAGES_FROM_CHUNK(dwChunk, dwEndChunk, dwHeapSize));
            if( bRet )
            {
                // If we succeeded, we need to mark the pages as being committed
                
                *pdwCommittedSize += ((dwEndChunk - dwChunk) * 
                    DDLOCAL_AGP_MAPPING_PAGES * PAGE_SIZE);
                while( dwChunk < dwEndChunk )
                {
                    MARK_CHUNK_COMMITTED( pAgpCommitMask, dwChunk );
                    dwChunk++;
                }
            }
        }
    }

    return bRet;
} /* AGPCommit */


VOID AGPUpdateCommitMask( BYTE* pAgpCommitMask, DWORD dwOffset, DWORD dwSize, DWORD dwHeapSize )
{
    DWORD   dwChunk;
    DWORD   dwLastChunk;

    dwChunk = CHUNK_INDEX(dwOffset);
    dwLastChunk = CHUNK_INDEX(dwOffset + dwSize - 1);

    ASSERTGDI((dwOffset + dwSize <= dwHeapSize), 
        "Attempting to allocate beyond the heap size");

    /*
     * Now set all of the bits indicating that they are committed.
     */
    while( dwChunk <= dwLastChunk ) 
    {
        MARK_CHUNK_COMMITTED( pAgpCommitMask, dwChunk );
        dwChunk++;
    }
}


BOOL AGPDecommitAll( HANDLE hdev, PVOID pvReservation, 
                     BYTE* pAgpCommitMask, DWORD dwAgpCommitMaskSize,
                     DWORD* pdwDecommittedSize,
                     DWORD dwHeapSize)
{
    DWORD   dwNumChunks;
    DWORD   dwChunk;

    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );

    *pdwDecommittedSize = 0;
 
    /*
     * Walk the mask and decomit all of the previously committed chunks of
     * pages.  Do not decommit them one by one as this is fairly slow.
     */
    dwNumChunks = NUM_CHUNKS(dwHeapSize);
    dwChunk = 0;
    while( dwChunk < dwNumChunks )
    {
        if( !IS_CHUNK_COMMITTED( pAgpCommitMask, dwChunk ) )
        {
            // Page is not committed.
            dwChunk++;
        }
        else
        {
            DWORD   dwEndChunk;

            // We are at the start of a block of committed chunks, so figure
            // out how many chunks are in this block and decommit them all.
            dwEndChunk = dwChunk + 1;
            while( ( dwEndChunk < dwNumChunks ) &&
                   IS_CHUNK_COMMITTED( pAgpCommitMask, dwEndChunk ) )
            {
                dwEndChunk++;
            }

            OsAGPDecommit( hdev, pvReservation,
                PAGE_FROM_CHUNK(dwChunk), 
                NUM_PAGES_FROM_CHUNK(dwChunk, dwEndChunk, dwHeapSize));

            *pdwDecommittedSize += ((dwEndChunk - dwChunk) * 
                    DDLOCAL_AGP_MAPPING_PAGES * PAGE_SIZE);

            dwChunk = dwEndChunk;
        }
    }
    RtlZeroMemory( pAgpCommitMask, dwAgpCommitMaskSize );
    return TRUE;

} /* AGPDecommitAll */

BOOL AGPFree( HANDLE hdev, PVOID pvReservation )
{
    DDASSERT( INVALID_HANDLE_VALUE != hdev );
    DDASSERT( 0UL                  != pvReservation );

    return OsAGPFree( hdev, pvReservation );
} /* AGPFree */


DWORD AGPGetChunkCount( DWORD dwSize )
{
    return NUM_CHUNKS(dwSize);
}


BOOL AGPCommitAllVirtual( EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal, VIDEOMEMORY* lpVidMem, int iHeapIndex)
{
    DWORD                   i, j;
    DWORD                   dwNumChunks;
    BOOL                    bSuccess = TRUE;
    BYTE*                   pPhysicalCommitMask;
    BYTE*                   pVirtualCommitMask;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING*        peMap;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    dwNumChunks = NUM_CHUNKS(lpVidMem->lpHeap->dwTotalSize);
    pPhysicalCommitMask = lpVidMem->lpHeap->pAgpCommitMask;
    if (peDirectDrawLocal->ppeMapAgp != NULL)
    {
        peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
        if (peMap != NULL)
        {
            pVirtualCommitMask = peMap->pAgpVirtualCommitMask;

            for (i = 0; (i < dwNumChunks) && bSuccess; i++)
            {
                if (IS_CHUNK_COMMITTED(pPhysicalCommitMask, i) &&
                    !IS_CHUNK_COMMITTED(pVirtualCommitMask, i))
                {
                    // We have found a page that needs to be committed.
                    // Now find the last page in the block to commit.
                    for (j = i + 1; j < dwNumChunks; j++)
                    {
                        if (!IS_CHUNK_COMMITTED(pPhysicalCommitMask,j) ||
                            IS_CHUNK_COMMITTED(pVirtualCommitMask,j))
                        {
                            break;
                        }
                    }

                    if (peDirectDrawGlobal->AgpInterface.AgpServices.
                        AgpCommitVirtual(peDirectDrawGlobal->AgpInterface.Context,
                                 peMap->pvReservation, 
                                 NUM_PAGES_FROM_CHUNK(i, j, lpVidMem->lpHeap->dwTotalSize),
                                 PAGE_FROM_CHUNK(i)) == NULL)
                    {
                        bSuccess = FALSE;
                    }
                    else
                    {
                        // If we succeeded in committing the block, then mark the pages
                        // as committed.
                        while (i < j)
                        {
                            MARK_CHUNK_COMMITTED(pVirtualCommitMask,i);
                            i++;
                        }
                    }
                }
            }
        }
    }
    else
    {
        bSuccess = FALSE;
    }
    return bSuccess;
}


BOOL AGPCommitVirtual( EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal, 
                       VIDEOMEMORY* lpVidMem, 
                       int iHeapIndex, 
                       DWORD dwOffset,
                       DWORD dwSize )
{
    DWORD                   i, j;
    DWORD                   dwNumChunks;
    BYTE*                   pVirtualCommitMask;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING*        peMap;
    BOOL                    bSuccess = TRUE;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
    if (peDirectDrawLocal->ppeMapAgp != NULL)
    {
        peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
        if (peMap != NULL)
        {
            DWORD dwChunk = CHUNK_INDEX(dwOffset);
            DWORD dwLastChunk = CHUNK_INDEX(dwOffset + dwSize - 1);
            
            pVirtualCommitMask = peMap->pAgpVirtualCommitMask;
            if (peDirectDrawGlobal->AgpInterface.AgpServices.
                AgpCommitVirtual(peDirectDrawGlobal->AgpInterface.Context,
                             peMap->pvReservation, 
                             NUM_PAGES_FROM_CHUNK(dwChunk, dwLastChunk + 1, lpVidMem->lpHeap->dwTotalSize),
                             PAGE_FROM_CHUNK(dwChunk)) != NULL)
            {
                while( dwChunk <= dwLastChunk ) 
                {
                    MARK_CHUNK_COMMITTED( pVirtualCommitMask, dwChunk );
                    dwChunk++;
                }
            }
            else
            {
                bSuccess = FALSE;
            }
        }
    }
    return bSuccess;
}

BOOL AGPDecommitVirtual( EDD_VMEMMAPPING*        peMap,
                         EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
                         EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
                         DWORD                   dwHeapSize)
{
    DWORD   i, j;
    DWORD   dwNumChunks;
    BYTE*   pVirtualCommitMask;
    DWORD   dwCommitMaskSize;

    pVirtualCommitMask = peMap->pAgpVirtualCommitMask;
    dwCommitMaskSize = peMap->dwAgpVirtualCommitMaskSize;
    dwNumChunks = NUM_CHUNKS(dwHeapSize);

    for (i = 0; i < dwNumChunks; i++)
    {
        if (IS_CHUNK_COMMITTED(pVirtualCommitMask,i))
        {
            // We have found a chunk that needs to be decommitted.
            // Now find the last chunk in the block to commit.
            for (j = i + 1; j < dwNumChunks; j++)
            {
                if (!IS_CHUNK_COMMITTED(pVirtualCommitMask,j))
                {
                    break;
                }
            }

            peDirectDrawGlobal->AgpInterface.AgpServices.
                AgpFreeVirtual(peDirectDrawGlobal->AgpInterface.Context,
                           peMap->pvReservation,
                           NUM_PAGES_FROM_CHUNK(i, j, dwHeapSize),
                           PAGE_FROM_CHUNK(i));
            i = j;
        }
    }
    RtlZeroMemory( pVirtualCommitMask, dwCommitMaskSize );

    return TRUE;
}

NTSTATUS AGPMapToDummy( EDD_VMEMMAPPING*        peMap, 
                        EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
                        PVOID                   pDummyPage )
{
    BYTE*       pVirtualCommitMask;
    ULONG       ulOffs;
    VOID*       pvVirtAddr;
    NTSTATUS    Status = STATUS_SUCCESS;
    DWORD       dwNumChunks;
    DWORD       i;
    DWORD       j;

    pVirtualCommitMask = peMap->pAgpVirtualCommitMask;
    dwNumChunks = NUM_CHUNKS(peDirectDrawGlobal->pvmList[peMap->iHeapIndex].lpHeap->dwTotalSize);

    for (i = 0; i < dwNumChunks; i++)
    {
        // This takes a little bit of explaining.  Even though AGPCommitVirtual
        // passes in as many pages as it wants to get mapped at any given time,
        // videoport.sys always breaks these down and maps them in 16 page 
        // chunks.  Therefore, we need to re-amp them in 16 page chunks in order
        // for MmMapUserAddress to work correctly.
        
        if (IS_CHUNK_COMMITTED(pVirtualCommitMask,i))
        {
            pvVirtAddr = (VOID*)((PAGE_FROM_CHUNK(i) * PAGE_SIZE) + (ULONG_PTR) peMap->pvVirtAddr);
            Status = MmMapUserAddressesToPage(
                        pvVirtAddr, 0, gpDummyPage);
        }

        if (!NT_SUCCESS(Status))
        {
            break;
        }
    }

    return Status;
}


#ifndef __NTDDKCOMP__

#define OSR2_POINT_0_BUILD_NUMBER           1111
#define OSR2_BUILD_NUMBER_A                 1212
#define OSR2_BUILD_NUMBER_B                 1214

/*
 * Does this operating system understand AGP?
 *
 * NOTE: There may be a better way of determining this but for now I will
 * assumed that Memphis and NT 5.0 class operating systems are AGP aware.
 *
 * NOTE: The VXD handle is (obviously) only important on Win95. On NT
 * NULL should be passed.
 */
BOOL OSIsAGPAware( HANDLE hvxd )
{
    OSVERSIONINFO osvi;
    BOOL          success;
    BOOL          fIsVMMAGPAware;

    ZeroMemory(&osvi, sizeof(osvi));
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    success = GetVersionEx(&osvi);
    DDASSERT( success );

    if( VER_PLATFORM_WIN32_WINDOWS == osvi.dwPlatformId )
    {
	DPF( 8, "Major version = %d", osvi.dwMajorVersion );
	DPF( 8, "Minor version = %d", osvi.dwMinorVersion );
	DPF( 8, "Build number  = %d", LOWORD(osvi.dwBuildNumber) );

	if( ( osvi.dwMajorVersion > 4UL ) ||
	    ( ( osvi.dwMajorVersion == 4UL ) &&
	      ( osvi.dwMinorVersion >= 10UL ) &&
	      ( LOWORD( osvi.dwBuildNumber ) >= 1373 ) ) )
	{
	    /*
	     * Memphis or greater version of Win95. AGP support assumed.
	     */
	    DPF( 5, "AGP aware Windows95 detected. Enabling AGP" );
	    return TRUE;
	}
	else if( ( osvi.dwMajorVersion == 4UL ) &&
	         ( osvi.dwMinorVersion == 0UL ) &&
		 ( ( LOWORD( osvi.dwBuildNumber ) == OSR2_BUILD_NUMBER_A ) ||
  		   ( LOWORD( osvi.dwBuildNumber ) == OSR2_BUILD_NUMBER_B ) ||
  		   ( LOWORD( osvi.dwBuildNumber ) == OSR2_POINT_0_BUILD_NUMBER ) ) )
	{
	    DPF( 5, "Win95 OSR 2.1 detected. Checking VMM for AGP services" );

	    fIsVMMAGPAware = FALSE;
	    #ifdef    WIN95
		DDASSERT( INVALID_HANDLE_VALUE != hvxd );
		fIsVMMAGPAware = vxdIsVMMAGPAware( hvxd );
	    #else  /* WIN95 */
		/*
		 * Should never occur as this would mean we are running an NT
		 * binary on a 95 system.
		 */
		DDASSERT(FALSE);
	    #endif /* WIN95 */

	    if( fIsVMMAGPAware )
	    {
		/*
		 * AGP services are present in the VMM. Enable AGP.
		 */
		DPF( 5, "OSR 2.1 VMM has AGP services. Enabled AGP" );
		return TRUE;
	    }
	    else
	    {
		/*
		 * No AGP services. Disable AGP.
		 */
		DPF( 5, "OSR 2.1 VMM has no AGP services. AGP not available" );
		return FALSE;
	    }
	}
	else
	{
	    DPF( 5, "Win95 Gold, OSR 1.0 or OSR 2.0 detected. No AGP support available" );
	    return FALSE;
	}

    }
    else if( VER_PLATFORM_WIN32_NT == osvi.dwPlatformId )
    {
        /*
         * AGP support assumed in NT 5.0 and above.
         */
        if( osvi.dwMajorVersion >= 5UL )
        {
            DPF( 4, "AGP aware WindowsNT detected. Enabling AGP" );
            return TRUE;
        }
    }

    /*
     * If we got to here we failed the AGP aware test.
     */
    DPF( 5, "Operating system is not AGP aware. Disabling AGP" );
    return FALSE;
} /* OSIsAGPAware */

#endif // __NTDDKCOMP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxapi\dxapi.cxx ===
/******************************Module*Header*******************************\
* Module Name: dxapi.cxx
*
* Contains the public kernel-mode APIs for DirectX.
*
* All of the stuff that has to happen at raised IRQL happens here, because
* win32k is entirely pageable.
*
* Created: 11-Apr-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

#if DBG
    #define RIPDX(x) { KdPrint((x)); DbgBreakPoint();}
    #define ASSERTDX(x, y) if (!(x)) RIPDX(y)
#else
    #define RIPDX(x)
    #define ASSERTDX(x, y)
#endif

extern "C" {

VOID
APIENTRY
DxIrqCallBack(
    DX_IRQDATA* pIrqData
    );

NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );

VOID
APIENTRY
DxGetVersionNumber(
    DWORD               dwNotUsed,
    DDGETVERSIONNUMBER* pGetVersionNumber
    );

BOOL
bDxModifyPassiveEventList(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    BOOL                bAdd,
    DWORD               dwEvent,
    LPDD_NOTIFYCALLBACK pfnCallBack,
    PVOID               pContext
    );

DWORD
dwDxRegisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    BOOL                bRegister
    );

VOID
APIENTRY
DxRegisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    DWORD*              pdwRet
    );

VOID
APIENTRY
DxUnregisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    DWORD*              pdwRet
    );

VOID
APIENTRY
DxOpenDirectDraw(
    DDOPENDIRECTDRAWIN*     pOpenDirectDrawIn,
    DDOPENDIRECTDRAWOUT*    pOpenDirectDrawOut
    );

VOID
APIENTRY
DxApiInitialize(
    PFNDXAPIOPENDIRECTDRAW    pfnOpenDirectDraw,
    PFNDXAPIOPENVIDEOPORT     pfnOpenVideoPort,
    PFNDXAPIOPENSURFACE       pfnOpenSurface,
    PFNDXAPICLOSEHANDLE       pfnCloseHandle,
    PFNDXAPIGETKERNELCAPS     pfnGetKernelCaps,
    PFNDXAPIOPENCAPTUREDEVICE pfnOpenCaptureDevice,
    PFNDXAPILOCKDEVICE        pfnLockDevice,
    PFNDXAPIUNLOCKDEVICE      pfnUnlockDevice
    );

DWORD
APIENTRY
DxApi(
    DWORD   iFunction,
    VOID*   pInBuffer,
    DWORD   cInBuffer,
    VOID*   pOutBuffer,
    DWORD   cOutBuffer
    );

VOID
APIENTRY
DxAutoflipDpc(
    DWORD   dwEvent,
    PVOID   pContext,
    DWORD   dwParam1,
    DWORD   dwParam2
    );

VOID
APIENTRY
DxAutoflipUpdate(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXSURFACE**     apeDxSurfaceVideo,
    ULONG               cSurfacesVideo,
    EDD_DXSURFACE**     apeDxSurfaceVbi,
    ULONG               cSurfacesVbi
    );

VOID
APIENTRY
DxLoseObject(
    VOID*   pvObject,
    LOTYPE  loType
    );

VOID
APIENTRY
DxEnableIRQ(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    BOOL		bEnable
    );

VOID
APIENTRY
DxUpdateCapture(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXCAPTURE*      peDxCapture,
    BOOL                bRemove
    );

DWORD
APIENTRY
DxApiGetVersion(
    VOID
    );

}; // end "extern "C"


// Marke whatever we can as pageable:

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,DxGetVersionNumber)
#pragma alloc_text(PAGE,bDxModifyPassiveEventList)
#pragma alloc_text(PAGE,dwDxRegisterEvent)
#pragma alloc_text(PAGE,DxRegisterEvent)
#pragma alloc_text(PAGE,DxUnregisterEvent)
#pragma alloc_text(PAGE,DxOpenDirectDraw)
#pragma alloc_text(PAGE,DxApiInitialize)
#pragma alloc_text(PAGE,DxApiGetVersion)
#endif

PFNDXAPIOPENDIRECTDRAW  gpfnOpenDirectDraw;
PFNDXAPILOCKDEVICE      gpfnLockDevice;
PFNDXAPIUNLOCKDEVICE    gpfnUnlockDevice;

/***************************************************************************\
* NTSTATUS DriverEntry
*
* This routine is never actually called, but we need it to link.
*
\***************************************************************************/

extern "C"
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    return(STATUS_SUCCESS);
}

/******************************Public*Routine******************************\
* DWORD DxGetVersionNumber
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetVersionNumber(
    DWORD               dwNotUsed,
    DDGETVERSIONNUMBER* pGetVersionNumber
    )
{
    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DxGetVersionNumber: Call only at passive level (it's not pageable)");

    pGetVersionNumber->dwMajorVersion = DXAPI_MAJORVERSION;
    pGetVersionNumber->dwMinorVersion = DXAPI_MINORVERSION;
    pGetVersionNumber->ddRVal = DD_OK;
}

/******************************Public*Routine******************************\
* VOID DxGetFieldNumber
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetFieldNumber(
    DDGETFIELDNUMIN*    pGetFieldNumIn,
    DDGETFIELDNUMOUT*   pGetFieldNumOut
    )
{
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;

    pDxObjDirectDraw = (DXOBJ*) pGetFieldNumIn->hDirectDraw;
    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;

    pDxObjVideoPort  = (DXOBJ*) pGetFieldNumIn->hVideoPort;
    peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
        "Invalid VideoPort object");
    ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
        "VideoPort and DirectDraw objects don't match");

    if (peDxVideoPort->peDxDirectDraw->dwIRQCaps & DDIRQ_VPORT0_VSYNC )
    {
        pGetFieldNumOut->dwFieldNum = peDxVideoPort->dwCurrentField;
        pGetFieldNumOut->ddRVal = DD_OK;
    }
    else
    {
        KdPrint(("DxGetFieldNumber: Device doesn't support an interrupt\n"));
        pGetFieldNumOut->ddRVal = DDERR_UNSUPPORTED;
    }
}

/******************************Public*Routine******************************\
* VOID DxSetFieldNumber
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxSetFieldNumber(
    DDSETFIELDNUM*  pSetFieldNum,
    DWORD*          pdwRet
    )
{
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;

    pDxObjDirectDraw = (DXOBJ*) pSetFieldNum->hDirectDraw;
    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;

    pDxObjVideoPort  = (DXOBJ*) pSetFieldNum->hVideoPort;
    peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
        "Invalid VideoPort object");
    ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
        "VideoPort and DirectDraw objects don't match");

    if (peDxVideoPort->peDxDirectDraw->dwIRQCaps & DDIRQ_VPORT0_VSYNC )
    {
        peDxVideoPort->dwCurrentField = pSetFieldNum->dwFieldNum;
        *pdwRet = DD_OK;
    }
    else
    {
        KdPrint(("DxSetFieldNumber: Device doesn't support an interrupt\n"));
        *pdwRet = DDERR_UNSUPPORTED;
    }
}

/******************************Public*Routine******************************\
* VOID DxSetSkipPattern
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxSetSkipPattern(
    DDSETSKIPFIELD*   pSetSkipPattern,
    DWORD*            pdwRet
    )
{
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    KIRQL               OldIrql;
    DWORD               dwStartField;

    pDxObjDirectDraw = (DXOBJ*) pSetSkipPattern->hDirectDraw;
    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;

    pDxObjVideoPort  = (DXOBJ*) pSetSkipPattern->hVideoPort;
    peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
        "Invalid VideoPort object");
    ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
        "VideoPort and DirectDraw objects don't match");

    // Acquire the spinlock while we muck around

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    // We assume that we are called during the VSYNC callback notification
    // so all that we do is store the value and do the actual skipping
    // during the AutoflipDpc call.

    dwStartField = pSetSkipPattern->dwStartField;
    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIP_SET )
    {
        if( peDxVideoPort->dwFieldToSkip > dwStartField )
        {
            peDxVideoPort->dwNextFieldToSkip = peDxVideoPort->dwFieldToSkip;
            peDxVideoPort->dwFieldToSkip = dwStartField;
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET;
        }
        else if ( dwStartField != peDxVideoPort->dwFieldToSkip )
        {
            peDxVideoPort->dwFieldToSkip = dwStartField;
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET;
        }
    }
    else
    {
        peDxVideoPort->dwFieldToSkip = dwStartField;
        peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_SKIP_SET;
    }

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    *pdwRet = DX_OK;
}

/******************************Public*Routine******************************\
* VOID EffectStateChange
*
*  09-Jan-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID EffectStateChange( EDD_DXVIDEOPORT* peDxVideoPort,
        EDD_DXSURFACE* peDxSurface, DWORD dwNewState )
{
    EDD_DXDIRECTDRAW* peDxDirectDraw;
    DDSETSTATEININFO ddStateInInfo;
    DDSETSTATEOUTINFO ddStateOutInfo;
    DWORD dwOldFlags;
    DWORD dwOldVPFlags;
    DWORD ddRVal;
    DWORD i;
    DWORD dwRet;

    dwOldVPFlags = 0;
    if( peDxVideoPort != NULL )
    {
        peDxVideoPort->dwSetStateState = 0;
        peDxSurface = peDxVideoPort->apeDxSurfaceVideo[0];
        dwOldVPFlags = peDxVideoPort->dwVPFlags;
        if( dwNewState & DDSTATE_SKIPEVENFIELDS )
        {
            peDxVideoPort->dwVPFlags |= DDVP_SKIPEVENFIELDS;
        }
        else
        {
            peDxVideoPort->dwVPFlags &= ~DDVP_SKIPEVENFIELDS;
        }
    }

    if( peDxSurface != NULL )
    {
        dwOldFlags = peDxSurface->dwOverlayFlags;
        if( dwNewState & DDSTATE_BOB )
        {
            peDxSurface->dwOverlayFlags |= DDOVER_BOB;
        }
        else if( dwNewState & ( DDSTATE_WEAVE | DDSTATE_SKIPEVENFIELDS ) )
        {
            peDxSurface->dwOverlayFlags &= ~DDOVER_BOB;
        }

        peDxDirectDraw = peDxSurface->peDxDirectDraw;

        ddStateInInfo.lpSurfaceData = peDxSurface;
        ddStateInInfo.lpVideoPortData = peDxVideoPort;
        ddStateOutInfo.bSoftwareAutoflip = 0;

        dwRet = DDERR_UNSUPPORTED;
        if (peDxDirectDraw->DxApiInterface.DxSetState != NULL)
        {
            dwRet = peDxDirectDraw->DxApiInterface.DxSetState(
                                peDxDirectDraw->HwDeviceExtension,
                                &ddStateInInfo,
                                &ddStateOutInfo);
        }
        if( dwRet != DD_OK )
    	{
            peDxSurface->dwOverlayFlags = dwOldFlags;
            if( peDxVideoPort != NULL )
            {
                peDxVideoPort->dwVPFlags = dwOldVPFlags;
            }
    	}
        peDxSurface->flFlags |= DD_DXSURFACE_FLAG_STATE_SET;
        if( peDxVideoPort != NULL )
        {
            if( peDxSurface->dwOverlayFlags & DDOVER_BOB )
            {
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_BOB;
            }
            else
            {
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_BOB;
            }

            // Do they want to switch from hardware autoflipping to
            // software autoflipping?

            if( ( ddStateOutInfo.bSoftwareAutoflip ) &&
                ( peDxVideoPort->dwVPFlags & DDVP_AUTOFLIP ) &&
                !( peDxVideoPort->flFlags & (DD_DXVIDEOPORT_FLAG_AUTOFLIP|DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI)))
            {
                if( peDxVideoPort->cAutoflipVideo > 0 )
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP;
                }
                if( peDxVideoPort->cAutoflipVbi > 0 )
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI;
                }
                if( ddStateOutInfo.dwSurfaceIndex >= peDxVideoPort->cAutoflipVideo )
                {
                    peDxVideoPort->iCurrentVideo = 0;
                }
                else
                {
                    peDxVideoPort->iCurrentVideo = ddStateOutInfo.dwSurfaceIndex;
                }
                if( ddStateOutInfo.dwVBISurfaceIndex >= peDxVideoPort->cAutoflipVbi )
                {
                    peDxVideoPort->iCurrentVbi = 0;
                }
                else
                {
                    peDxVideoPort->iCurrentVbi = ddStateOutInfo.dwVBISurfaceIndex;
                }
            }

            for( i = 0; i < peDxVideoPort->iCurrentVideo; i++ )
    	    {
                peDxSurface = peDxVideoPort->apeDxSurfaceVideo[i];
                peDxSurface->flFlags &= ~(DD_DXSURFACE_FLAG_STATE_BOB|DD_DXSURFACE_FLAG_STATE_WEAVE);
                if( dwNewState & DDSTATE_BOB )
                {
                    peDxSurface->dwOverlayFlags |= DDOVER_BOB;
                    peDxSurface->flFlags |= DD_DXSURFACE_FLAG_STATE_BOB;
                }
                else if( dwNewState & ( DDSTATE_WEAVE | DDSTATE_SKIPEVENFIELDS ) )
                {
                    peDxSurface->dwOverlayFlags &= ~DDOVER_BOB;
                    if( dwNewState == DDSTATE_WEAVE )
                    {
                        peDxSurface->flFlags |= DD_DXSURFACE_FLAG_STATE_WEAVE;
                    }
                }
                peDxSurface->flFlags |= DD_DXSURFACE_FLAG_STATE_SET;
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxGetSurfaceState
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetSurfaceState(
    DDGETSURFACESTATEIN*    pGetSurfaceStateIn,
    DDGETSURFACESTATEOUT*   pGetSurfaceStateOut
    )
{
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObjSurface;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DXSURFACE*          peDxSurface;

    pDxObjDirectDraw = (DXOBJ*) pGetSurfaceStateIn->hDirectDraw;
    pDxObjSurface    = (DXOBJ*) pGetSurfaceStateIn->hSurface;

    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
    peDxSurface      = pDxObjSurface->peDxSurface;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjSurface->iDxType == DXT_SURFACE,
        "Invalid Surface object");
    ASSERTDX(peDxDirectDraw == peDxSurface->peDxDirectDraw,
        "Surface and DirectDraw objects don't match");
    ASSERTDX(peDxSurface->ddsCaps & DDSCAPS_OVERLAY,
        "Surface is not an overlay surface");

    // Fill in the available caps

    pGetSurfaceStateOut->dwStateCaps = 0;
    pGetSurfaceStateOut->dwStateStatus = 0;
    peDxVideoPort = peDxSurface->peDxVideoPort;

    // If the DDOVER_OVERRIDEBOBWEAVE flag was set, the status is equal
    // to the caps.

    if( peDxSurface->dwOverlayFlags & DDOVER_OVERRIDEBOBWEAVE )
    {
        if( peDxSurface->dwOverlayFlags & DDOVER_BOB )
        {
            pGetSurfaceStateOut->dwStateStatus |= DDSTATE_BOB;
            pGetSurfaceStateOut->dwStateCaps |= DDSTATE_BOB;
        }
        else if( ( peDxVideoPort != NULL ) &&
            ( peDxVideoPort->dwVPFlags & (DDVP_SKIPEVENFIELDS|DDVP_SKIPODDFIELDS) ) )
        {
            pGetSurfaceStateOut->dwStateStatus |= DDSTATE_SKIPEVENFIELDS;
            pGetSurfaceStateOut->dwStateCaps |= DDSTATE_SKIPEVENFIELDS;
        }
        else if( ( peDxVideoPort != NULL ) &&
            ( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE ) )
        {
            pGetSurfaceStateOut->dwStateStatus |= DDSTATE_WEAVE;
            pGetSurfaceStateOut->dwStateCaps |= DDSTATE_WEAVE;
        }
        else if( ( peDxVideoPort == NULL ) &&
            ( peDxSurface->dwOverlayFlags & DDOVER_INTERLEAVED ) )
        {
            pGetSurfaceStateOut->dwStateStatus |= DDSTATE_WEAVE;
            pGetSurfaceStateOut->dwStateCaps |= DDSTATE_WEAVE;
        }
    }
    else
    {
        // The status is different from the caps

        if( ( peDxVideoPort != NULL ) &&
            ( peDxVideoPort->dwVPFlags & (DDVP_SKIPEVENFIELDS|DDVP_SKIPODDFIELDS) ) )
        {
            pGetSurfaceStateOut->dwStateStatus |= DDSTATE_SKIPEVENFIELDS;
        }
        else if( peDxSurface->dwOverlayFlags & DDOVER_BOB )
        {
            pGetSurfaceStateOut->dwStateStatus |= DDSTATE_BOB;
        }

        if( ( ( peDxVideoPort != NULL ) &&
            ( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE ) ) ||
            ( ( peDxVideoPort == NULL ) &&
            ( peDxSurface->dwOverlayFlags & DDOVER_INTERLEAVED ) ) )
        {
            pGetSurfaceStateOut->dwStateCaps |= DDSTATE_WEAVE;
            if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_CAN_BOB_INTERLEAVED )
            {
                pGetSurfaceStateOut->dwStateCaps |= DDSTATE_BOB;
            }
            if( pGetSurfaceStateOut->dwStateStatus == 0 )
            {
                pGetSurfaceStateOut->dwStateStatus |= DDSTATE_WEAVE;
            }
        }
        else if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_CAN_BOB_NONINTERLEAVED )
        {
            pGetSurfaceStateOut->dwStateCaps |= DDSTATE_BOB;
        }
        if( peDxVideoPort != NULL )
        {
            pGetSurfaceStateOut->dwStateCaps |= DDSTATE_SKIPEVENFIELDS;
        }
    }

    // Notify the client that the state was explicity set by a
    // kernel mode client.

    if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_STATE_SET )
    {
        pGetSurfaceStateOut->dwStateStatus |= DDSTATE_EXPLICITLY_SET;
    }

    // Tell if software autoflipping vs. hardware autofliping.  This
    // is mostly for DDraw's benefit.

    if( ( peDxVideoPort != NULL ) && ( peDxVideoPort->bSoftwareAutoflip ) )
    {
        pGetSurfaceStateOut->dwStateStatus |= DDSTATE_SOFTWARE_AUTOFLIP;
    }

    pGetSurfaceStateOut->ddRVal = DD_OK;
}

/******************************Public*Routine******************************\
* VOID DxSetSurfaceState
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxSetSurfaceState(
    DDSETSURFACESTATE*  pSetSurfaceState,
    DWORD*              pdwRet
    )
{
    DWORD                   dwState;
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObjSurface;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DXSURFACE*          peDxSurface;
    DDGETSURFACESTATEIN     GetSurfaceStateIn;
    DDGETSURFACESTATEOUT    GetSurfaceStateOut;
    DDSETSTATEININFO        SetStateInInfo;
    DDSETSTATEOUTINFO       SetStateOutInfo;
    DWORD                   iCurrentVideo;
    KIRQL                   OldIrql;
    DWORD                   dwRet;
    DWORD                   dwVPFlags;

    dwRet = DDERR_INVALIDPARAMS;

    pDxObjDirectDraw = (DXOBJ*) pSetSurfaceState->hDirectDraw;
    pDxObjSurface    = (DXOBJ*) pSetSurfaceState->hSurface;

    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
    peDxSurface      = pDxObjSurface->peDxSurface;

    GetSurfaceStateIn.hDirectDraw = pSetSurfaceState->hDirectDraw;
    GetSurfaceStateIn.hSurface    = pSetSurfaceState->hSurface;

    DxGetSurfaceState(&GetSurfaceStateIn, &GetSurfaceStateOut);

    ASSERTDX(GetSurfaceStateOut.ddRVal == DD_OK,
        "DxSetSurfaceState: Didn't expect failure from DxGetSurfaceState");

    dwState = pSetSurfaceState->dwState;

    // Get the video port if one is associated with the surface

    if( peDxSurface->peDxVideoPort == NULL )
    {
        peDxVideoPort = NULL;
        dwVPFlags = 0;
    }
    else
    {
        peDxVideoPort = peDxSurface->peDxVideoPort;
        dwVPFlags = peDxVideoPort->dwVPFlags;
    }

    if ((dwState != DDSTATE_BOB) &&
        (dwState != DDSTATE_WEAVE) &&
        (dwState != DDSTATE_SKIPEVENFIELDS))
    {
        RIPDX("DxSetSurfaceState: Invalid dwState flags");
    }
    else if ((dwState & GetSurfaceStateOut.dwStateCaps) != dwState)
    {
        RIPDX("DxSetSurfaceState: State not supported");
    }
    else if ((dwState == DDSTATE_SKIPEVENFIELDS) && (peDxVideoPort == NULL ))
    {
        RIPDX("DxSetSurfaceState: Surface not attached to video port");
    }
    else if (((dwState & DDSTATE_BOB) &&
              (peDxSurface->dwOverlayFlags & DDOVER_BOB)) ||
             ((dwState & DDSTATE_WEAVE) &&
              !(peDxSurface->dwOverlayFlags & DDOVER_BOB) &&
              !(dwVPFlags & (DDVP_SKIPEVENFIELDS|DDVP_SKIPODDFIELDS))) ||
             ((dwState & DDSTATE_SKIPEVENFIELDS ) &&
               (dwVPFlags & (DDVP_SKIPEVENFIELDS|DDVP_SKIPODDFIELDS))))
    {
        // Don't do nothin, it's already in the requested state.

        dwRet = DD_OK;
    }
    else if (peDxDirectDraw->DxApiInterface.DxSetState != NULL)
    {
        // Acquire the spinlock while we muck around in the 'dwSetStateState'
        // and 'dwSetStateField' members, which are accessed by the videoport
        // DPC.

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        if ((peDxDirectDraw->bLost) ||
            ((peDxVideoPort != NULL) && (peDxVideoPort->bLost)) ||
            (peDxSurface->bLost))
        {
            KdPrint(("DxSetSurfaceState: Objects are lost\n"));
            dwRet = DDERR_SURFACELOST;
        }

        // If they want it to happen for the next field or we are not
        // using a video port, call the mini port now; otherwise, we'll let
        // the IRQ logoic handle this later.

        else if ((pSetSurfaceState->dwStartField == 0) ||
            (peDxVideoPort == NULL) ||
            !(peDxVideoPort->bSoftwareAutoflip))
        {
            EffectStateChange( peDxVideoPort, peDxSurface, dwState );
        }
        else
        {
            peDxVideoPort->dwSetStateState = dwState;
            peDxVideoPort->dwSetStateField = pSetSurfaceState->dwStartField;
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_NEW_STATE;
        }

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

        dwRet = DD_OK;
    }

    if (peDxDirectDraw->DxApiInterface.DxSetState == NULL)
    {
        dwRet = DDERR_UNSUPPORTED;
    }

    *pdwRet = dwRet;
}

/******************************Public*Routine******************************\
* VOID DxLock
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxLock(
    DDLOCKIN*   pLockIn,
    DDLOCKOUT*  pLockOut
    )
{
    DWORD               dwRet;
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjSurface;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXSURFACE*      peDxSurface;
    DDLOCKININFO        LockInInfo;
    DDLOCKOUTINFO       LockOutInfo;
    KIRQL               OldIrql;

    dwRet = DD_OK;

    pDxObjDirectDraw = (DXOBJ*) pLockIn->hDirectDraw;
    pDxObjSurface    = (DXOBJ*) pLockIn->hSurface;

    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
    peDxSurface      = pDxObjSurface->peDxSurface;

    ASSERTDX(peDxDirectDraw == peDxSurface->peDxDirectDraw,
        "Surface and DirectDraw objects don't match");
    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjSurface->iDxType == DXT_SURFACE,
        "Invalid surface object");

    LockInInfo.lpSurfaceData = peDxSurface;
    LockOutInfo.dwSurfacePtr  = peDxSurface->fpLockPtr;

    // The display driver can set 'fpLockPtr' to NULL in its SyncSurfaceData
    // routine if it doesn't want to support a DXAPI lock.

    if (peDxSurface->fpLockPtr == NULL)
    {
        KdPrint(("DxLock: Video miniport doesn't support lock on this surface\n"));
        dwRet = DDERR_UNSUPPORTED;
    }
    else
    {
        // NOTE: The miniport should not wait for accelerator complete!

        if (peDxDirectDraw->DxApiInterface.DxLock)
        {
            KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

            if ((peDxDirectDraw->bLost) || (peDxSurface->bLost))
            {
                KdPrint(("DxLock: Objects are lost\n"));
                dwRet = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxLock(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &LockInInfo,
                                    &LockOutInfo);
            }

            KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

            if (dwRet != DD_OK)
            {
                KdPrint(("DxLock: Driver failed call\n"));

                // Pass the return code on down...
            }
        }

        pLockOut->lpSurface        = (LPVOID) LockOutInfo.dwSurfacePtr;

        pLockOut->dwSurfHeight     = peDxSurface->dwHeight;
        pLockOut->dwSurfWidth      = peDxSurface->dwWidth;
        pLockOut->lSurfPitch       = peDxSurface->lPitch;
        pLockOut->SurfaceCaps      = peDxSurface->ddsCaps;
        pLockOut->dwFormatFlags    = peDxSurface->dwFormatFlags;
        pLockOut->dwFormatFourCC   = peDxSurface->dwFormatFourCC;
        pLockOut->dwFormatBitCount = peDxSurface->dwFormatBitCount;
        pLockOut->dwRBitMask       = peDxSurface->dwRBitMask;
        pLockOut->dwGBitMask       = peDxSurface->dwGBitMask;
        pLockOut->dwBBitMask       = peDxSurface->dwBBitMask;
    }

    pLockOut->ddRVal = dwRet;
}

/******************************Public*Routine******************************\
* VOID DxFlipOverlay
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxFlipOverlay(
    DDFLIPOVERLAY*  pFlipOverlay,
    DWORD*          pdwRet
    )
{
    DWORD               dwRet;
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjTarget;
    DXOBJ*              pDxObjCurrent;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXSURFACE*      peDxTarget;
    EDD_DXSURFACE*      peDxCurrent;
    DDFLIPOVERLAYINFO   FlipOverlayInfo;
    KIRQL               OldIrql;

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pFlipOverlay->hDirectDraw;
    pDxObjTarget     = (DXOBJ*) pFlipOverlay->hTargetSurface;
    pDxObjCurrent    = (DXOBJ*) pFlipOverlay->hCurrentSurface;

    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
    peDxTarget       = pDxObjTarget->peDxSurface;
    peDxCurrent      = pDxObjCurrent->peDxSurface;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjTarget->iDxType == DXT_SURFACE,
        "Invalid target object");
    ASSERTDX(pDxObjCurrent->iDxType == DXT_SURFACE,
        "Invalid current object");
    ASSERTDX((peDxDirectDraw == peDxTarget->peDxDirectDraw) &&
             (peDxDirectDraw == peDxCurrent->peDxDirectDraw),
        "Surface and DirectDraw objects don't match");
    ASSERTDX((peDxCurrent->dwWidth == peDxTarget->dwWidth) &&
              (peDxCurrent->dwHeight == peDxTarget->dwHeight),
        "Surfaces are different sizes");

    if (!(peDxCurrent->ddsCaps & DDSCAPS_OVERLAY) ||
        (peDxCurrent->dwOverlayFlags & DDOVER_AUTOFLIP))
    {
        RIPDX("Invalid current overlay status");
    }
    else if (!(peDxTarget->ddsCaps & DDSCAPS_OVERLAY) ||
             (peDxTarget->dwOverlayFlags & DDOVER_AUTOFLIP))
    {
        RIPDX("Invalid target overlay status");
    }
    else
    {
        FlipOverlayInfo.lpCurrentSurface = peDxCurrent;
        FlipOverlayInfo.lpTargetSurface  = peDxTarget;
        FlipOverlayInfo.dwFlags          = pFlipOverlay->dwFlags;

        if (peDxDirectDraw->DxApiInterface.DxFlipOverlay)
        {
            KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

            if ((peDxDirectDraw->bLost) ||
                (peDxTarget->bLost)     ||
                (peDxCurrent->bLost))
            {
                KdPrint(("DxFlipOverlay: Objects are lost\n"));
                dwRet = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxFlipOverlay(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &FlipOverlayInfo,
                                    NULL);
            }

            KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        }

        if (dwRet != DD_OK)
        {
            KdPrint(("DxFlipOverlay: Driver failed call\n"));
        }
    }

    *pdwRet = dwRet;
}

/******************************Public*Routine******************************\
* VOID DxFlipVideoPort
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxFlipVideoPort(
    DDFLIPVIDEOPORT*    pFlipVideoPort,
    DWORD*              pdwRet
    )
{
    DWORD               dwRet;
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    DXOBJ*              pDxObjTarget;
    DXOBJ*              pDxObjCurrent;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    EDD_DXSURFACE*      peDxTarget;
    EDD_DXSURFACE*      peDxCurrent;
    DDFLIPVIDEOPORTINFO FlipVideoPortInfo;
    KIRQL               OldIrql;

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pFlipVideoPort->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pFlipVideoPort->hVideoPort;
    pDxObjTarget     = (DXOBJ*) pFlipVideoPort->hTargetSurface;
    pDxObjCurrent    = (DXOBJ*) pFlipVideoPort->hCurrentSurface;

    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
    peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;
    peDxTarget       = pDxObjTarget->peDxSurface;
    peDxCurrent      = pDxObjCurrent->peDxSurface;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
        "Invalid VideoPort object");
    ASSERTDX(pDxObjTarget->iDxType == DXT_SURFACE,
        "Invalid target object");
    ASSERTDX(pDxObjCurrent->iDxType == DXT_SURFACE,
        "Invalid current object");
    ASSERTDX((peDxDirectDraw == peDxTarget->peDxDirectDraw) &&
             (peDxDirectDraw == peDxCurrent->peDxDirectDraw) &&
             (peDxDirectDraw == peDxVideoPort->peDxDirectDraw),
        "Surface, VideoPort, and DirectDraw objects don't match");
    ASSERTDX((peDxCurrent->dwWidth == peDxTarget->dwWidth) &&
              (peDxCurrent->dwHeight == peDxTarget->dwHeight),
        "Surfaces are different sizes");
    ASSERTDX((pFlipVideoPort->dwFlags == DDVPFLIP_VIDEO) ||
              (pFlipVideoPort->dwFlags == DDVPFLIP_VBI),
        "Invalid flags");
    ASSERTDX(!(peDxVideoPort->dwVPFlags & DDVP_AUTOFLIP),
        "Flip not available while autoflipping");

    FlipVideoPortInfo.lpVideoPortData  = peDxVideoPort;
    FlipVideoPortInfo.lpCurrentSurface = peDxCurrent;
    FlipVideoPortInfo.lpTargetSurface  = peDxTarget;
    FlipVideoPortInfo.dwFlipVPFlags    = pFlipVideoPort->dwFlags;

    if (peDxDirectDraw->DxApiInterface.DxFlipVideoPort)
    {
        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        if ((peDxDirectDraw->bLost) ||
            (peDxVideoPort->bLost)  ||
            (peDxTarget->bLost)     ||
            (peDxCurrent->bLost))
        {
            KdPrint(("DxFlipVideoPort: Objects are lost\n"));
            dwRet = DDERR_SURFACELOST;
        }
        else
        {
            dwRet = peDxDirectDraw->DxApiInterface.DxFlipVideoPort(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &FlipVideoPortInfo,
                                    NULL);
        }
        peDxCurrent->peDxVideoPort = NULL;
        peDxTarget->peDxVideoPort = peDxVideoPort;

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
    }

    if (dwRet != DD_OK)
    {
        KdPrint(("DxFlipVideoPort: Driver failed call\n"));
    }

    *pdwRet = dwRet;
}

/******************************Public*Routine******************************\
* VOID DxGetCurrentAutoflip
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetCurrentAutoflip(
    DDGETAUTOFLIPIN*  pGetCurrentAutoflipIn,
    DDGETAUTOFLIPOUT* pGetCurrentAutoflipOut
    )
{
    DWORD                       dwRet;
    DXOBJ*                      pDxObjDirectDraw;
    DXOBJ*                      pDxObjVideoPort;
    DXOBJ*                      pDxObjTarget;
    DXOBJ*                      pDxObjCurrent;
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    EDD_DXVIDEOPORT*            peDxVideoPort;
    EDD_DXSURFACE*              peDxTarget;
    EDD_DXSURFACE*              peDxCurrent;
    DDGETPOLARITYININFO         GetPolarityInInfo;
    DDGETPOLARITYOUTINFO        GetPolarityOutInfo;
    DDGETCURRENTAUTOFLIPININFO  GetCurrentAutoflipInInfo;
    DDGETCURRENTAUTOFLIPOUTINFO GetCurrentAutoflipOutInfo;
    KIRQL                       OldIrql;
    DWORD                       dwVideo;
    DWORD                       dwVBI;
    BOOL                        bFlipping;

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pGetCurrentAutoflipIn->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pGetCurrentAutoflipIn->hVideoPort;

    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
    peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
        "Invalid VideoPort object");
    ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
        "Surface, VideoPort, and DirectDraw objects don't match");
    ASSERTDX(peDxVideoPort->dwVPFlags & DDVP_AUTOFLIP,
        "Not currently autoflipping");

    GetPolarityInInfo.lpVideoPortData = peDxVideoPort;

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    if ((peDxDirectDraw->bLost) ||
        (peDxVideoPort->bLost))
    {
        KdPrint(("DxGetCurrentAutoflip: Objects are lost\n"));
        dwRet = DDERR_SURFACELOST;
    }
    else
    {
        dwRet = DDERR_UNSUPPORTED;
        if (peDxDirectDraw->DxApiInterface.DxGetPolarity)
        {
            dwRet = peDxDirectDraw->DxApiInterface.DxGetPolarity(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &GetPolarityInInfo,
                                    &GetPolarityOutInfo);
        }

        if (dwRet != DD_OK)
        {
            KdPrint(("DxGetCurrentAutoflip: Driver failed GetPolarity\n"));
        }
        else
        {
            // Determine which field is currently receiving the data.  If they
            // are software autoflipping, I can do that myself; otherwise, I
            // have to call the HAL
            //
            // When software autoflipping, there is an issue that if this
            // function is called between the time that the IRQ occured
            // and the time that the DPC ran, this function would return
            // the wrong surface. Since fixing this requires that we do all
            // of the work at IRQ time (bad), we can probably assume that
            // this will always be the case since anybody using this
            // function would be calling it during the IRQ callback.  We
            // will therefore work around it.

            dwVideo = (DWORD) -1;
            dwVBI = (DWORD) -1;

            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP )
            {
                dwVideo = peDxVideoPort->iCurrentVideo;
                bFlipping = TRUE;
                if( ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIP_SET ) &&
                    ( peDxVideoPort->dwFieldToSkip == 1 ) )
                {
                    bFlipping = FALSE;
                }
                else if( !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIPPED_LAST ) &&
                          ( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE ) &&
                         !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT ) )
                {
                    bFlipping = FALSE;
                }
                if( bFlipping )
                {
                    if( ++dwVideo >= peDxVideoPort->cAutoflipVideo )
                    {
                        dwVideo = 0;
                    }
                }
            }

            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI )
            {
                dwVBI = peDxVideoPort->iCurrentVbi;
                if(  ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_VBI_INTERLEAVED ) &&
                    !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI ) )
                {
                    if( ++dwVBI >= peDxVideoPort->cAutoflipVbi )
                    {
                        dwVBI = 0;
                    }
                }
            }

            if( ( dwVideo == (DWORD) -1 ) && ( dwVBI == (DWORD) -1 ) )
            {
                GetCurrentAutoflipInInfo.lpVideoPortData = peDxVideoPort;
                GetCurrentAutoflipOutInfo.dwSurfaceIndex = 0;
                GetCurrentAutoflipOutInfo.dwVBISurfaceIndex = 0;
                if (peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip)
                {
                    dwRet = peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip(
                                peDxDirectDraw->HwDeviceExtension,
                                &GetCurrentAutoflipInInfo,
                                &GetCurrentAutoflipOutInfo);
                }
                dwVideo = GetCurrentAutoflipOutInfo.dwSurfaceIndex;
                dwVBI = GetCurrentAutoflipOutInfo.dwVBISurfaceIndex;
            }

            pGetCurrentAutoflipOut->hVideoSurface = NULL;
            pGetCurrentAutoflipOut->hVBISurface = NULL;
            if( ( peDxVideoPort->cAutoflipVideo > 0 ) && ( dwVideo != (DWORD) -1 ) )
            {
                pGetCurrentAutoflipOut->hVideoSurface =
                    peDxVideoPort->apeDxSurfaceVideo[dwVideo];
            }
            if( ( peDxVideoPort->cAutoflipVbi > 0 ) && ( dwVBI != (DWORD) -1 ) )
            {
                pGetCurrentAutoflipOut->hVBISurface =
                    peDxVideoPort->apeDxSurfaceVbi[dwVBI];
            }
            pGetCurrentAutoflipOut->bPolarity = GetPolarityOutInfo.bPolarity;
        }
    }

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    pGetCurrentAutoflipOut->ddRVal    = dwRet;
}

/******************************Public*Routine******************************\
* VOID DxGetPreviousAutoflip
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetPreviousAutoflip(
    DDGETAUTOFLIPIN*  pGetPreviousAutoflipIn,
    DDGETAUTOFLIPOUT* pGetPreviousAutoflipOut
    )
{
    DWORD                       dwRet;
    DXOBJ*                      pDxObjDirectDraw;
    DXOBJ*                      pDxObjVideoPort;
    DXOBJ*                      pDxObjTarget;
    DXOBJ*                      pDxObjCurrent;
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    EDD_DXVIDEOPORT*            peDxVideoPort;
    EDD_DXSURFACE*              peDxTarget;
    EDD_DXSURFACE*              peDxPrevious;
    DDGETPOLARITYININFO         GetPolarityInInfo;
    DDGETPOLARITYOUTINFO        GetPolarityOutInfo;
    DDGETPREVIOUSAUTOFLIPININFO GetPreviousAutoflipInInfo;
    DDGETPREVIOUSAUTOFLIPOUTINFO GetPreviousAutoflipOutInfo;
    KIRQL                       OldIrql;
    DWORD                       dwVideo;
    DWORD                       dwVBI;

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pGetPreviousAutoflipIn->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pGetPreviousAutoflipIn->hVideoPort;

    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
    peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
        "Invalid VideoPort object");
    ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
        "Surface, VideoPort, and DirectDraw objects don't match");
    ASSERTDX(peDxVideoPort->dwVPFlags & DDVP_AUTOFLIP,
        "Not currently autoflipping");

    GetPolarityInInfo.lpVideoPortData = peDxVideoPort;

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    if ((peDxDirectDraw->bLost) ||
        (peDxVideoPort->bLost))
    {
        KdPrint(("DxGetPreviousAutoflip: Objects are lost\n"));
        dwRet = DDERR_SURFACELOST;
    }
    else
    {
        dwRet = DDERR_UNSUPPORTED;
        if (peDxDirectDraw->DxApiInterface.DxGetPolarity)
        {
            dwRet = peDxDirectDraw->DxApiInterface.DxGetPolarity(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &GetPolarityInInfo,
                                    &GetPolarityOutInfo);
        }

        if (dwRet != DD_OK)
        {
            KdPrint(("DxGetPreviousAutoflip: Driver failed GetPolarity\n"));
        }
        else
        {
            // Determine which field is currently receiving the data.  If they
            // are software autoflipping, I can do that myself; otherwise, I
            // have to call the HAL
            //
            // This is complicated by the facts that:
            // 1) Skipping may be enabled.
            //  3) When interleaving, they flip every other field, but its not
            //     guarenteed that the flip always occurs between the even and the
            //     odd fields.
            //
            // When software autoflipping, there is an issue that if this
            // function is called between the time that the IRQ occured
            // and the time that the DPC ran, this function would return
            // the wrong surface. Since fixing this requires that we do all
            // of the work at IRQ time (bad), we can probably assume that
            // this will always be the case since anybody using this
            // function would be calling it during the IRQ callback.  We
            // will therefore work around it.

            dwVideo = (DWORD) -1;
            dwVBI = (DWORD) -1;
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP )
            {
                dwVideo = peDxVideoPort->iCurrentVideo;
            }
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI )
            {
                dwVBI = peDxVideoPort->iCurrentVbi;
            }
            if( ( dwVideo == (DWORD) -1 ) && ( dwVBI == (DWORD) -1 ) )
            {
                GetPreviousAutoflipInInfo.lpVideoPortData = peDxVideoPort;
                GetPreviousAutoflipOutInfo.dwSurfaceIndex = 0;
                GetPreviousAutoflipOutInfo.dwVBISurfaceIndex = 0;
                if (peDxDirectDraw->DxApiInterface.DxGetPreviousAutoflip)
                {
                    dwRet = peDxDirectDraw->DxApiInterface.DxGetPreviousAutoflip(
                                peDxDirectDraw->HwDeviceExtension,
                                &GetPreviousAutoflipInInfo,
                                &GetPreviousAutoflipOutInfo);
                }
                dwVideo = GetPreviousAutoflipOutInfo.dwSurfaceIndex;
                dwVBI = GetPreviousAutoflipOutInfo.dwVBISurfaceIndex;
            }

            pGetPreviousAutoflipOut->hVideoSurface = NULL;
            pGetPreviousAutoflipOut->hVBISurface = NULL;
            if( ( peDxVideoPort->cAutoflipVideo > 0 ) && ( dwVideo != (DWORD) -1 ) )
            {
                pGetPreviousAutoflipOut->hVideoSurface =
                    peDxVideoPort->apeDxSurfaceVideo[dwVideo];
            }
            if( ( peDxVideoPort->cAutoflipVbi > 0 ) && ( dwVBI != (DWORD) -1 ) )
            {
                pGetPreviousAutoflipOut->hVBISurface =
                    peDxVideoPort->apeDxSurfaceVbi[dwVBI];
            }
            pGetPreviousAutoflipOut->bPolarity =
                ( GetPolarityOutInfo.bPolarity == FALSE );  // invert
        }
    }

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    pGetPreviousAutoflipOut->ddRVal    = dwRet;
}

/******************************Public*Routine******************************\
* BOOL bDxModifyPassiveEventList
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDxModifyPassiveEventList(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    BOOL                bAdd,           // TRUE to add, FALSE to delete
    DWORD               dwEvent,
    LPDD_NOTIFYCALLBACK pfnCallBack,
    PVOID               pContext
    )
{
    BOOL            bRet;
    DXAPI_EVENT*    pDxEvent;
    DXAPI_EVENT*    pDxEvent_New;
    DXAPI_EVENT*    pDxEvent_Previous;
    KIRQL           OldIrql;

    bRet = FALSE;                       // Assume failure

    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL, "Expected passive level");
    ASSERTDX((bAdd == FALSE) || (bAdd == TRUE), "Bad boolean");

    if (bAdd)
    {
        pDxEvent_New = (DXAPI_EVENT*) ExAllocatePoolWithTag(PagedPool,
                                                            sizeof(*pDxEvent),
                                                            'eddG');

        if (pDxEvent_New == NULL)
            return(FALSE);

        RtlZeroMemory(pDxEvent_New, sizeof(*pDxEvent_New));
    }

    // We must synchronize additions or deletions to the passive-level
    // event list via our devlock.

    ASSERTDX(gpfnLockDevice, "bDxModifyPassiveEventList: gpfnLockDevice is NULL");
    gpfnLockDevice(peDxDirectDraw->hdev);

    if (peDxDirectDraw->bLost)
    {
        KdPrint(("bDxModifyPassiveEventList: Object is lost\n"));
    }
    else
    {
        // First, try to find this event in the list:

        pDxEvent_Previous = NULL;

        for (pDxEvent = peDxDirectDraw->pDxEvent_PassiveList;
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            if ((pDxEvent->dwEvent     == dwEvent)     &&
                (pDxEvent->pfnCallBack == pfnCallBack) &&
                (pDxEvent->pContext    == pContext))
            {
                break;
            }

            pDxEvent_Previous = pDxEvent;
        }
         
        // It's a failure when:
        //
        //    1) If adding, the same event is already in the list;
        //    2) If deleting, the event is not in the list.

        if ((bAdd) == (pDxEvent == NULL))
        {
            if (bAdd)
            {
                // Add the event.

                pDxEvent_New->peDxDirectDraw = peDxDirectDraw;
                pDxEvent_New->dwEvent        = dwEvent;
                pDxEvent_New->dwIrqFlag      = 0;
                pDxEvent_New->pfnCallBack    = pfnCallBack;
                pDxEvent_New->pContext       = pContext;
                pDxEvent_New->pDxEvent_Next  = peDxDirectDraw->pDxEvent_PassiveList;

                peDxDirectDraw->pDxEvent_PassiveList = pDxEvent_New;

                bRet = TRUE;
            }
            else
            {
                // Delete the event.

                if (pDxEvent_Previous == NULL)
                {
                    ASSERTDX(peDxDirectDraw->pDxEvent_PassiveList == pDxEvent,
                        "Deletion code is confused");

                    peDxDirectDraw->pDxEvent_PassiveList = pDxEvent->pDxEvent_Next;
                }
                else
                {
                    pDxEvent_Previous->pDxEvent_Next = pDxEvent->pDxEvent_Next;
                }

                bRet = TRUE;
            }
        }
    }

    ASSERTDX(gpfnUnlockDevice, "bDxModifyPassiveEventList: gpfnUnlockDevice is NULL");
    gpfnUnlockDevice(peDxDirectDraw->hdev);

    if (bAdd)   // Add case
    {
        if (!bRet)
        {
            // Add failed, so free the new node we allocated up front:

            ExFreePool(pDxEvent_New);

            RIPDX("DD_DXAPI_REGISTER_EVENT: Event was already registered");
        }
    }
    else        // Remove case
    {
        if (bRet)
        {
            // Delete succeeded, so free the old node:

            ExFreePool(pDxEvent);
        }
        else
        {
            KdPrint(("DD_DXAPI_UNREGISTEREVENT: Couldn't find an event registered with those\n"));
            KdPrint(("same parameters, so the unregister failed.\n"));
            RIPDX("This will probably cause a leak of non-paged memory!");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bDxModifyDispatchEventList
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDxModifyDispatchEventList(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    EDD_DXVIDEOPORT*    peDxVideoPort,
    BOOL                bAdd,           // TRUE to add, FALSE to delete
    DWORD               dwEvent,
    DWORD               dwIrqFlag,
    LPDD_NOTIFYCALLBACK pfnCallBack,
    PVOID               pContext,
    DWORD               dwListEntry
    )
{
    BOOL                    bRet;
    DXAPI_EVENT*            pDxEvent;
    DXAPI_EVENT*            pDxEvent_New;
    DXAPI_EVENT*            pDxEvent_Previous;
    KIRQL                   OldIrql;

    bRet = FALSE;                       // Assume failure

    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL, "Expected passive level");
    ASSERTDX((bAdd == FALSE) || (bAdd == TRUE), "Bad boolean");

    // The event list is traversed at dispatch-level, so needs
    // to be allocated non-paged.

    if (bAdd)
    {
        pDxEvent_New = (DXAPI_EVENT*) ExAllocatePoolWithTag(NonPagedPool,
                                                            sizeof(*pDxEvent),
                                                            'eddG');
        if (pDxEvent_New == NULL)
            return(FALSE);

        RtlZeroMemory(pDxEvent_New, sizeof(*pDxEvent_New));
    }

    // We must synchronize additions or deletions to the dispatch-level
    // event list via our spin lock.  Note that this spinlock (of course)
    // raises our IRQL level, which means we can't touch any pageable code!

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    if ((peDxDirectDraw->bLost) ||
        ((peDxVideoPort != NULL) && (peDxVideoPort->bLost)))
    {
        KdPrint(("bDxModifyDispatchEventList: Objects are lost\n"));
    }
    else
    {
        // First, try to find this event in the list:

        pDxEvent_Previous = NULL;

        for (pDxEvent = peDxDirectDraw->pDxEvent_DispatchList[dwListEntry];
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            if ((pDxEvent->dwEvent     == dwEvent)     &&
                (pDxEvent->dwIrqFlag   == dwIrqFlag)   &&
                (pDxEvent->pfnCallBack == pfnCallBack) &&
                (pDxEvent->pContext    == pContext))
            {
                break;
            }

            pDxEvent_Previous = pDxEvent;
        }

        // It's a failure when:
        //
        //    1) If adding, the same event is already in the list;
        //    2) If deleting, the event is not in the list.

        if ((bAdd) == (pDxEvent == NULL))
        {
            if (bAdd)
            {
                // Add the event.

                pDxEvent_New->peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
                pDxEvent_New->peDxVideoPort  = peDxVideoPort;
                pDxEvent_New->dwEvent        = dwEvent;
                pDxEvent_New->dwIrqFlag      = dwIrqFlag;
                pDxEvent_New->pfnCallBack    = pfnCallBack;
                pDxEvent_New->pContext       = pContext;
                pDxEvent_New->pDxEvent_Next  = peDxDirectDraw->pDxEvent_DispatchList[dwListEntry];

                peDxDirectDraw->pDxEvent_DispatchList[dwListEntry] = pDxEvent_New;

                bRet = TRUE;
            }
            else
            {
                // Delete the event.

                if (pDxEvent_Previous == NULL)
                {
                    ASSERTDX(peDxDirectDraw->pDxEvent_DispatchList[dwListEntry] == pDxEvent,
                        "Deletion code is confused");

                    peDxDirectDraw->pDxEvent_DispatchList[dwListEntry]
                        = pDxEvent->pDxEvent_Next;
                }
                else
                {
                    pDxEvent_Previous->pDxEvent_Next = pDxEvent->pDxEvent_Next;
                }

                bRet = TRUE;
            }
        }
    }

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    if (bAdd)   // Add case
    {
        if (!bRet)
        {
            // Add failed, so free the new node we allocated up front:

            ExFreePool(pDxEvent_New);
        }
    }
    else        // Remove case
    {
        if (bRet)
        {
            // Delete succeeded, so free the old node:

            ExFreePool(pDxEvent);
        }
        else
        {
            KdPrint(("DD_DXAPI_UNREGISTEREVENT: Couldn't find an event registered with those\n"));
            KdPrint(("same parameters, so the unregister failed.\n"));
            RIPDX("This will probably cause a leak of non-paged memory!");
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vDxEnableInterrupts
*
* NOTE: Drivers may not fail DxEnableIrq.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDxEnableInterrupts(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    DWORD               dwLine
    )
{
    DWORD           dwIRQSources = 0;
    KIRQL           OldIrql;
    DXAPI_EVENT*    pDxEvent;
    DDENABLEIRQINFO EnableIrqInfo;
    DWORD           dwRet;
    DWORD           i;

    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL, "Expected passive level");
    ASSERTDX(peDxDirectDraw->DxApiInterface.DxEnableIrq != NULL,
        "DxEnableIrq must be hooked if supporting interrupts.");

    // We acquire both the devlock and the spinlock to ensure that no other
    // activity in the driver is occurring while interrupts are enabled.
    //
    // The motivation for acquiring both (the spinlock could have been
    // sufficient) is that we want to allow drivers to touch the CRTC
    // registers in their interrupt enable routine (typically, both the
    // display driver and the enable interrupt routine use CRTC registers,
    // the usage of which must be synchronized).

    ASSERTDX(gpfnLockDevice, "vDxEnableInterrupts: gpfnLockDevice is NULL");
    gpfnLockDevice(peDxDirectDraw->hdev);

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    // Compute the interrupts that are to be enabled by traversing the
    // active event list:

    for( i = 0; i < NUM_DISPATCH_LISTS; i++ )
    {
        for (pDxEvent = peDxDirectDraw->pDxEvent_DispatchList[i];
            pDxEvent != NULL;
            pDxEvent = pDxEvent->pDxEvent_Next)
        {
            dwIRQSources |= pDxEvent->dwIrqFlag;
        }
    }

    EnableIrqInfo.dwIRQSources = dwIRQSources;
    EnableIrqInfo.dwLine       = dwLine;
    EnableIrqInfo.IRQCallback  = DxIrqCallBack;
    EnableIrqInfo.lpIRQData    = &peDxDirectDraw->IrqData;

    dwRet = peDxDirectDraw->DxApiInterface.DxEnableIrq(
                                peDxDirectDraw->HwDeviceExtension,
                                &EnableIrqInfo,
                                NULL);

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    ASSERTDX(gpfnUnlockDevice, "vDxEnableInterrupts: gpfnUnlockDevice is NULL");
    gpfnUnlockDevice(peDxDirectDraw->hdev);

    ASSERTDX(dwRet == DD_OK, "vDxEnableInterrupts: Driver failed DxEnableIrq");
}

/******************************Public*Routine******************************\
* DWORD dwDxRegisterEvent
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
dwDxRegisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    BOOL                bRegister       // TRUE if register, FALSE if unregister
    )
{
    DWORD               dwRet;
    DXOBJ*              pDxObjDirectDraw;
    DXOBJ*              pDxObjVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    DWORD               dwEvent;
    DWORD               dwIrqFlag;
    BOOL                bPassiveEvent;
    BOOL                bDispatchEvent;
    DWORD               dwLine;

    dwRet = DDERR_GENERIC;              // Assume failure

    // Passive level is required because we have to acquire the devlock
    // for the RESCHANGE and DOSBOX notifications.

    ASSERTDX(KeGetCurrentIrql() == PASSIVE_LEVEL, "Expected passive level");
    ASSERTDX(pRegisterEvent->pfnCallback != NULL, "Null callback specified");
    ASSERTDX(pRegisterEvent->hDirectDraw != NULL, "Null hDirectDraw specified");

    pDxObjDirectDraw = (DXOBJ*) pRegisterEvent->hDirectDraw;
    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;

    // Note that we don't support the hooking of DDEVENT_CLOSEDIRECTDRAW,
    // DDEVENT_CLOSESURFACE, or DDEVENT_CLOSEVIDEOPORT because those are
    // always explictly registered with the object open call.  If multiple
    // clients want object close notification, they should each open their
    // own object instances.

    dwEvent = pRegisterEvent->dwEvents;

    // Memphis doesn't bother checking to verify that 'dwParam1' and
    // 'dwParam2' are zero when unused, so we won't either.

    bPassiveEvent = FALSE;
    bDispatchEvent = FALSE;
    peDxVideoPort = NULL;
    dwLine = 0;
    dwIrqFlag = 0;

    switch (dwEvent)
    {
    case DDEVENT_VP_VSYNC:
    case DDEVENT_VP_LINE:

        ASSERTDX(pRegisterEvent->dwParam1 != NULL,
            "dwParam1 should be videoport handle");

        pDxObjVideoPort = (DXOBJ*) pRegisterEvent->dwParam1;
        peDxVideoPort   = pDxObjVideoPort->peDxVideoPort;

        ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
            "dwParam1 should be videoport handle");

        if (dwEvent == DDEVENT_VP_LINE)
        {
            dwIrqFlag = DDIRQ_VPORT0_LINE;      // We're going to shift this...

            // We make it so that the 'dwLine' parameter is non-zero only
            // when the event is registered, not unregistered,

            dwLine = (bRegister) ? (DWORD) pRegisterEvent->dwParam2 : 0;
        }
        else
        {
            dwIrqFlag = DDIRQ_VPORT0_VSYNC;     // We're going to shift this...
        }

        dwIrqFlag <<= (2 * peDxVideoPort->dwVideoPortID);

        bDispatchEvent = TRUE;
        break;

    case DDEVENT_DISPLAY_VSYNC:

        dwIrqFlag = DDIRQ_DISPLAY_VSYNC;
        bDispatchEvent = TRUE;
        break;

    case DDEVENT_PRERESCHANGE:
    case DDEVENT_POSTRESCHANGE:
    case DDEVENT_PREDOSBOX:
    case DDEVENT_POSTDOSBOX:

        bPassiveEvent = TRUE;
        break;

    default:

        KdPrint(("dwDxRegisterEvent: Invalid dwEvents specified\n"));
        dwRet = DDERR_UNSUPPORTED;
        break;
    }

    if (bPassiveEvent)
    {
        if (bDxModifyPassiveEventList(peDxDirectDraw,
                                      bRegister,
                                      dwEvent,
                                      pRegisterEvent->pfnCallback,
                                      pRegisterEvent->pContext))
        {
            dwRet = DD_OK;
        }
    }
    else if (bDispatchEvent)
    {
        // First, verify that the requested interrupt is supported:

        if (!(peDxDirectDraw->dwIRQCaps & dwIrqFlag))
        {
            KdPrint(("dwDxRegisterEvent: Interrupt not supported by driver.\n"));
            dwRet = DDERR_UNSUPPORTED;
        }
        else
        {
            if (bDxModifyDispatchEventList(peDxDirectDraw,
                                           peDxVideoPort,
                                           bRegister,
                                           dwEvent,
                                           dwIrqFlag,
                                           pRegisterEvent->pfnCallback,
                                           pRegisterEvent->pContext,
                                           CLIENT_DISPATCH_LIST))
            {
                vDxEnableInterrupts(peDxDirectDraw, dwLine);
                dwRet = DD_OK;
            }
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* VOID DxRegisterEvent
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxRegisterEvent(
    DDREGISTERCALLBACK*    pRegisterEvent,
    DWORD*              pdwRet
    )
{
    *pdwRet = dwDxRegisterEvent(pRegisterEvent, TRUE);
}

/******************************Public*Routine******************************\
* VOID DxUnregisterEvent
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxUnregisterEvent(
    DDREGISTERCALLBACK* pRegisterEvent,
    DWORD*              pdwRet
    )
{
    *pdwRet = dwDxRegisterEvent(pRegisterEvent, FALSE);
}

/******************************Public*Routine******************************\
* VOID DxGetPolarity
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxGetPolarity(
    DDGETPOLARITYIN*    pGetPolarityIn,
    DDGETPOLARITYOUT*   pGetPolarityOut
    )
{
    DWORD                       dwRet;
    DXOBJ*                      pDxObjDirectDraw;
    DXOBJ*                      pDxObjVideoPort;
    DXOBJ*                      pDxObjTarget;
    DXOBJ*                      pDxObjCurrent;
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    EDD_DXVIDEOPORT*            peDxVideoPort;
    DDGETPOLARITYININFO         GetPolarityInInfo;
    DDGETPOLARITYOUTINFO        GetPolarityOutInfo;
    KIRQL                       OldIrql;

    dwRet = DDERR_UNSUPPORTED;      // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pGetPolarityIn->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pGetPolarityIn->hVideoPort;

    peDxDirectDraw   = pDxObjDirectDraw->peDxDirectDraw;
    peDxVideoPort    = pDxObjVideoPort->peDxVideoPort;

    ASSERTDX(pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW,
        "Invalid DirectDraw object");
    ASSERTDX(pDxObjVideoPort->iDxType == DXT_VIDEOPORT,
        "Invalid VideoPort object");
    ASSERTDX(peDxDirectDraw == peDxVideoPort->peDxDirectDraw,
        "Surface, VideoPort, and DirectDraw objects don't match");

    GetPolarityInInfo.lpVideoPortData = peDxVideoPort;
    GetPolarityOutInfo.bPolarity = 0;

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    if ((peDxDirectDraw->bLost) ||
        (peDxVideoPort->bLost))
    {
        KdPrint(("DxGetPolarity: Objects are lost\n"));
        dwRet = DDERR_SURFACELOST;
    }
    else
    {
        if (peDxDirectDraw->DxApiInterface.DxGetPolarity)
        {
            dwRet = peDxDirectDraw->DxApiInterface.DxGetPolarity(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &GetPolarityInInfo,
                                    &GetPolarityOutInfo);
        }
    }

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    pGetPolarityOut->ddRVal = dwRet;
    pGetPolarityOut->bPolarity = GetPolarityOutInfo.bPolarity;
}

/******************************Public*Routine******************************\
* VOID DxAddVpCaptureBuffer
*
*  01-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxAddVpCaptureBuffer(
    DDADDVPCAPTUREBUFF* pAddCaptureBuff,
    DWORD*   		pdwRet
    )
{
    DXOBJ*                      pDxObjCapture;
    EDD_DXCAPTURE*              peDxCapture;
    EDD_DXVIDEOPORT*            peDxVideoPort;
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    DWORD                       dwTop;
    KIRQL                       OldIrql;

    pDxObjCapture = (DXOBJ*) pAddCaptureBuff->hCapture;
    peDxCapture   = pDxObjCapture->peDxCapture;

    ASSERTDX(pDxObjCapture->iDxType == DXT_CAPTURE,
        "Invalid Capture object");
    ASSERTDX(pAddCaptureBuff->pKEvent != NULL,
        "No KEvent specified");
    ASSERTDX(pAddCaptureBuff->pMDL != NULL,
        "No MDL specified");
    ASSERTDX((pAddCaptureBuff->dwFlags != 0 ) &&
             !(pAddCaptureBuff->dwFlags & ~(DDADDBUFF_SYSTEMMEMORY|DDADDBUFF_NONLOCALVIDMEM|DDADDBUFF_INVERT)),
        "Invalid flags specified");
    ASSERTDX(pAddCaptureBuff->lpBuffInfo != NULL,
        "lpBuffInfo not specified");

    *pdwRet = DDERR_INVALIDOBJECT;
    peDxVideoPort = peDxCapture->peDxVideoPort;
    if( peDxVideoPort != NULL )
    {
        peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        if( !( peDxVideoPort->bLost ) &&
            !( peDxCapture->bLost ) )
        {
            // Is the queue full?

            dwTop = peDxCapture->dwTop;
            if( ( peDxCapture->CaptureQueue[dwTop].flFlags & DD_DXCAPTUREBUFF_FLAG_IN_USE ) ||
                !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON ) )
            {
                *pdwRet = DDERR_CURRENTLYNOTAVAIL;
            }
            else
            {
                // Save the new buffer in the queque

                peDxCapture->CaptureQueue[dwTop].dwClientFlags =
                    pAddCaptureBuff->dwFlags;
                peDxCapture->CaptureQueue[dwTop].pBuffMDL =
                    pAddCaptureBuff->pMDL;
                peDxCapture->CaptureQueue[dwTop].pBuffKEvent =
                    pAddCaptureBuff->pKEvent;
                peDxCapture->CaptureQueue[dwTop].lpBuffInfo =
                    (PVOID) pAddCaptureBuff->lpBuffInfo;
                peDxCapture->CaptureQueue[dwTop].flFlags = DD_DXCAPTUREBUFF_FLAG_IN_USE;
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_CAPTURING;

                if( ++(peDxCapture->dwTop) >= DXCAPTURE_MAX_CAPTURE_BUFFS )
                {
                    peDxCapture->dwTop = 0;
                }
                *pdwRet = DD_OK;
            }
        }
        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
    }
}

/******************************Public*Routine******************************\
* VOID DxInternalFlushVpCaptureBuffs
*
*  12-Apr-1999 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxInternalFlushVpCaptureBuffs(
    EDD_DXDIRECTDRAW*   peDxDirectDraw,
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXCAPTURE*      peDxCapture
    )
{
    DDTRANSFERININFO    ddTransferIn;
    DDTRANSFEROUTINFO   ddTransferOut;
    LPDDCAPBUFFINFO     lpBuffInfo;
    DWORD               i;

    // Turn off all video port capture if nobody else is capturing

    if( peDxVideoPort->peDxCapture && ( peDxCapture->peDxCaptureNext == NULL ) )
    {
        peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_CAPTURING;
    }

    // If a buffer is in the queue and the busmaster has not yet been
    // initiated, clear it now so we don't do it. If the busmaster has
    // already been initiated, we will tell the miniport to stop it now.

    peDxCapture->dwTop = peDxCapture->dwBottom = 0;
    for( i = 0; i < DXCAPTURE_MAX_CAPTURE_BUFFS; i++ )
    {
        if( peDxCapture->CaptureQueue[i].flFlags & DD_DXCAPTUREBUFF_FLAG_IN_USE )
        {
            if( peDxCapture->CaptureQueue[i].flFlags & DD_DXCAPTUREBUFF_FLAG_WAITING )
            {
                ddTransferIn.dwStartLine = 0;
                ddTransferIn.dwEndLine = 0;
                ddTransferIn.dwTransferFlags = DDTRANSFER_CANCEL;
                ddTransferIn.lpDestMDL = NULL;
                ddTransferIn.lpSurfaceData = NULL;
                ddTransferIn.dwTransferID = ((ULONG_PTR)peDxCapture & ~0xf) + i;

                if (peDxDirectDraw->DxApiInterface.DxTransfer)
                {
                    peDxDirectDraw->DxApiInterface.DxTransfer(
                        peDxDirectDraw->HwDeviceExtension,
                        &ddTransferIn,
                        &ddTransferOut);
                }

                peDxCapture->CaptureQueue[i].peDxSurface->flFlags
                    &= ~DD_DXSURFACE_FLAG_TRANSFER;
            }

            lpBuffInfo = (LPDDCAPBUFFINFO) peDxCapture->CaptureQueue[i].lpBuffInfo;
            lpBuffInfo->bPolarity = 0;
            lpBuffInfo->dwFieldNumber = 0;
            lpBuffInfo->ddRVal = (DWORD) DDERR_GENERIC;
            peDxCapture->CaptureQueue[i].flFlags = 0;

            KeSetEvent( peDxCapture->CaptureQueue[i].pBuffKEvent, 0, 0 );
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxFlushVpCaptureBuffs
*
*  01-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxFlushVpCaptureBuffs(
    DWORD**     hCapture,
    DWORD*   	pdwRet
    )
{
    DXOBJ*              pDxObjCapture;
    EDD_DXCAPTURE*      peDxCapture;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    KIRQL               OldIrql;

    ASSERTDX(KeGetCurrentIrql() <= DISPATCH_LEVEL,
        "DxFlushCaptureBuffs: Call less than or equl to DISPATCH_LEVEL (it accesses the dispatch table)");

    pDxObjCapture = (DXOBJ*) (*hCapture);
    peDxCapture   = pDxObjCapture->peDxCapture;
    peDxVideoPort = peDxCapture->peDxVideoPort;
    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

    DxInternalFlushVpCaptureBuffs( peDxDirectDraw, peDxVideoPort, peDxCapture );

    KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

    *pdwRet = DD_OK;
}

/******************************Public*Routine******************************\
* VOID DxIrqCallBack
*
* This routine is called by the miniport at interrupt time to notify us
* of interrupt-based events.  We simply queue a DPC to handle the request
* at the more appropriate dispatch level, instead of interrupt level that
* we're currently at.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxIrqCallBack(
    DX_IRQDATA* pIrqData
    )
{
    EDD_DXDIRECTDRAW* peDxDirectDraw;

    // We always tell the miniport to call us back with the pointer to
    // &peDxDirectDraw->IrqData, so we can get back to the original
    // peDxDirectDraw by subtracting the offset.  If we ever need to
    // change this in the future, we can simply add a field to DX_IRQDATA
    // to point to the context:

    peDxDirectDraw = (EDD_DXDIRECTDRAW*)
        ((BYTE*) pIrqData - offsetof(EDD_DXDIRECTDRAW, IrqData));

    // It's okay if KeInsertQueueDpc fails because the same DPC for a
    // previous interrupt is still queued -- the miniport always ORs
    // its interrupt flags into pIrqData->dwIrqflags.

    KeInsertQueueDpc(&peDxDirectDraw->EventDpc, pIrqData, NULL);
}

/******************************Public*Routine******************************\
* VOID DxGetIrqFlags
*
* Out interrupt processing code runs at DPC level, and can be interrupt
* by an ISR.  Consequently, when we look at the interrupt status, we
* must synchronize with the ISR.  This is accomplished by having
* VideoPortSynchronizeExecution (which does a KeSynchronizeExecution)
* call-back to this routine.
*
* All we do here is copy the flags to the device extension (actually,
* we use the EDD_DXDIRECTDRAW which is allocated one-to-one with the
* device extension).
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOLEAN
DxGetIrqFlags(
    PVOID   pvContext
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;

    peDxDirectDraw = (EDD_DXDIRECTDRAW*) pvContext;

    // Copy the flags to a safe place:

    peDxDirectDraw->dwSynchedIrqFlags = peDxDirectDraw->IrqData.dwIrqFlags;

    // We have to zero the current flags because the miniport always ORs
    // its flags in:

    peDxDirectDraw->IrqData.dwIrqFlags = 0;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID DxEventDpc
*
* This routine does all the work of handling interrupt notification
* from the miniport.  It makes the synchronous call-backs to anyone
* who has hooked the particular event.
*
* Note that to be synchronous we're making the call-backs at dispatch
* level.  So if a callee doesn't require a truly synchronous notification,
* they should do nothing but kick off an event.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

// We can't call KeSynchronizeExecution directly, because we don't
// have the device's interrupt object.  Videoport.sys does, however.
// Unfortunately, 'video.h', which is used to access the videoport.sys
// routines, was never intended to be mixed with GDI and USER header
// files (among other problems, there are conflicts in the PEVENT and
// PVIDEO_POWER_MANAGEMENT structures).  So we define what prototypes
// we need here:

extern "C" {

typedef enum VIDEO_SYNCHRONIZE_PRIORITY {
    VpLowPriority,
    VpMediumPriority,
    VpHighPriority
} VIDEO_SYNCHRONIZE_PRIORITY, *PVIDEO_SYNCHRONIZE_PRIORITY;

typedef
BOOLEAN
(*PMINIPORT_SYNCHRONIZE_ROUTINE)(
    PVOID Context
    );

VOID
VideoPortSynchronizeExecution(
    PVOID HwDeviceExtension,
    VIDEO_SYNCHRONIZE_PRIORITY Priority,
    PMINIPORT_SYNCHRONIZE_ROUTINE synchronizeRoutine,
    PVOID Context
    );

};

VOID
DxEventDpc(
    PKDPC   pDpc,
    PVOID   pvContext,
    PVOID   pvArgument1,
    PVOID   pvArgument2
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DX_IRQDATA*         pIrqData;
    DXAPI_EVENT*        pDxEvent;
    DWORD               dwIrqFlags;
    DWORD               i;

    pIrqData = (DX_IRQDATA*) pvArgument1;
    peDxDirectDraw = (EDD_DXDIRECTDRAW*) pvContext;

    // The ISR can be triggered even while we're processing the DPC for
    // its previous interrupt.  Consequently, we have to access the
    // interrupt flags in a routine that is synchronized to the ISR
    // routine.
    //
    // Note that we don't call KeSynchronizeExecution directly, because
    // we don't have the device's interrupt object.

    VideoPortSynchronizeExecution(peDxDirectDraw->HwDeviceExtension,
                                  VpMediumPriority,
                                  DxGetIrqFlags,
                                  peDxDirectDraw);

    dwIrqFlags = peDxDirectDraw->dwSynchedIrqFlags;

    // We must acquire a spinlock while traversing the event list to
    // protect against simultaneous modifications to the list.

    KeAcquireSpinLockAtDpcLevel(&peDxDirectDraw->SpinLock);

    // We call the callbacks registered by the client before we
    // call the ones that we registered so we give the client a chance
    // to skip fields before we execute our skip logic.  This is why
    // we keep two dispatch lists.

    for (i = 0; i < NUM_DISPATCH_LISTS; i++)
    {
        for (pDxEvent = peDxDirectDraw->pDxEvent_DispatchList[i];
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            if (pDxEvent->dwIrqFlag & dwIrqFlags)
            {
                pDxEvent->pfnCallBack(pDxEvent->dwEvent, pDxEvent->pContext, 0, 0);
            }
        }
    }

    // If it was a busmaster IRQ, take care of them as well

    if (dwIrqFlags & DDIRQ_BUSMASTER)
    {
        for (pDxEvent = peDxDirectDraw->pDxEvent_CaptureList;
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            pDxEvent->pfnCallBack(pDxEvent->dwEvent, pDxEvent->pContext, 0, 0);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&peDxDirectDraw->SpinLock);
}

/******************************Public*Routine******************************\
* VOID vDxFlip
*
* Assumes the spinlock is held.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDxFlip(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    DWORD               dwFlags
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DWORD               iOldVideo;
    DWORD               iOldVbi;
    DWORD               iOldOverlay;
    DWORD               iNewVideo;
    DWORD               iNewVbi;
    DWORD               iNewOverlay;
    DDFLIPVIDEOPORTINFO FlipVideoPortInfo;
    DDFLIPOVERLAYINFO   FlipOverlayInfo;
    DWORD               dwRet;
    DWORD               dwTemp;

    ASSERTDX(KeGetCurrentIrql() == DISPATCH_LEVEL, "Expected held spinlock");

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    if( dwFlags == DDVPFLIP_VBI )
    {
        if (peDxVideoPort->cAutoflipVbi != 0)
        {
            // Flip videoport VBI surface:

            iOldVbi = peDxVideoPort->iCurrentVbi;
            iNewVbi = iOldVbi + 1;
            if (iNewVbi >= peDxVideoPort->cAutoflipVbi)
                iNewVbi = 0;
            peDxVideoPort->iCurrentVbi = iNewVbi;

            FlipVideoPortInfo.lpVideoPortData
                            = peDxVideoPort;
            FlipVideoPortInfo.lpCurrentSurface
                            = peDxVideoPort->apeDxSurfaceVbi[iOldVbi];
            FlipVideoPortInfo.lpTargetSurface
                            = peDxVideoPort->apeDxSurfaceVbi[iNewVbi];
            FlipVideoPortInfo.dwFlipVPFlags = DDVPFLIP_VBI;

            if (peDxDirectDraw->DxApiInterface.DxFlipVideoPort)
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxFlipVideoPort(
                        peDxDirectDraw->HwDeviceExtension,
                        &FlipVideoPortInfo,
                        NULL);
            }
        }
    }

    else if( dwFlags == DDVPFLIP_VIDEO )
    {
        if (peDxVideoPort->cAutoflipVideo != 0)
        {
            // Flip videoport video surface:

            iOldVideo = peDxVideoPort->iCurrentVideo;
            iNewVideo = iOldVideo + 1;
            if (iNewVideo >= peDxVideoPort->cAutoflipVideo)
                iNewVideo = 0;
            peDxVideoPort->iCurrentVideo = iNewVideo;

            FlipVideoPortInfo.lpVideoPortData
                            = peDxVideoPort;
            FlipVideoPortInfo.lpCurrentSurface
                            = peDxVideoPort->apeDxSurfaceVideo[iOldVideo];
            FlipVideoPortInfo.lpTargetSurface
                            = peDxVideoPort->apeDxSurfaceVideo[iNewVideo];
            FlipVideoPortInfo.dwFlipVPFlags
                            = DDVPFLIP_VIDEO;

            if (peDxDirectDraw->DxApiInterface.DxFlipVideoPort)
            {
                dwRet = peDxDirectDraw->DxApiInterface.DxFlipVideoPort(
                        peDxDirectDraw->HwDeviceExtension,
                        &FlipVideoPortInfo,
                        NULL);
            }

            // Flip overlay surface:

            if( ( peDxVideoPort->apeDxSurfaceVideo[0] != NULL ) &&
                ( peDxVideoPort->apeDxSurfaceVideo[0]->ddsCaps & DDSCAPS_OVERLAY ) &&
                ( ( peDxVideoPort->apeDxSurfaceVideo[0]->dwOverlayFlags & DDOVER_AUTOFLIP ) ||
                ( peDxVideoPort->bSoftwareAutoflip ) ) )
            {
                // If there are two surfaces, flip to the opposite surface.  If
                // there are more than two surfaces, flip to dwNumAutoflip - 2.

                dwTemp = 1;
                if( peDxVideoPort->cAutoflipVideo != 2 )
                {
                    dwTemp++;
                }
                dwTemp  = peDxVideoPort->iCurrentVideo +
                    peDxVideoPort->cAutoflipVideo - dwTemp;
                if( dwTemp >= peDxVideoPort->cAutoflipVideo )
                {
                    dwTemp -= peDxVideoPort->cAutoflipVideo;
                }

                FlipOverlayInfo.lpTargetSurface
                            = peDxVideoPort->apeDxSurfaceVideo[dwTemp];
                if( dwTemp == 0 )
                {
                    dwTemp = peDxVideoPort->cAutoflipVideo;
                }
                FlipOverlayInfo.lpCurrentSurface
                            = peDxVideoPort->apeDxSurfaceVideo[--dwTemp];
                FlipOverlayInfo.dwFlags = 0;

                if (peDxDirectDraw->DxApiInterface.DxFlipOverlay)
                {
                    dwRet = peDxDirectDraw->DxApiInterface.DxFlipOverlay(
                        peDxDirectDraw->HwDeviceExtension,
                        &FlipOverlayInfo,
                        NULL);
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDxBob
*
* Assumes the spinlock is held.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDxBob(
    EDD_DXVIDEOPORT*    peDxVideoPort
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DDBOBNEXTFIELDINFO  BobNextFieldInfo;
    DWORD               dwRet;
    DWORD               dwTemp;

    ASSERTDX(KeGetCurrentIrql() == DISPATCH_LEVEL, "Expected held spinlock");

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    // Get the current surface handle.  This is tricky because
    // dwCurrentBuffer tells us which surface the video port is
    // writting to - not which surface has the overlay.  Therefore,
    // we re-create the algorithm used in DoFlip to get the surface.

    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP )
    {
        dwTemp = 1;
        if( peDxVideoPort->cAutoflipVideo != 2 )
        {
	    dwTemp++;
        }
        dwTemp  = peDxVideoPort->iCurrentVideo +
            peDxVideoPort->cAutoflipVideo - dwTemp;
        if( dwTemp >= peDxVideoPort->cAutoflipVideo )
        {
            dwTemp -= peDxVideoPort->cAutoflipVideo;
        }
    }
    else
    {
        dwTemp = 0;
    }

    BobNextFieldInfo.lpSurface = peDxVideoPort->apeDxSurfaceVideo[dwTemp];

    if (peDxDirectDraw->DxApiInterface.DxBobNextField)
    {
        dwRet = peDxDirectDraw->DxApiInterface.DxBobNextField(
                    peDxDirectDraw->HwDeviceExtension,
                    &BobNextFieldInfo,
                    NULL);
    }
}

/******************************Public*Routine******************************\
* VOID vDxSkip
*
* Assumes the spinlock is held.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDxSkip(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    DWORD               dwFlags
    )
{
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    DDSKIPNEXTFIELDINFO     SkipNextFieldInfo;
    DWORD                   dwRet;

    ASSERTDX(KeGetCurrentIrql() == DISPATCH_LEVEL, "Expected held spinlock");

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    if (peDxDirectDraw->DxApiInterface.DxSkipNextField)
    {
        SkipNextFieldInfo.lpVideoPortData = peDxVideoPort;
        SkipNextFieldInfo.dwSkipFlags     = dwFlags;

        dwRet = peDxDirectDraw->DxApiInterface.DxSkipNextField(
                        peDxDirectDraw->HwDeviceExtension,
                        &SkipNextFieldInfo,
                        NULL);
    }
}

/******************************Public*Routine******************************\
* VOID IRQCapture
*
* This routine initiates video/VBI capture based on a video port VSYNC.
*
* NOTE: The spinlock is already held.
*
*  10-Jan-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID IRQCapture(
    EDD_DXVIDEOPORT* peDxVideoPort,
    EDD_DXDIRECTDRAW* peDxDirectDraw
    )
{
    DDGETCURRENTAUTOFLIPININFO  ddAutoflipInInfo;
    DDGETCURRENTAUTOFLIPOUTINFO ddAutoflipOutInfo;
    EDD_DXCAPTURE*       peDxCapture;
    LPDDCAPBUFFINFO      lpBuffInfo;
    DXCAPTUREBUFF*       lpBuff;
    DDTRANSFERININFO     ddTransferIn;
    DDTRANSFEROUTINFO    ddTransferOut;
    ULONGLONG            ullTimeStamp;
    PULONGLONG           pullTemp;
    ULONGLONG            rate;
    DWORD                dwVBIIndex;
    DWORD                dwVideoIndex;
    BOOL                 bStarved = TRUE;
    DWORD                ddRVal;

    // Get the current time stamp

    ullTimeStamp = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;
    ullTimeStamp = (ullTimeStamp & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ullTimeStamp & 0xFFFFFFFF) * 10000000 / rate;

    // If either the VBI or video is being hardware autoflipped, figure out
    // the correct buffers.

    dwVBIIndex = 0;
    dwVideoIndex = 0;
    if( ( ( peDxVideoPort->cAutoflipVbi > 1 ) &&
        !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI ) ) ||
        ( ( peDxVideoPort->cAutoflipVideo > 1 ) &&
        !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP ) ) )
    {
        ddAutoflipInInfo.lpVideoPortData = peDxVideoPort;
        ddAutoflipOutInfo.dwSurfaceIndex = 0;
        if (peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip)
        {
            ddRVal = peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip(
                            peDxDirectDraw->HwDeviceExtension,
                            &ddAutoflipInInfo,
                            &ddAutoflipOutInfo);
        }
        if( peDxVideoPort->cAutoflipVideo > 0 )
        {
            dwVideoIndex = ddAutoflipOutInfo.dwSurfaceIndex;
            if( dwVideoIndex-- == 0 )
            {
                dwVideoIndex = peDxVideoPort->cAutoflipVideo - 1;
            }
        }
        if( peDxVideoPort->cAutoflipVbi > 0 )
        {
            dwVBIIndex = ddAutoflipOutInfo.dwVBISurfaceIndex;
            if( dwVBIIndex-- == 0 )
            {
                dwVBIIndex = peDxVideoPort->cAutoflipVbi - 1;
            }
        }
    }

    // Which is the surface containing the most recent VBI data?

    if( ( peDxVideoPort->cAutoflipVbi > 0 ) &&
        ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI ) )
    {
        dwVBIIndex = peDxVideoPort->iCurrentVbi;
        if( dwVBIIndex-- == 0 )
        {
            dwVBIIndex = peDxVideoPort->cAutoflipVbi - 1;
        }
    }

    // Which is the surface containing the most recent video data?

    if( ( peDxVideoPort->cAutoflipVideo > 0 ) &&
        ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP ) )
    {
        dwVideoIndex = peDxVideoPort->iCurrentVideo;
        if( dwVideoIndex-- == 0 )
        {
            dwVideoIndex = peDxVideoPort->cAutoflipVideo - 1;
        }
    }

    // Look at each capture device to determine if it has to do a busmaster
    // or not

    peDxCapture = peDxVideoPort->peDxCapture;
    while( peDxCapture != NULL )
    {
        if( ( peDxCapture->CaptureQueue[peDxCapture->dwBottom].flFlags & DD_DXCAPTUREBUFF_FLAG_IN_USE ) &&
            !( peDxCapture->CaptureQueue[peDxCapture->dwBottom].flFlags & DD_DXCAPTUREBUFF_FLAG_WAITING ) )
        {
            bStarved = FALSE;

            if( peDxCapture->dwCaptureCountDown-- == 1 )
            {
                peDxCapture->dwCaptureCountDown = peDxCapture->dwCaptureEveryNFields;
                lpBuff = &(peDxCapture->CaptureQueue[peDxCapture->dwBottom]);

                // Fill in the buffer info

                lpBuffInfo = (LPDDCAPBUFFINFO) lpBuff->lpBuffInfo;
                lpBuffInfo->dwFieldNumber = peDxVideoPort->dwCurrentField;
                pullTemp = (PULONGLONG) &(lpBuffInfo->liTimeStamp);
                *pullTemp = ullTimeStamp;

                // Tell mini port to do the transfer

                ddTransferIn.dwStartLine = peDxCapture->dwStartLine;
                ddTransferIn.dwEndLine = peDxCapture->dwEndLine;
                ddTransferIn.dwTransferFlags = lpBuff->dwClientFlags;
                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_HALFLINES )
                {
                    ddTransferIn.dwTransferFlags |= DDTRANSFER_HALFLINES;
                }
                ddTransferIn.lpDestMDL = lpBuff->pBuffMDL;
                if( peDxCapture->flFlags & DD_DXCAPTURE_FLAG_VIDEO )
                {
                    ddTransferIn.lpSurfaceData = peDxVideoPort->apeDxSurfaceVideo[dwVideoIndex];
                }
                else
                {
                    ddTransferIn.lpSurfaceData = peDxVideoPort->apeDxSurfaceVbi[dwVBIIndex];
                }

                if (ddTransferIn.lpSurfaceData)
                {
                    ddTransferIn.dwTransferID = (ULONG_PTR) peDxCapture;
                    ddTransferIn.dwTransferID &= ~0xf;
                    ddTransferIn.dwTransferID |= peDxCapture->dwBottom;

                    ddRVal = DDERR_UNSUPPORTED;
                    if (peDxDirectDraw->DxApiInterface.DxTransfer)
                    {
                        ddRVal = peDxDirectDraw->DxApiInterface.DxTransfer(
                                peDxDirectDraw->HwDeviceExtension,
                                &ddTransferIn,
                                &ddTransferOut);
                    }
                }
                else
                {
                    ddRVal = DDERR_INVALIDPARAMS;
                }

                lpBuffInfo->ddRVal = ddRVal;
                if( ddRVal != DD_OK )
                {
                    // Set the KEvent now

                    KeSetEvent( lpBuff->pBuffKEvent, 0, 0 );
                    lpBuff->flFlags = 0;
                    lpBuff->pBuffKEvent = 0;
                }
                else
                {
                    // Mark the lucky surface as doing a transfer

                    lpBuffInfo->bPolarity = ddTransferOut.dwBufferPolarity;
                    lpBuff->peDxSurface = (EDD_DXSURFACE*) ddTransferIn.lpSurfaceData;
                    lpBuff->peDxSurface->flFlags |= DD_DXSURFACE_FLAG_TRANSFER;
                    lpBuff->flFlags |= DD_DXCAPTUREBUFF_FLAG_WAITING;
                }

                // Next time use the next buffer

                if( ++( peDxCapture->dwBottom ) >= DXCAPTURE_MAX_CAPTURE_BUFFS )
                {
                    peDxCapture->dwBottom = 0;
                }
            }
        }
        peDxCapture = peDxCapture->peDxCaptureNext;
    }

    if( bStarved )
    {
        peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_CAPTURING;
    }
}

/******************************Public*Routine******************************\
* VOID DxAutoflipDpc
*
* This routine handles 'software autoflipping' and is called at dispatch
* level when the miniport's videoport interrupt is triggered.  This routine
* can't be kept in 'win32k.sys' because it needs to be non-pageable.
*
* NOTE: The spinlock is already held.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxAutoflipDpc(
    DWORD       dwEvent,
    PVOID       pContext,
    DWORD       dwParam1,
    DWORD       dwParam2
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    DWORD               dwCurrentField;
    BOOL                bAdjustFirstWeave;
    BOOL                bSkipped;
    BOOL                bFlipped;

    ASSERTDX(KeGetCurrentIrql() == DISPATCH_LEVEL, "Expected dispath level");
    ASSERTDX(dwEvent == DDEVENT_VP_VSYNC, "Expected VP_VSYNC event");

    peDxVideoPort = (EDD_DXVIDEOPORT*) pContext;
    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

    // If capturing, do it now

    if( ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_CAPTURING ) &&
        ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON ) )
    {
        IRQCapture(peDxVideoPort, peDxDirectDraw);
    }

    // Do we need to notify user mode that a vsync occurred?

    if ((peDxVideoPort->pNotifyEvent != NULL) &&
        (peDxVideoPort->pNotifyBuffer != NULL) &&
        (1 == InterlockedExchange( &peDxVideoPort->pNotifyBuffer->lDone, 0 ) ) )
    {
        DDGETCURRENTAUTOFLIPININFO  ddAutoflipInInfo;
        DDGETCURRENTAUTOFLIPOUTINFO ddAutoflipOutInfo;

        ULONGLONG                   ullTimeStamp;
        ULONGLONG                   rate;
        UINT                        dwVideoIndex;

        // Fill in the buffer

        peDxVideoPort->pNotifyBuffer->lField = -1;
        if ( peDxDirectDraw->DxApiInterface.DxGetPolarity )
        {
            DDGETPOLARITYININFO ddPolarityInInfo;
            DDGETPOLARITYOUTINFO ddPolarityOutInfo;
            ddPolarityInInfo.lpVideoPortData = peDxVideoPort;
            peDxDirectDraw->DxApiInterface.DxGetPolarity( peDxDirectDraw->HwDeviceExtension,
                &ddPolarityInInfo, &ddPolarityOutInfo );
            peDxVideoPort->pNotifyBuffer->lField = ddPolarityOutInfo.bPolarity ? 1 : 0;
        }

        dwVideoIndex = 0;
        if (peDxVideoPort->cAutoflipVideo > 1 ) 
        {
            if (peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP)
            {
                dwVideoIndex = peDxVideoPort->iCurrentVideo;
            }
            else
            {
                ddAutoflipInInfo.lpVideoPortData = peDxVideoPort;
                ddAutoflipOutInfo.dwSurfaceIndex = 0;
                if (peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip)
                {
                    peDxDirectDraw->DxApiInterface.DxGetCurrentAutoflip(
                        peDxDirectDraw->HwDeviceExtension,
                        &ddAutoflipInInfo,
                        &ddAutoflipOutInfo);
                }
                dwVideoIndex = ddAutoflipOutInfo.dwSurfaceIndex;
            }
            if( dwVideoIndex-- == 0 )
            {
                dwVideoIndex = peDxVideoPort->cAutoflipVideo - 1;
            }
        }
        peDxVideoPort->pNotifyBuffer->dwSurfaceIndex = dwVideoIndex;

        ullTimeStamp = (ULONGLONG)KeQueryPerformanceCounter((PLARGE_INTEGER)&rate).QuadPart;
        ullTimeStamp = (ullTimeStamp & 0xFFFFFFFF00000000) / rate * 10000000 +
            (ullTimeStamp & 0xFFFFFFFF) * 10000000 / rate;
	*((ULONGLONG*)&(peDxVideoPort->pNotifyBuffer->ApproximateTimeStamp)) = ullTimeStamp;

        KeSetEvent (peDxVideoPort->pNotifyEvent, IO_NO_INCREMENT, FALSE);
    }

    // Note that it is okay to modify 'dwCurrentField' outside of a spinlock,
    // as the only other routine that modifies it is 'DxSetFieldNumber' and
    // it always does an atomic write.

    dwCurrentField = InterlockedIncrement((LONG*) &peDxVideoPort->dwCurrentField);

    // Check for posted state changes

    bAdjustFirstWeave = FALSE;
    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_NEW_STATE )
    {
        if( peDxVideoPort->dwSetStateField-- == 0 )
        {
            peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_NEW_STATE;

            // If we'll be weaving, we need to make sure that
            // we only flip at the beginning of a frame and not
            // during the middle.  We assume that we're told to
            // star weaving at the beginning of the frame.

            if( ( peDxVideoPort->dwSetStateState & DDSTATE_WEAVE ) &&
                !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT ) )
            {
                bAdjustFirstWeave = TRUE;
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
            }
            EffectStateChange( peDxVideoPort, NULL, peDxVideoPort->dwSetStateState );
        }
    }

    // Check the skip logic

    bSkipped = FALSE;
    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIP_SET )
    {
        if( peDxVideoPort->dwFieldToSkip-- == 0 )
        {
            // Tell the MiniPort to skip the next field

            vDxSkip( peDxVideoPort, DDSKIP_SKIPNEXT );
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_SKIPPED_LAST;
            bSkipped = TRUE;

            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET )
            {
                peDxVideoPort->dwFieldToSkip = peDxVideoPort->dwNextFieldToSkip;
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET;
            }
            else
            {
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_SKIP_SET;
            }
        }
        else if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_NEXT_SKIP_SET )
        {
            peDxVideoPort->dwNextFieldToSkip--;
        }
    }
    if( ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SKIPPED_LAST ) && !bSkipped )
    {
        // Tell the MiniPort to un-skip the next field

        vDxSkip( peDxVideoPort, DDSKIP_ENABLENEXT );
        peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_SKIPPED_LAST;

        // This next part is a hack.We keep track of which fields
        // to flip on in weave mode during the ISR, but what if we
        // happen to miss an IRQ (due to DOS box, etc.)?  We can't
        // use to polarity to re-sync because field skipping screws
        // that up, so this code assume that the repeat field will
        // always be the last field of a frame and so the following
        // field will be the first field.  This will make it re-sync
        // if we ever miss an IRQ.

        peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
    }

    // Now do all of the autoflipping

    if( peDxVideoPort->flFlags & (DD_DXVIDEOPORT_FLAG_AUTOFLIP|
        DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI|DD_DXVIDEOPORT_FLAG_BOB ) )
    {
        // Check for autoflipping the VBI surface in which case we
        // don't care about the skip logic

        if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI )
        {
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_VBI_INTERLEAVED )
            {
                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI )
                {
                    peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI;
                    vDxFlip( peDxVideoPort, DDVPFLIP_VBI );
                }
                else
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI;
                }
            }
            else
            {
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_FLIP_NEXT_VBI;
                vDxFlip( peDxVideoPort, DDVPFLIP_VBI );
            }
        }

        // Autoflip the vhe video if we are not skipping this field

        if( !bSkipped )
        {
            bFlipped = FALSE;
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_AUTOFLIP )
            {
                if( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE )
                {
                    if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_FLIP_NEXT )
                    {
                        peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
                        if( !bAdjustFirstWeave )
                        {
                            vDxFlip( peDxVideoPort, DDVPFLIP_VIDEO );
                            bFlipped = TRUE;
                        }
                    }
                    else
                    {
                        peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
                    }
                }
                else
                {
                    vDxFlip( peDxVideoPort, DDVPFLIP_VIDEO );
                    bFlipped = TRUE;
                    peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_FLIP_NEXT;
                }
            }

            // They may be bobbing even when not autoflipping
            // (they may have one interleaved buffer that they
            // use for bob - technically this is not a flip since
            // only one surface is involved).

            if( ( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_BOB ) &&
                !bFlipped )
            {
                vDxBob( peDxVideoPort );
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxBusmasterDpc
*
* This routine handles the video capture and is called when one of
* the buffers is filled.  It figures out which one and then sets the
* compeletion event for that buffer.
*
* NOTE: The spinlock is already held.
*
*  10-Jan-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxBusmasterDpc(
    DWORD       dwEvent,
    PVOID       pContext,
    DWORD       dwParam1,
    DWORD       dwParam2
    )
{
    DDGETTRANSFERSTATUSOUTINFO ddGetTransferStatus;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXCAPTURE*      peDxCapture;
    DWORD               ddRVal;
    ULONG_PTR           dwTempId;
    DWORD               dwTempIndex;

    // Call the miniport to get the transfer ID of the completed busmaster

    ddRVal = DDERR_UNSUPPORTED;
    peDxVideoPort = (EDD_DXVIDEOPORT*) pContext;
    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
    if (peDxDirectDraw->DxApiInterface.DxGetTransferStatus)
    {
        ddRVal = peDxDirectDraw->DxApiInterface.DxGetTransferStatus(
            peDxDirectDraw->HwDeviceExtension,
            NULL,
            &ddGetTransferStatus);
    }
    if( ddRVal == DD_OK )
    {
        // Find the capture object.  It may not even be associated with this
        // video port if multiple vidoe ports exist in the system.

        dwTempId = ddGetTransferStatus.dwTransferID & ~0xf;
        peDxCapture = peDxVideoPort->peDxCapture;
        while (peDxCapture && (((ULONG_PTR)peDxCapture & ~0xf) != dwTempId))
        {
            peDxCapture = peDxCapture->peDxCaptureNext;
        }

        if (peDxCapture != NULL)
        {
            // We've found the capture object

            dwTempIndex = (DWORD)(ddGetTransferStatus.dwTransferID & 0xf);
            if (peDxCapture->CaptureQueue[dwTempIndex].flFlags & DD_DXCAPTUREBUFF_FLAG_WAITING )
            {
                peDxCapture->CaptureQueue[dwTempIndex].flFlags = 0;
                KeSetEvent(peDxCapture->CaptureQueue[dwTempIndex].pBuffKEvent, 0, 0);
            }

            // Mark the lucky surface as being done w/ the transfer

            peDxCapture->CaptureQueue[dwTempIndex].peDxSurface->flFlags
                &= ~DD_DXSURFACE_FLAG_TRANSFER;
            peDxCapture->CaptureQueue[dwTempIndex].peDxSurface = NULL;
        }
    }
}

/******************************Public*Routine******************************\
* VOID DxAutoflipUpdate
*
* This routine handles 'software autoflipping' and is called at dispatch
* level when the miniport's videoport interrupt is triggered.  This routine
* can't be kept in 'win32k.sys' because it needs to be non-pageable.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxAutoflipUpdate(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXSURFACE**     apeDxSurfaceVideo,
    ULONG               cSurfacesVideo,
    EDD_DXSURFACE**     apeDxSurfaceVbi,
    ULONG               cSurfacesVbi
    )
{
    KIRQL   OldIrql;
    ULONG   i;

    KeAcquireSpinLock(&peDxVideoPort->peDxDirectDraw->SpinLock, &OldIrql);

    peDxVideoPort->cAutoflipVideo = cSurfacesVideo;
    for (i = 0; i < cSurfacesVideo; i++)
    {
        peDxVideoPort->apeDxSurfaceVideo[i] = apeDxSurfaceVideo[i];
        peDxVideoPort->apeDxSurfaceVideo[i]->peDxVideoPort = peDxVideoPort;
    }
    peDxVideoPort->cAutoflipVbi = cSurfacesVbi;
    for (i = 0; i < cSurfacesVbi; i++)
    {
        peDxVideoPort->apeDxSurfaceVbi[i] = apeDxSurfaceVbi[i];
        peDxVideoPort->apeDxSurfaceVbi[i]->peDxVideoPort = peDxVideoPort;
    }

    KeReleaseSpinLock(&peDxVideoPort->peDxDirectDraw->SpinLock, OldIrql);
}

/******************************Public*Routine******************************\
* VOID DxLoseObject
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxLoseObject(
    VOID*   pvObject,
    LOTYPE  loType
    )
{
    KIRQL               OldIrql;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    EDD_DXSURFACE*      peDxSurface;
    EDD_DXCAPTURE*      peDxCapture;
    DXAPI_EVENT*        pDxEvent;
    DDENABLEIRQINFO 	EnableIrqInfo;
    DWORD               dwRet;

    switch (loType)
    {
    case LO_DIRECTDRAW:
        peDxDirectDraw = (EDD_DXDIRECTDRAW*) pvObject;

        peDxDirectDraw->peDirectDrawGlobal->peDxDirectDraw = NULL;  // Passive

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        peDxDirectDraw->bLost              = TRUE;
        peDxDirectDraw->peDirectDrawGlobal = NULL;

        if (peDxDirectDraw->DxApiInterface.DxEnableIrq)
        {
            // Make sure all IRQs are disabled

            EnableIrqInfo.dwIRQSources = 0;
            EnableIrqInfo.dwLine       = 0;
            EnableIrqInfo.IRQCallback  = NULL;
            EnableIrqInfo.lpIRQData    = NULL;

            peDxDirectDraw->DxApiInterface.DxEnableIrq(
                                    peDxDirectDraw->HwDeviceExtension,
                                    &EnableIrqInfo,
                                    NULL);
        }

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        break;

    case LO_VIDEOPORT:
        peDxVideoPort = (EDD_DXVIDEOPORT*) pvObject;
        peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

        peDxVideoPort->peVideoPort->peDxVideoPort = NULL;           // Passive

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        peDxVideoPort->bLost       = TRUE;
        peDxVideoPort->peVideoPort = NULL;
        peDxVideoPort->peDxCapture = NULL;

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        break;

    case LO_SURFACE:
        peDxSurface = (EDD_DXSURFACE*) pvObject;
        peDxDirectDraw = peDxSurface->peDxDirectDraw;

        peDxSurface->peSurface->peDxSurface = NULL;                 // Passive

        KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

        peDxSurface->bLost     = TRUE;
        peDxSurface->peSurface = NULL;
        peDxSurface->peDxVideoPort = NULL;

        KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);
        break;

    case LO_CAPTURE:
        peDxCapture = (EDD_DXCAPTURE*) pvObject;
        peDxVideoPort = peDxCapture->peDxVideoPort;
        if( peDxVideoPort != NULL )
        {
            peDxDirectDraw = peDxVideoPort->peDxDirectDraw;

            KeAcquireSpinLock(&peDxDirectDraw->SpinLock, &OldIrql);

            // First flush the capture buffers

            DxInternalFlushVpCaptureBuffs( peDxDirectDraw, peDxVideoPort, peDxCapture );

            // Disassociate the capture object from the video port

            peDxCapture->peDxVideoPort = NULL;
            peDxCapture->bLost       = TRUE;
            if( peDxVideoPort->peDxCapture == peDxCapture )
            {
                peDxVideoPort->peDxCapture = peDxCapture->peDxCaptureNext;
            }
            else
            {
                EDD_DXCAPTURE* peDxTemp;

                for( peDxTemp = peDxVideoPort->peDxCapture;
                    ( peDxTemp != NULL ) &&
                    ( peDxTemp->peDxCaptureNext != peDxCapture );
                    peDxTemp = peDxTemp->peDxCaptureNext );
                if( peDxTemp != NULL )
                {
                    peDxTemp->peDxCaptureNext = peDxCapture->peDxCaptureNext;
                }
                else
                {
                    RIPDX("Capture object not in video port list");
                }
            }

            // If there are no more capture objects associated with the
            // video port, remove the video port from the capture list.

            pDxEvent = NULL;
            if( peDxVideoPort->peDxCapture == NULL )
            {
                if( peDxDirectDraw->pDxEvent_CaptureList->peDxVideoPort == peDxVideoPort )
                {
                    pDxEvent = peDxDirectDraw->pDxEvent_CaptureList;
                    peDxDirectDraw->pDxEvent_CaptureList = pDxEvent->pDxEvent_Next;
                }
                else
                {
                    for( pDxEvent = peDxDirectDraw->pDxEvent_CaptureList;
                        (pDxEvent != NULL) &&
                        (pDxEvent->pDxEvent_Next->peDxVideoPort != peDxVideoPort);
                        pDxEvent = pDxEvent->pDxEvent_Next );
                    if( pDxEvent != NULL )
                    {
                        pDxEvent->pDxEvent_Next =
                            pDxEvent->pDxEvent_Next->pDxEvent_Next;
                        pDxEvent = pDxEvent->pDxEvent_Next;
                    }
                }
            }

            KeReleaseSpinLock(&peDxDirectDraw->SpinLock, OldIrql);

            if( pDxEvent != NULL )
            {
                ExFreePool(pDxEvent);
            }
        }
        break;

    default:
        RIPDX("Unexpected type");
    }
}

/******************************Public*Routine******************************\
* VOID DxUpdateCapture
*
* This routine inserts capture devices intot he list handling off of the
* video port.  Since this list is walked at DPC level, we need to
* synchronize this with the DPC.
*
*  10-Jan-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxUpdateCapture(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    EDD_DXCAPTURE*      peDxCapture,
    BOOL                bRemove
    )
{
    KIRQL             OldIrql;
    EDD_DXCAPTURE*    peDxTemp;
    EDD_DXDIRECTDRAW* peDxDirectDraw;
    DXAPI_EVENT*      pDxEvent_New;
    DXAPI_EVENT*      pDxEvent_Temp = NULL;
    DWORD             dwRet;

    // If adding to the list, also an event to the capture list so we
    // can get the busmaster complete notification.  Allocate the
    // memory for this now.

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
    if( !bRemove )
    {
        pDxEvent_New = (DXAPI_EVENT*) ExAllocatePoolWithTag(NonPagedPool,
                                                        sizeof(*pDxEvent_New),
                                                        'eddG');
        if (pDxEvent_New == NULL)
            return;

        RtlZeroMemory(pDxEvent_New, sizeof(*pDxEvent_New));
        pDxEvent_New->peDxDirectDraw = peDxDirectDraw;
        pDxEvent_New->peDxVideoPort  = peDxVideoPort;
        pDxEvent_New->pfnCallBack    = (LPDD_NOTIFYCALLBACK) DxBusmasterDpc;
        pDxEvent_New->pContext       = peDxVideoPort;
    }

    KeAcquireSpinLock(&peDxVideoPort->peDxDirectDraw->SpinLock, &OldIrql);

    if( bRemove )
    {
        // First flush the capture buffers

        DxInternalFlushVpCaptureBuffs( peDxDirectDraw, peDxVideoPort, peDxCapture );

        // Disassociate the capture object with the video port

        if( peDxVideoPort->peDxCapture == peDxCapture )
        {
            peDxVideoPort->peDxCapture = peDxCapture->peDxCaptureNext;
        }
        else
        {
            for( peDxTemp = peDxVideoPort->peDxCapture;
                ( peDxTemp != NULL ) &&
                ( peDxTemp->peDxCaptureNext != peDxCapture );
                peDxTemp = peDxTemp->peDxCaptureNext );
            if( peDxTemp != NULL )
            {
                peDxTemp->peDxCaptureNext = peDxCapture->peDxCaptureNext;
            }
        }
        peDxCapture->peDxVideoPort = NULL;

        // If there are no more capture objects associated with the
        // video port, remove the video port from the capture list.

        if( peDxVideoPort->peDxCapture == NULL )
        {
            pDxEvent_Temp = NULL;
            if( peDxDirectDraw->pDxEvent_CaptureList->peDxVideoPort == peDxVideoPort )
            {
                pDxEvent_Temp = peDxDirectDraw->pDxEvent_CaptureList;
                peDxDirectDraw->pDxEvent_CaptureList = pDxEvent_Temp->pDxEvent_Next;
            }
            else
            {
                for( pDxEvent_Temp = peDxDirectDraw->pDxEvent_CaptureList;
                    (pDxEvent_Temp != NULL) &&
                    (pDxEvent_Temp->pDxEvent_Next->peDxVideoPort != NULL);
                    pDxEvent_Temp = pDxEvent_Temp->pDxEvent_Next );
                if( pDxEvent_Temp != NULL )
                {
                    pDxEvent_Temp->pDxEvent_Next =
                        pDxEvent_Temp->pDxEvent_Next->pDxEvent_Next;
                    pDxEvent_Temp = pDxEvent_Temp->pDxEvent_Next;
                }
            }
        }
    }
    else
    {
        // Associate the capture object with the video port

        peDxCapture->peDxCaptureNext = peDxVideoPort->peDxCapture;
        peDxVideoPort->peDxCapture = peDxCapture;

        // Add an event to the capture list so we can get the busmaster
        // complete notification.  First check to see if it's already in
        // in the list.

        for (pDxEvent_Temp = peDxDirectDraw->pDxEvent_CaptureList;
             pDxEvent_Temp != NULL;
             pDxEvent_Temp = pDxEvent_Temp->pDxEvent_Next)
        {
            if (pDxEvent_Temp->peDxVideoPort == peDxVideoPort)
            {
                break;
            }
        }
        if( pDxEvent_Temp == NULL )
        {
            // Not already in list - add it

            pDxEvent_New->pDxEvent_Next = peDxDirectDraw->pDxEvent_CaptureList;
            peDxDirectDraw->pDxEvent_CaptureList = pDxEvent_New;
        }
    }

    KeReleaseSpinLock(&peDxVideoPort->peDxDirectDraw->SpinLock, OldIrql);

    if( bRemove && ( pDxEvent_Temp != NULL ) )
    {
        ExFreePool(pDxEvent_Temp);
    }
    else if( pDxEvent_Temp != NULL )
    {
        ExFreePool(pDxEvent_New);
    }
}

/******************************Public*Routine******************************\
* DWORD DxOpenDirectDraw
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxOpenDirectDraw(
    DDOPENDIRECTDRAWIN*     pOpenDirectDrawIn,
    DDOPENDIRECTDRAWOUT*    pOpenDirectDrawOut
    )
{
    pOpenDirectDrawOut->ddRVal = DDERR_UNSUPPORTED;

    if (gpfnOpenDirectDraw != NULL)
    {
        gpfnOpenDirectDraw(pOpenDirectDrawIn,
                           pOpenDirectDrawOut,
                           DxEventDpc,
                           DXAPI_PRIVATE_VERSION_NUMBER);
    }
}

/******************************Public*Routine******************************\
* VOID DxEnableIRQ
*
* This routine enables/disables the video port VSYNC IRQ  and is
* is called at dispatch level.
*
*  17-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxEnableIRQ(
    EDD_DXVIDEOPORT*    peDxVideoPort,
    BOOL		bEnable
    )
{
    EDD_DXDIRECTDRAW*           peDxDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*      peDirectDrawGlobal;
    DWORD                       dwBit;

    peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
    peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;
    dwBit = DDIRQ_VPORT0_VSYNC << ( peDxVideoPort->dwVideoPortID * 2);

    /*
     * Don't enable or disable of the IRQ isn't supported
     */
    if( ( peDirectDrawGlobal != NULL ) &&
        ( peDirectDrawGlobal->DDKernelCaps.dwIRQCaps & dwBit ) )
    {
        if( bEnable )
        {
            if( !( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_REGISTERED_IRQ ) )
            {
                bDxModifyDispatchEventList(peDxDirectDraw,
                                   peDxVideoPort,
                                   bEnable,
                                   DDEVENT_VP_VSYNC,
                                   dwBit,
                                   (LPDD_NOTIFYCALLBACK) DxAutoflipDpc,
                                   (PVOID)peDxVideoPort,
                                   INTERNAL_DISPATCH_LIST);
                peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_REGISTERED_IRQ;
            }
        }
        else
        {
            if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_REGISTERED_IRQ )
            {
                bDxModifyDispatchEventList(peDxDirectDraw,
                                   peDxVideoPort,
                                   bEnable,
                                   DDEVENT_VP_VSYNC,
                                   dwBit,
                                   (LPDD_NOTIFYCALLBACK) DxAutoflipDpc,
                                   (PVOID)peDxVideoPort,
                                   INTERNAL_DISPATCH_LIST);
                peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_REGISTERED_IRQ;
            }
        }
        vDxEnableInterrupts( peDxDirectDraw, 0 );
    }
}

/******************************Public*Routine******************************\
* DxApi
*
* Single entry point for all DXAPI.SYS public functionality.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

typedef VOID (APIENTRY* PDX_FUNCTION)(VOID*, VOID*);

typedef struct _DXAPI_ENTRY_POINT {
    PDX_FUNCTION    pfn;
    DWORD           cInBuffer;
    DWORD           cOutBuffer;
    BOOLEAN         bMapProcess;
} DXAPI_ENTRY_POINT;

#define DX(fn, structin, structout, boolean) \
    (PDX_FUNCTION) fn, structin, sizeof(structout), boolean

DXAPI_ENTRY_POINT gDxApiEntryPoint[] = {
    DX(DxGetVersionNumber,    0,                              DDGETVERSIONNUMBER,       FALSE ), // 0
    DX(NULL,                  sizeof(DDCLOSEHANDLE),          DWORD,                    TRUE  ), // 1
    DX(DxOpenDirectDraw,      sizeof(DDOPENDIRECTDRAWIN),     DDOPENDIRECTDRAWOUT,      FALSE ), // 2
    DX(NULL,                  sizeof(DDOPENSURFACEIN),        DDOPENSURFACEOUT,         TRUE  ), // 3
    DX(NULL,                  sizeof(DDOPENVIDEOPORTIN),      DDOPENVIDEOPORTOUT,       TRUE  ), // 4
    DX(NULL,                  sizeof(DWORD),                  DDGETKERNELCAPSOUT,       TRUE  ), // 5
    DX(DxGetFieldNumber,      sizeof(DDGETFIELDNUMIN),        DDGETFIELDNUMOUT,         FALSE ), // 6
    DX(DxSetFieldNumber,      sizeof(DDSETFIELDNUM),          DWORD,                    FALSE ), // 7
    DX(DxSetSkipPattern,      sizeof(DDSETSKIPFIELD),         DWORD,                    FALSE ), // 8
    DX(DxGetSurfaceState,     sizeof(DDGETSURFACESTATEIN),    DDGETSURFACESTATEOUT,     FALSE ), // 9
    DX(DxSetSurfaceState,     sizeof(DDSETSURFACESTATE),      DWORD,                    FALSE ), // 10
    DX(DxLock,                sizeof(DDLOCKIN),               DDLOCKOUT,                FALSE ), // 11
    DX(DxFlipOverlay,         sizeof(DDFLIPOVERLAY),          DWORD,                    FALSE ), // 12
    DX(DxFlipVideoPort,       sizeof(DDFLIPVIDEOPORT),        DWORD,                    FALSE ), // 13
    DX(DxGetCurrentAutoflip,  sizeof(DDGETAUTOFLIPIN),        DDGETAUTOFLIPOUT,         FALSE ), // 14
    DX(DxGetPreviousAutoflip, sizeof(DDGETAUTOFLIPIN),        DDGETAUTOFLIPOUT,         FALSE ), // 15
    DX(DxRegisterEvent,       sizeof(DDREGISTERCALLBACK),     DWORD,                    FALSE ), // 16
    DX(DxUnregisterEvent,     sizeof(DDREGISTERCALLBACK),     DWORD,                    FALSE ), // 17
    DX(DxGetPolarity,         sizeof(DDGETPOLARITYIN),        DDGETPOLARITYOUT,         FALSE ), // 18
    DX(NULL,                  sizeof(DDOPENVPCAPTUREDEVICEIN),DDOPENVPCAPTUREDEVICEOUT, TRUE  ), // 19
    DX(DxAddVpCaptureBuffer,  sizeof(DDADDVPCAPTUREBUFF),     DWORD,                    FALSE ), // 20
    DX(DxFlushVpCaptureBuffs, sizeof(DWORD),                  DWORD,                    FALSE ), // 21
};

DWORD
APIENTRY
DxApi(
    DWORD   iFunction,
    VOID*   pInBuffer,
    DWORD   cInBuffer,
    VOID*   pOutBuffer,
    DWORD   cOutBuffer
    )
{
    DWORD dwRet;
    BOOL  bProcessAttached = FALSE;

    dwRet = 0;

    iFunction -= DD_FIRST_DXAPI;

    if ((iFunction >= sizeof(gDxApiEntryPoint) / sizeof(DXAPI_ENTRY_POINT)) ||
        (gDxApiEntryPoint[iFunction].pfn == NULL))
    {
        KdPrint(("DxApi: Invalid function\n"));
    }
    else if ((cInBuffer  < gDxApiEntryPoint[iFunction].cInBuffer) ||
             (cOutBuffer < gDxApiEntryPoint[iFunction].cOutBuffer))
    {
        KdPrint(("DxApi: Input or output buffer too small\n"));
    }
    else
    {
        if (gDxApiEntryPoint[iFunction].bMapProcess)
        {
            PEPROCESS pepSession;

            switch (iFunction)
            {
            case (DD_DXAPI_CLOSEHANDLE - DD_FIRST_DXAPI):
            case (DD_DXAPI_OPENSURFACE - DD_FIRST_DXAPI):
            case (DD_DXAPI_OPENVIDEOPORT - DD_FIRST_DXAPI):
            case (DD_DXAPI_OPENVPCAPTUREDEVICE - DD_FIRST_DXAPI):

                // pInBuffer is a pointer to a structure that has
                // a pointer to DXOBJ as its first element.

                pepSession = ((DXOBJ *)(*(HANDLE *)pInBuffer))->pepSession;
                break;

            case (DD_DXAPI_GETKERNELCAPS - DD_FIRST_DXAPI):

                // pInBuffer is a pointer to DXOBJ.

                pepSession = ((DXOBJ *)pInBuffer)->pepSession;
                break;

            default:
                return (dwRet);
            }

            if (!KeIsAttachedProcess())
            {
                KeAttachProcess(PsGetProcessPcb(pepSession));
                bProcessAttached = TRUE;
            }
        }

        // The return value is the size of the output buffer:

        dwRet = gDxApiEntryPoint[iFunction].cOutBuffer;

        // Call the actual routine:

        gDxApiEntryPoint[iFunction].pfn(pInBuffer, pOutBuffer);

        if (bProcessAttached)
        {
            KeDetachProcess();
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* VOID DxApiInitialize
*
* Called by win32k.sys to initialize dxapi.sys state.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxApiInitialize(
    PFNDXAPIOPENDIRECTDRAW    pfnOpenDirectDraw,
    PFNDXAPIOPENVIDEOPORT     pfnOpenVideoPort,
    PFNDXAPIOPENSURFACE       pfnOpenSurface,
    PFNDXAPICLOSEHANDLE       pfnCloseHandle,
    PFNDXAPIGETKERNELCAPS     pfnGetKernelCaps,
    PFNDXAPIOPENCAPTUREDEVICE pfnOpenCaptureDevice,
    PFNDXAPILOCKDEVICE        pfnLockDevice,
    PFNDXAPIUNLOCKDEVICE      pfnUnlockDevice
    )
{
    gpfnOpenDirectDraw = pfnOpenDirectDraw;
    gpfnLockDevice     = pfnLockDevice;
    gpfnUnlockDevice   = pfnUnlockDevice;

    gDxApiEntryPoint[DD_DXAPI_OPENVIDEOPORT - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnOpenVideoPort;

    gDxApiEntryPoint[DD_DXAPI_OPENSURFACE - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnOpenSurface;

    gDxApiEntryPoint[DD_DXAPI_CLOSEHANDLE - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnCloseHandle;

    gDxApiEntryPoint[DD_DXAPI_GETKERNELCAPS - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnGetKernelCaps;

    gDxApiEntryPoint[DD_DXAPI_OPENVPCAPTUREDEVICE - DD_FIRST_DXAPI].pfn
        = (PDX_FUNCTION) pfnOpenCaptureDevice;
}

/******************************Public*Routine******************************\
* ULONG DxApiGetVersion
*
* The original Memphis DXAPI had this entry point and although it doesn't
* do anything usefull, some drivers called it so we have to support it
* for those drivers to load.  It does not return a real version number
* because the original incorrectly returned the DSOUND version 4.02,
* which has no correlation to the DxApi version number.  If we return the
* real version, however, we risk breaking drivers.
*
*  16-Apr-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

ULONG
APIENTRY
DxApiGetVersion(
    VOID
    )
{
    return( 0x402 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddguids.c ===
/******************************Module*Header*******************************\
* Module Name: ddguids.c
*
* This file contains the actual data declarations for all GUIDs used by
* GDI and device drivers.
*
* Created: 15-Feb-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/

#define GUID_DEFS_ONLY
#define INITGUID
#include <guiddef.h>
#include <ddrawint.h>
#include <dxmini.h>
// #include <dvp.h>
#include <agp.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\d3d.cxx ===
/******************************Module*Header*******************************\
* Module Name: d3d.cxx
*
* Contains all of GDI's private Direct3D APIs.
*
* Created: 04-Jun-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Minimum size of DrawPrimitive buffer associated with a context.
#define MIN_PRIM_BUFFER_SIZE (1 << 14)
// Maximum
#define MAX_PRIM_BUFFER_SIZE (1 << 20)
// Default
#define DEF_PRIM_BUFFER_SIZE (1 << 16)

// Alignment requirement for the DrawPrim buffer.  Must be a power of two.
#define DP_BUFFER_ALIGN 32

// Maximum number of vertices considered legal.
#define MAX_VERTEX_COUNT 0x10000

// Maximum number of indices considered legal.
#define MAX_INDEX_COUNT 0x80000

// Maximum number of clear rectangles considered legal.
#define MAX_CLEAR_RECTS 0x1000

// Maximum number of state changes per RenderState call
#define MAX_STATE_CHANGE (D3DRENDERSTATE_STIPPLEPATTERN31+1)

#ifdef D3D_ENTRIES
#define D3D_ENTRY(s) WARNING(s)
#else
#define D3D_ENTRY(s)
#endif

// Simple structure for managing DD surfaces
struct D3D_SURFACE
{
    HANDLE h;
    BOOL bOptional;
    EDD_SURFACE* peSurf;
    PDD_SURFACE_LOCAL pLcl;
};


#define INIT_D3DSURFACE(SurfaceArray, Count) \
    for (int i = 0 ; i < (Count) ; i++) { \
        (SurfaceArray)[i].peSurf = NULL; \
    }

#define CLEANUP_D3DSURFACE(SurfaceArray, Count) \
    for (int i = 0 ; i < (Count) ; i++) { \
        if ((SurfaceArray)[i].peSurf) { \
            DEC_EXCLUSIVE_REF_CNT((SurfaceArray)[i].peSurf); \
        } \
    }

// Convenience macro for parameter validation.  ProbeForWrite does
// all the checks that ProbeForRead does in addition to write testing
// so it serves as a read/write check.
// Assumes DWORD alignment.

#define CAPTURE_RW_STRUCT(ptr, type) \
    (ProbeForWrite(ptr, sizeof(type), sizeof(DWORD)), *(ptr))
#define CAPTURE_RD_STRUCT(ptr, type) \
    (ProbeForRead(ptr, sizeof(type), sizeof(DWORD)), *(ptr))

/******************************Public*Routine******************************\
*
* D3dLockSurfaces
*
* Walks the array of surfaces, locking any with non-zero handles
*
* This routine must be called with the HmgrSemaphore acquired
*
* History:
*  Fri Jun 14 14:26:06 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL D3dLockSurfaces(int n, D3D_SURFACE *pSurf)
{
    while (n-- > 0)
    {
        if (pSurf->h != NULL)
        {
            pSurf->peSurf = (EDD_SURFACE *)DdHmgLock((HDD_OBJ)pSurf->h, DD_SURFACE_TYPE, TRUE);

            if (pSurf->peSurf == NULL)
            {
                WARNING("D3dLockSurfaces unable to lock buffer");
                return FALSE;
            }
            if (pSurf->peSurf->bLost)
            {   
                DEC_EXCLUSIVE_REF_CNT(pSurf->peSurf);
                WARNING("D3dLockSurfaces unable to lock buffer Surface is Lost");
                return FALSE;
            }

            pSurf->pLcl = pSurf->peSurf;
        }
        else if (!pSurf->bOptional)
        {
            WARNING("D3dLockSurfaces: NULL for mandatory surface");
            return FALSE;
        }
        else
        {
            pSurf->pLcl = NULL;
        }

        pSurf++;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
*
* D3dSetup
*
* Prepares the system for a call to a D3D driver
*
* History:
*  Tue Jun 04 17:09:23 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL D3dSetup(EDD_DIRECTDRAW_GLOBAL* peDdGlobal,
              KFLOATING_SAVE* pfsState)
{
    ASSERTGDI(peDdGlobal != NULL,
              "D3dSetup on NULL global\n");

    if (!NT_SUCCESS(KeSaveFloatingPointState(pfsState)))
    {
        WARNING("D3dSetup: Unable to save FP state\n");
        return FALSE;
    }

    DxEngLockHdev(peDdGlobal->hdev);

    return TRUE;
}

/******************************Public*Routine******************************\
*
* D3dCleanup
*
* Cleans up after a D3D driver calls
*
* History:
*  Tue Jun 04 17:10:21 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void D3dCleanup(EDD_DIRECTDRAW_GLOBAL* peDdGlobal,
                KFLOATING_SAVE* pfsState)
{
    DxEngUnlockHdev(peDdGlobal->hdev);
    KeRestoreFloatingPointState(pfsState);
}

/******************************Public*Routine******************************\
*
* D3dLockContext
*
* Prepares the system for a call to a D3D driver with a driver context
*
* This routine must be called with the HmgrSemaphore acquired
*
* History:
*  Tue Jun 04 17:09:23 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

D3DNTHAL_CONTEXT *D3dLockContext(KFLOATING_SAVE *pfsState,
                                  ULONG_PTR *pdwhContext)
{
    D3DNTHAL_CONTEXT *pdhctx;

    pdhctx = (D3DNTHAL_CONTEXT *)DdHmgLock((HDD_OBJ)*pdwhContext, D3D_HANDLE_TYPE, TRUE);
    DdHmgReleaseHmgrSemaphore();

    if (pdhctx == NULL)
    {
        WARNING("D3dLockContext unable to lock context");
        return NULL;
    }

    if (pdhctx->dwType != DNHO_CONTEXT)
    {
        WARNING("D3dLockContext: Valid handle not a context");
        return NULL;
    }

    // Before we access inside D3DCONTEXT.peDdGlobal, hold shared devlock,
    // since peDdGlobal can be changed during video mode change.

    DxEngLockShareSem();

    if (pdhctx->peDdGlobal == NULL)
    {
        WARNING("D3dLockContext: Call on disabled object");
        DxEngUnlockShareSem();
        return NULL;
    }
    
    ASSERTGDI(pdhctx->peDdGlobal->Miscellaneous2CallBacks.CreateSurfaceEx,
              "D3dLockContext: No CreateSurfaceEx callback");

    if (D3dSetup(pdhctx->peDdGlobal, pfsState))
    {
        *pdwhContext = pdhctx->dwDriver;
        // keep holding share lock, will be released at D3dUnlockContext. 
        return pdhctx;
    }
    else
    {
        DxEngUnlockShareSem();
        return NULL;
    }
}

/******************************Public*Routine******************************\
*
* D3dCleanup
*
* Cleans up after a D3D driver calls with D3D context
*
* History:
*  Tue Apr 10 16:15:00 2001 -by-    Hideyuki Nagase [hideyukn]
*   Created
*
\**************************************************************************/

VOID D3dUnlockContext(D3DNTHAL_CONTEXT *pdhctx, KFLOATING_SAVE *pfsState)
{
    //
    // Release devlock, and restore floating point state.
    //
    D3dCleanup(pdhctx->peDdGlobal, pfsState);

    //
    // Release share devlock.
    //
    DxEngUnlockShareSem();
}

/******************************Public*Routine******************************\
*
* D3dAddContextObject
*
* Adds a context-related object to the context's reverse lookup table.
*
* History:
*  Thu Oct 24 12:03:32 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void D3dAddContextObject(D3DNTHAL_CONTEXT *pdhctx, D3DNTHAL_OBJECT *pdhobj)
{
    DWORD dwKey;

    dwKey = DNHO_HASH_KEY(pdhobj->dwDriver);
    pdhobj->pdhobj = pdhctx->pdhobjHash[dwKey];
    pdhctx->pdhobjHash[dwKey] = pdhobj;
}

/******************************Public*Routine******************************\
*
* D3dRemoveContextObject
*
* Removes a context-related object from the context's reverse lookup table.
*
* History:
*  Thu Oct 24 12:05:49 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

D3DNTHAL_OBJECT *D3dRemoveContextObject(D3DNTHAL_CONTEXT *pdhctx,
                                        ULONG_PTR dwDriver)
{
    D3DNTHAL_OBJECT *pdhobjPrev, *pdhobj;
    DWORD dwKey;

    dwKey = DNHO_HASH_KEY(dwDriver);
    pdhobjPrev = NULL;
    pdhobj = pdhctx->pdhobjHash[dwKey];
    while (pdhobj != NULL)
    {
        if (pdhobj->dwDriver == dwDriver)
        {
            // Remove from hash table
            if (pdhobjPrev == NULL)
            {
                pdhctx->pdhobjHash[dwKey] = pdhobj->pdhobj;
            }
            else
            {
                pdhobjPrev->pdhobj = pdhobj->pdhobj;
            }

            return pdhobj;
        }

        pdhobjPrev = pdhobj;
        pdhobj = pdhobj->pdhobj;
    }

    return NULL;
}

/******************************Public*Routine******************************\
*
* D3dDeleteHandle
*
* Cleans up D3D driver context wrapper objects
*
* History:
*  Tue Jun 11 17:42:25 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD D3dDeleteHandle(HANDLE hD3dHandle, ULONG_PTR dwContext,
                      BOOL *pbRemoved, HRESULT *phr)
{
    D3DNTHAL_OBJECT  *pdhobj;
    D3DNTHAL_CONTEXT *pdhctx;
    D3DNTHAL_CONTEXTDESTROYDATA dcdd;
    D3DNTHAL_TEXTUREDESTROYDATA dtdd;
    KFLOATING_SAVE fsState;
    DWORD dwRet = DDHAL_DRIVER_HANDLED;

    // Lock handle first.

    pdhobj = (D3DNTHAL_OBJECT *) DdHmgLock((HDD_OBJ)hD3dHandle, D3D_HANDLE_TYPE, FALSE);

    if (pdhobj == NULL)
    {
        if (pbRemoved != NULL)
        {
            *pbRemoved = FALSE;
        }

        *phr = DDERR_INVALIDOBJECT;
        return (dwRet);
    }

    // Before we access inside D3DCONTEXT.peDdGlobal, hold shared devlock,
    // since peDdGlobal can be changed during video mode change.

    DxEngLockShareSem();

    // Sundowndx: Needs to pass in cjBuffer as SIZE_T inorder to compiler in 64bit

    SIZE_T cjBuffer = 0;

    if (!D3dSetup(pdhobj->peDdGlobal, &fsState))
    {
        DxEngUnlockShareSem();
        *phr = DDERR_OUTOFMEMORY;
        return (dwRet);
    }

    switch(pdhobj->dwType)
    {
    case DNHO_CONTEXT:

        // Clean up DrawPrimitive buffer.

        pdhctx = (D3DNTHAL_CONTEXT *)pdhobj;
        MmUnsecureVirtualMemory(pdhctx->hBufSecure);
        ZwFreeVirtualMemory(NtCurrentProcess(), &pdhctx->pvBufferAlloc,
                            &cjBuffer, MEM_RELEASE);

        // Sundowndx: need to look at the d3d structure, truncate it for now

        pdhctx->cjBuffer = (ULONG)cjBuffer;

        // Call driver.

        dcdd.dwhContext = pdhobj->dwDriver;
        dwRet = pdhobj->peDdGlobal->D3dCallBacks.ContextDestroy(&dcdd);
        *phr = dcdd.ddrval;
        break;

    case DNHO_TEXTURE:

        dtdd.dwhContext = dwContext;
        dtdd.dwHandle = pdhobj->dwDriver;
        dwRet = pdhobj->peDdGlobal->D3dCallBacks.TextureDestroy(&dtdd);
        *phr = dtdd.ddrval;
        break;
    }

    // Now Remove handle from handle manager.

    PVOID pv = DdHmgRemoveObject((HDD_OBJ)hD3dHandle, 1, 0, TRUE, D3D_HANDLE_TYPE);

    // This shouldn't fail, because above DdHmgLock is succeeded.

    ASSERTGDI(pv,"DdHmgRemoveObject failed D3dDeleteHandle");

    // Release devlock and restore floating point state.

    D3dCleanup(pdhobj->peDdGlobal, &fsState);

    // Release share lock

    DxEngUnlockShareSem();

    // If this is last reference to DdGlobal (= GDI's PDEV), this
    // will release it, so we can't call it while devlock is hold (which
    // means between D3dSetup ~ D3dCleanup).

    vDdDecrementReferenceCount(pdhobj->peDdGlobal);

    // Delete the object.

    DdFreeObject(pdhobj, D3D_HANDLE_TYPE);

    if (pbRemoved != NULL)
    {
        *pbRemoved = TRUE;
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* D3D_SIMPLE_COPY_WITH_CONTEXT
*
* Macro which creates a thunk function for D3D entry points which
* have only simple copy arguments in, a context to dereference and
* only a simple copy out.
*
* D3D_SIMPLE_DECL can be defined to add declarations.
* By default it's empty.
* D3D_SIMPLE_SETUP can be defined to add more setup code.
* By default it's empty.
* D3D_SIMPLE_WRITEBACK can be defined to add more writeback code.
* By default it's empty.
* D3D_SIMPLE_CALLBACKS is defined to the callbacks structure to look in.
* By default it's D3dCallBacks.
*
* History:
*  Fri Jun 14 14:12:54 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define D3D_SIMPLE_DECL
#define D3D_SIMPLE_SETUP
#define D3D_SIMPLE_WRITEBACK
#define D3D_SIMPLE_CALLBACKS D3dCallBacks

#define D3D_SIMPLE_COPY_WITH_CONTEXT(Name, Type)                           \
DWORD APIENTRY                                                             \
DxD3d##Name(LPD3DNTHAL_##Type##DATA pdata)                                 \
{                                                                          \
    D3DNTHAL_##Type##DATA data;                                            \
    KFLOATING_SAVE fsState;                                                \
    DWORD dwRet;                                                           \
    D3DNTHAL_CONTEXT* pdhctx;                                              \
    D3D_SIMPLE_DECL                                                        \
                                                                           \
    D3D_ENTRY("DxD3d" #Name);                                              \
                                                                           \
    dwRet = DDHAL_DRIVER_NOTHANDLED;                                       \
                                                                           \
    __try                                                                  \
    {                                                                      \
        data = CAPTURE_RW_STRUCT(pdata, D3DNTHAL_##Type##DATA);            \
    }                                                                      \
    __except(EXCEPTION_EXECUTE_HANDLER)                                    \
    {                                                                      \
        WARNING("DxD3d" #Name " unable to access argument");               \
        return dwRet;                                                      \
    }                                                                      \
                                                                           \
    DdHmgAcquireHmgrSemaphore();                                           \
    pdhctx = D3dLockContext(&fsState, &data.dwhContext);                   \
    if (pdhctx == NULL)                                                    \
    {                                                                      \
        return dwRet;                                                      \
    }                                                                      \
                                                                           \
    D3D_SIMPLE_SETUP                                                       \
                                                                           \
    if (pdhctx->peDdGlobal->bSuspended)                                    \
    {                                                                      \
        data.ddrval = DDERR_SURFACELOST;                                   \
    }                                                                      \
    else                                                                   \
    {                                                                      \
        if (pdhctx->peDdGlobal->D3D_SIMPLE_CALLBACKS.##Name)               \
        {                                                                  \
            dwRet = pdhctx->peDdGlobal->D3D_SIMPLE_CALLBACKS.##Name(&data);\
        }                                                                  \
        else                                                               \
        {                                                                  \
            WARNING("DxD3d" #Name " call not present!");                   \
        }                                                                  \
    }                                                                      \
                                                                           \
    D3dUnlockContext(pdhctx, &fsState);                                    \
                                                                           \
    __try                                                                  \
    {                                                                      \
        pdata->ddrval = data.ddrval;                                       \
        D3D_SIMPLE_WRITEBACK                                               \
    }                                                                      \
    __except(EXCEPTION_EXECUTE_HANDLER)                                    \
    {                                                                      \
        WARNING("DxD3d" #Name " unable to write back arguments");          \
    }                                                                      \
                                                                           \
    DEC_EXCLUSIVE_REF_CNT(pdhctx);                                         \
    return dwRet;                                                          \
}

/******************************Public*Routine******************************\
*
* D3D_DELETE_HANDLE
*
* Macro for routines which destroy a handle-managed object.
*
* History:
*  Wed Oct 23 19:32:11 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define D3D_DELETE_HANDLE(Name, Type, Field)                               \
DWORD APIENTRY                                                             \
DxD3d##Name##Destroy(LPD3DNTHAL_##Type##DESTROYDATA pdata)                 \
{                                                                          \
    DWORD dwRet;                                                           \
    HANDLE hD3dHandle;                                                     \
    HRESULT hr;                                                            \
                                                                           \
    D3D_ENTRY("DxD3d" #Name "Destroy");                                    \
                                                                           \
    __try                                                                  \
    {                                                                      \
        ProbeForWrite(pdata, sizeof(D3DNTHAL_##Type##DESTROYDATA),         \
                      sizeof(DWORD));                                      \
        hD3dHandle = (HANDLE)pdata->Field;                                 \
    }                                                                      \
    __except(EXCEPTION_EXECUTE_HANDLER)                                    \
    {                                                                      \
        WARNING("DxD3d" #Name "Destroy unable to access argument");        \
        return DDHAL_DRIVER_NOTHANDLED;                                    \
    }                                                                      \
                                                                           \
    dwRet = D3dDeleteHandle(hD3dHandle, 0, (BOOL *)NULL, &hr);             \
                                                                           \
    __try                                                                  \
    {                                                                      \
        pdata->ddrval = hr;                                                \
    }                                                                      \
    __except(EXCEPTION_EXECUTE_HANDLER)                                    \
    {                                                                      \
        WARNING("DxD3d" #Name "Destroy unable to write back arguments");   \
    }                                                                      \
                                                                           \
    return dwRet;                                                          \
}

/******************************Public*Routine******************************\
*
* DxD3dContextCreate
*
* History:
*  Tue Jun 04 13:05:18 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY
DxD3dContextCreate(HANDLE hDirectDrawLocal,
                      HANDLE hSurfColor,
                      HANDLE hSurfZ,
                      D3DNTHAL_CONTEXTCREATEI *pdcci)
{
    LPD3DNTHAL_CONTEXTCREATEDATA pdccd;
    D3DNTHAL_CONTEXTCREATEDATA dccd;
    KFLOATING_SAVE fsState;
    DWORD dwRet;
    D3DNTHAL_CONTEXT *pdhctx;
    HANDLE hCleanup = 0;
    EDD_DIRECTDRAW_LOCAL* peDdLocal;
    EDD_LOCK_DIRECTDRAW eLockDd;
    EDD_DIRECTDRAW_GLOBAL* peDdGlobal;
    D3D_SURFACE dsurf[2];
    NTSTATUS nts;
    SIZE_T cjBuffer;
    PVOID pvBuffer = NULL;
    PVOID pvBufRet = NULL;
    HANDLE hBufSecure = 0;
    ULONG_PTR Interface;

    D3D_ENTRY("DxD3dContextCreate");

    ASSERTGDI(FIELD_OFFSET(D3DNTHAL_CONTEXTCREATEI, pvBuffer) ==
              sizeof(D3DNTHAL_CONTEXTCREATEDATA),
              "D3DNTHAL_CONTEXTCREATEI out of sync\n");
    pdccd = (LPD3DNTHAL_CONTEXTCREATEDATA)pdcci;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    __try
    {
        ProbeForWrite(pdcci, sizeof(D3DNTHAL_CONTEXTCREATEI), sizeof(DWORD));
        dccd.dwPID = pdccd->dwPID;
        dccd.dwhContext = pdccd->dwhContext;
        dccd.ddrval = pdccd->ddrval;
        cjBuffer = pdcci->cjBuffer;
        Interface = pdccd->dwhContext;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dContextCreate unable to access argument");
        return dwRet;
    }

    if (cjBuffer == 0)
    {
        cjBuffer = DEF_PRIM_BUFFER_SIZE;
    }
    else if (cjBuffer < MIN_PRIM_BUFFER_SIZE ||
             cjBuffer > MAX_PRIM_BUFFER_SIZE)
    {
        WARNING("DxD3dContextCreate: illegal prim buffer size");
        return dwRet;
    }

    peDdLocal = eLockDd.peLock(hDirectDrawLocal);

    if (peDdLocal == NULL)
    {
        WARNING("DxD3dContextCreate unable to lock hDdLocal");
        return dwRet;
    }

    peDdGlobal = peDdLocal->peDirectDrawGlobal;

    INIT_D3DSURFACE(dsurf, 2);
    dsurf[0].h = hSurfColor;
    dsurf[0].bOptional = FALSE;
    dsurf[1].h = hSurfZ;
    dsurf[1].bOptional = TRUE;
    DdHmgAcquireHmgrSemaphore();
    if (!D3dLockSurfaces(2, dsurf))
    {
        DdHmgReleaseHmgrSemaphore();
        return dwRet;
    }

    DdHmgReleaseHmgrSemaphore();

    pdhctx = (D3DNTHAL_CONTEXT *)DdHmgAlloc(sizeof(D3DNTHAL_CONTEXT),
                                          D3D_HANDLE_TYPE, HMGR_ALLOC_LOCK);
    if (pdhctx == NULL)
    {
        CLEANUP_D3DSURFACE(dsurf, 2);
        WARNING("DxD3dContextCreate unable to alloc handle");
        return dwRet;
    }
    hCleanup = pdhctx->hHmgr;

    // Allocate and lock DrawPrimitive buffer space.  We want the
    // buffer to be aligned on a large boundary so we alter the
    // pointer to return to be aligned.  Note that we do not overallocate
    // since we don't want the extra alignment space to push the allocation
    // into another page.  We're returning a size anyway so we can
    // get away with this transparently.

    nts = ZwAllocateVirtualMemory(NtCurrentProcess(), &pvBuffer,
                                  0, &cjBuffer, MEM_COMMIT | MEM_RESERVE,
                                  PAGE_READWRITE);
    if (!NT_SUCCESS(nts))
    {
        goto EH_Exit;
    }

    hBufSecure = MmSecureVirtualMemory(pvBuffer, cjBuffer, PAGE_READWRITE);
    if (hBufSecure == 0)
    {
        goto EH_Exit;
    }

    if (!D3dSetup(peDdGlobal, &fsState))
    {
        goto EH_Exit;
    }

    // CreateSurfaceEx callback must exist for DX7 or greater drivers

    if (!peDdGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
    {
        D3dCleanup(peDdGlobal, &fsState);
        goto EH_Exit;
    }
    dccd.lpDDLcl = peDdLocal;

    dccd.lpDDS = dsurf[0].pLcl;
    dccd.lpDDSZ = dsurf[1].pLcl;

    if (peDdGlobal->D3dCallBacks.ContextCreate)
    {
        dwRet = peDdGlobal->D3dCallBacks.ContextCreate(&dccd);
    }
    else
    {
        WARNING("DxD3dContextCreate: ContextCreate callback not found");
    }
    
    if (dwRet == DDHAL_DRIVER_HANDLED &&
        dccd.ddrval == DD_OK)
    {
        // Create a wrapper for the handle and stash the DD global in it
        pdhctx->dwType = DNHO_CONTEXT;
        pdhctx->dwDriver = dccd.dwhContext;
        pdhctx->peDdGlobal = peDdGlobal;
        pdhctx->peDdLocal  = peDdLocal;
        pdhctx->hSurfColor = hSurfColor;
        pdhctx->hSurfZ = hSurfZ;
        pdhctx->hBufSecure = hBufSecure;

        // Save the real pointer for freeing and return an aligned pointer
        // rather than the raw pointer.
        pdhctx->pvBufferAlloc = pvBuffer;
        pvBufRet = (PVOID)(((ULONG_PTR)pvBuffer+DP_BUFFER_ALIGN-1) &
                           ~(DP_BUFFER_ALIGN-1));
        pdhctx->pvBufferAligned = pvBufRet;
        pdhctx->cjBuffer = (ULONG)cjBuffer;
        // Subtract off any space used for alignment.
        cjBuffer -= (DWORD)((ULONG_PTR)pvBufRet-(ULONG_PTR)pvBuffer);

        // Save interface number
        pdhctx->Interface = Interface;

        // Null these values to deactivate cleanup code.
        hBufSecure = 0;
        pvBuffer = NULL;
        dccd.dwhContext = (ULONG_PTR)pdhctx->hHmgr;
        hCleanup = 0;

        /* Add reference to DirectDraw driver instance so that it won't
           go away during dynamic mode changes, until the object is
           deleted. */
        vDdIncrementReferenceCount(pdhctx->peDdGlobal);
    }

    // We're done with pdhctx so unlock it
    DEC_EXCLUSIVE_REF_CNT(pdhctx);

    D3dCleanup(peDdGlobal, &fsState);

    __try
    {
        pdccd->dwhContext = dccd.dwhContext;
        pdccd->ddrval = dccd.ddrval;
        pdcci->pvBuffer = pvBufRet;
        pdcci->cjBuffer = (ULONG)cjBuffer;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dContextCreate unable to write back arguments");
        /* This is an unlikely thing to occur so we don't bother cleaning
           up the handle here.  It will be cleaned up by the process
           termination handle cleanup. */
        dwRet = DDHAL_DRIVER_NOTHANDLED;
    }

EH_Exit:
    CLEANUP_D3DSURFACE(dsurf, 2);

    if (hBufSecure != 0)
    {
        MmUnsecureVirtualMemory(hBufSecure);
    }

    if (pvBuffer != NULL)
    {
        // cjBuffer has to be zero to free memory.
        cjBuffer = 0;
        ZwFreeVirtualMemory(NtCurrentProcess(), &pvBuffer, &cjBuffer,
                            MEM_RELEASE);
    }

    if (hCleanup != 0)
    {
        DdHmgFree((HDD_OBJ)hCleanup);
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* DxD3dContextDestroy
*
* History:
*  Tue Jun 04 13:08:43 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

D3D_DELETE_HANDLE(Context, CONTEXT, dwhContext)

/******************************Public*Routine******************************\
*
* DxD3dContextDestroyAll
*
* History:
*  Tue Jun 04 13:09:04 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY
DxD3dContextDestroyAll(LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad)
{
    DWORD dwRet;

    D3D_ENTRY("DxD3dContextDestroyAll");

    __try
    {
        ProbeForWrite(pdcdad, sizeof(D3DNTHAL_CONTEXTDESTROYALLDATA),
              sizeof(DWORD));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dContextDestroyAll unable to access argument");
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // Having the context wrappers be handle-based should
    // provide automatic process cleanup of driver contexts
    // If this function does need to be passed to the driver then
    // some way to get the proper DD global will need to be found
    // I don't think it's necessary, though

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    __try
    {
        pdcdad->ddrval = DDERR_GENERIC;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dContextDestroyAll unable to write back arguments");
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* DxD3dDrawPrimitives2
*
* History:
*  Fri Jun 14 11:56:53 1996 -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD APIENTRY
DxD3dDrawPrimitives2(HANDLE hCmdBuf, HANDLE hVBuf,
                        LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
                        FLATPTR* pfpVidMemCmd,
                        DWORD* pdwSizeCmd,
                        FLATPTR* pfpVidMemVtx,
                        DWORD* pdwSizeVtx)
{
    D3DNTHAL_DRAWPRIMITIVES2DATA ded;
    KFLOATING_SAVE fsState;
    DWORD dwRet;
    D3DNTHAL_CONTEXT *pdhctx;
    D3D_SURFACE dsurf[4];
    HANDLE hSecure;

    D3D_ENTRY("DxD3dDrawPrimitives2");

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    __try
    {
        //
        // ProbeForRead and ProbeForWrite are fairly expensive.  Moved the write probe
        // to the bottom but we could also do a ProbeForWriteStructure here if the
        // error checking needs to be the exact same semantics.
        //
        ded = ProbeAndReadStructure(pded, D3DNTHAL_DRAWPRIMITIVES2DATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dDrawPrimitives2 unable to access argument");
        return dwRet;
    }

    DWORD Length = ded.dwVertexLength*ded.dwVertexSize;

    // Validate and secure user-mode memory if it is a user
    // allocated buffer instead of a ddraw surface

    if (ded.dwFlags & D3DNTHALDP2_USERMEMVERTICES)
    {
        // !!Assert here that hVBuf is NULL
        ASSERTGDI(hVBuf == NULL,
                  "User allocated memory, hVBuf should be NULL\n");

        if ((Length > 0) && (ded.lpVertices != NULL))
        {
            LPVOID Address = (LPVOID) ((LPBYTE)ded.lpVertices +
                                          ded.dwVertexOffset);

            // Secure user-mode data.

            __try
            {
                ProbeForRead(Address, Length, sizeof(BYTE));
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("DxD3dDrawPrimives2 fail to secure the vertex buffer");
                return dwRet;
            }

            hSecure = MmSecureVirtualMemory(Address, Length, PAGE_READONLY);
            if (hSecure == NULL)
            {
                return dwRet;
            }

            INIT_D3DSURFACE(dsurf, 4);
            dsurf[0].h = hCmdBuf;
            dsurf[0].bOptional = FALSE;
            DdHmgAcquireHmgrSemaphore();
            if (!D3dLockSurfaces(1, dsurf))
            {
                DdHmgReleaseHmgrSemaphore();
                goto EH_Unsecure;
            }
            ded.lpDDCommands = dsurf[0].pLcl;
        }
        else
        {
            return dwRet;
        }
    }
    else
    {
        INIT_D3DSURFACE(dsurf, 4);
        dsurf[0].h = hCmdBuf;
        dsurf[0].bOptional = FALSE;
        dsurf[1].h = hVBuf;
        dsurf[1].bOptional = FALSE;
        DdHmgAcquireHmgrSemaphore();
        if (!D3dLockSurfaces(2, dsurf))
        {
            DdHmgReleaseHmgrSemaphore();
            return dwRet;
        }
        ded.lpDDCommands = dsurf[0].pLcl;
        ded.lpDDVertex = dsurf[1].pLcl;

        // Make sure given buffer size is smaller than the actual surface size.

        if (dsurf[1].peSurf && ded.dwVertexSize)
        {
            DWORD dwSurfaceSize = dsurf[1].peSurf->lPitch;

            if (Length > dwSurfaceSize)
            {
                WARNING("DxD3dDrawPrimitive2 d3d.dwVertexLength is bigger than surface, trim it!!");

                ded.dwVertexLength = dwSurfaceSize / ded.dwVertexSize;
            }
        }
    }

    pdhctx = D3dLockContext(&fsState, &ded.dwhContext);
    if (pdhctx == NULL)
    {
        goto EH_Unsecure;
    }

    // Validate that the lpdwRStates pointer is the same as the one allocated
    // by the kernel during context create. The D3d runtime uses this pointer
    // to receive state information from the driver.

    if (ded.lpdwRStates != pdhctx->pvBufferAligned)
    {
        D3dUnlockContext(pdhctx, &fsState);
        goto EH_Unsecure;
    }

    if ((pdhctx->peDdGlobal->bSuspended) ||
        ((pdhctx->peDdLocal->cSurface != pdhctx->peDdLocal->cActiveSurface) &&
        // We wish we could do this for all interfaces, but due to legacy app compat reasons, we can't.
        // We have noticed that apps such as Dungeon Keeper II and Final Fantasy lose surfaces and
        // never bother to restore them.
         pdhctx->Interface >= 4))
    {
#if DBG
        if (pdhctx->peDdGlobal->bSuspended)
        {
            // WARNING("D3dDrawPrimitives2" Caller uses disabled device");
        }
        else if ((pdhctx->peDdLocal->cSurface != pdhctx->peDdLocal->cActiveSurface)) 
        {
            WARNING("D3dDrawPrimitives2: Cannot call driver when lost surfaces exist in the context");
        }
#endif
        dwRet = DDHAL_DRIVER_HANDLED;
        ded.ddrval = DDERR_SURFACELOST;
    }
    else
    {
        if (pdhctx->peDdGlobal->D3dCallBacks3.DrawPrimitives2)
        {
            dwRet = pdhctx->peDdGlobal->D3dCallBacks3.DrawPrimitives2(&ded);
        }
        else
        {
            WARNING("DxD3dDrawPrimitives2: DrawPrimitives2 callback absent!");
        }
    }

    __try
    {
        if ((dwRet == DDHAL_DRIVER_HANDLED) && (ded.ddrval == DD_OK))
        {
            if (ded.dwFlags & D3DNTHALDP2_SWAPCOMMANDBUFFER)
            {
                ProbeAndWriteStructure( pfpVidMemCmd, ded.lpDDCommands->lpGbl->fpVidMem, FLATPTR); 
                ProbeAndWriteStructure( pdwSizeCmd, ded.lpDDCommands->lpGbl->dwLinearSize, DWORD);  
            }
            if ((ded.dwFlags & D3DNTHALDP2_SWAPVERTEXBUFFER) && 
                !(ded.dwFlags & D3DNTHALDP2_USERMEMVERTICES))
            {
                ProbeAndWriteStructure( pfpVidMemVtx, ded.lpDDVertex->lpGbl->fpVidMem, FLATPTR); 
                ProbeAndWriteStructure( pdwSizeVtx, ded.lpDDVertex->lpGbl->dwLinearSize, DWORD);  
            }
        }
        ProbeAndWriteUlong(&pded->dwErrorOffset, ded.dwErrorOffset);
        //
        // Should be cleaned up as HRESULT might not allways be a ULONG
        //
        ProbeAndWriteLong(&pded->ddrval, ded.ddrval);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxD3dDrawPrimitives2 unable to write back arguments");
        dwRet = DDHAL_DRIVER_NOTHANDLED;
    }

    D3dUnlockContext(pdhctx, &fsState);

EH_Unsecure:

    CLEANUP_D3DSURFACE(dsurf, 4);

    if (pdhctx)
    {
        DEC_EXCLUSIVE_REF_CNT(pdhctx);
    }

    if (ded.dwFlags & D3DNTHALDP2_USERMEMVERTICES)
    {
        MmUnsecureVirtualMemory(hSecure);
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* DxD3dValidateTextureStageState
*
\**************************************************************************/

#undef  D3D_SIMPLE_WRITEBACK
#define D3D_SIMPLE_WRITEBACK pdata->dwNumPasses = data.dwNumPasses;
#undef  D3D_SIMPLE_CALLBACKS
#define D3D_SIMPLE_CALLBACKS D3dCallBacks3
D3D_SIMPLE_COPY_WITH_CONTEXT(ValidateTextureStageState, VALIDATETEXTURESTAGESTATE)
#undef  D3D_SIMPLE_WRITEBACK
#define D3D_SIMPLE_WRITEBACK
#undef  D3D_SIMPLE_CALLBACKS
#define D3D_SIMPLE_CALLBACKS D3dCallBacks

/******************************Public*Routine******************************\
*
* D3DParseUnknownCommand
*
\**************************************************************************/

HRESULT CALLBACK D3DParseUnknownCommand (LPVOID lpvCommands,
                              LPVOID *lplpvReturnedCommand)
{
    LPD3DINSTRUCTION lpInstr = (LPD3DINSTRUCTION) lpvCommands;
    LPD3DPROCESSVERTICES data;
    int i;

    // Initialize the return address to the command's address
    *lplpvReturnedCommand = lpvCommands;

    switch (lpInstr->bOpcode)
    {
    case D3DOP_SPAN:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof (D3DINSTRUCTION) +
                                          lpInstr->wCount *
                                          lpInstr->bSize);                   
        return DD_OK;
    case D3DNTDP2OP_VIEWPORTINFO:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof(D3DINSTRUCTION) +
                                          lpInstr->wCount *
                                          sizeof(D3DNTHAL_DP2VIEWPORTINFO));
        return DD_OK;
    case D3DNTDP2OP_WINFO:
        *lplpvReturnedCommand = (LPVOID) ((LPBYTE)lpInstr +
                                          sizeof(D3DINSTRUCTION) +
                                          lpInstr->wCount *
                                          sizeof(D3DNTHAL_DP2WINFO));
        return DD_OK;
    case D3DOP_PROCESSVERTICES:
    case D3DOP_MATRIXLOAD:
    case D3DOP_MATRIXMULTIPLY:
    case D3DOP_STATETRANSFORM:
    case D3DOP_STATELIGHT:
    case D3DOP_TEXTURELOAD:
    case D3DOP_BRANCHFORWARD:
    case D3DOP_SETSTATUS:
    case D3DOP_EXIT:
        return D3DNTERR_COMMAND_UNPARSED;
    default:
        return DDERR_GENERIC;
    }
}

/******************************Public*Routine******************************\
*
* DxDdGetDriverState
*
\**************************************************************************/

DWORD APIENTRY
DxDdGetDriverState(PDD_GETDRIVERSTATEDATA pdata)
{
    DD_GETDRIVERSTATEDATA data;
    KFLOATING_SAVE fsState;
    DWORD dwRet;
    D3DNTHAL_CONTEXT* pdhctx;
    HANDLE hSecure;

    D3D_ENTRY("DxDdGetDriverState");

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    __try
    {
        data = CAPTURE_RW_STRUCT(pdata, DD_GETDRIVERSTATEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxDdGetDriverState unable to access argument");
        return dwRet;
    }

    if (data.lpdwStates == NULL)
    {
        WARNING("DxDdGetDriverState passed null lpdwStates");
        return dwRet;
    }

    // Secure the usermode memory passed down to collect state data
    hSecure = MmSecureVirtualMemory((LPVOID)data.lpdwStates, data.dwLength, 
                                    PAGE_READONLY);
    if (hSecure == 0)
    {
        return dwRet;
    }
    
    DdHmgAcquireHmgrSemaphore();
    pdhctx = D3dLockContext(&fsState, &data.dwhContext);
    if (pdhctx == NULL)
    {
        goto EH_Unsecure;
    }

    // No additional validation is needed
    // Assuming that GetDriverState exists in all DX7+ drivers

    ASSERTGDI(pdhctx->peDdGlobal->Miscellaneous2CallBacks.GetDriverState != NULL,
              "DxDdGetDriverState is not present. It is not an optional callback\n");

    if (pdhctx->peDdGlobal->bSuspended)
    {
        data.ddRVal = DDERR_GENERIC;
    }
    else
    {
        if (pdhctx->peDdGlobal->Miscellaneous2CallBacks.GetDriverState)
        {
            dwRet = pdhctx->peDdGlobal->Miscellaneous2CallBacks.GetDriverState(&data);
        }
        else
        {
            WARNING("DxD3dDrawPrimitives2: GetDriverState callback absent!");
        }
    }
    
    D3dUnlockContext(pdhctx, &fsState);

    __try
    {
        pdata->ddRVal = data.ddRVal;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DxDdGetDriverState unable to write back arguments");
    }

EH_Unsecure:
    DEC_EXCLUSIVE_REF_CNT(pdhctx);
    MmUnsecureVirtualMemory(hSecure);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddheap.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.h
 *  Content:	Heap manager header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDHEAP_INCLUDED__
#define __DDHEAP_INCLUDED__

#include "dmemmgr.h"

BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end );
void linVidMemFini( LPVMEMHEAP pvmh );
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch );
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh );
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh );
    
BOOL rectVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, DWORD width, DWORD height,
                     DWORD stride );
void rectVidMemFini( LPVMEMHEAP pvmh );
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment );
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh );

BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 );

#define DDHA_SKIPRECTANGULARHEAPS       0x0001
#define DDHA_ALLOWNONLOCALMEMORY        0x0002
#define DDHA_ALLOWNONLOCALTEXTURES      0x0004
#define DDHA_USEALTCAPS                 0x0008

FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize);

LPVMEMHEAP WINAPI VidMemInit( DWORD flags, FLATPTR start, FLATPTR end_or_width,
                              DWORD height, DWORD pitch );
void WINAPI VidMemFini( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh );
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh );

LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem, DWORD pitch, HANDLE hdev,
                                  LPHEAPALIGNMENT phad);
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev );
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize );

FLATPTR WINAPI DdHeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch );
void WINAPI    DdHeapVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

DWORD GetHeapSizeInPages(LPVIDMEM lpVidMem, LONG pitch);
VOID CleanupAgpCommits(LPVIDMEM lpVidMem, HANDLE hdev, EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal, int iHeapIndex);
void SwapHeaps(LPVIDMEM pOldVidMem, LPVIDMEM pNewVidMem);

#endif // __DDHEAP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddheap.cxx ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheap.c
 *  Content:    Top-level heap routines.
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   06-dec-94  craige  initial implementation
 *   06-jan-95  craige  integrated into DDRAW
 *   20-mar-95  craige  prepare for rectangular memory manager
 *   27-mar-95  craige  linear or rectangular vidmem
 *   01-apr-95  craige  happy fun joy updated header file
 *   06-apr-95  craige  fill in free video memory
 *   15-may-95  craige  made separate VMEM struct for rect & linear
 *   10-jun-95  craige  exported fns
 *   02-jul-95  craige  fail if VidMemInit if linear or rect. fail;
 *                      removed linFindMemBlock
 *   17-jul-95  craige  added VidMemLargestFree
 *   01-dec-95  colinmc added VidMemAmountAllocated
 *   11-dec-95  kylej   added VidMemGetRectStride
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   03-Feb-98  DrewB   Made portable between user and kernel.
 *
 ***************************************************************************/

#include "precomp.hxx"


/*
 * VidMemInit - initialize video memory manager heap
 */
LPVMEMHEAP WINAPI VidMemInit(
		DWORD   flags,
		FLATPTR start,
		FLATPTR width_or_end,
		DWORD   height,
		DWORD   pitch )
{
    LPVMEMHEAP  pvmh;

    pvmh = (LPVMEMHEAP)MemAlloc( sizeof( VMEMHEAP ) );
    if( pvmh == NULL )
    {
	return NULL;
    }
    pvmh->dwFlags = flags;
    ZeroMemory( & pvmh->Alignment.ddsCaps, sizeof(pvmh->Alignment.ddsCaps) );

    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	if( !linVidMemInit( pvmh, start, width_or_end ) )
	{
	    MemFree( pvmh );
	    return NULL;
	}
    }
    else
    {
	if( !rectVidMemInit( pvmh, start, (DWORD) width_or_end, height,
                             pitch ) )
	{
	    MemFree( pvmh );
	    return NULL;
	}
    }
    return pvmh;

} /* VidMemInit */

/*
 * VidMemFini - done with video memory manager
 */
void WINAPI VidMemFini( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	linVidMemFini( pvmh );
    }
    else
    {
	rectVidMemFini( pvmh );
    }

} /* VidMemFini */

/*
 * InternalVidMemAlloc - alloc some flat video memory and give us back the size
 * we allocated
 */
FLATPTR WINAPI InternalVidMemAlloc( LPVMEMHEAP pvmh, DWORD x, DWORD y,
                                    LPDWORD lpdwSize,
                                    LPSURFACEALIGNMENT lpAlignment,
                                    LPLONG lpNewPitch )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAlloc( pvmh, x, y, lpdwSize, lpAlignment, lpNewPitch );
    }
    else
    {
	FLATPTR lp = rectVidMemAlloc( pvmh, x, y, lpdwSize, lpAlignment );
        if (lp && lpNewPitch )
        {
            *lpNewPitch = (LONG) pvmh->stride;
        }
        return lp;
    }
    return (FLATPTR) NULL;

} /* InternalVidMemAlloc */

/*
 * VidMemAlloc - alloc some flat video memory
 */
FLATPTR WINAPI VidMemAlloc( LPVMEMHEAP pvmh, DWORD x, DWORD y )
{
    DWORD dwSize;

    /*
     * We are not interested in the size here.
     */
    return InternalVidMemAlloc( pvmh, x, y, &dwSize , NULL , NULL );
} /* VidMemAlloc */

/*
 * DxDdHeapVidMemFree = free some flat video memory
 */
void WINAPI DxDdHeapVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	linVidMemFree( pvmh, ptr );
    }
    else
    {
	rectVidMemFree( pvmh, ptr );
    }

} /* VidMemFree */

/*
 * VidMemAmountAllocated
 */
DWORD WINAPI VidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAmountAllocated( pvmh );
    }
    else
    {
	return rectVidMemAmountAllocated( pvmh );
    }
 
} /* VidMemAmountAllocated */

/*
 * VidMemAmountFree
 */
DWORD WINAPI VidMemAmountFree( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemAmountFree( pvmh );
    }
    else
    {
	return rectVidMemAmountFree( pvmh );
    }
 
} /* VidMemAmountFree */

/*
 * VidMemLargestFree
 */
DWORD WINAPI VidMemLargestFree( LPVMEMHEAP pvmh )
{
    if( pvmh->dwFlags & VMEMHEAP_LINEAR )
    {
	return linVidMemLargestFree( pvmh );
    }
    else
    {
	return 0;
    }

} /* VidMemLargestFree */

/*
 * HeapVidMemInit
 *
 * Top level heap initialization code which handles AGP stuff.
 */
LPVMEMHEAP WINAPI HeapVidMemInit( LPVIDMEM lpVidMem,
		                  DWORD    pitch,
		                  HANDLE   hdev,
                                  LPHEAPALIGNMENT pgad)
{
    DWORD         dwSize;

    DDASSERT( NULL != lpVidMem );

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        /*
         * We do not actually call AGPReserve at this time since that would
         * mean calling it each time a mode change occurred.  Insted, we defer
         * this until later when we call InitAgpHeap.
         */

        /*
         * Compute the size of the heap.
         */
        if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
        {
            dwSize = (DWORD)(lpVidMem->fpEnd - lpVidMem->fpStart) + 1UL;
        }
        else
        {
            DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
            dwSize = (pitch * lpVidMem->dwHeight);
        }
        DDASSERT( 0UL != dwSize );

        /*
         * Update the heap for the new start address
         * (and end address for a linear heap).
         */
        lpVidMem->fpStart = 0;
        if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
        {
            lpVidMem->fpEnd = dwSize - 1UL;
        }
        else
        {
            DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
            DDASSERT( pitch );
            lpVidMem->dwHeight = dwSize / pitch;
        }
    }

    if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
    {
	VDPF(( 1,V, "VidMemInit: Linear:      fpStart = 0x%08x fpEnd = 0x%08x",
	     lpVidMem->fpStart, lpVidMem->fpEnd ));
	lpVidMem->lpHeap = VidMemInit( VMEMHEAP_LINEAR, lpVidMem->fpStart,
                                       lpVidMem->fpEnd, 0, 0 );
    }
    else
    {
        // We have no way of testing a rectangular AGP heap, so I'm disabling
        // it for now.
        
        if( !( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL ) )
        {
	    VDPF(( 1,V, "VidMemInit: Rectangular: fpStart = 0x%08x "
                   "dwWidth = %ld dwHeight = %ld, pitch = %ld",
	         lpVidMem->fpStart, lpVidMem->dwWidth, lpVidMem->dwHeight,
                   pitch  ));
	    lpVidMem->lpHeap = VidMemInit( VMEMHEAP_RECTANGULAR, lpVidMem->fpStart,
				           lpVidMem->dwWidth, lpVidMem->dwHeight,
                                           pitch );
        }
    }

    /*
     * Modify the caps and alt-caps so that you don't allocate local
     * video memory surfaces out of AGP memory and vice-verse.
     */
    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
	/*
	 * Its an AGP heap. So don't let explict LOCAL video memory
	 * be allocated out of this heap.
	 */
	lpVidMem->ddsCaps.dwCaps    |= DDSCAPS_LOCALVIDMEM;
	lpVidMem->ddsCapsAlt.dwCaps |= DDSCAPS_LOCALVIDMEM;
    }
    else
    {
	/*
	 * Its a local video memory heap. So don't let explicity NON-LOCAL
	 * video memory be allocated out of this heap.
	 */
	lpVidMem->ddsCaps.dwCaps    |= DDSCAPS_NONLOCALVIDMEM;
	lpVidMem->ddsCapsAlt.dwCaps |= DDSCAPS_NONLOCALVIDMEM;
    }

    /*
     * Copy any extended alignment data into the private heap structure
     */
    if ( lpVidMem->lpHeap )
    {
        if ( pgad )
        {
            lpVidMem->lpHeap->dwFlags |= VMEMHEAP_ALIGNMENT;
            lpVidMem->lpHeap->Alignment = *pgad;
            VDPF((5,V,"Extended alignment turned on for this heap."));
            VDPF((6,V,"Alignments are turned on for:"));
            VDPF((6,V,"  %08X",pgad->ddsCaps));
        }
        else
        {
            /*
             * This means the allocation routines will do no alignment modifications
             */
            VDPF((5,V,"Extended alignment turned OFF for this heap."));
            lpVidMem->lpHeap->dwFlags &= ~VMEMHEAP_ALIGNMENT;
        }
    }

    return lpVidMem->lpHeap;
} /* HeapVidMemInit */

/*
 * HeapVidMemFini
 *
 * Top level heap release code. Handle AGP stuff
 */
void WINAPI HeapVidMemFini( LPVIDMEM lpVidMem, HANDLE hdev )
{
    DWORD dwCommittedSize = 0UL;
    PVOID pvReservation;
    BYTE* pAgpCommitMask = NULL;
    DWORD dwAgpCommitMaskSize;
    DWORD dwTotalSize;

    /*
     * Remember how much memory we committed to the AGP heap.
     */
    DDASSERT( NULL != lpVidMem->lpHeap );
    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        dwCommittedSize = lpVidMem->lpHeap->dwCommitedSize;
        pvReservation = lpVidMem->lpHeap->pvPhysRsrv;
        pAgpCommitMask = lpVidMem->lpHeap->pAgpCommitMask;
        dwAgpCommitMaskSize = lpVidMem->lpHeap->dwAgpCommitMaskSize;
        dwTotalSize = lpVidMem->lpHeap->dwTotalSize;
    }

    /*
     * Free the memory manager
     */
    VidMemFini( lpVidMem->lpHeap );
    lpVidMem->lpHeap = NULL;

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        BOOL fSuccess = TRUE;
        
        /*
         * If this is a non-local (AGP) heap then decommit and
         * free the GART memory now.
         */
        if( ( 0UL != dwCommittedSize ) &&
            ( pAgpCommitMask != NULL ) )
        {
            DWORD dwTemp;

            /*
             * Only decommit if we actually bothered to commit something
             * in the first place.
             */
            fSuccess = AGPDecommitAll( hdev, pvReservation, 
                                       pAgpCommitMask, 
                                       dwAgpCommitMaskSize,
                                       &dwTemp,
                                       dwTotalSize);

            /*
             * Should never fail and not much we can do if it does apart
             * from assert that something bad is happening.
             */
            DDASSERT( fSuccess );
        }

        if( pAgpCommitMask != NULL ) 
        {
            VFREEMEM(pAgpCommitMask);
        }

        if( pvReservation != NULL )
        {
            fSuccess = AGPFree( hdev, pvReservation );
        }

        /*
         * Again this should only fail if the OS is in an unstable state
         * or if I have screwed up (sadly the later is all too likely)
         * so assert.
         */
        DDASSERT( fSuccess );
    }   
} /* HeapVidMemFini */

/*
 * This is an external entry point which can be used by drivers to allocate 
 * aligned surfaces.
 */
FLATPTR WINAPI DxDdHeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch )
{
    HANDLE  hdev;
    FLATPTR ptr;
    DWORD   dwSize;


    if ( lpVidMem == NULL ||
         lpVidMem->lpHeap == NULL ||
         (lpVidMem->dwFlags & VIDMEM_HEAPDISABLED))
    {
	return (FLATPTR) NULL;
    }

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        if( lpVidMem->lpHeap->pvPhysRsrv == NULL )
        {
            LPVIDMEM    pHeap;
            DWORD       dwHeap;

            // If we haven't yet initialized the AGP heap, then we will
            // do so now.  This could be dangerous since initializing the
            // heap causes the driver to get re-entered by the 
            // UpdateNonLocalVidMemHeap call.

            EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal = 
                (EDD_DIRECTDRAW_GLOBAL*) OsGetAGPDeviceHandle(lpVidMem->lpHeap);

            pHeap = peDirectDrawGlobal->pvmList;
            for (dwHeap = 0;
                dwHeap < peDirectDrawGlobal->dwNumHeaps;
                pHeap++, dwHeap++)
            {
                if( pHeap == lpVidMem )
                {
                    break;
                }
            }

            if( dwHeap < peDirectDrawGlobal->dwNumHeaps )
            {
                InitAgpHeap( peDirectDrawGlobal,
                             dwHeap,
                             (HANDLE) peDirectDrawGlobal );
            }

            if( ( lpVidMem->lpHeap->pvPhysRsrv == NULL ) ||
                ( lpVidMem->dwFlags & VIDMEM_HEAPDISABLED ) )
            {
                return (FLATPTR) NULL;
            }
        }

        /*
         * As we may need to commit AGP memory we need a device handle
         * to communicate with the AGP controller. Rather than hunting
         * through the driver object list hoping we will find a
         * local object for this process we just create a handle
         * and discard it after the allocation. This should not be
         * performance critical code to start with.
         */
        hdev = OsGetAGPDeviceHandle(lpVidMem->lpHeap);
        if (hdev == NULL)
        {
            return 0;
        }
    }
    else
    {
        hdev = NULL;
    }

    /* Pass NULL Alignment and new pitch pointer */
    ptr = HeapVidMemAlloc( lpVidMem, dwWidth, dwHeight,
                           hdev, lpAlignment, lpNewPitch, &dwSize );

    if( hdev != NULL )
    {
        OsCloseAGPDeviceHandle( hdev );
    }

    return ptr; 
}

/*
 * HeapVidMemAlloc
 *
 * Top level video memory allocation function. Handles AGP stuff
 */
FLATPTR WINAPI HeapVidMemAlloc( LPVIDMEM lpVidMem, DWORD x, DWORD y,
                                HANDLE hdev, LPSURFACEALIGNMENT lpAlignment,
                                LPLONG lpNewPitch, LPDWORD pdwSize )
{
    FLATPTR fpMem;
    DWORD   dwSize;

    DDASSERT( NULL != lpVidMem );
    DDASSERT( NULL != lpVidMem->lpHeap );

    /*
     * Validate the reserved and flags fields of the alignment structure
     */
    if( lpAlignment )
    {
        if( ( lpAlignment->Linear.dwReserved2 != 0 ) ||
            ( lpAlignment->Linear.dwFlags & ~( SURFACEALIGN_DISCARDABLE ) ) )
        {
            return NULL;
        }
    }

    if( ( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL ) &&
        ( lpVidMem->lpHeap->pvPhysRsrv == NULL ) )
    {
        return NULL;
    }

    fpMem = InternalVidMemAlloc( lpVidMem->lpHeap, x, y, &dwSize,
                                 lpAlignment, lpNewPitch );
    if( 0UL == fpMem )
    {
	return fpMem;
    }

    if( lpVidMem->dwFlags & VIDMEM_ISNONLOCAL )
    {
        DWORD dwCommittedSize;
        BOOL  fSuccess;
        DWORD dwOffset;

        dwOffset = (DWORD)(fpMem - lpVidMem->fpStart);

        /*
         * Okay, we have the offset and the size we need to commit. So ask
         * the OS to commit memory to that portion of this previously
         * reserved GART range.
         */
        fSuccess = AGPCommit( hdev, lpVidMem->lpHeap->pvPhysRsrv,
                              dwOffset, dwSize, 
                              lpVidMem->lpHeap->pAgpCommitMask,
                              &dwCommittedSize,
                              lpVidMem->lpHeap->dwTotalSize );
        if( !fSuccess )
        {
            /*
             * Couldn't commit. Must be out of memory.
             * Put the allocated memory back and fail.
             */
            DxDdHeapVidMemFree( lpVidMem->lpHeap, fpMem );
            return (FLATPTR) NULL;
        }
        lpVidMem->lpHeap->dwCommitedSize += dwCommittedSize;

        /*
         * Now we need to vitually commit the memory for all of the
         * DirectDrawLocals that we have.  This is because some drivers
         * (nvidia) allocate a single buffer and then hand out pointers
         * into that buffer to multimple processes.
         */
        EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal = 
            (EDD_DIRECTDRAW_GLOBAL*) OsGetAGPDeviceHandle(lpVidMem->lpHeap);
        EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal; 
        LPVIDMEM    pHeap;
        DWORD       dwHeap;

        pHeap = peDirectDrawGlobal->pvmList;
        for (dwHeap = 0;
            dwHeap < peDirectDrawGlobal->dwNumHeaps;
            pHeap++, dwHeap++)
        {
            if( pHeap == lpVidMem )
            {
                break;
            }
        }
        if( dwHeap < peDirectDrawGlobal->dwNumHeaps )
        {
            peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
            while( ( peDirectDrawLocal != NULL ) && fSuccess )
            {
                if( !( peDirectDrawLocal->fl & DD_LOCAL_DISABLED ) )
                {
                    fSuccess = AGPCommitVirtual( peDirectDrawLocal,
                                                 lpVidMem,
                                                 dwHeap,
                                                 dwOffset,
                                                 dwSize);
                }
                peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext;
            }
        }
        else
        {
            fSuccess = FALSE;
        }
        if( !fSuccess )
        {
            /*
             * Something went wrong on the virtual commit, so fail the allocation.
             */
            DxDdHeapVidMemFree( lpVidMem->lpHeap, fpMem );
            return (FLATPTR) NULL;
        }
    }

    if (pdwSize != NULL)
    {
        *pdwSize = dwSize;
    }
    
    return fpMem;
} /* HeapVidMemAlloc */

/*
 * IsDifferentPixelFormat
 *
 * determine if two pixel formats are the same or not
 *
 * (CMcC) 12/14/95 Really useful - so no longer static
 *
 * This function really shouldn't be in a heap file but it's
 * needed by both the user and kernel code so this is a convenient
 * place to put it to have it shared.
 */
BOOL IsDifferentPixelFormat( LPDDPIXELFORMAT pdpf1, LPDDPIXELFORMAT pdpf2 )
{
    /*
     * same flags?
     */
    if( pdpf1->dwFlags != pdpf2->dwFlags )
    {
	VDPF(( 8, S, "Flags differ!" ));
	return TRUE;
    }

    /*
     * same bitcount for non-YUV surfaces?
     */
    if( !(pdpf1->dwFlags & (DDPF_YUV | DDPF_FOURCC)) )
    {
	if( pdpf1->dwRGBBitCount != pdpf2->dwRGBBitCount )
	{
	    VDPF(( 8, S, "RGB Bitcount differs!" ));
	    return TRUE;
	}
    }

    /*
     * same RGB properties?
     */
    if( pdpf1->dwFlags & DDPF_RGB )
    {
	if( pdpf1->dwRBitMask != pdpf2->dwRBitMask )
	{
	    VDPF(( 8, S, "RBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwGBitMask != pdpf2->dwGBitMask )
	{
	    VDPF(( 8, S, "GBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwBBitMask != pdpf2->dwBBitMask )
	{
	    VDPF(( 8, S, "BBitMask differs!" ));
	    return TRUE;
	}
	if( pdpf1->dwRGBAlphaBitMask != pdpf2->dwRGBAlphaBitMask )
	{
	    VDPF(( 8, S, "RGBAlphaBitMask differs!" ));
	    return TRUE;
	}
    }

    /*
     * same YUV properties?
     */
    if( pdpf1->dwFlags & DDPF_YUV )
    {
	VDPF(( 8, S, "YUV???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVBitCount != pdpf2->dwYUVBitCount )
	{
	    return TRUE;
	}
	if( pdpf1->dwYBitMask != pdpf2->dwYBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwUBitMask != pdpf2->dwUBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwVBitMask != pdpf2->dwVBitMask )
	{
	    return TRUE;
	}
	if( pdpf1->dwYUVAlphaBitMask != pdpf2->dwYUVAlphaBitMask )
	{
	    return TRUE;
	}
    }

    /*
     * Possible to use FOURCCs w/o setting the DDPF_YUV flag
     * ScottM 7/11/96
     */
    else if( pdpf1->dwFlags & DDPF_FOURCC )
    {
	VDPF(( 8, S, "FOURCC???" ));
	if( pdpf1->dwFourCC != pdpf2->dwFourCC )
	{
	    return TRUE;
	}
    }

    /*
     *	If Interleaved Z then check Z bit masks are the same
     */
    if( pdpf1->dwFlags & DDPF_ZPIXELS )
    {
	VDPF(( 8, S, "ZPIXELS???" ));
	if( pdpf1->dwRGBZBitMask != pdpf2->dwRGBZBitMask )
	    return TRUE;
    }

    return FALSE;

} /* IsDifferentPixelFormat */

/*
 * SurfaceCapsToAlignment
 *
 * Return a pointer to the appropriate alignment element in a VMEMHEAP
 * structure given surface caps.
 *
 */
LPSURFACEALIGNMENT SurfaceCapsToAlignment(
    LPVIDMEM			lpVidmem ,
    LPDDRAWI_DDRAWSURFACE_LCL	lpSurfaceLcl,
    LPVIDMEMINFO                lpVidMemInfo)
{
    LPVMEMHEAP			lpHeap;
    LPDDSCAPS			lpCaps;
    LPDDRAWI_DDRAWSURFACE_GBL	lpSurfaceGbl;

    DDASSERT( lpVidmem );
    DDASSERT( lpSurfaceLcl );
    DDASSERT( lpVidMemInfo );
    DDASSERT( lpVidmem->lpHeap );

    if ( !lpVidmem->lpHeap )
        return NULL;

    lpCaps = &lpSurfaceLcl->ddsCaps;
    lpHeap = lpVidmem->lpHeap;
    lpSurfaceGbl = lpSurfaceLcl->lpGbl;

    if ( (lpHeap->dwFlags & VMEMHEAP_ALIGNMENT) == 0 )
        return NULL;

    if ( lpCaps->dwCaps & DDSCAPS_EXECUTEBUFFER )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER )
        {
            VDPF((6,V,"Aligning surface as execute buffer"));
            return & lpHeap->Alignment.ExecuteBuffer;
        }
        /*
         * If the surface is an execute buffer, then no other
         * alignment can apply
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_OVERLAY )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_OVERLAY )
        {
            VDPF((6,V,"Aligning surface as overlay"));
            return & lpHeap->Alignment.Overlay;
        }
        /*
         * If the surface is an overlay, then no other alignment can apply
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_TEXTURE )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_TEXTURE )
        {
            VDPF((6,V,"Aligning surface as texture"));
            return & lpHeap->Alignment.Texture;
        }
        /*
         * If it's a texture, it can't be an offscreen or any of the others
         */
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_ZBUFFER )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_ZBUFFER )
        {
            VDPF((6,V,"Aligning surface as Z buffer"));
            return & lpHeap->Alignment.ZBuffer;
        }
        return NULL;
    }

    if ( lpCaps->dwCaps & DDSCAPS_ALPHA )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_ALPHA )
        {
            VDPF((6,V,"Aligning surface as alpha buffer"));
            return & lpHeap->Alignment.AlphaBuffer;
        }
        return NULL;
    }

    /*
     * We need to give a surface which may potentially become a back buffer
     * the alignment which is reserved for potentially visible back buffers.
     * This includes any surface which has made it through the above checks
     * and has the same dimensions as the primary.
     * Note we check only the dimensions of the primary. There's an outside
     * chance that an app could create its back buffer before it creates
     * the primary
     */
    do
    {
	if ( lpSurfaceLcl->dwFlags & DDRAWISURF_HASPIXELFORMAT )
	{
	    if (IsDifferentPixelFormat( &lpVidMemInfo->ddpfDisplay,
                                        &lpSurfaceGbl->ddpfSurface ))
	    {
		/*
		 * Different pixel format from primary means this surface
                 * cannot be part of primary chain
		 */
		break;
	    }

	}

	if ( (DWORD)lpSurfaceGbl->wWidth != lpVidMemInfo->dwDisplayWidth )
	    break;

	if ( (DWORD)lpSurfaceGbl->wHeight != lpVidMemInfo->dwDisplayHeight )
	    break;


	/*
	 * This surface could potentially be part of primary chain.
         * It has the same
	 * pixel format as the primary and the same dimensions.
	 */
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_FLIP )
        {
            VDPF((6,V,"Aligning surface as potential primary surface"));
            return & lpHeap->Alignment.FlipTarget;
        }

	/*
	 * Drop through and check for offscreen if driver specified no
         * part-of-primary-chain alignment
	 */
	break;
    } while (0);

    if ( lpCaps->dwCaps & DDSCAPS_OFFSCREENPLAIN )
    {
        if ( lpHeap->Alignment.ddsCaps.dwCaps & DDSCAPS_OFFSCREENPLAIN )
        {
            VDPF((6,V,"Aligning surface as offscreen plain"));
            return & lpHeap->Alignment.Offscreen;
        }
    }

    VDPF((6,V,"No extended alignment for surface"));
    return NULL;
}

/*
 * DdHeapAlloc
 *
 * Search all heaps for one that has space and the appropriate
 * caps for the requested surface type and size.
 *
 * We AND the caps bits required and the caps bits not allowed
 * by the video memory.   If the result is zero, it is OK.
 *
 * This is called in 2 passes.   Pass1 is the preferred memory state,
 * pass2 is the "oh no no memory" state.
 *
 * On pass1, we use ddsCaps in the VIDMEM struct.
 * On pass2, we use ddsCapsAlt in the VIDMEM struct.
 *
 */
FLATPTR DdHeapAlloc( DWORD dwNumHeaps,
                     LPVIDMEM pvmHeaps,
                     HANDLE hdev,
                     LPVIDMEMINFO lpVidMemInfo,
                     DWORD dwWidth,
                     DWORD dwHeight,
                     LPDDRAWI_DDRAWSURFACE_LCL lpSurfaceLcl,
                     DWORD dwFlags,
                     LPVIDMEM *ppvmHeap,
                     LPLONG plNewPitch,
                     LPDWORD pdwNewCaps,
                     LPDWORD pdwSize)
{
    LPVIDMEM	pvm;
    DWORD	vm_caps;
    int		i;
    FLATPTR	pvidmem;
    HANDLE      hvxd;
    LPDDSCAPS	lpCaps;

    LPDDSCAPSEX lpExtendedRestrictions;
    LPDDSCAPSEX lpExtendedCaps;

    DDASSERT( NULL != pdwNewCaps );
    DDASSERT( NULL != lpSurfaceLcl );

    lpCaps = &lpSurfaceLcl->ddsCaps;
    lpExtendedCaps = &lpSurfaceLcl->lpSurfMore->ddsCapsEx;

    for( i = 0 ; i < (int)dwNumHeaps ; i++ )
    {
	pvm = &pvmHeaps[i];

        // Skip disabled heaps.
        if (pvm->dwFlags & VIDMEM_HEAPDISABLED)
        {
            continue;
        }
        
        /*
         * Skip rectangular heaps if we were told to.
         */
        if (dwFlags & DDHA_SKIPRECTANGULARHEAPS)
        {
            if (pvm->dwFlags & VIDMEM_ISRECTANGULAR)
            {
                continue;
            }
        }

	/*
	 * If local or non-local video memory has been explicity
	 * specified then ignore heaps which don't match the required
	 * memory type.
	 */
	if( ( lpCaps->dwCaps & DDSCAPS_LOCALVIDMEM ) &&
            ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
	{
	    VDPF(( 4, V, "Local video memory was requested but heap is "
                   "non local. Ignoring heap %d", i ));
	    continue;
	}

	if( ( lpCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
            !( pvm->dwFlags & VIDMEM_ISNONLOCAL ) )
	{
	    VDPF(( 4, V, "Non-local video memory was requested but "
                   "heap is local. Ignoring heap %d", i ));
	    continue;
	}

	if( !( lpCaps->dwCaps & DDSCAPS_NONLOCALVIDMEM ) &&
	     ( pvm->dwFlags & VIDMEM_ISNONLOCAL ) &&
             ( dwFlags & DDHA_ALLOWNONLOCALMEMORY ) )
	{
            /*
             * We can allow textures to fail over to DMA model cards
             * if the card exposes an appropriate heap. This won't
             * affect cards which can't texture from nonlocal, because
             * they won't expose such a heap. This mod doesn't affect
             * execute model because all surfaces fail over to nonlocal
             * for them.
             * Note that we should only fail over to nonlocal if the
             * surface wasn't explicitly requested in local. There is a
             * clause a few lines up which guarantees this.
             */
            if ( !(lpCaps->dwCaps & DDSCAPS_TEXTURE) )
            {
	        VDPF(( 4, V, "Non-local memory not explicitly requested "
                       "for non-texture surface. Ignoring non-local heap %d",
                       i ));
	        continue;
            }

            /*
             * If the device can't texture out of AGP, we need to fail this
             * heap, since the app is probably expecting to texture out of
             * this surface.
             */
            if ( !(dwFlags & DDHA_ALLOWNONLOCALTEXTURES) )
            {
                continue;
            }
	}

	if( dwFlags & DDHA_USEALTCAPS )
	{
	    vm_caps = pvm->ddsCapsAlt.dwCaps;
            lpExtendedRestrictions = &(pvm->lpHeap->ddsCapsExAlt);
	}
	else
	{
	    vm_caps = pvm->ddsCaps.dwCaps;
            lpExtendedRestrictions = &(pvm->lpHeap->ddsCapsEx);
	}
        
	if( ((lpCaps->dwCaps & vm_caps) == 0) &&
            ((lpExtendedRestrictions->dwCaps2 & lpExtendedCaps->dwCaps2) == 0) &&
            ((lpExtendedRestrictions->dwCaps3 & lpExtendedCaps->dwCaps3) == 0) &&
            ((lpExtendedRestrictions->dwCaps4 & lpExtendedCaps->dwCaps4) == 0))
	{
	    pvidmem = HeapVidMemAlloc(
		pvm,
                dwWidth,
		dwHeight,
		hdev,
		SurfaceCapsToAlignment(pvm, lpSurfaceLcl, lpVidMemInfo),
		plNewPitch,
                pdwSize);

	    if( pvidmem != (FLATPTR) NULL )
	    {
		*ppvmHeap = pvm;

		if( pvm->dwFlags & VIDMEM_ISNONLOCAL )
		    *pdwNewCaps |= DDSCAPS_NONLOCALVIDMEM;
		else
		    *pdwNewCaps |= DDSCAPS_LOCALVIDMEM;
		return pvidmem;
	    }
	}
    }
    return (FLATPTR) NULL;

} /* DdHeapAlloc */

/*
 * GetHeapSizeInPages
 *
 * This is called to determine how much memory should be allocated
 * for the commit mask.  Initially the mask had an entry for each page,
 * so it returned the number of pages in the heap, but the commit mask now has
 * a bit for each 16 page chunk, so we now return the number of chunks in the
 * heap.
 */
DWORD GetHeapSizeInPages(LPVIDMEM lpVidMem, LONG pitch)
{
    DWORD dwSize;

    if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
    {
        dwSize = (DWORD)(lpVidMem->fpEnd - lpVidMem->fpStart) + 1UL;
    }
    else
    {
        DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
        dwSize = (pitch * lpVidMem->dwHeight);
    }
    return AGPGetChunkCount(dwSize);
}

/*
 * CleanupAgpCommits
 *
 * Some drivers leave outstanding allocates after an app exits so that we
 * cannot completely cleanup the AGP heap, so what this function does is
 * decommit as much of the physical AGP memory as it can.  To do this, it
 * determines what memory is still allocated and then decommits everything
 * esle.
 */
VOID CleanupAgpCommits(LPVIDMEM lpVidMem, HANDLE hdev, EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal, int iHeapIndex)
{
    BYTE*   pGoodCommits;
    BYTE*   pAgpCommitMask;
    BYTE*   pVirtCommitMask;
    BYTE*   pTempMask;
    DWORD   dwAgpCommitMaskSize;
    DWORD   i;
    DWORD   dwOffset;
    DWORD   dwSize;
    DWORD   dwDecommittedSize;
    EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal; 
    EDD_VMEMMAPPING*      peMap;

    if( ( lpVidMem->lpHeap == NULL ) ||
        ( lpVidMem->lpHeap->pAgpCommitMask == NULL ) ||
        ( lpVidMem->lpHeap->dwAgpCommitMaskSize == 0 ) ||
        ( lpVidMem->lpHeap->dwCommitedSize == 0 ) ||
        ( lpVidMem->lpHeap->pvPhysRsrv == NULL ) )
    {
        return;
    }
    pAgpCommitMask = lpVidMem->lpHeap->pAgpCommitMask;
    dwAgpCommitMaskSize = lpVidMem->lpHeap->dwAgpCommitMaskSize; 

    pGoodCommits = (BYTE*) PALLOCMEM(dwAgpCommitMaskSize,
                      'pddG');
    if( pGoodCommits == NULL )
    {
        return;
    }
    pVirtCommitMask = (BYTE*) PALLOCMEM(dwAgpCommitMaskSize,
                      'pddG');
    if( pVirtCommitMask == NULL )
    {
        VFREEMEM(pGoodCommits);
        return;
    }

    /*
     * Walk the alloc list and build the list of all the pages that should
     * be committed.
     */
    if( lpVidMem->lpHeap->dwFlags & VMEMHEAP_LINEAR )
    {
        LPVMEML pAlloc = (LPVMEML) lpVidMem->lpHeap->allocList;

        while( pAlloc != NULL )
        {
            dwOffset = (DWORD)(pAlloc->ptr - lpVidMem->fpStart);
            dwSize = pAlloc->size;

            AGPUpdateCommitMask( pGoodCommits, dwOffset, dwSize, lpVidMem->lpHeap->dwTotalSize );

            pAlloc = pAlloc->next;
        }
    }
    else
    {
        LPVMEMR pAlloc = (LPVMEMR) lpVidMem->lpHeap->allocList;

        /*
         * This is a circular list where the end of the list is denoted by
         * a node containing a sentinel value of 0x7fffffff
         */
        while(( pAlloc != NULL ) &&
              ( pAlloc->size != 0x7fffffff ))
        {
            dwOffset = (DWORD)(pAlloc->ptr - lpVidMem->fpStart);
            dwSize = (lpVidMem->lpHeap->stride * 
                (pAlloc->cy - 1)) + pAlloc->cx;

            AGPUpdateCommitMask( pGoodCommits, dwOffset, dwSize, lpVidMem->lpHeap->dwTotalSize );

            pAlloc = pAlloc->next;
        }
    }

    /*
     * Check here to verify that every page that we think should be committed
     * actually is committed.
     */
#if DBG
    {
        BYTE    bit;
        DWORD   dwPage;
        DWORD   dwNumPages;

        bit = 1;
        dwNumPages = dwAgpCommitMaskSize * BITS_IN_BYTE;
        dwPage = 0;
        while( dwPage < dwNumPages )
        {
            ASSERTGDI(!((!(pAgpCommitMask[dwPage/BITS_IN_BYTE] & bit)&&(pGoodCommits[dwPage/BITS_IN_BYTE] & bit))),
                "Page not commited when we think it should be!");

            if( bit == 0x80 )  
            {                   
                bit = 1;        
            }                   
            else                
            {                   
                bit <<= 1;      
            }
            dwPage++;
        }
    }
#endif

    /*
     * Now build a list of pages that are committed but that don't need to be.
     * To save space, we will re-use pAgpCommitMask for this purpose.
     */
    for( i = 0; i < dwAgpCommitMaskSize; i++ )
    {
        pAgpCommitMask[i] ^= pGoodCommits[i];
    }

    /*
     * We don't want to physically decommit the memory w/o first virtually
     * decommitting it for each processs.
     */
    peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
    while( peDirectDrawLocal != NULL )
    {
        if (peDirectDrawLocal->ppeMapAgp != NULL)
        {
            peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
            if ((peMap != NULL) && !(peDirectDrawLocal->fl & DD_LOCAL_DISABLED))
            {
                // Replace the committed mask with the mask that we want to decommit

                ASSERTGDI((dwAgpCommitMaskSize == peMap->dwAgpVirtualCommitMaskSize) ,
                    "Virtual AGP mask size does not equal physical mask size");

                memcpy( pVirtCommitMask, pAgpCommitMask, dwAgpCommitMaskSize );
                pTempMask = peMap->pAgpVirtualCommitMask;
                peMap->pAgpVirtualCommitMask = pVirtCommitMask;

                // pVirtCommitMask now contains all of the pages that are
                // physically committed but that don't need to be, but that
                // doesn't mean that these are virtually commited, so we AND
                // out the pages that are not virtually committed.

                for( i = 0; i < dwAgpCommitMaskSize; i++ )
                {
                    pVirtCommitMask[i] &= pTempMask[i];
                }
                
                AGPDecommitVirtual( peMap,
                                    peDirectDrawLocal->peDirectDrawGlobal,
                                    peDirectDrawLocal,
                                    lpVidMem->lpHeap->dwTotalSize); 

                // pTempMask contains all of the pages that used to be virtually
                // committed but are not neccessarily committed now.  pGoodCommits
                // contains all of the physical pages that need to kept, so ANDing
                // them will give us the pages that are currently committed.

                peMap->pAgpVirtualCommitMask = pTempMask;
                for( i = 0; i < dwAgpCommitMaskSize; i++ )
                {
                    pTempMask[i] &= pGoodCommits[i];
                }
            }
        }
        peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext;
    }

    AGPDecommitAll( hdev, 
                    lpVidMem->lpHeap->pvPhysRsrv, 
                    pAgpCommitMask, 
                    dwAgpCommitMaskSize,
                    &dwDecommittedSize,
                    lpVidMem->lpHeap->dwTotalSize);
    lpVidMem->lpHeap->dwCommitedSize -= dwDecommittedSize;
    memcpy( pAgpCommitMask, pGoodCommits, dwAgpCommitMaskSize );
    VFREEMEM(pGoodCommits);
    VFREEMEM(pVirtCommitMask);
}

/*
 * SwapHeaps
 *
 * During a mode change, we create a new heap and copy it over the old heap.
 * For AGP heaps, however, we really only want one instance of the heap 
 * active at any given time, so the new heap is not fully initialized.  This
 * means that we just swapped our good heap with a abd one, which means that
 * we need to selectively swap certain elements of the heap back.
 */
void SwapHeaps( LPVIDMEM pOldVidMem, LPVIDMEM pNewVidMem )
{
    LPVMEMHEAP      pOldHeap = pOldVidMem->lpHeap;
    LPVMEMHEAP      pNewHeap = pNewVidMem->lpHeap;
    FLATPTR         fpTemp;
    DWORD           dwTemp;
    LPVOID          pvTemp;
    LARGE_INTEGER   liTemp;

    fpTemp = pOldVidMem->fpStart;
    pOldVidMem->fpStart = pNewVidMem->fpStart;
    pNewVidMem->fpStart = fpTemp;

    fpTemp = pOldVidMem->fpEnd;
    pOldVidMem->fpEnd = pNewVidMem->fpEnd;
    pNewVidMem->fpEnd = fpTemp;

    dwTemp = pOldHeap->stride;
    pOldHeap->stride = pNewHeap->stride;
    pNewHeap->stride = dwTemp;

    pvTemp = pOldHeap->freeList;
    pOldHeap->freeList = pNewHeap->freeList;
    pNewHeap->freeList = pvTemp;

    pvTemp = pOldHeap->allocList;
    pOldHeap->allocList = pNewHeap->allocList;
    pNewHeap->allocList = pvTemp;

    pOldHeap->dwTotalSize = min(pOldHeap->dwTotalSize,pNewHeap->dwTotalSize);
    
    fpTemp = pOldHeap->fpGARTLin;
    pOldHeap->fpGARTLin = pNewHeap->fpGARTLin;
    pNewHeap->fpGARTLin = fpTemp;

    fpTemp = pOldHeap->fpGARTDev;
    pOldHeap->fpGARTDev = pNewHeap->fpGARTDev;
    pNewHeap->fpGARTDev = fpTemp;

    dwTemp = pOldHeap->dwCommitedSize;
    pOldHeap->dwCommitedSize = pNewHeap->dwCommitedSize;
    pNewHeap->dwCommitedSize = dwTemp;

    liTemp = pOldHeap->liPhysAGPBase;
    pOldHeap->liPhysAGPBase = pNewHeap->liPhysAGPBase;
    pNewHeap->liPhysAGPBase = liTemp;

    pvTemp = pOldHeap->pvPhysRsrv;
    pOldHeap->pvPhysRsrv = pNewHeap->pvPhysRsrv;
    pNewHeap->pvPhysRsrv = pvTemp;

    pvTemp = (LPVOID) pOldHeap->pAgpCommitMask;
    pOldHeap->pAgpCommitMask = pNewHeap->pAgpCommitMask;
    pNewHeap->pAgpCommitMask = (BYTE*) pvTemp;

    dwTemp = pOldHeap->dwAgpCommitMaskSize;
    pOldHeap->dwAgpCommitMaskSize = pNewHeap->dwAgpCommitMaskSize;
    pNewHeap->dwAgpCommitMaskSize = dwTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddagpnt.cxx ===
/*========================================================================== *
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagpnt.c
 *  Content:	Functions for dealing with AGP memory in DirectDraw on NT
 *
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   18-jan-97	colinmc	initial implementation
 *   13-mar-97  colinmc Bug 6533: Pass uncached flag to VMM correctly
 *   07-may-97  colinmc Add support for AGP on OSR 2.1
 *   12-Feb-98  DrewB   Split into common, Win9x and NT sections.
 *
 ***************************************************************************/

#include "precomp.hxx"

#ifndef WIN95

// Currently the hdev passed in is the DirectDraw global, so
// look up the AGP interface in it.
#define GET_AGPI(hdev) (&((EDD_DIRECTDRAW_GLOBAL *)hdev)->AgpInterface)

#define CHECK_GET_AGPI(hdev, pvai) \
    (pvai) = GET_AGPI(hdev); \
    ASSERTGDI((pvai)->Context != NULL, "No AGP context");

// Offset to use for biasing AGP heaps.
#define DDNLV_HEAP_BIAS PAGE_SIZE

/*
 * OsAGPReserve
 *
 * Reserve resources for use as an AGP aperture.
 */
BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   PVOID *ppvReservation )
{
    AGP_INTERFACE *pai;
    VIDEO_PORT_CACHE_TYPE Cached;

    CHECK_GET_AGPI(hdev, pai);

    if (fIsUC)
    {
        Cached = VpNonCached;
    }
    else
    {
        Cached = VpWriteCombined;
    }

    // On NT heaps are kept with offsets rather than pointers so
    // always return a base offset as the starting address.  The
    // base offset is non-zero so that successful heap allocations
    // always have a non-zero value.
    *pfpLinStart = DDNLV_HEAP_BIAS;
    
    *pliDevStart = pai->AgpServices.
        AgpReservePhysical(pai->Context, dwNumPages,
                           Cached, ppvReservation);
    return *ppvReservation != NULL;

} /* OsAGPReserve */

/*
 * OsAGPCommit
 *
 * Commit memory to the given portion of a previously reserved range.
 */
BOOL OsAGPCommit( HANDLE hdev, PVOID pvReservation, DWORD dwPageOffset,
                  DWORD dwNumPages )
{
    AGP_INTERFACE *pai;

    CHECK_GET_AGPI(hdev, pai);

    return pai->AgpServices.AgpCommitPhysical(pai->Context,
                                              pvReservation,
                                              dwNumPages, dwPageOffset);

} /* OsAGPCommit */

/*
 * OsAGPDecommitAll
 *
 * Decommit everything in a reserved area.
 */
BOOL OsAGPDecommit( HANDLE hdev, PVOID pvReservation, DWORD dwPageOffset,
                    DWORD dwNumPages )
{
    AGP_INTERFACE *pai;

    CHECK_GET_AGPI(hdev, pai);

    // Decommit memory.
    pai->AgpServices.AgpFreePhysical(pai->Context, pvReservation,
                                     dwNumPages, dwPageOffset );
    return TRUE;
} /* OsAGPDecommitAll */

/*
 * OsAGPFree
 *
 * Free a previously reserved range.
 */
BOOL OsAGPFree( HANDLE hdev, PVOID pvReservation )
{
    AGP_INTERFACE *pai;
    
    CHECK_GET_AGPI(hdev, pai);

    pai->AgpServices.AgpReleasePhysical(pai->Context,
                                        pvReservation);
    return TRUE;
} /* OsAGPFree */

#endif // !WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddagp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddagp.h
 *  Content:	AGP memory header file
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Split from ddrawpr.h for user/kernel portability.
 *
 ***************************************************************************/

#ifndef __DDAGP_INCLUDED__
#define __DDAGP_INCLUDED__

// This value controls how big a chunk of GART memory to commit each time
// we need to (rather than commiting just what we need to satisfy a surface
// request). This value is in bytes.  Currently 256KB.
#define DEFAULT_AGP_COMMIT_DELTA (256 * 1024)

#define BITS_IN_BYTE    8


extern DWORD dwAGPPolicyMaxBytes;
extern DWORD dwAGPPolicyCommitDelta;

//
// OS-specific functions for AGP manipulation.
//

#ifdef WIN95
#define OsGetAGPDeviceHandle(pHeap) GetDXVxdHandle()
#define OsCloseAGPDeviceHandle(h) CloseHandle(h)
#else
#define OsGetAGPDeviceHandle(pHeap) ((pHeap)->hdevAGP)
#define OsCloseAGPDeviceHandle(h)
#endif

BOOL OsAGPReserve( HANDLE hdev, DWORD dwNumPages, BOOL fIsUC, BOOL fIsWC,
                   FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                   PVOID *ppvReservation );
BOOL OsAGPCommit( HANDLE hdev, PVOID pvReservation,
                  DWORD dwPageOffset, DWORD dwNumPages );
BOOL OsAGPDecommit( HANDLE hdev, PVOID pvReservation, DWORD dwPageOffset,
                    DWORD dwNumPages );
BOOL OsAGPFree( HANDLE hdev, PVOID pvReservation );

//
// Generic functions that use the OS-specific functions.
//

DWORD AGPReserve( HANDLE hdev, DWORD dwSize, BOOL fIsUC, BOOL fIsWC,
                  FLATPTR *pfpLinStart, LARGE_INTEGER *pliDevStart,
                  PVOID *ppvReservation );
BOOL AGPCommit( HANDLE hdev, PVOID pvReservation,
                DWORD dwOffset, DWORD dwSize, BYTE* pAgpCommitMask,
                DWORD* pdwCommittedSize, DWORD dwHeapSize );
BOOL AGPDecommitAll( HANDLE hdev, PVOID pvReservation, 
                     BYTE* pAgpCommitMask, DWORD dwAgpCommitMaksSize,
                     DWORD* pdwDecommittedSize,
                     DWORD dwHeapSize);
BOOL AGPFree( HANDLE hdev, PVOID pvReservation );
DWORD AGPGetChunkCount( DWORD dwSize );
VOID AGPUpdateCommitMask( BYTE* pAgpCommitMask, DWORD dwOffset, 
                          DWORD dwSize, DWORD dwHeapSize );
BOOL AGPCommitVirtual( EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal, 
                       VIDEOMEMORY* lpVidMem, 
                       int iHeapIndex, 
                       DWORD dwOffset,
                       DWORD dwSize );
BOOL AGPDecommitVirtual( EDD_VMEMMAPPING*        peMap,
                         EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
                         EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
                         DWORD                   dwHeapSize);
NTSTATUS AGPMapToDummy( EDD_VMEMMAPPING*        peMap, 
                        EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
                        PVOID                   pDummyPage);
BOOL AGPCommitAllVirtual( EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal, 
                          VIDEOMEMORY* lpVidMem, 
                          int iHeapIndex);

VOID InitAgpHeap( EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
                  DWORD                   dwHeapIndex,
                  HANDLE                  hdev);
BOOL bDdMapAgpHeap( EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
                    VIDEOMEMORY*            pvmHeap);
    
#ifndef __NTDDKCOMP__

#ifdef WIN95
BOOL vxdIsVMMAGPAware ( HANDLE hvxd );
#endif

BOOL OSIsAGPAware( HANDLE hdev );
#endif

#endif // __DDAGP_INCLUDED__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddvpe.cxx ===
/******************************Module*Header*******************************\
* Module Name: dvpe.cxx
*
* Contains all of GDI's private VideoPort APIs.
*
* Note that for videoport support, WIN32K.SYS and DXAPI.SYS are closely
* linked.  DXAPI.SYS provides two services:
*
*   1.  It handles the "software autoflipping" support for the videoports,
*       where the CPU handles the videoport field-done interrupt to
*       flip the overlay and do "bob" and "weave" for better video
*       quality.
*   2.  It provides the public DirectDraw entry points that are callable
*       by other kernel-mode WDM drivers (there is a corresponding DXAPI.SYS
*       module on Memphis/Win95 that exposes the same interface).
*
* All of the non-paged code for videoports has to go into DXAPI.SYS since
* WIN32K.SYS is marked entirely as pageable.  WIN32K.SYS handles some
* functionality on behalf of DXAPI.SYS, such as object opens and closes,
* since only WIN32K.SYS can access GDI's handle table.
*
* Created: 17-Oct-1996
* Author: Lingyun Wang [LingyunW]
*
* Copyright (c) 1996-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

extern PEPROCESS gpepSession;

VOID
vDdDxApiFreeDirectDraw(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    );

/////////////////////////////////////////////////////////////////////////
// DXAPI concerns:
//
// - Document that call-back may not occur in context of same process
// - Refuse to open surface, videoport objects while full-screen
//     Keep DirectDraw open so that POSTFULLSCREEN and DOSBOX can be honored
// - See InitKernelInterface for init restrictions
// - Flush DMA buffer before mode changes?
// - Invalidate dxapi data after mode change?
// - Right now, DirectDraw DXAPI objects have to be closed last

/////////////////////////////////////////////////////////////////////////
// VPE concerns:
//
// - Make sure VideoPort's not duplicated on same device
// - Document that display driver cannot use pool-allocated memory for
//     dwReserved fields on Synchronize calls
// - Close DxVideoPort objects on full-screen switch?
//     No, to support hardware that can DMA even while full-screen!
//     Okay, but what about mode changes?  There's no way they'll not
//     be able to drop frames
// - Never close DxDirectDraw objects?

/*****************************Private*Routine******************************\
* ULONG vDdNullCallBack
*
* The DXAPI register routines require a close call-back routine to notify
* the client that the object is going away.  Since we're really DirectDraw,
* we already know when the object is going away; hence, this routine doesn't
* need to do anything.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG
vDdNullCallBack(
    DWORD   dwFlags,
    PVOID   pContext,
    DWORD   dwParam1,
    DWORD   dwParam2
    )
{
    return 0;
}

/*****************************Private*Routine******************************\
* VOID vDdUnloadDxApiImage
*
* This routine performs the actual unload of DXAPI.SYS.
*
*  28-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
vDdUnloadDxApiImage(
    EDD_DIRECTDRAW_GLOBAL*   peDirectDrawGlobal
    )
{
    EDD_VIDEOPORT*        peVideoPort;
    EDD_VIDEOPORT*        peVideoPortNext;
    EDD_SURFACE*          peSurface;
    EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    // Notify clients that the resources are lost and clean up

    for (peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
        peDirectDrawLocal != NULL;
        peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext)
    {
        // If any video port still exist (which should not be the case)
        // delete all of the video port objects since the video port assumes
        // that DXAPI.SYS is loaded.

        for (peVideoPort = peDirectDrawLocal->peVideoPort_DdList;
            peVideoPort != NULL;
            peVideoPort = peVideoPortNext)
        {
            // Don't reference peVideoPort after it's been deleted!

            peVideoPortNext = peVideoPort->peVideoPort_DdNext;
            bDdDeleteVideoPortObject(peVideoPort->hGet(), NULL);
        }

        // If a surface still has a client using it, shut it down.

        peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

        while (peSurface)
        {
            if (peSurface->hSurface != NULL)
            {
                vDdDxApiFreeSurface( (DXOBJ*) peSurface->hSurface, FALSE );
                peSurface->hSurface = NULL;
            }
            if( peSurface->peDxSurface != NULL )
            {
                vDdLoseDxObjects( peDirectDrawGlobal,
                    peSurface->peDxSurface->pDxObj_List,
                    (PVOID) peSurface->peDxSurface,
                    LO_SURFACE );
            }
            peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
        }
    }
    if (peDirectDrawGlobal->hDirectDraw != NULL)
    {
        vDdDxApiFreeDirectDraw( (DXOBJ*) peDirectDrawGlobal->hDirectDraw, FALSE );
    }
    if( peDirectDrawGlobal->peDxDirectDraw != NULL )
    {
        vDdLoseDxObjects( peDirectDrawGlobal,
            peDirectDrawGlobal->peDxDirectDraw->pDxObj_List,
            (PVOID) peDirectDrawGlobal->peDxDirectDraw,
            LO_DIRECTDRAW );
    }

    EngUnloadImage(peDirectDrawGlobal->hDxApi);

    //
    // Free the memory associate with the module
    //

    peDirectDrawGlobal->hDxApi = NULL;
    peDirectDrawGlobal->dwDxApiRefCnt = 0;
}

/*****************************Private*Routine******************************\
* BOOL bDdLoadDxApi
*
* This routine loads up DXAPI.SYS and allocates the non-paged DXAPI
* structures.
*
* Returns: FALSE only if a DXAPI resource could not be allocated.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
*  16-Oct-1977 -by- smac
* Broke it out into a separate function.
\**************************************************************************/

BOOL
bDdLoadDxApi(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal
    )
{
    EDD_DIRECTDRAW_GLOBAL*   peDirectDrawGlobal;
    HANDLE                  hDxApi;
    PFNDXAPIINITIALIZE      pfnDxApiInitialize;
    DDOPENDIRECTDRAWIN      OpenDirectDrawIn;
    DDOPENDIRECTDRAWOUT     OpenDirectDrawOut;
    DWORD                   dwRet;

    DD_ASSERTDEVLOCK(peDirectDrawLocal->peDirectDrawGlobal);
    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    /*
     * Don't load if it's already loaded
     */
    if (peDirectDrawGlobal->hDxApi == NULL)
    {
        ASSERTGDI((peDirectDrawGlobal->hDirectDraw == NULL) &&
                  (peDirectDrawGlobal->hDxApi == NULL),
            "Expected NULL hDirectDraw and hDxApi");

        BOOL loaded;

        hDxApi = DxEngLoadImage(L"drivers\\dxapi.sys",FALSE);
        if (hDxApi)
        {
            peDirectDrawGlobal->hDxApi = hDxApi;
            peDirectDrawGlobal->pfnDxApi = (LPDXAPI)
                EngFindImageProcAddress(hDxApi, "_DxApi");
            peDirectDrawGlobal->pfnAutoflipUpdate = (PFNAUTOFLIPUPDATE)
                EngFindImageProcAddress(hDxApi, "_DxAutoflipUpdate");
            peDirectDrawGlobal->pfnLoseObject = (PFNLOSEOBJECT)
                EngFindImageProcAddress(hDxApi, "_DxLoseObject");
            pfnDxApiInitialize = (PFNDXAPIINITIALIZE)
                EngFindImageProcAddress(hDxApi, "_DxApiInitialize");
            peDirectDrawGlobal->pfnEnableIRQ = (PFNENABLEIRQ)
                EngFindImageProcAddress(hDxApi, "_DxEnableIRQ");
            peDirectDrawGlobal->pfnUpdateCapture = (PFNUPDATECAPTURE)
                EngFindImageProcAddress(hDxApi, "_DxUpdateCapture");

            ASSERTGDI(peDirectDrawGlobal->pfnDxApi != NULL,
                "Couldn't find DxApi'");
            ASSERTGDI(peDirectDrawGlobal->pfnAutoflipUpdate != NULL,
                "Couldn't find DxAutoflipUpdate");
            ASSERTGDI(peDirectDrawGlobal->pfnLoseObject != NULL,
                "Couldn't find DxLoseObject");
            ASSERTGDI(peDirectDrawGlobal->pfnEnableIRQ != NULL,
                "Couldn't find DxEnableIRQ");
            ASSERTGDI(peDirectDrawGlobal->pfnUpdateCapture != NULL,
                "Couldn't find DxUpdateCapture");
            ASSERTGDI(pfnDxApiInitialize != NULL,
                "Couldn't find DxApiInitialize");

            // By explicitly passing dxapi.sys its private win32k.sys
            // entry points, we don't have to export them from win32k.sys,
            // thus preventing any drivers from using those entry points
            // for their own nefarious purposes.

            pfnDxApiInitialize(DdDxApiOpenDirectDraw,
                               DdDxApiOpenVideoPort,
                               DdDxApiOpenSurface,
                               DdDxApiCloseHandle,
                               DdDxApiGetKernelCaps,
                               DdDxApiOpenCaptureDevice,
                               DdDxApiLockDevice,
                               DdDxApiUnlockDevice);

            // EngLoadImage always makes the entire driver pageable, but
            // DXAPI.SYS handles the DPC for the videoport interrupt and
            // so cannot be entirely pageable.  Consequently, we reset
            // the paging now:

            MmResetDriverPaging(pfnDxApiInitialize);

            // Now open the DXAPI version of DirectDraw:

            OpenDirectDrawIn.pfnDirectDrawClose = vDdNullCallBack;
            OpenDirectDrawIn.pContext          = NULL;
            OpenDirectDrawIn.dwDirectDrawHandle
                = (ULONG_PTR) peDirectDrawLocal->hGet();

            peDirectDrawGlobal->pfnDxApi(DD_DXAPI_OPENDIRECTDRAW,
                                         &OpenDirectDrawIn,
                                         sizeof(OpenDirectDrawIn),
                                         &OpenDirectDrawOut,
                                         sizeof(OpenDirectDrawOut));

            if (OpenDirectDrawOut.ddRVal == DD_OK)
            {
                // Success!
                peDirectDrawGlobal->hDirectDraw = OpenDirectDrawOut.hDirectDraw;
            }

            peDirectDrawGlobal->dwDxApiRefCnt = 1;
        }
        else
        {
            WARNING("bDdLoadDxApi: Couldn't load dxapi.sys\n");
            return(FALSE);
        }
    }
    else
    {
        peDirectDrawGlobal->dwDxApiRefCnt++;
    }

    return(TRUE);
}

/*****************************Private*Routine******************************\
* VOID vDdUnloadDxApi
*
* This routine unloads DXAPI.SYS
*
*  22-Oct-1997 -by- smac
\**************************************************************************/

VOID
vDdUnloadDxApi(
    EDD_DIRECTDRAW_GLOBAL*   peDirectDrawGlobal
    )
{
    DDCLOSEHANDLE           CloseHandle;
    DWORD                   dwRet;

    if ((peDirectDrawGlobal->hDxApi != NULL) &&
        (peDirectDrawGlobal->dwDxApiRefCnt > 0 ))
    {
        if( --peDirectDrawGlobal->dwDxApiRefCnt == 0 )
        {
            if (peDirectDrawGlobal->hDirectDraw != NULL)
            {
                CloseHandle.hHandle = peDirectDrawGlobal->hDirectDraw;

                peDirectDrawGlobal->pfnDxApi(DD_DXAPI_CLOSEHANDLE,
                    &CloseHandle,
                    sizeof(CloseHandle),
                    &dwRet,
                    sizeof(dwRet));

                ASSERTGDI(dwRet == DD_OK, "Unexpected failure from close");

                peDirectDrawGlobal->hDirectDraw = NULL;
            }

            vDdUnloadDxApiImage( peDirectDrawGlobal );
        }
    }
}

/*****************************Private*Routine******************************\
* BOOL bDdEnableSoftwareAutoflipping
*
* This routine loads up DXAPI.SYS, allocates the non-paged DXAPI structures
* required for software autoflipping, and enables the videoport interrupt.
*
* Returns: FALSE only if a DXAPI resource could not be allocated.  May
*          return TRUE even if the interrupt hasn't been successfully
*          enabled (because I expect that interrupts will be usable
*          on the majority of systems that support videoports, and this
*          simplifies other code by allowing it to assume that all the
*          DXAPI structures have been allocated).
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdEnableSoftwareAutoflipping(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    EDD_VIDEOPORT*          peVideoPort,
    DWORD                   dwVideoPortID,
    BOOL                    bFirst
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    HANDLE                  hDxApi;
    PFNDXAPIINITIALIZE      pfnDxApiInitialize;
    DDOPENDIRECTDRAWIN      OpenDirectDrawIn;
    DDOPENDIRECTDRAWOUT     OpenDirectDrawOut;
    DDOPENVIDEOPORTIN       OpenVideoPortIn;
    DDOPENVIDEOPORTOUT      OpenVideoPortOut;
    DWORD                   dwRet;
    UNICODE_STRING          UnicodeString;

    DD_ASSERTDEVLOCK(peVideoPort->peDirectDrawGlobal);

    peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

    // Create a DXAPI DirectDraw object, which we'll need for software
    // autoflipping.

    if (bFirst)
    {
        bDdLoadDxApi( peDirectDrawLocal );
    }

    if (peDirectDrawGlobal->hDirectDraw != NULL)
    {
        ASSERTGDI(peVideoPort->hVideoPort == NULL, "Expected NULL hVideoPort");

        OpenVideoPortIn.hDirectDraw       = peDirectDrawGlobal->hDirectDraw;
        OpenVideoPortIn.pfnVideoPortClose = vDdNullCallBack;
        OpenVideoPortIn.pContext          = NULL;
        OpenVideoPortIn.dwVideoPortHandle = dwVideoPortID;

        peDirectDrawGlobal->pfnDxApi(DD_DXAPI_OPENVIDEOPORT,
                                     &OpenVideoPortIn,
                                     sizeof(OpenVideoPortIn),
                                     &OpenVideoPortOut,
                                     sizeof(OpenVideoPortOut));

        if (OpenVideoPortOut.ddRVal == DD_OK)
        {
            peVideoPort->hVideoPort = OpenVideoPortOut.hVideoPort;
            return(TRUE);
        }
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vDdNotifyEvent
*
* This routine calls back to all registered DXAPI clients when a particular
* event (like mode change notification) occurs.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdNotifyEvent(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    DWORD                   dwEvent
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DXAPI_EVENT*        pDxEvent;

    peDxDirectDraw = peDirectDrawGlobal->peDxDirectDraw;

    if (peDxDirectDraw != NULL)
    {
        DD_ASSERTDEVLOCK(peDirectDrawGlobal);

        for (pDxEvent = peDxDirectDraw->pDxEvent_PassiveList;
             pDxEvent != NULL;
             pDxEvent = pDxEvent->pDxEvent_Next)
        {
            if (pDxEvent->dwEvent == dwEvent)
            {
                pDxEvent->pfnCallBack(pDxEvent->dwEvent,pDxEvent->pContext, 0, 0);
            }
        }
    }
}

/******************************Public*Routine******************************\
* DXAPI_OBJECT* pDdDxObjHandleAllocate
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DXOBJ*
pDdDxObjHandleAllocate(
    DXTYPE              iDxType,
    LPDD_NOTIFYCALLBACK pfnClose,
    DWORD               dwEvent,
    PVOID               pvContext
    )
{
    DXOBJ* pDxObj;

    ASSERTGDI(pfnClose != NULL,
        "pDdDxObjHandleAllocate: DXAPI client must supply Close function");

    pDxObj = (DXOBJ*) PALLOCNONPAGED(sizeof(*pDxObj),'xxdG');
    if (pDxObj != NULL)
    {
        pDxObj->iDxType     = iDxType;
        pDxObj->pfnClose    = pfnClose;
        pDxObj->pContext    = pvContext;
        pDxObj->dwEvent     = dwEvent;
        pDxObj->pDxObj_Next = NULL;
        pDxObj->dwFlags     = 0;
        pDxObj->pepSession  = gpepSession;
    }

    return(pDxObj);
}

// Should be macro for free build.

PVOID
pDdDxObjDataAllocate(
    ULONG cj,
    ULONG tag
    )
{
    return (PALLOCNONPAGED(cj,tag));
}

VOID
vDdDxObjFree(
    PVOID pvDxObj
    )
{
    VFREEMEM(pvDxObj);
}

/******************************Public*Routine******************************\
* VOID vDdQueryMiniportDxApiSupport
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdQueryMiniportDxApiSupport(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    BOOL bMiniportSupport;

    // Assume failure.
    bMiniportSupport = FALSE;

    if (bDdIoQueryInterface(peDirectDrawGlobal,
                            &GUID_DxApi,
                            sizeof(DXAPI_INTERFACE),
                            DXAPI_HALVERSION,
                            (INTERFACE *)&peDirectDrawGlobal->DxApiInterface))
    {
        ASSERTGDI((peDirectDrawGlobal->DxApiInterface.
                   InterfaceReference == NULL) &&
                  (peDirectDrawGlobal->DxApiInterface.
                   InterfaceDereference == NULL),
                  "Miniport shouldn't modify InterfaceReference/Dereference");

        // Assert some stuff about hooked entry points?

        peDirectDrawGlobal->HwDeviceExtension
            = peDirectDrawGlobal->DxApiInterface.Context;
        bMiniportSupport = TRUE;
    }

    // Even if the miniport doesn't support DXAPI accelerations, we still
    // allow DXAPI to work (the DXAPI Lock call doesn't require that the
    // miniport support DXAPI, for example).

    if (!bMiniportSupport)
    {
        // Zero out any capabilities:

        RtlZeroMemory(&peDirectDrawGlobal->DxApiInterface,
                sizeof(peDirectDrawGlobal->DxApiInterface));
    }
}

/******************************Public*Routine******************************\
* DWORD vDdSynchronizeSurface
*
* Updates the EDD_DXSURFACE structure using the master EDD_SURFACE
* structure, with some help from the driver.
*
* Analagous to Win95's SyncKernelSurface routine.
*
* This routine lets a driver use fields from the larger, pageable version
* of the DD_SURFACE_* structures used by the display driver to set
* fields in the smaller, non-pageable version of the corresponding
* DDSURFACEDATA structure used by the miniport.
*
* NOTE: The display driver may NOT use the reserved fields to point to
*       allocated memory, for two reasons:
*
*       1.  We don't call them when the surfaces is freed, so they'd
*           lose memory;
*       2.  We only let display drivers allocate paged memory, which
*           they can't use in the miniport since they'll be at raised
*           IRQL when we call them.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdSynchronizeSurface(
    EDD_SURFACE*    peSurface
    )
{
    EDD_DXSURFACE*          peDxSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DD_SYNCSURFACEDATA      SyncSurfaceData;

    peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

    peDxSurface = peSurface->peDxSurface;
    if (peDxSurface != NULL)
    {
        RtlZeroMemory(&SyncSurfaceData, sizeof(SyncSurfaceData));

        SyncSurfaceData.lpDD            = peDirectDrawGlobal;
        SyncSurfaceData.lpDDSurface     = peSurface;
        SyncSurfaceData.dwSurfaceOffset = (DWORD) peSurface->fpVidMem;
        SyncSurfaceData.fpLockPtr       = peSurface->fpVidMem
                + (FLATPTR) peDirectDrawGlobal->HalInfo.vmiData.pvPrimary;
        SyncSurfaceData.lPitch          = peSurface->lPitch;

        EDD_DEVLOCK eDevLock(peDirectDrawGlobal);

        // Call the driver to let it fill in the rest of the values:

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->DxApiCallBacks.SyncSurfaceData))
        {
            peDirectDrawGlobal->
                DxApiCallBacks.SyncSurfaceData(&SyncSurfaceData);
        }

        // Fields updated by the driver:

        peDxSurface->dwSurfaceOffset   = SyncSurfaceData.dwSurfaceOffset;
        peDxSurface->fpLockPtr         = SyncSurfaceData.fpLockPtr;
        peDxSurface->lPitch            = SyncSurfaceData.lPitch;
        peDxSurface->dwOverlayOffset   = SyncSurfaceData.dwOverlayOffset;
        peDxSurface->dwDriverReserved1 = SyncSurfaceData.dwDriverReserved1;
        peDxSurface->dwDriverReserved2 = SyncSurfaceData.dwDriverReserved2;
        peDxSurface->dwDriverReserved3 = SyncSurfaceData.dwDriverReserved3;
        peDxSurface->dwDriverReserved4 = SyncSurfaceData.dwDriverReserved4;

        // Fields taken straight from the surface structure:

        peDxSurface->ddsCaps             = peSurface->ddsCaps.dwCaps;
        peDxSurface->dwWidth             = peSurface->wWidth;
        peDxSurface->dwHeight            = peSurface->wHeight;
        peDxSurface->dwOverlayFlags      = peSurface->dwOverlayFlags;
        peDxSurface->dwFormatFlags       = peSurface->ddpfSurface.dwFlags;
        peDxSurface->dwFormatFourCC      = peSurface->ddpfSurface.dwFourCC;
        peDxSurface->dwFormatBitCount    = peSurface->ddpfSurface.dwRGBBitCount;
        peDxSurface->dwRBitMask          = peSurface->ddpfSurface.dwRBitMask;
        peDxSurface->dwGBitMask          = peSurface->ddpfSurface.dwGBitMask;
        peDxSurface->dwBBitMask          = peSurface->ddpfSurface.dwBBitMask;
        peDxSurface->dwOverlaySrcWidth   = peSurface->dwOverlaySrcWidth;
        peDxSurface->dwOverlaySrcHeight  = peSurface->dwOverlaySrcHeight;
        peDxSurface->dwOverlayDestWidth  = peSurface->dwOverlayDestWidth;
        peDxSurface->dwOverlayDestHeight = peSurface->dwOverlayDestHeight;
    }
}

/******************************Public*Routine******************************\
* DWORD vDdSynchronizeVideoPort
*
* Updates the EDD_DXVIDEOPORT structure using the master EDD_VIDEOPORT
* structure, with some help from the driver.
*
* Analagous to Win95's SyncKernelVideoPort routine.
*
* This routine lets a driver use fields from the larger, pageable version
* of the DD_VIDEOPORT_LOCAL structure used by the display driver to set
* fields in the smaller, non-pageable version of the corresponding
* DDVIDEOPORTDATA structure used by the miniport.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdSynchronizeVideoPort(
    EDD_VIDEOPORT*  peVideoPort
    )
{
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DD_SYNCVIDEOPORTDATA    SyncVideoPortData;

    peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

    peDxVideoPort = peVideoPort->peDxVideoPort;
    if (peDxVideoPort != NULL)
    {
        RtlZeroMemory(&SyncVideoPortData, sizeof(SyncVideoPortData));

        SyncVideoPortData.lpDD        = peDirectDrawGlobal;
        SyncVideoPortData.lpVideoPort = peVideoPort;
        SyncVideoPortData.dwVBIHeight = peVideoPort->ddvpInfo.dwVBIHeight;

        if (peVideoPort->ddvpInfo.dwVPFlags & DDVP_PRESCALE)
        {
            SyncVideoPortData.dwHeight = peVideoPort->ddvpInfo.dwPrescaleHeight;
        }
        else if (peVideoPort->ddvpInfo.dwVPFlags & DDVP_CROP)
        {
            SyncVideoPortData.dwHeight = peVideoPort->ddvpInfo.rCrop.bottom -
                                         peVideoPort->ddvpInfo.rCrop.top;
        }
        else
        {
            SyncVideoPortData.dwHeight = peVideoPort->ddvpDesc.dwFieldHeight;
        }
        if (peVideoPort->ddvpInfo.dwVPFlags & DDVP_INTERLEAVE)
        {
            SyncVideoPortData.dwHeight *= 2;
        }

        EDD_DEVLOCK eDevLock(peDirectDrawGlobal);

        // Call the driver to let it fill in the rest of the values:

        if ((peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->DxApiCallBacks.SyncVideoPortData))
        {
            peDirectDrawGlobal->
                DxApiCallBacks.SyncVideoPortData(&SyncVideoPortData);
        }

        // Fields updated by the driver:

        peDxVideoPort->dwOriginOffset    = SyncVideoPortData.dwOriginOffset;
        peDxVideoPort->dwHeight          = SyncVideoPortData.dwHeight;
        peDxVideoPort->dwVBIHeight       = SyncVideoPortData.dwVBIHeight;
        peDxVideoPort->dwDriverReserved1 = SyncVideoPortData.dwDriverReserved1;
        peDxVideoPort->dwDriverReserved2 = SyncVideoPortData.dwDriverReserved2;
        peDxVideoPort->dwDriverReserved3 = SyncVideoPortData.dwDriverReserved3;

        // Fields taken straight from the videoport structure:

        peDxVideoPort->dwVideoPortId     = peVideoPort->ddvpDesc.dwVideoPortID;
        peDxVideoPort->dwVPFlags         = peVideoPort->ddvpInfo.dwVPFlags;
        if( ( peDxVideoPort->dwVBIHeight > 0 ) &&
            ( peDxVideoPort->dwVPFlags & DDVP_INTERLEAVE ) &&
            !( peDxVideoPort->dwVPFlags & DDVP_VBINOINTERLEAVE ) )
        {
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_VBI_INTERLEAVED;
        }
        else
        {
            peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_VBI_INTERLEAVED;
        }
    }
}

/******************************Public*Routine******************************\
* HANDLE hDdOpenDxApiSurface
*
* Opens a DXAPI representation of a surface
*
*  20-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

HANDLE
hDdOpenDxApiSurface(
    EDD_SURFACE*            peSurface
    )
{
    DDOPENSURFACEIN     OpenSurfaceIn;
    DDOPENSURFACEOUT    OpenSurfaceOut;
    HANDLE              hHandle;

    hHandle = NULL;

    // Allocate a DXAPI object:

    OpenSurfaceIn.hDirectDraw     = peSurface->peDirectDrawGlobal->hDirectDraw;
    OpenSurfaceIn.dwSurfaceHandle = (ULONG_PTR) peSurface->hGet();
    OpenSurfaceIn.pfnSurfaceClose = vDdNullCallBack;

    peSurface->peDirectDrawGlobal->pfnDxApi(DD_DXAPI_OPENSURFACE,
        &OpenSurfaceIn,
        sizeof(OpenSurfaceIn),
        &OpenSurfaceOut,
        sizeof(OpenSurfaceOut));

    if( ( OpenSurfaceOut.ddRVal == DD_OK ) &&
        ( OpenSurfaceOut.hSurface != NULL ) )
    {
        hHandle = OpenSurfaceOut.hSurface;
        vDdSynchronizeSurface( peSurface );
    }

    return hHandle;
}

/******************************Public*Routine******************************\
* HANDLE hDdCloseDxApiSurface
*
* Closes a DXAPI representation of a surface
*
*  21-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
vDdCloseDxApiSurface(
    EDD_SURFACE*            peSurface
    )
{
    DDCLOSEHANDLE CloseHandle;
    DWORD         dwRet;

    CloseHandle.hHandle = peSurface->hSurface;

    peSurface->peDirectDrawGlobal->pfnDxApi(DD_DXAPI_CLOSEHANDLE,
        &CloseHandle,
        sizeof(CloseHandle),
        &dwRet,
        sizeof(dwRet));

    ASSERTGDI(dwRet == DD_OK, "Expected DD_OK");

    peSurface->hSurface = NULL;
}

/******************************Public*Routine******************************\
* BOOL bDdUpdateLinksAndSynchronize
*
* A bidirectional link is maintained between a videoport and its active
* surfaces:
*
*     1. From each surface to the active videoport;
*     2. From the videoport to each of its active surfaces.
*
* This routine does all the maintaining of those links, automatically
* removing links from surfaces that are no longer used, and informing
* the software autoflipper of the change.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdUpdateLinksAndSynchronize(
    EDD_VIDEOPORT*  peVideoPort,
    BOOL            bNewVideo,          // FALSE if 'video' parameters should
    EDD_SURFACE**   apeNewVideo,        //   be ignored and current video state
    ULONG           cAutoflipVideo,     //   should remain unchanged
    BOOL            bNewVbi,            // FALSE if 'VBI' parameters should
    EDD_SURFACE**   apeNewVbi,          //   be ignored and current VBI state
    ULONG           cAutoflipVbi        //   should remain unchanged
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_DXVIDEOPORT*        peDxVideoPort;
//    EDD_SURFACE*            apeTempVideo[MAX_AUTOFLIP_BUFFERS];
//    EDD_SURFACE*            apeTempVbi[MAX_AUTOFLIP_BUFFERS];
    EDD_DXSURFACE*          apeDxNewVideo[MAX_AUTOFLIP_BUFFERS];
    EDD_DXSURFACE*          apeDxNewVbi[MAX_AUTOFLIP_BUFFERS];
    ULONG                   i;
    BOOL                    bOk;

    peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;
    peDxVideoPort = peVideoPort->peDxVideoPort;

    if (peDxVideoPort == NULL)
        return(TRUE);

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    // First, check to make sure the surfaces have been opened

    bOk = TRUE;
    for (i = 0; i < cAutoflipVideo; i++)
    {
        if( ( apeNewVideo[i] == NULL ) ||
            ( apeNewVideo[i]->hSurface == NULL ) )
        {
            bOk = FALSE;
        }
    }
    for (i = 0; i < cAutoflipVbi; i++)
    {
        if( ( apeNewVbi[i] == NULL ) ||
            ( apeNewVbi[i]->hSurface == NULL ) )
        {
            bOk = FALSE;
        }
    }

    if (!bOk)
    {
        return(FALSE);
    }

    // Remove the videoport links from the old surfaces, and stash a copy
    // of the list for later:

    for (i = 0; i < peVideoPort->cAutoflipVideo; i++)
    {
        peVideoPort->apeSurfaceVideo[i]->lpVideoPort = NULL;
        if( peVideoPort->apeSurfaceVideo[i]->peDxSurface != NULL )
        {
            peVideoPort->apeSurfaceVideo[i]->peDxSurface->peDxVideoPort = NULL;
        }
    }
    for (i = 0; i < peVideoPort->cAutoflipVbi; i++)
    {
        peVideoPort->apeSurfaceVbi[i]->lpVideoPort = NULL;
        if( peVideoPort->apeSurfaceVbi[i]->peDxSurface != NULL )
        {
            peVideoPort->apeSurfaceVbi[i]->peDxSurface->peDxVideoPort = NULL;
        }
    }

    // Now add the links to the new surfaces:

    for (i = 0; i < cAutoflipVideo; i++)
    {
        peVideoPort->apeSurfaceVideo[i] = apeNewVideo[i];
        apeNewVideo[i]->lpVideoPort = peVideoPort;
        apeDxNewVideo[i] = apeNewVideo[i]->peDxSurface;
    }
    for (i = 0; i < cAutoflipVbi; i++)
    {
        peVideoPort->apeSurfaceVbi[i] = apeNewVbi[i];
        apeNewVbi[i]->lpVideoPort = peVideoPort;
        apeDxNewVbi[i] = apeNewVbi[i]->peDxSurface;
    }

    // Now modify the autoflip buffers, being careful to synchronize with
    // the software-autoflip DPC.  Note that this does stuff like sets
    // peDxVideoPort->cAutoflipVbi.

    peDirectDrawGlobal->pfnAutoflipUpdate(peDxVideoPort,
                                          apeDxNewVideo,
                                          cAutoflipVideo,
                                          apeDxNewVbi,
                                          cAutoflipVbi);

    peVideoPort->cAutoflipVideo = cAutoflipVideo;
    peVideoPort->cAutoflipVbi   = cAutoflipVbi;

    // Finally, Update some last public fields in the videoport structure:

    peVideoPort->dwNumAutoflip    = cAutoflipVideo;
    peVideoPort->dwNumVBIAutoflip = cAutoflipVbi;
    peVideoPort->lpSurface      = (cAutoflipVideo == 0) ? NULL : apeNewVideo[0];
    peVideoPort->lpVBISurface   = (cAutoflipVbi == 0)   ? NULL : apeNewVbi[0];

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vDdDxApiFreeDirectDraw
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDxApiFreeDirectDraw(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DXOBJ*              pDxTmp;

    ASSERTGDI(pDxObj->iDxType == DXT_DIRECTDRAW, "Invalid object");

    peDxDirectDraw = pDxObj->peDxDirectDraw;

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (bDoCallBack)
    {
        pDxObj->pfnClose(pDxObj->dwEvent,pDxObj->pContext, 0, 0);
    }

    // Remove this DXOBJ instance from the list hanging off the DXAPI object:

    if (peDxDirectDraw->pDxObj_List == pDxObj)
    {
        peDxDirectDraw->pDxObj_List = pDxObj->pDxObj_Next;
    }
    else
    {
        for (pDxTmp = peDxDirectDraw->pDxObj_List;
             pDxTmp->pDxObj_Next != pDxObj;
             pDxTmp = pDxTmp->pDxObj_Next)
        {
            ASSERTGDI(pDxTmp->iDxType == DXT_DIRECTDRAW, "Unexpected type");
            ASSERTGDI(pDxTmp->pDxObj_Next != NULL, "Couldn't find node");
        }

        pDxTmp->pDxObj_Next = pDxObj->pDxObj_Next;
    }

    // Free the DXOBJ instance:

    pDxObj->iDxType = DXT_INVALID;
    vDdDxObjFree(pDxObj);

    // If there are no more DXOBJ instances of the DirectDraw DXAPI object,
    // we can free the non-paged DXAPI part of the DirectDraw structure:

    if (peDxDirectDraw->pDxObj_List == NULL)
    {
        if ((peDxDirectDraw->pDxEvent_PassiveList != NULL) ||
            (peDxDirectDraw->pDxEvent_DispatchList[CLIENT_DISPATCH_LIST] != NULL))
        {
            KdPrint(("vDdDxApiFreeDirectDraw: A kernel-mode DXAPI client didn't unregister all\n"));
            KdPrint(("  its events when it received CLOSE call-backs.  This will cause at\n"));
            KdPrint(("  best a memory leak and at worst a crash!\n"));
            RIP("The DXAPI client must be fixed.");
        }

        if (peDxDirectDraw->peDirectDrawGlobal != NULL)
        {
            peDxDirectDraw->peDirectDrawGlobal->peDxDirectDraw = NULL;
        }
        vDdDxObjFree(peDxDirectDraw);
    }
}

/******************************Public*Routine******************************\
* VOID vDdDxApiFreeVideoPort
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDxApiFreeVideoPort(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    )
{
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    EDD_DXVIDEOPORT*    peDxVideoPort;
    DXOBJ*              pDxObjTmp;
    DXAPI_EVENT*        pDxEventTmp;

    ASSERTGDI(pDxObj->iDxType == DXT_VIDEOPORT, "Invalid object");

    peDxVideoPort      = pDxObj->peDxVideoPort;
    peDxDirectDraw     = peDxVideoPort->peDxDirectDraw;

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (bDoCallBack)
    {
        pDxObj->pfnClose(pDxObj->dwEvent, pDxObj->pContext, 0, 0);
    }

    // Remove this DXOBJ instance from the list hanging off the DXAPI object:

    if (peDxVideoPort->pDxObj_List == pDxObj)
    {
        peDxVideoPort->pDxObj_List = pDxObj->pDxObj_Next;
    }
    else
    {
        for (pDxObjTmp = peDxVideoPort->pDxObj_List;
             pDxObjTmp->pDxObj_Next != pDxObj;
             pDxObjTmp = pDxObjTmp->pDxObj_Next)
        {
            ASSERTGDI(pDxObjTmp->iDxType == DXT_VIDEOPORT, "Unexpected type");
            ASSERTGDI(pDxObjTmp->pDxObj_Next != NULL, "Couldn't find node");
        }

        pDxObjTmp->pDxObj_Next = pDxObj->pDxObj_Next;
    }

    // Free the notification event if one is present

    if (peDxVideoPort->pNotifyEvent != NULL)
    {
        PKEVENT     pTemp = NULL;
        HANDLE      hEvent = peDxVideoPort->pNotifyEventHandle;
        NTSTATUS    Status;

        peDxVideoPort->pNotifyEvent = NULL;
        peDxVideoPort->pNotifyEventHandle = NULL;

        // Make sure that the handle hasn't been freed by the OS already
        Status = ObReferenceObjectByHandle( hEvent,
                                        0,
                                        0,
                                        KernelMode,
                                        (PVOID *) &pTemp,
                                        NULL );
        if ((pTemp != NULL) && (Status != STATUS_INVALID_HANDLE))
        {
            ObDereferenceObject(pTemp);
            ZwClose (hEvent);
        }

        // Un-page lock memory

        peDxVideoPort->pNotifyBuffer = NULL;
        if (peDxVideoPort->pNotifyMdl != NULL)
        {
            MmUnlockPages (peDxVideoPort->pNotifyMdl);
            IoFreeMdl (peDxVideoPort->pNotifyMdl);
            peDxVideoPort->pNotifyMdl = NULL;
        }
    }

    // Free the DXOBJ instance:

    pDxObj->iDxType = DXT_INVALID;
    vDdDxObjFree(pDxObj);

    // If there are no more DXOBJ instances of the VideoPort DXAPI object,
    // we can free the non-paged DXAPI part of the VideoPort structure:

    if (peDxVideoPort->pDxObj_List == NULL)
    {
        ASSERTGDI(peDxDirectDraw != NULL, "Unexpected NULL peDxDirectDraw");

        for (pDxEventTmp = peDxDirectDraw->pDxEvent_DispatchList[CLIENT_DISPATCH_LIST];
             pDxEventTmp != NULL;
             pDxEventTmp = pDxEventTmp->pDxEvent_Next)
        {
            if (pDxEventTmp->peDxVideoPort == peDxVideoPort)
            {
                KdPrint(("vDdDxApiFreeVideoPort: A kernel-mode DXAPI client didn't unregister all\n"));
                KdPrint(("  its videoport events when it received CLOSE call-backs.  This will\n"));
                KdPrint(("  cause at best a memory leak and at worst a crash!\n"));
                RIP("The DXAPI client must be fixed.");
            }
        }

        if (peDxVideoPort->peVideoPort != NULL)
        {
            // If we are actually freeing the video port, we need to lose
            // any capture objects that are associated with it

            while( peDxVideoPort->peDxCapture != NULL )
            {
                vDdLoseDxObjects( peDxDirectDraw->peDirectDrawGlobal,
                    peDxVideoPort->peDxCapture->pDxObj_List,
                    (PVOID) peDxVideoPort->peDxCapture,
                    LO_CAPTURE );
            }

            peDxVideoPort->peVideoPort->peDxVideoPort = NULL;
        }
        vDdDxObjFree(peDxVideoPort);
    }
}

/******************************Public*Routine******************************\
* VOID vDdDxApiFreeCapture
*
*  10-Apr-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
vDdDxApiFreeCapture(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    )
{
    EDD_DXCAPTURE*      peDxCapture;
    EDD_DXVIDEOPORT*    peDxVideoPort;

    ASSERTGDI(pDxObj->iDxType == DXT_CAPTURE, "Invalid object");

    peDxCapture        = pDxObj->peDxCapture;
    peDxVideoPort      = peDxCapture->peDxVideoPort;

    if (bDoCallBack)
    {
        pDxObj->pfnClose(pDxObj->dwEvent, pDxObj->pContext, 0, 0);
    }

    // Free the DXOBJ instance:

    pDxObj->iDxType = DXT_INVALID;
    vDdDxObjFree(pDxObj);

    // Unassociate the capture object from the video port.  Since this
    // must be synchronized with the DPC, we need to call DxApi to do this.

    if( peDxVideoPort != NULL )
    {
        EDD_DXDIRECTDRAW*       peDxDirectDraw;
        EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

        peDxDirectDraw = peDxVideoPort->peDxDirectDraw;
        EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;
        peDirectDrawGlobal->pfnUpdateCapture( peDxVideoPort,
                        peDxCapture, TRUE );
    }

    vDdDxObjFree(peDxCapture);
}

/******************************Public*Routine******************************\
* VOID vDdDxApiFreeSurface
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDxApiFreeSurface(
    DXOBJ*  pDxObj,
    BOOL    bDoCallBack
    )
{
    EDD_DXSURFACE*      peDxSurface;
    EDD_DXDIRECTDRAW*   peDxDirectDraw;
    DXOBJ*              pDxTmp;

    ASSERTGDI(pDxObj->iDxType == DXT_SURFACE, "Invalid object");

    peDxSurface    = pDxObj->peDxSurface;
    peDxDirectDraw = peDxSurface->peDxDirectDraw;

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (bDoCallBack)
    {
        pDxObj->pfnClose(pDxObj->dwEvent, pDxObj->pContext, 0, 0);
    }

    // Remove this DXOBJ instance from the list hanging off the DXAPI object:

    if (peDxSurface->pDxObj_List == pDxObj)
    {
        peDxSurface->pDxObj_List = pDxObj->pDxObj_Next;
    }
    else
    {
        for (pDxTmp = peDxSurface->pDxObj_List;
             pDxTmp->pDxObj_Next != pDxObj;
             pDxTmp = pDxTmp->pDxObj_Next)
        {
            ASSERTGDI(pDxTmp->iDxType == DXT_SURFACE, "Unexpected type");
            ASSERTGDI(pDxTmp->pDxObj_Next != NULL, "Couldn't find node");
        }

        pDxTmp->pDxObj_Next = pDxObj->pDxObj_Next;
    }

    // Free the DXOBJ instance:

    pDxObj->iDxType = DXT_INVALID;
    vDdDxObjFree(pDxObj);

    // If there are no more DXOBJ instances of the Surface DXAPI object,
    // we can free the non-paged DXAPI part of the Surface structure:

    if (peDxSurface->pDxObj_List == NULL)
    {
        if (peDxSurface->peSurface != NULL)
        {
            peDxSurface->peSurface->peDxSurface = NULL;
        }
        vDdDxObjFree(peDxSurface);
    }
}

/******************************Public*Routine******************************\
* VOID vDdStopVideoPort
*
* Makes an emergency stop of the videoport.
*
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdStopVideoPort(
    EDD_VIDEOPORT*  peVideoPort
    )
{
    EDD_DXVIDEOPORT*        peDxVideoPort;
    DD_UPDATEVPORTDATA      UpdateVPortData;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    BOOL                    b;

    peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;
    peDxVideoPort      = peVideoPort->peDxVideoPort;

    // Stop the videoport itself:

    UpdateVPortData.lpDD             = peDirectDrawGlobal;
    UpdateVPortData.lpVideoPort      = peVideoPort;
    UpdateVPortData.lplpDDVBISurface = NULL;
    UpdateVPortData.lplpDDSurface    = NULL;
    UpdateVPortData.lpVideoInfo      = NULL;
    UpdateVPortData.dwNumAutoflip    = 0;
    UpdateVPortData.dwFlags          = DDRAWI_VPORTSTOP;

    EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

    ASSERTGDI(peDirectDrawGlobal->VideoPortCallBacks.UpdateVideoPort != NULL,
        "Videoport object shouldn't have been created if UpdateVideoPort NULL");

    // Disable video port VSYNC IRQ

    if (peDxVideoPort != NULL)
    {
        // Shut down software autoflipping (the autoflipping routine peeks
        // at these values, so this is sufficient):

        peDxVideoPort->bSoftwareAutoflip = FALSE;
        peDxVideoPort->flFlags          &= ~(DD_DXVIDEOPORT_FLAG_AUTOFLIP|DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI);
        peDxVideoPort->bSkip             = FALSE;
        peDxVideoPort->dwSetStateField   = 0;

        if (peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON)
        {
            peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_ON;
            peDirectDrawGlobal->pfnEnableIRQ(peDxVideoPort, FALSE );
        }
    }


    if (!peDirectDrawGlobal->bSuspended &&
        (peDirectDrawGlobal->VideoPortCallBacks.UpdateVideoPort != NULL))
    {
        peDirectDrawGlobal->VideoPortCallBacks.UpdateVideoPort(&UpdateVPortData);
    }

    // Update the links to reflect the fact that no surface is a
    // destination for this videoport anymore:

    b = bDdUpdateLinksAndSynchronize(peVideoPort, TRUE, NULL, 0, TRUE, NULL, 0);

    ASSERTGDI(b, "vDdStopVideoPort: Shouldn't fail bDdUpdateLinkAndSynchronize");
}

/******************************Public*Routine******************************\
* VOID LoseDxObjects
*
* Notifies all clients using the resource that it can't be used anymore.
* It also notifies DXAPI.SYS that the resource is unusable.
*
*  04-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
vDdLoseDxObjects(
    EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal,
    DXOBJ*                 pDxObj,
    PVOID                  pDxThing,
    DWORD                  dwType
    )
{
    if( pDxObj != NULL )
    {
        while( pDxObj != NULL )
        {
            pDxObj->pfnClose(pDxObj->dwEvent, pDxObj->pContext, 0, 0);
            pDxObj = pDxObj->pDxObj_Next;
        }

        peDirectDrawGlobal->pfnLoseObject( pDxThing, (LOTYPE) dwType );
    }
}

/******************************Public*Routine******************************\
* BOOL bDdDeleteVideoPortObject
*
* Deletes a kernel-mode representation of the videoport object.
*
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdDeleteVideoPortObject(
    HANDLE  hVideoPort,
    DWORD*  pdwRet          // For returning driver return code, may be NULL
    )
{
    BOOL                    bRet;
    DWORD                   dwRet;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_VIDEOPORT*          peVideoPort;
    EDD_VIDEOPORT*          peTmp;
    VOID*                   pvRemove;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    DD_DESTROYVPORTDATA     DestroyVPortData;
    DXOBJ*                  pDxObj;
    DXOBJ*                  pDxObjNext;

    bRet = FALSE;
    dwRet = DDHAL_DRIVER_HANDLED;

    peVideoPort = (EDD_VIDEOPORT*) DdHmgLock((HDD_OBJ) hVideoPort, DD_VIDEOPORT_TYPE, FALSE);

    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        // Make sure the videoport has been turned off:

        vDdStopVideoPort(peVideoPort);

        // If there are any capture objects associated witht he video port,
        // lose them now

        peDxVideoPort = peVideoPort->peDxVideoPort;
        while( peDxVideoPort && (peDxVideoPort->peDxCapture != NULL) )
        {
            vDdLoseDxObjects( peDirectDrawGlobal,
                peDxVideoPort->peDxCapture->pDxObj_List,
                (PVOID) peDxVideoPort->peDxCapture,
                LO_CAPTURE );
        }

        // Free the DXAPI instance of the videoport object

        if (peVideoPort->hVideoPort != NULL)
        {
            vDdDxApiFreeVideoPort( (DXOBJ*) peVideoPort->hVideoPort, FALSE);
            peVideoPort->hVideoPort = NULL;
            peDxVideoPort = peVideoPort->peDxVideoPort;
        }

        // Notify clients that their open objects are lost

        if (peDxVideoPort) {
            vDdLoseDxObjects( peDirectDrawGlobal,
                peDxVideoPort->pDxObj_List,
                (PVOID) peDxVideoPort,
                LO_VIDEOPORT );
        }

        pvRemove = DdHmgRemoveObject((HDD_OBJ) hVideoPort,
                                   DdHmgQueryLock((HDD_OBJ) hVideoPort),
                                   0,
                                   TRUE,
                                   DD_VIDEOPORT_TYPE);

        ASSERTGDI(pvRemove != NULL, "Outstanding surfaces locks");

        // Hold the devlock while we call the driver and while we muck
        // around in the videoport list:

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if (peVideoPort->fl & DD_VIDEOPORT_FLAG_DRIVER_CREATED)
        {
            // Call the driver if it created the object:

            if (peDirectDrawGlobal->VideoPortCallBacks.DestroyVideoPort)
            {
                DestroyVPortData.lpDD        = peDirectDrawGlobal;
                DestroyVPortData.lpVideoPort = peVideoPort;
                DestroyVPortData.ddRVal      = DDERR_GENERIC;

                dwRet = peDirectDrawGlobal->
                    VideoPortCallBacks.DestroyVideoPort(&DestroyVPortData);
            }
        }

        // Remove from the videoport linked-list:

        peDirectDrawLocal = peVideoPort->peDirectDrawLocal;

        if (peDirectDrawLocal->peVideoPort_DdList == peVideoPort)
        {
            peDirectDrawLocal->peVideoPort_DdList
                = peVideoPort->peVideoPort_DdNext;
        }
        else
        {
            for (peTmp = peDirectDrawLocal->peVideoPort_DdList;
                 peTmp->peVideoPort_DdNext != peVideoPort;
                 peTmp = peTmp->peVideoPort_DdNext)
                 ;

            peTmp->peVideoPort_DdNext = peVideoPort->peVideoPort_DdNext;
        }

        // Unload DXAPI.SYS if no other video port is using it

        if (peDirectDrawLocal->peVideoPort_DdList == NULL)
        {
            vDdUnloadDxApi( peDirectDrawGlobal );
        }

        // We're all done with this object, so free the memory and
        // leave:

        DdFreeObject(peVideoPort, DD_VIDEOPORT_TYPE);

        bRet = TRUE;
    }
    else
    {
        WARNING1("bDdDeleteVideoPortObject: Bad handle or object was busy\n");
    }

    if (pdwRet != NULL)
    {
        *pdwRet = dwRet;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* DWORD DdDxApiOpenDirectDraw
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiOpenDirectDraw(
    DDOPENDIRECTDRAWIN*     pOpenDirectDrawIn,
    DDOPENDIRECTDRAWOUT*    pOpenDirectDrawOut,
    PKDEFERRED_ROUTINE      pfnEventDpc,
    ULONG                   DxApiPrivateVersionNumber
    )
{
    HANDLE                  hDirectDraw;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DXOBJ*                  pDxObj;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiOpenDirectDraw: Callable only at passive level (it's not pageable)");

    hDirectDraw = 0;            // Assume failure

    // We use the private version number to ensure consistency between
    // win32k.sys and dxapi.sys.  Since dxapi.sys is dynamically loaded,
    // I am worried about a scenario where a service pack is applied that
    // updates both dxapi.sys and win32k.sys -- if the machine isn't
    // rebooted, the old win32k.sys will remain loaded but the new dxapi.sys
    // may be loaded, possibly causing a crash.

    peDirectDrawLocal
        = eLockDirectDraw.peLock((HANDLE) pOpenDirectDrawIn->dwDirectDrawHandle);
    if ((peDirectDrawLocal != NULL) ||
        (DxApiPrivateVersionNumber != DXAPI_PRIVATE_VERSION_NUMBER))
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
        pDxObj = pDdDxObjHandleAllocate(DXT_DIRECTDRAW,
                                  pOpenDirectDrawIn->pfnDirectDrawClose,
                                  DDNOTIFY_CLOSEDIRECTDRAW,
                                  pOpenDirectDrawIn->pContext);
        if (pDxObj != NULL)
        {
            // Among other things, enforce synchronization while we muck
            // around in the global DirectDraw object:

            EDD_DEVLOCK eDevLock(peDirectDrawGlobal);

            peDxDirectDraw = peDirectDrawGlobal->peDxDirectDraw;
            if (peDxDirectDraw != NULL)
            {
                // Just add this object to the list hanging off the DirectDraw
                // object:

                pDxObj->peDxDirectDraw      = peDxDirectDraw;
                pDxObj->pDxObj_Next         = peDxDirectDraw->pDxObj_List;
                peDxDirectDraw->pDxObj_List = pDxObj;

                // Success!

                hDirectDraw = (HANDLE) pDxObj;
            }
            else
            {
                peDxDirectDraw = (EDD_DXDIRECTDRAW*) pDdDxObjDataAllocate(
                                                        sizeof(*peDxDirectDraw),
                                                        'dxdG');
                if (peDxDirectDraw)
                {
                    RtlZeroMemory(peDxDirectDraw, sizeof(*peDxDirectDraw));

                    pDxObj->peDxDirectDraw = peDxDirectDraw;

                    // We need to access some capabilities at raised IRQL,
                    // so copy those from the paged 'peDirectDrawGlobal'
                    // to the non-paged 'peDxDirectDraw' now:

                    peDxDirectDraw->DxApiInterface
                        = peDirectDrawGlobal->DxApiInterface;
                    peDxDirectDraw->HwDeviceExtension
                        = peDirectDrawGlobal->HwDeviceExtension;
                    peDxDirectDraw->dwIRQCaps
                        = peDirectDrawGlobal->DDKernelCaps.dwIRQCaps;
                    peDxDirectDraw->peDirectDrawGlobal
                        = peDirectDrawGlobal;
                    peDxDirectDraw->hdev
                        = peDirectDrawGlobal->hdev;

                    peDirectDrawGlobal->peDxDirectDraw = peDxDirectDraw;

                    peDxDirectDraw->pDxObj_List = pDxObj;

                    // Initialize our kernel structures use for interrupts
                    // and handling raised IRQL callers.

                    KeInitializeDpc(&peDxDirectDraw->EventDpc,
                                    pfnEventDpc,
                                    peDxDirectDraw);

                    KeInitializeSpinLock(&peDxDirectDraw->SpinLock);

                    // Success!

                    hDirectDraw = (HANDLE) pDxObj;
                }
            }

            if (!hDirectDraw)
            {
                vDdDxObjFree(pDxObj);
            }
        }
    }
    else
    {
        WARNING("DdDxApiOpenDirectDraw: Invalid dwDirectDrawHandle, failing\n");
    }

    pOpenDirectDrawOut->hDirectDraw = hDirectDraw;
    pOpenDirectDrawOut->ddRVal = (hDirectDraw != NULL) ? DD_OK : DDERR_GENERIC;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiOpenVideoPort
*
* This routine lets a driver use fields from the larger, pageable version
* of the DD_SURFACE_* structures used by the display driver to set
* fields in the smaller, non-pageable version of the corresponding
* DDSURFACEDATA structure used by the miniport.
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiOpenVideoPort(
    DDOPENVIDEOPORTIN*  pOpenVideoPortIn,
    DDOPENVIDEOPORTOUT* pOpenVideoPortOut
    )
{
    HANDLE                  hVideoPort;
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObj;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_VIDEOPORT*          peVideoPort;
    BOOL                    bFound;
    EDD_DIRECTDRAW_LOCAL*   peTempDirectDrawLocal;
    EDD_VIDEOPORT*          peTempVideoPort;


    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiOpenVideoPort: Callable only at passive level (it's not pageable)");

    hVideoPort = 0;               // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pOpenVideoPortIn->hDirectDraw;

    ASSERTGDI((pDxObjDirectDraw != NULL) &&
              (pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW),
        "DdDxApiOpenVideoPort: Invalid hDirectDraw, we're about to crash");

    peDxDirectDraw = pDxObjDirectDraw->peDxDirectDraw;

    // Among other things, enforce synchronization while we muck around
    // in the DirectDraw object:

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (!peDxDirectDraw->bLost)
    {
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;

        // We need to get a handle to the video port, so we need to
        // go looking for it.

        bFound = FALSE;
        peTempDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
        while( ( peTempDirectDrawLocal != NULL ) && !bFound )
        {
            peTempVideoPort = peTempDirectDrawLocal->peVideoPort_DdList;
            while( peTempVideoPort != NULL )
            {
                if( peTempVideoPort->ddvpDesc.dwVideoPortID == pOpenVideoPortIn->dwVideoPortHandle )
                {
                    bFound = TRUE;
                    break;
                }
                peTempVideoPort = peTempVideoPort->peVideoPort_DdNext;
            }
            peTempDirectDrawLocal = peTempDirectDrawLocal->peDirectDrawLocalNext;
        }
        if( bFound )
        {
            peVideoPort = eLockVideoPort.peLock(
                (HANDLE) peTempVideoPort->hGet());
            if ((peVideoPort != NULL) &&
                (peVideoPort->peDirectDrawGlobal == peDirectDrawGlobal))
            {
                pDxObj = pDdDxObjHandleAllocate(DXT_VIDEOPORT,
                                      pOpenVideoPortIn->pfnVideoPortClose,
                                      DDNOTIFY_CLOSEVIDEOPORT,
                                      pOpenVideoPortIn->pContext);
                if (pDxObj != NULL)
                {

                    peDxVideoPort = peVideoPort->peDxVideoPort;
                    if (peDxVideoPort != NULL)
                    {
                        // Just add this object to the list hanging off the
                        // surface object:

                        pDxObj->peDxVideoPort      = peDxVideoPort;
                        pDxObj->pDxObj_Next        = peDxVideoPort->pDxObj_List;
                        peDxVideoPort->pDxObj_List = pDxObj;

                        // Success!

                        hVideoPort = (HANDLE) pDxObj;
                    }
                    else
                    {
                        peDxVideoPort = (EDD_DXVIDEOPORT*) pDdDxObjDataAllocate(
                                                        sizeof(*peDxVideoPort),
                                                        'sxdG');
                        if (peDxVideoPort)
                        {
                            RtlZeroMemory(peDxVideoPort, sizeof(*peDxVideoPort));

                            pDxObj->peDxVideoPort = peDxVideoPort;

                            peVideoPort->peDxVideoPort = peDxVideoPort;

                            peDxVideoPort->pDxObj_List    = pDxObj;
                            peDxVideoPort->peVideoPort    = peVideoPort;
                            peDxVideoPort->peDxDirectDraw = peDxDirectDraw;

                            peDxVideoPort->iCurrentVideo  = 1;
                            peDxVideoPort->dwVideoPortID
                                = peVideoPort->ddvpDesc.dwVideoPortID;

                            vDdSynchronizeVideoPort(peVideoPort);

                            // Success!

                            hVideoPort = (HANDLE) pDxObj;
                        }
                    }

                    if (!hVideoPort)
                    {
                        vDdDxObjFree(pDxObj);
                    }
                }
            }
            else
            {
                WARNING("DdDxApiOpenVideoPort: Invalid dwSurfaceHandle, failing.\n");
            }
        }
        else
        {
            WARNING("DdDxApiOpenVideoPort: Invalid dwSurfaceHandle, failing.\n");
        }
    }
    else
    {
        WARNING("DdDxApiOpenVideoPort: DirectDraw object is lost");
    }

    pOpenVideoPortOut->hVideoPort = hVideoPort;
    pOpenVideoPortOut->ddRVal = (hVideoPort != NULL) ? DD_OK : DDERR_GENERIC;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiOpenSurface
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiOpenSurface(
    DDOPENSURFACEIN*    pOpenSurfaceIn,
    DDOPENSURFACEOUT*   pOpenSurfaceOut
    )
{
    HANDLE                  hSurface;
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObj;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXSURFACE*          peDxSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiOpenSurface: Callable only at passive level (it's not pageable)");

    hSurface = 0;               // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pOpenSurfaceIn->hDirectDraw;

    ASSERTGDI((pDxObjDirectDraw != NULL) &&
              (pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW),
        "DdDxApiOpenSurface: Invalid hDirectDraw, we're about to crash");

    peDxDirectDraw = pDxObjDirectDraw->peDxDirectDraw;

    // Among other things, enforce synchronization while we muck around
    // in the DirectDraw object:

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (!peDxDirectDraw->bLost)
    {
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;

        peSurface = eLockSurface.peLock((HANDLE) pOpenSurfaceIn->dwSurfaceHandle);
        if ((peSurface != NULL) &&
            (peSurface->peDirectDrawGlobal == peDirectDrawGlobal))
        {
            pDxObj = pDdDxObjHandleAllocate(DXT_SURFACE,
                                      pOpenSurfaceIn->pfnSurfaceClose,
                                      DDNOTIFY_CLOSESURFACE,
                                      pOpenSurfaceIn->pContext);
            if (pDxObj != NULL)
            {
                peDxSurface = peSurface->peDxSurface;
                if (peDxSurface != NULL)
                {
                    // Just add this object to the list hanging off the
                    // surface object:

                    pDxObj->peDxSurface      = peDxSurface;
                    pDxObj->pDxObj_Next      = peDxSurface->pDxObj_List;
                    peDxSurface->pDxObj_List = pDxObj;

                    // Success!

                    hSurface = (HANDLE) pDxObj;
                }
                else
                {
                    peDxSurface = (EDD_DXSURFACE*) pDdDxObjDataAllocate(
                                                        sizeof(*peDxSurface),
                                                        'sxdG');
                    if (peDxSurface)
                    {
                        RtlZeroMemory(peDxSurface, sizeof(*peDxSurface));

                        pDxObj->peDxSurface = peDxSurface;

                        peSurface->peDxSurface = peDxSurface;

                        peDxSurface->pDxObj_List    = pDxObj;
                        peDxSurface->peSurface      = peSurface;
                        peDxSurface->peDxDirectDraw = peDxDirectDraw;
                        if( peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &
                            DDCAPS2_CANBOBINTERLEAVED )
                        {
                            peDxSurface->flFlags |= DD_DXSURFACE_FLAG_CAN_BOB_INTERLEAVED;
                        }
                        if( peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &
                            DDCAPS2_CANBOBNONINTERLEAVED )
                        {
                            peDxSurface->flFlags |= DD_DXSURFACE_FLAG_CAN_BOB_NONINTERLEAVED;
                        }

                        // Success!

                        hSurface = (HANDLE) pDxObj;
                    }
                }

                vDdSynchronizeSurface(peSurface);

                if (!hSurface)
                {
                    vDdDxObjFree(pDxObj);
                }
            }
        }
        else
        {
            WARNING("DdDxApiOpenSurface: Invalid dwSurfaceHandle, failing.\n");
        }
    }
    else
    {
        WARNING("DdDxApiOpenSurface: DirectDraw object lost\n");
    }

    pOpenSurfaceOut->hSurface = hSurface;
    pOpenSurfaceOut->ddRVal = (hSurface != NULL) ? DD_OK : DDERR_GENERIC;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiCloseHandle
*
*  14-Apr-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiCloseHandle(
    DDCLOSEHANDLE*  pCloseHandle,
    DWORD*          pdwRet
    )
{
    DXOBJ*  pDxObj = (DXOBJ*) pCloseHandle->hHandle;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiCloseHandle: Callable only at passive level (it's not pageable)");
    ASSERTGDI(pCloseHandle->hHandle != NULL,
        "DdDxApiCloseHandle: Trying to close NULL handle");

    switch(pDxObj->iDxType)
    {
    case DXT_DIRECTDRAW:
        vDdDxApiFreeDirectDraw(pDxObj, TRUE);
        break;

    case DXT_VIDEOPORT:
        vDdDxApiFreeVideoPort(pDxObj, FALSE);
        break;

    case DXT_SURFACE:
        vDdDxApiFreeSurface(pDxObj, FALSE);
        break;

    case DXT_CAPTURE:
        vDdDxApiFreeCapture(pDxObj, FALSE);
        break;

    case DXT_INVALID:
        RIP("DdDxApiCloseHandle: Invalid surface.  Same handle probably closed twice");
        break;

    default:
        RIP("DdDxApiCloseHandle: Invalid surface.");
        break;
    }

    *pdwRet = DD_OK;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiOpenCaptureDevice
*
*  01-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiOpenCaptureDevice(
    DDOPENVPCAPTUREDEVICEIN*  pOpenCaptureDeviceIn,
    DDOPENVPCAPTUREDEVICEOUT* pOpenCaptureDeviceOut
    )
{
    HANDLE                  hCaptureDevice;
    DXOBJ*                  pDxObjDirectDraw;
    DXOBJ*                  pDxObjVideoPort;
    DXOBJ*                  pDxObj;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DXVIDEOPORT*        peDxVideoPort;
    EDD_DXCAPTURE*          peDxCapture;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DWORD                   dwRet;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiOpenVideoPort: Callable only at passive level (it's not pageable)");

    hCaptureDevice = 0;               // Assume failure

    pDxObjDirectDraw = (DXOBJ*) pOpenCaptureDeviceIn->hDirectDraw;
    pDxObjVideoPort  = (DXOBJ*) pOpenCaptureDeviceIn->hVideoPort;

    ASSERTGDI((pDxObjDirectDraw != NULL) &&
              (pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW),
        "DdDxApiOpenCaptureDevice: Invalid hDirectDraw, we're about to crash");
    ASSERTGDI((pDxObjVideoPort != NULL) &&
              (pDxObjVideoPort->iDxType == DXT_VIDEOPORT),
        "DdDxApiOpenCaptureDevice: Invalid hVideoPort, we're about to crash");

    peDxDirectDraw = pDxObjDirectDraw->peDxDirectDraw;
    peDxVideoPort  = pDxObjVideoPort->peDxVideoPort;

    ASSERTGDI((pOpenCaptureDeviceIn->dwFlags == DDOPENCAPTURE_VIDEO) ||
              (pOpenCaptureDeviceIn->dwFlags == DDOPENCAPTURE_VBI),
        "DdDxApiOpenCaptureDevice: Invalid flags specified");
    ASSERTGDI((pOpenCaptureDeviceIn->dwCaptureEveryNFields != 0),
        "DdDxApiOpenCaptureDevice: Invalid dwCaptureEveryNFields specified");
    ASSERTGDI((pOpenCaptureDeviceIn->pfnCaptureClose != 0),
        "DdDxApiOpenCaptureDevice: Invalid pfnCaptureClose specified");

    // Among other things, enforce synchronization while we muck around
    // in the DirectDraw object:

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    dwRet = DDERR_INVALIDPARAMS;
    if ((!peDxDirectDraw->bLost) &&
        (!peDxVideoPort->bLost))
    {
        // Only do this if the device actually supports capturing

       dwRet = DDERR_CURRENTLYNOTAVAIL;
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;
        if ((peDirectDrawGlobal->DDKernelCaps.dwCaps &
            (DDKERNELCAPS_CAPTURE_SYSMEM|DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM)) &&
            (peDxDirectDraw->DxApiInterface.DxTransfer != NULL))
        {
#if 0 // fix bug 169385
            // See capturing target is matched.

            if (((pOpenCaptureDeviceIn->dwFlags & DDOPENCAPTURE_VBI) &&
                 (peDxVideoPort->cAutoflipVbi > 0)) ||
                ((pOpenCaptureDeviceIn->dwFlags & DDOPENCAPTURE_VIDEO) &&
                 (peDxVideoPort->cAutoflipVideo > 0)))
            {
#endif
                // Allocate the object. We only allow one handle per object.

                dwRet = DDERR_OUTOFMEMORY;
                pDxObj = pDdDxObjHandleAllocate(DXT_CAPTURE,
                                          pOpenCaptureDeviceIn->pfnCaptureClose,
                                          DDNOTIFY_CLOSECAPTURE,
                                          pOpenCaptureDeviceIn->pContext);
                if (pDxObj != NULL)
                {
                    peDxCapture = (EDD_DXCAPTURE*) pDdDxObjDataAllocate(
                                                       sizeof(*peDxCapture),
                                                       'sxdG');
                    if (peDxCapture)
                    {
                        RtlZeroMemory(peDxCapture, sizeof(*peDxCapture));
    
                        pDxObj->peDxCapture = peDxCapture;

                        peDxCapture->pDxObj_List    = pDxObj;
                        peDxCapture->peDxVideoPort  = peDxVideoPort;
                        peDxCapture->dwStartLine    = pOpenCaptureDeviceIn->dwStartLine;
                        peDxCapture->dwEndLine      = pOpenCaptureDeviceIn->dwEndLine;
                        peDxCapture->dwCaptureCountDown = 1;
                        peDxCapture->dwCaptureEveryNFields =
                             pOpenCaptureDeviceIn->dwCaptureEveryNFields;
                        if (pOpenCaptureDeviceIn->dwFlags & DDOPENCAPTURE_VBI )
                        {
                            peDxCapture->flFlags = DD_DXCAPTURE_FLAG_VBI;
                        }
                        else
                        {
                            peDxCapture->flFlags = DD_DXCAPTURE_FLAG_VIDEO;
                        }

                        // Now we need to put the capture object into the list
                        // of active capture objects, but since this list is
                        // walked at DPC time, we need to call DxApi to do this.

                        peDirectDrawGlobal->pfnUpdateCapture( peDxVideoPort,
                            peDxCapture, FALSE );

                        // Success!

                        hCaptureDevice = (HANDLE) pDxObj;
                        dwRet = DD_OK;
                    }

                    if (!hCaptureDevice)
                    {
                        vDdDxObjFree(pDxObj);
                    }
                }
#if 0 // fix bug 169385
            }
            else
            {
                WARNING("DdDxApiOpenCaptureDevice: VideoPort doesn't have surface requested by driver.\n");
            }
#endif

        }
        else
        {
            WARNING("DdDxApiOpenCaptureDevice: Device does not support capture, failing.\n");
        }
    }
    else
    {
        WARNING("DdDxApiOpenCaptureDevice: DirectDraw or VideoPort object is not valid, failing.\n");
    }

    pOpenCaptureDeviceOut->hCapture = hCaptureDevice;
    pOpenCaptureDeviceOut->ddRVal = dwRet;
}

/******************************Public*Routine******************************\
* DWORD DdDxApiGetKernelCaps
*
*  01-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DdDxApiGetKernelCaps(
    HANDLE              hDirectDraw,
    DDGETKERNELCAPSOUT* pGetKernelCaps
    )
{
    DXOBJ*                  pDxObjDirectDraw;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    ASSERTGDI(KeGetCurrentIrql() == PASSIVE_LEVEL,
        "DdDxApiGetKernelCaps: Callable only at passive level (it's not pageable)");

    pDxObjDirectDraw = (DXOBJ*) hDirectDraw;

    ASSERTGDI((pDxObjDirectDraw != NULL) &&
              (pDxObjDirectDraw->iDxType == DXT_DIRECTDRAW),
        "DdDxApiGetKernelCaps: Invalid hDirectDraw, we're about to crash");

    peDxDirectDraw = pDxObjDirectDraw->peDxDirectDraw;

    // Among other things, enforce synchronization while we muck around
    // in the DirectDraw object:

    EDD_DEVLOCK eDevLock(peDxDirectDraw->hdev);

    if (!peDxDirectDraw->bLost)
    {
        peDirectDrawGlobal = peDxDirectDraw->peDirectDrawGlobal;

        pGetKernelCaps->ddRVal = DD_OK;
        pGetKernelCaps->dwCaps =   peDirectDrawGlobal->DDKernelCaps.dwCaps;
        pGetKernelCaps->dwIRQCaps = peDirectDrawGlobal->DDKernelCaps.dwIRQCaps;
    }
    else
    {
        pGetKernelCaps->ddRVal = DXERR_OUTOFCAPS;
        pGetKernelCaps->dwCaps =   0;
        pGetKernelCaps->dwIRQCaps = 0;
    }
}

/******************************Public*Routine******************************\
* VOID DdDxApiLockDevice
*
*  05-Jun-1998 -by- agodfrey
\**************************************************************************/

VOID
APIENTRY
DdDxApiLockDevice(
    HDEV hdev
    )
{
    DxEngLockHdev(hdev);
}

/******************************Public*Routine******************************\
* VOID DdDxApiUnlockDevice
*
*  05-Jun-1998 -by- agodfrey
\**************************************************************************/

VOID
APIENTRY
DdDxApiUnlockDevice(
    HDEV hdev
    )
{
    DxEngUnlockHdev(hdev);
}

/******************************Public*Routine******************************\
* DWORD DxDvpCanCreateVideoPort
*
* Queries the driver to determine whether it can support a DirectDraw
* videoPort.
*
*  3-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpCanCreateVideoPort(
    HANDLE                   hDirectDraw,
    PDD_CANCREATEVPORTDATA   puCanCreateVPortData
    )
{
    DWORD                   dwRet;
    DD_CANCREATEVPORTDATA   CanCreateVideoPort;
    DDVIDEOPORTDESC         VideoPortDescription;

    __try
    {
        CanCreateVideoPort
            = ProbeAndReadStructure(puCanCreateVPortData,
                                    DD_CANCREATEVPORTDATA);

        VideoPortDescription
            = ProbeAndReadStructure(CanCreateVideoPort.lpDDVideoPortDesc,
                                    DDVIDEOPORTDESC);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                     = DDHAL_DRIVER_NOTHANDLED;
    CanCreateVideoPort.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);

    // For now, do now enable VPE on Terminal Server due to problems
    // loading DXAPI.SYS into session space vs. non-session space

    {
        if (peDirectDrawLocal != NULL)
        {
            peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

            CanCreateVideoPort.lpDD              = peDirectDrawGlobal;
            CanCreateVideoPort.lpDDVideoPortDesc = &VideoPortDescription;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((!peDirectDrawGlobal->bSuspended) &&
                (peDirectDrawGlobal->VideoPortCallBacks.CanCreateVideoPort))
            {
                dwRet = peDirectDrawGlobal->
                    VideoPortCallBacks.CanCreateVideoPort(&CanCreateVideoPort);
            }
        }
        else
        {
            WARNING("DxDvpCanCreateSurface: Invalid object\n");
        }
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puCanCreateVPortData->ddRVal,
                          CanCreateVideoPort.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(dwRet);
}


/*****************************Private*Routine******************************\
* HANDLE DxDvpCreateVideoPort
*
* Notifies the HAL after a video port is created.
*
* This is an optional call for the driver, but we always have to 'hook'
* this call from user-mode DirectDraw.
*
* Question: A user-mode application could have absolute garbage in
*           lpDDVideoPortDesc and get it by the driver, because the
*           driver would only be monitoring for invalid data in its
*           CanCreateVideoPort call.  So should we call the driver's
*           CanCreateVideoPort here in this routine before calling
*           CreateVideoPort?
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDvpCreateVideoPort(
    HANDLE              hDirectDraw,
    PDD_CREATEVPORTDATA puCreateVPortData
    )
{
    HANDLE                  hRet;
    DWORD                   dwRet;
    DD_CREATEVPORTDATA      CreateVPortData;
    DDVIDEOPORTDESC         VideoPortDescription;
    BOOL                    bFirst;

    __try
    {
        CreateVPortData =
            ProbeAndReadStructure(puCreateVPortData,
                                  DD_CREATEVPORTDATA);

        VideoPortDescription
            = ProbeAndReadStructure(CreateVPortData.lpDDVideoPortDesc,
                                    DDVIDEOPORTDESC);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    hRet                   = 0;
    CreateVPortData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_VIDEOPORT*          peVideoPort;

    // The two items below where triple bang comments are are somewhat cryptic.
    //
    // 1. Ensure that not more than one VideoPort created
    // 2. Scott allows CanCreateVideoPort and CreateVideoPort to be optional

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);

    // For now, enable VPE on Terminal Server due to conflicts loading in
    // session space vs. non-session sapce.

    {
        if (peDirectDrawLocal != NULL)
        {
            peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

            // Here we do the minimal validations checks to ensure that bad
            // parameters won't crash NT.  We're not more strict than
            // checking for stuff that will crash us, as the user-mode part
            // of DirectDraw handles that.

            if (VideoPortDescription.dwVideoPortID <
                peDirectDrawGlobal->HalInfo.ddCaps.dwMaxVideoPorts)
            {

                // Check for the case where a video port has been created for
                // VBI or video and we are now creating the other one, in which
                // case we use the existing video port.

                peVideoPort = peDirectDrawLocal->peVideoPort_DdList;
                while ((peVideoPort != NULL) && 
                    (peVideoPort->ddvpDesc.dwVideoPortID != VideoPortDescription.dwVideoPortID))
                {
                    peVideoPort = peVideoPort->peVideoPort_DdNext;
                }
                if (peVideoPort != NULL)
                {
                    peVideoPort->ddvpDesc = VideoPortDescription;
                    CreateVPortData.ddRVal = DD_OK;
                    hRet = peVideoPort->hGet();
                }
                else
                {
                    peVideoPort = (EDD_VIDEOPORT*) DdHmgAlloc(sizeof(EDD_VIDEOPORT),
                                                        DD_VIDEOPORT_TYPE,
                                                        HMGR_ALLOC_LOCK);
            
                    if (peVideoPort)
                    {
                        // Private data:

                        peVideoPort->peDirectDrawGlobal = peDirectDrawGlobal;
                        peVideoPort->peDirectDrawLocal = peDirectDrawLocal;

                        // Public data:
    
                        peVideoPort->lpDD     = peDirectDrawGlobal;
                        peVideoPort->ddvpDesc = VideoPortDescription;

                        // Hold devlock for driver call and for bDdEnableSoftware
                        // Autoflipping.

                        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                        // Add this videoport to the list hanging off the
                        // DirectDrawLocal object allocated for this process:

                        bFirst = peDirectDrawLocal->peVideoPort_DdList == NULL;
                        peVideoPort->peVideoPort_DdNext
                            = peDirectDrawLocal->peVideoPort_DdList;
                        peDirectDrawLocal->peVideoPort_DdList
                            = peVideoPort;

                        // Now call the driver to create its version:

                        CreateVPortData.lpDD              = peDirectDrawGlobal;
                        CreateVPortData.lpDDVideoPortDesc = &VideoPortDescription;
                        CreateVPortData.lpVideoPort       = peVideoPort;
                        CreateVPortData.ddRVal            = DDERR_GENERIC;

                        dwRet = DDHAL_DRIVER_NOTHANDLED;    // Call is optional
                        if ((!peDirectDrawGlobal->bSuspended) &&
                            (peDirectDrawGlobal->VideoPortCallBacks.CreateVideoPort))
                        {
                            dwRet = peDirectDrawGlobal->
                                VideoPortCallBacks.CreateVideoPort(&CreateVPortData);
                        }

                        if ((dwRet == DDHAL_DRIVER_NOTHANDLED) ||
                            (CreateVPortData.ddRVal == DD_OK))
                        {
                            CreateVPortData.ddRVal = DD_OK;
                            peVideoPort->fl |= DD_VIDEOPORT_FLAG_DRIVER_CREATED;
                        }
                        else
                        {
                            WARNING("DxDvpCreateVideoPort: Driver failed call\n");
                        }

                        if ((CreateVPortData.ddRVal == DD_OK) &&
                            (bDdEnableSoftwareAutoflipping(peDirectDrawLocal,
                                                       peVideoPort,
                                                       VideoPortDescription.dwVideoPortID,
                                                       bFirst)))
                        {
                            // Success!

                            hRet = peVideoPort->hGet();

                            DEC_EXCLUSIVE_REF_CNT( peVideoPort );
                        }
                        else
                        {
                            bDdDeleteVideoPortObject(peVideoPort->hGet(), NULL);

                            CreateVPortData.ddRVal = DDERR_GENERIC;
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDvpCreateVideoPort: Bad parameters\n");
            }
        }
        else
        {
            WARNING("DxDvpCreateVideoPort: Invalid object\n");
        }
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puCreateVPortData->ddRVal, CreateVPortData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // Note that the user-mode stub always returns DDHAL_DRIVER_HANDLED
    // to DirectDraw.

    return(hRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpDestroyVideoPort
*
* Notifies the HAL when the video port is destroyed.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpDestroyVideoPort(
    HANDLE                  hVideoPort,
    PDD_DESTROYVPORTDATA    puDestroyVPortData
    )
{
    DWORD   dwRet;

    bDdDeleteVideoPortObject(hVideoPort, &dwRet);

    __try
    {
        ProbeAndWriteRVal(&puDestroyVPortData->ddRVal, DD_OK);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpFlipVideoPort
*
* Performs the physical flip, causing the video port to start writing data
* to the new surface.  This does not affect the actual display of this data.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpFlipVideoPort(
    HANDLE              hVideoPort,
    HANDLE              hDDSurfaceCurrent,
    HANDLE              hDDSurfaceTarget,
    PDD_FLIPVPORTDATA   puFlipVPortData
    )
{
    DWORD               dwRet;
    DD_FLIPVPORTDATA    FlipVPortData;

    dwRet                   = DDHAL_DRIVER_NOTHANDLED;
    FlipVPortData.ddRVal    = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    // 1. Make sure they're videoport surfaces, and compatible, not system surfaces?
    // 2. Make sure not software autoflipping?

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;
        if (peDirectDrawGlobal->VideoPortCallBacks.FlipVideoPort)
        {
            EDD_SURFACE*     peSurfaceCurrent;
            EDD_SURFACE*     peSurfaceTarget;
            EDD_LOCK_SURFACE eLockSurfaceCurrent;
            EDD_LOCK_SURFACE eLockSurfaceTarget;

            peSurfaceCurrent = eLockSurfaceCurrent.peLock(hDDSurfaceCurrent);
            peSurfaceTarget  = eLockSurfaceTarget.peLock(hDDSurfaceTarget);

            if ((peSurfaceCurrent != NULL)                                   &&
                (peSurfaceTarget != NULL)                                    &&
                (peSurfaceCurrent->peDirectDrawGlobal == peDirectDrawGlobal) &&
                (peSurfaceCurrent->peDirectDrawLocal
                    == peSurfaceTarget->peDirectDrawLocal))
            {
                FlipVPortData.lpDD        = peDirectDrawGlobal;
                FlipVPortData.lpVideoPort = peVideoPort;
                FlipVPortData.lpSurfCurr  = peSurfaceCurrent;
                FlipVPortData.lpSurfTarg  = peSurfaceTarget;

                {
                    EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                    if ((!peDirectDrawGlobal->bSuspended) &&
                        (peDirectDrawGlobal->VideoPortCallBacks.FlipVideoPort))
                    {
                         dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                                        FlipVideoPort(&FlipVPortData);
                    }
                }

                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                    (FlipVPortData.ddRVal == DD_OK))
                {
                    peVideoPort->lpSurface  = peSurfaceTarget;
                }
            }
            else
            {
                WARNING("DxDvpFlipVPort: Invalid source or target surface\n");
            }
        }
        else
        {
             WARNING("DxDvpFlipVPort: Driver doesn't hook call\n");
        }
    }
    else
    {
        WARNING("DxDvpFlipVPort: Invalid object\n");
    }

    __try
    {
        ProbeAndWriteRVal(&puFlipVPortData->ddRVal, FlipVPortData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxGetVideoPortBandwidth
*
* Informs the client of bandwidth requirements for any specified format,
* allowing them to better chose a format and to understand its limitations.
* This information can only be given after the video port object is created
* because the information in the DDVIDEOPORTDESC structure is required before
* accurate bandwidth information can be supplied.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortBandwidth(
    HANDLE                      hVideoPort,
    PDD_GETVPORTBANDWIDTHDATA   puGetVPortBandwidthData
    )
{
    DWORD                       dwRet;
    DD_GETVPORTBANDWIDTHDATA    GetVPortBandwidthData;
    LPDDPIXELFORMAT             pddpfFormat;
    DDPIXELFORMAT               ddpfFormat;
    DDVIDEOPORTBANDWIDTH        Bandwidth;
    LPDDVIDEOPORTBANDWIDTH      puBandwidth;

    __try
    {
        GetVPortBandwidthData = ProbeAndReadStructure(puGetVPortBandwidthData,
                                                      DD_GETVPORTBANDWIDTHDATA);

        ddpfFormat = ProbeAndReadStructure(GetVPortBandwidthData.lpddpfFormat,
                                           DDPIXELFORMAT);

        puBandwidth = GetVPortBandwidthData.lpBandwidth;

        Bandwidth = ProbeAndReadStructure(puBandwidth,DDVIDEOPORTBANDWIDTH);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                        = DDHAL_DRIVER_NOTHANDLED;
    GetVPortBandwidthData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        if (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortBandwidth)
        {
            GetVPortBandwidthData.lpDD         = peDirectDrawGlobal;
            GetVPortBandwidthData.lpVideoPort  = peVideoPort;
            GetVPortBandwidthData.lpBandwidth  = &Bandwidth;
            GetVPortBandwidthData.lpddpfFormat = &ddpfFormat;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((!peDirectDrawGlobal->bSuspended) &&
                (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortBandwidth))
            {
                dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                    GetVideoPortBandwidth(&GetVPortBandwidthData);
            }
        }
        else
        {
            WARNING("DxDvpGetVPortBandwidthData: Driver doesn't hook call\n");
        }
    }
    else
    {
        WARNING("DxDvpGetVPortBandwidthData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteStructure(puBandwidth, Bandwidth, DDVIDEOPORTBANDWIDTH);

        ProbeAndWriteRVal(&puGetVPortBandwidthData->ddRVal,
                          GetVPortBandwidthData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpGetVideoPortField
*
* Sets bField to TRUE if the current field is the even field of an
* interlaced signal.  Otherwise, bField is set to FALSE.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortField(
    HANDLE                  hVideoPort,
    PDD_GETVPORTFIELDDATA   puGetVPortFieldData
    )
{
    DWORD                   dwRet;
    DD_GETVPORTFIELDDATA    GetVPortFieldData;

    __try
    {
        GetVPortFieldData = ProbeAndReadStructure(puGetVPortFieldData,
                                                  DD_GETVPORTFIELDDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_NOTHANDLED;
    GetVPortFieldData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortFieldData.lpDD        = peDirectDrawGlobal;
        GetVPortFieldData.lpVideoPort = peVideoPort;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortField))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoPortField(&GetVPortFieldData);
        }
    }
    else
    {
        WARNING("DxDvpCanGetVPortFieldData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortFieldData->ddRVal,
                          GetVPortFieldData.ddRVal);
        ProbeAndWriteStructure(&puGetVPortFieldData->bField,
                               GetVPortFieldData.bField,
                               BOOL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpGetVideoPortFlipStatus
*
* Returns DDERR_WASSTILLDRAWING if a video VSYNC has not occurred since the
* flip was performed on the specified surface.  This function allows DDRAW.DLL
* to fail locks on a surface that was recently flipped from so the HAL doesn't
* have to account for this.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortFlipStatus(
    HANDLE                      hDirectDraw,
    PDD_GETVPORTFLIPSTATUSDATA  puGetVPortFlipStatusData
    )
{
    DWORD                        dwRet;
    DD_GETVPORTFLIPSTATUSDATA    GetVPortFlipStatusData;

    __try
    {
        GetVPortFlipStatusData = ProbeAndReadStructure(puGetVPortFlipStatusData,
                                                       DD_GETVPORTFLIPSTATUSDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                         = DDHAL_DRIVER_NOTHANDLED;
    GetVPortFlipStatusData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetVPortFlipStatusData.lpDD = peDirectDrawGlobal;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortFlipStatus))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoPortFlipStatus(
                    &GetVPortFlipStatusData);
        }
    }
    else
    {
        WARNING("DxDvpCanGetVPortFlipStatusData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortFlipStatusData->ddRVal,
                          GetVPortFlipStatusData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpGetVideoPortInputFormats
*
* Fills in the specified array with all of the formats that the video port
* can accept and puts that number in dwNumFormats.  If lpddpfFormats is NULL,
* it only fills in dwNumFormats with the number of formats that it can support.
* This function is needed because the supported formats may vary depending on
* the electrical connection of the video port.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortInputFormats(
    HANDLE                      hVideoPort,
    PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData
    )
{
    DWORD                       dwRet;
    DD_GETVPORTINPUTFORMATDATA  GetVPortInputFormatData;
    LPDDPIXELFORMAT             puFormat;
    ULONG                       cjFormat;
    HANDLE                      hSecure;

    __try
    {
        GetVPortInputFormatData
            = ProbeAndReadStructure(puGetVPortInputFormatData,
                                    DD_GETVPORTINPUTFORMATDATA);

        puFormat = GetVPortInputFormatData.lpddpfFormat;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                          = DDHAL_DRIVER_NOTHANDLED;
    GetVPortInputFormatData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortInputFormatData.lpDD         = peDirectDrawGlobal;
        GetVPortInputFormatData.lpVideoPort  = peVideoPort;
        GetVPortInputFormatData.lpddpfFormat = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortInputFormats))
        {
            dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortInputFormats(&GetVPortInputFormatData);

            cjFormat = GetVPortInputFormatData.dwNumFormats
                     * sizeof(DDPIXELFORMAT);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetVPortInputFormatData.ddRVal == DD_OK) &&
                (cjFormat > 0) &&
                (puFormat != NULL) &&
                !BALLOC_OVERFLOW1(GetVPortInputFormatData.dwNumFormats, DDPIXELFORMAT))
            {
                GetVPortInputFormatData.ddRVal = DDERR_GENERIC;
                hSecure = 0;

                __try
                {
                    ProbeForWrite(puFormat, cjFormat, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puFormat,
                                                    cjFormat,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetVPortInputFormatData.lpddpfFormat = puFormat;

                    dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortInputFormats(&GetVPortInputFormatData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDvpGetVideoPortInputFormats: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDvpGetVPortInputFormatData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortInputFormatData->ddRVal,
                          GetVPortInputFormatData.ddRVal);
        ProbeAndWriteUlong(&puGetVPortInputFormatData->dwNumFormats,
                           GetVPortInputFormatData.dwNumFormats);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpGetVideoPortOutputFormats
*
* Fills in the specified array with all of the formats that can be written
* to the frame buffer based on the specified input format and puts that
* number in dwNumFormats.  If lpddpfOutputFormats is NULL, it only fills
* in dwNumFormats with the number of formats that can be written to the
* frame buffer.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortOutputFormats(
    HANDLE                          hVideoPort,
    PDD_GETVPORTOUTPUTFORMATDATA    puGetVPortOutputFormatData
    )
{
    DWORD                           dwRet;
    DD_GETVPORTOUTPUTFORMATDATA     GetVPortOutputFormatData;
    LPDDPIXELFORMAT                 puOutputFormats;
    DDPIXELFORMAT                   ddpfInputFormat;
    ULONG                           cjFormat;
    HANDLE                          hSecure;

    __try
    {
        GetVPortOutputFormatData
            = ProbeAndReadStructure(puGetVPortOutputFormatData,
                                    DD_GETVPORTOUTPUTFORMATDATA);

        ddpfInputFormat
            = ProbeAndReadStructure(GetVPortOutputFormatData.lpddpfInputFormat,
                                    DDPIXELFORMAT);

        puOutputFormats = GetVPortOutputFormatData.lpddpfOutputFormats;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                           = DDHAL_DRIVER_NOTHANDLED;
    GetVPortOutputFormatData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortOutputFormatData.lpDD                = peDirectDrawGlobal;
        GetVPortOutputFormatData.lpVideoPort         = peVideoPort;
        GetVPortOutputFormatData.lpddpfInputFormat   = &ddpfInputFormat;
        GetVPortOutputFormatData.lpddpfOutputFormats = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortOutputFormats))
        {
            dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortOutputFormats(&GetVPortOutputFormatData);

            cjFormat = GetVPortOutputFormatData.dwNumFormats
                     * sizeof(DDPIXELFORMAT);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetVPortOutputFormatData.ddRVal == DD_OK) &&
                (cjFormat > 0) &&
                (puOutputFormats != NULL) &&
                !BALLOC_OVERFLOW1(GetVPortOutputFormatData.dwNumFormats, DDPIXELFORMAT))
            {
                GetVPortOutputFormatData.ddRVal = DDERR_GENERIC;
                hSecure = 0;

                __try
                {
                    ProbeForWrite(puOutputFormats,
                                  cjFormat,
                                  sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puOutputFormats,
                                                    cjFormat,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetVPortOutputFormatData.lpddpfOutputFormats
                        = puOutputFormats;

                    dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortOutputFormats(&GetVPortOutputFormatData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDvpGetVideoPortOutputFormats: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDvpGetVPortOutputFormatData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortOutputFormatData->ddRVal,
                          GetVPortOutputFormatData.ddRVal);
        ProbeAndWriteUlong(&puGetVPortOutputFormatData->dwNumFormats,
                           GetVPortOutputFormatData.dwNumFormats);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxGetVideoPortLine
*
* Returns the current line counter of the video port.
*
* This function is only required if the driver sets the DDVPCAPS_READBACKLINE
* flag.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortLine(
    HANDLE                  hVideoPort,
    PDD_GETVPORTLINEDATA    puGetVPortLineData
    )
{
    DWORD               dwRet;
    DD_GETVPORTLINEDATA GetVPortLineData;

    dwRet                      = DDHAL_DRIVER_NOTHANDLED;
    GetVPortLineData.ddRVal    = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortLineData.lpDD        = peDirectDrawGlobal;
        GetVPortLineData.lpVideoPort = peVideoPort;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortLine))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoPortLine(&GetVPortLineData);
        }
    }
    else
    {
        WARNING("DxDvpGetVPortLineData: Invalid object\n");
    }

    __try
    {
        ProbeAndWriteStructure(puGetVPortLineData,
                               GetVPortLineData,
                               DD_GETVPORTLINEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxGetVideoPortConnectInfo
*
* Fills in the specified array with all of the connection combinations
* supported by the specified video port and puts that number in dwNumEntries.
* If lpConnect is NULL, it only fills in dwNumEntries with the number of
* DDVIDEOPORTCONNECT entries supported.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoPortConnectInfo(
    HANDLE                  hDirectDraw,
    PDD_GETVPORTCONNECTDATA puGetVPortConnectData
    )
{
    DWORD                   dwRet;
    DD_GETVPORTCONNECTDATA  GetVPortConnectData;
    DDVIDEOPORTCONNECT*     puConnect;
    ULONG                   cjConnect;
    HANDLE                  hSecure;

    __try
    {
        GetVPortConnectData = ProbeAndReadStructure(puGetVPortConnectData,
                                                    DD_GETVPORTCONNECTDATA);

        puConnect = GetVPortConnectData.lpConnect;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                      = DDHAL_DRIVER_NOTHANDLED;
    GetVPortConnectData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetVPortConnectData.lpDD      = peDirectDrawGlobal;
        GetVPortConnectData.lpConnect = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoPortConnectInfo))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoPortConnectInfo(
                    &GetVPortConnectData);

            cjConnect = GetVPortConnectData.dwNumEntries
                      * sizeof(DDVIDEOPORTCONNECT);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetVPortConnectData.ddRVal == DD_OK) &&
                (cjConnect > 0) &&
                (puConnect != NULL) &&
                !BALLOC_OVERFLOW1(GetVPortConnectData.dwNumEntries, DDVIDEOPORTCONNECT))
            {
                GetVPortConnectData.ddRVal = DDERR_GENERIC;
                hSecure = 0;

                __try
                {
                    ProbeForWrite(puConnect, cjConnect, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puConnect,
                                                    cjConnect,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetVPortConnectData.lpConnect = puConnect;

                    dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                        GetVideoPortConnectInfo(&GetVPortConnectData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDvpGetVideoPortConnectInfo: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDvpGetVPortConnectData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetVPortConnectData->ddRVal,
                          GetVPortConnectData.ddRVal);
        ProbeAndWriteUlong(&puGetVPortConnectData->dwNumEntries,
                           GetVPortConnectData.dwNumEntries);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DxDvpGetVideoSignalStatus
*
* If the video port is receiving a good signal, the HAL should set dwStatus
* to DDVPSQ_SIGNALOK; otherwise, it should set dwStatus to DDVPSQ_NOSIGNAL.
*
*History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpGetVideoSignalStatus(
    HANDLE                  hVideoPort,
    PDD_GETVPORTSIGNALDATA  puGetVPortSignalData
    )
{
    DWORD                   dwRet;
    DD_GETVPORTSIGNALDATA   GetVPortSignalData;

    dwRet                       = DDHAL_DRIVER_NOTHANDLED;
    GetVPortSignalData.ddRVal   = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        GetVPortSignalData.lpDD        = peDirectDrawGlobal;
        GetVPortSignalData.lpVideoPort = peVideoPort;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.GetVideoSignalStatus))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.GetVideoSignalStatus(&GetVPortSignalData);
        }
    }
    else
    {
        WARNING("DxDvpGetVPortSignalData: Invalid object\n");
    }

    __try
    {
        ProbeAndWriteStructure(puGetVPortSignalData,
                               GetVPortSignalData,
                               DD_GETVPORTSIGNALDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpUpdateVideoPort
*
* Starts, stops, and changes the video port.  dwFlags can contain either
* DDRAWI_VPORTSTART, DDRAWI_VPORTSTOP, or DDRAWI_VPORTUPDATE.  To accommodate
* auto-flipping, lplpDDSurface and lplpDDVBISurface point to an array of
* surface structures rather than to a single structure.  If autoflipping is
* requested, the dwNumAutoflip field contains the number of surfaces in the
* list.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpUpdateVideoPort(
    HANDLE              hVideoPort,
    HANDLE*             phSurfaceVideo,
    HANDLE*             phSurfaceVbi,
    PDD_UPDATEVPORTDATA puUpdateVPortData
    )
{
    DWORD               dwRet;
    DD_UPDATEVPORTDATA  UpdateVPortData;
    DDVIDEOPORTINFO     VideoPortInfo;
    DDPIXELFORMAT       ddpfInputFormat;
    DDPIXELFORMAT       ddpfVBIInputFormat;
    DDPIXELFORMAT       ddpfVBIOutputFormat;
    HANDLE              ahSurfaceVideo[MAX_AUTOFLIP_BUFFERS];
    HANDLE              ahSurfaceVbi[MAX_AUTOFLIP_BUFFERS];
    EDD_SURFACE*        apeSurfaceVideo[MAX_AUTOFLIP_BUFFERS];
    EDD_SURFACE*        apeSurfaceVbi[MAX_AUTOFLIP_BUFFERS];
    DD_SURFACE_INT*     apDDSurfaceVideo[MAX_AUTOFLIP_BUFFERS];
    DD_SURFACE_INT*     apDDSurfaceVbi[MAX_AUTOFLIP_BUFFERS];
    ULONG               cAutoflipVideo;
    ULONG               cAutoflipVbi;
    EDD_DXVIDEOPORT*    peDxVideoPort;

    __try
    {
        UpdateVPortData = ProbeAndReadStructure(puUpdateVPortData,
                                                DD_UPDATEVPORTDATA);

        // Handle VideoPortInfo structure:

        if (UpdateVPortData.dwFlags != DDRAWI_VPORTSTOP)
        {
            VideoPortInfo = ProbeAndReadStructure(UpdateVPortData.lpVideoInfo,
                                                  DDVIDEOPORTINFO);

            if (VideoPortInfo.lpddpfInputFormat != NULL)
            {
                ddpfInputFormat
                    = ProbeAndReadStructure(VideoPortInfo.lpddpfInputFormat,
                                            DDPIXELFORMAT);

                VideoPortInfo.lpddpfInputFormat = &ddpfInputFormat;
            }
            if (VideoPortInfo.dwVBIHeight > 0)
            {
                if (VideoPortInfo.lpddpfVBIInputFormat  != NULL)
                {
                    ddpfVBIInputFormat
                        = ProbeAndReadStructure(VideoPortInfo.lpddpfVBIInputFormat,
                                                DDPIXELFORMAT);

                    VideoPortInfo.lpddpfVBIInputFormat = &ddpfVBIInputFormat;
                }
                if (VideoPortInfo.lpddpfVBIOutputFormat != NULL)
                {
                    ddpfVBIOutputFormat
                        = ProbeAndReadStructure(VideoPortInfo.lpddpfVBIOutputFormat,
                                                DDPIXELFORMAT);

                    VideoPortInfo.lpddpfVBIOutputFormat = &ddpfVBIOutputFormat;
                }
            }
            else
            {
                VideoPortInfo.lpddpfVBIInputFormat  = NULL;
                VideoPortInfo.lpddpfVBIOutputFormat = NULL;
            }
        }

        // Handle arrays of surfaces:

        cAutoflipVbi = 0;
        cAutoflipVideo = 0;

        if (UpdateVPortData.dwFlags != DDRAWI_VPORTSTOP)
        {
            cAutoflipVideo = min(UpdateVPortData.dwNumAutoflip, MAX_AUTOFLIP_BUFFERS);
            if ((cAutoflipVideo == 0) && (UpdateVPortData.lplpDDSurface != NULL))
            {
                cAutoflipVideo = 1;
            }

            cAutoflipVbi = min(UpdateVPortData.dwNumVBIAutoflip, MAX_AUTOFLIP_BUFFERS);
            if ((cAutoflipVbi == 0) && (UpdateVPortData.lplpDDVBISurface != NULL))
            {
                cAutoflipVbi = 1;
            }
        }
        if (cAutoflipVideo)
        {
            ProbeForRead(phSurfaceVideo,
                         cAutoflipVideo * sizeof(HANDLE),
                         sizeof(HANDLE));
            RtlCopyMemory(ahSurfaceVideo,
                          phSurfaceVideo,
                          cAutoflipVideo * sizeof(HANDLE));
        }
        if (cAutoflipVbi)
        {
            ProbeForRead(phSurfaceVbi,
                         cAutoflipVbi * sizeof(HANDLE),
                         sizeof(HANDLE));
            RtlCopyMemory(ahSurfaceVbi,
                          phSurfaceVbi,
                          cAutoflipVbi * sizeof(HANDLE));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                   = DDHAL_DRIVER_NOTHANDLED;
    UpdateVPortData.ddRVal  = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    ULONG                   i;
    EDD_SURFACE*            peSurface;

    BOOL                    bUpdateOK = TRUE;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDxVideoPort = peVideoPort->peDxVideoPort;
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        // Lock all the surfaces.  Note that bDdUpdateLinksAndSynchronize
        // will check for failure of DdHmgLock (the pointer will be NULL):

        for (i = 0; i < cAutoflipVideo; i++)
        {
            apeSurfaceVideo[i] = (EDD_SURFACE*)
                DdHmgLock((HDD_OBJ) ahSurfaceVideo[i], DD_SURFACE_TYPE, FALSE);
        }
        for (i = 0; i < cAutoflipVbi; i++)
        {
            apeSurfaceVbi[i] = (EDD_SURFACE*)
                DdHmgLock((HDD_OBJ) ahSurfaceVbi[i], DD_SURFACE_TYPE, FALSE);
        }

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.UpdateVideoPort) &&
            (bUpdateOK = bDdUpdateLinksAndSynchronize(
                                          peVideoPort,
                                          TRUE,             // Update video
                                          apeSurfaceVideo,
                                          cAutoflipVideo,
                                          TRUE,             // Update VBI
                                          apeSurfaceVbi,
                                          cAutoflipVbi)))
        {
            UpdateVPortData.lpDD             = peDirectDrawGlobal;
            UpdateVPortData.lpVideoPort      = peVideoPort;
            UpdateVPortData.lplpDDSurface    = NULL;
            UpdateVPortData.lplpDDVBISurface = NULL;
            UpdateVPortData.dwNumAutoflip    = cAutoflipVideo;
            UpdateVPortData.dwNumVBIAutoflip = cAutoflipVbi;
            UpdateVPortData.lpVideoInfo
                = (UpdateVPortData.dwFlags == DDRAWI_VPORTSTOP)
                ? NULL
                : &VideoPortInfo;

            if (cAutoflipVideo != 0)
            {
                for (i = 0; i < cAutoflipVideo; i++)
                {
                    apDDSurfaceVideo[i] = apeSurfaceVideo[i];
                }
                UpdateVPortData.lplpDDSurface = apDDSurfaceVideo;
            }
            if (cAutoflipVbi != 0)
            {
                for (i = 0; i < cAutoflipVbi; i++)
                {
                    apDDSurfaceVbi[i] = apeSurfaceVbi[i];
                }
                UpdateVPortData.lplpDDVBISurface = apDDSurfaceVbi;
            }

            // Turn off software autoflipping if necessary:

            if (UpdateVPortData.dwFlags == DDRAWI_VPORTSTOP)
            {
                peDxVideoPort->bSoftwareAutoflip = FALSE;
                peDxVideoPort->flFlags &= ~(DD_DXVIDEOPORT_FLAG_AUTOFLIP|DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI);

                // Disable the video port VSYNC IRQ now

                if( peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON )
                {
                    peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_ON;
                    peDirectDrawGlobal->pfnEnableIRQ(peDxVideoPort, FALSE );
                }
            }

            // We don't allow switching back to hardware once software
            // autoflipping has started (for various reasons, among
            // them being how do we synchronize -- the hardware would
            // start autoflipping before we could turn off the software
            // autoflipping).

            if (peDxVideoPort->bSoftwareAutoflip)
            {
                VideoPortInfo.dwVPFlags &= ~DDVP_AUTOFLIP;
            }

            // Make the HAL call:

            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.UpdateVideoPort(&UpdateVPortData);

            // If we failed due to a request for hardware autoflipping,
            // try again with software autoflipping.

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (UpdateVPortData.ddRVal != DD_OK) &&
                (peDirectDrawGlobal->DDKernelCaps.dwCaps & DDKERNELCAPS_AUTOFLIP))
            {
                VideoPortInfo.dwVPFlags &= ~DDVP_AUTOFLIP;

                dwRet = peDirectDrawGlobal->
                    VideoPortCallBacks.UpdateVideoPort(&UpdateVPortData);

                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                    (UpdateVPortData.ddRVal == DD_OK))
                {
                    KdPrint(("DxDvpUpdateVideoPort: Software autoflipping\n"));

                    peDxVideoPort->bSoftwareAutoflip = TRUE;
                    UpdateVPortData.ddRVal = DD_OK;
                }
            }
            
            if ((UpdateVPortData.ddRVal == DD_OK) &&
                peDxVideoPort->bSoftwareAutoflip)
            {
                if( cAutoflipVideo > 0 )
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP;
                }
                if( cAutoflipVbi > 0 )
                {
                    peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI;
                }
            }
        }

        if (!bUpdateOK)
        {
            WARNING("DxDvpUpdateVideoPort: failed on bDdUpdateLinksAndSynchronize");
        }

        if ((dwRet == DDHAL_DRIVER_HANDLED) &&
            (UpdateVPortData.ddRVal == DD_OK))
        {
            // Success!

            peVideoPort->dwNumAutoflip    = cAutoflipVideo;
            peVideoPort->dwNumVBIAutoflip = cAutoflipVbi;
            if (UpdateVPortData.dwFlags != DDRAWI_VPORTSTOP)
            {
                peVideoPort->ddvpInfo = VideoPortInfo;

                if (VideoPortInfo.lpddpfInputFormat != NULL)
                {
                    peVideoPort->ddvpInfo.lpddpfInputFormat
                        = &peVideoPort->ddpfInputFormat;

                    peVideoPort->ddpfInputFormat = ddpfInputFormat;
                }
                else
                {
                    peVideoPort->ddvpInfo.lpddpfInputFormat = NULL;
                }
            }
        }

        // Update various DXAPI state to reflect the changes:

        vDdSynchronizeVideoPort(peVideoPort);

        // If it wasn't previously on, enable the video port VSYNC IRQ now
        //
        // if bDdUpdateLinksAndSynchronize failed, don't enable.

        if(  (bUpdateOK) &&
             (UpdateVPortData.dwFlags != DDRAWI_VPORTSTOP) &&
            !(peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_ON) )
        {
            peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_ON;
            peDirectDrawGlobal->pfnEnableIRQ(peDxVideoPort, TRUE );
        }

        // Unlock the memory that I've locked

        for (i = 0; i < cAutoflipVideo; i++)
        {
            if( apeSurfaceVideo[i] != NULL )
                DEC_EXCLUSIVE_REF_CNT( apeSurfaceVideo[i] );
        }
        for (i = 0; i < cAutoflipVbi; i++)
        {
            if( apeSurfaceVbi[i] != NULL )
                DEC_EXCLUSIVE_REF_CNT( apeSurfaceVbi[i] );
        }

    }
    else
    {
        WARNING("DxDvpUpdateVPortData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puUpdateVPortData->ddRVal, UpdateVPortData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpWaitForVideoPortSync
*
* Returns at the beginning or end of either the video VSYNC or the specified
* line.  If the sync does not occur before the number of milliseconds
* specified in dwTimeOut has elapsed, the HAL should return
* DDERR_VIDEONOTACTIVE.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpWaitForVideoPortSync(
    HANDLE                      hVideoPort,
    PDD_WAITFORVPORTSYNCDATA    puWaitForVPortSyncData
    )
{
    DWORD                   dwRet;
    DD_WAITFORVPORTSYNCDATA WaitForVPortSyncData;

    __try
    {
        WaitForVPortSyncData = ProbeAndReadStructure(puWaitForVPortSyncData,
                                                     DD_WAITFORVPORTSYNCDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                       = DDHAL_DRIVER_NOTHANDLED;
    WaitForVPortSyncData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        WaitForVPortSyncData.lpDD        = peDirectDrawGlobal;
        WaitForVPortSyncData.lpVideoPort = peVideoPort;

        // Cap the number of milliseconds to wait to something reasonable:

        if (WaitForVPortSyncData.dwTimeOut
                > 6 * peVideoPort->ddvpDesc.dwMicrosecondsPerField)
        {
            WaitForVPortSyncData.dwTimeOut
                = 6 * peVideoPort->ddvpDesc.dwMicrosecondsPerField;
        }

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.WaitForVideoPortSync))
        {
            dwRet = peDirectDrawGlobal->VideoPortCallBacks.
                WaitForVideoPortSync(&WaitForVPortSyncData);
        }
    }
    else
    {
        WARNING("DxDvpWaitForVPortSyncData: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puWaitForVPortSyncData->ddRVal,
                          WaitForVPortSyncData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpColorControl
*
* Gets or sets the current color controls associated with the video port.
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpColorControl(
    HANDLE              hVideoPort,
    PDD_VPORTCOLORDATA  puVPortColorData
    )
{
    DWORD               dwRet;
    DD_VPORTCOLORDATA   VPortColorData;
    DDCOLORCONTROL      ColorData;

    __try
    {
        VPortColorData = ProbeAndReadStructure(puVPortColorData,
                                               DD_VPORTCOLORDATA);

        ColorData = ProbeAndReadStructure(VPortColorData.lpColorData,
                                          DDCOLORCONTROL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                 = DDHAL_DRIVER_NOTHANDLED;
    VPortColorData.ddRVal = DDERR_GENERIC;

    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if (peVideoPort != NULL)
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;

        VPortColorData.lpDD        = peDirectDrawGlobal;
        VPortColorData.lpVideoPort = peVideoPort;
        VPortColorData.lpColorData = &ColorData;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->VideoPortCallBacks.ColorControl))
        {
            dwRet = peDirectDrawGlobal->
                VideoPortCallBacks.ColorControl(&VPortColorData);
        }
    }
    else
    {
        WARNING("DxDvpColorControl: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puVPortColorData->ddRVal, VPortColorData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }
    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDvpAcquireNotification
*
* Sets up the user mode notification of video port vsyncs.
*
* History:
*  10-Oct-2000 -Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpAcquireNotification(
    HANDLE               hVideoPort,
    HANDLE *             phEvent,
    LPDDVIDEOPORTNOTIFY  pNotify
    )
{
    PKEVENT                 pEvent = NULL;
    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    PMDL                    mdl;
    LPDDVIDEOPORTNOTIFY     pLockedBuffer;

    __try
    {
        ProbeAndWriteHandle(phEvent, NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return DDHAL_DRIVER_NOTHANDLED;
    }

    // First check the caps to see if this device even supports a vport IRQ

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if ((peVideoPort != NULL) &&
        (peVideoPort->peDxVideoPort->pNotifyEvent == NULL))
    {
        peDirectDrawGlobal = peVideoPort->peDirectDrawGlobal;
        if (peDirectDrawGlobal->DDKernelCaps.dwIRQCaps & DDIRQ_VPORT0_VSYNC )
        {
            // Now setup the buffer so it can be accessed at DPC level
            mdl = IoAllocateMdl(pNotify,
                                sizeof(DDVIDEOPORTNOTIFY),
                                FALSE,
                                FALSE,
                                NULL);
            if (mdl != NULL)
            {
                __try
                {
                    MmProbeAndLockPages (mdl,
                                        KernelMode,
                                        IoWriteAccess);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    IoFreeMdl (mdl);
                    mdl = NULL;
                }
            }

            if (mdl != NULL)
            {
                pLockedBuffer = (LPDDVIDEOPORTNOTIFY) 
                    MmGetSystemAddressForMdlSafe (mdl,
                                                  NormalPagePriority);
                if (pLockedBuffer == NULL)
                {
                    MmUnlockPages (mdl);
                    IoFreeMdl (mdl);
                }
                else
                {
                    // Now set up the event that we trigger

                    HANDLE h = NULL;

                    ZwCreateEvent( &h,
                            EVENT_ALL_ACCESS,
                            NULL,
                            SynchronizationEvent,
                            FALSE );

                    if (h != NULL)
                    {
                        (VOID) ObReferenceObjectByHandle( h,
                                        0,
                                        0,
                                        KernelMode,
                                        (PVOID *) &pEvent,
                                        NULL );
                    }

                    if (pEvent != NULL)
                    {
                        ObDereferenceObject(pEvent);
                        peVideoPort->peDxVideoPort->pNotifyBuffer = pLockedBuffer;
                        peVideoPort->peDxVideoPort->pNotifyMdl = mdl;
                        peVideoPort->peDxVideoPort->pNotifyEvent = pEvent;
                        peVideoPort->peDxVideoPort->pNotifyEventHandle = h;

                        __try
                        {
                            ProbeAndWriteHandle(phEvent, h);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                    }
                    else
                    {
                        MmUnlockPages (mdl);
                        IoFreeMdl (mdl);
                    }
                }
                // force software autoflipping
                peVideoPort->peDxVideoPort->bSoftwareAutoflip = TRUE;
            }
        }
    }

    return 0;
}

/*****************************Private*Routine******************************\
* DWORD DxDvpReleaseNotification
*
* Stops up the user mode notification of video port vsyncs.
*
* History:
*  10-Oct-2000 -Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDvpReleaseNotification(
    HANDLE              hVideoPort,
    HANDLE              pEvent
    )
{
    EDD_VIDEOPORT*          peVideoPort;
    EDD_LOCK_VIDEOPORT      eLockVideoPort;

    peVideoPort = eLockVideoPort.peLock(hVideoPort);
    if ((peVideoPort != NULL) &&
        (peVideoPort->peDxVideoPort->pNotifyEventHandle == pEvent) &&
        (pEvent != NULL))
    {
        PKEVENT     pTemp = NULL;
        NTSTATUS    Status;

        peVideoPort->peDxVideoPort->pNotifyEvent = NULL;
        peVideoPort->peDxVideoPort->pNotifyEventHandle = NULL;

        // Make sure that the handle hasn't been freed by the OS already
        Status = ObReferenceObjectByHandle( pEvent,
                                        0,
                                        0,
                                        KernelMode,
                                        (PVOID *) &pTemp,
                                        NULL );
        if ((pTemp != NULL) && (Status != STATUS_INVALID_HANDLE))
        {
            ObDereferenceObject(pTemp);
            ZwClose (pEvent);
        }

        peVideoPort->peDxVideoPort->pNotifyBuffer = NULL;
        if (peVideoPort->peDxVideoPort->pNotifyMdl != NULL)
        {
            MmUnlockPages (peVideoPort->peDxVideoPort->pNotifyMdl);
            IoFreeMdl (peVideoPort->peDxVideoPort->pNotifyMdl);
            peVideoPort->peDxVideoPort->pNotifyMdl = NULL;
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddheapr.cxx ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:   ddheapr.c
 *  Content:    Rectangular heap manager
 *  History:
 *   Date   By  Reason
 *   ====   ==  ======
 *   30-mar-95  kylej   initial implementation
 *   07-apr-95  kylej   Added rectVidMemAmountFree
 *   15-may-95  craige  made separate VMEM struct for rect & linear
 *   18-jun-95  craige  specific pitch
 *   02-jul-95  craige  have rectVidMemInit return a BOOL
 *   28-nov-95  colinmc new function to return amount of allocated memory
 *                      in a heap
 *   05-jul-96  colinmc Work Item: Removing the restriction on taking Win16
 *                      lock on VRAM surfaces (not including the primary)
 *   18-jan-97  colinmc Work Item: AGP support
 *   03-mar-97  jeffno  Work item: Extended surface memory alignment
 *   03-Feb-98  DrewB   Made portable between user and kernel.
 *
 ***************************************************************************/

#include "precomp.hxx"

/****************************************************************************

 This memory manager manages allocation of rectangular blocks of 
 video memory.  It has essentially the same interface as the linear
 video memory manager implemented in vmemmgr.c.  Memory allocations
 are tracked by nodes on two circular, doubly-linked lists; the free
 list and the alloc list.  Each list has a special node called the 
 sentinel which contains a special memory size.  The head of each
 list always points to the sentinel node and the first member of the
 list (if there is one) is pointed to by the sentinel node.  Block
 adjacency information is kept in each node so that several free nodes 
 can be coalesced into larger free nodes.  This takes place every 
 time a block of memory is freed.
 
 This memory manager is designed to have no impact on video memory usage.
 Global memory is used to maintain the allocation and free lists.  Because
 of this choice, merging of free blocks is a more expensive operation.
 The assumption is that in general, the speed of creating/destroying these
 memory blocks is not a high usage item and so it is OK to be slower.

 ****************************************************************************/

/*
 * IS_FREE and NOT_FREE are used to set the free flag in the flags
 * field of each VMEM node.  The free flag is the lsb of this field.
 */
  
#define IS_FREE  0x00000001
#define NOT_FREE 0xfffffffe
 
/*
 * SENTINEL is the value stuffed into the size field of a VMEM
 * node to identify it as the sentinel node.  This value makes
 * the assumption that no rectangle sized 0x7fff by 0xffff will
 * ever be requested.
 */
  
#define SENTINEL 0x7fffffff

/*
 * MIN_DIMENSION_SIZE determines the smallest valid dimension for a 
 * free memory block.  If dividing a rectangle will result in a 
 * rectangle with a dimension less then MIN_DIMENSION_SIZE, the 
 * rectangle is not divided.
 */

#define MIN_DIMENSION_SIZE 4

/*
 * BLOCK_BOUNDARY must be a power of 2, and at least 4.  This gives
 * us the alignment of memory blocks.   
 */
#define BLOCK_BOUNDARY  4

// This macro results in the free list being maintained with a
// cx-major, cy-minor sort:

#define CXCY(cx, cy) (((cx) << 16) | (cy))

/*
 * Debugging helpers
 */
#define DPFVMEMR(str,p) VDPF((0,V,"%s: %d,%d (%dx%d) ptr:%08x, block:%08x",str,p->x,p->y,p->cx,p->cy,p->ptr,p))
#define CHECK_HEAP(a,b) ;

/*
 * insertIntoDoubleList - add an item to the a list. The list is
 *      kept in order of increasing size and is doubly linked.  The
 *      list is circular with a sentinel node indicating the end
 *      of the list.  The sentinel node has its size field set 
 *      to SENTINEL.
 */
void insertIntoDoubleList( LPVMEMR pnew, LPVMEMR listhead )
{
    LPVMEMR pvmem = listhead;

    #ifdef DEBUG
    if( pnew->size == 0 )
    {
        VDPF(( 1, V, "block size = 0\n" ));
    }
    #endif

    /*
     * run through the list (sorted from smallest to largest) looking
     * for the first item bigger than the new item.  If the sentinel
     * is encountered, insert the new item just before the sentinel.
     */

    while( pvmem->size != SENTINEL ) 
    {
    if( pnew->size < pvmem->size )
    {
        break;
    }
    pvmem = pvmem->next;
    }

    // insert the new item before the found one.
    pnew->prev = pvmem->prev;
    pnew->next = pvmem;
    pvmem->prev->next = pnew;
    pvmem->prev = pnew;

} /* insertIntoDoubleList */

/*
 * rectVidMemInit - initialize rectangular video memory manager
 */
BOOL rectVidMemInit(
        LPVMEMHEAP pvmh,
        FLATPTR start,
        DWORD width,
        DWORD height,
        DWORD pitch )
{
    LPVMEMR newNode;

    VDPF(( 2, V, "rectVidMemInit(start=%08lx,width=%ld,height=%ld,pitch=%ld)", start, width, height, pitch));

    pvmh->dwTotalSize = pitch * height;

    // Store the pitch for future address calculations.
    pvmh->stride = pitch;

    // Set up the Free list and the Alloc list by inserting the sentinel.
    pvmh->freeList = MemAlloc( sizeof(VMEMR) );
    if( pvmh->freeList == NULL )
    {
        return FALSE;
    }
    ((LPVMEMR)pvmh->freeList)->size = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->cx = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->cy = SENTINEL;
    ((LPVMEMR)pvmh->freeList)->next = (LPVMEMR)pvmh->freeList;
    ((LPVMEMR)pvmh->freeList)->prev = (LPVMEMR)pvmh->freeList;
    ((LPVMEMR)pvmh->freeList)->pLeft = NULL;
    ((LPVMEMR)pvmh->freeList)->pUp = NULL;
    ((LPVMEMR)pvmh->freeList)->pRight = NULL;
    ((LPVMEMR)pvmh->freeList)->pDown = NULL;

    pvmh->allocList = MemAlloc( sizeof(VMEMR) );
    if( pvmh->allocList == NULL )
    {
    MemFree(pvmh->freeList);
        return FALSE;
    }
    ((LPVMEMR)pvmh->allocList)->size = SENTINEL;
    ((LPVMEMR)pvmh->allocList)->next = (LPVMEMR)pvmh->allocList;
    ((LPVMEMR)pvmh->allocList)->prev = (LPVMEMR)pvmh->allocList;

    // Initialize the free list with the whole chunk of memory
    newNode = (LPVMEMR)MemAlloc( sizeof( VMEMR ) );
    if( newNode == NULL )
    {
    MemFree(pvmh->freeList);
        MemFree(pvmh->allocList);
        return FALSE;
    }
    newNode->ptr = start;
    newNode->size = CXCY(width, height);
    newNode->x = 0;
    newNode->y = 0;
    newNode->cx = width;
    newNode->cy = height;
    newNode->flags |= IS_FREE;
    newNode->pLeft = (LPVMEMR)pvmh->freeList;
    newNode->pUp = (LPVMEMR)pvmh->freeList;
    newNode->pRight = (LPVMEMR)pvmh->freeList;
    newNode->pDown = (LPVMEMR)pvmh->freeList;
    insertIntoDoubleList( newNode, ((LPVMEMR) pvmh->freeList)->next );

    return TRUE;
} /* rectVidMemInit */

/*
 * rectVidMemFini - done with rectangular video memory manager
 */
void rectVidMemFini( LPVMEMHEAP pvmh )
{
    LPVMEMR curr;
    LPVMEMR next;

    if( pvmh != NULL )
    {
    // free all memory allocated for the free list
    curr = ((LPVMEMR)pvmh->freeList)->next;
    while( curr->size != SENTINEL )
    {
        next = curr->next;
        MemFree( curr );
        curr = next;
    }
    MemFree( curr );
    pvmh->freeList = NULL;

    // free all memory allocated for the allocation list
    curr = ((LPVMEMR)pvmh->allocList)->next;
    while( curr->size != SENTINEL )
    {
        next = curr->next;
        MemFree( curr );
        curr = next;
    }
    MemFree( curr );
    pvmh->allocList = NULL;

    // free the heap data
    MemFree( pvmh );
    }
}   /* rectVidMemFini */

/*
 * GetBeforeWastage.
 * Align the surface in the given block. Return the size of the holes
 * on the left side of the surface.
 * Fail if alignment would cause surface to spill out of block.
 * Works for horizontal and vertical alignment.
 * IN:  dwBlockSize , dwBlockStart: Parameters of the block in which
 *                                  the surface hopes to fit
 *      dwSurfaceSize               Width or height of the surface
 *      dwAlignment                 Expected alignment. 0 means don't care
 * OUT: pdwBeforeWastage
 */
BOOL GetBeforeWastage(
    DWORD dwBlockSize,
    DWORD dwBlockStart,
    DWORD dwSurfaceSize, 
    LPDWORD pdwBeforeWastage, 
    DWORD dwAlignment )
{

    if (!dwAlignment)
    {
        *pdwBeforeWastage=0;
        /*
         * If no alignment requirement, then check if the surface fits
         */
        if (dwBlockSize >= dwSurfaceSize)
        {
            return TRUE;
        }
        return FALSE;
    }
    /*
     * There's an alignment.
     */
    *pdwBeforeWastage = (dwAlignment - (dwBlockStart % dwAlignment)) % dwAlignment;

    if ( *pdwBeforeWastage + dwSurfaceSize > dwBlockSize )
    {
            return FALSE;
    }

    DDASSERT( (dwBlockStart + *pdwBeforeWastage) % dwAlignment == 0 );
    return TRUE;
}

/*
 * rectVidMemAlloc - alloc some rectangular flat video memory
 */
FLATPTR rectVidMemAlloc( LPVMEMHEAP pvmh, DWORD cxThis, DWORD cyThis,
                         LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment )
{
    LPVMEMR pvmem;
    DWORD   cyRem;
    DWORD   cxRem;
    DWORD   cxBelow;
    DWORD   cyBelow;
    DWORD   cxBeside;
    DWORD   cyBeside;
    LPVMEMR pnewBeside;
    LPVMEMR pnewBelow;
    DWORD       dwXAlignment=0;
    DWORD       dwYAlignment=0;
    DWORD       dwLeftWastage=0;
    DWORD       dwTopWastage=0;
    BOOL        bDiscardable = FALSE;


    if((cxThis == 0) || (cyThis == 0) || (pvmh == NULL))
    return (FLATPTR) NULL;

    // Make sure the size of the block is a multiple of BLOCK_BOUNDARY
    // If every block allocated has a width which is a multiple of
    // BLOCK_BOUNDARY, it guarantees that all blocks will be allocated
    // on block boundaries.

    /*
     * Bump to new alignment
     */
    if( (cxThis >= (SENTINEL>>16) ) || (cyThis >= (SENTINEL&0xffff) ) )
    return (FLATPTR) NULL;


    if (lpAlignment)
    {
        dwXAlignment = lpAlignment->Rectangular.dwXAlignment;
        dwYAlignment = lpAlignment->Rectangular.dwYAlignment;
        
        if( lpAlignment->Rectangular.dwFlags & SURFACEALIGN_DISCARDABLE ) 
        {
            bDiscardable = TRUE;
        }
    }
    if (dwXAlignment < 4)
    {
        dwXAlignment = 4;
    }


    
    cxThis = (cxThis+(BLOCK_BOUNDARY-1)) & ~(BLOCK_BOUNDARY-1);

    /*
     * run through free list, looking for the closest matching block
     */

    pvmem = ((LPVMEMR)pvmh->freeList)->next;
    while (pvmem->size != SENTINEL)
    {
        if (!GetBeforeWastage( pvmem->cx, pvmem->x, cxThis, &dwLeftWastage, dwXAlignment ))
        {
        pvmem = pvmem->next;
            continue; //X size or alignment makes surface spill out of block
        }
        // Now see if size/alignment works for Y
        if (!GetBeforeWastage( pvmem->cy, pvmem->y, cyThis, &dwTopWastage, dwYAlignment ))
        {
        pvmem = pvmem->next;
            continue; //Y size alignment makes surface spill out of block
        }
        //success:
        break;
    }

    if(pvmem->size == SENTINEL)
    {
    // There was no rectangle large enough
    return (FLATPTR) NULL;
    }

    // pvmem now points to a rectangle that is the same size or larger
    // than the requested rectangle.  We're going to use the upper-left
    // corner of the found rectangle and divide the unused remainder into
    // two rectangles which will go on the available list.

    // grow allocation by the wastage which makes the top-left aligned
    cxThis += dwLeftWastage;
    cyThis += dwTopWastage;

    // Compute the width of the unused rectangle to the right and the 
    // height of the unused rectangle below:

    cyRem = pvmem->cy - cyThis;
    cxRem = pvmem->cx - cxThis;

    // Given finite area, we wish to find the two rectangles that are 
    // most square -- i.e., the arrangement that gives two rectangles
    // with the least perimiter:

    cyBelow = cyRem;
    cxBeside = cxRem;

    if (cxRem <= cyRem)
    {
    cxBelow = cxThis + cxRem;
    cyBeside = cyThis;
    }
    else
    {
    cxBelow = cxThis;
    cyBeside = cyThis + cyRem;
    }

    // We only make new available rectangles of the unused right and 
    // bottom portions if they're greater in dimension than MIN_DIMENSION_SIZE.
    // It hardly makes sense to do the book-work to keep around a 
    // two pixel wide available space, for example.

    pnewBeside = NULL;
    if (cxBeside >= MIN_DIMENSION_SIZE)
    {
    pnewBeside = (LPVMEMR)MemAlloc( sizeof(VMEMR) );
    if( pnewBeside == NULL)
        return (FLATPTR) NULL;

    // Update the adjacency information along with the other required
    // information in this new node and then insert it into the free
    // list which is sorted in ascending cxcy.

    // size information
    pnewBeside->size = CXCY(cxBeside, cyBeside);
    pnewBeside->x = pvmem->x + cxThis;
    pnewBeside->y = pvmem->y;
    pnewBeside->ptr = pvmem->ptr + cxThis;
    pnewBeside->cx = cxBeside;
    pnewBeside->cy = cyBeside;
    pnewBeside->flags |= IS_FREE;

    // adjacency information
    pnewBeside->pLeft = pvmem;
    pnewBeside->pUp = pvmem->pUp;
    pnewBeside->pRight = pvmem->pRight;
    pnewBeside->pDown = pvmem->pDown;
    }

    pnewBelow = NULL;
    if (cyBelow >= MIN_DIMENSION_SIZE)
    {
    pnewBelow = (LPVMEMR) MemAlloc( sizeof(VMEMR) );
    if (pnewBelow == NULL)
        {
            if( pnewBeside != NULL )
            {
                MemFree( pnewBeside );
            }
        return (FLATPTR) NULL;
        }

    // Update the adjacency information along with the other required
    // information in this new node and then insert it into the free
    // list which is sorted in ascending cxcy.

    // size information
    pnewBelow->size = CXCY(cxBelow, cyBelow);
    pnewBelow->x = pvmem->x;
    pnewBelow->y = pvmem->y + cyThis;
    pnewBelow->ptr = pvmem->ptr + cyThis*pvmh->stride;
    pnewBelow->cx = cxBelow;
    pnewBelow->cy = cyBelow;
    pnewBelow->flags |= IS_FREE;

    // adjacency information
    pnewBelow->pLeft = pvmem->pLeft;
    pnewBelow->pUp = pvmem;
    pnewBelow->pRight = pvmem->pRight;
    pnewBelow->pDown = pvmem->pDown;
    }

    // Remove this node from the available list
    pvmem->next->prev = pvmem->prev;
    pvmem->prev->next = pvmem->next;

    // Update adjacency information for the current node

    if(pnewBelow != NULL)
    {
    insertIntoDoubleList( pnewBelow, ((LPVMEMR) pvmh->freeList)->next );

    // Modify the current node to reflect the changes we've made:

    pvmem->cy = cyThis;
    pvmem->pDown = pnewBelow;
    if((pnewBeside != NULL) && (cyBeside == pvmem->cy))
        pnewBeside->pDown = pnewBelow;
    }

    if(pnewBeside != NULL)
    {
    insertIntoDoubleList( pnewBeside, ((LPVMEMR) pvmh->freeList)->next);

    // Modify the current node to reflect the changes we've made:

    pvmem->cx = cxThis;
    pvmem->pRight = pnewBeside;
    if ((pnewBelow != NULL) && (cxBelow == pvmem->cx))
        pnewBelow->pRight = pnewBeside;
    }

    // set up new pointers (pBits is the value returned to the client, pvmem
    // points to the actual top-left of the block).
    pvmem->pBits = pvmem->ptr + dwLeftWastage + dwTopWastage*pvmh->stride;
    pvmem->flags &= NOT_FREE;
    pvmem->size = CXCY(pvmem->cx, pvmem->cy);
    pvmem->bDiscardable = bDiscardable;

    // Now insert it into the alloc list.
    insertIntoDoubleList( pvmem, ((LPVMEMR) pvmh->allocList)->next );

    if( NULL != lpdwSize )
    {
    /*
     * Note this is the total number of bytes needed for this surface
     * including the stuff off the left and right hand sides due to
     * pitch not being equal to width. This is different from the
     * size computed above which is simply the number of bytes within
     * the boundary of the surface itself.
     *
     * The formula below calculates the number of bytes from the first
     * byte in the rectangular surface to the first byte after it
     * taking the pitch into account. Complex I know but it works.
     */
    DDASSERT( 0UL != pvmem->cy );
    *lpdwSize = (pvmh->stride * (pvmem->cy - 1)) + pvmem->cx;
    }

    CHECK_HEAP("After rectVidMemAlloc",pvmh);
    return pvmem->pBits;

} /* rectVidMemAlloc */

/*
 * rectVidMemFree = free some rectangular flat video memory
 */
void rectVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    LPVMEMR pvmem;
    LPVMEMR pBeside;

    // Find the node in the allocated list which matches ptr
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
    pvmem = pvmem->next)
    if(pvmem->pBits == ptr)
        break;

    if(pvmem->size == SENTINEL)   // couldn't find allocated rectangle?
    {
    VDPF(( 1, V, "Couldn't find node requested freed!\n"));
    return;
    }

    // pvmem now points to the node which must be freed.  Attempt to 
    // coalesce rectangles around this node until no more action
    // is possible.

    while(1)
    {
    // Try merging with the right sibling:

    pBeside = pvmem->pRight;
    if ((pBeside->flags & IS_FREE)       &&
        (pBeside->cy    == pvmem->cy)    &&
        (pBeside->pUp   == pvmem->pUp)   &&
        (pBeside->pDown == pvmem->pDown) &&
        (pBeside->pRight->pLeft != pBeside))
    {
        // Add the right rectangle to ours:

        pvmem->cx    += pBeside->cx;
        pvmem->pRight = pBeside->pRight;

        // Remove pBeside from the list and free it.
        pBeside->next->prev = pBeside->prev;
        pBeside->prev->next = pBeside->next;
        MemFree(pBeside);
        continue;       // go back and try again
    }

    // Try merging with the lower sibling:

    pBeside = pvmem->pDown;
    if ((pBeside->flags & IS_FREE)         &&
        (pBeside->cx     == pvmem->cx)     &&
        (pBeside->pLeft  == pvmem->pLeft)  &&
        (pBeside->pRight == pvmem->pRight) &&
        (pBeside->pDown->pUp != pBeside))
    {
        pvmem->cy   += pBeside->cy;
        pvmem->pDown = pBeside->pDown;

        // Remove pBeside from the list and free it.
        pBeside->next->prev = pBeside->prev;
        pBeside->prev->next = pBeside->next;
        MemFree(pBeside);
        continue;       // go back and try again
    }

    // Try merging with the left sibling:

    pBeside = pvmem->pLeft;
    if ((pBeside->flags & IS_FREE)        &&
        (pBeside->cy     == pvmem->cy)    &&
        (pBeside->pUp    == pvmem->pUp)   &&
        (pBeside->pDown  == pvmem->pDown) &&
        (pBeside->pRight == pvmem)        &&
        (pvmem->pRight->pLeft != pvmem))
    {
        // We add our rectangle to the one to the left:

        pBeside->cx    += pvmem->cx;
        pBeside->pRight = pvmem->pRight;

        // Remove 'pvmem' from the list and free it:
        pvmem->next->prev = pvmem->prev;
        pvmem->prev->next = pvmem->next;
        MemFree(pvmem);
        pvmem = pBeside;
        continue;
    }

    // Try merging with the upper sibling:

    pBeside = pvmem->pUp;
    if ((pBeside->flags & IS_FREE)         &&
        (pBeside->cx       == pvmem->cx)   &&
        (pBeside->pLeft  == pvmem->pLeft)  &&
        (pBeside->pRight == pvmem->pRight) &&
        (pBeside->pDown  == pvmem)         &&
        (pvmem->pDown->pUp != pvmem))
    {
        pBeside->cy      += pvmem->cy;
        pBeside->pDown  = pvmem->pDown;

        // Remove 'pvmem' from the list and free it:
        pvmem->next->prev = pvmem->prev;
        pvmem->prev->next = pvmem->next;
        MemFree(pvmem);
        pvmem = pBeside;
        continue;
    }

    // Remove the node from its current list.

    pvmem->next->prev = pvmem->prev;
    pvmem->prev->next = pvmem->next;

    pvmem->size = CXCY(pvmem->cx, pvmem->cy);
    pvmem->flags |= IS_FREE;

    // Insert the node into the free list:
    insertIntoDoubleList( pvmem, ((LPVMEMR) pvmh->freeList)->next );

    // No more area coalescing can be done, return.

        CHECK_HEAP("After rectVidMemFree",pvmh);
    return;
    }
}

/*
 * rectVidMemAmountAllocated
 */
DWORD rectVidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    LPVMEMR pvmem;
    DWORD   size;

    size = 0;
    // Traverse the alloc list and add up all the used space.
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
    pvmem = pvmem->next)
    {
        if( !( pvmem->bDiscardable ) )
        {
        size += pvmem->cx * pvmem->cy;
        }
    }

    return size;

} /* rectVidMemAmountAllocated */

/*
 * rectVidMemAmountFree
 */
DWORD rectVidMemAmountFree( LPVMEMHEAP pvmh )
{
    LPVMEMR pvmem;
    DWORD   size;

    size = 0;
    // Traverse the free list and add up all the empty space.
    for(pvmem=((LPVMEMR)pvmh->freeList)->next; pvmem->size != SENTINEL;
    pvmem = pvmem->next)
    {
    size += pvmem->cx * pvmem->cy;
    }

    // Now traverse the alloced list and add in all of the memory
    // that's discardable
    for(pvmem=((LPVMEMR)pvmh->allocList)->next; pvmem->size != SENTINEL;
    pvmem = pvmem->next)
    {
        if( pvmem->bDiscardable )
        {
        size += pvmem->cx * pvmem->cy;
        }
    }

    return size;

} /* rectVidMemAmountFree */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddkcomp.h ===
/*==========================================================================;
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddkcomp.h
 *  Content:	Compilation environment for Win9x code in NT kernel.
 *  History:
 *   Date	By	Reason
 *   ====	==	======
 *   03-Feb-98	DrewB   Keep common code for DDraw heap.
 *
 ***************************************************************************/

#ifndef __NTDDKCOMP__
#define __NTDDKCOMP__

#if DBG
#define DEBUG
#else
#undef DEBUG
#endif

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE NULL
#endif

typedef DD_DIRECTDRAW_LOCAL *LPDDRAWI_DIRECTDRAW_LCL;
typedef DD_DIRECTDRAW_GLOBAL *LPDDRAWI_DIRECTDRAW_GBL;
typedef DD_SURFACE_LOCAL *LPDDRAWI_DDRAWSURFACE_LCL;
typedef DD_SURFACE_GLOBAL *LPDDRAWI_DDRAWSURFACE_GBL;

typedef VIDEOMEMORYINFO VIDMEMINFO;
typedef VIDMEMINFO *LPVIDMEMINFO;
typedef VIDEOMEMORY VIDMEM;
typedef VIDMEM *LPVIDMEM;

#ifndef ZeroMemory
#define ZeroMemory(pv, cBytes) RtlZeroMemory(pv, cBytes)
#endif

#define ZwCloseKey             ZwClose

#define ABS(A)      ((A) <  0  ? -(A) : (A))

//
// Sundown: in GDI, there are lots of places SIZE_T are used as interchangeable
// as ULONG or UINT or LONG or INT.  On 64bit system, SIZE_T is int64 indeed.
// Since we are not making any GDI objects large objects right now, I just
// change all SIZE_T to ULONGSIZE_T here.
//
// The new type used is to easily identify the change later.
//
#define ULONGSIZE_T ULONG

#if defined(_X86_)

//
// Keep our own copy of this to avoid double indirections on probing
//
extern ULONG_PTR DxgUserProbeAddress;

#undef  MM_USER_PROBE_ADDRESS
#define MM_USER_PROBE_ADDRESS DxgUserProbeAddress
#endif // defined(_X86_)

//
// Macro to check memory allocation overflow.
//
#define MAXIMUM_POOL_ALLOC          (PAGE_SIZE * 10000)
#define BALLOC_OVERFLOW1(c,st)      (c > (MAXIMUM_POOL_ALLOC/sizeof(st)))
#define BALLOC_OVERFLOW2(c,st1,st2) (c > (MAXIMUM_POOL_ALLOC/(sizeof(st1)+sizeof(st2))))

//
// Debugger output macros
//
#define DDASSERT(Expr) ASSERTGDI(Expr, "DDASSERT")
#define VDPF(Args)

#ifdef DEBUG
    VOID  WINAPI DoRip(PSZ);
    VOID  WINAPI DoWarning(PSZ,LONG);

    #define RIP(x) DoRip((PSZ) x)
    #define ASSERTGDI(x,y) if(!(x)) DoRip((PSZ) y)
    #define WARNING(x)  DoWarning(x,0)
    #define WARNING1(x) DoWarning(x,1)

    #define RECORD_DRIVER_EXCEPTION() DbgPrint("Driver caused exception - %s line %u\n",__FILE__,__LINE__);

#else
    #define RIP(x)
    #define ASSERTGDI(x,y)
    #define WARNING(x)
    #define WARNING1(x)

    #define RECORD_DRIVER_EXCEPTION()

#endif

//
// Allocated memory is zero-filled.
//
#define MemAlloc(cBytes)           PALLOCMEM(cBytes, 'pddD')
#define MemFree(pv)                VFREEMEM(pv)

#define PALLOCMEM(cBytes,tag)      EngAllocMem(FL_ZERO_MEMORY,cBytes,tag)
#define PALLOCNOZ(cBytes,tag)      EngAllocMem(0,cBytes,tag)
#define PALLOCNONPAGED(cBytes,tag) EngAllocMem(FL_ZERO_MEMORY|FL_NONPAGED_MEMORY,cBytes,tag)

#define VFREEMEM(pv)               EngFreeMem(pv)

//
// From ntos\inc\pool.h
//
#define SESSION_POOL_MASK          32

//
// Error messages
//
#define SAVE_ERROR_CODE(x)         EngSetLastError((x))

//
// Macro to see if terminal server or not
//
#define ISTS()                     DxEngIsTermSrv()

//
// Macro to increment display uniqueness
//
#define INC_DISPLAY_UNIQUENESS()   DxEngIncDispUniq()

//
// Macro
//
#define VISRGN_UNIQUENESS()        DxEngVisRgnUniq()

//
// Macro
//
#define SURFOBJ_HOOK(pso)          ((FLONG)DxEngGetSurfaceData(pso,SURF_HOOKFLAGS))

#endif // __NTDDKCOMP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddraw.cxx ===
/******************************Module*Header*******************************\
* Module Name: ddraw.cxx
*
* Contains all of GDI's private DirectDraw APIs.
*
* Created: 3-Dec-1995
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1995-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

#if 0
#define DBG_DDKHEAP
#define DDKHEAP(Args) KdPrint(Args)
#else
#define DDKHEAP(Args)
#endif

#if 0
#define DBG_DDKSURF
#define DDKSURF(Args) KdPrint(Args)
#else
#define DDKSURF(Args)
#endif


// Several AGP routines take an hdev that is some cookie useful in
// AGP operations.  On NT, it's a pointer to the EDD_DIRECTDRAW_GLOBAL.
// This macro is largely just a marker in case it changes in the
// future.

#define AGP_HDEV(peDirectDrawGlobal) ((HANDLE)peDirectDrawGlobal)

// This variable is kept for stress debugging purposes.  When a mode change
// or desktop change is pending and an application has outstanding locks
// on the frame buffer, we will by default wait up to 7 seconds for the
// application to release its locks, before we will unmap the view anyway.
// 'gfpUnmap' will be user-mode address of the unmapped frame buffer, which
// will be useful for determining in stress whether an application had its
// frame buffer access rescinded, or whether it was using a completely bogus
// frame buffer pointer to begin with:

FLATPTR gfpUnmap = 0;

// The following global variables are kept only for debugging purposes, to
// aid in tracking DC drawing to surfaces that have been lost:

HDC ghdcGetDC;
HDC ghdcCantLose;

#ifdef DX_REDIRECTION

// The following global variable is kept the boolean value if system are in
// redirection mode or not.
//
// If system is in redirection mode, we disable ...
//
//  + Overlay.
//  + Primary surface lock (LATER).
//
// !!! Currently this is 'per system' status, so that we can have global variable
// !!! simply here, but it could be 'per process' or 'per hWnd' in later version.
// !!! (it's up to how Window manager manage its status)

BOOL gbDxRedirection = FALSE;

#endif // DX_REDIRECTION


#if DBG

/******************************Public*Routine******************************\
* VOID vDdAssertDevlock
*
* Debug code for verifying that the devlock is currently held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdAssertShareDevlock()
{
#if 0 // TODO: DBG - IsSem...
    ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(ghsemShareDevLock),
                    "DD_ASSERTSHAREDEVLOCK failed");
#endif
}

VOID
vDdAssertDevlock(
    EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal
    )
{
    ASSERTGDI(DxEngIsHdevLockedByCurrentThread(peDirectDrawGlobal->hdev),
              "DD_ASSERTDEVLOCK failed because Devlock is not held");
}

/******************************Public*Routine******************************\
* VOID vDdAssertNoDevlock
*
* Debug code for verifying that the devlock is currently not held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdAssertNoDevlock(
    EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal
    )
{
    ASSERTGDI(!DxEngIsHdevLockedByCurrentThread(peDirectDrawGlobal->hdev),
              "DD_ASSERTNODEVLOCK failed because Devlock held but shouldn't be!");
}

#endif // DBG

/******************************Public*Routine******************************\
* BOOL bDdIntersect
*
* Ubiquitous lower-right exclusive intersection detection.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline
BOOL
bDdIntersect(
    RECTL* pA,
    RECTL* pB
    )
{
    return((pA->left   < pB->right) &&
           (pA->top    < pB->bottom) &&
           (pA->right  > pB->left) &&
           (pA->bottom > pB->top));
}

/******************************Public*Routine******************************\
* BOOL bDdValidateDriverData
*
* Performs some parameter validation on the info DirectDraw info returned
* from the driver.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdValidateDriverData(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    BOOL            b;
    DDNTCORECAPS*   pCaps;

    b = TRUE;

    if ((peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 8)  &&
        (peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 16) &&
        (peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 24) &&
        (peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 32))
    {
        RIP("HalInfo.vmiData.ddpfDisplay.dwRGBBitCount not 8, 16, 24 or 32");
        b = FALSE;
    }

    if (peDirectDrawGlobal->HalInfo.vmiData.lDisplayPitch == 0)
    {
        RIP("HalInfo.vmiData.lDisplayPitch is 0");
        b = FALSE;
    }

    pCaps = &peDirectDrawGlobal->HalInfo.ddCaps;

    // Check to see if 'Blt' must be hooked:

    if (pCaps->dwCaps & (DDCAPS_BLT
                       | DDCAPS_BLTCOLORFILL
                       | DDCAPS_COLORKEY))
    {
        if (!(peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_BLT) ||
            (peDirectDrawGlobal->SurfaceCallBacks.Blt == NULL))
        {
            RIP("HalInfo.ddCaps.dwCaps indicate driver must hook Blt\n");
            b = FALSE;
        }
    }

    // We only permit a subset of the DirectDraw capabilities to be hooked
    // by the driver, because the kernel-mode code paths for any other
    // capabilities have not been tested:

    if (pCaps->dwCaps & (DDCAPS_GDI
                       | DDCAPS_PALETTE
                       | DDCAPS_ZOVERLAYS
                       | DDCAPS_BANKSWITCHED))
    {
        RIP("HalInfo.ddCaps.dwCaps has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    if (pCaps->dwCaps2 & (DDCAPS2_CERTIFIED))
    {
        RIP("HalInfo.ddCaps.dwCaps2 has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    if (pCaps->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY
                               | DDSCAPS_WRITEONLY
                               | DDSCAPS_OWNDC
                               | DDSCAPS_MODEX))
    {
        RIP("HalInfo.ddCaps.ddsCaps.dwCaps has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    if (pCaps->dwFXCaps & ( DDFXCAPS_BLTROTATION
                          | DDFXCAPS_BLTROTATION90))
    {
        RIP("HalInfo.ddCaps.dwFXCaps has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    /*
     * WINBUG #55100 2-1-2000 bhouse Alpha restrictions need to be revisited when AlphaBlt DDI is enabled.
     * We used to check and fail on the presence of either of the following bits:
     * DDFXALPHACAPS_BLTALPHASURFACES           0x00000008l
     * DDFXALPHACAPS_OVERLAYALPHASURFACES       0x00000100l
     */

    if (pCaps->dwPalCaps != 0)
    {
        RIP("HalInfo.ddCaps.dwPalCaps has capabilities set that aren't supported by NT\n");
        b = FALSE;
    }

    // GDI will handle the emulation of system-memory to video-memory blts.
    // Page-locking from user-mode is not allowed on NT, so
    // DDSCAPS2_NOPAGELOCKEDREQUIRED should always be set:

    if (!(pCaps->dwCaps & DDCAPS_CANBLTSYSMEM) &&
        (peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_BLT) &&
        (peDirectDrawGlobal->SurfaceCallBacks.Blt != NULL))
    {
        peDirectDrawGlobal->flDriver |= DD_DRIVER_FLAG_EMULATE_SYSTEM_TO_VIDEO;

        pCaps->dwCaps2   |= DDCAPS2_NOPAGELOCKREQUIRED;
    }

    return(b);
}

/******************************Public*Routine******************************\
* BOOL bDdGetDriverInfo
*
* Assumes devlock already held.
*
* In case the driver partially filled in the structure before it decided
* to fail, we always zero the buffer in the event of failure.
*
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdGetDriverInfo(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    const GUID*             pGuid,
    VOID*                   pvBuffer,
    ULONG                   cjSize,
    ULONG*                  pjSizeReturned
    )
{
    PDD_GETDRIVERINFO       pfnGetDriverInfo;
    DD_GETDRIVERINFODATA    GetDriverInfoData;
    DWORD                   dwRet = DDHAL_DRIVER_NOTHANDLED;
    DWORD                   dwSize;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    pfnGetDriverInfo = peDirectDrawGlobal->HalInfo.GetDriverInfo;

    if( ( pfnGetDriverInfo != NULL ) &&
        (peDirectDrawGlobal->HalInfo.dwFlags & DDHALINFO_GETDRIVERINFOSET))
    {
        RtlZeroMemory(&GetDriverInfoData, sizeof(GetDriverInfoData));

        GetDriverInfoData.dhpdev         = peDirectDrawGlobal->dhpdev;
        GetDriverInfoData.dwSize         = sizeof(GetDriverInfoData);
        GetDriverInfoData.guidInfo       = *pGuid;
        GetDriverInfoData.dwExpectedSize = cjSize;
        GetDriverInfoData.lpvData        = pvBuffer;
        GetDriverInfoData.ddRVal         = DDERR_CURRENTLYNOTAVAIL;

        dwRet = pfnGetDriverInfo(&GetDriverInfoData);
    }

    if (dwRet == DDHAL_DRIVER_HANDLED &&
        GetDriverInfoData.ddRVal == DD_OK)
    {
        if (pjSizeReturned != NULL)
        {
            *pjSizeReturned = GetDriverInfoData.dwActualSize;
        }

        return TRUE;
    }
    else
    {
        RtlZeroMemory(pvBuffer, cjSize);

        if (pjSizeReturned != NULL)
        {
            *pjSizeReturned = 0;
        }

        return FALSE;
    }
}

/******************************Public*Routine******************************\
* BOOL bDdIoQueryInterface
*
*  12-Feb-1998 -by- Drew Bliss [drewb]
* Made vDdQueryMiniportDxApiSupport generic for QI requests.
\**************************************************************************/

BOOL
bDdIoQueryInterface(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    const GUID*             pguid,
    DWORD                   cjInterface,
    DWORD                   dwDesiredVersion,
    INTERFACE*              pInterface
    )
{
    BOOL                bSuccess;
    PDEVICE_OBJECT      hDevice;
    KEVENT              event;
    PIRP                pIrp;
    IO_STATUS_BLOCK     Iosb;
    PIO_STACK_LOCATION  stack;
    DDGETIRQINFO        GetIrqInfo;

    bSuccess = FALSE;                       // Assume failure

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);   // Synchronize call into miniport

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    hDevice = (PDEVICE_OBJECT) po.hScreen();

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    pIrp = IoBuildSynchronousFsdRequest(IRP_MJ_FLUSH_BUFFERS,
                                        hDevice,
                                        NULL,
                                        0,
                                        NULL,
                                        &event,
                                        &Iosb);
    if (pIrp != NULL)
    {
        pIrp->IoStatus.Status = Iosb.Status = STATUS_NOT_SUPPORTED;

        stack = IoGetNextIrpStackLocation(pIrp);

        stack->MajorFunction
            = IRP_MJ_PNP;

        stack->MinorFunction
            = IRP_MN_QUERY_INTERFACE;

        stack->Parameters.QueryInterface.InterfaceType
            = pguid;

        stack->Parameters.QueryInterface.Size
            = (USHORT)cjInterface;

        stack->Parameters.QueryInterface.Version
            = (USHORT)dwDesiredVersion;

        stack->Parameters.QueryInterface.Interface
            = pInterface;

        stack->Parameters.QueryInterface.InterfaceSpecificData
            = NULL;

        // Note that we allow newer interfaces to work with older system
        // code so that new drivers can run on older systems.

        if (NT_SUCCESS(IoCallDriver(hDevice, pIrp)))
        {
            if ((pInterface->Version >= dwDesiredVersion) &&
                (pInterface->Size >= cjInterface) &&
                (pInterface->Context != NULL))
            {
                bSuccess = TRUE;
            }
            else
            {
                WARNING("bDdIoQueryInterface: "
                        "Driver returned invalid QueryInterface data.");
            }
        }
    }
    else
    {
        WARNING("bDdIoQueryInterface: Unable to build request.");
    }

    return bSuccess;
}

/******************************Public*Routine******************************\
* BOOL bDdGetAllDriverInfo
*
* Makes GetDriverInfo HAL calls to determine capabilities of the device,
* such as for Direct3D or VPE.
*
* Assumes devlock already held.
*
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdGetAllDriverInfo(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    DWORD               dwMaxVideoPorts;
    ULONG               cjMaxVideoPorts;
    DDVIDEOPORTCAPS*    pVideoPortCaps;
    ULONG               i;
    DWORD               dwRet;
    DWORD               dwOverride;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    // Get driver override info:

    dwOverride = po.dwDriverCapableOverride();

    // Get DXAPI info:

    vDdQueryMiniportDxApiSupport(peDirectDrawGlobal);

    // Get AGP info:

    if (!bDdIoQueryInterface(peDirectDrawGlobal,
                             &GUID_AGP_INTERFACE,
                             sizeof(AGP_INTERFACE),
                             AGP_INTERFACE_VERSION,
                             (INTERFACE *)
                             &peDirectDrawGlobal->AgpInterface))
    {
        RtlZeroMemory(&peDirectDrawGlobal->AgpInterface,
                      sizeof(peDirectDrawGlobal->AgpInterface));
    }

    if ((peDirectDrawGlobal->HalInfo.GetDriverInfo != NULL) &&
        (peDirectDrawGlobal->HalInfo.dwFlags & DDHALINFO_GETDRIVERINFOSET))
    {
        // DX5 callbacks are never used on NT so we do not bother to ask the driver for them
        // We simply zero them out

        RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks2,
                      sizeof(peDirectDrawGlobal->D3dCallBacks2));

        // Get D3DCallbacks3.  If this fails the callbacks will
        // be NULL. Also check if this driver is capable of doing D3D or not

        if ((!(dwOverride & DRIVER_NOT_CAPABLE_D3D))
          &&bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_D3DCallbacks3,
                             &peDirectDrawGlobal->D3dCallBacks3,
                             sizeof(peDirectDrawGlobal->D3dCallBacks3),
                             NULL))
        {
            // It needs to accept a new GUID
            if (bDdGetDriverInfo(peDirectDrawGlobal,
                                 &GUID_D3DParseUnknownCommandCallback,
                                 &D3DParseUnknownCommand, 0, NULL))
            {
                peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_D3DCALLBACKS3;
            }
            else
            {
                // If the GUID is not recognized, stub out Callbacks3
                WARNING("vDdGetAllDriverInfo: Driver failed GUID_D3DParseUnknownCommandCallback but understood GUID_D3DCallbacks3");
                RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks3,
                              sizeof(peDirectDrawGlobal->D3dCallBacks3));
                return FALSE;
            }
        }

        // Note: GUID_ZPixelFormats is not queried because kernel doesn't need to
        //       store the DDPIXELFORMATS data

        // Get DXAPI ("Kernel-Mode") capabilities.

        dwRet = DXERR_GENERIC;
        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_KernelCaps,
                             &peDirectDrawGlobal->DDKernelCaps,
                             sizeof(peDirectDrawGlobal->DDKernelCaps),
                             NULL))
        {
            /*
             * They may have said that they have IRQ capabilites, but
             * we need to make sure this is really the case.  For this,
             * we can call the GetIRQInfo function in the miniport.
             */
            if( peDirectDrawGlobal->DxApiInterface.DxGetIrqInfo != NULL )
            {
                DDGETIRQINFO GetIRQInfo;

                dwRet = peDirectDrawGlobal->DxApiInterface.DxGetIrqInfo(
                    peDirectDrawGlobal->HwDeviceExtension,
                    NULL,
                    &GetIRQInfo);
                if( GetIRQInfo.dwFlags != IRQINFO_HANDLED )
                {
                    dwRet = DXERR_GENERIC;
                }
            }
        }

        if( dwRet != DX_OK )
        {
            peDirectDrawGlobal->DDKernelCaps.dwIRQCaps = 0;
            peDirectDrawGlobal->DDKernelCaps.dwCaps &= ~( DDKERNELCAPS_AUTOFLIP |
                DDKERNELCAPS_CAPTURE_SYSMEM | DDKERNELCAPS_CAPTURE_NONLOCALVIDMEM );
        }

        // Get VPE info:

        dwMaxVideoPorts = peDirectDrawGlobal->HalInfo.ddCaps.dwMaxVideoPorts;
        if (dwMaxVideoPorts != 0)
        {
            if (bDdGetDriverInfo(peDirectDrawGlobal,
                                 &GUID_VideoPortCallbacks,
                                 &peDirectDrawGlobal->VideoPortCallBacks,
                                 sizeof(peDirectDrawGlobal->VideoPortCallBacks),
                                 NULL))
            {
                cjMaxVideoPorts = sizeof(DDVIDEOPORTCAPS) * dwMaxVideoPorts;

                pVideoPortCaps = (DDVIDEOPORTCAPS*) PALLOCMEM(cjMaxVideoPorts,
                                                              'pddG');
                if (pVideoPortCaps != NULL)
                {
                    if (bDdGetDriverInfo(peDirectDrawGlobal,
                                         &GUID_VideoPortCaps,
                                         pVideoPortCaps,
                                         cjMaxVideoPorts,
                                         NULL))
                    {
                        peDirectDrawGlobal->HalInfo.ddCaps.dwMaxVideoPorts
                            = dwMaxVideoPorts;
                        peDirectDrawGlobal->lpDDVideoPortCaps
                            = pVideoPortCaps;
                        peDirectDrawGlobal->flDriverInfo
                            |= DD_DRIVERINFO_VIDEOPORT;

                        for (i = 0; i < dwMaxVideoPorts; i++)
                        {
                            if (peDirectDrawGlobal->DDKernelCaps.dwIRQCaps
                                    & (DDIRQ_VPORT0_VSYNC << (i * 2)) &&
                                (peDirectDrawGlobal->DDKernelCaps.dwCaps
                                    & DDKERNELCAPS_AUTOFLIP))
                            {
                                // Can do software autoflipping.

                                pVideoPortCaps[i].dwCaps |= DDVPCAPS_AUTOFLIP;
                                pVideoPortCaps[i].dwNumAutoFlipSurfaces
                                    = MAX_AUTOFLIP_BUFFERS;
                                if (pVideoPortCaps[i].dwCaps & DDVPCAPS_VBISURFACE)
                                {
                                    pVideoPortCaps[i].dwNumVBIAutoFlipSurfaces
                                         = MAX_AUTOFLIP_BUFFERS;
                                }
                            }
                        }
                    }
                    else
                    {
                        RIP("vDdGetAllDriverInfo: Driver failed GUID_VideoPortCaps");

                        RtlZeroMemory(&peDirectDrawGlobal->VideoPortCallBacks,
                                sizeof(peDirectDrawGlobal->VideoPortCallBacks));

                        VFREEMEM(pVideoPortCaps);
                    }
                }
            }
        }

        // Get ColorControl info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_ColorControlCallbacks,
                             &peDirectDrawGlobal->ColorControlCallBacks,
                             sizeof(peDirectDrawGlobal->ColorControlCallBacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_COLORCONTROL;
        }

        // Get Miscellaneous info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_MiscellaneousCallbacks,
                             &peDirectDrawGlobal->MiscellaneousCallBacks,
                             sizeof(peDirectDrawGlobal->MiscellaneousCallBacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MISCELLANEOUS;
        }

        // Get Miscellaneous2 info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_Miscellaneous2Callbacks,
                             &peDirectDrawGlobal->Miscellaneous2CallBacks,
                             sizeof(peDirectDrawGlobal->Miscellaneous2CallBacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MISCELLANEOUS2;
        }
        else
        {
            // If the GUID is not recognized, stub out D3DCallbacks3...
            RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks3,
                          sizeof(peDirectDrawGlobal->D3dCallBacks3));
            // ... and clear the bit
            peDirectDrawGlobal->flDriverInfo &= ~DD_DRIVERINFO_D3DCALLBACKS3;
            // Stub out all other d3d driver info
            RtlZeroMemory(&peDirectDrawGlobal->D3dDriverData,
                          sizeof(peDirectDrawGlobal->D3dDriverData));
            RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks,
                          sizeof(peDirectDrawGlobal->D3dCallBacks));
            RtlZeroMemory(&peDirectDrawGlobal->D3dBufCallbacks,
                          sizeof(peDirectDrawGlobal->D3dBufCallbacks));
        }

        // Get NT info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_NTCallbacks,
                             &peDirectDrawGlobal->NTCallBacks,
                             sizeof(peDirectDrawGlobal->NTCallBacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_NT;
        }

        // Get MoreCaps info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_DDMoreCaps,
                             &peDirectDrawGlobal->MoreCaps,
                             sizeof(peDirectDrawGlobal->MoreCaps),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MORECAPS;
        }

        // Get PrivateDriverCaps info. If the driver is not capable of D3D
        // then don't do it

        if ((!(dwOverride & DRIVER_NOT_CAPABLE_D3D))
            &&(bDdGetDriverInfo(peDirectDrawGlobal,
                                &GUID_NTPrivateDriverCaps,
                                &peDirectDrawGlobal->PrivateCaps,
                                sizeof(peDirectDrawGlobal->PrivateCaps),
                                NULL)))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_PRIVATECAPS;
        }

        // Get DXAPI ("Kernel-Mode") call-backs.  Note that we don't bother
        // with a flag because user-mode never needs to know whether the
        // driver has actually hooked these or not.

        bDdGetDriverInfo(peDirectDrawGlobal,
                         &GUID_KernelCallbacks,
                         &peDirectDrawGlobal->DxApiCallBacks,
                         sizeof(peDirectDrawGlobal->DxApiCallBacks),
                         NULL);

        // Get MotionComp info:

        if (bDdGetDriverInfo(peDirectDrawGlobal,
                             &GUID_MotionCompCallbacks,
                             &peDirectDrawGlobal->MotionCompCallbacks,
                             sizeof(peDirectDrawGlobal->MotionCompCallbacks),
                             NULL))
        {
            peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MOTIONCOMP;
        }
     }

    // Determine if the device supports gamma ramps or not

    peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &= ~DDCAPS2_PRIMARYGAMMA;
    if ((po.iDitherFormat() == BMF_8BPP)  ||
        ((PPFNVALID(po, IcmSetDeviceGammaRamp)) &&
        (po.flGraphicsCaps2() & GCAPS2_CHANGEGAMMARAMP)))
    {
        peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 |= DDCAPS2_PRIMARYGAMMA;
    }

    // Squish any ROP caps that the driver may have set so apps will
    // know that they're not supported.

    RtlZeroMemory(peDirectDrawGlobal->HalInfo.ddCaps.dwRops,
            sizeof( peDirectDrawGlobal->HalInfo.ddCaps.dwRops ) );
    RtlZeroMemory(peDirectDrawGlobal->HalInfo.ddCaps.dwSVBRops,
            sizeof( peDirectDrawGlobal->HalInfo.ddCaps.dwSVBRops ) );
    RtlZeroMemory(peDirectDrawGlobal->HalInfo.ddCaps.dwVSBRops,
            sizeof( peDirectDrawGlobal->HalInfo.ddCaps.dwVSBRops ) );
    RtlZeroMemory(peDirectDrawGlobal->HalInfo.ddCaps.dwSSBRops,
            sizeof( peDirectDrawGlobal->HalInfo.ddCaps.dwSSBRops ) );

    return TRUE;
}

/******************************Public*Routine******************************\
* DWORD dwDdSetAGPPolicy()
*
* Reads the DirectDraw AGP policy value from the registry and adjusts as
* necessary.
*
* Note: This policy only restricts the size per heap. If the driver exposes
* more than 1 heap, it should do extra work to determine reasonable heap
* sizes based on total physical memory and perhaps other data.
*
*  28-Sep-1999 -by- John Stephens [johnstep]
* Copied from llDdAssertModeTimeout().
\**************************************************************************/

#define AGP_BASE_MEMORY_PAGES       ((64 * 1024 * 1024) / PAGE_SIZE)

// The following are the limits of an AGP reservation:

#define AGP_MINIMUM_MAX_PAGES   ((8 * 1024 * 1024) / PAGE_SIZE)
#define AGP_MAXIMUM_MAX_PAGES ((256 * 1024 * 1024) / PAGE_SIZE)

DWORD
dwDdSetAgpPolicy(
    )
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    DWORD                       Length;
    DWORD                       Policy;
    PKEY_VALUE_FULL_INFORMATION Information;
    SYSTEM_BASIC_INFORMATION    BasicInfo;

    status = ZwQuerySystemInformation(SystemBasicInformation,
                                      (VOID*) &BasicInfo,
                                      sizeof BasicInfo,
                                      NULL);

    if (!NT_SUCCESS(status) || 
        (BasicInfo.NumberOfPhysicalPages < AGP_MINIMUM_MAX_PAGES))
    {
        return 0;
    }

    // By default, we let them use all of the memory minus 64 Meg

    Policy = BasicInfo.NumberOfPhysicalPages - AGP_BASE_MEMORY_PAGES;
    if ((Policy < AGP_MINIMUM_MAX_PAGES) ||
        (BasicInfo.NumberOfPhysicalPages < AGP_BASE_MEMORY_PAGES))
    {
        // But some drivers (nvidia) really need to have at least 8 Meg, so we
        // need to give them at least that much.
        Policy = AGP_MINIMUM_MAX_PAGES;
    }

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                         L"Control\\GraphicsDrivers");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&hkRegistry, GENERIC_READ, &ObjectAttributes);

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&UnicodeString, L"AGPPolicyMaxPages");

        Length = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(L"AGPPolicyMaxPages") +
                 sizeof(DWORD);


        Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, ' ddG');

        if (Information)
        {
            status = ZwQueryValueKey(hkRegistry,
                                       &UnicodeString,
                                       KeyValueFullInformation,
                                       Information,
                                       Length,
                                       &Length);

            if (NT_SUCCESS(status))
            {
                Policy = *( (LPDWORD) ((((PUCHAR)Information) +
                            Information->DataOffset)) );
            }

            VFREEMEM(Information);
        }

        ZwCloseKey(hkRegistry);
    }

    // Clamp policy maximum pages:

    if (Policy < AGP_MINIMUM_MAX_PAGES)
    {
        Policy = 0;
    }
    else 
    {
        Policy = min(Policy, AGP_MAXIMUM_MAX_PAGES);
        if (BasicInfo.NumberOfPhysicalPages > AGP_BASE_MEMORY_PAGES)
        {
            Policy = min( Policy, 
                (BasicInfo.NumberOfPhysicalPages -
                    AGP_BASE_MEMORY_PAGES));
        }

        // Round down to the nearest 64 KB multiple and convert to bytes:

        Policy = (Policy & ~0xF) * PAGE_SIZE;
    }

    return Policy;
}

/******************************Public*Routine******************************\
* VOID vDdInitHeaps
*
* Initializes video memory heaps returned by the driver.
*
* Assumes devlock already held and AGP functions queried.
*
*  6-Feb-1998 -by- Drew Bliss [drewb]
* Wrote it.
\**************************************************************************/

VOID
vDdInitHeaps(EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal)
{
    DWORD dwHeap;
    VIDEOMEMORY* pHeap;

    DDKHEAP(("DDKHEAP: Initializing %d heaps\n",
             peDirectDrawGlobal->dwNumHeaps));

    // Set the AGP policy here:

    dwAGPPolicyMaxBytes = dwDdSetAgpPolicy();

    // Initialize heaps which aren't preallocated.
    pHeap = peDirectDrawGlobal->pvmList;
    for (dwHeap = 0;
         dwHeap < peDirectDrawGlobal->dwNumHeaps;
         pHeap++, dwHeap++)
    {
        // If the current heap is an AGP heap but we were unable to
        // get access to the AGP control functions then we can't use it,
        // so remove it from the list.
        //
        // The heap is also disabled in the case where a driver reports
        // a non-local heap but doesn't report non-local vidmem caps.
        if ((pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
            (peDirectDrawGlobal->AgpInterface.Context == NULL ||
             (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &
              DDCAPS2_NONLOCALVIDMEM) == 0))
        {
            DDKHEAP(("DDKHEAP: Disabling AGP heap %d\n", dwHeap));

            pHeap->dwFlags |= VIDMEM_HEAPDISABLED;
        }
        else if (!(pHeap->dwFlags & VIDMEM_ISHEAP))
        {
            // Get any heap alignment restrictions from driver:

            DD_GETHEAPALIGNMENTDATA GetHeapAlignmentData;
            HEAPALIGNMENT* pHeapAlignment = NULL;

            RtlZeroMemory(&GetHeapAlignmentData, sizeof GetHeapAlignmentData);

            GetHeapAlignmentData.dwInstance =
                (ULONG_PTR) peDirectDrawGlobal->dhpdev;
            GetHeapAlignmentData.dwHeap = dwHeap;
            GetHeapAlignmentData.ddRVal = DDERR_GENERIC;
            GetHeapAlignmentData.Alignment.dwSize =
                sizeof GetHeapAlignmentData.Alignment;

            if (bDdGetDriverInfo(peDirectDrawGlobal,
                                 &GUID_GetHeapAlignment,
                                 &GetHeapAlignmentData,
                                 sizeof GetHeapAlignmentData,
                                 NULL))
            {
                pHeapAlignment = &GetHeapAlignmentData.Alignment;
            }

            DDKHEAP(("DDKHEAP: Initializing heap %d, flags %X\n",
                     dwHeap, pHeap->dwFlags));

            if (HeapVidMemInit(pHeap,
                               peDirectDrawGlobal->
                               HalInfo.vmiData.lDisplayPitch,
                               AGP_HDEV(peDirectDrawGlobal),
                               pHeapAlignment) == NULL)
            {
                DDKHEAP(("DDKHEAP: Heap %d failed init\n", dwHeap));

                pHeap->dwFlags |= VIDMEM_HEAPDISABLED;
            }
            else
            {
                DDKHEAP(("DDKHEAP: Heap %d is %08X\n",
                         dwHeap, pHeap->lpHeap));
                if (pHeap->dwFlags & VIDMEM_ISNONLOCAL)
                {
                    pHeap->lpHeap->hdevAGP = AGP_HDEV(peDirectDrawGlobal);
                }
            }
        }
    }

    {
        ULONG ulHeaps=peDirectDrawGlobal->dwNumHeaps;
        ULONG cjData=sizeof(DD_MORESURFACECAPS)-sizeof(DDSCAPSEX)*2+
              ulHeaps*sizeof(DDSCAPSEX)*2;
        // allocate memory in ddraw style, add some junk after data strucure
        // so that not well behaved driver does not break the kernel.
        PDD_MORESURFACECAPS pDDMoreSurfaceCaps=(PDD_MORESURFACECAPS)
                PALLOCMEM(cjData+0x400,'pddG');

        RtlZeroMemory(&peDirectDrawGlobal->MoreSurfaceCaps,
                      sizeof(peDirectDrawGlobal->MoreSurfaceCaps));

        if (pDDMoreSurfaceCaps!=NULL)
        {
            RtlZeroMemory(pDDMoreSurfaceCaps, cjData);
            pDDMoreSurfaceCaps->dwSize=cjData;
            if (bDdGetDriverInfo(peDirectDrawGlobal,
                                 &GUID_DDMoreSurfaceCaps,
                                 pDDMoreSurfaceCaps,
                                 cjData,
                                 &cjData))
            {
                // now fill ddscaps into heaps
                // directdraw runtime does not expect the heap restrictions
                ULONG cjCopy= (ULONG)min(sizeof(DD_MORESURFACECAPS)-sizeof(DDSCAPSEX)*2,cjData);
                pDDMoreSurfaceCaps->dwSize=cjCopy;
                RtlCopyMemory(&peDirectDrawGlobal->MoreSurfaceCaps,
                              pDDMoreSurfaceCaps,
                              cjCopy);

                // now Copy ddxCapsex/ExAlt members to heaps...
                pHeap = peDirectDrawGlobal->pvmList;
                for (dwHeap = 0;
                     dwHeap < ulHeaps;
                     pHeap++, dwHeap++)
                {
                    if (!(pHeap->dwFlags&VIDMEM_HEAPDISABLED))
                    {
                        RtlCopyMemory(
                                &pHeap->lpHeap->ddsCapsEx,
                                &pDDMoreSurfaceCaps->ddsExtendedHeapRestrictions[dwHeap].ddsCapsEx,
                                sizeof(DDSCAPSEX));
                        RtlCopyMemory(
                                &pHeap->lpHeap->ddsCapsExAlt,
                                &pDDMoreSurfaceCaps->ddsExtendedHeapRestrictions[dwHeap].ddsCapsExAlt,
                                sizeof(DDSCAPSEX));
                    }
                }
                peDirectDrawGlobal->flDriverInfo |= DD_DRIVERINFO_MORESURFACECAPS;
            }
            VFREEMEM(pDDMoreSurfaceCaps);
        }
    }
}

/******************************Public*Routine******************************\
* VOID UpdateNonLocalHeap
*
* Notifies the driver when the AGP heap information changes.
*
*   2-Mar-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void UpdateNonLocalHeap(
            EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
            DWORD                   dwHeapIndex
            )
{
    DD_UPDATENONLOCALHEAPDATA UpdateNonLocalHeapData;
    LPVIDMEM      lpVidMem = &(peDirectDrawGlobal->pvmList[dwHeapIndex]);

    UpdateNonLocalHeapData.lpDD = peDirectDrawGlobal;
    UpdateNonLocalHeapData.dwHeap = dwHeapIndex;
    UpdateNonLocalHeapData.fpGARTLin = lpVidMem->lpHeap->fpGARTLin;
    UpdateNonLocalHeapData.fpGARTDev = lpVidMem->lpHeap->fpGARTDev;
    UpdateNonLocalHeapData.ulPolicyMaxBytes = 0;
    UpdateNonLocalHeapData.ddRVal = DDERR_GENERIC;

    bDdGetDriverInfo(peDirectDrawGlobal,
        &GUID_UpdateNonLocalHeap,
        &UpdateNonLocalHeapData,
        sizeof UpdateNonLocalHeapData,
        NULL);
}

/******************************Public*Routine******************************\
* VOID InitAgpHeap
*
* We do not want to call AGPReserve in HeapVidMemInit since it is called on
* every mode change, so instead we have a seperate function that reserves the
* AGP memory and it is called after the rest of the heap is initialized.
*
*  22-Feb-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID 
InitAgpHeap( 
            EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal, 
            DWORD                   dwHeapIndex,
            HANDLE                  hdev
            )
{
    DWORD         dwSize;
    FLATPTR       fpLinStart;
    LARGE_INTEGER liDevStart;
    PVOID         pvReservation;
    BOOL          fIsUC;
    BOOL          fIsWC;
    DWORD         dwSizeReserved = 0;
    LPVIDMEM      lpVidMem = &(peDirectDrawGlobal->pvmList[dwHeapIndex]);

    /*
     * Compute the size of the heap.
     */
    dwSize = lpVidMem->lpHeap->dwTotalSize;
    DDASSERT( 0UL != dwSize );

    if( lpVidMem->dwFlags & VIDMEM_ISWC )
    {
        fIsUC = FALSE;
        fIsWC = TRUE;
    }
    else
    {
        fIsUC = TRUE;
        fIsWC = FALSE;
    }

    /*
     * Allocate a bit mask to keep track of which pages have been 
     * committed or not.
     */
    lpVidMem->lpHeap->dwAgpCommitMaskSize = 
        (GetHeapSizeInPages(lpVidMem, lpVidMem->lpHeap->stride) / BITS_IN_BYTE) + 1;
    lpVidMem->lpHeap->pAgpCommitMask = 
        (BYTE*) PALLOCMEM(lpVidMem->lpHeap->dwAgpCommitMaskSize, 'pddG');
    if( lpVidMem->lpHeap->pAgpCommitMask == NULL )
    {
        lpVidMem->dwFlags |= VIDMEM_HEAPDISABLED;
        return;
    }

    if( !(dwSizeReserved = AGPReserve( hdev, dwSize, fIsUC, fIsWC,
                                       &fpLinStart, &liDevStart,
                                       &pvReservation )) )
    {
        VDPF(( 0, V, "Could not reserve a GART address range for a "
               "linear heap of size 0x%08x", dwSize ));
        VFREEMEM(lpVidMem->lpHeap->pAgpCommitMask);
        lpVidMem->lpHeap->pAgpCommitMask = NULL;
        lpVidMem->dwFlags |= VIDMEM_HEAPDISABLED;
        return;
    }
    else
    {
        VDPF((4,V, "Allocated a GART address range starting at "
              "0x%08x (linear) 0x%08x:0x%08x (physical) of size %d",
              fpLinStart, liDevStart.HighPart, liDevStart.LowPart,
              dwSizeReserved ));
    }

    if (dwSizeReserved != dwSize)
    {
        VDPF((0,V,"WARNING! This system required that the full "
              "nonlocal aperture could not be reserved!"));
        VDPF((0,V,"         Requested aperture:%08x, "
              "Reserved aperture:%08x", dwSize, dwSizeReserved));
    }

    /*
     * Update the heap for the new start address
     * (and end address for a linear heap).
     */
    lpVidMem->fpStart = fpLinStart;
    if( lpVidMem->dwFlags & VIDMEM_ISLINEAR )
    {
        LPVMEML plh;

        lpVidMem->fpEnd = ( fpLinStart + dwSizeReserved ) - 1UL;
        lpVidMem->lpHeap->dwTotalSize = dwSizeReserved;
        plh = (LPVMEML)lpVidMem->lpHeap->freeList;
        if( ( plh != NULL ) && ( plh->ptr == 0 ) )
        {
            plh->ptr = lpVidMem->fpStart;
            plh->size = dwSizeReserved;
        }
    }
    else
    {
        LPVMEMR prh;
        DWORD   dwHeight;

        DDASSERT( lpVidMem->dwFlags & VIDMEM_ISRECTANGULAR );
        dwHeight = dwSizeReserved / lpVidMem->lpHeap->stride;
        lpVidMem->lpHeap->dwTotalSize = dwHeight * lpVidMem->lpHeap->stride;
        prh = (LPVMEMR)lpVidMem->lpHeap->freeList;
        if( ( prh != NULL ) && ( prh->cy != 0x7fffffff ) )
        {
            prh->ptr = lpVidMem->fpStart;
            prh->cy = dwHeight;
            prh->size = (lpVidMem->dwWidth << 16 ) | dwHeight;
        }
    }

    lpVidMem->lpHeap->fpGARTLin      = fpLinStart;
    // Fill in partial physical address for Win9x.
    lpVidMem->lpHeap->fpGARTDev      = liDevStart.LowPart;
    // Fill in complete physical address for NT.
    lpVidMem->lpHeap->liPhysAGPBase  = liDevStart;
    lpVidMem->lpHeap->pvPhysRsrv     = pvReservation;

    UpdateNonLocalHeap( peDirectDrawGlobal, dwHeapIndex );

} /* InitAgpHeap */

/******************************Public*Routine******************************\
* VOID CheckAgpHeaps
*
* This funtion is called periodically to make sure that we initialize any
* uninitialized AGP heaps.
*
*  22-Feb-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void CheckAgpHeaps(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    LPVIDMEM    pHeap;
    DWORD       i;

    pHeap = peDirectDrawGlobal->pvmList;
    for( i = 0; i < peDirectDrawGlobal->dwNumHeaps; pHeap++, i++)
    {
        if ((pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
            !(pHeap->dwFlags & VIDMEM_ISHEAP) &&
            !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
            (pHeap->lpHeap->pvPhysRsrv == NULL))
        {
            InitAgpHeap( peDirectDrawGlobal, 
                         i,
                         AGP_HDEV(peDirectDrawGlobal));
        }
    }
}

/******************************Public*Routine******************************\
* VOID MapAllAgpHeaps
*
* This funtion is virtually map all AGP heaps.  It also virtually commits
* them to everything that is physically committed.
*
*  25-Apr-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

void MapAllAgpHeaps(
    EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocal
    )
{
    if (peDirectDrawLocal->ppeMapAgp != NULL)
    {
        VIDEOMEMORY*            pvmHeap;
        DWORD                   i;
        EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
        for (i = 0; i < peDirectDrawGlobal->dwNumHeaps; i++)
        {
            pvmHeap = &peDirectDrawGlobal->pvmList[i];

            if ((pvmHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
                !(pvmHeap->dwFlags & VIDMEM_ISHEAP) &&
                !(pvmHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
                (pvmHeap->lpHeap != NULL) &&
                (pvmHeap->lpHeap->pvPhysRsrv != NULL) && 
                (peDirectDrawLocal->ppeMapAgp[i] == NULL))
            {
                // Reserve address space for the heap:

                if (bDdMapAgpHeap(peDirectDrawLocal, pvmHeap))
                {
                    if (peDirectDrawLocal->ppeMapAgp[i] != NULL)
                    {
                        AGPCommitAllVirtual (peDirectDrawLocal, pvmHeap, i);
                    }
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDdDisableDriver
*
* Frees and destroys all driver state.  Note that this may be called
* even while the driver is still only partially enabled.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDisableDriver(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    PDEVOBJ po(peDirectDrawGlobal->hdev);

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    if (peDirectDrawGlobal->pvmList != NULL)
    {
        DWORD dwHeap;
        VIDEOMEMORY* pHeap;

        // Shut down heaps.

        DDKHEAP(("DDKHEAP: Shutting down %d heaps\n",
                 peDirectDrawGlobal->dwNumHeaps));

        pHeap = peDirectDrawGlobal->pvmList;
        for (dwHeap = 0;
             dwHeap < peDirectDrawGlobal->dwNumHeaps;
             pHeap++, dwHeap++)
        {
            if ((pHeap->dwFlags & VIDMEM_HEAPDISABLED) == 0 &&
                pHeap->lpHeap != NULL)
            {
                DDKHEAP(("DDKHEAP: Uninitializing heap %d\n", dwHeap));

                HeapVidMemFini(pHeap, AGP_HDEV(peDirectDrawGlobal));
            }
        }

        VFREEMEM(peDirectDrawGlobal->pvmList);
        peDirectDrawGlobal->pvmList = NULL;
    }

    if (peDirectDrawGlobal->pdwFourCC != NULL)
    {
        VFREEMEM(peDirectDrawGlobal->pdwFourCC);
        peDirectDrawGlobal->pdwFourCC = NULL;
    }

    if (peDirectDrawGlobal->lpDDVideoPortCaps != NULL)
    {

        VFREEMEM(peDirectDrawGlobal->lpDDVideoPortCaps);
        peDirectDrawGlobal->lpDDVideoPortCaps = NULL;
    }

    if (peDirectDrawGlobal->hDxApi != NULL)
    {
        vDdUnloadDxApiImage(peDirectDrawGlobal);
    }

    if (peDirectDrawGlobal->hdcCache != NULL)
    {
        // need to chage to 'current' since while it's in cache, it's 'none'
        DxEngSetDCOwner((HDC) peDirectDrawGlobal->hdcCache, OBJECT_OWNER_CURRENT);
        DxEngDeleteDC((HDC) peDirectDrawGlobal->hdcCache, TRUE);
        peDirectDrawGlobal->hdcCache = NULL;
    }

    if (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED)
    {
        peDirectDrawGlobal->fl &= ~DD_GLOBAL_FLAG_DRIVER_ENABLED;

        (*PPFNDRV(po, DisableDirectDraw))(po.dhpdev());
    }

    RtlZeroMemory((DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobal,
            sizeof(DD_DIRECTDRAW_GLOBAL_DRIVER_DATA));
}

/******************************Public*Routine******************************\
* VOID vDdEnableDriver
*
* Calls the driver's DrvGetDirectDrawInfo and DrvEnableDirectDraw
* functions to enable and initialize the driver and mode dependent
* portions of the global DirectDraw object.
*
* Assumes devlock already held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdEnableDriver(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    BOOL                        bSuccess;
    PFN_DrvGetDirectDrawInfo    pfnGetDirectDrawInfo;
    PFN_DrvEnableDirectDraw     pfnEnableDirectDraw;
    PFN_DrvDisableDirectDraw    pfnDisableDirectDraw;
    DWORD                       dwNumHeaps;
    DWORD                       dwNumFourCC;
    VIDEOMEMORY*                pvmList;
    DWORD*                      pdwFourCC;
    ULONG                       iDitherFormat;
    DWORD                       dw;

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    EDD_DEVLOCK eDevLock(peDirectDrawGlobal);

    // Call the driver to see what it can do:

    pfnGetDirectDrawInfo = PPFNDRV(po, GetDirectDrawInfo);
    pfnEnableDirectDraw  = PPFNDRV(po, EnableDirectDraw);
    pfnDisableDirectDraw = PPFNDRV(po, DisableDirectDraw);

    // To support DirectDraw, the driver must hook all three required
    // DirectDraw functions.

    bSuccess = ((pfnGetDirectDrawInfo != NULL) &&
                (pfnEnableDirectDraw != NULL)  &&
                (pfnDisableDirectDraw != NULL));

    dwNumHeaps = 0;
    dwNumFourCC = 0;

    peDirectDrawGlobal->fl &= ~DD_GLOBAL_FLAG_DRIVER_ENABLED;

    // Do the first DrvGetDirectDrawInfo query for this PDEV to
    // determine the number of heaps and the number of FourCC
    // codes that the driver supports, so that we know how
    // much memory to allocate:

    if ((bSuccess) &&
        (pfnGetDirectDrawInfo((DHPDEV) peDirectDrawGlobal->dhpdev,
                              &peDirectDrawGlobal->HalInfo,
                              &dwNumHeaps,
                              NULL,
                              &dwNumFourCC,
                              NULL)))
    {
        pvmList   = NULL;
        pdwFourCC = NULL;

        DDKHEAP(("DDKHEAP: Driver reports dwNumHeaps %d\n", dwNumHeaps));

        if (dwNumHeaps != 0)
        {
            pvmList = (VIDEOMEMORY*)
                      PALLOCMEM(sizeof(VIDEOMEMORY) * dwNumHeaps, 'vddG');
            peDirectDrawGlobal->dwNumHeaps = dwNumHeaps;
            peDirectDrawGlobal->pvmList = pvmList;

            if (pvmList == NULL)
                bSuccess = FALSE;
        }

        if (dwNumFourCC != 0)
        {
            pdwFourCC = (DWORD*)
                        PALLOCMEM(sizeof(DWORD) * dwNumFourCC, 'fddG');
            peDirectDrawGlobal->dwNumFourCC = dwNumFourCC;
            peDirectDrawGlobal->pdwFourCC = pdwFourCC;

            if (pdwFourCC == NULL)
                bSuccess = FALSE;
        }

        if (bSuccess)
        {
            // Do the second DrvGetDirectDrawInfo that actually
            // gets all the data:

            if (pfnGetDirectDrawInfo((DHPDEV) peDirectDrawGlobal->dhpdev,
                                     &peDirectDrawGlobal->HalInfo,
                                     &dwNumHeaps,
                                     pvmList,
                                     &dwNumFourCC,
                                     pdwFourCC))
            {
                // Ensure that the driver doesn't give us an invalid address
                // for its primary surface (like a user-mode address or NULL):
                if (peDirectDrawGlobal->HalInfo.vmiData.pvPrimary != NULL)
                {
                    dw = *((volatile DWORD *) peDirectDrawGlobal->HalInfo.vmiData.pvPrimary);
                    *((volatile DWORD *) peDirectDrawGlobal->HalInfo.vmiData.pvPrimary) = 0xabcdabcd;
		    *((volatile DWORD *) peDirectDrawGlobal->HalInfo.vmiData.pvPrimary) = dw;

                    if (pfnEnableDirectDraw((DHPDEV) peDirectDrawGlobal->dhpdev,
                                    &peDirectDrawGlobal->CallBacks,
                                    &peDirectDrawGlobal->SurfaceCallBacks,
                                    &peDirectDrawGlobal->PaletteCallBacks))
                    {
                        // Check the driver's capability status
                        DWORD dwOverride = po.dwDriverCapableOverride();

                        // check for D3D support here
                        if ( (!(dwOverride & DRIVER_NOT_CAPABLE_D3D))
                           &&(peDirectDrawGlobal->HalInfo.dwSize == sizeof(DD_HALINFO)) )
                        {
                            // for ease of porting, NT5 HALINFO has the same pointers
                            // to D3D data as DX5
                            if(peDirectDrawGlobal->HalInfo.lpD3DGlobalDriverData != NULL &&
                               ((D3DNTHAL_GLOBALDRIVERDATA*)
                                peDirectDrawGlobal->HalInfo.lpD3DGlobalDriverData)->dwSize ==
                               sizeof(D3DNTHAL_GLOBALDRIVERDATA))
                            {
                                peDirectDrawGlobal->D3dDriverData =
                                    *(D3DNTHAL_GLOBALDRIVERDATA*)peDirectDrawGlobal->HalInfo.lpD3DGlobalDriverData;
                                if( peDirectDrawGlobal->HalInfo.lpD3DHALCallbacks != NULL &&
                                    ((D3DNTHAL_CALLBACKS*)peDirectDrawGlobal->HalInfo.lpD3DHALCallbacks)->dwSize ==
                                    sizeof(D3DNTHAL_CALLBACKS))
                                {
                                    peDirectDrawGlobal->D3dCallBacks =
					*(D3DNTHAL_CALLBACKS*)peDirectDrawGlobal->HalInfo.lpD3DHALCallbacks;

                                    if( peDirectDrawGlobal->HalInfo.lpD3DBufCallbacks != NULL &&
                                        ((PDD_D3DBUFCALLBACKS)peDirectDrawGlobal->HalInfo.lpD3DBufCallbacks)->dwSize ==
                                        sizeof(DD_D3DBUFCALLBACKS))
                                    {
                                        peDirectDrawGlobal->D3dBufCallbacks =
                                            *(PDD_D3DBUFCALLBACKS)peDirectDrawGlobal->HalInfo.lpD3DBufCallbacks;
                                    }
                                }
                                else
                                {
                                    // D3DCaps succeeded but D3DCallbacks didn't, so we
                                    // must zero D3DCaps:

                                    RtlZeroMemory(&peDirectDrawGlobal->D3dDriverData,
                                                  sizeof(peDirectDrawGlobal->D3dDriverData));
                                }
                            }
                        }

                        // Use the GetDriverInfo HAL call to query any
                        // additional capabilities such as for Direct3D or
                        // VPE:

                        if (bDdGetAllDriverInfo(peDirectDrawGlobal))
                        {
                            if (bDdValidateDriverData(peDirectDrawGlobal))
                            {
                                // Initialize as many heaps as possible.
                                vDdInitHeaps(peDirectDrawGlobal);

                                peDirectDrawGlobal->fl |= DD_GLOBAL_FLAG_DRIVER_ENABLED;
                                return;
                            }
                        }

                        pfnDisableDirectDraw((DHPDEV) peDirectDrawGlobal->dhpdev);
                    }
                }
                else
                {
                    WARNING("vDdEnableDriver: Driver returned invalid vmiData.pvPrimary\n");
                }
            }
        }
    }

    // Something didn't work, so zero out all of the caps that we may have
    // gotten before the failure occurred.

    peDirectDrawGlobal->flDriver = 0;
    peDirectDrawGlobal->flDriverInfo = 0;
    if (peDirectDrawGlobal->pdwFourCC != NULL)
    {
        VFREEMEM(peDirectDrawGlobal->pdwFourCC);
        peDirectDrawGlobal->pdwFourCC = NULL;
    }
    peDirectDrawGlobal->dwNumFourCC = 0;

    if (peDirectDrawGlobal->pvmList != NULL)
    {
        VFREEMEM(peDirectDrawGlobal->pvmList);
        peDirectDrawGlobal->pvmList = NULL;
    }
    peDirectDrawGlobal->dwNumHeaps = 0;

    RtlZeroMemory( &peDirectDrawGlobal->DxApiInterface,
        sizeof( peDirectDrawGlobal->DxApiInterface ) );
    RtlZeroMemory( &peDirectDrawGlobal->AgpInterface,
        sizeof( peDirectDrawGlobal->AgpInterface ) );
    RtlZeroMemory( &peDirectDrawGlobal->DDKernelCaps,
        sizeof( peDirectDrawGlobal->DDKernelCaps ) );
    RtlZeroMemory( &peDirectDrawGlobal->DxApiCallBacks,
        sizeof( peDirectDrawGlobal->DxApiCallBacks ) );
    RtlZeroMemory(&peDirectDrawGlobal->D3dDriverData,
        sizeof(peDirectDrawGlobal->D3dDriverData));
    RtlZeroMemory(&peDirectDrawGlobal->CallBacks,
        sizeof(peDirectDrawGlobal->CallBacks));
    RtlZeroMemory(&peDirectDrawGlobal->D3dCallBacks,
        sizeof(peDirectDrawGlobal->D3dCallBacks));
    RtlZeroMemory(&peDirectDrawGlobal->D3dBufCallbacks,
        sizeof(peDirectDrawGlobal->D3dBufCallbacks));
    RtlZeroMemory(&peDirectDrawGlobal->SurfaceCallBacks,
        sizeof(peDirectDrawGlobal->SurfaceCallBacks));
    RtlZeroMemory(&peDirectDrawGlobal->PaletteCallBacks,
        sizeof(peDirectDrawGlobal->PaletteCallBacks));
    RtlZeroMemory(&peDirectDrawGlobal->HalInfo,
        sizeof(peDirectDrawGlobal->HalInfo));

    peDirectDrawGlobal->HalInfo.dwSize =
        sizeof(peDirectDrawGlobal->HalInfo);
    peDirectDrawGlobal->HalInfo.ddCaps.dwSize =
        sizeof(peDirectDrawGlobal->HalInfo.ddCaps);
    peDirectDrawGlobal->HalInfo.ddCaps.dwCaps = DDCAPS_NOHARDWARE;

    // Okay, we can't use the driver.  Initialize what information we need
    // from the PDEV so that system memory surfaces may still be used:

    iDitherFormat = po.iDitherFormat();
    if (iDitherFormat == BMF_4BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 4;
    }
    else if (iDitherFormat == BMF_8BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 8;
    }
    else if (iDitherFormat == BMF_16BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 16;
    }
    else if (iDitherFormat == BMF_24BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 24;
    }
    else if (iDitherFormat == BMF_32BPP)
    {
        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount = 32;
    }
    else
    {
        RIP("Invalid iDitherFormat()");
    }
}

/******************************Public*Routine******************************\
* VOID vDdIncrementReferenceCount
*
* Devlock must be held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdIncrementReferenceCount(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    peDirectDrawGlobal->cDriverReferences++;

    if (peDirectDrawGlobal->cDriverReferences == 1)
    {
        PDEVOBJ po(peDirectDrawGlobal->hdev);

        // Add a reference to the PDEV so that it won't be deleted
        // until the last D3D structure is freed.  We do this
        // so that on dynamic mode changes, we can keep the active
        // DirectDraw driver state around.  This is so that if we ever
        // return to the original mode, we can resume any Direct3D
        // accelerations exactly where we were originally.
        //
        // The DirectDraw convention is that if an accelerated Direct3D
        // application is started at 640x480, and the mode changes to
        // 800x600, the application stops drawing (unless it recreates
        // all its execute buffers and all other DirectX state).  But if
        // the display is returned back to the original 640x480 mode, all
        // the application has to do is 'restore' its surfaces, and it can
        // keep running.
        //
        // To allow this we have to keep around the driver's 640x480
        // instance even when the display is 800x600.  But if the
        // application terminated while at 800x600, we would have to clean
        // up the 640x480 driver instance.  Once that happens, the 640x480
        // PDEV can be completely deleted.  This is why we reference
        // count the PDEV:

        po.vReferencePdev();
    }
}

/******************************Public*Routine******************************\
* VOID vDdDecrementReferenceCount
*
* Devlock must not be held entering the function if PDEV may be unloaded.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDecrementReferenceCount(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    BOOL bUnreference = FALSE;

    {
        EDD_DEVLOCK eDevlock(peDirectDrawGlobal->hdev);

        ASSERTGDI(peDirectDrawGlobal->cDriverReferences > 0,
                "Weird reference count");

        if (--peDirectDrawGlobal->cDriverReferences == 0)
        {
            bUnreference = TRUE;
        }
    }

    if (bUnreference)
    {
        PDEVOBJ po(peDirectDrawGlobal->hdev);

        // If this dev lock is not held then we may free this driver.
        po.vUnreferencePdev();
    }
}

/******************************Public*Routine******************************\
* LONGLONG llDdAssertModeTimeout()
*
* Reads the DirectDraw timeout value from the registry.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Lifted it from AndreVa's code.
\**************************************************************************/

LONGLONG
llDdAssertModeTimeout(
    )
{
    HANDLE                      hkRegistry;
    OBJECT_ATTRIBUTES           ObjectAttributes;
    UNICODE_STRING              UnicodeString;
    NTSTATUS                    status;
    LONGLONG                    llTimeout;
    DWORD                       Length;
    PKEY_VALUE_FULL_INFORMATION Information;

    llTimeout = 0;

    RtlInitUnicodeString(&UnicodeString,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\"
                         L"Control\\GraphicsDrivers\\DCI");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    status = ZwOpenKey(&hkRegistry, GENERIC_READ, &ObjectAttributes);

    if (NT_SUCCESS(status))
    {
        RtlInitUnicodeString(&UnicodeString, L"Timeout");

        Length = sizeof(KEY_VALUE_FULL_INFORMATION) + sizeof(L"Timeout") +
                 sizeof(DWORD);

        Information = (PKEY_VALUE_FULL_INFORMATION) PALLOCMEM(Length, ' ddG');

        if (Information)
        {
            status = ZwQueryValueKey(hkRegistry,
                                       &UnicodeString,
                                       KeyValueFullInformation,
                                       Information,
                                       Length,
                                       &Length);

            if (NT_SUCCESS(status))
            {
                llTimeout = ((LONGLONG) -10000) * 1000 * (
                          *(LPDWORD) ((((PUCHAR)Information) +
                            Information->DataOffset)));
            }

            VFREEMEM(Information);
        }

        ZwCloseKey(hkRegistry);
    }

    return(llTimeout);
}

/******************************Public*Routine******************************\
* BOOL bDdMapAgpHeap
*
* Maps an AGP heap into a virtual address space.
*
*  25-Aug-1999 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

BOOL
bDdMapAgpHeap(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    VIDEOMEMORY*            pvmHeap
    )
{
    BOOL                    bSuccess = FALSE;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING*        peMap;
    BYTE*                   pAgpVirtualCommitMask;
    DWORD                   dwAgpVirtualCommitMaskSize;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    peMap = (EDD_VMEMMAPPING*) PALLOCMEM(sizeof(EDD_VMEMMAPPING), ' ddG');

    dwAgpVirtualCommitMaskSize = pvmHeap->lpHeap->dwAgpCommitMaskSize;
    if (dwAgpVirtualCommitMaskSize > 0)
    {
        pAgpVirtualCommitMask = (BYTE*)PALLOCMEM(dwAgpVirtualCommitMaskSize,
            ' ddG');
    }
    else
    {
        pAgpVirtualCommitMask = NULL;
    }
    if (pAgpVirtualCommitMask == NULL)
    {
        VFREEMEM(peMap);
        peMap = NULL;
    }

    if (peMap)
    {
        peMap->pvVirtAddr =
            peDirectDrawGlobal->AgpInterface.AgpServices.
                AgpReserveVirtual(peDirectDrawGlobal->AgpInterface.Context,
                                  NtCurrentProcess(),
                                  pvmHeap->lpHeap->pvPhysRsrv,
                                  &peMap->pvReservation);

        if (peMap->pvVirtAddr != NULL)
        {
            peMap->cReferences = 1;
            peMap->fl          = DD_VMEMMAPPING_FLAG_AGP;
            peMap->ulMapped    = 0;
            peMap->iHeapIndex  = (DWORD)
                (pvmHeap - peDirectDrawGlobal->pvmList);
            peMap->pAgpVirtualCommitMask = pAgpVirtualCommitMask;
            peMap->dwAgpVirtualCommitMaskSize = dwAgpVirtualCommitMaskSize;

            ASSERTGDI(peDirectDrawLocal->
                ppeMapAgp[peMap->iHeapIndex] == NULL,
                "Heap already mapped");

            peDirectDrawLocal->ppeMapAgp[peMap->iHeapIndex] = peMap;
            peDirectDrawLocal->iAgpHeapsMapped++;

            DDKHEAP(("DDKHEAP: Res %08X reserved %08X, size %X\n",
                    peMap->pvReservation, peMap->pvVirtAddr,
                    pvmHeap->lpHeap->dwTotalSize));

            bSuccess = TRUE;
        }
        else
        {
            VFREEMEM(peMap);
        }
    }

    return bSuccess;
}

/******************************Public*Routine******************************\
* VOID vDdUnmapMemory
*
* Deletes the user mode mapping of the frame buffer.
* We may be in a different process from the one in which
* the mapping was initially created in.
*
* The devlock must be held to call this function.
*
* Note: This should only be called from vDdUnreferenceVirtualMap
*
*  1-Oct-1998 -by- Anuj Gosalia [anujg]
* Wrote it.
\**************************************************************************/

VOID
vDdUnmapMemory(
    EDD_VMEMMAPPING*        peMap,
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    HANDLE                  ProcessHandle
    )
{
    DD_MAPMEMORYDATA        MapMemoryData;
    DWORD                   dwRet;
    NTSTATUS                Status;

    DDKHEAP(("vDdUnmapMemory: peDirectDrawGlobal=%x, fpProcess=%x\n",
            peDirectDrawGlobal, peMap->fpProcess));

    // Call driver to unmap memory:

    MapMemoryData.lpDD        = peDirectDrawGlobal;
    MapMemoryData.bMap        = FALSE;
    MapMemoryData.hProcess    = ProcessHandle;
    MapMemoryData.fpProcess   = peMap->fpProcess;

    dwRet = peDirectDrawGlobal->CallBacks.MapMemory(&MapMemoryData);

    ASSERTGDI((dwRet == DDHAL_DRIVER_NOTHANDLED) ||
              (MapMemoryData.ddRVal == DD_OK),
              "Driver failed DirectDraw memory unmap\n");
}

/******************************Public*Routine******************************\
* VOID vDdUnmapAgpHeap
*
* Decommits all virtual memory in an AGP heap, then releases the heap
* mapping. If the AGP heap is now empty, this function will decommit the
* physical memory as well.
*
* Note: This should only be called from vDdUnreferenceVirtualMap
*
*  19-Jan-1999 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

VOID
vDdUnmapAgpHeap(
    EDD_VMEMMAPPING*        peMap,
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal
    )
{
    VIDEOMEMORY*            pvmHeap;
    ULONG                   ulOffs;
    BOOL                    bSuccess;
    ULONG                   ulPages;
    ULONG                   ulHeapPages;

    pvmHeap = peDirectDrawGlobal->pvmList + peMap->iHeapIndex;

    ASSERTGDI(peMap != NULL,
        "Request to unmap an AGP heap which has not been mapped");
    ASSERTGDI(pvmHeap->lpHeap->pvPhysRsrv != NULL,
        "AGP reservation context is NULL in heap");

    if (!(peDirectDrawLocal->fl & DD_LOCAL_DISABLED))
    {
        bSuccess = AGPDecommitVirtual( peMap,
                                       peDirectDrawGlobal,
                                       peDirectDrawLocal,
                                       pvmHeap->lpHeap->dwTotalSize); 

        peDirectDrawGlobal->AgpInterface.AgpServices.
            AgpReleaseVirtual(peDirectDrawGlobal->AgpInterface.Context,
                              peMap->pvReservation); 

        peDirectDrawLocal->iAgpHeapsMapped--;
    }

    // If the heap is now empty but memory is still committed, go ahead and
    // decommit all the physical AGP memory:

    if ((pvmHeap->lpHeap->allocList == NULL) &&
        (pvmHeap->lpHeap->dwCommitedSize > 0))
    {
        DWORD                 dwTemp;
        EDD_DIRECTDRAW_LOCAL* peTempLocal; 
        EDD_VMEMMAPPING*      peTempMap;

        // We may have other processes that have virtual commits outstanding
        // even though they didn't allocate any AGP memory, so we can
        // decommit them now.

        peTempLocal = peDirectDrawGlobal->peDirectDrawLocalList;
        while (peTempLocal != NULL )
        {
            if (peTempLocal != peDirectDrawLocal)
            {
                if ((peTempLocal->ppeMapAgp != NULL) &&
                    !(peTempLocal->fl & DD_LOCAL_DISABLED))
                {
                    peTempMap = peTempLocal->ppeMapAgp[peMap->iHeapIndex];
                    if (peTempMap != NULL)
                    {
                        AGPDecommitVirtual( peTempMap,
                                            peDirectDrawGlobal,
                                            peTempLocal,
                                            pvmHeap->lpHeap->dwTotalSize); 
                    }
                }
            }
            peTempLocal = peTempLocal->peDirectDrawLocalNext;
        }

        bSuccess = AGPDecommitAll(
            AGP_HDEV(peDirectDrawGlobal),
            pvmHeap->lpHeap->pvPhysRsrv,
            pvmHeap->lpHeap->pAgpCommitMask,
            pvmHeap->lpHeap->dwAgpCommitMaskSize,
            &dwTemp,
            pvmHeap->lpHeap->dwTotalSize);

        ASSERTGDI(bSuccess, "Failed to decommit AGP memory");

        pvmHeap->lpHeap->dwCommitedSize = 0;
    }
    else 
    {
        CleanupAgpCommits( pvmHeap, pvmHeap->lpHeap->hdevAGP, 
            peDirectDrawGlobal, peMap->iHeapIndex );
    }
}

/******************************Public*Routine******************************\
* VOID vDdUnreferenceVirtualMap
*
*  24-Aug-1999 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

VOID
vDdUnreferenceVirtualMap(
    EDD_VMEMMAPPING*        peMap,
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    HANDLE                  ProcessHandle,
    BOOL                    bMapToDummyPage
    )
{
    BOOL    bUnmapMemory = FALSE;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    // If this was the last surface holding a pointer in the mapping we can
    // can free it now. This involves calling the driver since it was the
    // one who created the mapping in the first place. If this is not the
    // last reference, and the memory has not been aliased yet, do so now:

    if (--(peMap->cReferences) == 0)
    {
        bUnmapMemory = TRUE;
    }
    else if (!(peMap->fl & DD_VMEMMAPPING_FLAG_ALIASED) && bMapToDummyPage)
    {
        NTSTATUS    Status;

        EngAcquireSemaphore(ghsemDummyPage);

        if (gpDummyPage == NULL)
        {
            // Allocate dummy page which is used to map all disabled user
            // mode vid mem mapping to:

            gpDummyPage = ExAllocatePoolWithTag(
                              (POOL_TYPE)(SESSION_POOL_MASK | NonPagedPool),
                              PAGE_SIZE, 'DddG');

            if (gpDummyPage == NULL)
            {
                WARNING("vDdUnreferenceVirtualMap: could not allocate dummy page");
                Status = STATUS_UNSUCCESSFUL;
            }
            else
            {
                ASSERTGDI(((ULONG_PTR)gpDummyPage & (PAGE_SIZE - 1)) == 0,
                          "vDdUnreferenceVirtualMap: "
                          "Dummy page is not page aligned\n");
                DDKHEAP(("Allocated dummy page\n"));
                gcDummyPageRefCnt = 0;
            }
        }

        if (gpDummyPage != NULL)
        {
            DDKHEAP(("vDdUnreferenceVirtualMap: "
                "Attempting to remap vid mem to dummy page\n"));

            // There are outstanding locks to this memory. Map it to a dummy
            // page and proceed.

            // Calling services while attached is never a good idea.
            // However, MmMapUserAddressesToPage handles this case, so we
            // can attach and call:

            KeAttachProcess(PsGetProcessPcb(peDirectDrawLocal->Process));

            if (!(peMap->fl & DD_VMEMMAPPING_FLAG_AGP))
            {
                Status = MmMapUserAddressesToPage(
                    (VOID*) peMap->fpProcess, 0, gpDummyPage);
            }
            else
            {
                Status = AGPMapToDummy (peMap, peDirectDrawGlobal, gpDummyPage);
            }

            if (!NT_SUCCESS(Status))
            {
                DDKHEAP(("MmMapUserAddressesToPage failed: %08X\n", Status));
            }

            KeDetachProcess();
        }

        if (!NT_SUCCESS(Status))
        {
            EDD_SURFACE*    peSurface;

            WARNING("vDdUnreferenceVirtualMap: "
                "failed to map user addresses to dummy page\n");

            // Something went wrong so we must unmap the memory and remove
            // any references to this map:

            bUnmapMemory = TRUE;

            // We need to traverse the surfaces of this local and mark all
            // pointers to this mapping as NULL:

            peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

            while (peSurface)
            {
                if (peSurface->peMap == peMap)
                {
                    peSurface->peMap = NULL;

                    // Each mapping took a reference count on the surface's
                    // DirectDraw global, so undo that here:

                    vDdDecrementReferenceCount(
                        peSurface->peVirtualMapDdGlobal);
                    peSurface->peVirtualMapDdGlobal = NULL;
                }

                peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
            }
        }
        else
        {
            peMap->fl |= DD_VMEMMAPPING_FLAG_ALIASED;
            gcDummyPageRefCnt++;
        }

        EngReleaseSemaphore(ghsemDummyPage);
    }

    if (bUnmapMemory)
    {
        if (!(peMap->fl & DD_VMEMMAPPING_FLAG_AGP))
        {
            vDdUnmapMemory(peMap, peDirectDrawGlobal, ProcessHandle);
        }
        else
        {
            vDdUnmapAgpHeap(peMap, peDirectDrawGlobal, peDirectDrawLocal);
        }

        EngAcquireSemaphore(ghsemDummyPage);

        if (peMap->fl & DD_VMEMMAPPING_FLAG_ALIASED)
        {
            ASSERTGDI(gcDummyPageRefCnt > 0,
                "Dummy page reference count will be < 0");
            ASSERTGDI(gpDummyPage != NULL,
                "Dereferencing dummy page which has not been allocated");
            gcDummyPageRefCnt--;
        }

        if ((gpDummyPage != NULL) && (gcDummyPageRefCnt == 0))
        {
            ExFreePool(gpDummyPage);
            gpDummyPage = NULL;
            DDKHEAP(("Freed dummy page\n"));
        }

        EngReleaseSemaphore(ghsemDummyPage);

        if (peMap->pAgpVirtualCommitMask != NULL)
        {
            VFREEMEM(peMap->pAgpVirtualCommitMask);
        }
        VFREEMEM(peMap);
    }
}

/******************************Public*Routine******************************\
* BOOL DxDdEnableDirectDraw
*
* Allocates the global DirectDraw object and then enables the driver
* for DirectDraw.
*
* Assumes devlock already held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
DxDdEnableDirectDraw(
    HDEV hdev,
    BOOL bEnableDriver
    )
{
    BOOL                    bRet = FALSE;       // Assume failure
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    KEVENT*                 pAssertModeEvent;

    PDEVOBJ po(hdev);

    // Don't bother doing anything for printers.

    if (!po.bDisplayPDEV())
    {
        return(TRUE);
    }

    // Note that this must be zero initialized, because we promised
    // the driver that we would.  Don't zero-initialize the driver
    // state, though, because there may be some open references to
    // it!

    peDirectDrawGlobal = po.peDirectDrawGlobal();

    RtlZeroMemory((_DD_DIRECTDRAW_LOCAL*) peDirectDrawGlobal,
            sizeof(_DD_DIRECTDRAW_LOCAL));
    RtlZeroMemory((_DD_DIRECTDRAW_GLOBAL*) peDirectDrawGlobal,
            sizeof(_DD_DIRECTDRAW_GLOBAL));
    RtlZeroMemory((DD_DIRECTDRAW_GLOBAL_PDEV_DATA*) peDirectDrawGlobal,
            sizeof(DD_DIRECTDRAW_GLOBAL_PDEV_DATA));

    // Initialize our private structures:

    peDirectDrawGlobal->hdev   = po.hdev();
    peDirectDrawGlobal->dhpdev = po.dhpdev();
    peDirectDrawGlobal->bSuspended = FALSE;

    // The VideoPort HAL calls oddly reference PDD_DIRECTDRAW_LOCAL
    // instead of PDD_DIRECTDRAW_GLOBAL.  The driver will never reference
    // anything in the local structure other than 'lpGbl', so we simply
    // add a DIRECTDRAW_LOCAL structure to the definition of the
    // DIRECTDRAW_GLOBAL structure that points to itself:

    peDirectDrawGlobal->lpGbl  = peDirectDrawGlobal;

    peDirectDrawGlobal->llAssertModeTimeout
                               = llDdAssertModeTimeout();

    // The event must live in non-paged pool:

    pAssertModeEvent = (KEVENT*) PALLOCNONPAGED(sizeof(KEVENT),'eddG');

    if (pAssertModeEvent != NULL)
    {
        peDirectDrawGlobal->pAssertModeEvent = pAssertModeEvent;

        KeInitializeEvent(pAssertModeEvent,
                          SynchronizationEvent,
                          FALSE);

        if (bEnableDriver)
        {
            vDdEnableDriver(peDirectDrawGlobal);
        }

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID DxDdDisableDirectDraw
*
* Note: This function may be called without bDdEnableDirectDraw having
*       first been called!
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
DxDdDisableDirectDraw(
    HDEV hdev,
    BOOL bDisableDriver
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    PDEVOBJ po(hdev);

    peDirectDrawGlobal = po.peDirectDrawGlobal();

    // Don't bother doing anything more if we were never enabled in the
    // first place.

    if ((peDirectDrawGlobal == NULL) || 
        (peDirectDrawGlobal->hdev == NULL))
    {
        return;
    }

    EDD_DEVLOCK eDevLock(hdev);

    if (bDisableDriver)
    {
        vDdDisableDriver(peDirectDrawGlobal);
    }

    if (peDirectDrawGlobal->pAssertModeEvent != NULL)
    {
        VFREEMEM(peDirectDrawGlobal->pAssertModeEvent);
    }

    RtlZeroMemory(peDirectDrawGlobal, sizeof(*peDirectDrawGlobal));
}

/******************************Public*Routine******************************\
* VOID vDdDisableDirectDrawObject
*
* Disables a DirectDraw object.  This amounts to simply unmapping the
* view of the frame buffer.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDisableDirectDrawObject(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    NTSTATUS                Status;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    HANDLE                  ProcessHandle;
    CLIENT_ID               ClientId;
    EDD_VIDEOPORT*          peVideoPort;
    BOOL                    bUnmapAgpHeaps;

    bUnmapAgpHeaps = peDirectDrawLocal->iAgpHeapsMapped > 0;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    // We may be in a different process from the one in which the
    // memory was originally mapped.  Consequently, we have to open
    // a handle to the process in which the mapping was created.
    // We are guaranteed that the process will still exist because
    // this view is always unmapped at process termination.

    ProcessHandle = NULL;

    if (bUnmapAgpHeaps ||
        ((peDirectDrawLocal->fl & DD_LOCAL_FLAG_MEMORY_MAPPED) &&
         (peDirectDrawGlobal->CallBacks.dwFlags & DDHAL_CB32_MAPMEMORY)))
    {
        ClientId.UniqueThread = (HANDLE) NULL;
        ClientId.UniqueProcess = peDirectDrawLocal->UniqueProcess;

        InitializeObjectAttributes(&ObjectAttributes,
                                   NULL,
                                   OBJ_INHERIT,
                                   NULL,
                                   NULL);

        Status = ZwOpenProcess(&ProcessHandle,
                               PROCESS_DUP_HANDLE,
                               &ObjectAttributes,
                               &ClientId);

        if (!NT_SUCCESS(Status))
        {
            WARNING("vDdDisableDirectDrawObject: "
                    "Couldn't open process handle");
            ProcessHandle = NULL;
        }
    }

    if (peDirectDrawLocal->fl & DD_LOCAL_FLAG_MEMORY_MAPPED)
    {
        peDirectDrawLocal->fl &= ~DD_LOCAL_FLAG_MEMORY_MAPPED;
        peDirectDrawGlobal->cMaps--;

        ASSERTGDI(peDirectDrawGlobal->cMaps >= 0, "Invalid map count");

        if ((peDirectDrawGlobal->CallBacks.dwFlags & DDHAL_CB32_MAPMEMORY) &&
            ProcessHandle != NULL)
        {
            vDdUnreferenceVirtualMap(peDirectDrawLocal->peMapCurrent,
                                     peDirectDrawGlobal,
                                     peDirectDrawLocal,
                                     ProcessHandle,
                                     TRUE);

            peDirectDrawLocal->peMapCurrent = NULL;
        }
    }

    // Unmap AGP heaps if necessary:

    if (bUnmapAgpHeaps && (ProcessHandle != NULL))
    {
        DWORD i;
        EDD_VMEMMAPPING** ppeMapAgp;

        ppeMapAgp = peDirectDrawLocal->ppeMapAgp;

        for (i = 0; i < peDirectDrawGlobal->dwNumHeaps; i++, ppeMapAgp++)
        {
            if (*ppeMapAgp != NULL)
            {
                vDdUnreferenceVirtualMap(*ppeMapAgp,
                                         peDirectDrawGlobal,
                                         peDirectDrawLocal,
                                         ProcessHandle,
                                         TRUE);

                *ppeMapAgp = NULL;
            }
        }
    }

    if (ProcessHandle != NULL)
    {
        Status = ZwClose(ProcessHandle);
        ASSERTGDI(NT_SUCCESS(Status), "Failed close handle");
    }

    // Stop any active videoports:

    for (peVideoPort = peDirectDrawLocal->peVideoPort_DdList;
         peVideoPort != NULL;
         peVideoPort = peVideoPort->peVideoPort_DdNext)
    {
        vDdStopVideoPort(peVideoPort);
    }
}

/******************************Public*Routine******************************\
* HANDLE hDdCreateDirectDrawLocal
*
* Creates a new local DirectDraw object for a process attaching to
* a PDEV for which we've already enabled DirectDraw.  Note that the
* DirectDraw user-mode process will actually think of this as its
* 'global' DirectDraw object.
*
* Assumes devlock already held.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HANDLE
hDdCreateDirectDrawLocal(
    PDEVOBJ&    po
    )
{
    HANDLE                  h;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING**       ppeMapAgp;

    h = 0;

    peDirectDrawGlobal = po.peDirectDrawGlobal();

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    if (peDirectDrawGlobal->dwNumHeaps > 0)
    {
        // Allocate an array to hold per-process AGP heap information.
        ppeMapAgp = (EDD_VMEMMAPPING**)
            PALLOCMEM(sizeof(EDD_VMEMMAPPING*) *
                      peDirectDrawGlobal->dwNumHeaps,
                      'pddG');
        if (ppeMapAgp == NULL)
        {
            return h;
        }
    }
    else
    {
        ppeMapAgp = NULL;
    }

    // We allocate this via the handle manager so that we can use the
    // existing handle manager process clean-up mechanisms:


    peDirectDrawLocal = (EDD_DIRECTDRAW_LOCAL*) DdHmgAlloc(
                                 sizeof(EDD_DIRECTDRAW_LOCAL),
                                 DD_DIRECTDRAW_TYPE,
                                 HMGR_ALLOC_LOCK);
    if (peDirectDrawLocal != NULL)
    {
        // Insert this object at the head of the object list:

        peDirectDrawLocal->peDirectDrawLocalNext
            = peDirectDrawGlobal->peDirectDrawLocalList;

        peDirectDrawGlobal->peDirectDrawLocalList = peDirectDrawLocal;

        // Initialize surface list:

        InitializeListHead(&(peDirectDrawLocal->ListHead_eSurface));

        // Initialize private GDI data:

        peDirectDrawLocal->peDirectDrawGlobal = peDirectDrawGlobal;
        peDirectDrawLocal->lpGbl = peDirectDrawGlobal;
        peDirectDrawLocal->UniqueProcess = PsGetCurrentThreadProcessId();
        peDirectDrawLocal->Process = PsGetCurrentProcess();

        peDirectDrawLocal->ppeMapAgp = ppeMapAgp;

        peDirectDrawLocal->peMapCurrent = NULL;

        // This has reference to PDEVOBJ, so increment ref count of PDEVOBJ:

        po.vReferencePdev();

        // Do an HmgUnlock:

        h = peDirectDrawLocal->hHmgr;
        DEC_EXCLUSIVE_REF_CNT(peDirectDrawLocal);

        // Setup the AGP heaps if the driver exposes any

        MapAllAgpHeaps( peDirectDrawLocal );
    }
    else if (ppeMapAgp != NULL)
    {
        VFREEMEM(ppeMapAgp);
    }

    return(h);
}

/******************************Public*Routine******************************\
* BOOL bDdDeleteDirectDrawObject
*
* Deletes a kernel-mode representation of the DirectDraw object.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdDeleteDirectDrawObject(
    HANDLE  hDirectDrawLocal,
    BOOL    bProcessTermination
    )
{
    BOOL                        bRet;
    BOOL                        b;
    VOID*                       pRemove;
    EDD_DIRECTDRAW_LOCAL*       peDirectDrawLocal;
    EDD_DIRECTDRAW_LOCAL*       peTmp;
    EDD_DIRECTDRAW_GLOBAL*      peDirectDrawGlobal;
    EDD_VIDEOPORT*              peVideoPort;
    EDD_VIDEOPORT*              peVideoPortNext;
    EDD_MOTIONCOMP*             peMotionComp;
    EDD_MOTIONCOMP*             peMotionCompNext;
    EDD_SURFACE*                peSurface;
    EDD_SURFACE*                peSurfaceNext;

    bRet = FALSE;

    peDirectDrawLocal = (EDD_DIRECTDRAW_LOCAL*)
        DdHmgLock((HDD_OBJ) hDirectDrawLocal, DD_DIRECTDRAW_TYPE, FALSE);

    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        PDEVOBJ po(peDirectDrawGlobal->hdev);

        b = TRUE;

        // Now, try to delete all videoports associated with this object:

        for (peVideoPort = peDirectDrawLocal->peVideoPort_DdList;
             peVideoPort != NULL;
             peVideoPort = peVideoPortNext)
        {
            // Don't reference peVideoPort after it's been deleted!

            peVideoPortNext = peVideoPort->peVideoPort_DdNext;
            b &= bDdDeleteVideoPortObject(peVideoPort->hGet(), NULL);
        }

        for (peMotionComp = peDirectDrawLocal->peMotionComp_DdList;
             peMotionComp != NULL;
             peMotionComp = peMotionCompNext)
        {
            peMotionCompNext = peMotionComp->peMotionComp_DdNext;
            b &= bDdDeleteMotionCompObject(peMotionComp->hGet(), NULL);
        }

        // Next, try to delete all surfaces associated with this object:

        peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

        while (peSurface)
        {
            // Don't reference peSurface after it's been deleted!

            peSurfaceNext = peDirectDrawLocal->peSurface_Enum(peSurface);

            // Delete the surface

            b &= bDdDeleteSurfaceObject(peSurface->hGet(), NULL);

            // Move onto next one

            peSurface = peSurfaceNext;
        }

        {
            EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

            // If they set a gamma ramp, restore it now

            if (peDirectDrawLocal->pGammaRamp != NULL)
            {
                DxEngSetDeviceGammaRamp(
                    po.hdev(),
                    peDirectDrawLocal->pGammaRamp,
                    TRUE);
                VFREEMEM(peDirectDrawLocal->pGammaRamp);
                peDirectDrawLocal->pGammaRamp = NULL;
            }

            if (peDirectDrawGlobal->Miscellaneous2CallBacks.DestroyDDLocal)
            {
                DWORD dwRet = DDHAL_DRIVER_NOTHANDLED;
                DD_DESTROYDDLOCALDATA destDDLcl;
                destDDLcl.dwFlags = 0;
                destDDLcl.pDDLcl  = peDirectDrawLocal;
                dwRet = peDirectDrawGlobal->Miscellaneous2CallBacks.DestroyDDLocal(&destDDLcl);
                if (dwRet == DDHAL_DRIVER_NOTHANDLED)
                {
                    WARNING("bDdDeleteDirectDrawObject: failed DestroyDDLocal\n");
                }
            }

            // Only delete the DirectDraw object if we successfully deleted
            // all linked surface objects:

            if (b)
            {
                DWORD       dwHeap;
                LPVIDMEM    pHeap;

                // Remove object from the handle manager:

                pRemove = DdHmgRemoveObject((HDD_OBJ) hDirectDrawLocal,
                                            1,
                                            0,
                                            TRUE,
                                            DD_DIRECTDRAW_TYPE);

                ASSERTGDI(pRemove != NULL, "Couldn't delete DirectDraw object");

                vDdDisableDirectDrawObject(peDirectDrawLocal);

                // Now that we've cleanup up the surfaces, now we will cleanup any 
                // agp commits that need to be.

                pHeap = peDirectDrawGlobal->pvmList;
                for (dwHeap = 0;
                     dwHeap < peDirectDrawGlobal->dwNumHeaps;
                     pHeap++, dwHeap++)
                {
                    if (!(pHeap->dwFlags & VIDMEM_ISHEAP) &&
                        !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
                        (pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
                        (pHeap->lpHeap != NULL))
                    {
                        CleanupAgpCommits( pHeap, pHeap->lpHeap->hdevAGP, 
                            peDirectDrawGlobal, dwHeap );
                    }
                }

                ////////////////////////////////////////////////////////////
                // Remove the global DirectDraw object from the PDEV when
                // the last associated local object is destroyed, and
                // call the driver:

                if (peDirectDrawGlobal->peDirectDrawLocalList == peDirectDrawLocal)
                {
                    peDirectDrawGlobal->peDirectDrawLocalList
                        = peDirectDrawLocal->peDirectDrawLocalNext;
                }
                else
                {
                    for (peTmp = peDirectDrawGlobal->peDirectDrawLocalList;
                         peTmp->peDirectDrawLocalNext != peDirectDrawLocal;
                         peTmp = peTmp->peDirectDrawLocalNext)
                         ;

                    peTmp->peDirectDrawLocalNext
                        = peDirectDrawLocal->peDirectDrawLocalNext;
                }

                // We're all done with this object, so free the memory and
                // leave:

                if (peDirectDrawLocal->ppeMapAgp != NULL)
                {
                    VFREEMEM(peDirectDrawLocal->ppeMapAgp);
                }

                DdFreeObject(peDirectDrawLocal, DD_DIRECTDRAW_TYPE);

                bRet = TRUE;
            }
            else
            {
                WARNING("bDdDeleteDirectDrawObject: A surface was busy\n");
                if (bProcessTermination)
                {
                    peDirectDrawLocal->fl |= DD_LOCAL_DISABLED;
                }
            }
        }

        if (bRet)
        {
            // Unreference PDEVOBJ - must not have devlock
            po.vUnreferencePdev();
        }

        // Note that we can't force a repaint here by calling
        // UserRedrawDesktop because we may be in a bad process context.
    }
    else
    {
        WARNING("bDdDeleteDirectDrawObject: Bad handle or object busy\n");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vDdRelinquishSurfaceOrBufferLock
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdRelinquishSurfaceOrBufferLock(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface
    )
{
    DD_UNLOCKDATA   UnlockData;
    EDD_SURFACE*    peTmp;

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);
    ASSERTGDI(peSurface->cLocks > 0, "Must have non-zero locks to relinquish");

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        if (peDirectDrawGlobal->D3dBufCallbacks.UnlockD3DBuffer != NULL)
        {
            UnlockData.lpDD        = peDirectDrawGlobal;
            UnlockData.lpDDSurface = peSurface;

            peDirectDrawGlobal->D3dBufCallbacks.UnlockD3DBuffer(&UnlockData);
        }
    }
    else
    {
        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
            DDHAL_SURFCB32_UNLOCK)
        {
            UnlockData.lpDD        = peDirectDrawGlobal;
            UnlockData.lpDDSurface = peSurface;

            peDirectDrawGlobal->SurfaceCallBacks.Unlock(&UnlockData);
        }
    }

    // An application may take multiple locks on the same surface:

    if (--peSurface->cLocks == 0)
    {
        if (!(peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) ||
            ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
             (peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST)))
        {
            peDirectDrawGlobal->cSurfaceLocks--;
        }

        if (peSurface->peMap ||
            (peSurface->fl & DD_SURFACE_FLAG_FAKE_ALIAS_LOCK))
        {
            peDirectDrawGlobal->cSurfaceAliasedLocks--;
            peSurface->fl &= ~DD_SURFACE_FLAG_FAKE_ALIAS_LOCK;
        }

        // Primary surface unlocks require special handling for stuff like
        // pointer exclusion:

        if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
        {
            // Since all locks for this surface have been relinquished, remove
            // it from the locked surface list.

            if (peDirectDrawGlobal->peSurface_PrimaryLockList == peSurface)
            {
                peDirectDrawGlobal->peSurface_PrimaryLockList
                    = peSurface->peSurface_PrimaryLockNext;
            }
            else
            {
                for (peTmp = peDirectDrawGlobal->peSurface_PrimaryLockList;
                     peTmp->peSurface_PrimaryLockNext != peSurface;
                     peTmp = peTmp->peSurface_PrimaryLockNext)
                {
                    ASSERTGDI(peTmp != NULL, "Can't find surface in lock list");
                }

                peTmp->peSurface_PrimaryLockNext
                    = peSurface->peSurface_PrimaryLockNext;
            }

            peSurface->peSurface_PrimaryLockNext = NULL;

            // Redraw any sprites:

            DxEngSpUnTearDownSprites(peDirectDrawGlobal->hdev,
                                     &peSurface->rclLock,
                                     TRUE);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDdLooseManagedSurfaceObject
*
* Informs the driver that it should clean up any video memory allocated for
* a persistent managed surface since a mode switch has occured.
*
*  13-May-1999 -by- Sameer Nene [snene]
* Wrote it.
\**************************************************************************/

VOID
vDdLooseManagedSurfaceObject(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface,
    DWORD*                  pdwRet          // For returning driver return code,
    )                                       //   may be NULL
{
    DD_DESTROYSURFACEDATA   DestroySurfaceData;

    DD_ASSERTSHAREDEVLOCK();
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    DDKHEAP(("DDKHEAP: Loosing surface %X (%X)\n",
             peSurface->hGet(), peSurface));

    // Due to video mode change, this driver managed surface is lives in "different" video
    // driver then what the driver actually "manage" this surface.
    // So we don't do anything here, since it has been "loose" already since mode change happened.

    if (!(peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER))
    {
        DestroySurfaceData.lpDD        = peDirectDrawGlobal;
        DestroySurfaceData.lpDDSurface = peSurface;
        DestroySurfaceData.lpDDSurface->dwFlags |= DDRAWISURF_INVALID;
        if ((peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
            peDirectDrawGlobal->D3dBufCallbacks.DestroyD3DBuffer != NULL)
        {
            peDirectDrawGlobal->D3dBufCallbacks.DestroyD3DBuffer(&DestroySurfaceData);
        }
        else if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
            (peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_DESTROYSURFACE))
        {
            peDirectDrawGlobal->SurfaceCallBacks.DestroySurface(&DestroySurfaceData);
        }
        DestroySurfaceData.lpDDSurface->dwFlags &= ~DDRAWISURF_INVALID;
    }
    else
    {
        // WARNING("vDdLooseManagedSurfaceObject: called with DD_SURFACE_FLAG_WRONG_DRIVER");
    }

    if (pdwRet != NULL)
    {
        *pdwRet = DDHAL_DRIVER_HANDLED;
    }
}

/******************************Public*Routine******************************\
* VOID SafeFreeUserMem
*
* Frees user mem and switches to the correct process if required.
*
*  5-Apr-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
SafeFreeUserMem(
    PVOID       pv,
    PEPROCESS   Process
    )
{
    if (PsGetCurrentProcess() == Process)
    {
        EngFreeUserMem(pv);
    }
    else
    {
        // Calling services while attached is never a good idea.  However,
        // free virtual memory handles this case, so we can attach and
        // call.
        //
        // Note that the process must exist.  We are guaranteed that this
        // is the case because we automatically delete all surfaces on
        // process deletion.

        KeAttachProcess(PsGetProcessPcb(Process));
        EngFreeUserMem(pv);
        KeDetachProcess();
    }
}

/******************************Public*Routine******************************\
* VOID DeferMemoryFree
*
* Places the memory into a list to be freed at a later time when it's safe.
*
*  5-Apr-2001 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
DeferMemoryFree(
    PVOID                  pv,
    EDD_SURFACE*           peSurface
    )
{
    DD_USERMEM_DEFER* pDefer;

    pDefer = (DD_USERMEM_DEFER*) PALLOCMEM(sizeof(DD_USERMEM_DEFER),
                                               'pddG');
    if (pDefer != NULL)
    {
        pDefer->pUserMem = pv;
        pDefer->peSurface = peSurface;
        pDefer->pNext = peSurface->peDirectDrawLocal->peDirectDrawGlobal->pUserMemDefer;
        peSurface->peDirectDrawLocal->peDirectDrawGlobal->pUserMemDefer = pDefer;
        peSurface->fl |= DD_SURFACE_FLAG_DEFER_USERMEM;
    }
}

/******************************Public*Routine******************************\
* VOID vDdDisableSurfaceObject
*
* Disables a kernel-mode representation of the surface.  This is also
* known as marking the surface as 'lost'.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDisableSurfaceObject(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface,
    DWORD*                  pdwRet          // For returning driver return code,
    )                                       //   may be NULL
{
    DWORD                   dwRet;
    DXOBJ*                  pDxObj;
    DXOBJ*                  pDxObjNext;
    DD_FLIPDATA             FlipData;
    EDD_SURFACE*            peSurfaceCurrent;
    EDD_SURFACE*            peSurfacePrimary;
    DD_DESTROYSURFACEDATA   DestroySurfaceData;
    DD_UPDATEOVERLAYDATA    UpdateOverlayData;

    DD_ASSERTSHAREDEVLOCK();
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    DDKHEAP(("DDKHEAP: Disabling surface %X (%X)\n",
             peSurface->hGet(), peSurface));

    // If this surface is a destination surface for the videoport, turn it
    // off:

    if (peSurface->lpVideoPort != NULL)
    {
        vDdStopVideoPort(pedFromLp(peSurface->lpVideoPort));

        ASSERTGDI(peSurface->lpVideoPort == NULL, "Expected surface clean-up");
    }

    // Mark the DXAPI instance of the surface as lost:

    if (peSurface->hSurface != NULL)
    {
        vDdDxApiFreeSurface( (DXOBJ*) peSurface->hSurface, FALSE );
        peSurface->hSurface = NULL;
    }

    if (peSurface->peDxSurface != NULL)
    {
        vDdLoseDxObjects(peDirectDrawGlobal,
                         peSurface->peDxSurface->pDxObj_List,
                         (PVOID) peSurface->peDxSurface,
                         LO_SURFACE );
    }

    if (peSurface->peDxSurface != NULL)
    {
        peDirectDrawGlobal->pfnLoseObject(peSurface->peDxSurface,
                                          LO_SURFACE);
    }

    if (peSurface->hbmGdi != NULL)
    {
        // It's not always possible to delete the cached GDI
        // bitmap here, because we might have to first un-select
        // the bitmap from its DC, and doing so requires an
        // exclusive lock on the DC, which may not be possible
        // if another thread is currently in kernel mode with the
        // DC locked, just waiting for us to release the devlock.
        //
        // But we desperately need to delete the driver's
        // realization at this point, before a mode change happens
        // which renders its associations invalid.  So we do that
        // now.
        //
        // This may leave the surface in an unusable state (which
        // is true even for non-DrvDeriveSurface surfaces).
        // That's okay, because the surface can't be selected into
        // any other DC, and the DC is marked as 'disabled' in the
        // following snibbet of code.

        // Bug 330141 : sr(hbmGdi) does not work since it fails
        // when we are called on a non-creating thread in mode
        // change, thus not deleting the bitmap.

        SURFOBJ* pso;

        if ((pso = DxEngAltLockSurface(peSurface->hbmGdi)) != NULL)
        {
            if (pso->dhsurf != NULL)
            {
                (*PPFNDRV(po, DeleteDeviceBitmap))(pso->dhsurf);
                pso->dhsurf = NULL;
            }

            EngUnlockSurface(pso);
        }
    }

    if (peSurface->hdc != NULL)
    {
        // We've given out a DC to the application via GetDC that
        // allows it to have GDI draw directly on the surface.
        // The problem is that we want to unmap the application's
        // view of the frame buffer -- but now we can have GDI
        // drawing to it.  So if we simply forced the unmap, GDI
        // would access violate if the DC was ever used again.
        //
        // We also can't simply delete the DC, because there may
        // be another thread already in kernel mode that has locked
        // the DC and is waiting on the devlock -- which we have.
        //
        // Note that the DC can not simply be deleted here, because
        // it may validly be in-use by another thread that has made
        // it to the kernel.  The DC deletion has to wait until
        // bDdDeleteSurfaceObject.

        if (!DxEngSetDCState(peSurface->hdc,DCSTATE_FULLSCREEN,(ULONG_PTR)TRUE))
        {
            WARNING("vDdDisableSurfaceObject: Couldn't mark DC as disabled.\n");
            ghdcCantLose = peSurface->hdc;
#if DBG_HIDEYUKN
            DbgBreakPoint();
#endif
        }
    }

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        // System-memory surfaces should only ever need to be disabled from
        // the same process in which they were created:

        if (peSurface->hSecure)
        {
            ASSERTGDI(peSurface->peDirectDrawLocal->Process
                == PsGetCurrentProcess(),
                "vDdDisableSurfaceObject: SYSMEM object disabled in wrong process");

            MmUnsecureVirtualMemory(peSurface->hSecure);

            peSurface->hSecure = NULL;
        }
    }
    else
    {
        if (peSurface->cLocks != 0)
        {
            // We're unmapping the frame buffer view while there are outstanding
            // frame buffer locks; keep track of the address for debugging
            // purposes, since the application is undoubtedly about to access-
            // violate:

            gfpUnmap = peSurface->peDirectDrawLocal->fpProcess;

        #if DBG
            DbgPrint("GDI vDdDisableSurfaceObject: Preemptively unmapping application's\n");
            DbgPrint("                             frame buffer view at 0x%lx!\n\n", gfpUnmap);
        #endif
        }

        // Remove any outstanding locks and repaint the mouse pointer:

        while (peSurface->cLocks != 0)
        {
            vDdRelinquishSurfaceOrBufferLock(peDirectDrawGlobal, peSurface);
        }

        // If this surface is the currently visible one as a result of a flip,
        // then switch back to the primary GDI surface:

        peSurfaceCurrent = peDirectDrawGlobal->peSurfaceCurrent;
        peSurfacePrimary = peDirectDrawGlobal->peSurfacePrimary;

        if ((peSurfaceCurrent == peSurface) || (peSurfacePrimary == peSurface))
        {
            // We may be in a different process from the one that created the
            // surface, so don't flip to the primary if it's a user-memory
            // allocated surface:

            if ((peSurfacePrimary != NULL) &&
                !(peSurfacePrimary->fl & DD_SURFACE_FLAG_UMEM_ALLOCATED))
            {
                ASSERTGDI((peSurfaceCurrent != NULL) && (peSurfacePrimary != NULL),
                        "Both surfaces must be non-NULL");
                ASSERTGDI(peSurfacePrimary->fl & DD_SURFACE_FLAG_PRIMARY,
                        "Primary flag is confused.");

                if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_FLIP)
                {
                    // If the current isn't the primary, then swap back to the primary:

                    if (!(peSurfaceCurrent->fl & DD_SURFACE_FLAG_PRIMARY))
                    {
                        FlipData.ddRVal     = DDERR_GENERIC;
                        FlipData.lpDD       = peDirectDrawGlobal;
                        FlipData.lpSurfCurr = peSurfaceCurrent;
                        FlipData.lpSurfTarg = peSurfacePrimary;
                        FlipData.dwFlags    = 0;
                        FlipData.lpSurfCurrLeft = NULL;
                        FlipData.lpSurfTargLeft = NULL;

                        peSurfacePrimary->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;

                        do {
                            dwRet = peDirectDrawGlobal->SurfaceCallBacks.Flip(&FlipData);

                        } while ((dwRet == DDHAL_DRIVER_HANDLED) &&
                                 (FlipData.ddRVal == DDERR_WASSTILLDRAWING));

                        ASSERTGDI((dwRet == DDHAL_DRIVER_HANDLED) &&
                                  (FlipData.ddRVal == DD_OK),
                                  "Driver failed when cleaning up flip surfaces");
                    }
                }
            }

            peDirectDrawGlobal->peSurfaceCurrent = NULL;
            peDirectDrawGlobal->peSurfacePrimary = NULL;
        }

        // Make sure the overlay is marked as hidden before it's deleted, so
        // that we don't have to rely on drivers doing it in their DestroySurface
        // routine:

        if ((peSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
            (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                DDHAL_SURFCB32_UPDATEOVERLAY)                 &&
            (peSurface->fl & DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED))
        {
            UpdateOverlayData.lpDD            = peDirectDrawGlobal;
            UpdateOverlayData.lpDDDestSurface = NULL;
            UpdateOverlayData.lpDDSrcSurface  = peSurface;
            UpdateOverlayData.dwFlags         = DDOVER_HIDE;
            UpdateOverlayData.ddRVal          = DDERR_GENERIC;

            peDirectDrawGlobal->SurfaceCallBacks.UpdateOverlay(&UpdateOverlayData);
        }

        // If we allocated user-mode memory on the driver's behalf, we'll
        // free it now.  This is complicated by the fact that we may be
        // in a different process context.

        if (peSurface->fl & DD_SURFACE_FLAG_UMEM_ALLOCATED)
        {
            ASSERTGDI(peSurface->fpVidMem != NULL, "Expected non-NULL fpVidMem");

            DDKHEAP(("DDKHEAP: Fre um %08X, surf %X (%X)\n",
                     peSurface->fpVidMem, peSurface->hGet(), peSurface));

            if (peSurface->fl & DD_SURFACE_FLAG_ALIAS_LOCK)
            {
                DeferMemoryFree((PVOID)peSurface->fpVidMem, peSurface);
            }
            else
            {
                SafeFreeUserMem((PVOID)peSurface->fpVidMem,  peSurface->peDirectDrawLocal->Process);
            }
            peSurface->fpVidMem = 0;
        }

        if (peSurface->fl & DD_SURFACE_FLAG_VMEM_ALLOCATED)
        {
            ASSERTGDI(peSurface->lpVidMemHeap != NULL &&
                      peSurface->lpVidMemHeap->lpHeap &&
                      peSurface->fpHeapOffset != NULL,
                      "Expected non-NULL lpVidMemHeap and fpHeapOffset");

            DDKHEAP(("DDKHEAP: Fre vm %08X, o %08X, heap %X, surf %X (%X)\n",
                     peSurface->fpVidMem, peSurface->fpHeapOffset,
                     peSurface->lpVidMemHeap->lpHeap,
                     peSurface->hGet(), peSurface));

            DxDdHeapVidMemFree(peSurface->lpVidMemHeap->lpHeap,
                               peSurface->fpHeapOffset);

            peSurface->lpVidMemHeap = NULL;
            peSurface->fpVidMem = 0;
            peSurface->fpHeapOffset = 0;
        }

        // Delete the driver's surface instance.  Note that we may be calling
        // here from a process different from the one in which the surface was
        // created, meaning that the driver cannot make function calls like
        // EngFreeUserMem.

        if (peSurface->fl & DD_SURFACE_FLAG_DRIVER_CREATED)
        {
            EDD_DIRECTDRAW_GLOBAL *peDdGlobalDriver;

            if (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER)
            {
                WARNING("vDdDisableSurfaceObject: Call driver other than current."); 

                peDdGlobalDriver = peSurface->peDdGlobalCreator;
            }
            else
            {
                peDdGlobalDriver = peSurface->peDirectDrawGlobal;
            }

            DestroySurfaceData.lpDD        = peDdGlobalDriver;
            DestroySurfaceData.lpDDSurface = peSurface;

            if ((peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
                peDdGlobalDriver->D3dBufCallbacks.DestroyD3DBuffer != NULL)
            {
                dwRet = peDdGlobalDriver->
                    D3dBufCallbacks.DestroyD3DBuffer(&DestroySurfaceData);
            }
            else if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
                     (peDdGlobalDriver->SurfaceCallBacks.dwFlags &
                      DDHAL_SURFCB32_DESTROYSURFACE))
            {
                dwRet = peDdGlobalDriver->
                    SurfaceCallBacks.DestroySurface(&DestroySurfaceData);
            }

            // Drivers are supposed to return DDHAL_DRIVER_NOTHANDLED from
            // DestroySurface if they returned DDHAL_DRIVER_NOTHANDLED from
            // CreateSurface, which is the case for PLEASEALLOC_*.  We
            // munged the return code for PLEASEALLOC_* at CreateSurface
            // time; we have to munge it now, too:

            if ((dwRet == DDHAL_DRIVER_NOTHANDLED) &&
                (peSurface->fl & (DD_SURFACE_FLAG_UMEM_ALLOCATED |
                                  DD_SURFACE_FLAG_VMEM_ALLOCATED)))
            {
                dwRet = DDHAL_DRIVER_HANDLED;
            }

            // Decrement ref count on driver if driver managed surface.

            if (peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED)
            {
                ASSERTGDI(peSurface->fl & DD_SURFACE_FLAG_CREATE_COMPLETE,
                  "vDdDisableSurfaceObject: missing complete flag.");

                vDdDecrementReferenceCount(peDdGlobalDriver);
            }
        }
    }

    // Mark the surface as lost and reset some flags now for if the
    // surface gets reused:

    if (!(peSurface->bLost))
    {
        peSurface->bLost = TRUE;

        // If this surface is not lost formerly, but just lost here
        // decrement active surface ref. count.

        ASSERTGDI(peSurface->peDirectDrawLocal->cActiveSurface > 0,
                  "cActiveSurface will be negative");

        peSurface->peDirectDrawLocal->cActiveSurface--;
    }

    // We used to zero the flags, but we need below flags to survive
    // until we call DeleteSurfaceObject.
    peSurface->fl &= DD_SURFACE_FLAG_DEFER_USERMEM;

    if (pdwRet != NULL)
    {
        *pdwRet = dwRet;
    }
}

/******************************Public*Routine******************************\
* EDD_SURFACE* peSurfaceFindAttachedMipMap
*
* Transmogrified from misc.c's FindAttachedMipMap.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline
EDD_SURFACE*
peSurfaceFindAttachedMipMap(
    EDD_SURFACE* peSurface
    )
{
    DD_ATTACHLIST*  pAttachList;
    EDD_SURFACE*    peSurfaceAttached;

    for (pAttachList = peSurface->lpAttachList;
         pAttachList != NULL;
         pAttachList = pAttachList->lpLink)
    {
        peSurfaceAttached = pedFromLp(pAttachList->lpAttached);
        if (peSurfaceAttached->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            return(peSurfaceAttached);
        }
    }
    return(NULL);
}

/******************************Public*Routine******************************\
* EDD_SURFACE* peSurfaceFindParentMipMap
*
* Transmogrified from misc.c's FindParentMipMap.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline
EDD_SURFACE*
peSurfaceFindParentMipMap(
    EDD_SURFACE* peSurface
    )
{
    DD_ATTACHLIST*  pAttachList;
    EDD_SURFACE*    peSurfaceAttached;

    for (pAttachList = peSurface->lpAttachListFrom;
         pAttachList != NULL;
         pAttachList = pAttachList->lpLink)
    {
        peSurfaceAttached = pedFromLp(pAttachList->lpAttached);
        if (peSurfaceAttached->ddsCaps.dwCaps & DDSCAPS_MIPMAP)
        {
            return(peSurfaceAttached);
        }
    }
    return(NULL);
}

/******************************Public*Routine******************************\
* VOID vDdUpdateMipMapCount
*
* Transmogrified from ddsatch.c's UpdateMipMapCount.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdUpdateMipMapCount(
    EDD_SURFACE*    peSurface
    )
{
    EDD_SURFACE*    peSurfaceParent;
    DWORD           dwLevels;

    DD_ASSERTDEVLOCK(peSurface->peDirectDrawGlobal);

    // Find the top most level mip-map in the chain:

    peSurfaceParent = peSurface;
    while (peSurfaceParent != NULL)
    {
        peSurface = peSurfaceParent;
        peSurfaceParent = peSurfaceFindParentMipMap(peSurface);
    }
    peSurfaceParent = peSurface;

    // We have the top-most level in the mip-map chain.  Now count the
    // levels in the chain:

    dwLevels = 0;
    while (peSurface != NULL)
    {
        dwLevels++;
        peSurface = peSurfaceFindAttachedMipMap(peSurface);
    }

    // Now update all the levels with their new mip-map count:

    peSurface = peSurfaceParent;
    while (peSurface != NULL)
    {
        peSurface->dwMipMapCount = dwLevels;
        dwLevels--;
        peSurface = peSurfaceFindAttachedMipMap(peSurface);
    }

    ASSERTGDI(dwLevels == 0, "Unexpected ending surface count");
}

/******************************Public*Routine******************************\
* BOOL bDdRemoveAttachedSurface
*
* Transmogrified from ddsatch.c's DeleteOneLink.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdRemoveAttachedSurface(
    EDD_SURFACE*    peSurface,
    EDD_SURFACE*    peSurfaceAttached
    )
{
    BOOL                bRet = FALSE;
    DD_ATTACHLIST*      pAttachCurrent;
    DD_ATTACHLIST*      pAttachLast;

    // See if specified surface is attached:

    pAttachCurrent = peSurface->lpAttachList;
    pAttachLast = NULL;
    while (pAttachCurrent != NULL)
    {
        if (pAttachCurrent->lpAttached == peSurfaceAttached)
            break;

        pAttachLast = pAttachCurrent;
        pAttachCurrent = pAttachCurrent->lpLink;
    }
    if (pAttachCurrent != NULL)
    {
        // Delete the attached-from link:

        if (pAttachLast == NULL)
        {
            peSurface->lpAttachList = pAttachCurrent->lpLink;
        }
        else
        {
            pAttachLast->lpLink = pAttachCurrent->lpLink;
        }
        VFREEMEM(pAttachCurrent);

        // Remove the attached-to link:

        pAttachCurrent = peSurfaceAttached->lpAttachListFrom;
        pAttachLast = NULL;
        while (pAttachCurrent != NULL)
        {
            if (pAttachCurrent->lpAttached == peSurface)
                break;

            pAttachLast = pAttachCurrent;
            pAttachCurrent = pAttachCurrent->lpLink;
        }

        // Delete the attached-to link:

        if (pAttachLast == NULL)
        {
            peSurfaceAttached->lpAttachListFrom = pAttachCurrent->lpLink;
        }
        else
        {
            pAttachLast->lpLink = pAttachCurrent->lpLink;
        }
        VFREEMEM(pAttachCurrent);

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vDdDeleteReferringAttachments
*
* This surface is being deleted.  Remove any attachments to or from other
* surfaces.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDeleteReferringAttachments(
    EDD_SURFACE*    peSurface
    )
{
    DD_ATTACHLIST*  pAttachList;
    EDD_SURFACE*    peSurfaceAttachedTo;
    EDD_SURFACE*    peSurfaceAttachedFrom;
    BOOL            b;

    while (peSurface->lpAttachList != NULL)
    {
        peSurfaceAttachedTo
            = pedFromLp(peSurface->lpAttachList->lpAttached);

        b = bDdRemoveAttachedSurface(peSurface, peSurfaceAttachedTo);
        vDdUpdateMipMapCount(peSurfaceAttachedTo);

        ASSERTGDI(b, "Unexpected bDdRemoveAttachedSurface failure\n");
    }

    while (peSurface->lpAttachListFrom != NULL)
    {
        peSurfaceAttachedFrom
            = pedFromLp(peSurface->lpAttachListFrom->lpAttached);

        b = bDdRemoveAttachedSurface(peSurfaceAttachedFrom, peSurface);
        vDdUpdateMipMapCount(peSurfaceAttachedFrom);

        ASSERTGDI(b, "Unexpected bDdRemoveAttachedSurface failure\n");
    }
}

/******************************Public*Routine******************************\
* void vDdReleaseVirtualMap
*
* Released the reference a surface has on a VMEMMAPPING structure
*
*  28-Oct-1998 -by- Anuj Gosalia [anujg]
* Wrote it.
\**************************************************************************/

void vDdReleaseVirtualMap(EDD_SURFACE* peSurface)
{
    EDD_DIRECTDRAW_GLOBAL*  peVirtualMapDdGlobal;

    // Hold share to prevent video mode change.
    {
        EDD_SHARELOCK eShareLock(TRUE);

        peVirtualMapDdGlobal = peSurface->peVirtualMapDdGlobal;

        DDKHEAP(("vDdReleaseVirtualMap: peSurface=%lx, "
                "peVirtualMapDdGlobal=%lx, peDirectDrawGlobal=%lx\n",
                peSurface, peVirtualMapDdGlobal,
                peSurface->peDirectDrawGlobal));

        // See peVirtualMapDdGlobal is still present, since
        // video mode change occured before locking share
        // lock at above, this will be null by mode change thread.

        if (peVirtualMapDdGlobal)
        {
            EDD_DEVLOCK eDevlock(peVirtualMapDdGlobal);

            vDdUnreferenceVirtualMap(peSurface->peMap,
                                     peVirtualMapDdGlobal,
                                     peSurface->peDirectDrawLocal,
                                     NtCurrentProcess(),
                                     FALSE);

            peSurface->peMap = NULL;
            peSurface->peVirtualMapDdGlobal = NULL;
        }
    }

    if (peVirtualMapDdGlobal)
    {
        // Decrement the the driver instance
        // Note: To free the driver instance we must not be holding the devlock:

        vDdDecrementReferenceCount(peVirtualMapDdGlobal);
    }
}

/******************************Public*Routine******************************\
* BOOL bDdDeleteSurfaceObject
*
* Deletes and frees a kernel-mode representation of the surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdDeleteSurfaceObject(
    HANDLE  hSurface,
    DWORD*  pdwRet          // For returning driver return code, may be NULL
    )
{
    BOOL                    bRet;
    EDD_SURFACE*            peSurface;
    EDD_SURFACE*            peTmp;
    VOID*                   pvRemove;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DWORD                   dwRet;

    bRet = FALSE;
    dwRet = DDHAL_DRIVER_NOTHANDLED;

    peSurface = (EDD_SURFACE*) DdHmgLock((HDD_OBJ) hSurface, DD_SURFACE_TYPE, FALSE);

    if (peSurface != NULL)
    {
        PDEVOBJ poSurface;
        PDEVOBJ poMapping;
        BOOL    bUnrefMappingPdev = FALSE;

        peDirectDrawLocal  = peSurface->peDirectDrawLocal;
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        {
            EDD_SHAREDEVLOCK eDevLock(peDirectDrawGlobal);

            // Prevent from deleting GDI's PDEV if this is last Virtual map refer it.
            // We still need GDI's PDEV in order to call driver just below. so we
            //  -UN-reference it after we finish with driver.

            poSurface.vInit(peDirectDrawGlobal->hdev);
            poSurface.vReferencePdev();

            // If we have "aliased" video memory mapping, take ref count on the owner
            // of its mapping if it's different from current surface owner (due to video
            // mode change)

            if (peSurface->peMap)
            {
                // PDEVOBJ for owner of mapping

                poMapping.vInit(peSurface->peVirtualMapDdGlobal->hdev);

                // Is it different from current surface owner ?
 
                if (poMapping.bValid() &&
                    (poMapping.hdev() != poSurface.hdev()))
                {
                    poMapping.vReferencePdev();
                    bUnrefMappingPdev = TRUE;
                }
            }

            // Note that 'bDdReleaseDC' and 'bDeleteSurface' may fail if
            // another thread of the application is in the kernel using that
            // DC.  This can occur only if we're not currently doing the
            // process cleanup code (because process cleanup ensures that
            // only one thread from the process is still running).  It's okay,
            // because process-termination cleanup for the DC object itself
            // will take care of cleanup.

            if (peSurface->hdc)
            {
                // Note that any locks on behalf of the GetDC are taken care
                // of in 'vDdDisableSurfaceObject'.

                if (!bDdReleaseDC(peSurface, TRUE))
                {
                    WARNING("bDdDeleteSurfaceObject: Couldn't release DC\n");
                }
            }

            if (peSurface->hbmGdi)
            {
                // Delete the actual bitmap surface.  We are doing this from
                // the owning processes thread.

                DxEngDeleteSurface((HSURF) peSurface->hbmGdi);
                peSurface->hbmGdi = NULL;

                if (peSurface->hpalGdi)
                {
                    EngDeletePalette(peSurface->hpalGdi);
                    peSurface->hpalGdi = NULL;
                }
            }

            DDKSURF(("DDKSURF: Removing %X (%X)\n", hSurface, peSurface));

            pvRemove = DdHmgRemoveObject((HDD_OBJ) hSurface,
                                     DdHmgQueryLock((HDD_OBJ) hSurface),
                                     0,
                                     TRUE,
                                     DD_SURFACE_TYPE);

            ASSERTGDI(pvRemove != NULL, "Outstanding surfaces locks");

            // Remove any attachments:

            vDdDeleteReferringAttachments(peSurface);

            // Uncompleted surfaces are marked as 'lost' until they're completed,
            // but we still have to call the driver if that's the case:

            if (!(peSurface->bLost) ||
                !(peSurface->fl & DD_SURFACE_FLAG_CREATE_COMPLETE))
            {
                vDdDisableSurfaceObject(peDirectDrawGlobal, peSurface, &dwRet);
            }

            if (peSurface->peMap)
            {
                vDdReleaseVirtualMap(peSurface);
            }

            // Remove from the surface linked-list:

            RemoveEntryList(&(peSurface->List_eSurface));

            // Decrement number of surface in DirectDrawLocal.

            peDirectDrawLocal->cSurface--;

            // The surface object is about to be freed, call CreateSurfaceEx, to
            // inform the driver to disassociate the cookie if the driver can

            if ((peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
                && (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                && (peSurface->pGraphicsDeviceCreator == poSurface.pGraphicsDevice())
                && (0 != peSurface->dwSurfaceHandle)
               )
            {
                DD_CREATESURFACEEXDATA CreateSurfaceExData;
                ASSERTGDI(NULL==peSurface->hSecure,
                    "bDdDeleteSurfaceObject: SYSMEM object not unsecured upon delete");
                peSurface->fpVidMem = NULL;
                CreateSurfaceExData.ddRVal          = DDERR_GENERIC;
                CreateSurfaceExData.dwFlags         = 0;
                CreateSurfaceExData.lpDDLcl         = peDirectDrawLocal;
                CreateSurfaceExData.lpDDSLcl        = peSurface;
                // just notify driver that this system memory surface has been freed
                peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);
            }

            // If the surface has some outstanding system memory that needs
            // to be freed, now's the time to do it.

            if (peSurface->fl & DD_SURFACE_FLAG_DEFER_USERMEM)
            {
                DD_USERMEM_DEFER* pDefer = peDirectDrawGlobal->pUserMemDefer;
                DD_USERMEM_DEFER* pLast = NULL;
                DD_USERMEM_DEFER* pDeferTemp;

                while (pDefer != NULL)
                {
                    pDeferTemp = pDefer;
                    pDefer = pDefer->pNext;
                    if (pDeferTemp->peSurface == peSurface)
                    {
                        SafeFreeUserMem(pDeferTemp->pUserMem, peDirectDrawLocal->Process);

                        if (pLast == NULL)
                        {
                            peDirectDrawGlobal->pUserMemDefer = pDefer;
                        }
                        else
                        {
                            pLast->pNext = pDefer;
                        }
                        VFREEMEM(pDeferTemp);
                    }
                    else
                    {
                        pLast = pDeferTemp;
                    }
                }
            }

            // We're all done with this object, so free the memory and
            // leave:

            DdFreeObject(peSurface, DD_SURFACE_TYPE);
        }

        // Now, we've done. release GDI's PDEV if this is last one.

        if (bUnrefMappingPdev)
        {
            poMapping.vUnreferencePdev();
        }

        poSurface.vUnreferencePdev();

        bRet = TRUE;
    }
    else
    {
        WARNING1("bDdDeleteSurfaceObject: Bad handle or object was busy\n");
    }

    if (pdwRet != NULL)
    {
        *pdwRet = dwRet;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vDdDisableAllDirectDrawObjects
*
* Temporarily disables all DirectDraw surfaces and local objects.
*
* NOTE: Caller must be holding User critical section.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdDisableAllDirectDrawObjects(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal
    )
{
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DXDIRECTDRAW*       peDxDirectDraw;
    EDD_SURFACE*            peSurface;
    NTSTATUS                status;

    DD_ASSERTSHAREDEVLOCK();
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    // We may have to wait the standard 7 seconds for any locks to be
    // released before we go ahead and let the mode change happen.  We
    // do this only when cDirectDrawDisableLocks() == 1 to allow the
    // HDEV to be disabled recursively (i.e., this routine is re-entrant).

    peDirectDrawGlobal->bSuspended = TRUE;

    if (peDirectDrawGlobal->cSurfaceLocks >
        peDirectDrawGlobal->cSurfaceAliasedLocks)
    {
        // Release the devlock while waiting on the event:

        DxEngUnlockHdev(po.hdev());

        status = KeWaitForSingleObject(peDirectDrawGlobal->pAssertModeEvent,
                       Executive,
                       KernelMode,
                       FALSE,
                       (LARGE_INTEGER*) &peDirectDrawGlobal->
                                            llAssertModeTimeout);

        ASSERTGDI(NT_SUCCESS(status), "Wait error\n");

        DxEngLockHdev(po.hdev());

        // Now that we have the devlock, reset the event to not-signaled
        // for the next time we have to wait on someone's DirectDraw Lock
        // (someone may have signaled the event after the time-out, but
        // before we managed to acquire the devlock):

        KeResetEvent(peDirectDrawGlobal->pAssertModeEvent);
    }

    // Mark all surfaces associated with this device as lost and unmap all
    // views of the frame buffer:

    for (peDirectDrawLocal = peDirectDrawGlobal->peDirectDrawLocalList;
         peDirectDrawLocal != NULL;
         peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext)
    {
        peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

        while (peSurface)
        {
            if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
            {
                if((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
                    !(peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
                {
                    vDdLooseManagedSurfaceObject(peDirectDrawGlobal,
                                                 peSurface,
                                                 NULL);
                }
                else
                {
                    vDdDisableSurfaceObject(peDirectDrawGlobal,
                                            peSurface,
                                            NULL);
                }
            }
            else if ((peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
                      && (peSurface->pGraphicsDeviceCreator == po.pGraphicsDevice())
                      && (0 != peSurface->dwSurfaceHandle))
            {
                // Disassociate this system memory surface from driver.

                DD_CREATESURFACEEXDATA CreateSurfaceExData;
                FLATPTR                fpVidMem = peSurface->fpVidMem; // keep backup
                PDD_ATTACHLIST     lpAttachList = peSurface->lpAttachList; // keep backup
                PDD_ATTACHLIST lpAttachListFrom = peSurface->lpAttachListFrom; // keep backup
                peSurface->fpVidMem             = NULL;
                peSurface->lpAttachList         = NULL;
                peSurface->lpAttachListFrom     = NULL;
                CreateSurfaceExData.ddRVal      = DDERR_GENERIC;
                CreateSurfaceExData.dwFlags     = 0;
                CreateSurfaceExData.lpDDLcl     = peDirectDrawLocal;
                CreateSurfaceExData.lpDDSLcl    = peSurface;
                peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);
                peSurface->fpVidMem             = fpVidMem; // restore backup
                peSurface->lpAttachList         = lpAttachList; // restore backup
                peSurface->lpAttachListFrom     = lpAttachListFrom; // restore backup

                // workaround for smidisp.dll and just in case driver didn't clear-out dwReserved1

                if (((DD_SURFACE_GLOBAL *)peSurface)->dwReserved1)
                {
                    WARNING("Driver forget to clear SURFACE_GBL.dwReserved1 at CreateSurfaceEx()");
                }
                if (((DD_SURFACE_LOCAL *)peSurface)->dwReserved1)
                {
                    WARNING("Driver forget to clear SURFACE_LCL.dwReserved1 at CreateSurfaceEx()");
                }

                ((DD_SURFACE_GLOBAL *)peSurface)->dwReserved1 = 0;
                ((DD_SURFACE_LOCAL *)peSurface)->dwReserved1 = 0;
            }

            peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
        }

        vDdDisableDirectDrawObject(peDirectDrawLocal);
    }

    ASSERTGDI(peDirectDrawGlobal->cSurfaceLocks == 0,
        "There was a mismatch between global count of locks and actual");
}

/******************************Public*Routine******************************\
* BOOL DxDdGetDirectDrawBounds
*
* Gets the accumulated blt access rectangle to the primary surface. Returns
* FALSE if a DirectDraw blt to the primary has not occurred.
*
*  4-Nov-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

BOOL
DxDdGetDirectDrawBounds(
    HDEV    hdev,
    RECT*   prcBounds
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    PDEVOBJ po(hdev);

    peDirectDrawGlobal = po.peDirectDrawGlobal();
    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    if (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_BOUNDS_SET)
    {
        // Return the bounds rectangle and reset the bounds flag:

        *((RECTL*) prcBounds) = peDirectDrawGlobal->rclBounds;
        peDirectDrawGlobal->fl &= ~DD_GLOBAL_FLAG_BOUNDS_SET;

        return TRUE;
    }

    return FALSE;
}

/******************************Public*Routine******************************\
* VOID DxDdSuspendDirectDraw
*
* Temporarily disables DirectDraw for the specified device.
*
* NOTE: Caller must be holding User critical section.
*
* NOTE: Caller must NOT be holding devlock, unless DirectDraw is already
*       disabled.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
DxDdSuspendDirectDraw(
    HDEV    hdev,
    ULONG   fl
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    LONG*                   pl;
    HDEV                    hdevCurrent;
    BOOL                    bChildren = (fl & DXG_SR_DDRAW_CHILDREN);

    // Bump the mode uniqueness to let user-mode DirectDraw know that
    // someone else has done a mode change.  (Full-screen switches count as
    // full-screen, too).  Do it interlocked because we're not holding a
    // global lock:

    INC_DISPLAY_UNIQUENESS();

    // If bChildren is TRUE, make sure we've really got a meta driver:

    if (bChildren)
    {
        PDEVOBJ po(hdev);
        ASSERTGDI(po.bValid() && po.bDisplayPDEV(), "Invalid HDEV");

        bChildren = po.bMetaDriver();
    }

    hdevCurrent = bChildren ? DxEngEnumerateHdev(NULL) : hdev;

    do
    {
        PDEVOBJ po(hdevCurrent);
        ASSERTGDI(po.bValid(), "Invalid HDEV");
        ASSERTGDI(po.bDisplayPDEV(), "Not a display HDEV");

        if (!bChildren || (po.hdevParent() == hdev))
        {
            peDirectDrawGlobal = po.peDirectDrawGlobal();

            EDD_SHARELOCK eShareLock(FALSE);

            if (fl & DXG_SR_DDRAW_MODECHANGE)
            {
                // ShareLock must be held by caller for video mode change.

                DD_ASSERTSHAREDEVLOCK();

                // We need to completely release the devlock soon, so we must not
                // be called with the devlock already held.  If we don't do this,
                // any thread calling Unlock will be locked out until the timeout.

                DD_ASSERTNODEVLOCK(peDirectDrawGlobal);
            }
            else
            {
                eShareLock.vLock();
            }

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            ASSERTGDI(peDirectDrawGlobal->hdev != NULL,
                "Can't suspend DirectDraw on an HDEV that was never DDraw enabled!");

            if (po.cDirectDrawDisableLocks() == 0)
            {
                // Notify any kernel-mode DXAPI clients that have hooked the
                // relevant event:

                vDdNotifyEvent(peDirectDrawGlobal, DDEVENT_PREDOSBOX);

                // Disable all DirectDraw object.

                vDdDisableAllDirectDrawObjects(peDirectDrawGlobal);
            }

            // Increment the disable lock-count event if a DirectDraw global
            // object hasn't been created:

            po.cDirectDrawDisableLocks(po.cDirectDrawDisableLocks() + 1);
        }

        if (bChildren)
        {
            hdevCurrent = DxEngEnumerateHdev(hdevCurrent);
        }

    } while (bChildren && hdevCurrent);
}

/******************************Public*Routine******************************\
* VOID DxDdResumeDirectDraw
*
* Permits DirectDraw to be reenabled for the specified device.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
DxDdResumeDirectDraw(
    HDEV    hdev,
    ULONG   fl
    )
{
    LONG*   pl;
    HDEV    hdevCurrent;
    BOOL    bChildren = fl & DXG_SR_DDRAW_CHILDREN;

    // Bump the mode uniqueness again.  We do this both before and after
    // the mode change actually occurs to give DirectDraw proper
    // notification.  If kernel-mode starts failing DdBlt calls because
    // the mode has changed, this implies that we have to let DirectDraw
    // know before the mode change occurs; but if we let DirectDraw know
    // only before the mode change occurs, it might re-enable us before
    // the new mode is actually set, so we also have to let it know after
    // the mode change has occured.

    INC_DISPLAY_UNIQUENESS();

    // If bChildren is TRUE, make sure we've really got a meta driver:

    if (bChildren)
    {
        PDEVOBJ po(hdev);
        ASSERTGDI(po.bValid() && po.bDisplayPDEV(), "Invalid HDEV");

        bChildren = po.bMetaDriver();
    }

    hdevCurrent = bChildren ? DxEngEnumerateHdev(NULL) : hdev;

    do
    {
        PDEVOBJ po(hdevCurrent);
        ASSERTGDI(po.bValid(), "Invalid HDEV");
        ASSERTGDI(po.bDisplayPDEV(), "Not a display HDEV");

        if (!bChildren || (po.hdevParent() == hdev))
        {
            // Decrement the disable lock-count even if a DirectDraw global object
            // hasn't been created:

            EDD_DEVLOCK eDevlock(po.hdev());

            ASSERTGDI(po.cDirectDrawDisableLocks() != 0,
                "Must have called disable previously to be able to enable DirectDraw.");

            po.cDirectDrawDisableLocks(po.cDirectDrawDisableLocks() - 1);

            if (po.cDirectDrawDisableLocks() == 0)
            {
                // Notify any kernel-mode DXAPI clients that have hooked the relevant
                // event.  Note that thie mode change is done, but DirectDraw is still
                // in a suspended state. [Is that a problem?]

                vDdNotifyEvent(po.peDirectDrawGlobal(), DDEVENT_POSTDOSBOX);

                // Reassociate system memory surface to driver (which disassociated by ResumeDirectDraw)

                if (po.peDirectDrawGlobal()->Miscellaneous2CallBacks.CreateSurfaceEx)
                {
                    for (EDD_DIRECTDRAW_LOCAL *peDirectDrawLocal = po.peDirectDrawGlobal()->peDirectDrawLocalList;
                         peDirectDrawLocal != NULL;
                         peDirectDrawLocal = peDirectDrawLocal->peDirectDrawLocalNext)
                    {
                        EDD_SURFACE *peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

                        while (peSurface)
                        {
                            if ((peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                                && (peSurface->pGraphicsDeviceCreator == po.pGraphicsDevice())
                                && (0 != peSurface->dwSurfaceHandle)
                                && (peSurface->ddpfSurface.dwFlags & DDPF_FOURCC))
                            {
                                switch (peSurface->ddpfSurface.dwFourCC)
                                {
                                case FOURCC_DXT1:
                                case FOURCC_DXT2:
                                case FOURCC_DXT3:
                                case FOURCC_DXT4:
                                case FOURCC_DXT5:
                                    peSurface->wWidth = peSurface->wWidthOriginal;
                                    peSurface->wHeight = peSurface->wHeightOriginal;
                                }
                            }

                            peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
                        }


                        KeAttachProcess(PsGetProcessPcb(peDirectDrawLocal->Process));

                        peSurface = peDirectDrawLocal->peSurface_Enum(NULL);

                        while (peSurface)
                        {
                            // Only restore when this system memory surface previously
                            // called to this driver and we called CreateSurfaceEx.

                            if ((peSurface->fl & DD_SURFACE_FLAG_SYSMEM_CREATESURFACEEX)
                                && (peSurface->pGraphicsDeviceCreator == po.pGraphicsDevice()))
                            {
                                DD_CREATESURFACEEXDATA CreateSurfaceExData;

                                ASSERTGDI(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY,
                                          "DXG:ResumeDirectDraw: no system memory flag");
                                ASSERTGDI(peSurface->dwSurfaceHandle != 0,
                                          "DXG:ResumeDirectDraw: dwSurfaceHandle is 0");

                                CreateSurfaceExData.dwFlags        = 0;
                                CreateSurfaceExData.ddRVal         = DDERR_GENERIC;
                                CreateSurfaceExData.lpDDLcl        = peDirectDrawLocal;
                                CreateSurfaceExData.lpDDSLcl       = peSurface;
                                po.peDirectDrawGlobal()->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);

                                if (CreateSurfaceExData.ddRVal != DD_OK)
                                {
                                    WARNING("DxDdResumeDirectDraw(): Reassociate system memory surface failed");
                                }
                            }

                            peSurface = peDirectDrawLocal->peSurface_Enum(peSurface);
                        }

                        KeDetachProcess();
                    }
                }
            }
        }

        if (bChildren)
        {
            hdevCurrent = DxEngEnumerateHdev(hdevCurrent);
        }

    } while (bChildren && hdevCurrent);
}

/******************************Public*Routine******************************\
* VOID DxDdDynamicModeChange
*
* Transfers DirectDraw driver instances between two PDEVs.
*
* The devlock and handle manager semaphore must be held to call this function!
*
* NOTE: This is the last step that should be taken in the dynamic mode
*       change process, so that in this routine we can assume that the
*       call tables and the like for the respective HDEVs have already
*       been swapped.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
DxDdDynamicModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew,
    ULONG   fl
    )
{
    DD_DIRECTDRAW_GLOBAL_DRIVER_DATA    GlobalDriverDataSwap;
    EDD_DIRECTDRAW_GLOBAL*              peDirectDrawGlobalOld;
    EDD_DIRECTDRAW_GLOBAL*              peDirectDrawGlobalNew;
    D3DNTHAL_OBJECT*                    pdhobj;
    EDD_SURFACE*                        peSurface;
    HDD_OBJ                             hobj;
    LONG                                cReferencesOld;
    LONG                                cReferencesNew;
    LONG                                cAdjustOld;
    LONG                                cAdjustNew;
    FLONG                               flOld;
    FLONG                               flNew;
    LPDDVIDEOPORTCAPS                   lpDDVideoPortCaps;
    DWORD                               dwHeap;
    VIDEOMEMORY*                        pHeap;
    DWORD                               dwHeapNew;
    VIDEOMEMORY*                        pHeapNew;
    BOOL                                bSwappedAGP;

    PDEVOBJ poOld(hdevOld);
    PDEVOBJ poNew(hdevNew);

    peDirectDrawGlobalOld = poOld.peDirectDrawGlobal();
    peDirectDrawGlobalNew = poNew.peDirectDrawGlobal();

    DDKHEAP(("peDDGOld=%lx, cDriverReferences=%d\n",
             peDirectDrawGlobalOld, peDirectDrawGlobalOld->cDriverReferences));
    DDKHEAP(("peDDGNew=%lx, cDriverReferences=%d\n",
             peDirectDrawGlobalNew, peDirectDrawGlobalNew->cDriverReferences));

    // Notify any kernel-mode DXAPI clients that have hooked the relevant
    // events.

    vDdNotifyEvent(peDirectDrawGlobalOld, DDEVENT_PRERESCHANGE);
    vDdNotifyEvent(peDirectDrawGlobalOld, DDEVENT_POSTRESCHANGE);
    vDdNotifyEvent(peDirectDrawGlobalNew, DDEVENT_PRERESCHANGE);
    vDdNotifyEvent(peDirectDrawGlobalNew, DDEVENT_POSTRESCHANGE);

    // The DD_GLOBAL_FLAG_DRIVER_ENABLED flag transfers to the new PDEV
    // along with the driver instance:

    flOld = peDirectDrawGlobalOld->fl;
    flNew = peDirectDrawGlobalNew->fl;

    peDirectDrawGlobalOld->fl         = (flOld & ~DD_GLOBAL_FLAG_DRIVER_ENABLED)
                                      | (flNew & DD_GLOBAL_FLAG_DRIVER_ENABLED)
                                      | (DD_GLOBAL_FLAG_MODE_CHANGED);
    peDirectDrawGlobalOld->bSuspended = TRUE;
    peDirectDrawGlobalOld->dhpdev     = poOld.dhpdev();
    peDirectDrawGlobalOld->hdev       = poOld.hdev();

    peDirectDrawGlobalNew->fl         = (flNew & ~DD_GLOBAL_FLAG_DRIVER_ENABLED)
                                      | (flOld & DD_GLOBAL_FLAG_DRIVER_ENABLED)
                                      | (DD_GLOBAL_FLAG_MODE_CHANGED);
    peDirectDrawGlobalNew->bSuspended = TRUE;
    peDirectDrawGlobalNew->dhpdev     = poNew.dhpdev();
    peDirectDrawGlobalNew->hdev       = poNew.hdev();

    // Transfer heap AGP 'handles':
    //
    // since AGP handle stay with its driver instance.

    pHeap = peDirectDrawGlobalOld->pvmList;
    for (dwHeap = 0;
         dwHeap < peDirectDrawGlobalOld->dwNumHeaps;
         pHeap++, dwHeap++)
    {
        if (!(pHeap->dwFlags & VIDMEM_ISHEAP) &&
            !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
            (pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
            (pHeap->lpHeap != NULL) &&
            (pHeap->lpHeap->hdevAGP == AGP_HDEV(peDirectDrawGlobalOld)))
        {
            pHeap->lpHeap->hdevAGP = AGP_HDEV(peDirectDrawGlobalNew);
        }
    }

    pHeap = peDirectDrawGlobalNew->pvmList;
    for (dwHeap = 0;
         dwHeap < peDirectDrawGlobalNew->dwNumHeaps;
         pHeap++, dwHeap++)
    {
        if (!(pHeap->dwFlags & VIDMEM_ISHEAP) &&
            !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
            (pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
            (pHeap->lpHeap != NULL) &&
            (pHeap->lpHeap->hdevAGP == AGP_HDEV(peDirectDrawGlobalNew)))
        {
            pHeap->lpHeap->hdevAGP = AGP_HDEV(peDirectDrawGlobalOld);
        }
    }

    // DirectDraw objects and surfaces stay with the PDEV, but driver
    // instances are swapped:

    RtlCopyMemory(&GlobalDriverDataSwap,
                  (DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobalOld,
                  sizeof(DD_DIRECTDRAW_GLOBAL_DRIVER_DATA));

    RtlCopyMemory((DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobalOld,
                  (DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobalNew,
                  sizeof(DD_DIRECTDRAW_GLOBAL_DRIVER_DATA));

    RtlCopyMemory((DD_DIRECTDRAW_GLOBAL_DRIVER_DATA*) peDirectDrawGlobalNew,
                  &GlobalDriverDataSwap,
                  sizeof(DD_DIRECTDRAW_GLOBAL_DRIVER_DATA));

    // If the old object had an initialized AGP heap, make sure that it stays 
    // with the old object (swap it back).  We only want to do this if it's
    // not a one-to-many or many-to-one mode change, however.

    bSwappedAGP = FALSE;
    if (!poNew.bMetaDriver() && 
        !poOld.bMetaDriver() &&
        (poNew.pldev() == poOld.pldev()))
    {
        pHeap = peDirectDrawGlobalOld->pvmList;
        for (dwHeap = 0;
             dwHeap < peDirectDrawGlobalOld->dwNumHeaps;
             pHeap++, dwHeap++)
        {
            if (!(pHeap->dwFlags & VIDMEM_ISHEAP) &&
                !(pHeap->dwFlags & VIDMEM_HEAPDISABLED) &&
                (pHeap->dwFlags & VIDMEM_ISNONLOCAL) &&
                (pHeap->lpHeap != NULL) &&
                (pHeap->lpHeap->pvPhysRsrv == NULL))
            {
                // The old object has a heap, find the corresponding heap in the
                // new object.

                pHeapNew = peDirectDrawGlobalNew->pvmList;
                for (dwHeapNew = 0;
                     dwHeapNew < peDirectDrawGlobalNew->dwNumHeaps;
                     pHeapNew++, dwHeapNew++)
                {   
                    if ((pHeapNew->dwFlags == pHeap->dwFlags) &&
                        (pHeapNew->lpHeap != NULL) &&
                        (pHeapNew->lpHeap->pvPhysRsrv != NULL))
                    {
                        SwapHeaps( pHeap, pHeapNew );

                        // We used to tear down the heap and create a new one
                        // with each mode change, but now we keep the one heap 
                        // active acrross mode changes.  This means that we don't
                        // need to notify the driver the driver of the heap change,
                        // but this is a behavior change and some drivers depend
                        // on this notification so we'll do it anyway.

                        UpdateNonLocalHeap( peDirectDrawGlobalOld, dwHeap );
                        bSwappedAGP = TRUE;
                    }
                }
            }
        }
    }

    // Also swap video port caps, which are part of the DIRETCDRAW_GLOBAL

    lpDDVideoPortCaps = peDirectDrawGlobalOld->lpDDVideoPortCaps;
    peDirectDrawGlobalOld->lpDDVideoPortCaps = peDirectDrawGlobalNew->lpDDVideoPortCaps;
    peDirectDrawGlobalNew->lpDDVideoPortCaps = lpDDVideoPortCaps;

    cReferencesNew = 0;
    cReferencesOld = 0;
    cAdjustNew = 0;
    cAdjustOld = 0;

    // Transfer ownership of any Direct3D objects to its new PDEV:
    //
    // since it stay with its driver instance.

    DdHmgAcquireHmgrSemaphore();

    hobj = 0;
    while (pdhobj = (D3DNTHAL_OBJECT*) DdHmgNextObjt(hobj, D3D_HANDLE_TYPE))
    {
        hobj = (HDD_OBJ) pdhobj->hGet();

        if (pdhobj->peDdGlobal == peDirectDrawGlobalOld)
        {
            pdhobj->peDdGlobal = peDirectDrawGlobalNew;
            cReferencesNew++;
        }
        else if (pdhobj->peDdGlobal == peDirectDrawGlobalNew)
        {
            pdhobj->peDdGlobal = peDirectDrawGlobalOld;
            cReferencesOld++;
        }
    }

    hobj = 0;
    while (peSurface = (EDD_SURFACE*) DdHmgNextObjt(hobj, DD_SURFACE_TYPE))
    {
        hobj = (HDD_OBJ) peSurface->hGet();

        // Transfer VMEMMAPPING structures
        //
        // since it stay with its driver instance.  We do not switch these
        // for AGP surfaces since we no longer switch the AGP heaps.

        if (peSurface->peVirtualMapDdGlobal == peDirectDrawGlobalOld)
        {
            DDKHEAP(("vDdDynamicModeChange: %x->%x matches old global\n",
                     peSurface, peSurface->peVirtualMapDdGlobal));

            if ((peSurface->peMap != NULL) &&
                (peSurface->peMap->fl & DD_VMEMMAPPING_FLAG_AGP) &&
                bSwappedAGP)
            {
                cAdjustOld++;
            }
            else
            {
                peSurface->peVirtualMapDdGlobal = peDirectDrawGlobalNew;
                cReferencesNew++;
            }
        }
        else if (peSurface->peVirtualMapDdGlobal == peDirectDrawGlobalNew)
        {
            DDKHEAP(("vDdDynamicModeChange: %x->%x matches new global\n",
                     peSurface, peSurface->peVirtualMapDdGlobal));
            if ((peSurface->peMap != NULL) &&
                (peSurface->peMap->fl & DD_VMEMMAPPING_FLAG_AGP) &&
                bSwappedAGP)
            {
                cAdjustNew++;
            }
            else
            {
                peSurface->peVirtualMapDdGlobal = peDirectDrawGlobalOld;
                cReferencesOld++;
            }
        }

        // If surface is "driver managed"...
        //
        // driver managed surface will stay with its driver instance.

        if (peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED)
        {
            // And if we are doing mode change across "different" video drivers
            // mark wrong driver flag while it live in there until go back
            // to original creator driver.
            //
            // And peDdGlobalCreator should go with driver instance.

            // If video mode change happen with same driver, surface with just stay where it is.

            if (poOld.pldev() == poNew.pldev())
            {
                // Driver reference has been swapped, but this surface will continue to
                // stick with same, so need adjust it (= transfer back).

                if (peSurface->peDdGlobalCreator == peDirectDrawGlobalOld)
                {
                    if (!(peSurface->bLost))
                    {
                        cAdjustOld++;
                    }

                #if DBG_HIDEYUKN
                    KdPrint(("DXG: same pldev, stay with old\n"));
                #endif
                }
                else if (peSurface->peDdGlobalCreator == peDirectDrawGlobalNew)
                {
                    if (!(peSurface->bLost))
                    {
                        cAdjustNew++;
                    }

                #if DBG_HIDEYUKN
                    KdPrint(("DXG: same pldev, stay with new\n"));
                #endif
                }
            }
            else // if (poOld.pldev() != poNew.poNew())
            {
                if (peSurface->peDdGlobalCreator == peDirectDrawGlobalOld)
                {
                    // This surface is currently associated to old driver
                    // (= where actually will be new after swap)

                    // Transfer the surface to new (where it will be Old).

                    peSurface->peDdGlobalCreator = peDirectDrawGlobalNew;

                    if (peSurface->peDdGlobalCreator == peSurface->peDirectDrawGlobal)
                    {
                        peSurface->fl &= ~DD_SURFACE_FLAG_WRONG_DRIVER;

                    #if DBG_HIDEYUKN
                        KdPrint(("DXG: diff pldev, move to new, clear wrong driver\n"));
                    #endif
                    }
                    else
                    {
                        peSurface->fl |= DD_SURFACE_FLAG_WRONG_DRIVER; 

                    #if DBG_HIDEYUKN
                        KdPrint(("DXG: diff pldev, move to new, set wrong driver\n"));
                    #endif
                    }

                    // Driver reference count has been swapped already in above. so new DdGlobal
                    // already has reference for this surface. Increment this for later verification.

                    if (!(peSurface->bLost))
                    {
                        cReferencesNew++;
                    }
                }
                else if (peSurface->peDdGlobalCreator == peDirectDrawGlobalNew)
                {
                    // This surface is currently associated to new (where it will be old after swap)

                    // Transfer the surface to old (where it will be new).

                    peSurface->peDdGlobalCreator = peDirectDrawGlobalOld;

                    if (peSurface->peDdGlobalCreator == peSurface->peDirectDrawGlobal)
                    {
                        peSurface->fl &= ~DD_SURFACE_FLAG_WRONG_DRIVER;

                    #if DBG_HIDEYUKN
                        KdPrint(("DXG: diff pldev, move to old, clear wrong driver\n"));
                    #endif
                    }
                    else
                    {
                        peSurface->fl |= DD_SURFACE_FLAG_WRONG_DRIVER;

                    #if DBG_HIDEYUKN
                        KdPrint(("DXG: diff pldev, move to old, set wrong driver\n"));
                    #endif
                    }

                    // if surface is not losted, make sure reference is stay with old driver
                    // (this is for later assertion).

                    if (!(peSurface->bLost))
                    {
                        cReferencesOld++;
                    }
                }
            }
        }
    }

    DdHmgReleaseHmgrSemaphore();

#if DBG_HIDEYUKN
    KdPrint(("DXG:Reference Counts BEFORE Adjust\n"));
    KdPrint(("DXG:DdGlobalOld->cDriverReference (%d) = cReferencesOld (%d) + cAdjustNew (%d)\n",
              peDirectDrawGlobalOld->cDriverReferences,cReferencesOld,cAdjustNew));
    KdPrint(("DXG:DdGlobalNew->cDriverReference (%d) = cReferencesNew (%d) + cAdjustOld (%d)\n",
              peDirectDrawGlobalNew->cDriverReferences,cReferencesNew,cAdjustOld));
#endif

    // We used to transfer all of the surfaces from the old PDEV to the new
    // one, but now we only do that for the non-agp surfaces, which means that
    // we need to adjust the cDriverReferences accordingly.

    ASSERTGDI(cReferencesOld + cAdjustNew == peDirectDrawGlobalOld->cDriverReferences,
        "Mis-match in old D3D driver references");
    ASSERTGDI(cReferencesNew + cAdjustOld == peDirectDrawGlobalNew->cDriverReferences,
        "Mis-match in new D3D driver references");

    // Transfer the PDEV references:
    //
    // I'm going to try to explain this.  DXG keeps a single ref count on each
    // PDEV that either has a surface or a context associated with it, so on
    // entering this funtion, we have a single ref count on the old PDEV.
    // If we transfer all of the surfaces to the new PDEV, then we can decrement
    // from the ref from the old PDEV and add on to the new PDEV.  If some of the
    // surfaces continue with the old PDEV, however, then we need to make sure
    // that we keep ref on that PDEV as well.

    peDirectDrawGlobalNew->cDriverReferences -= cAdjustOld;
    peDirectDrawGlobalNew->cDriverReferences += cAdjustNew;
    peDirectDrawGlobalOld->cDriverReferences -= cAdjustNew;
    peDirectDrawGlobalOld->cDriverReferences += cAdjustOld;

#if DBG_HIDEYUKN
    KdPrint(("DXG:Reference Counts AFTER Adjust\n"));
    KdPrint(("DXG:DdGlobalOld->cDriverReferences = %d\n",peDirectDrawGlobalOld->cDriverReferences));
    KdPrint(("DXG:DdGlobalNew->cDriverReferences = %d\n",peDirectDrawGlobalNew->cDriverReferences));
#endif

    if (cReferencesNew || cAdjustOld)
    {
        // The old PDEV had references on it
        if (peDirectDrawGlobalOld->cDriverReferences == 0)
        {
            //but it doesn't now, so remove it
            poOld.vUnreferencePdev();
        }
    }
    else
    {
        // The old PDEV did not have refernces on it
        if (peDirectDrawGlobalOld->cDriverReferences > 0)
        {
            // but it does not, so add it
            poOld.vReferencePdev();      
        }
    }

    if (cReferencesOld || cAdjustNew)
    {
        // The new PDEV had references on it
        if (peDirectDrawGlobalNew->cDriverReferences == 0)
        {
            // but it doesn't now, so remove it
            poNew.vUnreferencePdev();
        }
    }
    else
    {
        // The new PDEV did not have references on it
        if (peDirectDrawGlobalNew->cDriverReferences > 0)
        {
            // but it does now, so add it
            poNew.vReferencePdev();      
        }
    }

    // Move DirectDraw lock count.
    //
    // - this point, the disabled flag has *NOT* been swapped YET, so
    //   we need to move the lock count to where it *will be* disabled "after this call"
    //   not the device currently disabled.
    // 
    // So if poNew is disabled at here, GDI will make poOld disabled (after this call),
    // thus transfer disabled lock to poOld.

    if (!poNew.bMetaDriver() && !poOld.bMetaDriver())
    {
        // Mode change between display drivers.

        if (poNew.bDisabled())
        {
            // These asserts make sure that nothing happens other than cLock count adjustment

            ASSERTGDI(poOld.cDirectDrawDisableLocks() >= 1,"Old PDEV cDirectDrawLocks <= 0");
            ASSERTGDI(poNew.cDirectDrawDisableLocks() >= 2,"New PDEV cDirectDrawLocks <= 1");

            poOld.cDirectDrawDisableLocks(poOld.cDirectDrawDisableLocks() + 1);
            poNew.cDirectDrawDisableLocks(poNew.cDirectDrawDisableLocks() - 1);
        }

        if (poOld.bDisabled())
        {
            // These asserts make sure that nothing happens other than cLock count adjustment

            ASSERTGDI(poNew.cDirectDrawDisableLocks() >= 1,"New PDEV cDirectDrawLocks <= 0");
            ASSERTGDI(poOld.cDirectDrawDisableLocks() >= 2,"Old PDEV cDirectDrawLocks <= 1");

            poNew.cDirectDrawDisableLocks(poNew.cDirectDrawDisableLocks() + 1);
            poOld.cDirectDrawDisableLocks(poOld.cDirectDrawDisableLocks() - 1);
        }
    }
    else if (poNew.bMetaDriver() && poOld.bMetaDriver())
    {
        // Mode change between DDMLs, nothing need to do.
        // Because the hdev for Meta driver is ALWAYS created newly, never reused.
        // (see gre\drvsup\hCreateHDEV()).
    }
    else if (poOld.bMetaDriver() || poNew.bMetaDriver())
    {
        // Since at this point, the meta driver flag has been swapped.
        //
        // - when poOld is meta, we are doing 1 -> 2 mode change.
        // - when poNew is meta, we are doing 2 -> 1 mode change.

        if (poNew.bDisabled())
        {
            // These asserts make sure that nothing happens other than cLock count adjustment
            //
            // ASSERTGDI(poOld.cDirectDrawDisableLocks() >= 1,"A: Old PDEV cDirectDrawLocks <= 0");
            // ASSERTGDI(poNew.cDirectDrawDisableLocks() >= 2,"B: New PDEV cDirectDrawLocks <= 1");

            poOld.cDirectDrawDisableLocks(poOld.cDirectDrawDisableLocks() + 1);
            poNew.cDirectDrawDisableLocks(poNew.cDirectDrawDisableLocks() - 1);
        }

        if (poOld.bDisabled())
        {
            // These asserts make sure that nothing happens other than cLock count adjustment
            //
            // ASSERTGDI(poNew.cDirectDrawDisableLocks() >= 1,"C: New PDEV cDirectDrawLocks <= 0");
            // ASSERTGDI(poOld.cDirectDrawDisableLocks() >= 2,"D: Old PDEV cDirectDrawLocks <= 1");

            poNew.cDirectDrawDisableLocks(poNew.cDirectDrawDisableLocks() + 1);
            poOld.cDirectDrawDisableLocks(poOld.cDirectDrawDisableLocks() - 1);
        }
    }
}

/******************************Public*Routine******************************\
* VOID vDdMapMemory
*
* Creates a user-mode mapping of the device's entire frame buffer in the
* current process.
*
* The devlock must be held to call this function.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vDdMapMemory(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    HRESULT*                pResult
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DWORD                   dwRet;
    DD_MAPMEMORYDATA        MapMemoryData;
    SIZE_T                  CommitSize;
    HANDLE                  pSection;
    HANDLE                  SectionHandle;
    NTSTATUS                Status;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    if (!(peDirectDrawGlobal->CallBacks.dwFlags & DDHAL_CB32_MAPMEMORY))
    {
        peDirectDrawLocal->fl |= DD_LOCAL_FLAG_MEMORY_MAPPED;
        peDirectDrawGlobal->cMaps++;
    }
    else
    {
        MapMemoryData.lpDD      = peDirectDrawGlobal;
        MapMemoryData.bMap      = TRUE;
        MapMemoryData.hProcess  = NtCurrentProcess();
        MapMemoryData.fpProcess = NULL;

        dwRet = peDirectDrawGlobal->CallBacks.MapMemory(&MapMemoryData);

        *pResult = MapMemoryData.ddRVal;

        if (*pResult == DD_OK)
        {
            // Allocate new EDD_VMEMMAPPING object
            peDirectDrawLocal->peMapCurrent = (EDD_VMEMMAPPING*)
                PALLOCMEM(sizeof(EDD_VMEMMAPPING), ' ddG');

            if (peDirectDrawLocal->peMapCurrent)
            {
                peDirectDrawLocal->peMapCurrent->fpProcess =
                    MapMemoryData.fpProcess;
                peDirectDrawLocal->peMapCurrent->cReferences = 1;

                peDirectDrawLocal->fpProcess = MapMemoryData.fpProcess;
                peDirectDrawLocal->fl |= DD_LOCAL_FLAG_MEMORY_MAPPED;
                peDirectDrawGlobal->cMaps++;

                ASSERTGDI(peDirectDrawLocal->fpProcess != 0,
                    "Expected non-NULL fpProcess value from MapMemory");
                ASSERTGDI((ULONG) peDirectDrawLocal->fpProcess
                        < MM_USER_PROBE_ADDRESS,
                    "Expected user-mode fpProcess value from MapMemory");
            }
            else
            {
                WARNING("vDdMapMemory: "
                    "Could not allocate memory for peMapCurrent\n");

                // Clean up the driver mapping since we are failing vDdMapMemory call!

                MapMemoryData.lpDD      = peDirectDrawGlobal;
                MapMemoryData.bMap      = FALSE;
                MapMemoryData.hProcess  = NtCurrentProcess();

                // Keep fpProcess as what driver returned at above call.
                //
                // MapMemoryData.fpProcess = MapMemoryData.fpProcess;

                // Don't really care if this succeeds. It's bad news anyway

                peDirectDrawGlobal->CallBacks.MapMemory(&MapMemoryData);

                return;
            }
        }
        else
        {
            WARNING("vDdMapMemory: Driver failed DdMapMemory\n");
        }
    }
}

/******************************Public*Routine******************************\
* VOID pDdLockSurfaceOrBuffer
*
* Returns a user-mode pointer to the surface or D3D buffer.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID*
pDdLockSurfaceOrBuffer(
    EDD_SURFACE*    peSurface,
    BOOL            bHasRect,
    RECTL*          pArea,
    DWORD           dwFlags,      // DDLOCK_WAIT, DDLOCK_NOSYSLOCK
    HRESULT*        pResult       // ddRVal result of call (may be NULL)
    )
{
    VOID*                   pvRet;
    DD_LOCKDATA             LockData;
    DD_UNLOCKDATA           UnlockData;
    EDD_DIRECTDRAW_GLOBAL*  peDdGlobalDriver;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    DWORD                   dwTmp;
    DWORD                   dwRedraw;
    PDD_SURFCB_LOCK         pfnLock;

    pvRet = NULL;
    LockData.ddRVal = DDERR_GENERIC;

    peDirectDrawLocal  = peSurface->peDirectDrawLocal;

    // Due to video mode change across different video driver, currently
    // this "driver managed" surface is associated to different driver
    // than the driver who actually manage it. So we must call the driver
    // which actually manage the surface.

    // Hold share lock and devlock for video mode change.
    // peSurface->fl can be changed by mode change, so we need to access
    // there under holding share lock.

    EDD_SHARELOCK eSharelock(TRUE);

    if (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER)
    {
        // If surface is owned by different driver, lock right driver.

        if (peSurface->peDirectDrawGlobal != peSurface->peDdGlobalCreator)
        {
            peDdGlobalDriver = peSurface->peDdGlobalCreator;
        }

        // WARNING("pDdLockSurfaceOrBuffer: Lock on wrong driver");
    }
    else
    {
        peDdGlobalDriver = peSurface->peDirectDrawGlobal;
    }

    EDD_DEVLOCK eDevlock(peDdGlobalDriver);

    // For system memory surface, just return here without involving driver.

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        pvRet = (VOID*) peSurface->fpVidMem;
        LockData.ddRVal = DD_OK;
        goto Exit;
    }

    // In case if videomode change just happened, make sure new mode
    // has DirectDraw capability.

    if (!(peDdGlobalDriver->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED))
    {
        LockData.ddRVal = DDERR_SURFACELOST;
        goto Exit;
    }

    // We have to check both to see if the surface is disabled and if
    // DirectDraw is disabled.  We have to do the latter because we may
    // be in a situtation where we're denying locks, but all the
    // individual surfaces have not yet been marked as disabled.

    if (peSurface->bLost)
    {
        LockData.ddRVal = DDERR_SURFACELOST;
        goto Exit;
    }

    if ((peDdGlobalDriver->bSuspended) ||
        (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER))
    {
        // Only the "driver managed surface" surface has DDSCAPS2_DONOTPERSIST
        // can be locked when driver is suspended or surface lives in different driver.

        if ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
            !(peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
        {
            // WARNING("pDdLockSurfaceOrBuffer: Call driver other than current to lock driver managed surface"); 
        }
        else
        {
            LockData.ddRVal = DDERR_SURFACELOST;
            goto Exit;
        }
    }

    LockData.dwFlags     = dwFlags & (
                            DDLOCK_SURFACEMEMORYPTR |
                            DDLOCK_DISCARDCONTENTS |
                            DDLOCK_NOOVERWRITE | 
                            DDLOCK_READONLY |
                            DDLOCK_WRITEONLY |
                            DDLOCK_HASVOLUMETEXTUREBOXRECT |
                            DDLOCK_NODIRTYUPDATE);
    LockData.lpDD        = peDdGlobalDriver;
    LockData.lpDDSurface = peSurface;
    LockData.bHasRect    = bHasRect;

    if (bHasRect)
    {
        // Validate lock area.

        LONG left, top, right, bottom;
        LONG front, back, SurfaceDepth;

        if ((peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) &&
            (LockData.dwFlags & DDLOCK_HASVOLUMETEXTUREBOXRECT))
        {
            left    = pArea->left  & 0xFFFF;
            top     = pArea->top;
            right   = pArea->right & 0xFFFF;
            bottom  = pArea->bottom;
            front   = (ULONG)(pArea->left)  >> 16;
            back    = (ULONG)(pArea->right) >> 16;
            SurfaceDepth = peSurface->dwBlockSizeY;
        }
        else
        {
            left    = pArea->left;
            top     = pArea->top;
            right   = pArea->right;
            bottom  = pArea->bottom;
        }

        // Ensure that the driver and 'bSpTearDownSprites'
        // don't fall over when given a bad rectangle:

        if ((left   >= right)                    ||
            (top    >= bottom)                   ||
            (left   < 0)                         ||
            (top    < 0)                         ||
            (right  > (LONG) peSurface->wWidth)  ||
            (bottom > (LONG) peSurface->wHeight))
        {
            if (!(left == 0 && right == 0 && 
                 (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) &&
                 (peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED)))
            {
                bHasRect = FALSE;
            }
        }

        if ((peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME) &&
            (LockData.dwFlags & DDLOCK_HASVOLUMETEXTUREBOXRECT))
        {
            if ((front >= back) ||
                (front < 0)     ||
                (back  > SurfaceDepth))
            {
                bHasRect = FALSE;
            }
        }
    }

    if (!bHasRect)
    {
        // Lock entire surface. (all depth if volume).

        LockData.rArea.left   = 0;
        LockData.rArea.top    = 0;
        LockData.rArea.right  = peSurface->wWidth;
        LockData.rArea.bottom = peSurface->wHeight;

        // Mask off DDLOCK_HASVOLUMETEXTUREBOXRECT.

        LockData.dwFlags &= ~DDLOCK_HASVOLUMETEXTUREBOXRECT;
    }
    else
    {
        LockData.rArea = *pArea;
    }

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        // AGP surfaces don't need fpProcess:

        LockData.fpProcess = 0;
    }
    else
    {
        if (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER)
        {
            // If this surface currently lives in different driver,
            // don't do video memory mapping to usermode address.
            // Driver should be able to lock surface without this.
            // Unless otherwise, driver should fail in Lock.

            LockData.fpProcess = 0;
        }
        else
        { 
            // Map the memory into the application's address space if that
            // hasn't already been done:

            if (!(peDirectDrawLocal->fl & DD_LOCAL_FLAG_MEMORY_MAPPED))
            {
                vDdMapMemory(peDirectDrawLocal, &LockData.ddRVal);
            }

            // Only proceed if we were successful in mapping the memory:

            if (!(peDirectDrawLocal->fl & DD_LOCAL_FLAG_MEMORY_MAPPED))
            {
                goto Exit;
            }

            LockData.fpProcess = peDirectDrawLocal->fpProcess;
        }
    }

    // If the surface is driver managed, we don't want to create any aliases
    // so we reset the NOSYSLOCK flag:

    if ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
        !(peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
    {
        dwFlags &= ~DDLOCK_NOSYSLOCK;
    }

    // We allow only one "aliased" lock at any time. Thus if there already
    // exists an aliased lock (peMap !=NULL) then we fail all other requests
    // for locks. Also if there are already non aliased locks then we fail
    // any requests for aliased locks.
    // All this restrictions are put in due to the fact that we do not keep
    // track of access rects for each surface in the kernel. If we did, we
    // would just store a peMap pointer per access rect and not require these
    // checks.

    if ((peSurface->peMap || 
        (peSurface->fl & DD_SURFACE_FLAG_FAKE_ALIAS_LOCK)) ||
        (peSurface->cLocks && (dwFlags & DDLOCK_NOSYSLOCK)))
    {
        WARNING("pDdLockSurfaceOrBuffer: Failing lock since we cannot have more than one aliased lock");
        LockData.ddRVal = DDERR_SURFACEBUSY;
        goto Exit;
    }

    // If the VisRgn has changed since the application last queried
    // it, fail the call with a unique error code so that they know
    // to requery the VisRgn and try again.  We do this only if we
    // haven't been asked to wait (we assume 'bWait' is equivalent
    // to 'bInternal').

    if (!(dwFlags & DDLOCK_WAIT) &&
        (peSurface->fl & DD_SURFACE_FLAG_PRIMARY) &&
        (peSurface->iVisRgnUniqueness != VISRGN_UNIQUENESS()))
    {
        LockData.ddRVal = DDERR_VISRGNCHANGED;
        goto Exit;
    }

    dwTmp = DDHAL_DRIVER_NOTHANDLED;

    // Pick the appropriate lock function.

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
    {
        pfnLock = peDdGlobalDriver->D3dBufCallbacks.LockD3DBuffer;
    }
    else
    {
        if (peDdGlobalDriver->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_LOCK)
        {
            pfnLock = peDdGlobalDriver->SurfaceCallBacks.Lock;
        }
        else
        {
            pfnLock = NULL;
        }
    }

    if (pfnLock != NULL)
    {
        do
        {
            dwTmp = pfnLock(&LockData);
        } while ((dwFlags & DDLOCK_WAIT) &&
                 (dwTmp == DDHAL_DRIVER_HANDLED) &&
                 (LockData.ddRVal == DDERR_WASSTILLDRAWING));
    }

    if ((dwTmp == DDHAL_DRIVER_NOTHANDLED) ||
        (LockData.ddRVal == DD_OK))
    {
        // We successfully did the lock!
        //
        // If this is the primary surface and no window has been
        // associated with the surface via DdResetVisRgn, then
        // we have to force a redraw at Unlock time if any
        // VisRgn has changed since the first Lock.
        //
        // If there is a window associated with the surface, then
        // we have already checked that peSurface->iVisRgnUniqueness
        // == po.iVisRgnUniqueness().

        if (peSurface->cLocks++ == 0)
        {
            // If the surface is driver managed, we don't bother to
            // increment the global lock count since we don't want to break
            // locks when "losing" surfaces.

            if (!(peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) ||
                ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
                 (peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST)))
            {
                peDdGlobalDriver->cSurfaceLocks++;
            }

            peSurface->iVisRgnUniqueness = VISRGN_UNIQUENESS();
        }
        else
        {
            if (peSurface->rclLock.left   < LockData.rArea.left)
                LockData.rArea.left   = peSurface->rclLock.left;

            if (peSurface->rclLock.top    < LockData.rArea.top)
                LockData.rArea.top    = peSurface->rclLock.top;

            if (peSurface->rclLock.right  > LockData.rArea.right)
                LockData.rArea.right  = peSurface->rclLock.right;

            if (peSurface->rclLock.bottom > LockData.rArea.bottom)
                LockData.rArea.bottom = peSurface->rclLock.bottom;
        }

        // If this is the primary surface, then union the current DirectDraw
        // bounds rectangle with the lock area rectangle.

        if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
        {
            if (peDdGlobalDriver->fl & DD_GLOBAL_FLAG_BOUNDS_SET)
            {
                if (LockData.rArea.left < peDdGlobalDriver->rclBounds.left)
                    peDdGlobalDriver->rclBounds.left = LockData.rArea.left;

                if (LockData.rArea.top < peDdGlobalDriver->rclBounds.top)
                    peDdGlobalDriver->rclBounds.top = LockData.rArea.top;

                if (LockData.rArea.right > peDdGlobalDriver->rclBounds.right)
                    peDdGlobalDriver->rclBounds.right = LockData.rArea.right;

                if (LockData.rArea.bottom > peDdGlobalDriver->rclBounds.bottom)
                    peDdGlobalDriver->rclBounds.bottom = LockData.rArea.bottom;
            }
            else
            {
                peDdGlobalDriver->rclBounds = LockData.rArea;
                peDdGlobalDriver->fl |= DD_GLOBAL_FLAG_BOUNDS_SET;
            }
        }

        // If there was a flip pending, then there is not now.

        if (peSurface->fl & DD_SURFACE_FLAG_FLIP_PENDING)
        {
            peSurface->fl &= ~DD_SURFACE_FLAG_FLIP_PENDING;
        }

        // Stash away surface lock data:

        peSurface->rclLock = LockData.rArea;

        if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
        {
            if (peSurface->cLocks == 1)
            {
                // Add this surface to the head of the locked list:

                peSurface->peSurface_PrimaryLockNext
                    = peDdGlobalDriver->peSurface_PrimaryLockList;
                peDdGlobalDriver->peSurface_PrimaryLockList
                    = peSurface;
            }

            // If this is the primary surface, tear down any
            // sprites that intersect with the specified
            // rectangle:
    
            if (DxEngSpTearDownSprites(peDdGlobalDriver->hdev,
                       &LockData.rArea,
                       TRUE))
            {
                // Here's some weirdness for you.  That sprite
                // tear-down we just did may have involved
                // accelerator operations, which means the
                // accelerator may be still in use if we
                // immediately returned to the application,
                // which of course is bad.
                //
                // You might think that a fix to this would
                // be to put the sprite tear-down *before*
                // the call to the driver's DdLock routine.
                // But then you get the problem that DdLock
                // would *always* return DDERR_WASSTILLDRAWING,
                // and we would have to re-draw the sprites,
                // meaning that the application would get into
                // an endless loop if it was itself (like all
                // of DirectDraw's HAL code) looping on
                // DDERR_WASSTILLDRAWING.
                //
                // To solve this problem, we'll simply wait for
                // accelerator idle after tearing-down the
                // sprite.  We do this by calling DdLock/DdUnlock
                // again:

                if (peDdGlobalDriver->SurfaceCallBacks.dwFlags
                    & DDHAL_SURFCB32_LOCK)
                {
                    do
                    {
                        dwRedraw = peDdGlobalDriver->
                               SurfaceCallBacks.Lock(&LockData);
                    } while ((dwRedraw == DDHAL_DRIVER_HANDLED) &&
                          (LockData.ddRVal == DDERR_WASSTILLDRAWING));
                }
        
                if (peDdGlobalDriver->SurfaceCallBacks.dwFlags
                     & DDHAL_SURFCB32_UNLOCK)
                {
                    UnlockData.lpDD        = peDdGlobalDriver;
                    UnlockData.lpDDSurface = peSurface;
        
                    peDdGlobalDriver->
                    SurfaceCallBacks.Unlock(&UnlockData);
                }
            }
        }

        LockData.ddRVal = DD_OK;

        if (dwTmp == DDHAL_DRIVER_HANDLED)
        {
            // If it says it handled the call, the driver is
            // expected to have computed the address in the
            // client's address space:

            pvRet = (VOID*) LockData.lpSurfData;

            ASSERTGDI(pvRet != NULL,
                      "Expected non-NULL lock pointer value (DRIVER_HANDLED)");
            ASSERTGDI(pvRet < (PVOID) MM_USER_PROBE_ADDRESS,
                      "Expected user-mode lock pointer value (DRIVER_HANDLED)");
        }
        else
        {
            if (peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                pvRet = (VOID*)peSurface->fpVidMem;
            }
            else
            {
                pvRet = (VOID*) (peDirectDrawLocal->fpProcess
                                 + peSurface->fpVidMem);
            }

            ASSERTGDI(pvRet != NULL,
                      "Expected non-NULL lock pointer value (DRIVER_NOT_HANDLED)");
            ASSERTGDI(pvRet < (PVOID) MM_USER_PROBE_ADDRESS,
                      "Expected user-mode lock pointer value (DRIVER_NOT_HANDLED)");

            // DirectDraw has a goofy convention that when a
            // driver returns DD_OK and DDHAL_DRIVER_HANDLED
            // from a Lock, that the driver is also supposed to
            // adjust the pointer to point to the upper left
            // corner of the specified rectangle.
            //
            // This doesn't make a heck of a lot of sense for
            // odd formats such as YUV surfaces, but oh well --
            // since kernel-mode is acting like a driver to
            // user-mode DirectDraw, we have to do the adjustment:

            if (bHasRect)
            {
                pvRet = (VOID*)
                    ((BYTE*) pvRet
                     + (pArea->top * peSurface->lPitch)
                     + (pArea->left
                        * (peSurface->ddpfSurface.dwRGBBitCount >> 3)));
            }
        }

        // If this was an "aliased" lock, we store the corresponding pointer
        // to the EDD_VMEMMAPPING
        if (dwFlags & DDLOCK_NOSYSLOCK)
        {
            if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM))
            {
                peSurface->peMap = peDirectDrawLocal->peMapCurrent;

                ASSERTGDI(peSurface->peMap != NULL,
                    "Expected video memory to be mapped into user space");
            }
            else
            {
                // If the non-local surface was not allocated from one of
                // our managed heaps, then lpVidMemHeap will be NULL and
                // we cannot alias the heap, so we don't do the aliased
                // lock.

                if (peSurface->lpVidMemHeap != NULL)
                {
                    peSurface->peMap = peDirectDrawLocal->ppeMapAgp[
                        (peSurface->lpVidMemHeap -
                        peDdGlobalDriver->pvmList)];
                }
            }

            // If the map pointer is NULL, then the surface lock cannot be
            // aliased so proceed as if DDLOCK_NOSYSLOCK was not passed.
            // Otherwise, take the appropriate reference counts now:

            if (peSurface->peMap != NULL)
            {
                peSurface->fl |= DD_SURFACE_FLAG_ALIAS_LOCK; 
                peDdGlobalDriver->cSurfaceAliasedLocks++;
                peSurface->peMap->cReferences++;
                // Keep a reference of the driver instance used to create this mapping
                peSurface->peVirtualMapDdGlobal = peDdGlobalDriver;
                vDdIncrementReferenceCount(peDdGlobalDriver);
                DDKHEAP(("Taken aliased lock: peSurface=%lx, peMap=%lx, "
                        "peDdGlobalDriver=%lx\n",
                        peSurface, peSurface->peMap, peDdGlobalDriver));
            }
            else
            {
                // We have a private driver cap that will enable us to treat
                // AGP surface locks as aliased even though the driver doesn't
                // expose an AGP heap.  This is to enable drivers to work around
                // anything that we happen to do wrong in our AGP code without
                // them incurring the 7 second tiemout on every mode change.

                if ((peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
                    (peDdGlobalDriver->PrivateCaps.dwPrivateCaps & DDHAL_PRIVATECAP_RESERVED1))

                {
                    peSurface->fl |= DD_SURFACE_FLAG_ALIAS_LOCK; 
                    peDdGlobalDriver->cSurfaceAliasedLocks++;
                    peSurface->fl |= DD_SURFACE_FLAG_FAKE_ALIAS_LOCK;
                }

                // Just to avoid possible problems in the future, turn
                // off the flag here:

                dwFlags &= ~DDLOCK_NOSYSLOCK;
            }
        }
    }
    else
    {
        if (LockData.ddRVal != DDERR_WASSTILLDRAWING)
        {
            WARNING("pDdLockSurface: Driver failed DdLock\n");
        }
    }

 Exit:
    if (pResult)
    {
        *pResult = LockData.ddRVal;
    }

    return(pvRet);
}

/******************************Public*Routine******************************\
* BOOL bDdUnlockSurfaceOrBuffer
*
* DirectDraw unlock for surfaces and D3D buffers.
*
* Note that the Devlock MUST NOT be held when entering this function
* if the surface is the primary surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdUnlockSurfaceOrBuffer(
    EDD_SURFACE* peSurface
    )
{
    BOOL                    b;
    BOOL                    bRedraw;
    BOOL                    bFreeVirtualMap = FALSE;
    EDD_DIRECTDRAW_GLOBAL  *peDdGlobalDriver;

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
    {
        return(TRUE);
    }

    peSurface->fl &= ~DD_SURFACE_FLAG_ALIAS_LOCK; 
    b = FALSE;
    bRedraw = FALSE;

    {
        // Don't hold ShareLock togather (see vDdDisableAllDirectDrawObjects)
        // Give a change to signal AssertMode event.

        EDD_DEVLOCK eDevlock(peSurface->peDirectDrawGlobal);

        // Due to video mode change across different video driver, currently
        // this "driver managed" surface is associated to different driver
        // than the driver who actually manage it. So we must call the driver
        // which actually manage the surface.
        //
        // peSurface->fl can be changed by mode change, thus we access there
        // under holding devlock.

        if (peSurface->fl & DD_SURFACE_FLAG_WRONG_DRIVER)
        {
            // If surface is owned by different driver, lock right driver.

            if (peSurface->peDirectDrawGlobal != peSurface->peDdGlobalCreator)
            {
                // Unlike DdLockSurfaceOrBuffer case, we can't just unlock and
                // lock with new device. Because, we can't hold sharelock (see above)
                // so when we unlock device, there is a chance to mode change happens.
                // thus, after we relock the device, we have to make sure peDdGlobalCreator
                // is continue to be save as before. Otherwise loop until it match.

                do {
                    peDdGlobalDriver = peSurface->peDdGlobalCreator;
                    eDevlock.vUnlockDevice();
                    eDevlock.vUpdateDevice(peDdGlobalDriver);
                    eDevlock.vLockDevice();
                } while (peDdGlobalDriver !=
                         ((EDD_DIRECTDRAW_GLOBAL volatile *)(peSurface->peDdGlobalCreator)));

                // WARNING("pDdLockSurfaceOrBuffer: Unlock on wrong driver");
            }
        }
        else
        {
            peDdGlobalDriver = peSurface->peDirectDrawGlobal;
        }

        // Make sure there was a previous lock:

        if (peSurface->cLocks > 0)
        {
            if ((peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
                !(peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_DONOTPERSIST))
            {
                // Driver managed surface can be unlock ANYTIME.
                // (even PDEV is disabled)
            }
            else
            {
                PDEVOBJ po(peDdGlobalDriver->hdev);

                ASSERTGDI(!po.bDisabled(),
                         "Surface is disabled but there are outstanding locks?");
            }

            vDdRelinquishSurfaceOrBufferLock(peDdGlobalDriver, peSurface);

            // Does lock went to 0 after "Relinquish" ?

            if (peSurface->cLocks == 0)
            {
                // Was this an aliased lock ?

                if (peSurface->peMap)
                {
                    bFreeVirtualMap = TRUE;
                }

                // If the API-disabled flag is set and we got this far into
                // Unlock, it means that there is a DdSuspendDirectDraw()
                // call pending, and that thread is waiting for all surface
                // locks related to the device to be released.
                //
                // If this is the last lock to be released, signal the event
                // so that the AssertMode thread can continue on.

                if ((peDdGlobalDriver->cSurfaceLocks == 0) &&
                    (peDdGlobalDriver->bSuspended))
                {
                    KeSetEvent(peDdGlobalDriver->pAssertModeEvent,
                               0,
                               FALSE);
                }

                // NOTE: This should really test if the surface has a clipper. But
                //       it can't because of comapatibility with Win95, where
                //       applications expect a primary surface lock to be atomic
                //       even if they haven't attached a clipper object.
                //       (Microsoft's own OPENGL32.DLL does this, that shipped
                //       in NT 5.0.)  However, this means that applications
                //       that are full-screen double buffering can possibly
                //       be causing a whole bunch of repaints when it does a
                //       direct lock on (what is now) the back buffer.
                //
                //       Potentially, this 'if' should have an additional
                //       condition, and that is not to do it if the application
                //       is in exclusive mode:

                if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
                {
                    // If the VisRgn changed while the application was writing
                    // to the surface, it may have started drawing over the
                    // the wrong window, so fix it up.
                    //
                    // Alas, right now a DirectDraw application doesn't always
                    // tell us what window it was drawing to, so we can't fix
                    // up only the affected windows.  Instead, we solve it the
                    // brute-force way and redraw *all* windows:

                    if (peSurface->iVisRgnUniqueness != VISRGN_UNIQUENESS())
                    {
                        // We can't call UserRedrawDesktop here because it
                        // grabs the User critical section, and we're already
                        // holding the devlock -- which could cause a possible
                        // deadlock.  Since it's a posted message it obviously
                        // doesn't have to be done under the devlock.

                        bRedraw = TRUE;

                        // Note that we should not update peSurface->
                        // iVisRgnUniqueness here.  That's because if the
                        // application has attached a window to the surface, it
                        // has to be notified that the clipping has changed --
                        // which is done by returning DDERR_VISRGNCHANGED on the
                        // next Lock or Blt call.  And if the application has
                        // not attached a window, we automatically update the
                        // uniqueness at the next Lock time.
                    }
                }
            }

            b = TRUE;
        }
        else // if (peSurface->cLocks == 0)
        {
            // The lock count is 0 but we may have a "broken" lock.
            if (peSurface->peMap)
            {
                bFreeVirtualMap = TRUE;
            }
            else
            {
                WARNING("bDdUnlockSurfaceOrBuffer: Surface already unlocked\n");
            }
        }
    }

    if (bRedraw)
    {
        PDEVOBJ po(peDdGlobalDriver->hdev);

        // We can redraw only if we're not holding the devlock, because
        // User needs to acquire its critical section.  The User lock
        // must always be acquired before the devlock, which is why
        // we can't call User if we're already holding the devlock.
        //
        // I don't trust any callers enough to merely assert that we're
        // not holding the devlock; I'll actually check...

        if (!DxEngIsHdevLockedByCurrentThread(po.hdev()))
        {
            DxEngRedrawDesktop();
        }
    }

    if (bFreeVirtualMap)
    {
        // We can release virtual map if we're not holding the devlock,
        // because it might release GDI's PDEV if this is last reference.

        vDdReleaseVirtualMap(peSurface);
    }

    return(b);
}

/******************************Public*Routine******************************\
* HANDLE DxDdCreateDirectDrawObject
*
* Creates a DirectDraw object.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDdCreateDirectDrawObject(
    HDC     hdc
    )
{
    HANDLE  hDirectDrawLocal;

    hDirectDrawLocal = 0;       // Assume failure

    PVOID pvLockedDC = DxEngLockDC(hdc);

    if (pvLockedDC)
    {
        PDEVOBJ po((HDEV)DxEngGetDCState(hdc,DCSTATE_HDEV));

        if (po.bValid() && po.bDisplayPDEV())
        {
            // Note that we aren't checking to see if the PDEV is disabled,
            // so that DirectDraw could be started even when full-screen:

            EDD_DEVLOCK eDevlock(po.hdev());

            if (!(po.bDisabled()))
            {
                CheckAgpHeaps(po.peDirectDrawGlobal());
            }

            // DirectDraw works only at 8bpp or higher:

            if (po.iDitherFormat() >= BMF_8BPP)
            {
                hDirectDrawLocal = hDdCreateDirectDrawLocal(po);
            }
        }

        DxEngUnlockDC(pvLockedDC);
    }
    else
    {
        WARNING("DxDdCreateDirectDrawObject: Bad DC\n");
    }

    return(hDirectDrawLocal);
}

/******************************Public*Routine******************************\
* BOOL DxDdDeleteDirectDrawObject
*
* Deletes a kernel-mode representation of the surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdDeleteDirectDrawObject(
    HANDLE  hDirectDrawLocal
    )
{
    return(bDdDeleteDirectDrawObject(hDirectDrawLocal, FALSE));
}

/******************************Public*Routine******************************\
* HANDLE DxDdQueryDirectDrawObject
*
* Queries a DirectDraw object.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdQueryDirectDrawObject(
    HANDLE                      hDirectDrawLocal,
    DD_HALINFO*                 pHalInfo,
    DWORD*                      pCallBackFlags,
    LPD3DNTHAL_CALLBACKS        puD3dCallbacks,
    LPD3DNTHAL_GLOBALDRIVERDATA puD3dDriverData,
    PDD_D3DBUFCALLBACKS         puD3dBufferCallbacks,
    LPDDSURFACEDESC             puD3dTextureFormats,
    DWORD*                      puNumHeaps,
    VIDEOMEMORY*                puvmList,
    DWORD*                      puNumFourCC,
    DWORD*                      puFourCC
    )
{
    BOOL                    b;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    ULONG                   cBytes;

    b = FALSE;              // Assume failure

    // The most fundamental basis of accelerated DirectDraw is that it
    // allows direct access to the frame buffer by the application.  If
    // security permissions prohibit reading from the screen, we cannot
    // allow accelerated DirectDraw:

    if (DxEngScreenAccessCheck())
    {
        peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDrawLocal);
        if (peDirectDrawLocal != NULL)
        {
            peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            // A registry timeout value of 'zero' signifies that DirectDraw
            // accelerations cannot be enabled.  Note that the timeout is
            // non-positive because it's a relative time duration.

            if (peDirectDrawGlobal->llAssertModeTimeout < 0)
            {
                DWORD   dwOverride;
                PDEVOBJ po(peDirectDrawGlobal->hdev);
    
                // Get driver override info:

                dwOverride = po.dwDriverCapableOverride();

                __try
                {
                    DD_HALINFO ddhi = peDirectDrawGlobal->HalInfo;

                    if ( dwOverride & DRIVER_NOT_CAPABLE_D3D )
                    {
                        // If the driver is not capable of doing D3D, turn the CAPS
                        // off

                        ddhi.ddCaps.dwCaps &= ~DDCAPS_3D;
                        ddhi.lpD3DGlobalDriverData = 0;
                        ddhi.lpD3DHALCallbacks = 0;
                    }

#ifdef DX_REDIRECTION
                    if ( gbDxRedirection )
                    {
                        // If we are in redirection mode, disable overlay.

                        ddhi.ddCaps.dwCaps &= ~DDCAPS_OVERLAY;
                        ddhi.ddCaps.dwMaxVisibleOverlays = 0;
                    }
#endif // DX_REDIRECTION

                    ProbeAndWriteStructure(pHalInfo,
                                           ddhi,
                                           DD_HALINFO);

                    ProbeForWrite(pCallBackFlags, 3 * sizeof(ULONG), sizeof(ULONG));
                    pCallBackFlags[0] = peDirectDrawGlobal->CallBacks.dwFlags;
                    pCallBackFlags[1] = peDirectDrawGlobal->SurfaceCallBacks.dwFlags;
                    pCallBackFlags[2] = peDirectDrawGlobal->PaletteCallBacks.dwFlags;

                    if (puD3dCallbacks != NULL)
                    {
                        ProbeAndWriteStructure(puD3dCallbacks,
                                               peDirectDrawGlobal->D3dCallBacks,
                                               D3DNTHAL_CALLBACKS);
                    }

                    if (puD3dDriverData != NULL)
                    {
                        ProbeAndWriteStructure(puD3dDriverData,
                                               peDirectDrawGlobal->D3dDriverData,
                                               D3DNTHAL_GLOBALDRIVERDATA);
                    }

                    if (puD3dBufferCallbacks != NULL)
                    {
                        ProbeAndWriteStructure(puD3dBufferCallbacks,
                                               peDirectDrawGlobal->D3dBufCallbacks,
                                               DD_D3DBUFCALLBACKS);
                    }

                    if (puD3dTextureFormats != NULL)
                    {
                        ProbeForWrite(puD3dTextureFormats,
                                      peDirectDrawGlobal->D3dDriverData.dwNumTextureFormats*
                                      sizeof(DDSURFACEDESC), sizeof(DWORD));
                        RtlCopyMemory(puD3dTextureFormats,
                                      peDirectDrawGlobal->D3dDriverData.lpTextureFormats,
                                      peDirectDrawGlobal->D3dDriverData.dwNumTextureFormats*
                                      sizeof(DDSURFACEDESC));
                    }

                    ProbeAndWriteUlong(puNumFourCC, peDirectDrawGlobal->dwNumFourCC);

                    // Offscreen heap allocations are handled directly
                    // in the kernel so don't report any memory back to
                    // user mode.

                    ProbeAndWriteUlong(puNumHeaps, 0);

                    if (puFourCC != NULL)
                    {
                        cBytes = sizeof(ULONG) * peDirectDrawGlobal->dwNumFourCC;

                        ProbeForWrite(puFourCC, cBytes, sizeof(ULONG));
                        RtlCopyMemory(puFourCC, peDirectDrawGlobal->pdwFourCC, cBytes);
                    }

                    b = TRUE;
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    WARNING("DxDdQueryDirectDrawObject: Passed bad pointers\n");
                }
            }
            else
            {
                WARNING("DxDdQueryDirectDrawObject: DirectDraw disabled in registry\n");
            }
        }
        else
        {
            WARNING("DxDdQueryDirectDrawObject: Bad handle or busy\n");
        }
    }
    else
    {
        WARNING("DxDdCreateDirectDrawObject: Don't have screen read permission");
    }

    return(b);
}

/******************************Public*Routine******************************\
* EDD_SURFACE* peDdOpenNewSurfaceObject
*
* Creates a new kernel-mode surface by re-using the old surface if it's
* lost, or by allocating a new surface.
*
* NOTE: Leaves the surface exclusive locked!
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EDD_SURFACE*
peDdOpenNewSurfaceObject(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    HANDLE                  hSurface,
    DD_SURFACE_GLOBAL*      pSurfaceGlobal,
    DD_SURFACE_LOCAL*       pSurfaceLocal,
    DD_SURFACE_MORE*        pSurfaceMore
    )
{
    EDD_SURFACE* peSurface;

    BOOL         bSurfaceAlloced = FALSE;

    // First, try to resurrect the old surface if there is one:

    peSurface = NULL;
    if (hSurface != 0)
    {
        peSurface = (EDD_SURFACE*) DdHmgLock((HDD_OBJ) hSurface, DD_SURFACE_TYPE, FALSE);
        if (peSurface == NULL)
        {
            WARNING("peDdOpenNewSurfaceObject: hDDSurface wasn't set to 0\n");
        }
        else if ((peSurface->peDirectDrawLocal != peDirectDrawLocal) ||
                 (!(peSurface->bLost)))
        {
            WARNING("peDdOpenNewSurfaceObject: Couldn't re-use surface\n");
            DEC_EXCLUSIVE_REF_CNT(peSurface);
            peSurface = NULL;
            return(peSurface);
        }

#if DBG
        if (peSurface != NULL)
        {
            DDKSURF(("DDKSURF: Reusing %X (%X)\n", hSurface, peSurface));
        }
#endif
    }

    if (peSurface == NULL)
    {
        peSurface = (EDD_SURFACE*) DdHmgAlloc(sizeof(EDD_SURFACE),
                                              DD_SURFACE_TYPE,
                                              HMGR_ALLOC_LOCK);
        if (peSurface != NULL)
        {
            bSurfaceAlloced = TRUE;

            // Win95's DirectDraw makes a number of allocations that represent
            // a single surface, and have pointers between the different
            // parts.  We make just one allocation and so the pointers refer
            // back to ourselves.  Note that the power of C++ means that
            // 'lpGbl = peSurface' assigns 'lpGbl' the address to the
            // DD_SURFACE_GLOBAL part of 'peSurface':

            peSurface->lpGbl              = peSurface;
            peSurface->lpSurfMore         = peSurface;
            peSurface->lpLcl              = peSurface;

            peSurface->peDirectDrawLocal  = peDirectDrawLocal;
            peSurface->peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

            // Remember original creator of this surface (in case for video mode change).

            PDEVOBJ po(peSurface->peDirectDrawGlobal->hdev);

            // and remember which graphics device has association.
            peSurface->pldevCreator           = po.pldev();
            peSurface->pGraphicsDeviceCreator = po.pGraphicsDevice();

            // No locks yet
            peSurface->peMap = NULL;

            // This is new surface, so it keeps lost state initially.
            // The surface will be marked as lost until 'vDdCompleteSurfaceObject'
            // is called on it:

            peSurface->bLost = TRUE;

            DDKSURF(("DDKSURF: Created %X (%X)\n", peSurface->hGet(), peSurface));
        }
    }

    if ((peSurface != NULL) &&
        !(peSurface->fl & DD_SURFACE_FLAG_CREATE_COMPLETE))
    {
        // We do this under try ~ except, because pSurfaceGlobal/Local/More
        // could be user mode buffer.

        __try
        {
            peSurface->fpVidMem        = pSurfaceGlobal->fpVidMem;
            peSurface->lPitch          = pSurfaceGlobal->lPitch;
            peSurface->wWidth          = pSurfaceGlobal->wWidth;
            peSurface->wHeight         = pSurfaceGlobal->wHeight;
            peSurface->wWidthOriginal  = pSurfaceGlobal->wWidth;
            peSurface->wHeightOriginal = pSurfaceGlobal->wHeight;
            peSurface->ddpfSurface     = pSurfaceGlobal->ddpfSurface;
            peSurface->ddsCaps         = pSurfaceLocal->ddsCaps;
            // Copy just the driver managed flag
            peSurface->dwFlags        &= ~DDRAWISURF_DRIVERMANAGED;
            peSurface->dwFlags        |= (pSurfaceLocal->dwFlags & DDRAWISURF_DRIVERMANAGED);
            peSurface->ddsCapsEx       = pSurfaceMore->ddsCapsEx;
            peSurface->dwSurfaceHandle = pSurfaceMore->dwSurfaceHandle;
            // Copy the slice pitch for sysmem volume textures
            if ((peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                (peSurface->ddsCapsEx.dwCaps2 & DDSCAPS2_VOLUME))
            {
                peSurface->dwBlockSizeY = pSurfaceGlobal->dwBlockSizeY;
            }

            if (!(peSurface->bLost))
            {
                peSurface->bLost = TRUE;

                // Surface wasn't losted formerly, but here we put null to make it lost forcely.
                // This might causes some leak in driver, but anyway we should decrement
                // active surface count here.

                ASSERTGDI(peSurface->peDirectDrawLocal->cActiveSurface > 0,
                          "cActiveSurface will be negative");

                peSurface->peDirectDrawLocal->cActiveSurface--;
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            if (bSurfaceAlloced)
            {
                DdFreeObject(peSurface, DD_SURFACE_TYPE);
            }
            else
            {
                DEC_EXCLUSIVE_REF_CNT(peSurface);
            }

            peSurface = NULL;
        }
    }

    // if everything went fine, and this is newly allocated surface ...

    if (peSurface && bSurfaceAlloced)
    {
        // Add this to the head of the surface list hanging off the
        // local DirectDraw object.
        //
        // This list is protected because we have exclusive access to
        // the local DirectDraw object:

        InsertHeadList(&(peDirectDrawLocal->ListHead_eSurface),
                       &(peSurface->List_eSurface));

        peDirectDrawLocal->cSurface++;
    }

    return(peSurface);
}

/******************************Public*Routine******************************\
* BOOL bDdValidateSurfaceDescription
*
* Validates surface description information.
* Can be used before surface actually exists to validate data
* prior to creation.
*
*  6-Feb-1998 -by- Drew Bliss [drewb]
* Split from bDdValidateSurfaceObject.
\**************************************************************************/

BOOL
bDdValidateSurfaceDescription(
    DD_SURFACE_GLOBAL* pSurfaceGlobal,
    DD_SURFACE_LOCAL*  pSurfaceLocal
    )
{
    // Protect against math overflow:

    if (!(pSurfaceLocal->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        if ((pSurfaceGlobal->wWidth > DD_MAXIMUM_COORDINATE)  ||
            (pSurfaceGlobal->wWidth <= 0)                     ||
            (pSurfaceGlobal->wHeight > DD_MAXIMUM_COORDINATE) ||
            (pSurfaceGlobal->wHeight <= 0))
        {
            WARNING("bDdValidateSurfaceDescription: Bad dimensions");
            return(FALSE);
        }

        // dwRGBBitCount is overloaded with dwYUVBitCount:

        if ((pSurfaceGlobal->ddpfSurface.dwRGBBitCount < 1) &&
            !(pSurfaceGlobal->ddpfSurface.dwFlags & DDPF_FOURCC))
        {
            WARNING("bDdValidateSurfaceDescription: Bad bit count");
            return(FALSE);
        }

        if (pSurfaceGlobal->ddpfSurface.dwFlags & DDPF_RGB)
        {
            if ((pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 1)  &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 2)  &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 4)  &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 8)  &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 16) &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 24) &&
                (pSurfaceGlobal->ddpfSurface.dwRGBBitCount != 32))
            {
                WARNING("bDdValidateSurfaceDescription: "
                        "dwRGBBitCount not 1, 2, 4, 8, 16, 24 or 32");
                return(FALSE);
            }
        }
    }

    return(TRUE);
}
/******************************Public*Routine******************************\
* BOOL bDdValidateSystemMemoryObject
*
* Checks surface description and parameters for an existing
* system-memory surface.
*
* Checks suitable for pre-creation testing should be in
* bDdValidateSurfaceDescription.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdValidateSystemMemoryObject(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface
    )
{
    if (!bDdValidateSurfaceDescription(peSurface, peSurface))
    {
        return FALSE;
    }

    if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        if (ABS(peSurface->lPitch) > 4 * DD_MAXIMUM_COORDINATE)
        {
            WARNING("bDdValidateSurfaceObject: Bad dimensions");
            return(FALSE);
        }

        // The width in bytes must not be more than the pitch.

        if (peSurface->wWidth * peSurface->ddpfSurface.dwRGBBitCount >
            (ULONG) 8 * ABS(peSurface->lPitch))
        {
            WARNING("bDdValidateSurfaceObject: Bad pitch");
            return(FALSE);
        }
    }

    if ((peSurface->fpVidMem & 3) || (peSurface->lPitch & 3))
    {
        WARNING("bDdValidateSurfaceObject: Bad alignment");
        return(FALSE);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bDdSecureSystemMemorySurface
*
* For system-memory surfaces, the user-mode DirectDraw component allocates
* the actual bits for storage.  Since we will need to access those bits
* from kernel mode for the duration of the life of the surface, we must
* ensure that they're valid user-mode bits and that the pages will never
* be decommitted until the kernel-mode surface is destroyed.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdSecureSystemMemorySurface(
    EDD_SURFACE*    peSurface
    )
{
    FLATPTR fpStart;
    FLATPTR fpEnd;
    DWORD dwHeight;

    // Note that bDdValidateSurfaceObject has already ensured that
    // lPitch, fpVidMem, and the dimensions are "reasonable".

    if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
    {
        dwHeight = peSurface->wHeight;
    }
    else
    {
        dwHeight = 1;
    }


    if (peSurface->lPitch >= 0)
    {
        fpStart = peSurface->fpVidMem;
        fpEnd   = fpStart + dwHeight * peSurface->lPitch;
    }
    else
    {
        fpEnd   = peSurface->fpVidMem - peSurface->lPitch;
        fpStart = fpEnd + dwHeight * peSurface->lPitch;
    }


    ASSERTGDI(fpEnd >= fpStart, "Messed up fpStart and fpEnd");

    __try
    {
        ProbeForWrite((VOID*) fpStart, (ULONG)(ULONG_PTR)((BYTE*)fpEnd - (BYTE*)fpStart),
            sizeof(DWORD));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("bDdSecureSystemMemorySurface: fpVidMem wasn't valid and writable");
        return(FALSE);
    }

    peSurface->hSecure = MmSecureVirtualMemory((VOID*) fpStart,
                                               fpEnd - fpStart,
                                               PAGE_READWRITE);

    return(peSurface->hSecure != 0);
}

/******************************Public*Routine******************************\
* VOID vDdCompleteSurfaceObject
*
* Add the object to the surface list and initialize some miscellaneous
* fields.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
vDdCompleteSurfaceObject(
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal,
    EDD_SURFACE*            peSurface
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    FLATPTR                 fpStartOffset;
    LONG                    lDisplayPitch;
    DWORD                   dwDepth;
    DWORD                   dwBitsPixel;

    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    // Calculate the 2-d coordinate 'hint' for 2-d cards so that
    // hopefully they don't need to do these three divides each
    // time they need to use the surface:

    if (peSurface->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM)
    {
        dwBitsPixel = peSurface->ddpfSurface.dwRGBBitCount;

        if ((dwBitsPixel > 0) && (peSurface->lpVidMemHeap != NULL))
        {
            fpStartOffset =
                peSurface->fpHeapOffset - peSurface->lpVidMemHeap->fpStart;

            if (peSurface->lpVidMemHeap->dwFlags & VMEMHEAP_RECTANGULAR)
            {
                lDisplayPitch = peSurface->lpVidMemHeap->lpHeap->stride;
            }
            else
            {
                lDisplayPitch = 1;
            }
        }
        else
        {
            fpStartOffset = 0;
            lDisplayPitch = 1;
            dwBitsPixel = 1;
        }
    }
    else
    {
        fpStartOffset  = peSurface->fpVidMem
            - peDirectDrawGlobal->HalInfo.vmiData.fpPrimary;
        lDisplayPitch  = peDirectDrawGlobal->HalInfo.vmiData.lDisplayPitch;
        dwBitsPixel =
            peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount;
    }

    peSurface->yHint = (LONG) (fpStartOffset / lDisplayPitch);
    peSurface->xHint =
        (LONG) (8 * (fpStartOffset % lDisplayPitch) / dwBitsPixel);

    // Make sure some other flags are correct:

    peSurface->ddsCaps.dwCaps &= ~DDSCAPS_PRIMARYSURFACE;
    if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
    {
        peSurface->ddsCaps.dwCaps |= DDSCAPS_PRIMARYSURFACE;
    }

    // Remember who is creator (needed for driver managed surface).

    peSurface->peDdGlobalCreator = peDirectDrawGlobal;

    // And if this is driver managed surface, keep reference on driver.

    if (peSurface->dwFlags & DDRAWISURF_DRIVERMANAGED)
    {
        ASSERTGDI(peSurface->fl & DD_SURFACE_FLAG_DRIVER_CREATED,
                  "vDdCompleteSurfaceObject: driver managed surface must be driver created.");

        vDdIncrementReferenceCount(peDirectDrawGlobal);
    }

    // This denotes, among other things, that the surface has been added
    // to the surface list, so on deletion it will have to ben removed
    // from the surface list:

    peSurface->fl |= DD_SURFACE_FLAG_CREATE_COMPLETE;

    // We've had stress failures where there is some funky reuse of the
    // surfaces and we assert because the hbmGdi wasn't cleaned up.  We
    // do it here since we're on the same process as a final check.

    if (peSurface->hbmGdi)
    {
        DxEngDeleteSurface( (HSURF) peSurface->hbmGdi);
        peSurface->hbmGdi = NULL;

        if (peSurface->hpalGdi)
        {
            EngDeletePalette(peSurface->hpalGdi);
            peSurface->hpalGdi = NULL;
        }
    }
}

/******************************Public*Routine******************************\
* HANDLE DxDdCreateSurfaceObject
*
* Creates a kernel-mode representation of the surface, given a location
* in off-screen memory allocated by user-mode DirectDraw.
*
* We expect DirectDraw to already have called DxDdCreateSurface, which
* gives the driver a chance at creating the surface.  In the future, I expect
* all off-screen memory management to be moved to the kernel, with all surface
* allocations being handled via DxDdCreateSurface.  This function call will
* then be extraneous.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDdCreateSurfaceObject(
    HANDLE                  hDirectDrawLocal,
    HANDLE                  hSurface,
    PDD_SURFACE_LOCAL       puSurfaceLocal,
    PDD_SURFACE_MORE        puSurfaceMore,
    PDD_SURFACE_GLOBAL      puSurfaceGlobal,
    BOOL                    bComplete       // TRUE if surface is now complete.
                                            // FALSE if we're just creating a
                                            // kernel handle to handle attaches;
                                            // the surface will be filled-out
                                            // and 'completed' in a later call
    )                                       // to DxDdCreateSurfaceObject.
{
    HANDLE                  hRet;
    DD_SURFACE_LOCAL        SurfaceLocal;
    DD_SURFACE_MORE         SurfaceMore;
    DD_SURFACE_GLOBAL       SurfaceGlobal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_SURFACE*            peSurface;

    hRet = 0;

    __try
    {
        SurfaceLocal  = ProbeAndReadStructure(puSurfaceLocal,  DD_SURFACE_LOCAL);
        SurfaceMore   = ProbeAndReadStructure(puSurfaceMore,   DD_SURFACE_MORE);
        SurfaceGlobal = ProbeAndReadStructure(puSurfaceGlobal, DD_SURFACE_GLOBAL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(hRet);
    }

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDrawLocal);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (SurfaceLocal.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
        {
            // This is system memory

            peSurface = peDdOpenNewSurfaceObject(peDirectDrawLocal,
                                                 hSurface,
                                                 &SurfaceGlobal,
                                                 &SurfaceLocal,
                                                 &SurfaceMore);
            if (peSurface)
            {
                if (bComplete)
                {
                    if ((bDdValidateSystemMemoryObject(peDirectDrawGlobal,
                                                       peSurface)) &&
                        (bDdSecureSystemMemorySurface(peSurface)))
                    {
                        ASSERTGDI(peSurface->hbmGdi == NULL,
                            "DxDdCreateSurfaceObject: Invalid cached bitmap");

                        // If this surface is in lost state, make it active.

                        if (peSurface->bLost)
                        {
                            peSurface->bLost = FALSE;

                            // Now this surface is ready to go, increment active surface ref. count.

                            peSurface->peDirectDrawLocal->cActiveSurface++;

                            ASSERTGDI(peSurface->peDirectDrawLocal->cActiveSurface <=
                                      peSurface->peDirectDrawLocal->cSurface,
                                      "cActiveSurface is > than cSurface");
                        }

                        // We were successful, so unlock the surface:

                        hRet = peSurface->hGet();
                        DEC_EXCLUSIVE_REF_CNT(peSurface);   // Unlock
                    }
                    else
                    {
                        // Delete the surface.  Note that it may or may not
                        // yet have been completed:

                        bDdDeleteSurfaceObject(peSurface->hGet(), NULL);
                    }
                }
                else
                {
                    // This must be a complex surface (e.g. MipMap) that is getting called via the attach function.
                    // DDraw should call this again later to complete the surface.

                    hRet = peSurface->hGet();
                    DEC_EXCLUSIVE_REF_CNT(peSurface);   // Unlock
                }
            }
        }
        else if (!(peDirectDrawGlobal->bSuspended))
        {
            // This is any video memory

            peSurface = peDdOpenNewSurfaceObject(peDirectDrawLocal,
                                                 hSurface,
                                                 &SurfaceGlobal,
                                                 &SurfaceLocal,
                                                 &SurfaceMore);
            if (peSurface != NULL)
            {
                if ((bComplete) &&
                    !(peSurface->fl & DD_SURFACE_FLAG_CREATE_COMPLETE))
                {
                    // Only the kernel can create vidmem surface objects now, so
                    // if we're asked to 'complete' a surface that the kernel
                    // hasn't allocated, it's an error and no object should
                    // be completed.  This weird code path is actually hit when
                    // user-mode DirectDraw  tries to create a primary surface on
                    // a device whose driver doesn't support DirectDraw.

                    bDdDeleteSurfaceObject(peSurface->hGet(), NULL);
                    WARNING("DxDdCreateSurfaceObject: No DirectDraw driver");
                }
                else
                {
                    if (bComplete)
                    {
                        ASSERTGDI(peSurface->hbmGdi == NULL,
                            "DxDdCreateSurfaceObject: Invalid cached bitmap");

                        // If this surface is in lost state, make it active.

                        if (peSurface->bLost)
                        {
                            peSurface->bLost = FALSE;   // Surface can now be used

                            // Now this surface is ready to go, increment active surface ref. count.

                            peSurface->peDirectDrawLocal->cActiveSurface++;

                            ASSERTGDI(peSurface->peDirectDrawLocal->cActiveSurface <=
                                      peSurface->peDirectDrawLocal->cSurface,
                                      "cActiveSurface is > than cSurface");
                        }
                    }

                    // No need to call the CreateSurfaceEx here for this case

                    // We were successful, so unlock the surface:

                    hRet = peSurface->hGet();
                    DEC_EXCLUSIVE_REF_CNT(peSurface);   // Unlock
                }
            }
        }
        else
        {
            WARNING("DxDdCreateSurfaceObject: "
                    "Can't create because disabled\n");
        }
    }
    else
    {
        WARNING("DxDdCreateSurfaceObjec: Bad handle or busy\n");
    }

    return(hRet);
}

/******************************Public*Routine******************************\
* BOOL DxDdDeleteSurfaceObject
*
* Deletes a kernel-mode representation of the surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdDeleteSurfaceObject(
    HANDLE  hSurface
    )
{
    return(bDdDeleteSurfaceObject(hSurface, NULL));
}

/******************************Public*Routine******************************\
* ULONG DxDdResetVisrgn
*
* Registers a window for clipping.
*
*   Remembers the current VisRgn state.  Must be called before the VisRgn
* is downloaded and used.
*
* hwnd is currently not used.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdResetVisrgn(
    HANDLE      hSurface,
    HWND        hwnd            //  0 indicates no window clipping
    )                           // -1 indicates any window can be written to
                                // otherwise indicates a particular window
{
    BOOL                    bRet;
    EDD_SURFACE*            peSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_SURFACE        eLockSurface;

    bRet = FALSE;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        // We only care about the changes to the primary

        if (peSurface->fl & DD_SURFACE_FLAG_PRIMARY)
        {
            peSurface->iVisRgnUniqueness = VISRGN_UNIQUENESS();
        }

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* ULONG DxDdReenableDirectDrawObject
*
* Resets the DirectDraw object after a mode change or after full-screen.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdReenableDirectDrawObject(
    HANDLE hDirectDrawLocal,
    BOOL*  pubNewMode
    )
{
    BOOL                    b;
    HDC                     hdc;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    BOOL                    bModeChanged;

    b = FALSE;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDrawLocal);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        // Get a DC on this HDEV so we can determine if the app has
        // access to it.  A NULL vis-region will be returned whenever
        // something like a desktop has switched.

        hdc = DxEngGetDesktopDC(DCTYPE_DIRECT, FALSE, FALSE);

        PDEVOBJ po(peDirectDrawGlobal->hdev);

        {
            EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

            if (DxEngGetDCState(hdc,DCSTATE_VISRGNCOMPLEX) != NULLREGION)
            {
                // DirectDraw can't be re-enabled while full-screen, or
                // while USER has told us to disable DirectDraw, or when
                // the colour depth is less than 8bpp:

                if (!(po.bDisabled()) &&
                    !(po.bDeleted()) &&
                    (po.cDirectDrawDisableLocks() == 0) &&
                    (po.iDitherFormat() >= BMF_8BPP) &&
                    (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED))
                {
                    bModeChanged
                        = (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_MODE_CHANGED) != 0;

                    CheckAgpHeaps(peDirectDrawGlobal);

                    MapAllAgpHeaps(peDirectDrawLocal);

                    b = TRUE;

                    peDirectDrawGlobal->bSuspended = FALSE;

                    peDirectDrawGlobal->fl &= ~DD_GLOBAL_FLAG_MODE_CHANGED;

                    __try
                    {
                        ProbeAndWriteStructure(pubNewMode, bModeChanged, BOOL);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    }
                }
            }
        }

        if (hdc)
        {
            DxEngDeleteDC(hdc, FALSE);
        }
    }
    else
    {
        WARNING("DxDdReenableDirectDrawObject: Bad handle or busy\n");
    }

    return(b);
}

/******************************Public*Routine******************************\
* HBITMAP hbmDdCreateAndLockGdiSurface
*
* Creates a GDI surface derived from a DirectDraw surface.  This routine
* may call the driver's DdLock function if it hasn't hooked (or fails)
* the DrvDeriveSurface call which gets the driver to wrap a GDI surface
* around a DirectDraw surface.
*
* Note that for the primary (GDI) surface, we can't simply return a handle
* back to the surface stashed in the PDEV.  There are a couple of reasons
* for this:
*
*   o The surface contains the palette, and at 8bpp the palette for
*     a DirectDraw GetDC surface must have the DIB-Section flag set
*     for proper colour matching.  But the primary device surface can
*     not have its palette marked as a DIB-Section.
*
*   o GreSelectBitmap doesn't allow one surface to be selected into more
*     than one DC.
*
*  22-Feb-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HBITMAP
hbmDdCreateAndLockGdiSurface(
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal,
    EDD_SURFACE*            peSurface,
    PALETTEENTRY*           puColorTable    // Points to user-mode table
    )
{
    VOID*               pvScan0;
    VOID*               pvBits;
    LONG                cjBits;
    HBITMAP             hbm;
    ULONG               iMode;
    ULONG               cColors;
    ULONG               i;
    ULONG               iFormat = 0;

    // No color table is used for surfaces greater than 8bpp.

    cColors = 0;
    if (peSurface->ddpfSurface.dwRGBBitCount <= 8)
    {
        cColors = 1 << peSurface->ddpfSurface.dwRGBBitCount;

        // Verify that the color table is safe to look at:

        if (puColorTable != NULL)
        {
            __try
            {
                ProbeForRead(puColorTable, cColors * sizeof(PALETTEENTRY), 1);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("hbmDdCreateAndLockGdiSurface: Bad color table pointer");
                return(0);
            }
        }

        // The bitmap's color table can be shared with the primary surface only
        // if both are 8bpp:

        if (puColorTable == NULL)
        {
            if ((peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount != 8) ||
                (peSurface->ddpfSurface.dwRGBBitCount != 8))
            {
                WARNING("hbmDdCreateAndLockGdiSurface: Can't create shared palettes");
                return(0);
            }
        }
    }

    PDEVOBJ po(peDirectDrawGlobal->hdev);

    if (peSurface->hbmGdi != NULL)
    {
        // Ah ha, we already have a cached GDI surface.  See if we need
        // to call 'Lock', and then get out:

        SURFOBJ* pso;

        if ((pso = EngLockSurface((HSURF)(peSurface->hbmGdi))) != NULL)
        {
            if (peSurface->fl & DD_SURFACE_FLAG_BITMAP_NEEDS_LOCKING)
            {
                pvScan0 =
                    pDdLockSurfaceOrBuffer(peSurface, FALSE, NULL, DDLOCK_WAIT, NULL);

                ASSERTGDI(pvScan0 != NULL,
                    "Driver failed lock call when it succeeded it before.  Tsk, tsk");

                // The drivers allowed to move the surface around between locks, so
                // update the bitmap address:
                if ((pvScan0 != pso->pvScan0) &&
                    (pvScan0 != NULL))
                {
                    pso->pvScan0 = pvScan0;
                    pso->pvBits  = pvScan0;
                }
            }

            // If it's 8bpp or less, we have to update the color table.

            if (peSurface->ddpfSurface.dwRGBBitCount <= 8)
            {
                // Update the color table.

                // Note that the scumy application might have delete the cached
                // bitmap, so we have to check for bValid() here.  (It's been a
                // bad app, so we just protect against crashing, and don't bother
                // to re-create a good bitmap for him.)

                DxEngUploadPaletteEntryToSurface(po.hdev(),pso,puColorTable,cColors);
            }

            EngUnlockSurface(pso);
        }
    }
    else
    {
        // Okay, we have to create a GDI surface on the spot.
        //
        // First, The DirectDraw surface must be marked as RGB (even at 8bpp).
        // GDI doesn't (yet) support drawing to YUV surfaces or the like.  It
        // also doesn't support 2bpp surfaces.

        if ((peSurface->ddpfSurface.dwFlags & DDPF_RGB) &&
            (peSurface->ddpfSurface.dwRGBBitCount != 2))
        {
            // We have to have the devlock since we'll be grunging around in
            // the PDEV:

            DD_ASSERTDEVLOCK(peDirectDrawGlobal);

            switch (peSurface->ddpfSurface.dwRGBBitCount)
            {
            case 1:
                iFormat = BMF_1BPP; break;
            case 4:
                iFormat = BMF_4BPP; break;
            case 8:
                iFormat = BMF_8BPP; break;
            case 16:
                iFormat = BMF_16BPP; break;
            case 24:
                iFormat = BMF_24BPP; break;
            case 32:
                iFormat = BMF_32BPP; break;
            default:
                RIP("hbmDdCreateAndLockGdiSurface: Illegal dwRGBBitCount\n");
            }

            iMode = (iFormat <= BMF_8BPP) ? PAL_INDEXED : PAL_BITFIELDS;

            HPALETTE hpal = EngCreatePalette(iMode,
                                       cColors,
                                       (ULONG*) puColorTable,
                                       peSurface->ddpfSurface.dwRBitMask,
                                       peSurface->ddpfSurface.dwGBitMask,
                                       peSurface->ddpfSurface.dwBBitMask);

            if (hpal)
            {
                if ((cColors == 256) && (puColorTable == NULL))
                {
                    ASSERTGDI(po.bIsPalManaged(), "Expected palettized display");

                    // Make this palette share the same colour table as the
                    // screen, so that we always get identity blts:

                    DxEngSyncPaletteTableWithDevice(hpal,po.hdev());
                }

                hbm = 0;

                // First, try getting the driver to create the surface, assuming
                // it's a video memory surface.

                if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                    PPFNVALID(po, DeriveSurface))
                {
                    hbm = PPFNDRV(po, DeriveSurface)(peDirectDrawGlobal,
                                                     peSurface);
                    if (hbm)
                    {
                        SURFOBJ* pso = EngLockSurface((HSURF)hbm);
                        if (pso)
                        {
                            // Mark surface as DirectDraw surface.

                            DxEngMarkSurfaceAsDirectDraw(pso,peSurface->hGet());

                            // Select the created palette to surface palette.

                            DxEngSelectPaletteToSurface(pso,hpal);

                            EngUnlockSurface(pso);
                        }
                        else
                        {
                            EngDeleteSurface((HSURF)hbm);
                            hbm = 0;
                        }
                    }
                }

                // Next, try getting GDI to create the surface:

                if (hbm == 0)
                {
                    // Note that this lock will fail when the PDEV isn't active,
                    // meaning that GetDC will return 0 when full-screen.
                    // GDI won't barf on any calls where the HDC is passed in as
                    // 0, so this is okay.

                    pvScan0 = pDdLockSurfaceOrBuffer(peSurface, FALSE,
                                                     NULL, DDLOCK_WAIT, NULL);
                    if (pvScan0 != NULL)
                    {
                        FLONG fl;
                        SIZEL sizl;

                        sizl.cx = peSurface->wWidth;
                        sizl.cy = peSurface->wHeight;
                        fl      = BMF_TOPDOWN;
                        pvBits  = pvScan0;
                        cjBits  = (LONG) peSurface->wHeight * peSurface->lPitch;
                        if (cjBits < 0)
                        {
                            fl = 0;
                            cjBits = -cjBits;
                            pvBits = (BYTE*) pvScan0 - cjBits - peSurface->lPitch;
                        }

                        hbm = EngCreateBitmap(sizl,
                                              0,
                                              iFormat,
                                              fl,
                                              pvBits);

                        // Mark the palette as a DIB-Section so that any color-
                        // matching on the DC actually uses the entire device
                        // palette, NOT what the logical palette selected into
                        // the DC.

                        DxEngSetPaletteState(hpal,PALSTATE_DIBSECTION,(ULONG_PTR)TRUE);

                        if (hbm)
                        {
                            SURFOBJ* pso = EngLockSurface((HSURF) hbm);
                            if (pso)
                            {
                                peSurface->fl |= DD_SURFACE_FLAG_BITMAP_NEEDS_LOCKING;

                                // Select the created palette to surface palette.

                                DxEngSelectPaletteToSurface(pso,hpal);

                                // Mark surface as DirectDraw surface.

                                DxEngMarkSurfaceAsDirectDraw(pso,peSurface->hGet());

                                // Override some fields which we couldn't specify in
                                // the 'EngCreateBitmap' call.  The following 3 are due to
                                // the fact that we couldn't pass in a stride:

                                pso->lDelta    = peSurface->lPitch;
                                pso->pvScan0   = pvScan0;
                                pso->cjBits    = cjBits;
                                pso->fjBitmap |= BMF_DONTCACHE;

                                if (!(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
                                {
                                    pso->fjBitmap |= BMF_NOTSYSMEM;
                                }

                                EngUnlockSurface(pso);
                            }
                            else
                            {
                                EngDeleteSurface((HSURF)hbm);
                                hbm = 0;
                            }
                        }
                        else
                        {
                            bDdUnlockSurfaceOrBuffer(peSurface);
                        }
                    }
                }

                if (hbm)
                {
                    // Success, we're done!
                    //
                    // Set handle owner to current process.

                    DxEngSetBitmapOwner(hbm, OBJECT_OWNER_CURRENT);

                    peSurface->hbmGdi = hbm;

                    // TODO: Palette needs to be owned by this process.

                    peSurface->hpalGdi = hpal;
                }
                else
                {
                    EngDeletePalette(hpal);
                }
            }
        }
        else if (!(peSurface->ddpfSurface.dwFlags & DDPF_ZBUFFER))
        {
            WARNING("hbbDdCreateAndLockGdiSurface: Invalid surface or RGB type\n");
        }
    }

    return(peSurface->hbmGdi);
}

/******************************Public*Routine******************************\
* VOID vDdUnlockGdiSurface
*
* Unlocks the view required for the GDI bitmap if necessary (that is, if
* the driver didn't hook DrvDeriveSurface, or failed it).
*
*  22-Feb-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID FASTCALL
vDdUnlockGdiSurface(
    EDD_SURFACE*    peSurface
    )
{
    if (peSurface->fl & DD_SURFACE_FLAG_BITMAP_NEEDS_LOCKING)
    {
        bDdUnlockSurfaceOrBuffer(peSurface);
    }
}

/******************************Public*Routine******************************\
* HDC DxDdGetDC
*
* Creates a DC that can be used to draw to an off-screen DirectDraw
* surface.
*
* Essentially, this works as follows:
*
*   o Do a DirectDraw Lock on the specified surface;
*   o CreateDIBSection of the appropriate format pointing to that surface;
*   o CreateCompatibleDC to get a DC;
*   o Select the DIBSection into the compatible DC
*
* At 8bpp, however, the DIBSection is not a 'normal' DIBSection.  It's
* created with no palette so that it it behaves as a device-dependent
* bitmap: the color table is the same as the display.
*
* GDI will do all drawing to the surface using the user-mode mapping of
* the frame buffer.  Since all drawing to the created DC will occur in the
* context of the application's process, this is not a problem.  We do have
* to watch out that we don't blow away the section view while a thread is
* in kernel-mode GDI drawing; however, this problem would have to be solved
* even if using a kernel-mode mapping of the section because we don't want
* any drawing intended for an old PDEV to get through to a new PDEV after
* a mode change has occured, for example.
*
* A tricky part of GetDC is how to blow away the surface lock while a thread
* could be in kernel-mode GDI about to draw using the surface pointer.  We
* solve that problem by changing the DC's VisRgn to be an empty region when
* trying to blow away all the surface locks.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

HDC
APIENTRY
DxDdGetDC(
    HANDLE          hSurface,
    PALETTEENTRY*   puColorTable
    )
{
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    HDC                     hdc;
    HBITMAP                 hbm;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        // DirectDraw doesn't let an application have more than one active
        // GetDC DC to a surface at a time:

        if (peSurface->hdc != 0)
        {
            return(0);
        }

        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        // Grab the devlock because hbmDdCreateAndLockGdiSurface grunges
        // around in the global data.

        EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

        if (!peSurface->bLost)
        {
            // Note that 'hbmDdCreateAndLockGdiSurface' keeps a bitmap cache,
            // so this should usually be pretty quick:

            hbm = hbmDdCreateAndLockGdiSurface(peDirectDrawGlobal,
                                               peSurface,
                                               puColorTable);
            if (hbm != NULL)
            {
                // First, try to get a DC from the cache:

                hdc = (HDC) peDirectDrawGlobal->hdcCache;
                if (hdc != NULL)
                {
                    // This will succeed only if we atomically managed to
                    // grab the cached DC (there may be other threads
                    // calling 'bDdReleaseDC' at exactly the same time).

                    if (InterlockedCompareExchangePointer(
                                &peDirectDrawGlobal->hdcCache,
                                NULL,
                                (VOID*) hdc) == hdc)
                    {

                        // Set the DC's ownership to the current process so
                        // that it will get cleaned up if the process terminates
                        // unexpectedly.

                        BOOL bSet = DxEngSetDCOwner(hdc, OBJECT_OWNER_CURRENT);

                        ASSERTGDI(bSet, "DxDdGetDC: Cached DC was invalid");
                    }
                    else
                    {
                        hdc = NULL;
                    }
                }

                if (hdc == NULL)
                {
                    // Now, create the DC for the actual drawing, owned by the
                    // current process.

                    hdc = DxEngCreateMemoryDC(peDirectDrawGlobal->hdev);
                }

                if (hdc)
                {
                    // Finally, select our surface into the DC.  It
                    // doesn't matter if this fails for some bizarre
                    // reason; the default bitmap will be stuck in there
                    // instead.

                    HBITMAP hbmOld = DxEngSelectBitmap(hdc, hbm);

                    ASSERTGDI(hbmOld, "DxDdGetDC: Invalid selection");

                    peSurface->hdc = hdc;

                    // I'm paranoid, so let's verify that we've set things
                    // up correctly:

                    #if 0 // TODO: DBG - DC
                    {
                        DCOBJ dco(hdc);
                        ASSERTGDI(dco.bValid(),
                            "DxDdGetDC: Should have a valid DC");
                        ASSERTGDI(!dco.bFullScreen(),
                            "DxDdGetDC: DC shouldn't be disabled");
                        ASSERTGDI(dco.bSynchronizeAccess(),
                            "DxDdGetDC: Should mark devlock needed");
                        ASSERTGDI(dco.pSurfaceEff()->bDirectDraw(),
                            "DxDdGetDC: Should mark as DDraw surface");
                        ASSERTGDI(dco.dctp() == DCTYPE_MEMORY,
                            "DxDdGetDC: Should be memory DC");
                    }
                    #endif

                    // For debugging purposes:

                    ghdcGetDC = hdc;

                    return(hdc);
                }

                vDdUnlockGdiSurface(peSurface);
            }
            else
            {
                WARNING("DxDdGetDC: hbmDdCreateAndLockGdiSurface failed\n");
            }
        }
    }
    else
    {
        WARNING("DxDdGetDC: Couldn't lock the surface\n");
    }

    return(0);
}

/******************************Public*Routine******************************\
* BOOL bDdReleaseDC
*
* Deletes a DC created via DdGetDC.
*
* The devlock should not be held when entering this function.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
bDdReleaseDC(
    EDD_SURFACE*    peSurface,
    BOOL            bForce              // True when cleaning up surface
    )
{
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    BOOL                    bRet = FALSE;
    BOOL                    bClean;
    HDC                     hdc;

    hdc = peSurface->hdc;
    if (hdc)
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

#if 0 // Temporary disable DC cache for bug 176728

        // See if there's already a DC in the one-deep cache:

        if (!peDirectDrawGlobal->hdcCache)
        {
            // Okay, it looks like we can cache this DC.  Clean it up first,
            // which among other things unselects the current DirectDraw
            // GDI surface.  Then set the owner to 'none' so that it
            // doesn't get deleted when the current process terminates and
            // no one can touch it until we pick up from cache.

            if (DxEngCleanDC(hdc) &&
                DxEngSetDCOwner(hdc, OBJECT_OWNER_NONE))
            {
                // Atomically try to stick the DC into the cache.  Note that
                // it's okay if this fails and we fall into 'bDeleteDCInternal',
                //
                // Note that we use 'InterlockedCompareExchangePointer' so that
                // we can avoid acquiring the devlock in most cases through
                // bDdReleaseDC.  So if someone changes this code to acquire
                // the devlock, there's really no pointer in doing this via
                // an Interlocked method.

                if (InterlockedCompareExchangePointer(
                                &peDirectDrawGlobal->hdcCache,
                                (VOID*) hdc,
                                NULL) == NULL)
                {
                    // Success, we cached the DC!

                    hdc = NULL;
                }
                else
                {
                    // Need to be belonging to current process in order to delete.
                    // since we already changed the owner to 'none' above.

                    DxEngSetDCOwner(hdc, OBJECT_OWNER_CURRENT);
                }
            }
            else
            {
                WARNING("bDdReleaseDC: Not caching DC, app may have deleted it");
            }
        }

#endif

        if (hdc)
        {
            // There's already a DC in the cache.  So delete this one.
            //
            // Note that the application could have called DeleteObject(hdc)
            // or SelectObject(hdc, hSomeOtherBitmap) with the DC we gave
            // them.  That's okay, though: nothing will crash, just some of
            // the below operations may fail because they've already been
            // done:

            if (!DxEngDeleteDC(hdc, TRUE))
            {
                WARNING("bDdReleaseDC: Couldn't delete DC\n");
            }
        }

        // Call the driver's DdUnlock if necessary:

        vDdUnlockGdiSurface(peSurface);

        peSurface->hdc = NULL;

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DxDdReleaseDC
*
* User-mode callable routine to delete a DC created via DdGetDC.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdReleaseDC(
    HANDLE  hSurface
    )
{
    BOOL               bRet;
    EDD_LOCK_SURFACE   eLockSurface;
    EDD_SURFACE*       peSurface;

    bRet = FALSE;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        bRet = bDdReleaseDC(peSurface, FALSE);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL DxDdAttachSurface
*
* Transmogrified from Win95's ddsatch.c AddAttachedSurface.  Don't blame
* me for this wonderful attach system; the attach links are used by drivers
* and so we have to be compatible with Win95.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL
APIENTRY
DxDdAttachSurface(
    HANDLE  hSurfaceFrom,   // hSurfaceFrom will point 'to' hSurfaceTo
                            //   (think of this as the main surface)
    HANDLE  hSurfaceTo      // hSurfaceTo will point 'from' hSurfaceFrom
    )                       //   (think of this as the secondary surface)
{
    EDD_LOCK_SURFACE    eLockSurfaceFrom;
    EDD_LOCK_SURFACE    eLockSurfaceTo;
    EDD_SURFACE*        peSurfaceFrom;
    EDD_SURFACE*        peSurfaceTo;
    DD_ATTACHLIST*      pAttachFrom;
    DD_ATTACHLIST*      pAttachTo;
    DD_ATTACHLIST*      pAttach;
    DD_ATTACHLIST*      pAttachTemp;
    BOOL                bAttach;
    BOOL                bRet;

    bRet = FALSE;           // Assume failure

    peSurfaceFrom = eLockSurfaceFrom.peLock(hSurfaceFrom);
    peSurfaceTo   = eLockSurfaceTo.peLock(hSurfaceTo);
    if ((peSurfaceFrom != NULL) && (peSurfaceTo != NULL))
    {
        if (peSurfaceFrom->peDirectDrawLocal == peSurfaceTo->peDirectDrawLocal)
        {
            // Use the devlock to synchronize additions and deletions to
            // the attach list:

            EDD_DEVLOCK eDevLock(peSurfaceFrom->peDirectDrawGlobal);

            // First, see if the surface is already attached or in the
            // chain.  If so, don't add it again

            bAttach = TRUE;
            for (pAttach = peSurfaceFrom->lpAttachListFrom;
                 pAttach != NULL;
                 pAttach = pAttach->lpAttached->lpAttachListFrom)
            {
                for (pAttachTemp = pAttach;
                    pAttachTemp != NULL;
                    pAttachTemp = pAttachTemp->lpLink)
                {
                    if (pedFromLp(pAttachTemp->lpAttached) == peSurfaceTo)
                        bAttach = FALSE;
                }
            }
            for (pAttach = peSurfaceTo->lpAttachList;
                 pAttach != NULL;
                 pAttach = pAttach->lpAttached->lpAttachList)
            {
                for (pAttachTemp = pAttach;
                    pAttachTemp != NULL;
                    pAttachTemp = pAttachTemp->lpLink)
                {
                    if (pedFromLp(pAttachTemp->lpAttached) == peSurfaceTo)
                        bAttach = FALSE;
                }
            }

            if (bAttach)
            {
                pAttachFrom = (DD_ATTACHLIST*) PALLOCMEM(sizeof(*pAttachFrom),
                                                         'addG');
                if (pAttachFrom != NULL)
                {
                    pAttachTo = (DD_ATTACHLIST*) PALLOCMEM(sizeof(*pAttachTo),
                                                           'addG');
                    if (pAttachTo != NULL)
                    {
                        pAttachFrom->lpAttached = peSurfaceTo;
                        pAttachFrom->lpLink = peSurfaceFrom->lpAttachList;
                        peSurfaceFrom->lpAttachList = pAttachFrom;

                        pAttachTo->lpAttached = peSurfaceFrom;
                        pAttachTo->lpLink = peSurfaceTo->lpAttachListFrom;
                        peSurfaceTo->lpAttachListFrom = pAttachTo;

                        vDdUpdateMipMapCount(peSurfaceTo);
                        bRet = TRUE;
                    }

                    if (!bRet)
                    {
                        VFREEMEM(pAttachFrom);
                    }
                }
            }
            else
            {
                WARNING("DxDdAttachSurface: Surfaces already attached");
                bRet = TRUE;
            }
        }
        else
        {
            WARNING("DxDdAttachSurface: Surfaces not for same device");
        }
    }
    else
    {
        WARNING("DxDdAttachSurface: Invalid surface specified");
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID DxDdUnattachSurface
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID
APIENTRY
DxDdUnattachSurface(
    HANDLE  hSurface,
    HANDLE  hSurfaceAttached
    )
{
    EDD_LOCK_SURFACE    eLockSurface;
    EDD_LOCK_SURFACE    eLockSurfaceAttached;
    EDD_SURFACE*        peSurface;
    EDD_SURFACE*        peSurfaceAttached;

    peSurface         = eLockSurface.peLock(hSurface);
    peSurfaceAttached = eLockSurfaceAttached.peLock(hSurfaceAttached);
    if ((peSurface != NULL) && (peSurfaceAttached != NULL))
    {
        // Use the devlock to synchronize additions and deletions to
        // the attach list:

        EDD_DEVLOCK eDevLock(peSurface->peDirectDrawGlobal);

        if (bDdRemoveAttachedSurface(peSurface, peSurfaceAttached))
        {
            vDdUpdateMipMapCount(peSurface);
            vDdUpdateMipMapCount(peSurfaceAttached);
        }
        else
        {
            WARNING("DxDdUnattachSurface: Surface not attached");
        }
    }
    else
    {
        WARNING("DxDdUnattachSurface: Invalid surface specified");
    }
}

/******************************Public*Routine******************************\
* DWORD dwDdBltViaGdi
*
* This routine will attempt to do a non-stretching, non-system-memory to
* non-system-memory blt, or system-memory to non-system-memory blt via the
* driver's CopyBits routine.  The motivation for this is two-fold:
*
* 1.  If the system-memory to video-memory blt has to be emulated, we can
*     do a better emulation job here from the kernel than the HEL can from
*     user-mode, where it has to call Lock/Unlock.  We get a couple of
*     benefits:
*
*           o We can do the blt in one kernel-mode transition, instead
*             of the two previously needed for the lock and unlock;
*
*           o Because we don't have to hold from user-mode a DirectDraw Lock
*             on the video memory, we don't run the risk of having to
*             redraw if the clipping changes asynchronously;
*
*           o We can handle blts underneath emulated sprites without having
*             to tear down the sprites, by virtue of going through
*             SpCopyBits.  This means, among other things, that the
*             cursor won't flash.
*
* 2.  For non-system-memory to video-memory blts, we can handle blts to the
*     underneath emulated sprites without having to tear down the sprites,
*     by virtue of going through SpCopyBits.
*
* Returns DDHAL_DRIVER_HANDLED if GDI handled the blt; DDHAL_DRIVER_NOTHANDLED
* if the blt should be handled by the driver's HAL.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
dwDdBltViaGdi(
    EDD_SURFACE*    peSurfaceDest,
    EDD_SURFACE*    peSurfaceSrc,
    DD_BLTDATA*     pBltData
    )
{
    DWORD                   dwRet = DDHAL_DRIVER_NOTHANDLED;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    HBITMAP                 hbmDest;
    HBITMAP                 hbmSrc;
    BOOL                    bGdiCandidate;

    // If the sources are compatible, and the destination is video-memory,
    // we may want to call the driver through GDI.  We do this primarily
    // to handle blts that occur underneath  emulated sprites, so that we
    // don't have to tear down the sprite.

    if ((peSurfaceSrc != NULL) &&
        (peSurfaceDest->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY))
    {
        peDirectDrawGlobal = peSurfaceDest->peDirectDrawGlobal;

        PDEVOBJ po(peDirectDrawGlobal->hdev);

        // We're acting as the HEL for system-memory to video-memory
        // blts, and so those cases always have to go through GDI.
        //
        // Otherwise, we go through CopyBits only if:
        //
        //    o The destination is the primary GDI surface;
        //    o Sprites are visible;
        //    o The source surface can be accelerated;
        //    o There isn't a stretch.

        bGdiCandidate = FALSE;

        // If we're emulating system-memory to video-memory blts, we have
        // to take all system-memory to video-memory blts here (we never
        // said we'd do stretches or anything weird, but we don't want to
        // pass any system-memory to video-memory calls at all to the driver,
        // since it may fall-over when it gets a surface type it doesn't
        // expect).

        if ((peSurfaceSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
            (peDirectDrawGlobal->flDriver & DD_DRIVER_FLAG_EMULATE_SYSTEM_TO_VIDEO) &&
            (peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY))
        {
            bGdiCandidate = TRUE;

            // As a robustness thing, don't let *any* system-memory to video-
            // memory blts down to the driver if it didn't ask for it.

            dwRet = DDHAL_DRIVER_HANDLED;
        }

        // If the destination is the primary GDI surface and any sprites
        // are visible, we also vector through GDI in order to be able to
        // handle blts underneath sprites without flashing.

        else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY) &&
                 (DxEngSpSpritesVisible(peDirectDrawGlobal->hdev)) &&
                 ((PPFNVALID(po, DeriveSurface)) ||
                  (peSurfaceSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)))
        {
            bGdiCandidate = TRUE;
        }

        // Add cases where CopyBits can not handle the blit
        //
        // 1. color keying
        // 2. FX blit(mirror)
        // 3. Blit has color space conversion, e.g. YUV to RGB

        if (bGdiCandidate)
        {
            bGdiCandidate=FALSE;

            if (!(pBltData->dwFlags & (DDBLT_KEYSRCOVERRIDE |
                                      DDBLT_KEYDESTOVERRIDE |
                                      DDBLT_KEYSRC |
                                      DDBLT_KEYDEST |
                                      DDBLT_DDFX)) &&
                 (peSurfaceDest->ddpfSurface.dwRGBBitCount
                     == peSurfaceSrc->ddpfSurface.dwRGBBitCount))
            {
                DWORD dwDestFlags = peSurfaceDest->ddpfSurface.dwFlags;
                DWORD dwSrcFlags  = peSurfaceSrc->ddpfSurface.dwFlags;

                dwDestFlags &= (DDPF_RGB|DDPF_PALETTEINDEXED8);
                dwSrcFlags &= (DDPF_RGB|DDPF_PALETTEINDEXED8);

                if ((dwDestFlags != 0) && (dwDestFlags==dwSrcFlags))
                {
                    if (!(dwSrcFlags & DDPF_PALETTEINDEXED8))
                    {
                        if ((peSurfaceDest->ddpfSurface.dwRBitMask
                                == peSurfaceSrc->ddpfSurface.dwRBitMask) &&
                              (peSurfaceDest->ddpfSurface.dwGBitMask
                                == peSurfaceSrc->ddpfSurface.dwGBitMask) &&
                              (peSurfaceDest->ddpfSurface.dwBBitMask
                                == peSurfaceSrc->ddpfSurface.dwBBitMask))
                        {
                            bGdiCandidate=TRUE;
                        }
                    }
                    else
                    {
                        bGdiCandidate=TRUE;
                    }
                }
            }
        }

        if ((bGdiCandidate)                                      &&
            ((pBltData->rDest.right - pBltData->rDest.left)
                == (pBltData->rSrc.right - pBltData->rSrc.left)) &&
            ((pBltData->rDest.bottom - pBltData->rDest.top)
                == (pBltData->rSrc.bottom - pBltData->rSrc.top)))
        {
            // At this point, GDI is definitely going to handle the
            // blt (or die trying):

            dwRet = DDHAL_DRIVER_HANDLED;
            pBltData->ddRVal = DD_OK;

            // If a hardware flip is pending on this surface, then wait for
            // the flip to finish before continuing:

            if (peSurfaceDest->fl & DD_SURFACE_FLAG_FLIP_PENDING)
            {
                ASSERTGDI(
                    (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_GETFLIPSTATUS) &&
                    peDirectDrawGlobal->SurfaceCallBacks.GetFlipStatus,
                    "Flip pending but GetFlipStatus unsupported by driver?");

                DD_GETFLIPSTATUSDATA GetFlipStatusData;
                DWORD dwFlipRet;

                GetFlipStatusData.lpDD = peDirectDrawGlobal;
                GetFlipStatusData.lpDDSurface = peSurfaceDest;
                GetFlipStatusData.dwFlags = DDGFS_ISFLIPDONE;
                GetFlipStatusData.GetFlipStatus = NULL;
                GetFlipStatusData.ddRVal = DDERR_GENERIC;

                do
                {
                    dwFlipRet = peDirectDrawGlobal->
                        SurfaceCallBacks.GetFlipStatus(&GetFlipStatusData);

                } while (
                    (dwFlipRet == DDHAL_DRIVER_HANDLED) &&
                    (GetFlipStatusData.ddRVal == DDERR_WASSTILLDRAWING));

                peSurfaceDest->fl &= ~DD_SURFACE_FLAG_FLIP_PENDING;
            }

            // If the surfaces are primary (GDI) surfaces, just use
            // the GDI surface we have stashed in the PDEV:

            hbmDest = (HBITMAP) po.hsurf();
            hbmSrc  = (HBITMAP) po.hsurf();

            if (!(peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY))
            {
                hbmDest = hbmDdCreateAndLockGdiSurface(peDirectDrawGlobal,
                                                       peSurfaceDest,
                                                       NULL);
            }

            if (!(peSurfaceSrc->fl & DD_SURFACE_FLAG_PRIMARY))
            {
                hbmSrc = hbmDdCreateAndLockGdiSurface(peDirectDrawGlobal,
                                                      peSurfaceSrc,
                                                      NULL);
            }

            SURFOBJ *psoDest = EngLockSurface((HSURF) hbmDest);
            SURFOBJ *psoSrc  = EngLockSurface((HSURF) hbmSrc);

            if (psoDest && psoSrc)
            {
                PDEVOBJ po(peDirectDrawGlobal->hdev);

                // A malicious app may have given us stretch values on
                // system-memory to video-memory blts, so check:

                if (((pBltData->rDest.right - pBltData->rDest.left)
                    == (pBltData->rSrc.right - pBltData->rSrc.left)) &&
                    ((pBltData->rDest.bottom - pBltData->rDest.top)
                    == (pBltData->rSrc.bottom - pBltData->rSrc.top)))
                {
                    (*PPFNGET(po, CopyBits, SURFOBJ_HOOK(psoDest)))
                         (psoDest,
                          psoSrc,
                          NULL,
                          NULL,
                          &pBltData->rDest,
                          (POINTL*) &pBltData->rSrc);
                }
            }

            if (psoDest)
            {
                EngUnlockSurface(psoDest);
            }

            if (psoSrc)
            {
                EngUnlockSurface(psoSrc);
            }

            if (!(peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY))
            {
                vDdUnlockGdiSurface(peSurfaceDest);
            }

            if (!(peSurfaceSrc->fl & DD_SURFACE_FLAG_PRIMARY))
            {
                vDdUnlockGdiSurface(peSurfaceSrc);
            }
        }
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdBlt
*
* DirectDraw blt.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdBlt(
    HANDLE      hSurfaceDest,
    HANDLE      hSurfaceSrc,
    PDD_BLTDATA puBltData
    )
{
    DWORD       dwRet;
    DD_BLTDATA  BltData;
#ifdef DX_REDIRECTION
    HWND        hWnd;
#endif // DX_REDIRECTION

    __try
    {
        ProbeForRead(puBltData, sizeof(DD_BLTDATA), sizeof(DWORD));

        // To save some copying time, we copy only those fields which are
        // supported for NT drivers:

        BltData.rDest.left            = puBltData->rDest.left;
        BltData.rDest.top             = puBltData->rDest.top;
        BltData.rDest.right           = puBltData->rDest.right;
        BltData.rDest.bottom          = puBltData->rDest.bottom;
        BltData.rSrc.left             = puBltData->rSrc.left;
        BltData.rSrc.top              = puBltData->rSrc.top;
        BltData.rSrc.right            = puBltData->rSrc.right;
        BltData.rSrc.bottom           = puBltData->rSrc.bottom;

        BltData.dwFlags               = puBltData->dwFlags;
        BltData.bltFX.dwFillColor     = puBltData->bltFX.dwFillColor;
        BltData.bltFX.ddckSrcColorkey = puBltData->bltFX.ddckSrcColorkey;
        BltData.bltFX.ddckDestColorkey= puBltData->bltFX.ddckDestColorkey;
        BltData.bltFX.dwDDFX          = puBltData->bltFX.dwDDFX;

#ifdef DX_REDIRECTION
        // DD_BLTDATA.Blt member contains hWnd.
        hWnd                          = (HWND)(puBltData->Blt);
#endif // DX_REDIRECTION
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet          = DDHAL_DRIVER_NOTHANDLED;
    BltData.ddRVal = DDERR_GENERIC;

#ifdef DX_REDIRECTION
    // if hWnd is given and redirection is enabled on the hWnd,
    // we just fail this call here, and let ddraw runtime to uses
    // emulation code, which eventually call GDI Blt functions.

    if (hWnd)
    {
        if (DxEngGetRedirectionBitmap(hWnd))
        {
            return(dwRet);
        }
    }
#endif // DX_REDIRECTION

    EDD_SURFACE*            peSurfaceDest;
    EDD_SURFACE*            peSurfaceSrc;
    DWORD                   dwFlags;
    EDD_LOCK_SURFACE        eLockSurfaceDest;
    EDD_LOCK_SURFACE        eLockSurfaceSrc;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DWORD                   dwSrcCaps;
    DWORD                   dwDestCaps;
    DDNTCORECAPS*           pCaps;
    BOOL                    bUnTearDown;

    peSurfaceDest = eLockSurfaceDest.peLock(hSurfaceDest);
    BltData.lpDDDestSurface = peSurfaceDest;

    if (peSurfaceDest != NULL)
    {
        peDirectDrawGlobal = peSurfaceDest->peDirectDrawGlobal;

        // We support only a specific set of Blt calls down to the driver
        // that we're willing to support and to test.

        dwFlags = BltData.dwFlags;
        if (((dwFlags & (DDBLT_ROTATIONANGLE)) == 0) &&
            ((dwFlags & (DDBLT_ROP
                       | DDBLT_COLORFILL
                       | DDBLT_DEPTHFILL)) != 0))
        {
            // I think ROPs are goofy, so we always tell the application
            // that our hardware can only do SRCCOPY blts, but we should
            // make sure the driver doesn't fall over if it gets something
            // unexpected.  And they can look at this even if DDBLT_DDFX
            // isn't set:

            BltData.bltFX.dwROP = 0xCC0000; // SRCCOPY in DirectDraw format

            // No support for IsClipped for now -- we would have to
            // validate and copy the prDestRects array:

            BltData.IsClipped = FALSE;

            if (dwFlags & DDBLT_DDFX)
            {
                // The only DDBLT_DDFX functionality we allow down to the
                // driver is DDBLTFX_NOTEARING:
                //           DDBLTFX_MIRRORLEFTRIGHT
                //           DDBLTFX_MIRRORUPDOWN

                if (BltData.bltFX.dwDDFX & ~(DDBLTFX_NOTEARING
                                            |DDBLTFX_MIRRORLEFTRIGHT
                                            |DDBLTFX_MIRRORUPDOWN)
                                            )
                {
                    WARNING("DxDdBlt: Invalid dwDDFX\n");
                    return(dwRet);
                }
            }

            if (dwFlags & (DDBLT_COLORFILL | DDBLT_DEPTHFILL))
            {
                // Do simpler stuff 'cause we don't need to lock a source:

                BltData.lpDDSrcSurface = NULL;
                peSurfaceSrc = NULL;

                if (peSurfaceDest->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                {
                    WARNING("DxDdBlt: Can't blt to system memory surface");
                    return(dwRet);
                }
            }
            else
            {
                // Lock the source surface:

                peSurfaceSrc = eLockSurfaceSrc.peLock(hSurfaceSrc);
                BltData.lpDDSrcSurface = peSurfaceSrc;

                // Ensure that both surfaces belong to the same DirectDraw
                // object, and check source rectangle:

                if ((peSurfaceSrc == NULL)                               ||
                    (peSurfaceSrc->peDirectDrawLocal !=
                            peSurfaceDest->peDirectDrawLocal)            ||
                    (BltData.rSrc.left   < 0)                            ||
                    (BltData.rSrc.top    < 0)                            ||
                    (BltData.rSrc.right  > (LONG) peSurfaceSrc->wWidth)  ||
                    (BltData.rSrc.bottom > (LONG) peSurfaceSrc->wHeight) ||
                    (BltData.rSrc.left  >= BltData.rSrc.right)           ||
                    (BltData.rSrc.top   >= BltData.rSrc.bottom))
                {
                    WARNING("DxDdBlt: Invalid source surface or source rectangle\n");
                    return(dwRet);
                }

                // Make sure the blts are between surface types that the
                // driver will expect, otherwise the driver may fall-over
                // if called with NtCrash or some other malicious program.

                dwSrcCaps = peSurfaceSrc->ddsCaps.dwCaps;
                dwDestCaps = peSurfaceDest->ddsCaps.dwCaps;
                pCaps = &peDirectDrawGlobal->HalInfo.ddCaps;

                // If the dest surface is the primary, DDraw will
                // ask the kernel to Blt from system to video memory
                // even if the driver doesn't specify this capability
                // because it knows that the kernel can emulate it properly.
                // The kernel used to set this cap, be we changed it because
                // it was eating up too many handles and creating inefficiencies.

                if (((dwSrcCaps & DDSCAPS_VIDEOMEMORY) &&
                      (dwDestCaps & DDSCAPS_SYSTEMMEMORY) &&
                      !(pCaps->dwVSBCaps & DDCAPS_BLT)) ||

                     ((dwDestCaps & DDSCAPS_VIDEOMEMORY) &&
                      (dwSrcCaps & DDSCAPS_SYSTEMMEMORY) &&
                      (!(pCaps->dwSVBCaps & DDCAPS_BLT) &&
                      !(peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY))) ||

                     ((dwSrcCaps & DDSCAPS_SYSTEMMEMORY) &&
                      (dwDestCaps & DDSCAPS_SYSTEMMEMORY) &&
                      !(pCaps->dwSSBCaps & DDCAPS_BLT)))
                {
                    WARNING("DxDdBlt: Illegal system memory surface");
                    return(dwRet);
                }
            }

            // Make sure that we weren't given rectangle coordinates
            // which might cause the driver to crash.  Note that we
            // don't allow inverting stretch blts:

            if ((BltData.rDest.left   >= 0)                             &&
                (BltData.rDest.top    >= 0)                             &&
                (BltData.rDest.right  <= (LONG) peSurfaceDest->wWidth)  &&
                (BltData.rDest.bottom <= (LONG) peSurfaceDest->wHeight) &&
                (BltData.rDest.left    < BltData.rDest.right)           &&
                (BltData.rDest.top     < BltData.rDest.bottom))
            {
                // Make sure that the surfaces aren't associated
                // with a PDEV whose mode has gone away.
                //
                // Also ensure that there are no outstanding
                // surface locks if running on a brain-dead video
                // card that crashes if the accelerator runs at
                // the same time the frame buffer is accessed.

                EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

                // We will return SURFACELOST when ...
                //
                // 1) This device is suspended.
                // 2) The driver managed surface is managed by other device.
                // 3) One of surface is losted.
                // 4) The visible region has been changed when surface is primary.

                if (peDirectDrawGlobal->bSuspended)                                 // 1)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_WRONG_DRIVER) ||
                         ((peSurfaceSrc != NULL) &&
                          (peSurfaceSrc->fl & DD_SURFACE_FLAG_WRONG_DRIVER)))       // 2)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->bLost) ||
                         ((peSurfaceSrc != NULL) && (peSurfaceSrc->bLost)))         // 3)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY) &&
                         (peSurfaceDest->iVisRgnUniqueness != VISRGN_UNIQUENESS())) // 4)
                {
                    // The VisRgn changed since the application last queried
                    // it; fail the call with a unique error code so that
                    // they  know to requery the VisRgn and try again:

                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_VISRGNCHANGED;
                }
                else
                {
                    if (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps & DDCAPS_BLT)
                    {
                        BltData.lpDD = peDirectDrawGlobal;

                        // Give GDI a crack at doing the Blt.  GDI may handle
                        // the blt only for the following cases:
                        //
                        // o When the blt occurs underneath a simulated sprite;
                        // o To emulate system-memory to video-memory HEL blts.

                        dwRet = dwDdBltViaGdi(peSurfaceDest,
                                              peSurfaceSrc,
                                              &BltData);

                        if (dwRet != DDHAL_DRIVER_HANDLED)
                        {
                            // This is the normal code path.  First, exclude the
                            // mouse pointer and any other sprites if necessary:

                            DEVEXCLUDERECT dxo;

                            if (peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY)
                            {
                                dxo.vExclude(peDirectDrawGlobal->hdev,
                                               &BltData.rDest);
                            }

                            // Call the driver to do the blt:

                            dwRet = peDirectDrawGlobal->SurfaceCallBacks.
                                            Blt(&BltData);

                            // If there was a flip pending, and the hardware
                            // blt succeeded, then unset the flag:

                            if ((peSurfaceDest->fl & DD_SURFACE_FLAG_FLIP_PENDING) &&
                                (dwRet == DDHAL_DRIVER_HANDLED) &&
                                (BltData.ddRVal == DD_OK))
                            {
                                peSurfaceDest->fl &= ~DD_SURFACE_FLAG_FLIP_PENDING;
                            }
                        }

                        // If the destination surface is the primary, update
                        // the bounds rect for this device:

                        if ((peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY) &&
                            (dwRet == DDHAL_DRIVER_HANDLED) &&
                            (BltData.ddRVal == DD_OK))
                        {
                            // Union the current DirectDraw bounds rectangle
                            // with the destination blt rectangle:
                            //
                            // BltData.IsClipped will always be FALSE since
                            // it is currently unsupported, so we only
                            // consider BltData.rDest:

                            if (peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_BOUNDS_SET)
                            {
                                if (BltData.rDest.left < peDirectDrawGlobal->rclBounds.left)
                                    peDirectDrawGlobal->rclBounds.left = BltData.rDest.left;

                                if (BltData.rDest.top < peDirectDrawGlobal->rclBounds.top)
                                    peDirectDrawGlobal->rclBounds.top = BltData.rDest.top;

                                if (BltData.rDest.right > peDirectDrawGlobal->rclBounds.right)
                                    peDirectDrawGlobal->rclBounds.right = BltData.rDest.right;

                                if (BltData.rDest.bottom > peDirectDrawGlobal->rclBounds.bottom)
                                    peDirectDrawGlobal->rclBounds.bottom = BltData.rDest.bottom;
                            }
                            else
                            {
                                peDirectDrawGlobal->rclBounds = BltData.rDest;
                                peDirectDrawGlobal->fl |= DD_GLOBAL_FLAG_BOUNDS_SET;
                            }
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDdBlt: Invalid destination rectangle\n");
            }
        }
        else
        {
            WARNING("DxDdBlt: Invalid dwFlags\n");
        }
    }
    else
    {
        WARNING("DxDdBlt: Couldn't lock destination surface\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puBltData->ddRVal, BltData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdFlip
*
* DirectDraw flip.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/
DWORD
APIENTRY
DxDdFlip(
    HANDLE       hSurfaceCurrent,
    HANDLE       hSurfaceTarget,
    HANDLE       hSurfaceCurrentLeft,
    HANDLE       hSurfaceTargetLeft,
    PDD_FLIPDATA puFlipData
    )
{
    DWORD       dwRet;
    DD_FLIPDATA FlipData;

    __try
    {
        FlipData = ProbeAndReadStructure(puFlipData, DD_FLIPDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet           = DDHAL_DRIVER_NOTHANDLED;
    FlipData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurfaceCurrent;
    EDD_SURFACE*            peSurfaceCurrentLeft;
    EDD_SURFACE*            peSurfaceTarget;
    EDD_SURFACE*            peSurfaceTargetLeft;
    EDD_LOCK_SURFACE        eLockSurfaceCurrent;
    EDD_LOCK_SURFACE        eLockSurfaceCurrentLeft;
    EDD_LOCK_SURFACE        eLockSurfaceTarget;
    EDD_LOCK_SURFACE        eLockSurfaceTargetLeft;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurfaceCurrent = eLockSurfaceCurrent.peLock(hSurfaceCurrent);
    peSurfaceTarget  = eLockSurfaceTarget.peLock(hSurfaceTarget);

    BOOL bLeftSurfaceOk=FALSE;

    if (FlipData.dwFlags & DDFLIP_STEREO)
    {
        peSurfaceTargetLeft  = eLockSurfaceTargetLeft.peLock(hSurfaceTargetLeft);
        peSurfaceCurrentLeft = eLockSurfaceCurrentLeft.peLock(hSurfaceCurrentLeft);

        // first check if left surface is ok
        // in stereo mode

        if ((peSurfaceCurrentLeft != NULL) &&
            (peSurfaceTargetLeft != NULL) &&
            (peSurfaceCurrent != peSurfaceTargetLeft) &&
            (peSurfaceCurrent != peSurfaceCurrentLeft) &&
            (peSurfaceTarget != peSurfaceTargetLeft) &&
            (peSurfaceTarget != peSurfaceCurrentLeft) &&
            (peSurfaceCurrentLeft != peSurfaceTargetLeft) &&
            (peSurfaceCurrent->peDirectDrawLocal ==
                peSurfaceTargetLeft->peDirectDrawLocal) &&
            (peSurfaceCurrent->peDirectDrawLocal ==
                peSurfaceCurrentLeft->peDirectDrawLocal)
        )
        {
           bLeftSurfaceOk=TRUE;
        } else
        {
          peSurfaceTargetLeft = NULL;
          peSurfaceCurrentLeft = NULL;
        }
    } else
    {
      peSurfaceTargetLeft = NULL;
      peSurfaceCurrentLeft = NULL;
      bLeftSurfaceOk=TRUE;
    }

    // Make sure surfaces belong to the same DirectDraw object and no
    // bad commands are specified:

    if ( bLeftSurfaceOk &&
        (peSurfaceCurrent != NULL) &&
        (peSurfaceTarget != NULL) &&
        (peSurfaceCurrent->peDirectDrawLocal ==
                peSurfaceTarget->peDirectDrawLocal) &&
        ((FlipData.dwFlags & ~DDFLIP_VALID) == 0))
    {
        peDirectDrawGlobal = peSurfaceCurrent->peDirectDrawGlobal;

        // Flipping to the same surface is OK as long as it's an overlay
        // and the ODD/EVEN flag is specified and supported by the driver

        if ((peSurfaceCurrent != peSurfaceTarget) ||
            ((FlipData.dwFlags & (DDFLIP_EVEN|DDFLIP_ODD)) &&
            ( peSurfaceCurrent->ddsCaps.dwCaps & DDSCAPS_OVERLAY ) &&
            (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 & DDCAPS2_CANFLIPODDEVEN)))
        {

            // Make sure that the target is flippable:
            if (peSurfaceCurrentLeft != NULL && peSurfaceTargetLeft != NULL)
            {
                if (!((peSurfaceCurrent->wHeight == peSurfaceTargetLeft->wHeight) &&
                    (peSurfaceCurrent->wWidth  == peSurfaceTargetLeft->wWidth) &&
                    (peSurfaceCurrentLeft->wHeight == peSurfaceTargetLeft->wHeight) &&
                    (peSurfaceCurrentLeft->wWidth  == peSurfaceTargetLeft->wWidth) &&
                    !(peSurfaceCurrentLeft->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                    !(peSurfaceTargetLeft->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)))
                {
                    bLeftSurfaceOk = FALSE;
                }
            }

            if ( bLeftSurfaceOk &&
                (peDirectDrawGlobal->SurfaceCallBacks.dwFlags & DDHAL_SURFCB32_FLIP) &&
                (peSurfaceCurrent->wHeight == peSurfaceTarget->wHeight) &&
                (peSurfaceCurrent->wWidth  == peSurfaceTarget->wWidth) &&
                !(peSurfaceCurrent->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                !(peSurfaceTarget->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
            {
                FlipData.lpDD       = peDirectDrawGlobal;
                FlipData.lpSurfCurr = peSurfaceCurrent;
                FlipData.lpSurfCurrLeft = peSurfaceCurrentLeft;
                FlipData.lpSurfTarg = peSurfaceTarget;
                FlipData.lpSurfTargLeft = peSurfaceTargetLeft;

                EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                if (peSurfaceCurrentLeft != NULL && peSurfaceTargetLeft != NULL)
                {
                    bLeftSurfaceOk =!(peSurfaceCurrentLeft->bLost) &&
                                    !(peSurfaceTargetLeft->bLost);
                }

                if (!bLeftSurfaceOk ||
                    (peSurfaceCurrent->bLost) ||
                    (peSurfaceTarget->bLost))
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    FlipData.ddRVal = DDERR_SURFACELOST;
                }
                else
                {
                    dwRet = peDirectDrawGlobal->SurfaceCallBacks.Flip(&FlipData);

                    // Remember this surface so that if it gets deleted, we can
                    // flip back to the GDI surface, assuming it's not an
                    // overlay surface:

                    if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                        (FlipData.ddRVal == DD_OK))
                    {
                        // Keep track of the hardware flip on this surface so if
                        // we do emulated blts to it, we will wait for the flip
                        // to complete first:

                        if(peSurfaceCurrent != peSurfaceTarget)
                        {
                            peSurfaceCurrent->fl |= DD_SURFACE_FLAG_FLIP_PENDING;
                        }

                        if(peSurfaceTarget->ddsCaps.dwCaps & DDSCAPS_OVERLAY)
                        {
                            if(peSurfaceCurrent->fl & DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED)
                            {
                                peSurfaceTarget->fl |= DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED;
                                if(peSurfaceCurrent != peSurfaceTarget)
                                {
                                    peSurfaceCurrent->fl &= ~DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED;
                                }
                            }
                        }
                        else
                        {
                            peSurfaceCurrent->ddsCaps.dwCaps &= ~DDSCAPS_PRIMARYSURFACE;
                            peSurfaceTarget->ddsCaps.dwCaps  |= DDSCAPS_PRIMARYSURFACE;

                            peDirectDrawGlobal->peSurfaceCurrent = peSurfaceTarget;
                            if (peSurfaceCurrent->fl & DD_SURFACE_FLAG_PRIMARY)
                            {
                                peDirectDrawGlobal->peSurfacePrimary
                                                    = peSurfaceCurrent;
                            }
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDdFlip: Non-flippable surface\n");
            }
        }
        else
        {
            WARNING("DxDdFlip: Invalid flip to same surface\n");
        }
    }
    else
    {
        WARNING("DxDdFlip: Invalid surfaces or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puFlipData->ddRVal, FlipData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}


/******************************Public*Routine******************************\
* DWORD DxDdLock
*
* DirectDraw function to return a user-mode pointer to the screen or
* off-screen surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdLock(
    HANDLE       hSurface,
    PDD_LOCKDATA puLockData,
    HDC          hdcClip
    )
{
    DD_LOCKDATA LockData;

    __try
    {
        LockData = ProbeAndReadStructure(puLockData, DD_LOCKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    LockData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*        peSurface;
    EDD_LOCK_SURFACE    eLockSurface;

    // Note that we have to let down DDLOCK_READONLY, DDLOCK_WRITE,
    // and DDLOCK_WAIT for compatibility.  Note also that a
    // DDLOCK_SURFACEMEMORY flag also gets passed down by default.

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        ((LockData.dwFlags & ~(DDLOCK_VALID)) == 0))
    {
        LockData.lpSurfData = pDdLockSurfaceOrBuffer(peSurface,
                                                     LockData.bHasRect,
                                                     &LockData.rArea,
                                                     // We remove the wait flag since it better to spin in user mode
                                                     LockData.dwFlags & (~DDLOCK_WAIT),
                                                     &LockData.ddRVal);
    }
    else
    {
        WARNING("DxDdLock: Invalid surface or flags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteHandle(&puLockData->lpSurfData, LockData.lpSurfData);
        ProbeAndWriteRVal(&puLockData->ddRVal,       LockData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // This function must always return DDHAL_DRIVER_HANDLED, otherwise
    // DirectDraw will simply use the 'fpVidMem' value, which on NT is
    // an offset and not a pointer:

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DxDdUnlock
*
* DirectDraw unlock.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdUnlock(
    HANDLE         hSurface,
    PDD_UNLOCKDATA puUnlockData
    )
{
    DWORD         dwRet;
    DD_UNLOCKDATA UnlockData;

    __try
    {
        UnlockData = ProbeAndReadStructure(puUnlockData, DD_UNLOCKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    UnlockData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        if (bDdUnlockSurfaceOrBuffer(peSurface))
        {
            UnlockData.ddRVal = DD_OK;
        }
    }
    else
    {
        WARNING("DxDdUnlock: Invalid surface\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puUnlockData->ddRVal, UnlockData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DxDdLockD3D
*
* DirectDraw function to return a user-mode pointer to the screen or
* off-screen surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdLockD3D(
    HANDLE       hSurface,
    PDD_LOCKDATA puLockData
    )
{
    DD_LOCKDATA LockData;

    __try
    {
        LockData = ProbeAndReadStructure(puLockData, DD_LOCKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    LockData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*        peSurface;
    EDD_LOCK_SURFACE    eLockSurface;

    // Note that we have to let down DDLOCK_READONLY, DDLOCK_WRITE,
    // and DDLOCK_WAIT for compatibility.  Note also that a
    // DDLOCK_SURFACEMEMORY flag also gets passed down by default.

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        ((LockData.dwFlags & ~(DDLOCK_VALID)) == 0))
    {
        LockData.lpSurfData = pDdLockSurfaceOrBuffer(peSurface,
                                                     LockData.bHasRect,
                                                     &LockData.rArea,
                                                     // We remove the wait flag since it better to spin in user mode
                                                     LockData.dwFlags & (~DDLOCK_WAIT),
                                                     &LockData.ddRVal);
    }
    else
    {
        WARNING("DxDdLockD3D: Invalid surface or flags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteHandle(&puLockData->lpSurfData, LockData.lpSurfData);
        ProbeAndWriteRVal(&puLockData->ddRVal,       LockData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // This function must always return DDHAL_DRIVER_HANDLED, otherwise
    // DirectDraw will simply use the 'fpVidMem' value, which on NT is
    // an offset and not a pointer:

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DxDdUnlockD3D
*
* DirectDraw unlock.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdUnlockD3D(
    HANDLE         hSurface,
    PDD_UNLOCKDATA puUnlockData
    )
{
    DWORD         dwRet;
    DD_UNLOCKDATA UnlockData;

    __try
    {
        UnlockData = ProbeAndReadStructure(puUnlockData, DD_UNLOCKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    UnlockData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        if (bDdUnlockSurfaceOrBuffer(peSurface))
        {
            UnlockData.ddRVal = DD_OK;
        }
    }
    else
    {
        WARNING("DxDdUnlockD3D: Invalid surface\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puUnlockData->ddRVal, UnlockData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(DDHAL_DRIVER_HANDLED);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetFlipStatus
*
* DirectDraw API to get the page-flip status.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetFlipStatus(
    HANDLE                hSurface,
    PDD_GETFLIPSTATUSDATA puGetFlipStatusData
    )
{
    DWORD                dwRet;
    DD_GETFLIPSTATUSDATA GetFlipStatusData;

    __try
    {
        GetFlipStatusData = ProbeAndReadStructure(puGetFlipStatusData,
                                                  DD_GETFLIPSTATUSDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_NOTHANDLED;
    GetFlipStatusData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        ((GetFlipStatusData.dwFlags & ~(DDGFS_CANFLIP
                                      | DDGFS_ISFLIPDONE)) == 0))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_GETFLIPSTATUS)
        {
            GetFlipStatusData.lpDD        = peDirectDrawGlobal;
            GetFlipStatusData.lpDDSurface = peSurface;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peSurface->bLost)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                GetFlipStatusData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                        SurfaceCallBacks.GetFlipStatus(&GetFlipStatusData);

                // If a flip was pending, and has completed, then turn off
                // the flag:

                if ((peSurface->fl & DD_SURFACE_FLAG_FLIP_PENDING) &&
                    (GetFlipStatusData.dwFlags & DDGFS_ISFLIPDONE) &&
                    (dwRet == DDHAL_DRIVER_HANDLED) &&
                    (GetFlipStatusData.ddRVal == DD_OK))
                {
                    peSurface->fl &= ~DD_SURFACE_FLAG_FLIP_PENDING;
                }
            }
        }
    }
    else
    {
        WARNING("DxDdGetFlipStatus: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetFlipStatusData->ddRVal,
                          GetFlipStatusData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetBltStatus
*
* DirectDraw API to get the accelerator's accelerator status.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetBltStatus(
    HANDLE               hSurface,
    PDD_GETBLTSTATUSDATA puGetBltStatusData
    )
{
    DWORD               dwRet;
    DD_GETBLTSTATUSDATA GetBltStatusData;

    __try
    {
        GetBltStatusData = ProbeAndReadStructure(puGetBltStatusData,
                                                 DD_GETBLTSTATUSDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                   = DDHAL_DRIVER_NOTHANDLED;
    GetBltStatusData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        ((GetBltStatusData.dwFlags & ~(DDGBS_CANBLT
                                     | DDGBS_ISBLTDONE)) == 0))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_GETBLTSTATUS)
        {
            GetBltStatusData.lpDD        = peDirectDrawGlobal;
            GetBltStatusData.lpDDSurface = peSurface;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peSurface->bLost)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                GetBltStatusData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    SurfaceCallBacks.GetBltStatus(&GetBltStatusData);
            }
        }
    }
    else
    {
        WARNING("DxDdGetBltStatus: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetBltStatusData->ddRVal, GetBltStatusData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdWaitForVerticalBlank
*
* DirectDraw API to wait for vertical blank.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdWaitForVerticalBlank(
    HANDLE                       hDirectDraw,
    PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData
    )
{
    DWORD                       dwRet;
    DD_WAITFORVERTICALBLANKDATA WaitForVerticalBlankData;

    __try
    {
        WaitForVerticalBlankData =
            ProbeAndReadStructure(puWaitForVerticalBlankData,
                                  DD_WAITFORVERTICALBLANKDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                           = DDHAL_DRIVER_NOTHANDLED;
    WaitForVerticalBlankData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if ((peDirectDrawLocal != NULL) &&
        ((WaitForVerticalBlankData.dwFlags & ~(DDWAITVB_I_TESTVB
                                             | DDWAITVB_BLOCKBEGIN
                                             | DDWAITVB_BLOCKBEGINEVENT
                                             | DDWAITVB_BLOCKEND)) == 0) &&
        (WaitForVerticalBlankData.dwFlags != 0))
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (peDirectDrawGlobal->CallBacks.dwFlags &
                    DDHAL_CB32_WAITFORVERTICALBLANK)
        {
            WaitForVerticalBlankData.lpDD = peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peDirectDrawGlobal->bSuspended)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                WaitForVerticalBlankData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    CallBacks.WaitForVerticalBlank(&WaitForVerticalBlankData);
            }
        }
    }
    else
    {
        WARNING("DxDdWaitForVerticalBlank: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puWaitForVerticalBlankData->ddRVal,
                          WaitForVerticalBlankData.ddRVal);
        ProbeAndWriteUlong(&puWaitForVerticalBlankData->bIsInVB,
                           WaitForVerticalBlankData.bIsInVB);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD dwDdCanCreateSurfaceOrBuffer
*
* Handles DxDdCanCreateSurface and DxDdCanCreateD3DBuffer.
*
*  3-Feb-1998 -by- Drew Bliss [drewb]
* Merged common code from calling routines.
\**************************************************************************/

DWORD
dwDdCanCreateSurfaceOrBuffer(
    BOOL                     bSurface,
    HANDLE                   hDirectDraw,
    PDD_CANCREATESURFACEDATA puCanCreateSurfaceData
    )
{
    DWORD                   dwRet;
    DD_CANCREATESURFACEDATA CanCreateSurfaceData;
    DDSURFACEDESC2*         puSurfaceDescription;
    DDSURFACEDESC2          SurfaceDescription;

    __try
    {
        CanCreateSurfaceData = ProbeAndReadStructure(puCanCreateSurfaceData,
                                                     DD_CANCREATESURFACEDATA);

        puSurfaceDescription = (DDSURFACEDESC2 *)CanCreateSurfaceData.lpDDSurfaceDesc;

        SurfaceDescription  = ProbeAndReadStructure(puSurfaceDescription,
                                                    DDSURFACEDESC2);

        CanCreateSurfaceData.lpDDSurfaceDesc = (DDSURFACEDESC*)&SurfaceDescription;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    // All video memory heaps are handled in the kernel so if
    // this routine cannot create a surface then user-mode can't
    // either.  Always returns DRIVER_HANDLED to enforce this.
    dwRet                       = DDHAL_DRIVER_HANDLED;
    CanCreateSurfaceData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        // Choose function to call.
        PDD_CANCREATESURFACE pfnCanCreate;

        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if (bSurface)
        {
            pfnCanCreate =
                (peDirectDrawGlobal->CallBacks.dwFlags &
                 DDHAL_CB32_CANCREATESURFACE) ?
                 peDirectDrawGlobal->CallBacks.CanCreateSurface :
                NULL;
        }
        else
        {
            pfnCanCreate =
                peDirectDrawGlobal->D3dBufCallbacks.CanCreateD3DBuffer;
        }

        if (pfnCanCreate != NULL)
        {
            CanCreateSurfaceData.lpDD = peDirectDrawGlobal;

            if (!peDirectDrawGlobal->bSuspended)
            {
                dwRet = pfnCanCreate(&CanCreateSurfaceData);
            }
            else
            {
                CanCreateSurfaceData.ddRVal = DDERR_SURFACELOST;
            }
        }
        else
        {
            WARNING("dwDdCanCreateSurface: Driver doesn't hook call\n");
        }
    }
    else
    {
        WARNING("dwDdCanCreateSurface: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puCanCreateSurfaceData->ddRVal,
                          CanCreateSurfaceData.ddRVal);
        ProbeAndWriteStructure(puSurfaceDescription,
                               SurfaceDescription,
                               DDSURFACEDESC);
        // Driver can update ddpfPixelFormat.dwYUVBitCount
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdCanCreateSurface
*
* Queries the driver to determine whether it can support a DirectDraw
* surface that is different from the primary display.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdCanCreateSurface(
    HANDLE                   hDirectDraw,
    PDD_CANCREATESURFACEDATA puCanCreateSurfaceData
    )
{
    return dwDdCanCreateSurfaceOrBuffer(TRUE, hDirectDraw,
                                        puCanCreateSurfaceData);
}

/******************************Public*Routine******************************\
* DWORD DxDdCanCreateD3DBuffer
*
* Queries the driver to determine whether it can support a given D3D Buffer
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdCanCreateD3DBuffer(
    HANDLE                   hDirectDraw,
    PDD_CANCREATESURFACEDATA puCanCreateSurfaceData
    )
{
    return dwDdCanCreateSurfaceOrBuffer(FALSE, hDirectDraw,
                                        puCanCreateSurfaceData);
}

/******************************Public*Routine******************************\
* HRESULT hrDdCommitAgpSurface
*
* Ensures that user-mode addresses are reserved in the current process
* and commits pages for the given surface.
*
*  7-May-1998 -by- Drew Bliss [drewb]
* Wrote it.
\**************************************************************************/

HRESULT
hrDdCommitAgpSurface(
    EDD_SURFACE*    peSurface,
    DWORD           dwSurfaceSize
    )
{
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_VMEMMAPPING*        peMap;
    VIDEOMEMORY*            pvmHeap;
    DWORD                   iHeapIndex;

    peDirectDrawLocal = peSurface->peDirectDrawLocal;
    peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    pvmHeap = peSurface->lpVidMemHeap;

    ASSERTGDI(peDirectDrawLocal->ppeMapAgp != NULL,
              "Committing AGP surface with no heaps\n");

    iHeapIndex = (DWORD) (pvmHeap - peDirectDrawGlobal->pvmList);
    peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
    if (peMap == NULL)
    {
        MapAllAgpHeaps(peDirectDrawLocal);
        peMap = peDirectDrawLocal->ppeMapAgp[iHeapIndex];
        if (peMap == NULL)
        {
            return DDERR_OUTOFMEMORY;
        }
    }

    peSurface->fpVidMem =
        (FLATPTR)(peMap->pvVirtAddr) +
        (peSurface->fpHeapOffset - pvmHeap->fpStart);
    return DD_OK;
}

/******************************Public*Routine******************************\
* HRESULT hrDdAllocSurface
*
* Allocates memory for the given surface.
*
*  3-Feb-1998 -by- Drew Bliss [drewb]
* Wrote it.
\**************************************************************************/

HRESULT
hrDdAllocSurface(
    EDD_DIRECTDRAW_LOCAL* peDirectDrawLocal,
    EDD_DIRECTDRAW_GLOBAL* peDirectDrawGlobal,
    EDD_SURFACE* peSurface
    )
{
    HRESULT hr = DDERR_OUTOFVIDEOMEMORY;
    BOOL bAllowNewPitch = TRUE;

    DD_ASSERTDEVLOCK(peDirectDrawGlobal);

    ASSERTGDI(!(peSurface->ddsCaps.dwCaps & (DDSCAPS_SYSTEMMEMORY |
                                             DDSCAPS_PRIMARYSURFACE)),
              "hrDdAllocSurface: System-memory or primary request");

    // If 'fpVidMem' is DDHAL_PLEASEALLOC_USERMEM, that means
    // the driver wants us to allocate a chunk of user-mode
    // memory on the driver's behalf:

    if (peSurface->fpVidMem == DDHAL_PLEASEALLOC_USERMEM)
    {
        // The driver was involved in this surface creation so
        // mark it as such.
        peSurface->fl |= DD_SURFACE_FLAG_DRIVER_CREATED;
    
        peSurface->fpVidMem =
            (FLATPTR) EngAllocUserMem(peSurface->dwUserMemSize, 'pddG');
        if (peSurface->fpVidMem != 0)
        {
            peSurface->fl |= DD_SURFACE_FLAG_UMEM_ALLOCATED;
            hr = DD_OK;

            DDKHEAP(("DDKHEAP: New um %08X, surf %X (%X)\n",
                     peSurface->fpVidMem, peSurface->hGet(), peSurface));
        }
        else
        {
            hr = DDERR_OUTOFMEMORY;
        }

        // FIX: WINBUG #388284
        //
        // - MATROX G200: STRESS: dxg ASSERT when YV12 overlay surface gets created in system memory
        //
        // Set bAllowNewPitch to FALSE to avoid hitting assertion in below.
        //
        // Matrox G200 does not support YU12 overlay surface format, but they want to
        // support this format for application compatibility, thus video driver ask us
        // to allocate YU12 overlay surface in system memory, so that they can Blt
        // with software emulation.

        bAllowNewPitch = FALSE;
    }
    else
    {
        DWORD dwWidth, dwHeight;
        DWORD dwSurfaceSize;

        if (peSurface->fpVidMem == DDHAL_PLEASEALLOC_BLOCKSIZE)
        {
            // The driver wants a surface of a particular size to be
            // allocated.
            dwWidth = peSurface->dwBlockSizeX;
            dwHeight = peSurface->dwBlockSizeY;
            bAllowNewPitch = FALSE;

            // The driver was involved in this surface creation so
            // mark it as such.
            peSurface->fl |= DD_SURFACE_FLAG_DRIVER_CREATED;
        }
        else
        {
            // The driver didn't specify a size so determine it from
            // the surface dimensions.

            if (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
            {
                // Execute buffers are long, thin surfaces for the purposes
                // of VM allocation.
                dwWidth = peSurface->dwLinearSize;
                dwHeight = 1;
            }
            else
            {
                // This lPitch may have been expanded by ComputePitch
                // to cover global alignment restrictions.
                dwWidth = labs(peSurface->lPitch);
                dwHeight = peSurface->wHeight;
            }

            // The driver didn't do anything special for this allocation
            // so don't call it when the surface is destroyed.
        }

        DWORD dwFlags = 0;

        // In user mode DDHA_SKIPRECTANGULARHEAPS keys off of
        // DDRAWISURFGBL_LATEALLOCATELINEAR.  Right now we just leave
        // it off.

        if (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps2 &
            DDCAPS2_NONLOCALVIDMEMCAPS)
        {
            dwFlags |= DDHA_ALLOWNONLOCALMEMORY;
        }

        if (peDirectDrawGlobal->D3dDriverData.hwCaps.dwDevCaps &
            D3DDEVCAPS_TEXTURENONLOCALVIDMEM)
        {
            dwFlags |= DDHA_ALLOWNONLOCALTEXTURES;
        }

        LONG lNewPitch = 0;
        DWORD dwNewCaps = 0;
        DWORD dwRet;
        DD_FREEDRIVERMEMORYDATA FreeDriverMemoryData;

        do {
            dwRet = DDHAL_DRIVER_NOTHANDLED;

            // Attempt to allocate the surface.
            peSurface->fpHeapOffset =
                DdHeapAlloc(peDirectDrawGlobal->dwNumHeaps,
                            peDirectDrawGlobal->pvmList,
                            AGP_HDEV(peDirectDrawGlobal),
                            &peDirectDrawGlobal->HalInfo.vmiData,
                            dwWidth,
                            dwHeight,
                            peSurface,
                            dwFlags,
                            &peSurface->lpVidMemHeap,
                            &lNewPitch,
                            &dwNewCaps,
                            &dwSurfaceSize);

            // If the surface could not be allocated, try calling the
            // driver to see if it can free up some room (such as by
            // getting rid of GDI surfaces).
            if ((peSurface->fpHeapOffset == 0) &&
                !(peDirectDrawGlobal->bSuspended) &&
                (peDirectDrawGlobal->NTCallBacks.dwFlags &
                    DDHAL_NTCB32_FREEDRIVERMEMORY))
            {
                DD_ASSERTDEVLOCK(peDirectDrawGlobal);

                FreeDriverMemoryData.lpDD = peDirectDrawGlobal;
                FreeDriverMemoryData.lpDDSurface = peSurface;
                FreeDriverMemoryData.ddRVal = DDERR_GENERIC;

                dwRet = peDirectDrawGlobal->NTCallBacks.
                    FreeDriverMemory(&FreeDriverMemoryData);
            }
        } while ((dwRet == DDHAL_DRIVER_HANDLED) &&
                 (FreeDriverMemoryData.ddRVal == DD_OK));

        // If the surface could not be allocated with the optimal caps,
        // try allocating with the alternate caps.
        if (peSurface->fpHeapOffset == 0)
        {
            peSurface->fpHeapOffset =
                DdHeapAlloc(peDirectDrawGlobal->dwNumHeaps,
                            peDirectDrawGlobal->pvmList,
                            AGP_HDEV(peDirectDrawGlobal),
                            &peDirectDrawGlobal->HalInfo.vmiData,
                            dwWidth,
                            dwHeight,
                            peSurface,
                            dwFlags | DDHA_USEALTCAPS,
                            &peSurface->lpVidMemHeap,
                            &lNewPitch,
                            &dwNewCaps,
                            &dwSurfaceSize);
        }

        if (peSurface->fpHeapOffset != 0)
        {
            // If this surface was allocated from an AGP heap then
            // we must make sure that the heap has a user-mode mapping
            // for this process and we must commit the necessary user-mode
            // pages.
            if (dwNewCaps & DDSCAPS_NONLOCALVIDMEM)
            {
                hr = hrDdCommitAgpSurface(peSurface, dwSurfaceSize);

                if (hr != DD_OK)
                {
                    DxDdHeapVidMemFree(peSurface->lpVidMemHeap->lpHeap,
                                       peSurface->fpHeapOffset);
                    return hr;
                }
            }
            else
            {
                peSurface->fpVidMem = peSurface->fpHeapOffset;
            }

            hr = DD_OK;
            peSurface->fl |= DD_SURFACE_FLAG_VMEM_ALLOCATED;

            // The particular heap that was used for the allocation may
            // modify certain aspects of the surface.  Update the surface
            // to reflect any changes.
            //
            // The stride is not relevant for an execute buffer so we don't
            // override it in that case.

            if (lNewPitch != 0 && bAllowNewPitch &&
                !(peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
            {
                peSurface->lPitch = lNewPitch;
            }

            peSurface->ddsCaps.dwCaps |= dwNewCaps;

            ASSERTGDI((peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) ||
                      peSurface->lPitch > 0,
                      "Unexpected negative surface pitch");
            ASSERTGDI((peSurface->fl & DD_SURFACE_FLAG_DRIVER_CREATED) ||
                      ((peSurface->ddpfSurface.dwFlags &
                        (DDPF_RGB | DDPF_ZBUFFER)) &&
                       (peSurface->ddsCaps.dwCaps & DDSCAPS_OVERLAY) == 0),
                      "Unexpected non-driver surface type");

            DDKHEAP(("DDKHEAP: New vm %08X, o %08X, heap %X, surf %X (%X)\n",
                     peSurface->fpVidMem, peSurface->fpHeapOffset,
                     peSurface->lpVidMemHeap->lpHeap,
                     peSurface->hGet(), peSurface));
        }
    }

#if DBG
    if (hr == DD_OK &&
        (peSurface->ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER) == 0)
    {
        ASSERTGDI((peSurface->fpVidMem & 3) == 0 &&
                  (peSurface->lPitch & 3) == 0,
                  "Unaligned surface pointer or pitch");
        ASSERTGDI(ABS(peSurface->lPitch) <= 4 * DD_MAXIMUM_COORDINATE,
                  "Pitch out of range");

        // The width in bytes must not be more than the pitch.
        // There are weird cases when this is actually valid (e.g. planar YUV formats), but in all
        // such cases it would involve FOURCCs and the driver telling us which block size to allocate.
        ASSERTGDI((peSurface->wWidth * peSurface->ddpfSurface.dwRGBBitCount <=
                  (ULONG) 8 * ABS(peSurface->lPitch) ||
                  (!bAllowNewPitch && (peSurface->ddpfSurface.dwFlags & DDPF_FOURCC))),
                  "Pitch less than width");
    }
#endif

    return hr;
}

/******************************Public*Routine******************************\
* DWORD dwDdCreateSurfaceOrBuffer
*
* Handles DxDdCreateSurface and DxDdCreateD3DBuffer.
*
*  3-Feb-1998 -by- Drew Bliss [drewb]
* Merged common code from calling functions.
\**************************************************************************/

DWORD dwDdCreateSurfaceOrBuffer(
    HANDLE                  hDirectDraw,
    HANDLE*                 phSurfaceHandles,
    DDSURFACEDESC*          puSurfaceDescription,
    DD_SURFACE_GLOBAL*      puSurfaceGlobalData,
    DD_SURFACE_LOCAL*       puSurfaceLocalData,
    DD_SURFACE_MORE*        puSurfaceMoreData,
    DD_CREATESURFACEDATA*   puCreateSurfaceData,
    HANDLE*                 puhReturnSurfaceHandles
    )
{
    DWORD                   dwRet;
    DD_CREATESURFACEDATA    CreateSurfaceData;
    DDSURFACEDESC2          SurfaceDescription;
    ULONG                   dwNumToCreate;
    HANDLE                  hSecureSurfaceHandles;
    HANDLE                  hSecureGlobals;
    HANDLE                  hSecureLocals;
    HANDLE                  hSecureMore;
    HANDLE                  hSecureReturn;
    ULONG                   cjHandles;
    ULONG                   cjGlobals;
    ULONG                   cjLocals;
    ULONG                   cjMore;
    ULONG                   i;
    ULONG                   j;
    ULONG                   k;
    BOOL                    bAutomicCreate;
    BOOL                    bNotifyCreation;
    ULONG                   dwStart;
    ULONG                   dwEnd;

    __try
    {
        CreateSurfaceData = ProbeAndReadStructure(puCreateSurfaceData,
                                                  DD_CREATESURFACEDATA);
        SurfaceDescription = ProbeAndReadStructure((DDSURFACEDESC2*)puSurfaceDescription,
                                                   DDSURFACEDESC2);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_HANDLED);
    }

    // All video memory heaps are handled in the kernel so if
    // this routine cannot create a surface then user-mode can't
    // either.  Always returns DRIVER_HANDLED to enforce this.

    dwRet                    = DDHAL_DRIVER_HANDLED;
    CreateSurfaceData.ddRVal = DDERR_GENERIC;
    dwNumToCreate = CreateSurfaceData.dwSCnt;

    EDD_SURFACE**           peSurface;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    DD_SURFACE_LOCAL*       pSurfaceLocal;
    BOOL                    bKeepSurface;
    PDD_CREATESURFACE       pfnCreate;

    DD_SURFACE_LOCAL**      pSList = NULL;
    EDD_SURFACE*            peSurfaceOnStack = NULL;
    BOOL                    bAnyType = TRUE;
    DWORD                   dwForceMemType = 0;

    peSurface = NULL;
    bKeepSurface = FALSE;
    bAutomicCreate = FALSE;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);

    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        // Hold the devlock throughout this process for
        // the driver call and to protect heap manipulations.

        EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

        if ((peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED) &&
            !(peDirectDrawGlobal->bSuspended))
        {
            // If the display pitch is 0 (which we should have already caught, but we want to
            // be safe), fail the call now or else vDdCompleteSurfaceObject will blue screen.

            if (peDirectDrawGlobal->HalInfo.vmiData.lDisplayPitch == 0)
            {
                CreateSurfaceData.ddRVal = DDERR_GENERIC;
            }
            else
            {
                // Secure all of the arrays that we are working with

                hSecureSurfaceHandles = 0;
                hSecureGlobals = 0;
                hSecureLocals = 0;
                hSecureMore = 0;
                hSecureReturn = 0;

                if (!BALLOC_OVERFLOW1(dwNumToCreate, HANDLE) &&
                    !BALLOC_OVERFLOW1(dwNumToCreate, DD_SURFACE_GLOBAL) &&
                    !BALLOC_OVERFLOW1(dwNumToCreate, DD_SURFACE_LOCAL) &&
                    !BALLOC_OVERFLOW1(dwNumToCreate, DD_SURFACE_MORE))
                {
                    cjHandles = dwNumToCreate * sizeof(HANDLE);
                    cjGlobals = dwNumToCreate * sizeof(DD_SURFACE_GLOBAL);
                    cjLocals = dwNumToCreate * sizeof(DD_SURFACE_LOCAL);
                    cjMore = dwNumToCreate * sizeof(DD_SURFACE_MORE);

                    if (phSurfaceHandles &&
                        puSurfaceGlobalData &&
                        puSurfaceLocalData &&
                        puSurfaceMoreData &&
                        puhReturnSurfaceHandles)
                    {
                        __try
                        {
                            ProbeForWrite(phSurfaceHandles, cjHandles, sizeof(UCHAR));
                            hSecureSurfaceHandles = MmSecureVirtualMemory(phSurfaceHandles,
                                                                          cjHandles,
                                                                          PAGE_READWRITE);

                            ProbeForWrite(puSurfaceGlobalData, cjGlobals, sizeof(UCHAR));
                            hSecureGlobals = MmSecureVirtualMemory(puSurfaceGlobalData,
                                                                   cjGlobals,
                                                                   PAGE_READWRITE);

                            ProbeForWrite(puSurfaceLocalData, cjLocals, sizeof(UCHAR));
                            hSecureLocals = MmSecureVirtualMemory(puSurfaceLocalData,
                                                                  cjLocals,
                                                                  PAGE_READWRITE);

                            ProbeForWrite(puSurfaceMoreData, cjMore, sizeof(UCHAR));
                            hSecureMore = MmSecureVirtualMemory(puSurfaceMoreData,
                                                                cjMore,
                                                                PAGE_READWRITE);

                            ProbeForWrite(puhReturnSurfaceHandles, cjHandles, sizeof(UCHAR));
                            hSecureReturn = MmSecureVirtualMemory(puhReturnSurfaceHandles,
                                                                  cjHandles,
                                                                  PAGE_READWRITE);
                            RtlZeroMemory(puhReturnSurfaceHandles, cjHandles);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                    }
                }

                // Allocate placeholder where we keep pointers to peSurface.

                if (dwNumToCreate > 1)
                {
                    peSurface = (EDD_SURFACE**) PALLOCMEM(sizeof(EDD_SURFACE*) * dwNumToCreate, 'pddG');
                }
                else
                {
                    peSurface = &peSurfaceOnStack;
                }
            }

            if ((hSecureSurfaceHandles != 0) &&
                (hSecureGlobals != 0) &&
                (hSecureLocals != 0) &&
                (hSecureMore != 0) &&
                (hSecureReturn != 0) &&
                (peSurface != NULL))
            {
                // if driver supports atomic creation and we are creating more than 1 surface,
                // allocate surface list.

                if ((peDirectDrawGlobal->PrivateCaps.dwPrivateCaps & DDHAL_PRIVATECAP_ATOMICSURFACECREATION) &&
                    (dwNumToCreate > 1))
                {
                    pSList = (DD_SURFACE_LOCAL**) PALLOCMEM(sizeof(DD_SURFACE_LOCAL*) * dwNumToCreate, 'pddG');
                    if (pSList != NULL)
                    {
                        bAutomicCreate = TRUE;
                    }
                }
                else
                {
                    pSList = NULL;
                }

                // Determine which function to call.

                if (puSurfaceLocalData[0].ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER)
                {
                    pfnCreate = peDirectDrawGlobal->D3dBufCallbacks.CreateD3DBuffer;
                }
                else
                {
                    pfnCreate =
                        (peDirectDrawGlobal->CallBacks.dwFlags &
                        DDHAL_CB32_CREATESURFACE) ?
                        peDirectDrawGlobal->CallBacks.CreateSurface :
                        NULL;
                }

                CreateSurfaceData.ddRVal = DD_OK;

                for (i = 0; (i < dwNumToCreate) && (CreateSurfaceData.ddRVal == DD_OK); i++)
                {
                    // Do some basic parameter checking to avoid creating
                    // surfaces based on bad information.

                    if (!(puSurfaceLocalData[i].ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                        bDdValidateSurfaceDescription(&puSurfaceGlobalData[i], &puSurfaceLocalData[i]))
                    {
                        peSurface[i] = peDdOpenNewSurfaceObject(peDirectDrawLocal,
                                                                phSurfaceHandles[i],
                                                                &puSurfaceGlobalData[i],
                                                                &puSurfaceLocalData[i],
                                                                &puSurfaceMoreData[i]);
                        if (peSurface[i] != NULL)
                        {
                            bKeepSurface = TRUE;
                            dwRet = DDHAL_DRIVER_NOTHANDLED;

                            pSurfaceLocal = peSurface[i];

                            peSurface[i]->fpVidMem = 0;
                            peSurface[i]->fpHeapOffset = 0;
                            peSurface[i]->hCreatorProcess =
                            peDirectDrawLocal->UniqueProcess;

                            // Setup some internal flags that are required because some
                            // drivers look at them and not setting them for NT5 cause
                            // regressions in NT4 drivers and incompatibilites between
                            // Win9X driver code.

                            if ((SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_OVERLAY) ||
                                ((SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE) &&
                                (peDirectDrawGlobal->HalInfo.ddCaps.dwCaps & DDCAPS_OVERLAY)))
                            {
                                peSurface[i]->dwFlags |= DDRAWISURF_HASOVERLAYDATA;
                                puSurfaceLocalData[i].dwFlags |= DDRAWISURF_HASOVERLAYDATA;
                            }

                            if (SurfaceDescription.dwFlags & DDSD_PIXELFORMAT)
                            {
                                if (!(SurfaceDescription.ddpfPixelFormat.dwFlags & DDPF_RGB) ||
                                    (SurfaceDescription.ddpfPixelFormat.dwRGBBitCount !=
                                        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBBitCount) ||
                                    ((SurfaceDescription.ddpfPixelFormat.dwRGBBitCount != 8) &&
                                    ((SurfaceDescription.ddpfPixelFormat.dwRBitMask !=
                                        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRBitMask) ||
                                    (SurfaceDescription.ddpfPixelFormat.dwGBitMask !=
                                        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwGBitMask) ||
                                    (SurfaceDescription.ddpfPixelFormat.dwBBitMask !=
                                        peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwBBitMask) ||
                                    ((SurfaceDescription.ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS) &&
                                    (!(peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwFlags & DDPF_ALPHAPIXELS) ||
                                    (SurfaceDescription.ddpfPixelFormat.dwRGBAlphaBitMask !=
                                    peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay.dwRGBAlphaBitMask))))))
                                {
                                    if (!(SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_EXECUTEBUFFER))
                                    {
                                        peSurface[i]->dwFlags |= DDRAWISURF_HASPIXELFORMAT;
                                        puSurfaceLocalData[i].dwFlags |= DDRAWISURF_HASPIXELFORMAT;
                                    }
                                }
                            }

                            // If this is an automic create, we need to complete all of the surfaces
                            // only after the final create surface is called, otherwise we need to
                            // complete each surface as we go through the loop.

                            if (bAutomicCreate)
                            {
                                dwStart = 0;

                                if (i == (dwNumToCreate - 1))
                                {
                                    dwEnd = dwNumToCreate;
                                }
                                else
                                {
                                    dwEnd = 0;
                                }
                            }
                            else
                            {
                                dwStart = i;
                                dwEnd = i + 1;
                            }

                            // Primary surfaces aren't truly allocated, so
                            // intercept requests for primary allocations and
                            // trivially succeed them with recorded primary information.

                            bNotifyCreation = TRUE;

                            if (peSurface[i]->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
                            {
                                peSurface[i]->fpVidMem =
                                    peDirectDrawGlobal->HalInfo.vmiData.fpPrimary;
                                peSurface[i]->lPitch =
                                    peDirectDrawGlobal->HalInfo.vmiData.lDisplayPitch;
                                peSurface[i]->wWidth =
                                    peDirectDrawGlobal->HalInfo.vmiData.dwDisplayWidth;
                                peSurface[i]->wHeight =
                                    peDirectDrawGlobal->HalInfo.vmiData.dwDisplayHeight;
                                peSurface[i]->ddpfSurface =
                                    peDirectDrawGlobal->HalInfo.vmiData.ddpfDisplay;

                                peSurface[i]->fl |= DD_SURFACE_FLAG_PRIMARY;

                                CreateSurfaceData.ddRVal = DD_OK;
                                dwRet = DDHAL_DRIVER_HANDLED;

                                if (!(peDirectDrawGlobal->PrivateCaps.dwPrivateCaps & DDHAL_PRIVATECAP_NOTIFYPRIMARYCREATION))
                                {
                                    bNotifyCreation = FALSE;
                                }

                                DDKHEAP(("DDKHEAP: Allocated primary %X, surf %X (%X)\n",
                                         peSurface[i]->fpVidMem, peSurface[i]->hGet(),
                                         peSurface[i]));
                            }

                            if (dwStart != dwEnd)
                            {
                                // Determines whether the memory type was explicit or not, so we know
                                // if we can change it if an allocation fails later.

                                if (dwForceMemType == 0)
                                {
                                    bAnyType = !(peSurface[dwStart]->ddsCaps.dwCaps &
                                               (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM));

                                    // if it's not any type, initialize force mem type so that always
                                    // that type for all surfaces.

                                    if (!bAnyType)
                                    {
                                        dwForceMemType = peSurface[dwStart]->ddsCaps.dwCaps &
                                                            (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                    }
                                }

                                // if force allocations, set the same memory type as the first one

                                if (dwForceMemType)
                                {
                                    for (j = dwStart; j < dwEnd; j++)
                                    {
                                        peSurface[j]->ddsCaps.dwCaps &=
                                            ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                        peSurface[j]->ddsCaps.dwCaps |= dwForceMemType;
                                    }
                                }

                                if ((pfnCreate != NULL) && bNotifyCreation)
                                {
                                    // Let the driver attempt to allocate the surface first.

                                    CreateSurfaceData.lpDD            = peDirectDrawGlobal;
                                    CreateSurfaceData.lpDDSurfaceDesc = (DDSURFACEDESC*)&SurfaceDescription;

                                    if (bAutomicCreate)
                                    {
                                        for (j = dwStart; j < dwEnd; j++)
                                        {
                                            pSList[j] = peSurface[j];
                                        }

                                        CreateSurfaceData.lplpSList       = pSList;
                                        CreateSurfaceData.dwSCnt          = dwNumToCreate;
                                    }
                                    else
                                    {
                                        CreateSurfaceData.lplpSList       = &pSurfaceLocal;
                                        CreateSurfaceData.dwSCnt          = 1;
                                    }

                                    dwRet = pfnCreate(&CreateSurfaceData);

                                    if (dwRet == DDHAL_DRIVER_HANDLED)
                                    {
                                        if (CreateSurfaceData.ddRVal == DD_OK)
                                        {
                                            for (j = dwStart; j < dwEnd; j++)
                                            {
                                                // Set the driver created flag because the driver
                                                // involved itself in the creation.

                                                peSurface[j]->fl |=
                                                    DD_SURFACE_FLAG_DRIVER_CREATED;
                                            }

                                            for (j = dwStart;
                                                 (j < dwEnd) && (CreateSurfaceData.ddRVal == DD_OK);
                                                 j++)
                                            {
                                                // If the surfaces were allocated from one of our non-local
                                                // heaps, commit sufficient virtual memory and fill in the
                                                // virtual address for fpVidMem so the surface can be locked
                                                // and accessed by user mode apps:

                                                if ((peSurface[j]->ddsCaps.dwCaps & DDSCAPS_NONLOCALVIDMEM) &&
                                                    (peSurface[j]->lpVidMemHeap != NULL) &&
                                                    (peSurface[j]->lpVidMemHeap->lpHeap != NULL) &&
                                                   !(peSurface[j]->lpVidMemHeap->dwFlags & VIDMEM_ISHEAP) &&
                                                    (peSurface[j]->lpVidMemHeap->dwFlags & VIDMEM_ISNONLOCAL))
                                                {
                                                    CreateSurfaceData.ddRVal =
                                                        hrDdCommitAgpSurface(peSurface[j], 0);
                                                }
                                            }

                                            if (CreateSurfaceData.ddRVal == DD_OK)
                                            {
                                                if (dwForceMemType == 0)
                                                {
                                                    // All surfaces must be of the same type as the first 
                                                    // so we remember the type of surface type which
                                                    // we have successfully created.

                                                    // This only has meaning non-atomic case, since
                                                    // if driver can do atomic creation and handled it
                                                    // without error, that's driver's responsibility to
                                                    // make sure all surface came from same type of memory.

                                                    dwForceMemType =
                                                        peSurface[dwStart]->ddsCaps.dwCaps &
                                                            (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                                }
                                            }
                                        }

                                        DDKHEAP(("DDHKEAP: Driver alloced %X, "
                                                 "hr %X, surf %X (%X)\n",
                                                peSurface[i]->fpVidMem,
                                                CreateSurfaceData.ddRVal,
                                                peSurface[i]->hGet(),
                                                peSurface[i]));
                                    }
                                    else  if (peSurface[dwStart]->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
                                    {
                                        // Driver possible to return NOTHANDLED for notification of
                                        // primary surface cration, but creation itself is done by
                                        // us in above, but we had "notified" to driver, make
                                        // the surface as driver created. (so that we call driver
                                        // when destroy).

                                        peSurface[dwStart]->fl |=
                                            DD_SURFACE_FLAG_DRIVER_CREATED;
                                    }
                                }

                                if (dwRet == DDHAL_DRIVER_NOTHANDLED)
                                {
                                    // FIX WINBUG: #322363
                                    // Prevent setup blue-screen playing intro AVI on nv3 display drivers

                                    if ((SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                                        (SurfaceDescription.ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
                                    {
                                        // Mask off system memory flag
                                        WARNING("Driver turn on SYSTEMMEMORY flag, disable it");
                                        SurfaceDescription.ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                                    }

                                    dwRet = DDHAL_DRIVER_HANDLED;

                                    for (j = dwStart;
                                         (j < dwEnd) && (CreateSurfaceData.ddRVal == DD_OK);
                                         j++)
                                    {
                                        if (peSurface[j]->ddsCaps.dwCaps & DDSCAPS_PRIMARYSURFACE)
                                        {
                                            // Driver possible to return NOTHANDLED for notification of
                                            // primary surface cration, but creation itself is done by
                                            // us in above, so just ignore driver return.
                                            // Since this is just "notification" to driver, we don't
                                            // except any work in driver basically.

                                            CreateSurfaceData.ddRVal = DD_OK;
                                        }
                                        else
                                        {
                                            // FIX WINBUG: #322363
                                            // Prevent setup blue-screen playing intro AVI on nv3 display drivers

                                            if ((peSurface[j]->ddsCaps.dwCaps & DDSCAPS_VIDEOMEMORY) &&
                                                (peSurface[j]->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
                                            {
                                                // Mask off system memory flag
                                                WARNING("Driver turn on SYSTEMMEMORY flag, disable it");
                                                peSurface[j]->ddsCaps.dwCaps &= ~DDSCAPS_SYSTEMMEMORY;
                                            }

                                            if (peSurface[j]->fpVidMem != DDHAL_PLEASEALLOC_USERMEM)
                                            {
                                                // Force allocations to the same memory type as the first

                                                if (dwForceMemType)
                                                {
                                                    peSurface[j]->ddsCaps.dwCaps &=
                                                            ~(DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                                    peSurface[j]->ddsCaps.dwCaps |= dwForceMemType;
                                                }

                                                // The driver didn't allocate a vidmem surface, so try
                                                // to allocate one from system-managed memory.

                                                CreateSurfaceData.ddRVal =
                                                    hrDdAllocSurface(peDirectDrawLocal,
                                                                     peDirectDrawGlobal,
                                                                     peSurface[j]);

                                                DDKHEAP(("DDHKEAP: Heap alloced %X, "
                                                    "hr %X, surf %X (%X)\n",
                                                    peSurface[j]->fpVidMem,
                                                    CreateSurfaceData.ddRVal,
                                                    peSurface[j]->hGet(),
                                                    peSurface[j]));

                                                if (CreateSurfaceData.ddRVal == DD_OK)
                                                {
                                                    if (dwForceMemType == 0)
                                                    {
                                                        // All surfaces must be of the same type as the first 
                                                        // so we remember the type of surface type which
                                                        // we have successfully created first time.

                                                        dwForceMemType =
                                                            peSurface[j]->ddsCaps.dwCaps &
                                                                (DDSCAPS_LOCALVIDMEM | DDSCAPS_NONLOCALVIDMEM);
                                                    }
                                                }
                                            }
                                            else
                                            {
                                                // No forcemem things for user mode memory allocation.
                                                //
                                                // The driver didn't allocate a vidmem surface, so try
                                                // to allocate one from system-managed memory.

                                                CreateSurfaceData.ddRVal =
                                                    hrDdAllocSurface(peDirectDrawLocal,
                                                                     peDirectDrawGlobal,
                                                                     peSurface[j]);
                                            }
                                        }
                                    }
                                }

                                // An attempt to allocate was made either by the driver
                                // or by the system allocator.  If the attempt succeeded,
                                // complete the surface creation.

                                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                                    (CreateSurfaceData.ddRVal == DD_OK))
                                {
                                    // The object is complete.  We can ignore any
                                    // following DxDdCreateSurfaceObject calls that may
                                    // occur on this object.

                                    for (j = dwStart; j < dwEnd; j++)
                                    {
                                        vDdCompleteSurfaceObject(peDirectDrawLocal, peSurface[j]);

                                #if 0
                                        ASSERTGDI((peSurface[j]->fl & DD_SURFACE_FLAG_PRIMARY) ||
                                            (peSurface[j]->fpVidMem !=
                                            peDirectDrawGlobal->HalInfo.vmiData.fpPrimary),
                                            "Expected primary surface to be marked as such");
                                #endif
                                        ASSERTGDI(peSurface[j]->hbmGdi == NULL,
                                            "DxDdCreateSurface: Invalid cached bitmap");

                                        if (peSurface[j]->bLost)
                                        {
                                            // Surface is ready for use.
                                            peSurface[j]->bLost = FALSE;

                                            // Now this surface is ready to go, increment active surface ref. count.
                                            peSurface[j]->peDirectDrawLocal->cActiveSurface++;

                                            ASSERTGDI(peSurface[j]->peDirectDrawLocal->cActiveSurface <=
                                                      peSurface[j]->peDirectDrawLocal->cSurface,
                                                "cActiveSurface is > than cSurface");
                                        }

                                        // Copy surface information to local storage
                                        // for access after the unlock.

                                        puSurfaceGlobalData[j] = *peSurface[j];
                                        puSurfaceLocalData[j].ddsCaps = peSurface[j]->ddsCaps;
                                        puSurfaceMoreData[j].ddsCapsEx = peSurface[j]->ddsCapsEx;

                                        // We were successful, so unlock the surface:

                                        puhReturnSurfaceHandles[j] = peSurface[j]->hGet();
                                    }
                                }

                            } // if (dwStart != dwEnd)
                        }
                        else
                        {
                            WARNING("DxDdCreateSurface: Couldn't allocate surface\n");
                            CreateSurfaceData.ddRVal = DDERR_OUTOFMEMORY;
                        }
                    }
                    else
                    {
                        WARNING("DxDdCreateSurface: Bad surface description\n");
                        CreateSurfaceData.ddRVal = DDERR_INVALIDPARAMS;
                    }

                } // For loop

                // The surface object is now created, call CreateSurfaceEx, to
                // inform the driver to associate a cookie if the driver can

                if ((peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx)
                    && (CreateSurfaceData.ddRVal == DD_OK)
                    && (NULL != peSurface[0])
                    && (0 != peSurface[0]->dwSurfaceHandle)
                   )
                {
                    DD_CREATESURFACEEXDATA CreateSurfaceExData;
                    CreateSurfaceExData.ddRVal          = DDERR_GENERIC;
                    CreateSurfaceExData.dwFlags         = 0;
                    CreateSurfaceExData.lpDDLcl         = peDirectDrawLocal;
                    CreateSurfaceExData.lpDDSLcl        = peSurface[0];

                    dwRet = peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);
                    if (dwRet != DDHAL_DRIVER_HANDLED)
                    {
                        // For now, simply warn that the driver failed to associate the surface with the
                        // token and continue
                        WARNING("dwDdCreateSurfaceOrBuffer: DDI call to the driver not handled\n");
                        dwRet = DDHAL_DRIVER_HANDLED;
                        CreateSurfaceData.ddRVal = DDERR_GENERIC;
                    }
                    else
                    {
                        // need to prop the return value as if it's in CreateSurfaceData
                        CreateSurfaceData.ddRVal = CreateSurfaceExData.ddRVal;
                    }
                }

                // Unlock the surfaces and clean up any failures.

                for (j = 0; j < i; j++)
                {
                    if (peSurface[j] != NULL)
                    {
                        if (CreateSurfaceData.ddRVal != DD_OK)
                        {
                            // Failure, so clean up the surface object.
                            bDdDeleteSurfaceObject(peSurface[j]->hGet(), NULL);

                            // bKeepSurface is left at TRUE so that any
                            // failure codes get written back.  Ensure
                            // that fpVidMem is zero on return.
                            puSurfaceGlobalData[j].fpVidMem = 0;
                            puhReturnSurfaceHandles[j] = 0;
                        }
                        else
                        {
                            DEC_EXCLUSIVE_REF_CNT(peSurface[j]);
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDdCreateSurface: Unable to allocate or secure memory\n");
            }

            if (hSecureSurfaceHandles)
            {
                MmUnsecureVirtualMemory(hSecureSurfaceHandles);
            }
            if (hSecureGlobals)
            {
                MmUnsecureVirtualMemory(hSecureGlobals);
            }
            if (hSecureLocals)
            {
                MmUnsecureVirtualMemory(hSecureLocals);
            }
            if (hSecureMore)
            {
                MmUnsecureVirtualMemory(hSecureMore);
            }
            if (hSecureReturn)
            {
                MmUnsecureVirtualMemory(hSecureReturn);
            }
            if (peSurface != &peSurfaceOnStack)
            {
                VFREEMEM(peSurface);
            }
            if (pSList != NULL)
            {
                VFREEMEM(pSList);
            }
        }
        else
        {
            if (!(peDirectDrawGlobal->fl & DD_GLOBAL_FLAG_DRIVER_ENABLED))
            {
                WARNING("DxDdCreateSurface: Driver doesn't support this mode\n");
            }
            else
            {
                CreateSurfaceData.ddRVal = DDERR_SURFACELOST;
            }
        }
    }
    else
    {
        WARNING("DxDdCreateSurface: Invalid object\n");
    }

    DDKHEAP(("DDKHEAP: Create returns %X, rval %X\n",
             dwRet, CreateSurfaceData.ddRVal));

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        if (dwRet == DDHAL_DRIVER_HANDLED)
        {
            ProbeAndWriteRVal(&puCreateSurfaceData->ddRVal,
                              CreateSurfaceData.ddRVal);
        }

        if (bKeepSurface)
        {
            ProbeAndWriteStructure((DDSURFACEDESC2*)puSurfaceDescription,
                                   SurfaceDescription,
                                   DDSURFACEDESC2);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdCreateSurface
*
* Corresponds to HAL CreateSurface entry point.
*
* Calls the driver to create a DirectDraw surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdCreateSurface(
    HANDLE                  hDirectDraw,
    HANDLE*                 puhSurfaceHandle,
    DDSURFACEDESC*          puSurfaceDescription,
    DD_SURFACE_GLOBAL*      puSurfaceGlobalData,
    DD_SURFACE_LOCAL*       puSurfaceLocalData,
    DD_SURFACE_MORE*        puSurfaceMoreData,
    DD_CREATESURFACEDATA*   puCreateSurfaceData,
    HANDLE*                 puhSurface
    )
{
    return dwDdCreateSurfaceOrBuffer(hDirectDraw, puhSurfaceHandle,
                                     puSurfaceDescription, puSurfaceGlobalData,
                                     puSurfaceLocalData, puSurfaceMoreData,
                                     puCreateSurfaceData, puhSurface);
}

/******************************Public*Routine******************************\
* DWORD DxDdDestroySurface
*
* Calls the driver to delete a surface it created via CreateSurface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdDestroySurface(
    HANDLE  hSurface,
    BOOL    bRealDestroy
    )
{
    DWORD                   dwRet;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    BOOL                    b;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        {
            EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

            if(bRealDestroy)
            {
                vDdDisableSurfaceObject(peDirectDrawGlobal,
                                        peSurface,
                                        &dwRet);
            }
            else
            {
                vDdLooseManagedSurfaceObject(peDirectDrawGlobal,
                                             peSurface,
                                             &dwRet);
                return(dwRet);
            }
        }

        // vDdDisableSurfaceObject doesn't delete the DC because it may
        // be called from a different process than the one that created
        // the DC.  However, at this point we're guaranteed to be in the
        // process that created the DC, so we should delete it now:

        if (peSurface->hdc)
        {
            b = DxEngDeleteDC(peSurface->hdc, TRUE);

            // DC may still be in use, which would cause the delete to fail,
            // so we don't assert on the return value (the DC will still get
            // cleaned up at process termination):

            if (!b)
            {
                WARNING("DxDdDestroySurface: bDeleteDCInternal failed");
            }

            peSurface->hdc = 0;
        }
    }
    else
    {
        WARNING("DxDdDestroySurface: Couldn't lock DirectDraw surface");
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdCreateD3DBuffer
*
* Calls the driver to create a D3D buffer.
*
* Corresponds to HAL CreateD3DBuffer entry point.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdCreateD3DBuffer(
    HANDLE                  hDirectDraw,
    HANDLE*                 puhSurfaceHandle,
    DDSURFACEDESC*          puSurfaceDescription,
    DD_SURFACE_GLOBAL*      puSurfaceGlobalData,
    DD_SURFACE_LOCAL*       puSurfaceLocalData,
    DD_SURFACE_MORE*        puSurfaceMoreData,
    DD_CREATESURFACEDATA*   puCreateSurfaceData,
    HANDLE*                 puhSurface
    )
{
    return dwDdCreateSurfaceOrBuffer(hDirectDraw, puhSurfaceHandle,
                                     puSurfaceDescription, puSurfaceGlobalData,
                                     puSurfaceLocalData, puSurfaceMoreData,
                                     puCreateSurfaceData, puhSurface);
}

/******************************Public*Routine******************************\
* DWORD DxDdDestroyD3DBuffer
*
* Calls the driver to delete a surface it created via CreateD3DBuffer.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdDestroyD3DBuffer(
    HANDLE  hSurface
    )
{
    DWORD                   dwRet;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    peSurface = eLockSurface.peLock(hSurface);
    if (peSurface != NULL)
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        {
            EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

            vDdDisableSurfaceObject(peDirectDrawGlobal,
                                    peSurface,
                                    &dwRet);
        }
    }
    else
    {
        WARNING("DxDdDestroyD3DBuffer: Couldn't lock DirectDraw surface");
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdSetColorKey
*
* This entry point is always hooked by NT kernel, regardless of whether
* the driver hooks it or not.
*
* Note that this call does not necessary need to be called on an overlay
* surface.
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdSetColorKey(
    HANDLE              hSurface,
    PDD_SETCOLORKEYDATA puSetColorKeyData
    )
{
    DWORD              dwRet;
    DD_SETCOLORKEYDATA SetColorKeyData;

    __try
    {
        SetColorKeyData = ProbeAndReadStructure(puSetColorKeyData,
                                                DD_SETCOLORKEYDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                  = DDHAL_DRIVER_NOTHANDLED;
    SetColorKeyData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        if (SetColorKeyData.dwFlags & DDCKEY_SRCBLT)
        {
            peSurface->dwFlags |= DDRAWISURF_HASCKEYSRCBLT;
            peSurface->ddckCKSrcBlt = SetColorKeyData.ckNew;
        }

        // If the driver doesn't hook SetColorKey, we return
        // DDHAL_DRIVER_NOTHANDLED, which means okay.

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_SETCOLORKEY)
        {
            SetColorKeyData.lpDD        = peDirectDrawGlobal;
            SetColorKeyData.lpDDSurface = peSurface;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peSurface->bLost)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                SetColorKeyData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    SurfaceCallBacks.SetColorKey(&SetColorKeyData);
            }
        }
    }
    else
    {
        WARNING("DxDdSetColorKey: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puSetColorKeyData->ddRVal, SetColorKeyData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdAddAttachedSurface
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdAddAttachedSurface(
    HANDLE                      hSurface,
    HANDLE                      hSurfaceAttached,
    PDD_ADDATTACHEDSURFACEDATA  puAddAttachedSurfaceData
    )
{
    DWORD                       dwRet;
    DD_ADDATTACHEDSURFACEDATA   AddAttachedSurfaceData;

    __try
    {
        AddAttachedSurfaceData = ProbeAndReadStructure(puAddAttachedSurfaceData,
                                                       DD_ADDATTACHEDSURFACEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                         = DDHAL_DRIVER_NOTHANDLED;
    AddAttachedSurfaceData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_SURFACE*            peSurfaceAttached;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_LOCK_SURFACE        eLockSurfaceAttached;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    peSurfaceAttached = eLockSurfaceAttached.peLock(hSurfaceAttached);
    if ((peSurface != NULL) &&
        (peSurfaceAttached != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        !(peSurfaceAttached->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        (peSurface->peDirectDrawLocal == peSurfaceAttached->peDirectDrawLocal))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        // If the driver doesn't hook AddAttachedSurface, we return
        // DDHAL_DRIVER_NOTHANDLED, which means okay.

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_ADDATTACHEDSURFACE)
        {
            AddAttachedSurfaceData.lpDD           = peDirectDrawGlobal;
            AddAttachedSurfaceData.lpDDSurface    = peSurface;
            AddAttachedSurfaceData.lpSurfAttached = peSurfaceAttached;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((peSurface->bLost) || (peSurfaceAttached->bLost))
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                AddAttachedSurfaceData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    SurfaceCallBacks.AddAttachedSurface(&AddAttachedSurfaceData);
            }
        }
    }
    else
    {
        WARNING("DxDdAddAttachedSurface: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puAddAttachedSurfaceData->ddRVal,
                          AddAttachedSurfaceData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdUpdateOverlay
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdUpdateOverlay(
    HANDLE                  hSurfaceDestination,
    HANDLE                  hSurfaceSource,
    PDD_UPDATEOVERLAYDATA   puUpdateOverlayData
    )
{
    DWORD                dwRet;
    DD_UPDATEOVERLAYDATA UpdateOverlayData;
    EDD_VIDEOPORT*       peVideoPort = NULL;
    EDD_DXSURFACE*       peDxSurface;
    DWORD                dwOldFlags;

    __try
    {
        UpdateOverlayData = ProbeAndReadStructure(puUpdateOverlayData,
                                                  DD_UPDATEOVERLAYDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_NOTHANDLED;
    UpdateOverlayData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurfaceSource;
    EDD_SURFACE*            peSurfaceDestination;
    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurfaceSource;
    EDD_LOCK_SURFACE        eLockSurfaceDestination;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    // 'peSurfaceSource' is the overlay surface, 'peSurfaceDestination' is
    // the surface to be overlayed.

    peSurfaceSource = eLockSurfaceSource.peLock(hSurfaceSource);
    if ((peSurfaceSource != NULL) &&
        !(peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        (peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_OVERLAY))
    {
        peDirectDrawGlobal = peSurfaceSource->peDirectDrawGlobal;

        // If we're being asked to hide the overlay, then we don't need
        // check any more parameters:

        peSurfaceDestination = NULL;
        if (!(UpdateOverlayData.dwFlags & DDOVER_HIDE))
        {
            // Okay, we have to validate every parameter in this call:

            peSurfaceDestination
                = eLockSurfaceDestination.peLock(hSurfaceDestination);

            if ((peSurfaceDestination == NULL)                                    ||
                (peSurfaceDestination->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)     ||
                (peSurfaceDestination->peDirectDrawLocal !=
                    peSurfaceSource->peDirectDrawLocal)                           ||
                (UpdateOverlayData.rDest.left   < DD_MINIMUM_COORDINATE)          ||
                (UpdateOverlayData.rDest.top    < DD_MINIMUM_COORDINATE)          ||
                (UpdateOverlayData.rDest.right  > DD_MAXIMUM_COORDINATE)          ||
                (UpdateOverlayData.rDest.bottom > DD_MAXIMUM_COORDINATE)          ||
                (UpdateOverlayData.rDest.left  >= UpdateOverlayData.rDest.right)  ||
                (UpdateOverlayData.rDest.top   >= UpdateOverlayData.rDest.bottom) ||
                (UpdateOverlayData.rSrc.left    < DD_MINIMUM_COORDINATE)          ||
                (UpdateOverlayData.rSrc.top     < DD_MINIMUM_COORDINATE)          ||
                (UpdateOverlayData.rSrc.right   > DD_MAXIMUM_COORDINATE)          ||
                (UpdateOverlayData.rSrc.bottom  > DD_MAXIMUM_COORDINATE)          ||
                (UpdateOverlayData.rSrc.left   >= UpdateOverlayData.rSrc.right)   ||
                (UpdateOverlayData.rSrc.top    >= UpdateOverlayData.rSrc.bottom))
            {
                WARNING("DxDdUpdateOverlay: Invalid destination or rectangle\n");
                return(dwRet);
            }

            // We don't keep track of pSurfaceLocal->ddckCKSrcOverlay in
            // kernel mode, so we always expect the user-mode call to convert
            // to DDOVER_KEYDESTOVERRIDE or DDOVER_KEYSRCOVERRIDE.  It is by
            // no means fatal if this is not the case, so we only do a warning:

            if ((UpdateOverlayData.dwFlags & DDOVER_KEYDEST) ||
                (UpdateOverlayData.dwFlags & DDOVER_KEYSRC))
            {
                WARNING("DxDdUpdateOverlay: Expected user-mode to set OVERRIDE\n");
            }

            // If using a video port, disable autoflipping and hardware
            // bob when neccesary

            if( peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_VIDEOPORT )
            {
                peVideoPort = (EDD_VIDEOPORT*) peSurfaceSource->lpVideoPort;
                if( peVideoPort != NULL )
                {
                    if( ( peVideoPort->peDxVideoPort->bSoftwareAutoflip ) ||
                        ( peVideoPort->peDxVideoPort->flFlags & DD_DXVIDEOPORT_FLAG_SOFTWAREBOB ) )
                    {
                        UpdateOverlayData.dwFlags &= ~(DDOVER_AUTOFLIP|DDOVER_BOBHARDWARE);
                    }
                }
            }

            // If this surface is being used by DxApi, change to weave if
            // DxApi told it to and visa versa.

            peDxSurface = peSurfaceSource->peDxSurface;
            if( peDxSurface != NULL )
            {
                if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_STATE_SET )
                {
                    if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_STATE_BOB )
                    {
                        UpdateOverlayData.dwFlags |= DDOVER_BOB;
                    }
                    else if( peDxSurface->flFlags & DD_DXSURFACE_FLAG_STATE_WEAVE )
                    {
                        UpdateOverlayData.dwFlags &= ~DDOVER_BOB | DDOVER_BOBHARDWARE;
                    }
                }
            }
        }

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags
                & DDHAL_SURFCB32_UPDATEOVERLAY)
        {
            UpdateOverlayData.lpDD            = peDirectDrawGlobal;
            UpdateOverlayData.lpDDDestSurface = peSurfaceDestination;
            UpdateOverlayData.lpDDSrcSurface  = peSurfaceSource;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((peSurfaceSource->bLost) ||
                ((peSurfaceDestination != NULL) && (peSurfaceDestination->bLost)))
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                UpdateOverlayData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                peSurfaceSource->fl |= DD_SURFACE_FLAG_UPDATE_OVERLAY_CALLED;

                dwRet = peDirectDrawGlobal->SurfaceCallBacks.UpdateOverlay(
                                            &UpdateOverlayData);

                // If it failed due to hardware autoflipping/bobbing
                // and software autoflipping is an option, try again
                // without hardware autolfipping.  If it works, we will
                // revert to software autoflipping.

                if( ( dwRet == DDHAL_DRIVER_HANDLED ) &&
                    ( UpdateOverlayData.ddRVal != DD_OK ) &&
                    ( UpdateOverlayData.dwFlags & (DDOVER_AUTOFLIP|DDOVER_BOBHARDWARE) ) &&
                    ( peDirectDrawGlobal->DDKernelCaps.dwCaps & DDKERNELCAPS_AUTOFLIP ) )
                {
                    dwOldFlags = UpdateOverlayData.dwFlags;
                    UpdateOverlayData.dwFlags &= ~(DDOVER_AUTOFLIP|DDOVER_BOBHARDWARE);
                    dwRet = peDirectDrawGlobal->SurfaceCallBacks.UpdateOverlay(
                                            &UpdateOverlayData);
                    if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                        (UpdateOverlayData.ddRVal == DD_OK))
                    {
                        if( dwOldFlags & DDOVER_AUTOFLIP )
                        {
                            peVideoPort->peDxVideoPort->bSoftwareAutoflip = TRUE;
                            if( peVideoPort->cAutoflipVideo > 0 )
                            {
                                peVideoPort->peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP;
                            }
                            if( peVideoPort->cAutoflipVbi > 0 )
                            {
                                peVideoPort->peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_AUTOFLIP_VBI;
                            }
                        }
                        if( dwOldFlags & DDOVER_BOBHARDWARE )
                        {
                            peVideoPort->peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_SOFTWAREBOB;
                        }
                    }
                }
                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                    (UpdateOverlayData.ddRVal == DD_OK))
                {
                    // Update the DXAPI data for all surfaces in the chain:

                    if( peVideoPort != NULL )
                    {
                        if( UpdateOverlayData.dwFlags & DDOVER_BOB )
                        {
                            peVideoPort->peDxVideoPort->flFlags |= DD_DXVIDEOPORT_FLAG_BOB;
                        }
                        else
                        {
                            peVideoPort->peDxVideoPort->flFlags &= ~DD_DXVIDEOPORT_FLAG_BOB;
                        }
                    }
                    peSurface = peSurfaceSource;
                    while (TRUE)
                    {
                        peSurface->dwOverlayFlags = UpdateOverlayData.dwFlags;

                        peSurface->dwOverlaySrcWidth
                            = UpdateOverlayData.rSrc.right -
                              UpdateOverlayData.rSrc.left;
                        peSurface->dwOverlaySrcHeight
                            = UpdateOverlayData.rSrc.bottom -
                              UpdateOverlayData.rSrc.top;
                        peSurface->dwOverlayDestWidth
                            = UpdateOverlayData.rDest.right -
                              UpdateOverlayData.rDest.left;
                        peSurface->dwOverlayDestHeight
                            = UpdateOverlayData.rDest.bottom -
                              UpdateOverlayData.rDest.top;

                        peSurface->rcOverlaySrc.left =
                              UpdateOverlayData.rSrc.left;
                        peSurface->rcOverlaySrc.right =
                              UpdateOverlayData.rSrc.right;
                        peSurface->rcOverlaySrc.top =
                              UpdateOverlayData.rSrc.top;
                        peSurface->rcOverlaySrc.bottom =
                              UpdateOverlayData.rSrc.bottom;

                        vDdSynchronizeSurface(peSurface);

                        if (peSurface->lpAttachList == NULL)
                            break;

                        peSurface
                            = pedFromLp(peSurface->lpAttachList->lpAttached);
                    }
                }
            }
        }
    }
    else
    {
        WARNING("DxDdUpdateOverlay: Invalid source or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puUpdateOverlayData->ddRVal, UpdateOverlayData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdSetOverlayPosition
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdSetOverlayPosition(
    HANDLE                      hSurfaceSource,
    HANDLE                      hSurfaceDestination,
    PDD_SETOVERLAYPOSITIONDATA  puSetOverlayPositionData
    )
{
    DWORD                     dwRet;
    DD_SETOVERLAYPOSITIONDATA SetOverlayPositionData;

    __try
    {
        SetOverlayPositionData = ProbeAndReadStructure(puSetOverlayPositionData,
                                                       DD_SETOVERLAYPOSITIONDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                         = DDHAL_DRIVER_NOTHANDLED;
    SetOverlayPositionData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurfaceSource;
    EDD_SURFACE*            peSurfaceDestination;
    EDD_LOCK_SURFACE        eLockSurfaceSource;
    EDD_LOCK_SURFACE        eLockSurfaceDestination;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurfaceSource      = eLockSurfaceSource.peLock(hSurfaceSource);
    peSurfaceDestination = eLockSurfaceSource.peLock(hSurfaceDestination);
    if ((peSurfaceSource != NULL) &&
        (peSurfaceDestination != NULL) &&
        (peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_OVERLAY) &&
        !(peSurfaceSource->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
        !(peSurfaceDestination->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        peDirectDrawGlobal = peSurfaceSource->peDirectDrawGlobal;

        if (peDirectDrawGlobal->SurfaceCallBacks.dwFlags &
                    DDHAL_SURFCB32_SETOVERLAYPOSITION)
        {
            SetOverlayPositionData.lpDD            = peDirectDrawGlobal;
            SetOverlayPositionData.lpDDSrcSurface  = peSurfaceSource;
            SetOverlayPositionData.lpDDDestSurface = peSurfaceDestination;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if ((peSurfaceSource->bLost) || (peSurfaceDestination->bLost))
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                SetOverlayPositionData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    SurfaceCallBacks.SetOverlayPosition(&SetOverlayPositionData);
            }
        }
    }
    else
    {
        WARNING("DxDdSetOverlayPosition: Invalid surfaces or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puSetOverlayPositionData->ddRVal,
                          SetOverlayPositionData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetScanLine
*
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetScanLine(
    HANDLE              hDirectDraw,
    PDD_GETSCANLINEDATA puGetScanLineData
    )
{
    DWORD              dwRet;
    DD_GETSCANLINEDATA GetScanLineData;

    __try
    {
        GetScanLineData = ProbeAndReadStructure(puGetScanLineData,
                                                DD_GETSCANLINEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                  = DDHAL_DRIVER_NOTHANDLED;
    GetScanLineData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (peDirectDrawGlobal->CallBacks.dwFlags & DDHAL_CB32_GETSCANLINE)
        {
            GetScanLineData.lpDD = peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peDirectDrawGlobal->bSuspended)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                GetScanLineData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    CallBacks.GetScanLine(&GetScanLineData);
            }
        }
    }
    else
    {
        WARNING("DxDdGetScanLine: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetScanLineData->ddRVal,
                          GetScanLineData.ddRVal);
        ProbeAndWriteUlong(&puGetScanLineData->dwScanLine,
                           GetScanLineData.dwScanLine);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdSetExclusiveMode
*
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdSetExclusiveMode(
    HANDLE                      hDirectDraw,
    PDD_SETEXCLUSIVEMODEDATA    puSetExclusiveModeData
    )
{
    DWORD                   dwRet;
    DD_SETEXCLUSIVEMODEDATA SetExclusiveModeData;

    __try
    {
        SetExclusiveModeData = ProbeAndReadStructure(puSetExclusiveModeData,
                                                     DD_SETEXCLUSIVEMODEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                       = DDHAL_DRIVER_NOTHANDLED;
    SetExclusiveModeData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (peDirectDrawGlobal->NTCallBacks.dwFlags &
            DDHAL_NTCB32_SETEXCLUSIVEMODE)
        {
            SetExclusiveModeData.lpDD = peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (!peDirectDrawGlobal->bSuspended)
            {
                dwRet = peDirectDrawGlobal->NTCallBacks.
                    SetExclusiveMode(&SetExclusiveModeData);
            }
            else
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                WARNING("DxDdSetExclusiveMode: "
                        "Can't set exclusive mode because disabled\n");
            }
        }
    }
    else
    {
        WARNING("DxDdSetExclusiveMode: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puSetExclusiveModeData->ddRVal,
                          SetExclusiveModeData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdFlipToGDISurface
*
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdFlipToGDISurface(
    HANDLE                      hDirectDraw,
    PDD_FLIPTOGDISURFACEDATA    puFlipToGDISurfaceData
    )
{
    DWORD                   dwRet;
    DD_FLIPTOGDISURFACEDATA FlipToGDISurfaceData;

    __try
    {
        FlipToGDISurfaceData = ProbeAndReadStructure(puFlipToGDISurfaceData,
                                                     DD_FLIPTOGDISURFACEDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                       = DDHAL_DRIVER_NOTHANDLED;
    FlipToGDISurfaceData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (peDirectDrawGlobal->NTCallBacks.dwFlags &
            DDHAL_NTCB32_FLIPTOGDISURFACE)
        {
            FlipToGDISurfaceData.lpDD = peDirectDrawGlobal;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (!peDirectDrawGlobal->bSuspended)
            {
                dwRet = peDirectDrawGlobal->NTCallBacks.
                    FlipToGDISurface(&FlipToGDISurfaceData);
            }
            else
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                WARNING("DxDdFlipToGDISurface: "
                        "Can't flip because disabled\n");
            }
        }
    }
    else
    {
        WARNING("DxDdFlipToGDISurface: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puFlipToGDISurfaceData->ddRVal,
                          FlipToGDISurfaceData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDdGetVailDriverMemory
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetAvailDriverMemory(
    HANDLE                          hDirectDraw,
    PDD_GETAVAILDRIVERMEMORYDATA    puGetAvailDriverMemoryData
    )
{
    DD_GETAVAILDRIVERMEMORYDATA GetAvailDriverMemoryData;
    DWORD                       dwHeap;
    VIDEOMEMORY*                pHeap;
    DWORD                       dwAllocated = 0;
    DWORD                       dwFree = 0;

    __try
    {
        GetAvailDriverMemoryData
            = ProbeAndReadStructure(puGetAvailDriverMemoryData,
                                    DD_GETAVAILDRIVERMEMORYDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    GetAvailDriverMemoryData.ddRVal = DD_OK;
    GetAvailDriverMemoryData.dwTotal = 0;
    GetAvailDriverMemoryData.dwFree = 0;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        // First count up all the memory for the heaps we control in kernel.
        pHeap = peDirectDrawGlobal->pvmList;
        for (dwHeap = 0;
             dwHeap < peDirectDrawGlobal->dwNumHeaps;
             pHeap++, dwHeap++)
        {
        /*
         * We use ddsCapsAlt as we wish to return the total amount
         * of memory of the given type it is possible to allocate
         * regardless of whether it is desirable to allocate that
         * type of memory from a given heap or not.
         */
            if( (pHeap->dwFlags & VIDMEM_HEAPDISABLED) == 0 &&
                (GetAvailDriverMemoryData.DDSCaps.dwCaps &
                 pHeap->ddsCapsAlt.dwCaps) == 0 )
            {
                dwFree += VidMemAmountFree( pHeap->lpHeap );
                dwAllocated += VidMemAmountAllocated( pHeap->lpHeap );
            }
        }

        if (peDirectDrawGlobal->MiscellaneousCallBacks.dwFlags &
                DDHAL_MISCCB32_GETAVAILDRIVERMEMORY)
        {
            GetAvailDriverMemoryData.lpDD = peDirectDrawGlobal;

            if (peDirectDrawGlobal->bSuspended)
            {
                GetAvailDriverMemoryData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                peDirectDrawGlobal->MiscellaneousCallBacks.
                    GetAvailDriverMemory(&GetAvailDriverMemoryData);
            }
        }
    }
    else
    {
        WARNING("DxDdGetAvailDriverMemory: Invalid object or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
    ProbeAndWriteRVal(&puGetAvailDriverMemoryData->ddRVal,
              GetAvailDriverMemoryData.ddRVal);
    ProbeAndWriteUlong(&puGetAvailDriverMemoryData->dwTotal,
               GetAvailDriverMemoryData.dwTotal + dwAllocated + dwFree);
    ProbeAndWriteUlong(&puGetAvailDriverMemoryData->dwFree,
               GetAvailDriverMemoryData.dwFree + dwFree);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(DDHAL_DRIVER_HANDLED);
}

/*****************************Private*Routine******************************\
* DWORD DxDdColorControl
*
* Not to be confused with the VideoPort ColorControl function.
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdColorControl(
    HANDLE                  hSurface,
    PDD_COLORCONTROLDATA    puColorControlData
    )
{
    DWORD               dwRet;
    DD_COLORCONTROLDATA ColorControlData;
    DDCOLORCONTROL      ColorInfo;

    __try
    {
        ColorControlData = ProbeAndReadStructure(puColorControlData,
                                                 DD_COLORCONTROLDATA);
        ColorInfo = ProbeAndReadStructure(puColorControlData->lpColorData,
                                          DDCOLORCONTROL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                   = DDHAL_DRIVER_NOTHANDLED;
    ColorControlData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurface = eLockSurface.peLock(hSurface);
    if ((peSurface != NULL) &&
        !(peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
    {
        peDirectDrawGlobal = peSurface->peDirectDrawGlobal;

        // NOTE: For security, gotta reset when switching desktops

        if (peDirectDrawGlobal->ColorControlCallBacks.dwFlags &
                    DDHAL_COLOR_COLORCONTROL)
        {
            ColorControlData.lpDD        = peDirectDrawGlobal;
            ColorControlData.lpDDSurface = peSurface;
            ColorControlData.lpColorData = &ColorInfo;

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            if (peSurface->bLost)
            {
                dwRet = DDHAL_DRIVER_HANDLED;
                ColorControlData.ddRVal = DDERR_SURFACELOST;
            }
            else
            {
                dwRet = peDirectDrawGlobal->
                    ColorControlCallBacks.ColorControl(&ColorControlData);
            }
        }
    }
    else
    {
        WARNING("DxColorControl: Invalid surface or dwFlags\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
    ProbeAndWriteRVal(&puColorControlData->ddRVal, ColorControlData.ddRVal);
        ProbeAndWriteStructure(puColorControlData->lpColorData,
                               ColorInfo,
                               DDCOLORCONTROL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DWORD DxDdGetDriverInfo
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetDriverInfo(
    HANDLE                  hDirectDraw,
    PDD_GETDRIVERINFODATA   puGetDriverInfoData
    )
{
    DD_GETDRIVERINFODATA    GetDriverInfoData;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    GUID*                   pGuid;
    VOID*                   pvData;
    ULONG                   cjData;
    // Needed for Z-Pixels and others which don't cache information
    // in the global.
    // 1K should be enough for about 30 DDPIXELFORMATS,
    // which should be plenty
    DWORD adwBuffer[256];

    __try
    {
        GetDriverInfoData = ProbeAndReadStructure(puGetDriverInfoData,
                                                  DD_GETDRIVERINFODATA);

        // Assume failure:

        puGetDriverInfoData->ddRVal = DDERR_GENERIC;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
        pGuid              = &GetDriverInfoData.guidInfo;
        pvData             = NULL;

        // Note that the actual addresses of the call-backs won't be of
        // much interest to user-mode DirectDraw, but it will still use the
        // dwFlags field of the CALLBACKS structure.

        if (IsEqualIID(pGuid, &GUID_VideoPortCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_VIDEOPORT))
        {
            pvData = &peDirectDrawGlobal->VideoPortCallBacks;
            cjData = sizeof(peDirectDrawGlobal->VideoPortCallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_VideoPortCaps) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_VIDEOPORT))
        {
            pvData = peDirectDrawGlobal->lpDDVideoPortCaps;
            cjData = peDirectDrawGlobal->HalInfo.ddCaps.dwMaxVideoPorts
                   * sizeof(DDVIDEOPORTCAPS);
        }

        if (IsEqualIID(pGuid, &GUID_KernelCaps) )
        {
            pvData = &(peDirectDrawGlobal->DDKernelCaps);
            cjData = sizeof(DDKERNELCAPS);
        }

        if (IsEqualIID(pGuid, &GUID_ColorControlCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_COLORCONTROL))
        {
            pvData = &peDirectDrawGlobal->ColorControlCallBacks;
            cjData = sizeof(peDirectDrawGlobal->ColorControlCallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_MiscellaneousCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MISCELLANEOUS))
        {
            pvData = &peDirectDrawGlobal->MiscellaneousCallBacks;
            cjData = sizeof(peDirectDrawGlobal->MiscellaneousCallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_Miscellaneous2Callbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MISCELLANEOUS2))
        {
            pvData = &peDirectDrawGlobal->Miscellaneous2CallBacks;
            cjData = sizeof(peDirectDrawGlobal->Miscellaneous2CallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_NTCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_NT))
        {
            pvData = &peDirectDrawGlobal->NTCallBacks;
            cjData = sizeof(peDirectDrawGlobal->NTCallBacks);
        }

        if (IsEqualIID(pGuid, &GUID_D3DCallbacks3) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_D3DCALLBACKS3))
        {
            pvData = &peDirectDrawGlobal->D3dCallBacks3;
            cjData = sizeof(peDirectDrawGlobal->D3dCallBacks3);
        }

        if (IsEqualIID(pGuid, &GUID_MotionCompCallbacks) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MOTIONCOMP))
        {
            pvData = &peDirectDrawGlobal->MotionCompCallbacks;
            cjData = sizeof(peDirectDrawGlobal->MotionCompCallbacks);
        }

        if (IsEqualIID(pGuid, &GUID_DDMoreCaps) &&
            (peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MORECAPS))
        {
            pvData = &peDirectDrawGlobal->MoreCaps;
            cjData = sizeof(peDirectDrawGlobal->MoreCaps);
        }

        if (IsEqualIID(pGuid, &GUID_DDMoreSurfaceCaps))
        {
            pvData = &peDirectDrawGlobal->MoreSurfaceCaps;
            cjData = sizeof(DD_MORESURFACECAPS)-2*sizeof(DDSCAPSEX);
        }
        //
        // The information for the following GUIDs does not
        // need to be kept around in the kernel so the call
        // is passed directly to the driver.
        //

        if (pvData == NULL)
        {
            cjData = 0;

            if (IsEqualIID(pGuid, &GUID_D3DExtendedCaps))
            {
                cjData = sizeof(D3DNTHAL_D3DEXTENDEDCAPS);
            }

            if (IsEqualIID(pGuid, &GUID_ZPixelFormats))
            {
                cjData = sizeof(adwBuffer);
            }

            if (IsEqualIID(pGuid, &GUID_NonLocalVidMemCaps))
            {
                cjData = sizeof(DD_NONLOCALVIDMEMCAPS);
            }

            if (IsEqualIID(pGuid, &GUID_DDStereoMode))
            {
                cjData = sizeof(DD_STEREOMODE);
                __try
                {
                    ProbeForRead(GetDriverInfoData.lpvData, cjData, sizeof(ULONG));
                    RtlCopyMemory(adwBuffer, GetDriverInfoData.lpvData, cjData);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                        return(DDHAL_DRIVER_NOTHANDLED);
                }
            }

            if (cjData > 0)
            {
                ASSERTGDI(sizeof(adwBuffer) >= cjData,
                          "adwBuffer too small");

                EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                if (bDdGetDriverInfo(peDirectDrawGlobal, pGuid,
                                     adwBuffer, cjData, &cjData))
                {
                    pvData = adwBuffer;
                }
            }
        }

        if (pvData != NULL)
        {
            __try
            {

                ProbeForWrite(GetDriverInfoData.lpvData, cjData, sizeof(ULONG));

                RtlCopyMemory(GetDriverInfoData.lpvData, pvData, cjData);

                ProbeAndWriteUlong(&puGetDriverInfoData->dwActualSize, cjData);
                ProbeAndWriteRVal(&puGetDriverInfoData->ddRVal, DD_OK);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                return(DDHAL_DRIVER_NOTHANDLED);
            }
        }
    }
    else
    {
        WARNING("DxDdGetDriverInfo: Invalid object\n");
    }

    return(DDHAL_DRIVER_HANDLED);
}
/******************************Public*Routine******************************\
* DWORD DxDdGetDxHandle
*
*  18-Oct-1997 -by- smac
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDdGetDxHandle(
    HANDLE  hDirectDraw,
    HANDLE  hSurface,
    BOOL    bRelease
    )
{
    EDD_LOCK_SURFACE        eLockSurface;
    EDD_SURFACE*            peSurface;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    HANDLE                  hRet;

    hRet = NULL;

    if( hDirectDraw != NULL )
    {
        peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
        if(  peDirectDrawLocal != NULL )
        {
            // Use the devlock to synchronize additions and deletions to
            // the attach list:

            EDD_DEVLOCK eDevLock(peDirectDrawLocal->peDirectDrawGlobal);

            peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;
            if( !bRelease )
            {
                if( bDdLoadDxApi( peDirectDrawLocal ) &&
                    ( peDirectDrawGlobal->hDirectDraw != NULL ) )
                {
                    hRet = hDirectDraw;
                    peDirectDrawGlobal->dwDxApiExplicitLoads++;
                }
            }
            else if( ( peDirectDrawGlobal->hDirectDraw != NULL ) && bRelease &&
                ( peDirectDrawGlobal->dwDxApiExplicitLoads > 0 ) )
            {
                vDdUnloadDxApi( peDirectDrawGlobal );
                hRet = hDirectDraw;
                peDirectDrawGlobal->dwDxApiExplicitLoads--;
            }
        }
    }

    else if( hSurface != NULL )
    {
        peSurface = eLockSurface.peLock(hSurface);
        if( peSurface != NULL )
        {
            // Use the devlock to synchronize additions and deletions to
            // the attach list:

            EDD_DEVLOCK eDevLock(peSurface->peDirectDrawGlobal);

            // They must open the DirectDraw handle before opening the
            // surface handle, otherwise we fail.

            if( peSurface->peDirectDrawGlobal->hDirectDraw != NULL )
            {
                if ((peSurface->bLost)                                    ||
                    (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY))
                {
                    WARNING("DxDdGetDxHandle: Video surface is bad/lost/system");
                }
                else if( ( peSurface->hSurface == NULL ) && !bRelease )
                {
                    peSurface->hSurface = hDdOpenDxApiSurface( peSurface );
                    if( peSurface->hSurface != NULL )
                    {
                        hRet = hSurface;
                    }
                }
                else if( ( peSurface->hSurface != NULL ) && bRelease )
                {
                    vDdCloseDxApiSurface( peSurface );
                    hRet = hSurface;
                }
            }
        }
    }

    return( hRet );
}

/******************************Public*Routine******************************\
* DWORD DxDdGetMoCompGuids
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetMoCompGuids(
    HANDLE                  hDirectDraw,
    PDD_GETMOCOMPGUIDSDATA  puGetMoCompGuidsData
    )
{
    DWORD                       dwRet;
    DD_GETMOCOMPGUIDSDATA       GetMoCompGuidsData;
    LPGUID                      puGuids;
    ULONG                       cjGuids;
    HANDLE                      hSecure;

    __try
    {
        GetMoCompGuidsData
            = ProbeAndReadStructure(puGetMoCompGuidsData,
                                    DD_GETMOCOMPGUIDSDATA);

        puGuids = GetMoCompGuidsData.lpGuids;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_HANDLED;
    GetMoCompGuidsData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if(  peDirectDrawLocal != NULL )
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetMoCompGuidsData.lpDD       = peDirectDrawGlobal;
        GetMoCompGuidsData.dwNumGuids = 0;
        GetMoCompGuidsData.lpGuids    = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.GetMoCompGuids))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompGuids(&GetMoCompGuidsData);

            cjGuids = GetMoCompGuidsData.dwNumGuids
                     * sizeof(GUID);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetMoCompGuidsData.ddRVal == DD_OK) &&
                (cjGuids > 0) &&
                (puGuids != NULL))
            {
                hSecure = 0;
                GetMoCompGuidsData.ddRVal = DDERR_GENERIC;

                __try
                {
                    ProbeForWrite(puGuids, cjGuids, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puGuids,
                                                    cjGuids,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetMoCompGuidsData.lpGuids = puGuids;

                    dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompGuids(&GetMoCompGuidsData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDdGetMoCompGuids: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDdGetMoCompGuids: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetMoCompGuidsData->ddRVal,
                          GetMoCompGuidsData.ddRVal);
        ProbeAndWriteUlong(&puGetMoCompGuidsData->dwNumGuids,
                           GetMoCompGuidsData.dwNumGuids);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetMoCompFormats
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetMoCompFormats(
    HANDLE                  hDirectDraw,
    PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData
    )
{
    DWORD                       dwRet;
    DD_GETMOCOMPFORMATSDATA     GetMoCompFormatsData;
    GUID                        guid;
    LPDDPIXELFORMAT             puFormats;
    ULONG                       cjFormats;
    HANDLE                      hSecure;

    __try
    {
        GetMoCompFormatsData
            = ProbeAndReadStructure(puGetMoCompFormatsData,
                                    DD_GETMOCOMPFORMATSDATA);
        guid = ProbeAndReadStructure(GetMoCompFormatsData.lpGuid,
                                    GUID);
        GetMoCompFormatsData.lpGuid = &guid;

        puFormats = GetMoCompFormatsData.lpFormats;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                      = DDHAL_DRIVER_HANDLED;
    GetMoCompFormatsData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if(  peDirectDrawLocal != NULL )
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetMoCompFormatsData.lpDD         = peDirectDrawGlobal;
        GetMoCompFormatsData.dwNumFormats = 0;
        GetMoCompFormatsData.lpFormats    = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.GetMoCompFormats))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompFormats(&GetMoCompFormatsData);

            cjFormats = GetMoCompFormatsData.dwNumFormats
                     * sizeof(DDPIXELFORMAT);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetMoCompFormatsData.ddRVal == DD_OK) &&
                (cjFormats > 0) &&
                (puFormats != NULL))
            {
                hSecure = 0;
                GetMoCompFormatsData.ddRVal = DDERR_GENERIC;

                __try
                {
                    ProbeForWrite(puFormats, cjFormats, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puFormats,
                                                    cjFormats,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetMoCompFormatsData.lpFormats = puFormats;

                    dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompFormats(&GetMoCompFormatsData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDdGetMoCompFormats: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDdGetMoCompFormats: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetMoCompFormatsData->ddRVal,
                          GetMoCompFormatsData.ddRVal);
        ProbeAndWriteUlong(&puGetMoCompFormatsData->dwNumFormats,
                           GetMoCompFormatsData.dwNumFormats);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* BOOL bDdDeleteMotionCompObject
*
* Deletes a kernel-mode representation of the motion comp object.
*
*  19-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

BOOL
bDdDeleteMotionCompObject(
    HANDLE  hMotionComp,
    DWORD*  pdwRet          // For returning driver return code, may be NULL
    )
{
    BOOL                    bRet;
    DWORD                   dwRet;
    EDD_MOTIONCOMP*         peMotionComp;
    EDD_MOTIONCOMP*         peTmp;
    VOID*                   pvRemove;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    DD_DESTROYMOCOMPDATA    DestroyMoCompData;
    DXOBJ*                  pDxObj;
    DXOBJ*                  pDxObjNext;

    bRet = FALSE;
    dwRet = DDHAL_DRIVER_HANDLED;

    peMotionComp = (EDD_MOTIONCOMP*) DdHmgLock((HDD_OBJ) hMotionComp, DD_MOTIONCOMP_TYPE, FALSE);

    if (peMotionComp != NULL)
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;

        pvRemove = DdHmgRemoveObject((HDD_OBJ) hMotionComp,
                                   DdHmgQueryLock((HDD_OBJ) hMotionComp),
                                   0,
                                   TRUE,
                                   DD_MOTIONCOMP_TYPE);

        // Hold the devlock while we call the driver and while we muck
        // around in the motion comp list:

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if (peMotionComp->fl & DD_MOTIONCOMP_FLAG_DRIVER_CREATED)
        {
            // Call the driver if it created the object:

            if (peDirectDrawGlobal->MotionCompCallbacks.DestroyMoComp)
            {
                DestroyMoCompData.lpDD        = peDirectDrawGlobal;
                DestroyMoCompData.lpMoComp    = peMotionComp;
                DestroyMoCompData.ddRVal      = DDERR_GENERIC;

                dwRet = peDirectDrawGlobal->
                    MotionCompCallbacks.DestroyMoComp(&DestroyMoCompData);
            }
        }

        // Remove from the motion comp object from linked-list:

        peDirectDrawLocal = peMotionComp->peDirectDrawLocal;

        if (peDirectDrawLocal->peMotionComp_DdList == peMotionComp)
        {
            peDirectDrawLocal->peMotionComp_DdList
                = peMotionComp->peMotionComp_DdNext;
        }
        else
        {
            for (peTmp = peDirectDrawLocal->peMotionComp_DdList;
                 ( peTmp != NULL)&&(peTmp->peMotionComp_DdNext != peMotionComp);
                 peTmp = peTmp->peMotionComp_DdNext)
                 ;

            if( peTmp != NULL )
            {
                peTmp->peMotionComp_DdNext = peMotionComp->peMotionComp_DdNext;
            }
        }

        // We're all done with this object, so free the memory and
        // leave:

        DdFreeObject(peMotionComp, DD_MOTIONCOMP_TYPE);

        bRet = TRUE;
    }
    else
    {
        WARNING1("bDdDeleteMotionComp: Bad handle or object was busy\n");
    }

    if (pdwRet != NULL)
    {
        *pdwRet = dwRet;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdCreateMoComp
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

HANDLE
APIENTRY
DxDdCreateMoComp(
    HANDLE                  hDirectDraw,
    PDD_CREATEMOCOMPDATA    puCreateMoCompData
    )
{
    HANDLE                  hRet;
    DWORD                   dwRet;
    DD_CREATEMOCOMPDATA     CreateMoCompData;
    GUID                    guid;
    PBYTE                   puData;
    ULONG                   cjData;
    HANDLE                  hSecure;

    __try
    {
        CreateMoCompData =
            ProbeAndReadStructure(puCreateMoCompData,
                                  DD_CREATEMOCOMPDATA);

        guid = ProbeAndReadStructure(CreateMoCompData.lpGuid,
                                    GUID);
        CreateMoCompData.lpGuid = &guid;

        puData = (PBYTE) CreateMoCompData.lpData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    hRet                   = NULL;
    dwRet = DDHAL_DRIVER_HANDLED;
    CreateMoCompData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_MOTIONCOMP*         peMotionComp;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        // Here we do the minimal validations checks to ensure that bad
        // parameters won't crash NT.  We're not more strict than
        // checking for stuff that will crash us, as the user-mode part
        // of DirectDraw handles that.

        peMotionComp = (EDD_MOTIONCOMP*) DdHmgAlloc(sizeof(EDD_MOTIONCOMP),
                                               DD_MOTIONCOMP_TYPE,
                                               HMGR_ALLOC_LOCK);
        if (peMotionComp)
        {
            // Private data:

            peMotionComp->peDirectDrawGlobal = peDirectDrawGlobal;
            peMotionComp->peDirectDrawLocal = peDirectDrawLocal;
            cjData = CreateMoCompData.dwDataSize;

            // Public data:

            peMotionComp->lpDD     = peDirectDrawGlobal;
            RtlCopyMemory(&(peMotionComp->guid),
                  &guid,
                  sizeof(GUID));
            peMotionComp->dwUncompWidth = CreateMoCompData.dwUncompWidth;
            peMotionComp->dwUncompHeight = CreateMoCompData.dwUncompHeight;
            RtlCopyMemory(&(peMotionComp->ddUncompPixelFormat),
                  &CreateMoCompData.ddUncompPixelFormat,
                  sizeof(DDPIXELFORMAT));

            // Hold devlock for driver call

            EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

            // Add this videoport to the list hanging off the
            // DirectDrawLocal object allocated for this process:

            peMotionComp->peMotionComp_DdNext
                    = peDirectDrawLocal->peMotionComp_DdList;
            peDirectDrawLocal->peMotionComp_DdList
                    = peMotionComp;

            // Now call the driver to create its version:

            CreateMoCompData.lpDD              = peDirectDrawGlobal;
            CreateMoCompData.lpMoComp          = peMotionComp;
            CreateMoCompData.ddRVal            = DDERR_GENERIC;
            dwRet = DDHAL_DRIVER_NOTHANDLED;    // Call is optional
            if ((!peDirectDrawGlobal->bSuspended) &&
                (peDirectDrawGlobal->MotionCompCallbacks.CreateMoComp))
            {
                hSecure = 0;
                if( puData )
                {
                    __try
                    {
                        ProbeForWrite(puData, cjData, sizeof(UCHAR));

                        hSecure = MmSecureVirtualMemory(puData,
                                                    cjData,
                                                    PAGE_READWRITE);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    }
                }
                if( ( puData == NULL ) || hSecure )
                {
                    CreateMoCompData.lpData = puData;

                    dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        CreateMoComp(&CreateMoCompData);
                }
                else
                {
                    WARNING("DxDdCreateMoComp: Bad data buffer\n");
                    dwRet = DDHAL_DRIVER_HANDLED;
                }

                if( hSecure )
                {
                    MmUnsecureVirtualMemory(hSecure);
                }
                if ((CreateMoCompData.ddRVal == DD_OK))
                {
                    peMotionComp->fl |= DD_MOTIONCOMP_FLAG_DRIVER_CREATED;
                }
                else
                {
                    WARNING("DxDdCreateMoComp: Driver failed call\n");
                }
            }
            if ((dwRet == DDHAL_DRIVER_NOTHANDLED) ||
                (CreateMoCompData.ddRVal == DD_OK))
            {
                    CreateMoCompData.ddRVal = DD_OK;
                    hRet = peMotionComp->hGet();
                    DEC_EXCLUSIVE_REF_CNT( peMotionComp );
            }
            else
            {
                bDdDeleteMotionCompObject(peMotionComp->hGet(), NULL);

                CreateMoCompData.ddRVal = DDERR_GENERIC;
            }
        }
        else
        {
            WARNING("DxDdCreateMoComp: Bad parameters\n");
        }
    }
    else
    {
        WARNING("DxDdCreateMoComp: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puCreateMoCompData->ddRVal, CreateMoCompData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    // Note that the user-mode stub always returns DDHAL_DRIVER_HANDLED
    // to DirectDraw.

    return(hRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetMoCompBuffInfo
*
*  17-Jun-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetMoCompBuffInfo(
    HANDLE                    hDirectDraw,
    PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData
    )
{
    DWORD                    dwRet;
    DD_GETMOCOMPCOMPBUFFDATA GetBuffData;
    LPDDCOMPBUFFERINFO       puBuffInfo;
    GUID                     guid;
    ULONG                    cjNumTypes;
    HANDLE                   hSecure;

    __try
    {
        GetBuffData =
            ProbeAndReadStructure(puGetBuffData,
                                  DD_GETMOCOMPCOMPBUFFDATA);
        guid = ProbeAndReadStructure(GetBuffData.lpGuid,
                                    GUID);
        GetBuffData.lpGuid = &guid;
        puBuffInfo = GetBuffData.lpCompBuffInfo;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet = DDHAL_DRIVER_HANDLED;
    GetBuffData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if(  peDirectDrawLocal != NULL )
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetBuffData.lpDD                 = peDirectDrawGlobal;
        GetBuffData.dwNumTypesCompBuffs = 0;
        GetBuffData.lpCompBuffInfo      = NULL;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.GetMoCompBuffInfo))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompBuffInfo(&GetBuffData);

            cjNumTypes = GetBuffData.dwNumTypesCompBuffs *
                     sizeof(DDCOMPBUFFERINFO);

            if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                (GetBuffData.ddRVal == DD_OK) &&
                (cjNumTypes > 0) &&
                (puBuffInfo != NULL))
            {
                hSecure = 0;
                GetBuffData.ddRVal = DDERR_GENERIC;

                __try
                {
                    ProbeForWrite(puBuffInfo, cjNumTypes, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puBuffInfo,
                                                    cjNumTypes,
                                                    PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }

                if (hSecure)
                {
                    GetBuffData.lpCompBuffInfo = puBuffInfo;

                    dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetMoCompBuffInfo(&GetBuffData);

                    MmUnsecureVirtualMemory(hSecure);
                }
                else
                {
                    WARNING("DxDdGetMoCompBuffInfo: Bad destination buffer\n");
                }
            }
        }
    }
    else
    {
        WARNING("DxDdGetMoCompBuffInfo: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetBuffData->ddRVal,
                          GetBuffData.ddRVal);
        ProbeAndWriteUlong(&puGetBuffData->dwNumTypesCompBuffs,
                           GetBuffData.dwNumTypesCompBuffs);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdGetInternalMoCompInfo
*
*  17-Jun-1998 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdGetInternalMoCompInfo(
    HANDLE                    hDirectDraw,
    PDD_GETINTERNALMOCOMPDATA puGetInternalData
    )
{
    DWORD                    dwRet;
    DD_GETINTERNALMOCOMPDATA GetInternalData;
    GUID                     guid;

    __try
    {
        GetInternalData =
            ProbeAndReadStructure(puGetInternalData,
                                  DD_GETINTERNALMOCOMPDATA);
        guid = ProbeAndReadStructure(GetInternalData.lpGuid,
                                    GUID);
        GetInternalData.lpGuid = &guid;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet = DDHAL_DRIVER_HANDLED;
    GetInternalData.ddRVal = DDERR_GENERIC;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if(  peDirectDrawLocal != NULL )
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        GetInternalData.lpDD              = peDirectDrawGlobal;
        GetInternalData.dwScratchMemAlloc = 0;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.GetInternalMoCompInfo))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                        GetInternalMoCompInfo(&GetInternalData);

        }
    }
    else
    {
        WARNING("DxDdGetInternalMoCompInfo: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puGetInternalData->ddRVal,
                          GetInternalData.ddRVal);
        ProbeAndWriteUlong(&puGetInternalData->dwScratchMemAlloc,
                           GetInternalData.dwScratchMemAlloc);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdDestroyMoComp
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdDestroyMoComp(
    HANDLE                  hMoComp,
    PDD_DESTROYMOCOMPDATA   puDestroyMoCompData
    )
{
    DWORD   dwRet;

    bDdDeleteMotionCompObject(hMoComp, &dwRet);

    __try
    {
        ProbeAndWriteRVal(&puDestroyMoCompData->ddRVal, DD_OK);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdBeginMoCompFrame
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdBeginMoCompFrame(
    HANDLE                   hMoComp,
    PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData
    )
{
    DWORD                       dwRet;
    DD_BEGINMOCOMPFRAMEDATA     BeginFrameData;
    LPBYTE                      puInputData;
    ULONG                       cjInputData;
    LPBYTE                      puOutputData;
    ULONG                       cjOutputData;
    ULONG                       cjRefData;
    HANDLE                      hInputSecure;
    HANDLE                      hOutputSecure;
    DWORD                       dwNumRefSurfaces;
    DWORD                       i;
    DWORD                       j;

    __try
    {
        BeginFrameData
            = ProbeAndReadStructure(puBeginFrameData,
                                    DD_BEGINMOCOMPFRAMEDATA);

        puInputData = (PBYTE) BeginFrameData.lpInputData;
        puOutputData = (PBYTE) BeginFrameData.lpOutputData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_HANDLED;
    BeginFrameData.ddRVal    = DDERR_GENERIC;

    EDD_MOTIONCOMP*         peMotionComp;
    EDD_LOCK_MOTIONCOMP     eLockMotionComp;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_SURFACE*            peSurfaceDest;
    EDD_LOCK_SURFACE        eLockSurfaceDest;

    peSurfaceDest = eLockSurfaceDest.peLock(BeginFrameData.lpDestSurface);
    peMotionComp = eLockMotionComp.peLock(hMoComp);
    if ((peMotionComp != NULL) && (peSurfaceDest != NULL))
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;
        cjInputData = BeginFrameData.dwInputDataSize;
        cjOutputData = BeginFrameData.dwOutputDataSize;

        BeginFrameData.lpDD          = peDirectDrawGlobal;
        BeginFrameData.lpMoComp      = peMotionComp;
        BeginFrameData.lpDestSurface = peSurfaceDest;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.BeginMoCompFrame))
        {
            // Secure the input buffer
            hInputSecure = 0;
            if( puInputData )
            {
                __try
                {
                    ProbeForWrite(puInputData, cjInputData, sizeof(UCHAR));

                    hInputSecure = MmSecureVirtualMemory(puInputData,
                                            cjInputData,
                                            PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }
            }

            // Secure the output buffer
            hOutputSecure = 0;
            if( puOutputData )
            {
                __try
                {
                    ProbeForWrite(puOutputData, cjOutputData, sizeof(UCHAR));

                    hOutputSecure = MmSecureVirtualMemory(puOutputData,
                                            cjOutputData,
                                            PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }
            }
            if( ( ( puInputData == NULL ) || hInputSecure ) &&
                ( ( puOutputData == NULL ) || hOutputSecure ) )
            {
                BeginFrameData.lpInputData = puInputData;
                BeginFrameData.lpOutputData = puOutputData;

                dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                    BeginMoCompFrame(&BeginFrameData);
                if ((BeginFrameData.ddRVal != DD_OK) &&
                    (dwRet == DDHAL_DRIVER_NOTHANDLED))
                {
                    WARNING("DxDdBeginMoCompFrame: Driver failed callad\n");
                }
            }
            else
            {
                WARNING("DxDdBeginMoCompFrame: Bad intput or output buffer\n");
                dwRet = DDHAL_DRIVER_HANDLED;
            }

            if( hInputSecure )
            {
                MmUnsecureVirtualMemory(hInputSecure);
            }
            if( hOutputSecure )
            {
                MmUnsecureVirtualMemory(hOutputSecure);
            }
        }
    }
    else
    {
        WARNING("DxDdBeginMoCompFrame: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puBeginFrameData->ddRVal,
            BeginFrameData.ddRVal);
        ProbeAndWriteUlong(&puBeginFrameData->dwOutputDataSize,
            BeginFrameData.dwOutputDataSize);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdEndMoCompFrame
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdEndMoCompFrame(
    HANDLE                  hMoComp,
    PDD_ENDMOCOMPFRAMEDATA  puEndFrameData
    )
{
    DWORD                       dwRet;
    DD_ENDMOCOMPFRAMEDATA       EndFrameData;
    LPBYTE                      puData;
    ULONG                       cjData;
    HANDLE                      hSecure;

    __try
    {
        EndFrameData
            = ProbeAndReadStructure(puEndFrameData,
                                    DD_ENDMOCOMPFRAMEDATA);

        puData = (PBYTE) EndFrameData.lpInputData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                    = DDHAL_DRIVER_HANDLED;
    EndFrameData.ddRVal      = DDERR_GENERIC;

    EDD_MOTIONCOMP*         peMotionComp;
    EDD_LOCK_MOTIONCOMP     eLockMotionComp;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peMotionComp = eLockMotionComp.peLock(hMoComp);
    if (peMotionComp != NULL)
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;
        cjData = EndFrameData.dwInputDataSize;

        EndFrameData.lpDD         = peDirectDrawGlobal;
        EndFrameData.lpMoComp     = peMotionComp;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.EndMoCompFrame))
        {
            hSecure = 0;
            if( puData )
            {
                __try
                {
                    ProbeForWrite(puData, cjData, sizeof(UCHAR));

                    hSecure = MmSecureVirtualMemory(puData,
                                                cjData,
                                                PAGE_READWRITE);
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                }
            }
            if( ( puData == NULL ) || hSecure )
            {
                EndFrameData.lpInputData = puData;

                dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                    EndMoCompFrame(&EndFrameData);
                if ((dwRet == DDHAL_DRIVER_HANDLED) &&
                    (EndFrameData.ddRVal != DD_OK))
                {
                    WARNING("DxDdEndMoCompFrame: Driver failed call\n");
                }
            }
            else
            {
                WARNING("DxDdEndMoCompFrame: Bad data buffer\n");
            }

            if( hSecure )
            {
                MmUnsecureVirtualMemory(hSecure);
            }
        }
    }
    else
    {
        WARNING("DxDdEndMoCompFrame: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puEndFrameData->ddRVal,
            EndFrameData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdRenderMoComp
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdRenderMoComp(
    HANDLE                  hMoComp,
    PDD_RENDERMOCOMPDATA    puRenderMoCompData
    )
{
    DWORD                       dwRet;
    DD_RENDERMOCOMPDATA         RenderMoCompData;
    LPDDMOCOMPBUFFERINFO        pMacroBlocks;
    DWORD                       dwNumMacroBlocks;
    LPBYTE                      puData;
    ULONG                       cjData;
    HANDLE                      hSecure;
    LPBYTE                      puInputData;
    ULONG                       cjInputData;
    LPBYTE                      puOutputData;
    ULONG                       cjOutputData;
    DWORD                       i;
    DWORD                       j;

    __try
    {
        RenderMoCompData
            = ProbeAndReadStructure(puRenderMoCompData,
                                    DD_RENDERMOCOMPDATA);

        pMacroBlocks = RenderMoCompData.lpBufferInfo;
        dwNumMacroBlocks = RenderMoCompData.dwNumBuffers;
        puInputData = (PBYTE) RenderMoCompData.lpInputData;
        puOutputData = (PBYTE) RenderMoCompData.lpOutputData;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                   = DDHAL_DRIVER_HANDLED;
    RenderMoCompData.ddRVal = DDERR_GENERIC;

    EDD_MOTIONCOMP*         peMotionComp;
    EDD_LOCK_MOTIONCOMP     eLockMotionComp;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peMotionComp = eLockMotionComp.peLock(hMoComp);
    if (peMotionComp != NULL)
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;

        RenderMoCompData.lpDD         = peDirectDrawGlobal;
        RenderMoCompData.lpMoComp     = peMotionComp;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.RenderMoComp))
        {
            if (!BALLOC_OVERFLOW1(dwNumMacroBlocks, DDMOCOMPBUFFERINFO))
            {
                cjData = dwNumMacroBlocks * sizeof(DDMOCOMPBUFFERINFO);
                hSecure = 0;
                if (pMacroBlocks)
                {
                    __try
                    {
                        ProbeForWrite(pMacroBlocks, cjData, sizeof(UCHAR));

                        hSecure = MmSecureVirtualMemory(pMacroBlocks,
                                                cjData,
                                                PAGE_READWRITE);
                    }
                    __except(EXCEPTION_EXECUTE_HANDLER)
                    {
                    }
                    for (i = 0; i < dwNumMacroBlocks; i++)
                    {
                        // HmgLock return EDD_SURFACE, but we need a pointer to
                        // a DD_SURFACE_LOCAL, so we need to adjust by the size of
                        // an OBJECT.  This means when releasing the lock, we need to
                        // reverse this adjustment.

                        pMacroBlocks[i].lpCompSurface = (PDD_SURFACE_LOCAL)
                            ((LPBYTE)(DdHmgLock((HDD_OBJ)(pMacroBlocks[i].lpCompSurface), DD_SURFACE_TYPE, FALSE))
                               + sizeof(DD_OBJECT));
                        if (pMacroBlocks[i].lpCompSurface == NULL)
                        {
                            for (j = 0; j < i; j++)
                            {
                                DEC_EXCLUSIVE_REF_CNT(((LPBYTE)(pMacroBlocks[i].lpCompSurface) - sizeof(DD_OBJECT)));
                            }
                            MmUnsecureVirtualMemory(hSecure);
                            hSecure = 0;
                            break;
                        }
                    }
                }
                if( (( pMacroBlocks == NULL ) && (dwNumMacroBlocks == 0)) ||
                    hSecure )
                {
                    HANDLE hInputSecure = 0;
                    HANDLE hOutputSecure = 0;

                    // Secure the input buffer
                    cjInputData = RenderMoCompData.dwInputDataSize;
                    cjOutputData = RenderMoCompData.dwOutputDataSize;
                    if( puInputData )
                    {
                        __try
                        {
                            ProbeForWrite(puInputData, cjInputData, sizeof(UCHAR));

                            hInputSecure = MmSecureVirtualMemory(puInputData,
                                                    cjInputData,
                                                    PAGE_READWRITE);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                    }

                    // Secure the output buffer
                    if( puOutputData )
                    {
                        __try
                        {
                            ProbeForWrite(puOutputData, cjOutputData, sizeof(UCHAR));

                            hOutputSecure = MmSecureVirtualMemory(puOutputData,
                                                    cjOutputData,
                                                    PAGE_READWRITE);
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                        }
                    }
                    if( ( ( puInputData == NULL ) || hInputSecure ) &&
                        ( ( puOutputData == NULL ) || hOutputSecure ) )
                    {
                        RenderMoCompData.lpInputData = puInputData;
                        RenderMoCompData.lpOutputData = puOutputData;
                        RenderMoCompData.lpBufferInfo = pMacroBlocks;

                        dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                            RenderMoComp(&RenderMoCompData);
                        if (RenderMoCompData.ddRVal != DD_OK)
                        {
                            WARNING("DxDdEnderMoComp: Driver failed call\n");
                        }
                    }

                    if( hInputSecure )
                    {
                        MmUnsecureVirtualMemory(hInputSecure);
                    }
                    if( hOutputSecure )
                    {
                        MmUnsecureVirtualMemory(hOutputSecure);
                    }
                }

                if( hSecure )
                {
                    for (i = 0; i < dwNumMacroBlocks; i++)
                    {
                        DEC_EXCLUSIVE_REF_CNT(((LPBYTE)(pMacroBlocks[i].lpCompSurface) - sizeof(DD_OBJECT)));
                    }
                    MmUnsecureVirtualMemory(hSecure);
                }
            }
        }
    }
    else
    {
        WARNING("DxDdRenderMoComp: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puRenderMoCompData->ddRVal,
            RenderMoCompData.ddRVal);
        ProbeAndWriteUlong(&puRenderMoCompData->dwOutputDataSize,
            RenderMoCompData.dwOutputDataSize);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdQueryMoCompStatus
*
*  18-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdQueryMoCompStatus(
    HANDLE                  hMoComp,
    PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData
    )
{
    DWORD                       dwRet;
    DD_QUERYMOCOMPSTATUSDATA    QueryMoCompData;

    __try
    {
        QueryMoCompData
            = ProbeAndReadStructure(puQueryMoCompStatusData,
                                    DD_QUERYMOCOMPSTATUSDATA);

    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet                  = DDHAL_DRIVER_HANDLED;
    QueryMoCompData.ddRVal = DDERR_GENERIC;

    EDD_MOTIONCOMP*         peMotionComp;
    EDD_LOCK_MOTIONCOMP     eLockMotionComp;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;
    EDD_SURFACE*            peSurface;
    EDD_LOCK_SURFACE        eLockSurface;

    peMotionComp = eLockMotionComp.peLock(hMoComp);
    peSurface = eLockSurface.peLock(QueryMoCompData.lpSurface);
    if ((peMotionComp != NULL) && (peSurface != NULL))
    {
        peDirectDrawGlobal = peMotionComp->peDirectDrawGlobal;

        QueryMoCompData.lpDD         = peDirectDrawGlobal;
        QueryMoCompData.lpMoComp     = peMotionComp;
        QueryMoCompData.lpSurface    = peSurface;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((!peDirectDrawGlobal->bSuspended) &&
            (peDirectDrawGlobal->MotionCompCallbacks.QueryMoCompStatus))
        {
            dwRet = peDirectDrawGlobal->MotionCompCallbacks.
                QueryMoCompStatus(&QueryMoCompData);
            if (QueryMoCompData.ddRVal != DD_OK)
            {
                WARNING("DxDdQueryMoCompStatus: Driver failed call\n");
            }
        }
    }
    else
    {
        WARNING("DxDdQueryMoCompStatus: Invalid object\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puQueryMoCompStatusData->ddRVal,
            QueryMoCompData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}

/******************************Public*Routine******************************\
* DWORD DxDdAlphaBlt
*
*  24-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DxDdAlphaBlt(
    HANDLE      hSurfaceDest,
    HANDLE      hSurfaceSrc,
    PDD_BLTDATA puBltData
    )
{
    DWORD       dwRet;
    DD_BLTDATA  BltData;

    __try
    {
        BltData
            = ProbeAndReadStructure(puBltData,
                                    DD_BLTDATA);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(DDHAL_DRIVER_NOTHANDLED);
    }

    dwRet          = DDHAL_DRIVER_NOTHANDLED;
    BltData.ddRVal = DDERR_GENERIC;

    EDD_SURFACE*            peSurfaceDest;
    EDD_SURFACE*            peSurfaceSrc;
    EDD_LOCK_SURFACE        eLockSurfaceDest;
    EDD_LOCK_SURFACE        eLockSurfaceSrc;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peSurfaceDest = eLockSurfaceDest.peLock(hSurfaceDest);
    BltData.lpDDDestSurface = peSurfaceDest;

    if (peSurfaceDest != NULL)
    {
        peDirectDrawGlobal = peSurfaceDest->peDirectDrawGlobal;
        if( peDirectDrawGlobal->flDriverInfo & DD_DRIVERINFO_MORECAPS )
        {
            // We support only a specific set of Blt calls down to the driver
            // that we're willing to support and to test.

            if (hSurfaceSrc == NULL)
            {
                // Do simpler stuff 'cause we don't need to lock a source:

                BltData.lpDDSrcSurface = NULL;
                peSurfaceSrc = NULL;

                if ((peSurfaceDest->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY) &&
                    (peDirectDrawGlobal->MoreCaps.dwVSBAlphaCaps == 0) &&
                    (peDirectDrawGlobal->MoreCaps.dwSSBAlphaCaps == 0))
                {
                    WARNING("DxDdAlphaBlt: Can't blt to system memory surface");
                    return(dwRet);
                }
            }
            else
            {
                // Lock the source surface:

                peSurfaceSrc = eLockSurfaceSrc.peLock(hSurfaceSrc);
                BltData.lpDDSrcSurface = peSurfaceSrc;

                // Ensure that both surfaces belong to the same DirectDraw
                // object, and check source rectangle:

                if ((peSurfaceSrc == NULL)                               ||
                    (peSurfaceSrc->peDirectDrawLocal !=
                        peSurfaceDest->peDirectDrawLocal)            ||
                    (BltData.rSrc.left   < 0)                            ||
                    (BltData.rSrc.top    < 0)                            ||
                    (BltData.rSrc.right  > (LONG) peSurfaceSrc->wWidth)  ||
                    (BltData.rSrc.bottom > (LONG) peSurfaceSrc->wHeight) ||
                    (BltData.rSrc.left  >= BltData.rSrc.right)           ||
                    (BltData.rSrc.top   >= BltData.rSrc.bottom))
                {
                    WARNING("DxDdAlphaBlt: Invalid source surface or source rectangle\n");
                    return(dwRet);
                }

                if (peSurfaceDest->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                {
                    if (peSurfaceSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    {
                        if (peDirectDrawGlobal->MoreCaps.dwSSBAlphaCaps == 0)
                        {
                            WARNING("DxDdAlphaBlt: System to System Blts not supported\n");
                            return(dwRet);
                        }
                    }
                    else if (peDirectDrawGlobal->MoreCaps.dwVSBAlphaCaps == 0)
                    {
                        WARNING("DxDdAlphaBlt: Video to System Blts not supported\n");
                        return(dwRet);
                    }
                }
                else
                {
                    if (peSurfaceSrc->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                    {
                        if (peDirectDrawGlobal->MoreCaps.dwSVBAlphaCaps == 0)
                        {
                            WARNING("DxDdAlphaBlt: System to Video Blts not supported\n");
                            return(dwRet);
                        }
                    }
                    else if (peDirectDrawGlobal->MoreCaps.dwAlphaCaps == 0)
                    {
                        WARNING("DxDdAlphaBlt: Video to Video Blts not supported\n");
                        return(dwRet);
                    }
                }
            }

            // Make sure that we weren't given rectangle coordinates
            // which might cause the driver to crash.  Note that we
            // don't allow inverting stretch blts:

            if ((BltData.rDest.left   >= 0)                             &&
                (BltData.rDest.top    >= 0)                             &&
                (BltData.rDest.right  <= (LONG) peSurfaceDest->wWidth)  &&
                (BltData.rDest.bottom <= (LONG) peSurfaceDest->wHeight) &&
                (BltData.rDest.left    < BltData.rDest.right)           &&
                (BltData.rDest.top     < BltData.rDest.bottom))
            {
                BltData.lpDD = peDirectDrawGlobal;

                // Make sure that the surfaces aren't associated
                // with a PDEV whose mode has gone away.
                //
                // Also ensure that there are no outstanding
                // surface locks if running on a brain-dead video
                // card that crashes if the accelerator runs at
                // the same time the frame buffer is accessed.

                EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

                // We will return SURFACELOST when ...
                //
                // 1) This device is suspended.
                // 2) The driver managed surface is managed by other device.
                // 3) One of surface is losted.
                // 4) The visible region has been changed when surface is primary.

                if (peDirectDrawGlobal->bSuspended)                                 // 1)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_WRONG_DRIVER) ||
                         ((peSurfaceSrc != NULL) &&
                          (peSurfaceSrc->fl & DD_SURFACE_FLAG_WRONG_DRIVER)))       // 2)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->bLost) ||
                         ((peSurfaceSrc != NULL) && (peSurfaceSrc->bLost)))         // 3)
                {
                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_SURFACELOST;
                }
                else if ((peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY) &&
                         (peSurfaceDest->iVisRgnUniqueness != VISRGN_UNIQUENESS())) // 4)
                {
                    // The VisRgn changed since the application last queried it;
                    // fail the call with a unique error code so that they know
                    // to requery the VisRgn and try again:

                    dwRet = DDHAL_DRIVER_HANDLED;
                    BltData.ddRVal = DDERR_VISRGNCHANGED;
                }
                else
                {
                    if (peDirectDrawGlobal->Miscellaneous2CallBacks.AlphaBlt)
                    {
                        DEVEXCLUDERECT dxo;
                        HANDLE hSecure;
                        ULONG cjData;
                        DWORD i;
                        LPRECT lpRect;

                        // Secure the clip list and ensure that all of its
                        // rectangles are valid

                        hSecure = 0;
                        if( BltData.dwRectCnt == 0 )
                        {
                            BltData.prDestRects = NULL;
                        }
                        else if ( BltData.prDestRects == NULL )
                        {
                            BltData.dwRectCnt = 0;
                        }
                        else
                        {
                            __try
                            {
                                cjData = BltData.dwRectCnt * sizeof( RECT );
                                if (!BALLOC_OVERFLOW1(BltData.dwRectCnt, RECT))
                                {
                                    ProbeForWrite(BltData.prDestRects, cjData, sizeof(UCHAR));

                                    hSecure = MmSecureVirtualMemory(BltData.prDestRects,
                                                    cjData,
                                                    PAGE_READWRITE);
                                }
                            }
                            __except(EXCEPTION_EXECUTE_HANDLER)
                            {
                            }
                            if( hSecure == NULL )
                            {
                                BltData.ddRVal = DDERR_OUTOFMEMORY;
                                dwRet = DDHAL_DRIVER_HANDLED;
                            }
                            else
                            {
                                // Validate each rectangle

                                lpRect = BltData.prDestRects;
                                for( i = 0; i < BltData.dwRectCnt; i++ )
                                {
                                    if ((lpRect->left   < 0)                     ||
                                        (lpRect->top    < 0)                     ||
                                        (lpRect->left   > lpRect->right )        ||
                                        (lpRect->top    > lpRect->bottom ) )
                                    {
                                        MmUnsecureVirtualMemory(hSecure);
                                        WARNING("DxDdAlphaBlt: Couldn't lock destination surface\n");
                                        dwRet = DDHAL_DRIVER_HANDLED;
                                        BltData.ddRVal = DDERR_INVALIDPARAMS;
                                        break;
                                    }
                                    lpRect++;
                                }
                            }
                        }

                        // Only do the Blt it everything has worked up until now

                        if( dwRet == DDHAL_DRIVER_NOTHANDLED )
                        {
                            // Exclude the mouse pointer if necessary:

                            if (peSurfaceDest->fl & DD_SURFACE_FLAG_PRIMARY)
                            {
                                dxo.vExclude(peDirectDrawGlobal->hdev,
                                             &BltData.rDest);
                            }

                            dwRet = peDirectDrawGlobal->Miscellaneous2CallBacks.
                                AlphaBlt(&BltData);

                            if( hSecure )
                            {
                                MmUnsecureVirtualMemory(hSecure);
                            }
                        }
                    }
                }
            }
            else
            {
                WARNING("DxDdAlphaBlt: Invalid destination rectangle\n");
            }
        }
        else
        {
            WARNING("DxDdAlphaBlt: Alpha not supported\n");
        }
    }
    else
    {
        WARNING("DxDdAlphaBlt: Couldn't lock destination surface\n");
    }

    // We have to wrap this in another try-except because the user-mode
    // memory containing the input may have been deallocated by now:

    __try
    {
        ProbeAndWriteRVal(&puBltData->ddRVal, BltData.ddRVal);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return(dwRet);
}


/******************************Public*Routine******************************\
* DxDdSetGammaRamp
*
* The reason we need this function when GDI already has one is that
* DirectDraw games need the ability to set bizarre gamma ramps to
* achieve special effects.  The GDI SetDeviceGammaRamp call does a range
* check that will reject all of these gamma ramps.  When this function is
* used, DirectDraw gaurentees that the original gamma ramp gets restored
* when the game gets minimized or exits.
*
* History:
*
* Wrote it:
*  06-Jun-1998 -by- Scott MacDonald [smac]
\**************************************************************************/

#define MAX_COLORTABLE     256

BOOL
DxDdSetGammaRamp(
    HANDLE  hDirectDraw,
    HDC     hdc,
    LPVOID  lpGammaRamp
    )
{
    WORD *  pTemp1;
    WORD *  pTemp2;
    int     i;

    BOOL bRet = FALSE;

    EDD_DIRECTDRAW_LOCAL*   peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_DIRECTDRAW_GLOBAL*  peDirectDrawGlobal;

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL)
    {
        peDirectDrawGlobal = peDirectDrawLocal->peDirectDrawGlobal;

        if (lpGammaRamp)
        {
            HANDLE hSecure = NULL;
            BOOL   bError  = FALSE;

            __try
            {
                ProbeForRead(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, sizeof(BYTE));
                hSecure = MmSecureVirtualMemory(lpGammaRamp, MAX_COLORTABLE * sizeof(WORD) * 3, PAGE_READONLY);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("DxDdSetGammaRamp: Fail to capture usermode buffer\n");
                bError = TRUE;
            }

            {
                EDD_SHAREDEVLOCK eDevlock(peDirectDrawGlobal);

                // If the gamma has not already been set by this app, get the existing gamma
                // ramp and save it so we can clean up after ourselves.

                if ((peDirectDrawLocal->pGammaRamp == NULL) && !bError)
                {
                    peDirectDrawLocal->pGammaRamp = (WORD *) PALLOCMEM(MAX_COLORTABLE * 3 * sizeof(WORD), 'pddG');
                    if (peDirectDrawLocal->pGammaRamp != NULL)
                    {
                        bRet = DxEngGetDeviceGammaRamp( peDirectDrawGlobal->hdev, peDirectDrawLocal->pGammaRamp );
                        if (!bRet)
                        {
                            bError = TRUE;
                        }
                    }
                    else
                    {
                        bError = TRUE;
                    }
                }

                // If this new gamma ramp is the same as the original ramp, we know
                // that we are restoring it.

                if ((peDirectDrawLocal->pGammaRamp != NULL) && !bError)
                {
                    pTemp1 = (WORD *) lpGammaRamp;
                    pTemp2 = peDirectDrawLocal->pGammaRamp;
                    for (i = 0; i < MAX_COLORTABLE * 3; i++)
                    {
                        if (*pTemp1++ != *pTemp2++)
                        {
                            break;
                        }
                    }
                    if (i == MAX_COLORTABLE * 3)
                    {
                        VFREEMEM(peDirectDrawLocal->pGammaRamp);
                        peDirectDrawLocal->pGammaRamp = NULL;
                    }
                }

                if ((bError == FALSE) && hSecure)
                {
                    bRet = DxEngSetDeviceGammaRamp(peDirectDrawGlobal->hdev, lpGammaRamp, FALSE);
                }
            }

            if (hSecure)
            {
                MmUnsecureVirtualMemory(hSecure);
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
    }
    else
    {
        WARNING("DxDdSetGammaRamp: Invalid DirectDraw object specified\n");
    }

    return(bRet);
}


/******************************Public*Routine******************************\
* DxDdCreateSurfaceEx
*
* Just notify driver of new handle association by calling its
* CreateSurfaceEx
*
* History:
*
* Wrote it:
*  25-Feb-1999 -by- Kan Qiu [kanqiu]
\**************************************************************************/

DWORD
APIENTRY
DxDdCreateSurfaceEx(
    HANDLE  hDirectDraw,
    HANDLE  hSurface,
    DWORD   dwSurfaceHandle
    )
{
    EDD_DIRECTDRAW_LOCAL*  peDirectDrawLocal;
    EDD_LOCK_DIRECTDRAW     eLockDirectDraw;
    EDD_SURFACE*   peSurface;
    EDD_LOCK_SURFACE        eLockSurface;

    peSurface = eLockSurface.peLock( hSurface );

    if (peSurface == NULL)
    {
        WARNING("DxDdCreateSurfaceEx: Invalid surfaces specified\n");
        return DDERR_GENERIC;
    }

    peDirectDrawLocal = eLockDirectDraw.peLock(hDirectDraw);
    if (peDirectDrawLocal != NULL )
    {
        EDD_DIRECTDRAW_GLOBAL *peDirectDrawGlobal =
            peDirectDrawLocal->peDirectDrawGlobal;

        EDD_DEVLOCK eDevlock(peDirectDrawGlobal);

        if ((peSurface->dwSurfaceHandle != 0) &&
            (peSurface->dwSurfaceHandle != dwSurfaceHandle))
        {
            WARNING("DxDdCreateSurfaceEx: called with surface which has been called already\n");
        }

        if (peDirectDrawGlobal->bSuspended)
        {
            return DDERR_SURFACELOST;
        }
        else if ((peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx) &&
                 (dwSurfaceHandle != 0))
        {
            DD_CREATESURFACEEXDATA CreateSurfaceExData;

            peSurface->lpSurfMore->dwSurfaceHandle = dwSurfaceHandle;

            // Use the CreateSurfaceEx DDI to once again inform the
            // driver that something has changed
            CreateSurfaceExData.dwFlags        = 0;
            CreateSurfaceExData.ddRVal         = DDERR_GENERIC;
            CreateSurfaceExData.lpDDLcl        = peDirectDrawLocal;
            CreateSurfaceExData.lpDDSLcl       = peSurface;

            peDirectDrawGlobal->Miscellaneous2CallBacks.CreateSurfaceEx(&CreateSurfaceExData);
            if (CreateSurfaceExData.ddRVal != DD_OK)
            {
                WARNING("DxDdCreateSurfaceEx: DDI call to the driver failed\n");
                return (CreateSurfaceExData.ddRVal);
            }
            else
            {
                if (peSurface->ddsCaps.dwCaps & DDSCAPS_SYSTEMMEMORY)
                {
                    PDEVOBJ po(peDirectDrawGlobal->hdev);

                    // Mark we called CreateSurfaceEx on this surface.
                    // this information will be used when we need to call
                    // CreateSurfaceEx after video mode change.
                    peSurface->fl |= DD_SURFACE_FLAG_SYSMEM_CREATESURFACEEX;

                    ASSERTGDI(peSurface->pGraphicsDeviceCreator == po.pGraphicsDevice(),
                              "DXG: CreateSurfaceEx: calling non-owner driver");
                }
            }
        }
        else
        {
            return DDERR_GENERIC;
        }
    }
    return DD_OK;
}

/******************************Public*Routine******************************\
* VOID DxDdCloseProcess
*
*   2-May-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID DxDdCloseProcess(W32PID w32Pid)
{
    DdHmgCloseProcess(w32Pid);
}

/******************************Public*Routine******************************\
* PVOID DxDdAllocPrivateUserMem()
*
* History:
*  28-Oct-1999 -by-  Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

PVOID
DxDdAllocPrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    SIZE_T cj,  //ZwAllocateVirtualMemory uses SIZE_T, change accordingly
    ULONG tag
    )
{
    EDD_SURFACE *peSurface = (EDD_SURFACE *) pSurfaceLocal;
    PVOID pv = NULL;

    //
    // DirectDraw can call the driver outside of it's process (e.g. switching
    // desktops, etc.), so this function helps protect against that.
    //

    if (PsGetCurrentProcess() == peSurface->peDirectDrawLocal->Process)
    {
        pv = EngAllocUserMem ( cj, tag );
    }

    return pv;
}

/******************************Public*Routine******************************\
* DxDdFreePrivateUserMem()
*
* History:
*  28-Oct-1999 -by-  Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

VOID
DxDdFreePrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    PVOID pv
    )
{
    EDD_SURFACE *peSurface = (EDD_SURFACE *) pSurfaceLocal;

    // If the surface has an aliased lock on it, then we don't want
    // to delete this memory now or else the app may fault, so we put
    // it in a list of memory to free later.
    
    if (peSurface->fl & DD_SURFACE_FLAG_ALIAS_LOCK)
    {
        DeferMemoryFree(pv, peSurface);
    }
    else
    {   
        SafeFreeUserMem(pv, peSurface->peDirectDrawLocal->Process);
    }
    return;
}

/******************************Public*Routine******************************\
* DxDdIoctl()
*
* History:
*  17-Apr-2001 -by-  Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

HRESULT
DxDdIoctl(
    ULONG   Ioctl,
    PVOID   pBuffer,
    ULONG   BufferSize
    )
{
    return DDERR_UNSUPPORTED;
}

/******************************Public*Routine******************************\
*
* DxDdLock/UnlockDirectDrawSurface
*
* Functions to allow drivers to lock and unlock DirectDraw surface handles
* that may get passed to them.
*
* Such handles are currently passed to the driver in the Direct3D texture
* interface, necessitating these functions.
*
* History:
*  Wed Oct 23 15:52:27 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

PDD_SURFACE_LOCAL
DxDdLockDirectDrawSurface(HANDLE hSurface)
{
    EDD_SURFACE *peSurf;

    peSurf = (EDD_SURFACE *)DdHmgLock((HDD_OBJ)hSurface, DD_SURFACE_TYPE, FALSE);
    if (peSurf != NULL)
    {
        return (PDD_SURFACE_LOCAL)peSurf;
    }
    else
    {
        return peSurf;
    }
}

BOOL
DxDdUnlockDirectDrawSurface(PDD_SURFACE_LOCAL pSurface)
{
    if (pSurface != NULL)
    {
        DEC_EXCLUSIVE_REF_CNT((EDD_SURFACE *)pSurface);
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/******************************Public*Routine******************************\
* BOOL DxDdEnableDirectDrawRedirection
*
*  11-Apr-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

BOOL DxDdEnableDirectDrawRedirection(HDEV hdev, BOOL bEnable)
{
#ifdef DX_REDIRECTION
    LONG* pl;

    PDEVOBJ po(hdev);

    if (po.bValid())
    {
        // Hold devlock to prevent from mode change.

        EDD_DEVLOCK eDevLock(po.hdev());

        // Bump the mode uniqueness to let user-mode DirectDraw know that
        // someone else has done 'something' need to refresh user-mode
        // data.

        INC_DISPLAY_UNIQUENESS();

        // Save redirection status

        gbDxRedirection = bEnable;

        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
#else
    return (FALSE);
#endif // DX_REDIRECTION
}

/******************************Public*Routine******************************\
* VOID DxDdSetAccelLevel
*
*   2-Oct-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

VOID DxDdSetAccelLevel(HDEV hdev, DWORD dwAccelLevel, DWORD dwOverride)
{
    if ((dwAccelLevel >= 3) || 
        (dwOverride & DRIVER_NOT_CAPABLE_DDRAW))
    {
        PDEVOBJ po(hdev);

        po.peDirectDrawGlobal()->llAssertModeTimeout = 0;
    }
}

/******************************Public*Routine******************************\
* VOID DxDdGetSurfaceLock
*
*   2-Oct-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

DWORD DxDdGetSurfaceLock(HDEV hdev)
{
    PDEVOBJ po(hdev);

    return (po.peDirectDrawGlobal()->cSurfaceLocks);
}

/******************************Public*Routine******************************\
* VOID DxDdEnumLockedSurfaceRect
*
*   2-Oct-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

PVOID DxDdEnumLockedSurfaceRect(HDEV hdev, PVOID pvSurface, RECTL *pRect)
{
    PDEVOBJ     po(hdev);

    EDD_SURFACE *peSurface;

    if (pvSurface == NULL)
    {
        peSurface = po.peDirectDrawGlobal()->peSurface_PrimaryLockList;
    }
    else
    {
        peSurface = ((EDD_SURFACE *)pvSurface)->peSurface_PrimaryLockNext;
    }

    if (peSurface)
    {
        *pRect = peSurface->rclLock;
    }

    return ((PVOID)peSurface);
}

/******************************Public*Routine******************************\
* DWORD DxDxgGenericThunk
*
*  14-Jun-2000 -by- Hideyuki Nagase [hideyukn]
* Wrote it (stub).
\**************************************************************************/

DWORD DxDxgGenericThunk(
    IN     ULONG_PTR ulIndex,
    IN     ULONG_PTR ulHandle,
    IN OUT SIZE_T   *pdwSizeOfPtr1,
    IN OUT PVOID     pvPtr1,
    IN OUT SIZE_T   *pdwSizeOfPtr2,
    IN OUT PVOID     pvPtr2)
{
    UNREFERENCED_PARAMETER(ulIndex);
    UNREFERENCED_PARAMETER(ulHandle);
    UNREFERENCED_PARAMETER(pdwSizeOfPtr1);
    UNREFERENCED_PARAMETER(pvPtr1);
    UNREFERENCED_PARAMETER(pdwSizeOfPtr2);
    UNREFERENCED_PARAMETER(pvPtr2);

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddheapl.cxx ===
/*==========================================================================
 *
 *  Copyright (C) 1994-1999 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       ddheapl.c
 *  Content:    Linear heap manager
 *  History:
 *   Date       By      Reason
 *   ====       ==      ======
 *   03-Feb-98  DrewB   Split from old vmemmgr.c for user/kernel code.
 *
 ***************************************************************************/

#include "precomp.hxx"

/****************************************************************************

 This memory manager is designed to have no impact on video memory usage.
 Global memory is used to maintain the allocation and free lists.  Because
 of this choice, merging of free blocks is a more expensive operation.
 The assumption is that in general, the speed of creating/destroying these
 memory blocks is not a high usage item and so it is OK to be slower.

 ****************************************************************************/

/*
 * MIN_SPLIT_SIZE determines the minimum size of a free block - if splitting
 * a block will result in less than MIN_SPLIT_SIZE bytes left, then
 * those bytes are just left as part of the new block.
 */
#define MIN_SPLIT_SIZE  15

/*
 * BLOCK_BOUNDARY must be a power of 2, and at least 4.  This gives
 * us the alignment of memory blocks.   
 */
#define BLOCK_BOUNDARY  4

/*
 * linVidMemInit - initialize video memory manager
 */
BOOL linVidMemInit( LPVMEMHEAP pvmh, FLATPTR start, FLATPTR end )
{
    DWORD       size;

    VDPF((2,V, "linVidMemInit(%08lx,%08lx)", start, end ));

    /*
     * get the size of the heap (and verify its alignment for debug builds)
     */
    size = (DWORD)(end - start) + 1;
    #ifdef DEBUG
    if( (size & (BLOCK_BOUNDARY-1)) != 0 )
    {
        VDPF(( 1, V, "Invalid size: %08lx (%ld)\n", size, size ));
        return FALSE;
    }
    #endif

    pvmh->dwTotalSize = size;

    /*
     * set up a free list with the whole chunk of memory on the block
     */
    pvmh->freeList = MemAlloc( sizeof( VMEML ) );
    if( pvmh->freeList == NULL )
    {
    return FALSE;
    }
    ((LPVMEML)pvmh->freeList)->next = NULL;
    ((LPVMEML)pvmh->freeList)->ptr = start;
    ((LPVMEML)pvmh->freeList)->size = size;

    pvmh->allocList = NULL;

    return TRUE;

} /* linVidMemInit */

/*
 * linVidMemFini - done with video memory manager
 */
void linVidMemFini( LPVMEMHEAP pvmh )
{
    LPVMEML     curr;
    LPVMEML     next;

    if( pvmh != NULL )
    {
    /*
     * free all memory allocated for the free list
     */
    curr = (LPVMEML)pvmh->freeList;
    while( curr != NULL )
    {
        next = curr->next;
        MemFree( curr );
        curr = next;
    }
    pvmh->freeList = NULL;

    /*
     * free all memory allocated for the allocation list
     */
    curr = (LPVMEML)pvmh->allocList;
    while( curr != NULL )
    {
        next = curr->next;
        MemFree( curr );
        curr = next;
    }
    pvmh->allocList = NULL;

    /*
     * free the heap data
     */
    MemFree( pvmh );
    }

} /* linVidMemFini */

/*
 * insertIntoList - add an item to the allocation list. list is kept in
 *                  order of increasing size
 */
void insertIntoList( LPVMEML pnew, LPLPVMEML listhead )
{
    LPVMEML     pvmem;
    LPVMEML     prev;

    #ifdef DEBUG
    if( pnew->size == 0 )
    {
        VDPF(( 1, V, "block size = 0\n" ));
    }
    #endif

    /*
     * run through the list (sorted from smallest to largest) looking
     * for the first item bigger than the new item
     */
    pvmem = *listhead;
    prev = NULL;
    while( pvmem != NULL )
    {
    if( pnew->size < pvmem->size )
    {
        break;
    }
    prev = pvmem;
    pvmem = pvmem->next;
    }

    /*
     * insert the new item item (before the found one)
     */
    if( prev != NULL )
    {
    pnew->next = pvmem;
    prev->next = pnew;
    }
    else
    {
    pnew->next = *listhead;
    *listhead = pnew;
    }

} /* insertIntoList */

/*
 * coalesceFreeBlocks - add a new item to the free list and coalesce
 */
LPVMEML coalesceFreeBlocks( LPVMEMHEAP pvmh, LPVMEML pnew )
{
    LPVMEML     pvmem;
    LPVMEML     prev;
    FLATPTR     end;
    BOOL        done;

    pvmem = (LPVMEML)pvmh->freeList;
    pnew->next = NULL;
    end = pnew->ptr + pnew->size;
    prev = NULL;
    done = FALSE;

    /*
     * try to merge the new block "pnew"
     */
    while( pvmem != NULL )
    {
    if( pnew->ptr == (pvmem->ptr + pvmem->size) )
    {
        /*
         * new block starts where another ended
         */
        pvmem->size += pnew->size;
        done = TRUE;
    }
    else if( end == pvmem->ptr )
    {
        /*
         * new block ends where another starts
         */
        pvmem->ptr = pnew->ptr;
        pvmem->size += pnew->size;
        done = TRUE;
    }
    /*
     * if we are joining 2 blocks, remove the merged on from the
     * list and return so that it can be re-tried (we don't recurse
     * since we could get very deep)
     */
    if( done )
    {
        if( prev != NULL )
        {
        prev->next = pvmem->next;
        }
        else
        {
        pvmh->freeList = pvmem->next;
        }
        MemFree( pnew );
        return pvmem;
    }
    prev = pvmem;
    pvmem = pvmem->next;
    }

    /*
     * couldn't merge, so just add to the free list
     */
    insertIntoList( pnew, (LPLPVMEML) &pvmh->freeList );
    return NULL;

} /* coalesceFreeBlocks */

/*
 * linVidMemFree = free some flat video memory
 */
void linVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr )
{
    LPVMEML     pvmem;
    LPVMEML     prev;

    if( ptr == (FLATPTR) NULL )
    {
    return;
    }

    #ifdef DEBUG
    if( pvmh == NULL )
    {
        VDPF(( 1, V, "VidMemAlloc: NULL heap handle!\n" ));
        return;
    }
    #endif

    pvmem = (LPVMEML)pvmh->allocList;
    prev = NULL;

    /*
     * run through the allocation list and look for this ptr
     * (O(N), bummer; that's what we get for not using video memory...)
     */
    while( pvmem != NULL )
    {
    if( pvmem->ptr == ptr )
    {
        /*
         * remove from allocation list
         */
        if( prev != NULL )
        {
        prev->next = pvmem->next;
        }
        else
        {
        pvmh->allocList = pvmem->next;
        }
        /*
         * keep coalescing until we can't coalesce anymore
         */
        while( pvmem != NULL )
        {
        pvmem = coalesceFreeBlocks( pvmh, pvmem );
        }
        return;
    }
    prev = pvmem;
    pvmem = pvmem->next;
    }

} /* linVidMemFree */

/*
 * linVidMemAlloc - alloc some flat video memory
 */
FLATPTR linVidMemAlloc( LPVMEMHEAP pvmh, DWORD xsize, DWORD ysize,
                        LPDWORD lpdwSize, LPSURFACEALIGNMENT lpAlignment,
                        LPLONG lpNewPitch )
{
    LPVMEML     pvmem;
    LPVMEML     prev;
    LPVMEML     pnew_free;

    DWORD       dwBeforeWastage;
    DWORD       dwAfterWastage;
    FLATPTR     pAligned;
    BOOL        bDiscardable = FALSE;

    LONG        lNewPitch;

    DWORD       size;

    if( xsize == 0 || ysize == 0 || pvmh == NULL )
    {
    return (FLATPTR) NULL;
    }

    if( lpAlignment && 
        ( lpAlignment->Linear.dwFlags & SURFACEALIGN_DISCARDABLE ) )
    {
        bDiscardable = TRUE;
    }

    lNewPitch = (LONG) xsize;
    if (lpAlignment && lpAlignment->Linear.dwPitchAlignment )
    {
        if (lNewPitch % lpAlignment->Linear.dwPitchAlignment)
        {
            lNewPitch += lpAlignment->Linear.dwPitchAlignment - lNewPitch % lpAlignment->Linear.dwPitchAlignment;
        }
    }
    /*
     * This weird size calculation doesn't include the little bit on the 'bottom right' of the surface
     */
    size = (DWORD) lNewPitch * (ysize-1) + xsize;
    size = (size+(BLOCK_BOUNDARY-1)) & ~(BLOCK_BOUNDARY-1);

    /*
     * run through free list, looking for the closest matching block
     */
    prev = NULL;
    pvmem = (LPVMEML)pvmh->freeList;
    while( pvmem != NULL )
    {
    while( pvmem->size >= size ) //Using while as a try block
    {
            /*
             * Setup for no alignment changes..
             */
            pAligned = pvmem->ptr;
            dwBeforeWastage = 0;
            dwAfterWastage = pvmem->size - size;
            if( lpAlignment )
            {
                //get wastage if we put the new block at the beginning or at the end of the free block
                if( lpAlignment->Linear.dwStartAlignment )
                {
                    /*
                     * The before wastage is how much we'd have to skip at the beginning to align the surface
                     */

                    dwBeforeWastage = (lpAlignment->Linear.dwStartAlignment - ((DWORD)pvmem->ptr % lpAlignment->Linear.dwStartAlignment)) % lpAlignment->Linear.dwStartAlignment;
                    //if ( dwBeforeWastage+size > pvmem->size )
                    //    break;
                    /*
                     * The after wastage is the bit between the end of the used surface and the end of the block
                     * if we snuggle this surface as close to the end of the block as possible.
                     */
                    dwAfterWastage = ( (DWORD)pvmem->ptr + pvmem->size - size ) % lpAlignment->Linear.dwStartAlignment;
                    //if ( dwAfterWastage + size > pvmem->size )
                    //    break;
                }
                /*
                 * Reassign before/after wastage to meaningful values based on where the block will actually go.
                 * Also check that aligning won't spill the surface off either end of the block.
                 */
                if ( dwBeforeWastage <= dwAfterWastage )
                {
                    if (pvmem->size < size + dwBeforeWastage)
                    {
                        /*
                         * Alignment pushes end of surface off end of block
                         */
                        break;
                    }
                    dwAfterWastage = pvmem->size - (size + dwBeforeWastage);
                    pAligned = pvmem->ptr + dwBeforeWastage;
                }
                else
                {
                    if (pvmem->size < size + dwAfterWastage)
                    {
                        /*
                         * Alignment pushes end of surface off beginning of block
                         */
                        break;
                    }
                    dwBeforeWastage = pvmem->size - (size + dwAfterWastage);
                    pAligned = pvmem->ptr + dwBeforeWastage;
                }
            }
            DDASSERT(size + dwBeforeWastage + dwAfterWastage == pvmem->size );
            DDASSERT(pAligned >= pvmem->ptr );
            DDASSERT(pAligned + size <= pvmem->ptr + pvmem->size );
            /*
             * Remove the old free block from the free list.
             */
        if( prev != NULL )
        {
        prev->next = pvmem->next;
        }
        else
        {
        pvmh->freeList = pvmem->next;
        }

            /*
             * If the after wastage is less than a small amount, smush it into
             * this block.
             */
            if (dwAfterWastage <= MIN_SPLIT_SIZE)
            {
                size += dwAfterWastage;
                dwAfterWastage=0;
            }
            /*
             * Add the new block to the used list, using the old free block
             */
        pvmem->size = size;
        pvmem->ptr = pAligned;
            pvmem->bDiscardable = bDiscardable;
        if( NULL != lpdwSize )
        *lpdwSize = size;
            if (NULL != lpNewPitch)
                *lpNewPitch = lNewPitch;
        insertIntoList( pvmem, (LPLPVMEML) &pvmh->allocList );

            /*
             * Add a new free block for before wastage
             */
            if (dwBeforeWastage)
            {
        pnew_free = (LPVMEML)MemAlloc( sizeof( VMEML ) );
        if( pnew_free == NULL )
        {
            return (FLATPTR) NULL;
        }
        pnew_free->size = dwBeforeWastage;
        pnew_free->ptr = pAligned-dwBeforeWastage;
        insertIntoList( pnew_free, (LPLPVMEML) &pvmh->freeList );
            }
            /*
             * Add a new free block for after wastage
             */
            if (dwAfterWastage)
            {
        pnew_free = (LPVMEML)MemAlloc( sizeof( VMEML ) );
        if( pnew_free == NULL )
        {
            return (FLATPTR) NULL;
        }
        pnew_free->size = dwAfterWastage;
        pnew_free->ptr = pAligned+size;
        insertIntoList( pnew_free, (LPLPVMEML) &pvmh->freeList );
            }
#ifdef DEBUG
            if( lpAlignment )
            {
                if (lpAlignment->Linear.dwStartAlignment)
                {
                    VDPF((6,V,"Alignment for start is %d",lpAlignment->Linear.dwStartAlignment));
                    DDASSERT(pvmem->ptr % lpAlignment->Linear.dwStartAlignment == 0);
                }
                if (lpAlignment->Linear.dwPitchAlignment)
                {
                    VDPF((6,V,"Alignment for pitch is %d",lpAlignment->Linear.dwPitchAlignment));
                    DDASSERT(lNewPitch % lpAlignment->Linear.dwPitchAlignment == 0);
                }
            }
#endif
        return pvmem->ptr;
    }
    prev = pvmem;
    pvmem = pvmem->next;
    }
    return (FLATPTR) NULL;

} /* linVidMemAlloc */

/*
 * linVidMemAmountAllocated
 */
DWORD linVidMemAmountAllocated( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;
    DWORD       size;

    pvmem = (LPVMEML)pvmh->allocList;
    size = 0;
    while( pvmem != NULL )
    {
        if( !( pvmem->bDiscardable ) )
        {
        size += pvmem->size;
        }
        pvmem = pvmem->next;
    }
    return size;

} /* linVidMemAmountAllocated */

/*
 * linVidMemAmountFree
 */
DWORD linVidMemAmountFree( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;
    DWORD       size;

    pvmem = (LPVMEML)pvmh->freeList;
    size = 0;
    while( pvmem != NULL )
    {
    size += pvmem->size;
    pvmem = pvmem->next;
    }

    /*
     * Now add in the memory that's allocated but discardable
     */
    pvmem = (LPVMEML)pvmh->allocList;
    while( pvmem != NULL )
    {
        if( pvmem->bDiscardable )
        {
        size += pvmem->size;
        }
        pvmem = pvmem->next;
    }
    return size;

} /* linVidMemAmountFree */

/*
 * linVidMemLargestFree - alloc some flat video memory
 */
DWORD linVidMemLargestFree( LPVMEMHEAP pvmh )
{
    LPVMEML     pvmem;

    if( pvmh == NULL )
    {
    return 0;
    }

    pvmem = (LPVMEML)pvmh->freeList;

    if( pvmem == NULL )
    {
    return 0;
    }
    
    while( 1 )
    {
    if( pvmem->next == NULL )
    {
        return pvmem->size;
    }
    pvmem = pvmem->next;
    }
    
} /* linVidMemLargestFree */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\ddhmgr.cxx ===
/******************************Module*Header*******************************\
* Module Name: DdHmgr.cxx
*
* DirectDraw handle manager API entry points
*
* Created: 30-Apr-1999 23:03:03
* Author: Lindsay Steventon [linstev]
*
* Copyright (c) 1989-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

ULONG          gcSizeDdHmgr = DD_TABLESIZE_DELTA;      // Start table size
DD_ENTRY      *gpentDdHmgrLast = NULL;  // Previous handle table
DD_ENTRY      *gpentDdHmgr = NULL;      // Points to handle table
HDD_OBJ        ghFreeDdHmgr;            // Free handle
ULONG          gcMaxDdHmgr;             // Max handle alloc-ed so far
HSEMAPHORE     ghsemHmgr = NULL;        // Synchronization of the handle manager
PLARGE_INTEGER gpLockShortDelay;

// Prototype for a handy debugging routine.
#if DBG
    extern "C"
    VOID
    DdHmgPrintBadHandle(
        HDD_OBJ    hobj,
        DD_OBJTYPE objt
        );
#else
    #define DdHmgPrintBadHandle(hobj, objt)
#endif

HDD_OBJ          hDdGetFreeHandle(DD_OBJTYPE objt);
VOID             DdFreeObject(PVOID pvFree, ULONG ulType);
HDD_OBJ FASTCALL DdHmgNextOwned(HDD_OBJ hobj, W32PID pid);

/*****************************Exported*Routine*****************************\
* DdHmgCreate()
*
* Initializes a new handle manager with an initial allocation.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

BOOL 
DdHmgCreate()
{
    //
    // Initialize the handle manager allocation database.
    //

    ghFreeDdHmgr = 0;                    // No free handles
    gcMaxDdHmgr  = DD_HMGR_HANDLE_BASE;  // Initialize with handle index base

    //
    // Create memory block for handle table
    //

    gpentDdHmgr  = (DD_ENTRY *)PALLOCMEM(sizeof(DD_ENTRY) * gcSizeDdHmgr, 'ddht');
    if (gpentDdHmgr == NULL) 
    {
        WARNING("Could not allocated DDraw handle table.");   
        return(FALSE);
    }

    //
    // Initialize exclusion stuff.
    //

    if ((ghsemHmgr = EngCreateSemaphore()) == NULL)
    {
        WARNING("Could not allocated DDraw handle semaphore.");   
        VFREEMEM(gpentDdHmgr);
        gpentDdHmgr = NULL;
        return(FALSE);
    }

    //
    // allocate and initialize the timeout lock for the handle manager.
    //

    gpLockShortDelay = (PLARGE_INTEGER) PALLOCNONPAGED(sizeof(LARGE_INTEGER),
                                                       'iniG');

    if (gpLockShortDelay == NULL)
    {
        WARNING("Could not allocated DDraw shortdelay.");   
        EngDeleteSemaphore(ghsemHmgr);
        ghsemHmgr = NULL;
        VFREEMEM(gpentDdHmgr);
        gpentDdHmgr = NULL;
        return(FALSE);
    }

    gpLockShortDelay->LowPart = (ULONG) -100000;
    gpLockShortDelay->HighPart = -1;

    return(TRUE);
}

/*****************************Exported*Routine*****************************\
* DdHmgDestroy()
*
* Free memory allocated by the handle manager. This happens on system 
* shutdown. Always succeeds.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

BOOL 
DdHmgDestroy()
{
    ghFreeDdHmgr  = 0;         // Zero free handles
    gcMaxDdHmgr   = 0;         // Zero current last handle
    gcSizeDdHmgr  = 0;         // Handle table size
    gpentDdHmgrLast = NULL;    // Zero previos handle table pointer

    if (gpentDdHmgr)           // Free handle table
    {
        VFREEMEM(gpentDdHmgr); 
        gpentDdHmgr = NULL;
    }

    if (ghsemHmgr)
    {
        EngDeleteSemaphore(ghsemHmgr);
        ghsemHmgr = NULL;
    }
    
    return(TRUE);
}

/*****************************Exported*Routine*****************************\
* DdHmgCloseProcess()
*
* Free handles in handle table from process. Occurs on process cleanup.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

BOOL 
DdHmgCloseProcess(W32PID W32Pid)
{
    BOOL bRes = TRUE;

    HDD_OBJ hobj;

    DdHmgAcquireHmgrSemaphore();

    hobj = DdHmgNextOwned((HDD_OBJ) 0, W32Pid);

    DdHmgReleaseHmgrSemaphore();

    while (hobj != (HDD_OBJ) NULL)
    {
        switch (DdHmgObjtype(hobj))
        {
        case DD_DIRECTDRAW_TYPE:
            bRes = bDdDeleteDirectDrawObject((HANDLE)hobj, TRUE);
            break;

        case DD_SURFACE_TYPE:
            bRes = bDdDeleteSurfaceObject((HANDLE)hobj, NULL);
            break;

        case DD_MOTIONCOMP_TYPE:
            bRes = bDdDeleteMotionCompObject((HANDLE)hobj, NULL);
            break;

        case DD_VIDEOPORT_TYPE:
            bRes = bDdDeleteVideoPortObject((HANDLE)hobj, NULL);
            break;

        case D3D_HANDLE_TYPE:
            HRESULT hr;
            bRes = D3dDeleteHandle((HANDLE)hobj, 0, NULL, &hr) ==
                DDHAL_DRIVER_HANDLED;
            break;

        default:
            bRes = FALSE;
            break;
        }

        #if DBG
            if (bRes == FALSE)
            {
                DbgPrint("DDRAW ERROR: DdHmgCloseProcess couldn't delete "
                         "obj = %p, type j=%lx\n", hobj, DdHmgObjtype(hobj));
            }
        #endif

        // Move on to next object.

        DdHmgAcquireHmgrSemaphore();

        hobj = DdHmgNextOwned(hobj, W32Pid);

        DdHmgReleaseHmgrSemaphore();
    }

    return (bRes);
}

/******************************Public*Routine******************************\
* DdHmgValidHandle
*
* Returns TRUE if the handle is valid, FALSE if not.
*
* Note we don't need to lock the semaphore, we aren't changing anything,
* we are just looking.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

BOOL
DdHmgValidHandle(
    HDD_OBJ    hobj,
    DD_OBJTYPE objt)
{
    BOOL      bRes = FALSE;
    PDD_ENTRY pentTmp;
    UINT      uiIndex = (UINT) (UINT) DdHmgIfromH(hobj);

    //
    // Acquire the handle manager lock before touching gpentDdHmgr
    //

    DdHmgAcquireHmgrSemaphore();

    if ((uiIndex < gcMaxDdHmgr) &&
        ((pentTmp = &gpentDdHmgr[uiIndex])->Objt == objt) &&
        (pentTmp->FullUnique == DdHmgUfromH(hobj)))
    {
        ASSERTGDI(pentTmp->einfo.pobj != (PDD_OBJ) NULL, "ERROR how can it be NULL");
        bRes = TRUE;
    }

    DdHmgReleaseHmgrSemaphore();

    return (bRes);
}

/******************************Public*Routine******************************\
* DdHmgRemoveObject
*
* Removes an object from the handle table if certain conditions are met.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

PVOID
DdHmgRemoveObject(
    HDD_OBJ    hobj,
    LONG       cExclusiveLock,
    LONG       cShareLock,
    BOOL       bIgnoreUndeletable,
    DD_OBJTYPE objt)
{
    PDD_OBJ pobj;
    UINT    uiIndex = (UINT) DdHmgIfromH(hobj);

    if (uiIndex < gcMaxDdHmgr)
    {
        //
        // Acquire the handle manager lock before touching gpentDdHmgr
        //

        DdHmgAcquireHmgrSemaphore();

        //
        // lock handle
        //

        PDD_ENTRY pentTmp = &gpentDdHmgr[uiIndex];

        if (VerifyObjectOwner(pentTmp))
        {
            //
            // verify objt and unique
            //

            if ((pentTmp->Objt == objt) &&
                (pentTmp->FullUnique == DdHmgUfromH(hobj)))
            {
                pobj = pentTmp->einfo.pobj;

                if ((pobj->cExclusiveLock == (USHORT)cExclusiveLock) &&
                    (pobj->ulShareCount   == (ULONG)cShareLock))
                {
                    if (bIgnoreUndeletable || (!(pentTmp->Flags & DD_HMGR_ENTRY_UNDELETABLE)))
                    {
                        //
                        // set the handle in the object to NULL
                        // to prevent/catch accidental decrement of the
                        // shared reference count
                        //

                        pobj->hHmgr = NULL;

                        //
                        // free the handle
                        //

                        ((DD_ENTRYOBJ *) pentTmp)->vFree(uiIndex);
                    }
                    else
                    {
                        WARNING1("DdHmgRemove failed object is undeletable\n");
                        pobj = NULL;
                    }
                }
                else
                {
                    //
                    // object is busy
                    //

                     WARNING1("DdHmgRemove failed - object busy elsewhere\n");
                     pobj = NULL;
                }
            }
            else
            {
                WARNING1("DdHmgRemove: bad objt or unique\n");
                pobj = NULL;
            }
        }
        else
        {
            WARNING1("DdHmgRemove: failed to lock handle\n");
            pobj = NULL;
        }

        DdHmgReleaseHmgrSemaphore();
    }
    else
    {
        WARNING1("DdHmgRemove failed invalid index\n");
        pobj = NULL;
    }

    return((PVOID)pobj);
}

/******************************Public*Routine******************************\
* DdAllocateObject
*
* Allocates an object out of the heap.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

//
// This struct and the following union can be thrown away
// when someone fixes the BASEOBJECT cExclusiveLock and BaseFlags sharing
// the same DWORD.
//

struct SplitLockAndFlags {
  USHORT c_cExclusiveLock;
  USHORT c_BaseFlags;
};

union SplitOrCombinedLockAndFlags {
  SplitLockAndFlags S;
  ULONG W;
};

PVOID
DdAllocateObject(
    ULONG cBytes,
    ULONG ulType,
    BOOL bZero)
{

    PVOID pvReturn = NULL;

    ASSERTGDI(ulType != DD_DEF_TYPE, "DdAllocateObject ulType is bad");
    ASSERTGDI(cBytes >= sizeof(DD_BASEOBJECT), "DdAllocateObject cBytes is bad");

    //
    // Debug check to avoid assert in ExAllocatePool
    //

    #if DBG
        if (cBytes >= (PAGE_SIZE * 10000))
        {
            WARNING("DdAllocateObject: cBytes >= 10000 pages");
            return(NULL);
        }
    #endif


    ULONG ulTag = '0 hD';
    ulTag += ulType << 24;

    //
    // BASEOBJECT is always zero-initialized.
    //

    if (bZero)
    {
        pvReturn = PALLOCMEM(cBytes, ulTag);
    }
    else
    {
        pvReturn = PALLOCNOZ(cBytes, ulTag);

        //
        // At least the BASEOBJECT should be initialized.
        //

        if (pvReturn)
        {
            RtlZeroMemory(pvReturn, (UINT) sizeof(DD_BASEOBJECT));
        }
    }

    //
    // If the allocation failed again, then set the extended
    // error status and return an invalid handle.
    //

    if (!pvReturn)
    {
        KdPrint(("DXG: DdAllocateObject failed alloc of %lu bytes\n", (cBytes)));
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    return(pvReturn);
}

/******************************Public*Routine******************************\
* DdHmgAlloc
*
* Allocate an object from Handle Manager.
*
* WARNING:
* --------
*
* If the object is share-lockable via an API, you MUST use DdHmgInsertObject
* instead.  If the object is only exclusive-lockable via an API, you MUST
* either use DdHmgInsertObject or specify HMGR_ALLOC_LOCK.
*
* (This is because if you use DdHmgAlloc, a malicious multi-threaded
* application could guess the handle and cause it to be dereferenced
* before you've finished initializing it, possibly causing an access
* violation.)
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

HDD_OBJ
DdHmgAlloc(
    ULONGSIZE_T cb,
    DD_OBJTYPE  objt,
    FSHORT      fs) // fs can be a combination of the following:
                    //  HMGR_NO_ZERO_INIT   - Don't zero initialize
                    //  HMGR_MAKE_PUBLIC    - Allow object to be lockable by
                    //                        any process
                    //  HMGR_ALLOC_LOCK     - Do an DdHmgLock on the object and
                    //                        return a pointer instead of handle
{
    HDD_OBJ Handle;
    PVOID   pv;

    ASSERTGDI(objt != (DD_OBJTYPE) DD_DEF_TYPE, "DdHmgAlloc objt is bad");
    ASSERTGDI(cb >= 8, "ERROR DdHmgr writes in first 8 bytes");

    //
    // Allocate a pointer.
    //

    pv = DdAllocateObject(cb, (ULONG) objt, ((fs & HMGR_NO_ZERO_INIT) == 0));

    if (pv != (PVOID) NULL)
    {
        //
        // We need the semaphore to access the free list
        //

        DdHmgAcquireHmgrSemaphore();

        //
        // Allocate a handle: can only fail if we run out of memory or bits to 
        // store the handle index.
        //
        
        Handle = hDdGetFreeHandle(objt);

        if (Handle != (HDD_OBJ) 0)
        {
            //
            // Store a pointer to the object in the entry corresponding to the
            // allocated handle and initialize the handle data.
            //

            ((DD_ENTRYOBJ *) &(gpentDdHmgr[DdHmgIfromH(Handle)]))->vSetup((PDD_OBJ) pv, objt, fs);

            //
            // Store the object handle at the beginning of the object memory.
            //

            ((DD_OBJECT *)pv)->hHmgr = (HANDLE)Handle;

            DdHmgReleaseHmgrSemaphore();

            return ((fs & HMGR_ALLOC_LOCK) ? (HDD_OBJ)pv : Handle);
        }
        else
        {
            //
            // We just failed a handle allocation.  Release the memory.
            //

            WARNING("Failed DdHmgAlloc to allocate a handle\n");

            DdHmgReleaseHmgrSemaphore();
            DdFreeObject(pv,(ULONG) objt);
        }
    }

    return((HDD_OBJ) 0);
}

/******************************Public*Routine******************************\
* DdFreeObject
*
* Frees the object from where it was allocated. We have this as a separate
* function in case we implement lookaside lists (as in GDI) later.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

VOID 
DdFreeObject(PVOID pvFree, ULONG ulType)
{
    VFREEMEM(pvFree);
}

/******************************Public*Routine******************************\
* DdHmgFree
*
* Free an object from the handle manager.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

VOID 
DdHmgFree(HDD_OBJ hobj)
{
    UINT       uiIndex = (UINT) DdHmgIfromH(hobj);
    PDD_OBJ    pobjTmp;
    DD_OBJTYPE objtTmp;

    ASSERTGDI(uiIndex != 0, "ERROR DdHmgFree invalid 0 handle");

    if (uiIndex < gcMaxDdHmgr)
    {
        //
        // Acquire the handle manager lock before touching gpentDdHmgr
        //

        DdHmgAcquireHmgrSemaphore();


        PDD_ENTRY pentTmp = &gpentDdHmgr[uiIndex];

        pobjTmp = pentTmp->einfo.pobj;
        objtTmp = pentTmp->Objt;

        //
        // Free the object handle
        //

        ((DD_ENTRYOBJ *) pentTmp)->vFree(uiIndex);


        DdHmgReleaseHmgrSemaphore();

        if (pobjTmp)
        {
            DdFreeObject((PVOID)pobjTmp, (ULONG) objtTmp);
        }
    }
    else
    {
        WARNING1("DdHmgFree: bad handle index");
    }
}

/*****************************Exported*Routine*****************************\
* HDD_OBJ DdHmgNextOwned(hobj, pid)
*
* Report the next object owned by specified process
*
* Must be called with the Hmgr semaphore acquired.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

HDD_OBJ
FASTCALL
DdHmgNextOwned(
    HDD_OBJ hobj,
    W32PID pid)
{
    PDD_ENTRYOBJ  pentTmp;
    UINT uiIndex = (UINT) DdHmgIfromH(hobj);

    //
    // If we are passed 0 we inc to 1 because 0 can never be valid.
    // If we are passed != 0 we inc 1 to find the next one valid.
    //

    uiIndex++;

    while (uiIndex < gcMaxDdHmgr)
    {
        pentTmp = (PDD_ENTRYOBJ) &gpentDdHmgr[uiIndex];

        if (pentTmp->bOwnedBy(pid))
        {
            LONG_PTR uiIndex1 = (LONG_PTR)DD_MAKE_HMGR_HANDLE(uiIndex,pentTmp->FullUnique);

            return((HDD_OBJ)(uiIndex1 & 0xFFFFFFFF));
        }

        // Advance to next object
        uiIndex++;
    }

    // No objects found

    return((HDD_OBJ) 0);
}

/*****************************Exported*Routine*****************************\
* HDD_OBJ DdHmgNextObjt
*
* Report the next object of a certain type.
*
* Must be called with the Hmgr semaphore acquired.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

PDD_OBJ
FASTCALL
DdHmgNextObjt(
    HDD_OBJ    hobj,
    DD_OBJTYPE objt)
{
    PDD_ENTRYOBJ  pentTmp;
    UINT uiIndex = (UINT) DdHmgIfromH(hobj);

    //
    // If we are passed 0 we inc to 1 because 0 can never be valid.
    // If we are passed != 0 we inc 1 to find the next one valid.
    //

    uiIndex++;

    while (uiIndex < gcMaxDdHmgr)
    {
        pentTmp = (PDD_ENTRYOBJ) &gpentDdHmgr[uiIndex];

        if (pentTmp->Objt == objt)
        {
            return(pentTmp->einfo.pobj);
        }

        //
        // Advance to next object
        //

        uiIndex++;
    }

    //
    // no objects found
    //

    return((PDD_OBJ) 0);
}

/*******************************Routine************************************\
* DdHmgLock
*
* Description:
*
*   Acquire an exclusive lock on an object, PID owner must match current PID
*   or be a public.
*
* Arguments:
*
*   hobj    -   Handle to lock
*   objt    -   Check to make sure handle is of expected type
*
* Return Value:
*
*   Pointer to object or NULL
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

PDD_OBJ
FASTCALL
DdHmgLock(
    HDD_OBJ    hobj,
    DD_OBJTYPE objt,
    BOOL       underSemaphore
    )
{
    PDD_OBJ pobj    = (PDD_OBJ)NULL;
    UINT    uiIndex = (UINT)DdHmgIfromH(hobj);

    //
    // Acquire the handle manager lock before touching gpentDdHmgr
    // Only do this if we are not already under the semaphore
    //

    if (!underSemaphore) {
        DdHmgAcquireHmgrSemaphore();
    }
 
    if (uiIndex < gcMaxDdHmgr)
    {
        PDD_ENTRY pentry = &gpentDdHmgr[uiIndex];

        if (VerifyObjectOwner(pentry))
        {
            if ((pentry->Objt == objt) &&
                (pentry->FullUnique == DdHmgUfromH(hobj)))
            {
                ULONG_PTR thread = (ULONG_PTR)PsGetCurrentThread();

                pobj = pentry->einfo.pobj;

                if ((pobj->cExclusiveLock == 0) ||
                    (pobj->Tid == thread))
                {
                    INC_EXCLUSIVE_REF_CNT(pobj);
                    pobj->Tid = thread;
                }
                else
                {
                    WARNING1("DdHmgLock: object already locked by another thread");
                    pobj = (PDD_OBJ)NULL;
                }
            }
            else
            {
                DdHmgPrintBadHandle(hobj, objt);
            }
        }
        else
        {
            DdHmgPrintBadHandle(hobj, objt);
        }
    }
    else
    {
        DdHmgPrintBadHandle(hobj, objt);
    }

    if (!underSemaphore) {
        DdHmgReleaseHmgrSemaphore();
    }

    return(pobj);
}

/******************************Public*Routine******************************\
* DdHmgQueryLock
*
* This returns the number of times an object has been Locked.
*
* Expects: A valid handle.  The handle should be validated and locked
*          before calling this. Note we don't need to grab the semaphore 
*          because this call assumes the handle has already been locked 
*          down and we are just reading memory.
*
* Returns: The number of times the object has been locked.
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

ULONG 
FASTCALL 
DdHmgQueryLock(HDD_OBJ hobj)
{
    //
    // Acquire the handle manager lock before touching gpentDdHmgr
    //

    DdHmgAcquireHmgrSemaphore();

    UINT uiIndex = (UINT)DdHmgIfromH(hobj);
    ASSERTGDI(uiIndex < gcMaxDdHmgr, "DdHmgQueryLock invalid handle");

    ULONG ulRes = gpentDdHmgr[uiIndex].einfo.pobj->cExclusiveLock;

    DdHmgReleaseHmgrSemaphore();

    return ulRes;
}

/******************************Public*Routine******************************\
* HDD_OBJ hDdGetFreeHandle()
*
* Get the next available handle. If the handle table is full, we grow it. 
* This function can fail under any of these circumstances:
* 1. Handle manager didn't initialize
* 2. Insufficient memory to grow the handle table
* 3. Insufficient bits to store the handle index
*
* Note: 
*    We must already have the HmgrSemaphore
*
* History:
*
*  30-Apr-1999 -by- Lindsay Steventon [linstev]
* Wrote it.
\**************************************************************************/

HDD_OBJ 
hDdGetFreeHandle(
    DD_OBJTYPE objt
    )
{
    LONG_PTR uiIndex;

    // 
    // Handle manager initialized and bounds check
    //

    if ((gpentDdHmgr == NULL) || (gcMaxDdHmgr == DD_MAX_HANDLE_COUNT))
    {
        return ((HDD_OBJ)0);
    }
    
    //
    // Check if there is a free handle we can use
    //

    if (ghFreeDdHmgr != (HDD_OBJ) 0)
    {
        PDD_ENTRYOBJ pentTmp;

        uiIndex = (LONG_PTR)ghFreeDdHmgr;
        pentTmp = (PDD_ENTRYOBJ) &gpentDdHmgr[uiIndex];
        ghFreeDdHmgr = pentTmp->einfo.hFree;

        pentTmp->FullUnique = DD_USUNIQUE(pentTmp->FullUnique,objt);

        uiIndex = (LONG_PTR)DD_MAKE_HMGR_HANDLE(uiIndex,pentTmp->FullUnique);

        return((HDD_OBJ)(uiIndex & 0xFFFFFFFF));
    }

    //
    // Check if we've run out of handles
    //
    
    if (gcMaxDdHmgr == gcSizeDdHmgr)
    {
        // Increase the table size
        
        ULONG dwNewSize = gcSizeDdHmgr + DD_TABLESIZE_DELTA;

        // Allocate a new block 
        DD_ENTRY *ptHmgr = (DD_ENTRY *)PALLOCMEM(sizeof(DD_ENTRY) * dwNewSize, 'ddht');

        if (ptHmgr == NULL)
        {
            WARNING("DdHmgr failed to grow handle table\n");
            return ((HDD_OBJ) 0);
        }

        // 
        // Copy the old handles into the new table
        //

        RtlMoveMemory(ptHmgr, gpentDdHmgr, sizeof(DD_ENTRY) * gcSizeDdHmgr);

        gcSizeDdHmgr = dwNewSize;
        gpentDdHmgrLast = gpentDdHmgr;
        VFREEMEM(gpentDdHmgr); 
        gpentDdHmgr = ptHmgr;
    }
    
    //
    // Allocate a new handle table entry and set the uniqueness value.
    //

    uiIndex = DD_USUNIQUE(DD_UNIQUE_INCREMENT,objt);
    gpentDdHmgr[gcMaxDdHmgr].FullUnique = (USHORT) uiIndex;
    uiIndex = (LONG_PTR)DD_MAKE_HMGR_HANDLE(gcMaxDdHmgr,uiIndex);
    gcMaxDdHmgr++;

    return((HDD_OBJ)(uiIndex & 0xFFFFFFFF));
}

/******************************Public*Routines*****************************\
* DdHmgAcquireHmgrSemaphore                                                *
* DdHmgReleaseHmgrSemaphore                                                *
*                                                                          *
* Convenience functions for the handle manager semaphore.                  *
*                                                                          *
\**************************************************************************/

VOID
DdHmgAcquireHmgrSemaphore()
{
    EngAcquireSemaphore(ghsemHmgr);
}

VOID
DdHmgReleaseHmgrSemaphore()
{
    EngReleaseSemaphore(ghsemHmgr);
}

/******************************Public*Routine******************************\
* DdHmgPrintBadHandle
*
*   Simple routine that prints out a warning when a handle manager
*   lock fails due to a bad handle.
*
\**************************************************************************/

#if DBG

CONST CHAR* aszDdType[] = {
    "hdef",         // DD_DEF_TYPE
    "hddraw",       // DD_DIRECTDRAW_TYPE
    "hddrawsurf",   // DD_SURFACE_TYPE
    "hd3d",         // D3D_HANDLE_TYPE
    "hddrawvport",  // DD_VIDEOPORT_TYPE
    "hmotioncomp",  // DD_MOTIONCOMP_TYPE
    "hunused",      //
};

VOID
DdHmgPrintBadHandle(
    HDD_OBJ    hobj,
    DD_OBJTYPE objt
    )
{
    static CHAR *szSystem = "System";
    static CHAR *szUnknown = "???";
    CHAR        *pszImage;

    {
        PETHREAD    pet;
        PEPROCESS   pep;

        if (pep = PsGetCurrentProcess())
        {
            pszImage = (CHAR *)PsGetProcessImageFileName(pep);
            if (*pszImage == '\0')
            {
                pszImage = szSystem;
            }
        }
        else
        {
            pszImage = szUnknown;
        }
    }

    KdPrint(("DXG: %s or DLL gave bad handle 0x%p as an %s.\n",
               pszImage,                     hobj,   aszDdType[objt]));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\dxg.cxx ===
/******************************Module*Header*******************************\
* Module Name: dxg.cxx
*
* Contains the kernel-mode code for DirectX graphics.
*
* Created: 20-Apr-2000
* Author: Hideyuki Nagase [hideyukn]
*
* Copyright (c) 2000 Microsoft Corporation
*
\**************************************************************************/

#include <precomp.hxx>

extern "C" {
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    );
}

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,DriverEntry)
#endif

#if defined(_X86_)
ULONG_PTR DxgUserProbeAddress;
#endif

DRVFN gaDxgFuncs[] =
{
    { INDEX_DxDxgGenericThunk,                (PFN) DxDxgGenericThunk               },
    { INDEX_DxD3dContextCreate,               (PFN) DxD3dContextCreate              },
    { INDEX_DxD3dContextDestroy,              (PFN) DxD3dContextDestroy             },
    { INDEX_DxD3dContextDestroyAll,           (PFN) DxD3dContextDestroyAll          },
    { INDEX_DxD3dValidateTextureStageState,   (PFN) DxD3dValidateTextureStageState  },
    { INDEX_DxD3dDrawPrimitives2,             (PFN) DxD3dDrawPrimitives2            },
    { INDEX_DxDdGetDriverState,               (PFN) DxDdGetDriverState              },
    { INDEX_DxDdAddAttachedSurface,           (PFN) DxDdAddAttachedSurface          },
    { INDEX_DxDdAlphaBlt,                     (PFN) DxDdAlphaBlt                    },
    { INDEX_DxDdAttachSurface,                (PFN) DxDdAttachSurface               },
    { INDEX_DxDdBeginMoCompFrame,             (PFN) DxDdBeginMoCompFrame            },
    { INDEX_DxDdBlt,                          (PFN) DxDdBlt                         },
    { INDEX_DxDdCanCreateSurface,             (PFN) DxDdCanCreateSurface            },
    { INDEX_DxDdCanCreateD3DBuffer,           (PFN) DxDdCanCreateD3DBuffer          },
    { INDEX_DxDdColorControl,                 (PFN) DxDdColorControl                },
    { INDEX_DxDdCreateDirectDrawObject,       (PFN) DxDdCreateDirectDrawObject      },
    { INDEX_DxDdCreateSurface,                (PFN) DxDdCreateSurface               },
    { INDEX_DxDdCreateD3DBuffer,              (PFN) DxDdCreateD3DBuffer             },
    { INDEX_DxDdCreateMoComp,                 (PFN) DxDdCreateMoComp                },
    { INDEX_DxDdCreateSurfaceObject,          (PFN) DxDdCreateSurfaceObject         },
    { INDEX_DxDdDeleteDirectDrawObject,       (PFN) DxDdDeleteDirectDrawObject      },
    { INDEX_DxDdDeleteSurfaceObject,          (PFN) DxDdDeleteSurfaceObject         },
    { INDEX_DxDdDestroyMoComp,                (PFN) DxDdDestroyMoComp               },
    { INDEX_DxDdDestroySurface,               (PFN) DxDdDestroySurface              },
    { INDEX_DxDdDestroyD3DBuffer,             (PFN) DxDdDestroyD3DBuffer            },
    { INDEX_DxDdEndMoCompFrame,               (PFN) DxDdEndMoCompFrame              },
    { INDEX_DxDdFlip,                         (PFN) DxDdFlip                        },
    { INDEX_DxDdFlipToGDISurface,             (PFN) DxDdFlipToGDISurface            },
    { INDEX_DxDdGetAvailDriverMemory,         (PFN) DxDdGetAvailDriverMemory        },
    { INDEX_DxDdGetBltStatus,                 (PFN) DxDdGetBltStatus                },
    { INDEX_DxDdGetDC,                        (PFN) DxDdGetDC                       },
    { INDEX_DxDdGetDriverInfo,                (PFN) DxDdGetDriverInfo               },
    { INDEX_DxDdGetDxHandle,                  (PFN) DxDdGetDxHandle                 },
    { INDEX_DxDdGetFlipStatus,                (PFN) DxDdGetFlipStatus               },
    { INDEX_DxDdGetInternalMoCompInfo,        (PFN) DxDdGetInternalMoCompInfo       },
    { INDEX_DxDdGetMoCompBuffInfo,            (PFN) DxDdGetMoCompBuffInfo           },
    { INDEX_DxDdGetMoCompGuids,               (PFN) DxDdGetMoCompGuids              },
    { INDEX_DxDdGetMoCompFormats,             (PFN) DxDdGetMoCompFormats            },
    { INDEX_DxDdGetScanLine,                  (PFN) DxDdGetScanLine                 },
    { INDEX_DxDdLock,                         (PFN) DxDdLock                        },
    { INDEX_DxDdLockD3D,                      (PFN) DxDdLockD3D                     },
    { INDEX_DxDdQueryDirectDrawObject,        (PFN) DxDdQueryDirectDrawObject       },
    { INDEX_DxDdQueryMoCompStatus,            (PFN) DxDdQueryMoCompStatus           },
    { INDEX_DxDdReenableDirectDrawObject,     (PFN) DxDdReenableDirectDrawObject    },
    { INDEX_DxDdReleaseDC,                    (PFN) DxDdReleaseDC                   },
    { INDEX_DxDdRenderMoComp,                 (PFN) DxDdRenderMoComp                },
    { INDEX_DxDdResetVisrgn,                  (PFN) DxDdResetVisrgn                 },
    { INDEX_DxDdSetColorKey,                  (PFN) DxDdSetColorKey                 },
    { INDEX_DxDdSetExclusiveMode,             (PFN) DxDdSetExclusiveMode            },
    { INDEX_DxDdSetGammaRamp,                 (PFN) DxDdSetGammaRamp                },
    { INDEX_DxDdCreateSurfaceEx,              (PFN) DxDdCreateSurfaceEx             },
    { INDEX_DxDdSetOverlayPosition,           (PFN) DxDdSetOverlayPosition          },
    { INDEX_DxDdUnattachSurface,              (PFN) DxDdUnattachSurface             },
    { INDEX_DxDdUnlock,                       (PFN) DxDdUnlock                      },
    { INDEX_DxDdUnlockD3D,                    (PFN) DxDdUnlockD3D                   },
    { INDEX_DxDdUpdateOverlay,                (PFN) DxDdUpdateOverlay               },
    { INDEX_DxDdWaitForVerticalBlank,         (PFN) DxDdWaitForVerticalBlank        },
    { INDEX_DxDvpCanCreateVideoPort,          (PFN) DxDvpCanCreateVideoPort         },
    { INDEX_DxDvpColorControl,                (PFN) DxDvpColorControl               },
    { INDEX_DxDvpCreateVideoPort,             (PFN) DxDvpCreateVideoPort            },
    { INDEX_DxDvpDestroyVideoPort,            (PFN) DxDvpDestroyVideoPort           },
    { INDEX_DxDvpFlipVideoPort,               (PFN) DxDvpFlipVideoPort              },
    { INDEX_DxDvpGetVideoPortBandwidth,       (PFN) DxDvpGetVideoPortBandwidth      },
    { INDEX_DxDvpGetVideoPortField,           (PFN) DxDvpGetVideoPortField          },
    { INDEX_DxDvpGetVideoPortFlipStatus,      (PFN) DxDvpGetVideoPortFlipStatus     },
    { INDEX_DxDvpGetVideoPortInputFormats,    (PFN) DxDvpGetVideoPortInputFormats   },
    { INDEX_DxDvpGetVideoPortLine,            (PFN) DxDvpGetVideoPortLine           },
    { INDEX_DxDvpGetVideoPortOutputFormats,   (PFN) DxDvpGetVideoPortOutputFormats  },
    { INDEX_DxDvpGetVideoPortConnectInfo,     (PFN) DxDvpGetVideoPortConnectInfo    },
    { INDEX_DxDvpGetVideoSignalStatus,        (PFN) DxDvpGetVideoSignalStatus       },
    { INDEX_DxDvpUpdateVideoPort,             (PFN) DxDvpUpdateVideoPort            },
    { INDEX_DxDvpWaitForVideoPortSync,        (PFN) DxDvpWaitForVideoPortSync       },
    { INDEX_DxDvpAcquireNotification,         (PFN) DxDvpAcquireNotification        },
    { INDEX_DxDvpReleaseNotification,         (PFN) DxDvpReleaseNotification        },
    { INDEX_DxDdHeapVidMemAllocAligned,       (PFN) DxDdHeapVidMemAllocAligned      },
    { INDEX_DxDdHeapVidMemFree,               (PFN) DxDdHeapVidMemFree              },
    { INDEX_DxDdEnableDirectDraw,             (PFN) DxDdEnableDirectDraw            },
    { INDEX_DxDdDisableDirectDraw,            (PFN) DxDdDisableDirectDraw           },
    { INDEX_DxDdSuspendDirectDraw,            (PFN) DxDdSuspendDirectDraw           },
    { INDEX_DxDdResumeDirectDraw,             (PFN) DxDdResumeDirectDraw            },
    { INDEX_DxDdDynamicModeChange,            (PFN) DxDdDynamicModeChange           },
    { INDEX_DxDdCloseProcess,                 (PFN) DxDdCloseProcess                },
    { INDEX_DxDdGetDirectDrawBounds,          (PFN) DxDdGetDirectDrawBounds         },
    { INDEX_DxDdEnableDirectDrawRedirection,  (PFN) DxDdEnableDirectDrawRedirection },
    { INDEX_DxDdAllocPrivateUserMem,          (PFN) DxDdAllocPrivateUserMem         },
    { INDEX_DxDdFreePrivateUserMem,           (PFN) DxDdFreePrivateUserMem          },
    { INDEX_DxDdLockDirectDrawSurface,        (PFN) DxDdLockDirectDrawSurface       },
    { INDEX_DxDdUnlockDirectDrawSurface,      (PFN) DxDdUnlockDirectDrawSurface     },
    { INDEX_DxDdSetAccelLevel,                (PFN) DxDdSetAccelLevel               },
    { INDEX_DxDdGetSurfaceLock,               (PFN) DxDdGetSurfaceLock              },
    { INDEX_DxDdEnumLockedSurfaceRect,        (PFN) DxDdEnumLockedSurfaceRect       },
    { INDEX_DxDdIoctl,                        (PFN) DxDdIoctl                       }
};

ULONG gcDxgFuncs = sizeof(gaDxgFuncs) / sizeof(DRVFN);

//
// Pointer to the pointer table to Win32k.sys
//

DRVFN *gpEngFuncs = NULL;

//
// This is the global pointer to the dummy page to which all of the video
// memory is mapped when we need to forcibly unmap it. Instead of causing
// the app to fault accessing unmapped memory, we remap it to this play
// area where it can doodle around till it discovers that it had "lost"
// surfaces.
//
PVOID      gpDummyPage;
LONG       gcDummyPageRefCnt;
HSEMAPHORE ghsemDummyPage;

PEPROCESS  gpepSession = NULL;

/***************************************************************************\
* NTSTATUS DriverEntry
*
* This routine is never actually called, but we need it to link.
*
\***************************************************************************/

extern "C"
NTSTATUS
DriverEntry(
    PDRIVER_OBJECT DriverObject,
    PUNICODE_STRING RegistryPath
    )
{
    return(STATUS_SUCCESS);
}

/***************************************************************************\
* NTSTATUS StartupDxGraphics
*
* This routine is called by win32k.sys to initialize dxg.sys.
*
\***************************************************************************/

extern "C"
NTSTATUS
DxDdStartupDxGraphics(
    ULONG          cjEng,
    DRVENABLEDATA *pdedEng,
    ULONG          cjDxg,
    DRVENABLEDATA *pdedDxg,
    DWORD         *pdwDirectDrawContext,
    PEPROCESS      pepSession
    )
{
    if ((cjEng >= sizeof(DRVENABLEDATA))  &&
        (cjDxg >= sizeof(DRVENABLEDATA)))
    {
        //
        // Initialize global variables
        //
        gpDummyPage = NULL;
        gcDummyPageRefCnt = 0;
        ghsemDummyPage = NULL;

        //
        // Give back function pointers to GDI, which they will call.
        //
        pdedDxg->iDriverVersion = 0x00080000; // Supporting until DX8.
        pdedDxg->c              = gcDxgFuncs;
        pdedDxg->pdrvfn         = gaDxgFuncs;

        //
        // pdedEng->iDriverVersion contains win32k version (= OS platform version).
        //
        //  - 0x00050001 for Whistler.
        //

        //
        // Check the function printers from GDI, which we will call.
        //
        if (pdedEng->c != INDEX_WIN32K_TABLE_SIZE)
        {
            WARNING("pdedEng->c != INDEX_WIN32K_TABLE_MAX\n");
            return STATUS_INTERNAL_ERROR;
        }

        //
        // Make sure all pointers are sorted and nothing missing.
        //
        for (ULONG i = 1; i < INDEX_WIN32K_TABLE_SIZE; i++)
        {
            if ((pdedEng->pdrvfn[i].iFunc != i) ||
                (pdedEng->pdrvfn[i].pfn == NULL))
            {
                WARNING("pdedEng->pdrvfn is not well orded or pointer is missing\n");
                return STATUS_INTERNAL_ERROR;
            }
        }

        //
        // If everything is good, keep the pointer.
        //
        gpEngFuncs = pdedEng->pdrvfn;

        //
        // Return size of DirectDraw context, so that GDI can allocate it inside HDEV.
        //
        *pdwDirectDrawContext = sizeof(EDD_DIRECTDRAW_GLOBAL);

        //
        // Initialize handle manager
        //
        if (!DdHmgCreate())
        {
            goto Error_Exit;
        }

        //
        // Create semaphore to sync dummy page global variable.
        //
        if ((ghsemDummyPage = EngCreateSemaphore()) == NULL)
        {
            goto Error_Exit;
        }

#if defined(_X86_)
        //
        // Keep our own copy of this to avoid double indirections on probing
        //
        DxgUserProbeAddress = *MmUserProbeAddress;
#endif

        //
        // Keep pointer to CsrSS process for this session.
        //
        gpepSession = pepSession;

        return(STATUS_SUCCESS);
    }

    return(STATUS_BUFFER_TOO_SMALL);

Error_Exit:

    DdHmgDestroy();

    if (ghsemDummyPage)
    {
        EngDeleteSemaphore(ghsemDummyPage);
        ghsemDummyPage = NULL;
    }

    return(STATUS_NO_MEMORY);
}

/***************************************************************************\
* NTSTATUS CleanupDxGraphics
*
* This routine is called by win32k.sys to uninitialize dxg.sys
* just before unload.
*
\***************************************************************************/

extern "C"
NTSTATUS
DxDdCleanupDxGraphics(VOID)
{
    DdHmgDestroy();

    if (ghsemDummyPage)
    {
        if (gpDummyPage)
        {
            ExFreePool(gpDummyPage);
            gpDummyPage = NULL;
            gcDummyPageRefCnt = 0;
        }

        EngDeleteSemaphore(ghsemDummyPage);
        ghsemDummyPage = NULL;
    }

    return (STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxg\debugko.cxx ===
/******************************Module*Header*******************************\
* Module Name: debugko.cxx
*
* Contains compile in routines that match the kernel debugger extensions
*
* Created: 16-jun-1995
* Author: Andre Vachon [andreva]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

#if DBG

LONG gWarningLevel = 0;

// DoWarning1 is for ASM functions to call at Warning Level 1

VOID DoWarning1(PSZ psz)
{
    if (1 <= gWarningLevel)
    {
        DbgPrint("DXG: ");
        DbgPrint(psz);
        DbgPrint("\n");
    }
}

VOID DoWarning(PSZ psz, LONG ulLevel)
{
    if (ulLevel <= gWarningLevel)
    {
        DbgPrint("DXG: ");
        DbgPrint(psz);
        DbgPrint("\n");
    }
}

VOID DoRip(PSZ psz)
{
    if (gWarningLevel >= 0)
    {
        DbgPrint("DXG Assertion: ");
        DbgPrint(psz);
        DbgPrint("\n");
        DbgBreakPoint();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\kmode\keizon\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\kmode\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\kmode\wow6432\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# Feb-14-1996 GerardoB Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\kmode\guids.c ===
//depot/Lab04_N/Windows/Core/kmode/guids.c#1 - branch change 9 (text)
/******************************Module*Header*******************************\
* Module Name: guids.c
*
* This file contains the actual data declarations for all GUIDs used by USER
*
* 1998-10-12 Ian James  Created
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
\**************************************************************************/


/*
 * Core NT headers
 */
#include <initguid.h>

#include <ntosp.h>
#include <ntddkbd.h>
#include <ntddmou.h>
#include <ntddstor.h>
#include <wdmguid.h>
#include <devguid.h>
#include <ioevent.h>
#include <hidusage.h>
#include <hidpi.h>
#include <hidclass.h>
#include <wmidata.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\inc\dxg.h ===
//TODO: from gre\pdevobj.hxx
#ifndef DRIVER_NOT_CAPABLE_DDRAW
#define DRIVER_NOT_CAPABLE_DDRAW      2
#endif
#ifndef DRIVER_NOT_CAPABLE_D3D
#define DRIVER_NOT_CAPABLE_D3D        4
#endif

#ifndef W32PID
#define W32PID ULONG
#endif

//
// The functions index which dxg.sys exports to win32k.sys
//
NTSTATUS
DxDdStartupDxGraphics(
    ULONG          cjEng,
    DRVENABLEDATA *pdedEng,
    ULONG          cjDxg,
    DRVENABLEDATA *pdedDxg,
    DWORD         *pdwDirectContext,
    PEPROCESS      pepSession
    );

NTSTATUS
DxDdCleanupDxGraphics(
    VOID
    );

typedef NTSTATUS (*PFN_StartupDxGraphics)(ULONG,DRVENABLEDATA*,ULONG,DRVENABLEDATA*,DWORD*,PEPROCESS);
typedef NTSTATUS (*PFN_CleanupDxGraphics)(VOID);

#define INDEX_DxDxgGenericThunk                     0
#define INDEX_DxD3dContextCreate                    1
#define INDEX_DxD3dContextDestroy                   2
#define INDEX_DxD3dContextDestroyAll                3
#define INDEX_DxD3dValidateTextureStageState        4
#define INDEX_DxD3dDrawPrimitives2                  5
#define INDEX_DxDdGetDriverState                    6
#define INDEX_DxDdAddAttachedSurface                7
#define INDEX_DxDdAlphaBlt                          8
#define INDEX_DxDdAttachSurface                     9
#define INDEX_DxDdBeginMoCompFrame                 10
#define INDEX_DxDdBlt                              11
#define INDEX_DxDdCanCreateSurface                 12
#define INDEX_DxDdCanCreateD3DBuffer               13
#define INDEX_DxDdColorControl                     14
#define INDEX_DxDdCreateDirectDrawObject           15
#define INDEX_DxDdCreateSurface                    16
#define INDEX_DxDdCreateD3DBuffer                  17
#define INDEX_DxDdCreateMoComp                     18
#define INDEX_DxDdCreateSurfaceObject              19
#define INDEX_DxDdDeleteDirectDrawObject           20
#define INDEX_DxDdDeleteSurfaceObject              21
#define INDEX_DxDdDestroyMoComp                    22
#define INDEX_DxDdDestroySurface                   23
#define INDEX_DxDdDestroyD3DBuffer                 24
#define INDEX_DxDdEndMoCompFrame                   25
#define INDEX_DxDdFlip                             26
#define INDEX_DxDdFlipToGDISurface                 27
#define INDEX_DxDdGetAvailDriverMemory             28
#define INDEX_DxDdGetBltStatus                     29
#define INDEX_DxDdGetDC                            30
#define INDEX_DxDdGetDriverInfo                    31
#define INDEX_DxDdGetDxHandle                      32
#define INDEX_DxDdGetFlipStatus                    33
#define INDEX_DxDdGetInternalMoCompInfo            34
#define INDEX_DxDdGetMoCompBuffInfo                35
#define INDEX_DxDdGetMoCompGuids                   36
#define INDEX_DxDdGetMoCompFormats                 37
#define INDEX_DxDdGetScanLine                      38
#define INDEX_DxDdLock                             39
#define INDEX_DxDdLockD3D                          40
#define INDEX_DxDdQueryDirectDrawObject            41
#define INDEX_DxDdQueryMoCompStatus                42
#define INDEX_DxDdReenableDirectDrawObject         43
#define INDEX_DxDdReleaseDC                        44
#define INDEX_DxDdRenderMoComp                     45
#define INDEX_DxDdResetVisrgn                      46
#define INDEX_DxDdSetColorKey                      47
#define INDEX_DxDdSetExclusiveMode                 48
#define INDEX_DxDdSetGammaRamp                     49
#define INDEX_DxDdCreateSurfaceEx                  50
#define INDEX_DxDdSetOverlayPosition               51
#define INDEX_DxDdUnattachSurface                  52
#define INDEX_DxDdUnlock                           53
#define INDEX_DxDdUnlockD3D                        54
#define INDEX_DxDdUpdateOverlay                    55
#define INDEX_DxDdWaitForVerticalBlank             56
#define INDEX_DxDvpCanCreateVideoPort              57
#define INDEX_DxDvpColorControl                    58
#define INDEX_DxDvpCreateVideoPort                 59
#define INDEX_DxDvpDestroyVideoPort                60
#define INDEX_DxDvpFlipVideoPort                   61
#define INDEX_DxDvpGetVideoPortBandwidth           62
#define INDEX_DxDvpGetVideoPortField               63
#define INDEX_DxDvpGetVideoPortFlipStatus          64
#define INDEX_DxDvpGetVideoPortInputFormats        65
#define INDEX_DxDvpGetVideoPortLine                66
#define INDEX_DxDvpGetVideoPortOutputFormats       67
#define INDEX_DxDvpGetVideoPortConnectInfo         68
#define INDEX_DxDvpGetVideoSignalStatus            69
#define INDEX_DxDvpUpdateVideoPort                 70
#define INDEX_DxDvpWaitForVideoPortSync            71
#define INDEX_DxDvpAcquireNotification             72
#define INDEX_DxDvpReleaseNotification             73
#define INDEX_DxDdHeapVidMemAllocAligned           74
#define INDEX_DxDdHeapVidMemFree                   75
#define INDEX_DxDdEnableDirectDraw                 76
#define INDEX_DxDdDisableDirectDraw                77
#define INDEX_DxDdSuspendDirectDraw                78 
#define INDEX_DxDdResumeDirectDraw                 79
#define INDEX_DxDdDynamicModeChange                80
#define INDEX_DxDdCloseProcess                     81
#define INDEX_DxDdGetDirectDrawBounds              82
#define INDEX_DxDdEnableDirectDrawRedirection      83
#define INDEX_DxDdAllocPrivateUserMem              84
#define INDEX_DxDdFreePrivateUserMem               85
#define INDEX_DxDdLockDirectDrawSurface            86
#define INDEX_DxDdUnlockDirectDrawSurface          87
#define INDEX_DxDdSetAccelLevel                    88
#define INDEX_DxDdGetSurfaceLock                   89
#define INDEX_DxDdEnumLockedSurfaceRect            90
#define INDEX_DxDdIoctl                            91

//
// Prototype definition
//

DWORD  APIENTRY DxDxgGenericThunk(
    IN     ULONG_PTR ulIndex,
    IN     ULONG_PTR ulHandle,
    IN OUT SIZE_T   *pdwSizeOfPtr1,
    IN OUT PVOID     pvPtr1,
    IN OUT SIZE_T   *pdwSizeOfPtr2,
    IN OUT PVOID     pvPtr2);

DWORD APIENTRY DxDdAddAttachedSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached,
    IN OUT PDD_ADDATTACHEDSURFACEDATA puAddAttachedSurfaceData);

BOOL APIENTRY DxDdAttachSurface(
    IN     HANDLE hSurfaceFrom,
    IN     HANDLE hSurfaceTo);

DWORD APIENTRY DxDdBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData);

DWORD APIENTRY DxDdCanCreateSurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);

DWORD APIENTRY DxDdColorControl(
    IN     HANDLE hSurface,
    IN OUT PDD_COLORCONTROLDATA puColorControlData);

HANDLE APIENTRY DxDdCreateDirectDrawObject(
    IN     HDC hdc);

DWORD  APIENTRY DxDdCreateSurface(
    IN     HANDLE  hDirectDraw,
    IN     HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
       OUT HANDLE* puhSurface);

HANDLE APIENTRY DxDdCreateSurfaceObject(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurface,
    IN     PDD_SURFACE_LOCAL puSurfaceLocal,
    IN     PDD_SURFACE_MORE puSurfaceMore,
    IN     PDD_SURFACE_GLOBAL puSurfaceGlobal,
    IN     BOOL bComplete);

BOOL APIENTRY DxDdDeleteSurfaceObject(
    IN     HANDLE hSurface);

BOOL APIENTRY DxDdDeleteDirectDrawObject(
    IN     HANDLE hDirectDrawLocal);

DWORD APIENTRY DxDdDestroySurface(
    IN     HANDLE hSurface,
    IN     BOOL bRealDestroy);

DWORD APIENTRY DxDdFlip(
    IN     HANDLE hSurfaceCurrent,
    IN     HANDLE hSurfaceTarget,
    IN     HANDLE hSurfaceCurrentLeft,
    IN     HANDLE hSurfaceTargetLeft,
    IN OUT PDD_FLIPDATA puFlipData);

DWORD APIENTRY DxDdGetAvailDriverMemory(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETAVAILDRIVERMEMORYDATA puGetAvailDriverMemoryData);

DWORD APIENTRY DxDdGetBltStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETBLTSTATUSDATA puGetBltStatusData);

HDC APIENTRY DxDdGetDC(
    IN     HANDLE hSurface,
    IN     PALETTEENTRY* puColorTable);

DWORD APIENTRY DxDdGetDriverInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETDRIVERINFODATA puGetDriverInfoData);

DWORD APIENTRY DxDdGetFlipStatus(
    IN     HANDLE hSurface,
    IN OUT PDD_GETFLIPSTATUSDATA puGetFlipStatusData);

DWORD APIENTRY DxDdGetScanLine(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETSCANLINEDATA puGetScanLineData);

DWORD APIENTRY DxDdSetExclusiveMode(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_SETEXCLUSIVEMODEDATA puSetExclusiveModeData);

DWORD APIENTRY DxDdFlipToGDISurface(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_FLIPTOGDISURFACEDATA puFlipToGDISurfaceData);

DWORD APIENTRY DxDdLock(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData,
    IN HDC hdcClip);

BOOL APIENTRY DxDdQueryDirectDrawObject(
    IN     HANDLE,
    IN OUT PDD_HALINFO,
    IN OUT DWORD*,
    IN OUT LPD3DNTHAL_CALLBACKS,
    IN OUT LPD3DNTHAL_GLOBALDRIVERDATA,
    IN OUT PDD_D3DBUFCALLBACKS,
    IN OUT LPDDSURFACEDESC,
    IN OUT DWORD*,
    IN OUT VIDEOMEMORY*,
    IN OUT DWORD*,
    IN OUT DWORD*);
 
BOOL APIENTRY DxDdReenableDirectDrawObject(
    IN     HANDLE hDirectDrawLocal,
    IN OUT BOOL* pubNewMode);

BOOL APIENTRY DxDdReleaseDC(
    IN     HANDLE hSurface);

BOOL APIENTRY DxDdResetVisrgn(
    IN     HANDLE hSurface,
    IN HWND hwnd);

DWORD APIENTRY DxDdSetColorKey(
    IN     HANDLE hSurface,
    IN OUT PDD_SETCOLORKEYDATA puSetColorKeyData);

DWORD APIENTRY DxDdSetOverlayPosition(
    IN     HANDLE hSurfaceSource,
    IN     HANDLE hSurfaceDestination,
    IN OUT PDD_SETOVERLAYPOSITIONDATA puSetOverlayPositionData);

VOID  APIENTRY DxDdUnattachSurface(
    IN     HANDLE hSurface,
    IN     HANDLE hSurfaceAttached);

DWORD APIENTRY DxDdUnlock(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData);

DWORD APIENTRY DxDdUpdateOverlay(
    IN     HANDLE hSurfaceDestination,
    IN     HANDLE hSurfaceSource,
    IN OUT PDD_UPDATEOVERLAYDATA puUpdateOverlayData);

DWORD APIENTRY DxDdWaitForVerticalBlank(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_WAITFORVERTICALBLANKDATA puWaitForVerticalBlankData);

HANDLE APIENTRY DxDdGetDxHandle(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     BOOL bRelease);

BOOL APIENTRY DxDdSetGammaRamp(
    IN     HANDLE hDirectDraw,
    IN     HDC hdc,
    IN     LPVOID lpGammaRamp);

DWORD APIENTRY DxDdLockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_LOCKDATA puLockData);

DWORD APIENTRY DxDdUnlockD3D(
    IN     HANDLE hSurface,
    IN OUT PDD_UNLOCKDATA puUnlockData);

DWORD APIENTRY DxDdCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT HANDLE* hSurface,
    IN OUT DDSURFACEDESC* puSurfaceDescription,
    IN OUT DD_SURFACE_GLOBAL* puSurfaceGlobalData,
    IN OUT DD_SURFACE_LOCAL* puSurfaceLocalData,
    IN OUT DD_SURFACE_MORE* puSurfaceMoreData,
    IN OUT DD_CREATESURFACEDATA* puCreateSurfaceData,
    IN OUT HANDLE* puhSurface);

DWORD APIENTRY DxDdCanCreateD3DBuffer(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATESURFACEDATA puCanCreateSurfaceData);

DWORD APIENTRY DxDdDestroyD3DBuffer(
    IN     HANDLE hSurface);

DWORD APIENTRY DxD3dContextCreate(
    IN     HANDLE hDirectDrawLocal,
    IN     HANDLE hSurfColor,
    IN     HANDLE hSurfZ,
    IN OUT D3DNTHAL_CONTEXTCREATEI *pdcci);

DWORD APIENTRY DxD3dContextDestroy(
    IN     LPD3DNTHAL_CONTEXTDESTROYDATA);

DWORD APIENTRY DxD3dContextDestroyAll(
       OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA pdcdad);

DWORD APIENTRY DxD3dValidateTextureStageState(
    IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA pData);

DWORD APIENTRY DxD3dDrawPrimitives2(
    IN     HANDLE hCmdBuf,
    IN     HANDLE hVBuf,
    IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
    IN OUT FLATPTR* pfpVidMemCmd,
    IN OUT DWORD* pdwSizeCmd,
    IN OUT FLATPTR* pfpVidMemVtx,
    IN OUT DWORD* pdwSizeVtx);

DWORD APIENTRY DxDdGetDriverState(
    IN OUT PDD_GETDRIVERSTATEDATA pdata);

DWORD APIENTRY DxDdCreateSurfaceEx(
    IN     HANDLE hDirectDraw,
    IN     HANDLE hSurface,
    IN     DWORD dwSurfaceHandle);

DWORD APIENTRY DxDdGetMoCompGuids(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPGUIDSDATA puGetMoCompGuidsData);

DWORD APIENTRY DxDdGetMoCompFormats(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPFORMATSDATA puGetMoCompFormatsData);

DWORD APIENTRY DxDdGetMoCompBuffInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETMOCOMPCOMPBUFFDATA puGetBuffData);

DWORD APIENTRY DxDdGetInternalMoCompInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETINTERNALMOCOMPDATA puGetInternalData);

HANDLE APIENTRY DxDdCreateMoComp(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CREATEMOCOMPDATA puCreateMoCompData);

DWORD APIENTRY DxDdDestroyMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_DESTROYMOCOMPDATA puDestroyMoCompData);

DWORD APIENTRY DxDdBeginMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_BEGINMOCOMPFRAMEDATA puBeginFrameData);

DWORD APIENTRY DxDdEndMoCompFrame(
    IN     HANDLE hMoComp,
    IN OUT PDD_ENDMOCOMPFRAMEDATA  puEndFrameData);

DWORD APIENTRY DxDdRenderMoComp(
    IN     HANDLE hMoComp,
    IN OUT PDD_RENDERMOCOMPDATA puRenderMoCompData);

DWORD APIENTRY DxDdQueryMoCompStatus(
    IN OUT HANDLE hMoComp,
    IN OUT PDD_QUERYMOCOMPSTATUSDATA puQueryMoCompStatusData);

DWORD APIENTRY DxDdAlphaBlt(
    IN     HANDLE hSurfaceDest,
    IN     HANDLE hSurfaceSrc,
    IN OUT PDD_BLTDATA puBltData);

DWORD APIENTRY DxDvpCanCreateVideoPort(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CANCREATEVPORTDATA puCanCreateVPortData);

DWORD APIENTRY DxDvpColorControl(
    IN     HANDLE hVideoPort,
    IN OUT PDD_VPORTCOLORDATA puVPortColorData);

HANDLE APIENTRY DxDvpCreateVideoPort(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_CREATEVPORTDATA puCreateVPortData);

DWORD  APIENTRY DxDvpDestroyVideoPort(
    IN     HANDLE hVideoPort,
    IN OUT PDD_DESTROYVPORTDATA puDestroyVPortData);

DWORD  APIENTRY DxDvpFlipVideoPort(
    IN     HANDLE hVideoPort,
    IN     HANDLE hDDSurfaceCurrent,
    IN     HANDLE hDDSurfaceTarget,
    IN OUT PDD_FLIPVPORTDATA puFlipVPortData);

DWORD  APIENTRY DxDvpGetVideoPortBandwidth(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTBANDWIDTHDATA puGetVPortBandwidthData);

DWORD  APIENTRY DxDvpGetVideoPortField(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTFIELDDATA puGetVPortFieldData);

DWORD  APIENTRY DxDvpGetVideoPortFlipStatus(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETVPORTFLIPSTATUSDATA puGetVPortFlipStatusData);

DWORD  APIENTRY DxDvpGetVideoPortInputFormats(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTINPUTFORMATDATA puGetVPortInputFormatData);

DWORD  APIENTRY DxDvpGetVideoPortLine(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTLINEDATA puGetVPortLineData);

DWORD  APIENTRY DxDvpGetVideoPortOutputFormats(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTOUTPUTFORMATDATA puGetVPortOutputFormatData);

DWORD  APIENTRY DxDvpGetVideoPortConnectInfo(
    IN     HANDLE hDirectDraw,
    IN OUT PDD_GETVPORTCONNECTDATA puGetVPortConnectData);

DWORD  APIENTRY DxDvpGetVideoSignalStatus(
    IN     HANDLE hVideoPort,
    IN OUT PDD_GETVPORTSIGNALDATA puGetVPortSignalData);

DWORD  APIENTRY DxDvpUpdateVideoPort(
    IN     HANDLE hVideoPort,
    IN     HANDLE* phSurfaceVideo,
    IN     HANDLE* phSurfaceVbi,
    IN OUT PDD_UPDATEVPORTDATA puUpdateVPortData);

DWORD  APIENTRY DxDvpWaitForVideoPortSync(
    IN     HANDLE hVideoPort,
    IN OUT PDD_WAITFORVPORTSYNCDATA puWaitForVPortSyncData);

DWORD  APIENTRY DxDvpAcquireNotification(
    IN     HANDLE hVideoPort,
    IN OUT HANDLE* phEvent,
    IN     LPDDVIDEOPORTNOTIFY pNotify);

DWORD  APIENTRY DxDvpReleaseNotification(
    IN     HANDLE hVideoPort,
    IN     HANDLE hEvent);

FLATPTR WINAPI DxDdHeapVidMemAllocAligned( 
                LPVIDMEM lpVidMem,
                DWORD dwWidth, 
                DWORD dwHeight, 
                LPSURFACEALIGNMENT lpAlignment , 
                LPLONG lpNewPitch );

VOID    WINAPI DxDdHeapVidMemFree( LPVMEMHEAP pvmh, FLATPTR ptr );

//
// Private for win32k.sys
//
BOOL DxDdEnableDirectDraw(
    HDEV hdev,
    BOOL bEnableDriver
    );

VOID DxDdDisableDirectDraw(
    HDEV hdev,
    BOOL bDisableDriver
    );

VOID DxDdSuspendDirectDraw(
    HDEV    hdev,
    ULONG   fl
    );

VOID DxDdResumeDirectDraw(
    HDEV    hdev,
    ULONG   fl
    );

#define DXG_SR_DDRAW_CHILDREN    0x0001
#define DXG_SR_DDRAW_MODECHANGE  0x0002

VOID DxDdDynamicModeChange(
    HDEV    hdevOld,
    HDEV    hdevNew,
    ULONG   fl
    );

#define DXG_MODECHANGE_TRANSFER  0x0001

VOID DxDdCloseProcess(
    W32PID  W32Pid
    );

BOOL DxDdGetDirectDrawBounds(
    HDEV    hdev,
    RECT*   prcBounds
    );

BOOL DxDdEnableDirectDrawRedirection(
    HDEV hdev,
    BOOL bEnable
    );

PVOID DxDdAllocPrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    SIZE_T cj,
    ULONG tag
    );

VOID DxDdFreePrivateUserMem(
    PDD_SURFACE_LOCAL pSurfaceLocal,
    PVOID pv
    );

HRESULT DxDdIoctl(
    ULONG ulIoctl,
    PVOID pBuffer,
    ULONG ulBufferSize
    );

PDD_SURFACE_LOCAL DxDdLockDirectDrawSurface(
    HANDLE hSurface
    );

BOOL DxDdUnlockDirectDrawSurface(
    PDD_SURFACE_LOCAL pSurface
    );

VOID DxDdSetAccelLevel(
    HDEV  hdev,
    DWORD dwAccelLevel,
    DWORD dwOverride
    );

DWORD DxDdGetSurfaceLock(
    HDEV  hdev
    );

PVOID DxDdEnumLockedSurfaceRect(
    HDEV   hdev,
    PVOID  pvSurface,
    RECTL *pLockedRect
    ); 

typedef DWORD (APIENTRY *PFN_DxDxgGenericThunk)(IN ULONG_PTR,IN ULONG_PTR,
                                                IN OUT SIZE_T *,IN OUT PVOID,
                                                IN OUT SIZE_T *,IN OUT PVOID);
typedef DWORD (APIENTRY *PFN_DxDdAddAttachedSurface)(IN HANDLE,IN HANDLE,IN OUT PDD_ADDATTACHEDSURFACEDATA);
typedef BOOL  (APIENTRY *PFN_DxDdAttachSurface)(IN HANDLE,IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxDdBlt)(IN HANDLE,IN HANDLE,IN OUT PDD_BLTDATA);
typedef DWORD (APIENTRY *PFN_DxDdCanCreateSurface)(IN HANDLE,IN OUT PDD_CANCREATESURFACEDATA);
typedef DWORD (APIENTRY *PFN_DxDdColorControl)(IN HANDLE,IN OUT PDD_COLORCONTROLDATA);
typedef HANDLE (APIENTRY *PFN_DxDdCreateDirectDrawObject)(IN HDC);
typedef DWORD (APIENTRY *PFN_DxDdCreateSurface)(IN HANDLE,IN HANDLE*,IN OUT DDSURFACEDESC*,
                                                IN OUT DD_SURFACE_GLOBAL*,IN OUT DD_SURFACE_LOCAL*,
                                                IN OUT DD_SURFACE_MORE*,IN OUT DD_CREATESURFACEDATA*,
                                                OUT HANDLE*);
typedef HANDLE (APIENTRY *PFN_DxDdCreateSurfaceObject)(IN HANDLE,IN HANDLE,IN PDD_SURFACE_LOCAL,
                                                       IN PDD_SURFACE_MORE,IN PDD_SURFACE_GLOBAL, 
                                                       IN BOOL);
typedef BOOL (APIENTRY *PFN_DxDdDeleteSurfaceObject)(IN HANDLE);
typedef BOOL (APIENTRY *PFN_DxDdDeleteDirectDrawObject)(IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxDdDestroySurface)(IN HANDLE,IN BOOL);
typedef DWORD (APIENTRY *PFN_DxDdFlip)(IN HANDLE,IN HANDLE,IN HANDLE,IN HANDLE,IN OUT PDD_FLIPDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetAvailDriverMemory)(IN HANDLE,IN OUT PDD_GETAVAILDRIVERMEMORYDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetBltStatus)(IN HANDLE,IN OUT PDD_GETBLTSTATUSDATA);
typedef HDC   (APIENTRY *PFN_DxDdGetDC)(IN HANDLE,IN PALETTEENTRY*);
typedef DWORD (APIENTRY *PFN_DxDdGetDriverInfo)(IN HANDLE,IN OUT PDD_GETDRIVERINFODATA);
typedef DWORD (APIENTRY *PFN_DxDdGetFlipStatus)(IN HANDLE,IN OUT PDD_GETFLIPSTATUSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetScanLine)(IN HANDLE,IN OUT PDD_GETSCANLINEDATA);
typedef DWORD (APIENTRY *PFN_DxDdSetExclusiveMode)(IN HANDLE,IN OUT PDD_SETEXCLUSIVEMODEDATA);
typedef DWORD (APIENTRY *PFN_DxDdFlipToGDISurface)(IN HANDLE,IN OUT PDD_FLIPTOGDISURFACEDATA);
typedef DWORD (APIENTRY *PFN_DxDdLock)(IN HANDLE,IN OUT PDD_LOCKDATA,IN HDC);
typedef BOOL  (APIENTRY *PFN_DxDdQueryDirectDrawObject)(IN HANDLE,IN OUT PDD_HALINFO,IN OUT DWORD*,
                                                        IN OUT LPD3DNTHAL_CALLBACKS,
                                                        IN OUT LPD3DNTHAL_GLOBALDRIVERDATA,
                                                        IN OUT PDD_D3DBUFCALLBACKS,
                                                        IN OUT LPDDSURFACEDESC,
                                                        IN OUT DWORD*, IN OUT VIDEOMEMORY*,
                                                        IN OUT DWORD*, IN OUT DWORD*);
typedef BOOL  (APIENTRY *PFN_DxDdReenableDirectDrawObject)(IN HANDLE,IN OUT BOOL*);
typedef BOOL  (APIENTRY *PFN_DxDdReleaseDC)(IN HANDLE);
typedef BOOL  (APIENTRY *PFN_DxDdResetVisrgn)(IN HANDLE,IN HWND);
typedef DWORD (APIENTRY *PFN_DxDdSetColorKey)(IN HANDLE,IN OUT PDD_SETCOLORKEYDATA);
typedef DWORD (APIENTRY *PFN_DxDdSetOverlayPosition)(IN HANDLE,IN HANDLE,IN OUT PDD_SETOVERLAYPOSITIONDATA);
typedef VOID  (APIENTRY *PFN_DxDdUnattachSurface)(IN HANDLE,IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxDdUnlock)(IN HANDLE,IN OUT PDD_UNLOCKDATA);
typedef DWORD (APIENTRY *PFN_DxDdUpdateOverlay)(IN HANDLE,IN HANDLE,IN OUT PDD_UPDATEOVERLAYDATA);
typedef DWORD (APIENTRY *PFN_DxDdWaitForVerticalBlank)(IN HANDLE,IN OUT PDD_WAITFORVERTICALBLANKDATA);
typedef HANDLE (APIENTRY *PFN_DxDdGetDxHandle)(IN HANDLE,IN HANDLE,IN BOOL);
typedef BOOL  (APIENTRY *PFN_DxDdSetGammaRamp)(IN HANDLE,IN HDC,IN LPVOID);
typedef DWORD (APIENTRY *PFN_DxDdLockD3D)(IN HANDLE,IN OUT PDD_LOCKDATA);
typedef DWORD (APIENTRY *PFN_DxDdUnlockD3D)(IN HANDLE,IN OUT PDD_UNLOCKDATA);
typedef DWORD (APIENTRY *PFN_DxDdCreateD3DBuffer)(IN HANDLE,IN OUT HANDLE*,
                                                  IN OUT DDSURFACEDESC*,IN OUT DD_SURFACE_GLOBAL*,
                                                  IN OUT DD_SURFACE_LOCAL*,IN OUT DD_SURFACE_MORE*,
                                                  IN OUT DD_CREATESURFACEDATA*,IN OUT HANDLE*);
typedef DWORD (APIENTRY *PFN_DxDdCanCreateD3DBuffer)(IN HANDLE,IN OUT PDD_CANCREATESURFACEDATA);
typedef DWORD (APIENTRY *PFN_DxDdDestroyD3DBuffer)(IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxD3dContextCreate)(IN HANDLE,IN HANDLE,IN HANDLE,IN OUT D3DNTHAL_CONTEXTCREATEI*);
typedef DWORD (APIENTRY *PFN_DxD3dContextDestroy)(IN LPD3DNTHAL_CONTEXTDESTROYDATA);
typedef DWORD (APIENTRY *PFN_DxD3dContextDestroyAll)(OUT LPD3DNTHAL_CONTEXTDESTROYALLDATA);
typedef DWORD (APIENTRY *PFN_DxD3dValidateTextureStageState)(IN OUT LPD3DNTHAL_VALIDATETEXTURESTAGESTATEDATA);
typedef DWORD (APIENTRY *PFN_DxD3dDrawPrimitives2)(IN HANDLE,IN HANDLE,IN OUT LPD3DNTHAL_DRAWPRIMITIVES2DATA pded,
                                                   IN OUT FLATPTR*,IN OUT DWORD*,IN OUT FLATPTR*,IN OUT DWORD*);
typedef DWORD (APIENTRY *PFN_DxDdGetDriverState)(IN OUT PDD_GETDRIVERSTATEDATA);
typedef DWORD (APIENTRY *PFN_DxDdCreateSurfaceEx)(IN HANDLE,IN HANDLE,IN DWORD);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompGuids)(IN HANDLE,IN OUT PDD_GETMOCOMPGUIDSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompFormats)(IN HANDLE,IN OUT PDD_GETMOCOMPFORMATSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompBuffInfo)(IN HANDLE,IN OUT PDD_GETMOCOMPCOMPBUFFDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetInternalMoCompInfo)(IN HANDLE,IN OUT PDD_GETINTERNALMOCOMPDATA);
typedef HANDLE (APIENTRY *PFN_DxDdCreateMoComp)(IN HANDLE,IN OUT PDD_CREATEMOCOMPDATA);
typedef DWORD (APIENTRY *PFN_DxDdDestroyMoComp)(IN HANDLE,IN OUT PDD_DESTROYMOCOMPDATA);
typedef DWORD (APIENTRY *PFN_DxDdBeginMoCompFrame)(IN HANDLE,IN OUT PDD_BEGINMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PFN_DxDdEndMoCompFrame)(IN HANDLE,IN OUT PDD_ENDMOCOMPFRAMEDATA);
typedef DWORD (APIENTRY *PFN_DxDdRenderMoComp)(IN HANDLE,IN OUT PDD_RENDERMOCOMPDATA);
typedef DWORD (APIENTRY *PFN_DxDdQueryMoCompStatus)(IN OUT HANDLE,IN OUT PDD_QUERYMOCOMPSTATUSDATA);
typedef DWORD (APIENTRY *PFN_DxDdAlphaBlt)(IN HANDLE,IN HANDLE,IN OUT PDD_BLTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpCanCreateVideoPort)(IN HANDLE,IN OUT PDD_CANCREATEVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpColorControl)(IN HANDLE,IN OUT PDD_VPORTCOLORDATA);
typedef HANDLE (APIENTRY *PFN_DxDvpCreateVideoPort)(IN HANDLE,IN OUT PDD_CREATEVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpDestroyVideoPort)(IN HANDLE,IN OUT PDD_DESTROYVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpFlipVideoPort)(IN HANDLE,IN HANDLE,IN HANDLE,IN OUT PDD_FLIPVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortBandwidth)(IN HANDLE,IN OUT PDD_GETVPORTBANDWIDTHDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortField)(IN HANDLE,IN OUT PDD_GETVPORTFIELDDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortFlipStatus)(IN HANDLE,IN OUT PDD_GETVPORTFLIPSTATUSDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortInputFormats)(IN HANDLE,IN OUT PDD_GETVPORTINPUTFORMATDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortLine)(IN HANDLE,IN OUT PDD_GETVPORTLINEDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortOutputFormats)(IN HANDLE,IN OUT PDD_GETVPORTOUTPUTFORMATDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoPortConnectInfo)(IN HANDLE,IN OUT PDD_GETVPORTCONNECTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpGetVideoSignalStatus)(IN HANDLE,IN OUT PDD_GETVPORTSIGNALDATA);
typedef DWORD (APIENTRY *PFN_DxDvpUpdateVideoPort)(IN HANDLE,IN HANDLE*,IN HANDLE*,IN OUT PDD_UPDATEVPORTDATA);
typedef DWORD (APIENTRY *PFN_DxDvpWaitForVideoPortSync)(IN HANDLE,IN OUT PDD_WAITFORVPORTSYNCDATA);
typedef DWORD (APIENTRY *PFN_DxDvpAcquireNotification)(IN HANDLE,IN OUT HANDLE*,IN OUT LPDDVIDEOPORTNOTIFY pNotify);
typedef DWORD (APIENTRY *PFN_DxDvpReleaseNotification)(IN HANDLE,IN HANDLE);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompGuids)(IN HANDLE,IN OUT PDD_GETMOCOMPGUIDSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompFormats)(IN HANDLE,IN OUT PDD_GETMOCOMPFORMATSDATA);
typedef DWORD (APIENTRY *PFN_DxDdGetMoCompBuffInfo)(IN HANDLE,IN OUT PDD_GETMOCOMPCOMPBUFFDATA);
typedef FLATPTR (WINAPI *PFN_DxDdHeapVidMemAllocAligned)(LPVIDMEM,DWORD,DWORD,LPSURFACEALIGNMENT,LPLONG);
typedef VOID    (WINAPI *PFN_DxDdHeapVidMemFree)(LPVMEMHEAP,FLATPTR);
typedef BOOL  (*PFN_DxDdEnableDirectDraw)(HDEV,BOOL);
typedef VOID  (*PFN_DxDdDisableDirectDraw)(HDEV,BOOL);
typedef VOID  (*PFN_DxDdSuspendDirectDraw)(HDEV,ULONG);
typedef VOID  (*PFN_DxDdResumeDirectDraw)(HDEV,ULONG);
typedef VOID  (*PFN_DxDdDynamicModeChange)(HDEV,HDEV,ULONG);
typedef VOID  (*PFN_DxDdCloseProcess)(W32PID);
typedef BOOL  (*PFN_DxDdGetDirectDrawBounds)(HDEV,RECT*);
typedef BOOL  (*PFN_DxDdEnableDirectDrawRedirection)(HDEV,BOOL);
typedef PVOID (*PFN_DxDdAllocPrivateUserMem)(PDD_SURFACE_LOCAL,SIZE_T,ULONG);
typedef VOID  (*PFN_DxDdFreePrivateUserMem)(PDD_SURFACE_LOCAL,PVOID);
typedef PDD_SURFACE_LOCAL (*PFN_DxDdLockDirectDrawSurface)(HANDLE);
typedef BOOL  (*PFN_DxDdUnlockDirectDrawSurface)(PDD_SURFACE_LOCAL);
typedef VOID  (*PFN_DxDdSetAccelLevel)(HDEV,DWORD,DWORD);
typedef DWORD (*PFN_DxDdGetSurfaceLock)(HDEV);
typedef PVOID (*PFN_DxDdEnumLockedSurfaceRect)(HDEV,PVOID,RECTL*);
typedef HRESULT (*PFN_DxDdIoctl)(ULONG,PVOID,ULONG);

//
// The functions definiton which import from win32k.sys
//
// Functions for global win32k.sys status.
//

#define INDEX_DxEngUnused                         0
#define INDEX_DxEngIsTermSrv                      1
#define INDEX_DxEngScreenAccessCheck              2
#define INDEX_DxEngRedrawDesktop                  3
#define INDEX_DxEngDispUniq                       4
#define INDEX_DxEngIncDispUniq                    5
#define INDEX_DxEngVisRgnUniq                     6
#define INDEX_DxEngLockShareSem                   7
#define INDEX_DxEngUnlockShareSem                 8
#define INDEX_DxEngEnumerateHdev                  9
#define INDEX_DxEngLockHdev                      10
#define INDEX_DxEngUnlockHdev                    11
#define INDEX_DxEngIsHdevLockedByCurrentThread   12
#define INDEX_DxEngReferenceHdev                 13
#define INDEX_DxEngUnreferenceHdev               14
#define INDEX_DxEngGetDeviceGammaRamp            15
#define INDEX_DxEngSetDeviceGammaRamp            16
#define INDEX_DxEngSpTearDownSprites             17
#define INDEX_DxEngSpUnTearDownSprites           18
#define INDEX_DxEngSpSpritesVisible              19
#define INDEX_DxEngGetHdevData                   20
#define INDEX_DxEngSetHdevData                   21
#define INDEX_DxEngCreateMemoryDC                22
#define INDEX_DxEngGetDesktopDC                  23
#define INDEX_DxEngDeleteDC                      24
#define INDEX_DxEngCleanDC                       25
#define INDEX_DxEngSetDCOwner                    26
#define INDEX_DxEngLockDC                        27
#define INDEX_DxEngUnlockDC                      28
#define INDEX_DxEngSetDCState                    29
#define INDEX_DxEngGetDCState                    30
#define INDEX_DxEngSelectBitmap                  31
#define INDEX_DxEngSetBitmapOwner                32
#define INDEX_DxEngDeleteSurface                 33
#define INDEX_DxEngGetSurfaceData                34
#define INDEX_DxEngAltLockSurface                35
#define INDEX_DxEngUploadPaletteEntryToSurface   36
#define INDEX_DxEngMarkSurfaceAsDirectDraw       37
#define INDEX_DxEngSelectPaletteToSurface        38
#define INDEX_DxEngSyncPaletteTableWithDevice    39
#define INDEX_DxEngSetPaletteState               40
#define INDEX_DxEngGetRedirectionBitmap          41
#define INDEX_DxEngLoadImage                     42

#define INDEX_WIN32K_TABLE_SIZE                  43

// DxEngSetHdevData()

#define HDEV_SURFACEHANDLE         0  // Get only
#define HDEV_MINIPORTHANDLE        1  // Get only
#define HDEV_DITHERFORMAT          2  // Get only
#define HDEV_GCAPS                 3
#define HDEV_GCAPS2                4
#define HDEV_FUNCTIONTABLE         5  // Get only
#define HDEV_DHPDEV                6  // Get only
#define HDEV_DXDATA                7
#define HDEV_DXLOCKS               8
#define HDEV_CAPSOVERRIDE          9  // Get only
#define HDEV_DISABLED             10
#define HDEV_DDML                 11  // Get only
#define HDEV_DISPLAY              12  // Get only
#define HDEV_PARENTHDEV           13  // Get only
#define HDEV_DELETED              14  // Get only
#define HDEV_PALMANAGED           15  // Get only
#define HDEV_LDEV                 16  // Get only
#define HDEV_GRAPHICSDEVICE       17  // Get only
#define HDEV_CLONE                18  // Get only

// DxEngGetDCState()

#define DCSTATE_FULLSCREEN         1
#define DCSTATE_VISRGNCOMPLEX      2 // Get only
#define DCSTATE_HDEV               3 // Get only

// DxEngGetSurfaceData()

#define SURF_HOOKFLAGS              1
#define SURF_IS_DIRECTDRAW_SURFACE  2
#define SURF_DD_SURFACE_HANDLE      3

// DxEngSetPaletteState()

#define PALSTATE_DIBSECTION        1

#ifdef DXG_BUILD // ONLY TRUE WHEN BUILD DXG.SYS.

//
// Stub routines to call Win32k.sys
//

extern DRVFN *gpEngFuncs;

typedef BOOL (*PFN_DxEngIsTermSrv)(VOID);
typedef BOOL (*PFN_DxEngScreenAccessCheck)(VOID);
typedef BOOL (*PFN_DxEngRedrawDesktop)(VOID);
typedef ULONG (*PFN_DxEngDispUniq)(VOID);
typedef BOOL (*PFN_DxEngIncDispUniq)(VOID);
typedef ULONG (*PFN_DxEngVisRgnUniq)(VOID);
typedef BOOL (*PFN_DxEngLockShareSem)(VOID);
typedef BOOL (*PFN_DxEngUnlockShareSem)(VOID);
typedef HDEV (*PFN_DxEngEnumerateHdev)(HDEV);
typedef BOOL (*PFN_DxEngLockHdev)(HDEV);
typedef BOOL (*PFN_DxEngUnlockHdev)(HDEV);
typedef BOOL (*PFN_DxEngIsHdevLockedByCurrentThread)(HDEV);
typedef BOOL (*PFN_DxEngReferenceHdev)(HDEV);
typedef BOOL (*PFN_DxEngUnreferenceHdev)(HDEV);
typedef BOOL (*PFN_DxEngGetDeviceGammaRamp)(HDEV,PVOID);
typedef BOOL (*PFN_DxEngSetDeviceGammaRamp)(HDEV,PVOID,BOOL);
typedef BOOL (*PFN_DxEngSpTearDownSprites)(HDEV,RECTL*,BOOL);
typedef BOOL (*PFN_DxEngSpUnTearDownSprites)(HDEV,RECTL*,BOOL);
typedef BOOL (*PFN_DxEngSpSpritesVisible)(HDEV);
typedef ULONG_PTR (*PFN_DxEngGetHdevData)(HDEV,DWORD);
typedef BOOL (*PFN_DxEngSetHdevData)(HDEV,DWORD,ULONG_PTR);
typedef HDC  (*PFN_DxEngCreateMemoryDC)(HDEV);
typedef HDC  (*PFN_DxEngGetDesktopDC)(ULONG,BOOL,BOOL);
typedef BOOL (*PFN_DxEngDeleteDC)(HDC,BOOL);
typedef BOOL (*PFN_DxEngCleanDC)(HDC);
typedef BOOL (*PFN_DxEngSetDCOwner)(HDC,W32PID);
typedef PVOID (*PFN_DxEngLockDC)(HDC);
typedef BOOL (*PFN_DxEngUnlockDC)(PVOID);
typedef BOOL (*PFN_DxEngSetDCState)(HDC,DWORD,ULONG_PTR);
typedef ULONG_PTR (*PFN_DxEngGetDCState)(HDC,DWORD);
typedef HBITMAP (*PFN_DxEngSelectBitmap)(HDC,HBITMAP);
typedef BOOL (*PFN_DxEngSetBitmapOwner)(HBITMAP,W32PID);
typedef BOOL (*PFN_DxEngDeleteSurface)(HSURF hsurf);
typedef ULONG_PTR (*PFN_DxEngGetSurfaceData)(SURFOBJ*,DWORD);
typedef SURFOBJ* (*PFN_DxEngAltLockSurface)(HBITMAP);
typedef BOOL (*PFN_DxEngUploadPaletteEntryToSurface)(HDEV,SURFOBJ*,PALETTEENTRY*,ULONG);
typedef BOOL (*PFN_DxEngMarkSurfaceAsDirectDraw)(SURFOBJ*,HANDLE);
typedef HPALETTE (*PFN_DxEngSelectPaletteToSurface)(SURFOBJ*,HPALETTE);
typedef BOOL (*PFN_DxEngSyncPaletteTableWithDevice)(HPALETTE,HDEV);
typedef BOOL (*PFN_DxEngSetPaletteState)(HPALETTE,DWORD,ULONG_PTR);
typedef HBITMAP (*PFN_DxEngGetRedirectionBitmap)(HWND);
typedef HANDLE (*PFN_DxEngLoadImage)(LPWSTR,BOOL);

#define PPFNGET_DXENG(name)        ((PFN_DxEng##name)((gpEngFuncs[INDEX_DxEng##name]).pfn))
#define CALL_DXENG(name)           (*(PPFNGET_DXENG(name)))

#define DxEngIsTermSrv()           ((BOOL)(CALL_DXENG(IsTermSrv)()))
#define DxEngScreenAccessCheck()   ((BOOL)(CALL_DXENG(ScreenAccessCheck)()))
#define DxEngRedrawDesktop()       ((BOOL)(CALL_DXENG(RedrawDesktop)()))

#define DxEngDispUniq()            ((ULONG)(CALL_DXENG(DxEngDispUniq)()))
#define DxEngIncDispUniq()         ((BOOL)(CALL_DXENG(IncDispUniq)()))
#define DxEngVisRgnUniq()          ((ULONG)(CALL_DXENG(VisRgnUniq)()))

#define DxEngLockShareSem()        ((BOOL)(CALL_DXENG(LockShareSem)()))
#define DxEngUnlockShareSem()      ((BOOL)(CALL_DXENG(UnlockShareSem)()))

#define DxEngEnumerateHdev(hdev)   ((HDEV)(CALL_DXENG(EnumerateHdev)(hdev)))

#define DxEngLockHdev(hdev)        ((BOOL)(CALL_DXENG(LockHdev)(hdev)))
#define DxEngUnlockHdev(hdev)      ((BOOL)(CALL_DXENG(UnlockHdev)(hdev)))

#define DxEngIsHdevLockedByCurrentThread(hdev) \
                                   ((BOOL)(CALL_DXENG(IsHdevLockedByCurrentThread)(hdev)))

#define DxEngReferenceHdev(hdev)   ((BOOL)(CALL_DXENG(ReferenceHdev)(hdev)))
#define DxEngUnreferenceHdev(hdev) ((BOOL)(CALL_DXENG(UnreferenceHdev)(hdev)))

#define DxEngGetHdevData(hdev,dwIndex) \
                                   ((ULONG_PTR)(CALL_DXENG(GetHdevData)(hdev,dwIndex)))
#define DxEngSetHdevData(hdev,dwIndex,pData) \
                                   ((BOOL)(CALL_DXENG(SetHdevData)(hdev,dwIndex,pData)))

#define DxEngCreateMemoryDC(hdev)  ((HDC)(CALL_DXENG(CreateMemoryDC)(hdev)))
#define DxEngGetDesktopDC(ulType,bAltType,bValidate) \
                                   ((HDC)(CALL_DXENG(GetDesktopDC)(ulType,bAltType,bValidate)))
#define DxEngDeleteDC(hdc,bForce)  ((BOOL)(CALL_DXENG(DeleteDC)(hdc,bForce)))
#define DxEngCleanDC(hdc)          ((BOOL)(CALL_DXENG(CleanDC)(hdc)))

#define DxEngSetDCOwner(hdc,pidOwner) \
                                   ((BOOL)(CALL_DXENG(SetDCOwner)(hdc,pidOwner)))

#define DxEngLockDC(hdc)           ((PVOID)(CALL_DXENG(LockDC)(hdc)))
#define DxEngUnlockDC(pvLockedDC)  ((BOOL)(CALL_DXENG(UnlockDC)(pvLockedDC)))

#define DxEngSetDCState(hdc,dwState,ulData) \
                                   ((BOOL)(CALL_DXENG(SetDCState)(hdc,dwState,ulData)))
#define DxEngGetDCState(hdc,dwState) \
                                   ((ULONG_PTR)(CALL_DXENG(GetDCState)(hdc,dwState)))

#define DxEngSelectBitmap(hdc,hbm) ((HBITMAP)(CALL_DXENG(SelectBitmap)(hdc,hbm)))
#define DxEngSetBitmapOwner(hbm,pidOwner) \
                                   ((BOOL)(CALL_DXENG(SetBitmapOwner)(hbm,pidOwner)))
#define DxEngDeleteSurface(hsurf)  ((BOOL)(CALL_DXENG(DeleteSurface)(hsurf)))
#define DxEngGetSurfaceData(pso,dwIndex) \
                                   ((ULONG_PTR)(CALL_DXENG(GetSurfaceData)(pso,dwIndex)))
#define DxEngAltLockSurface(hsurf) ((SURFOBJ*)(CALL_DXENG(AltLockSurface)(hsurf)))
#define DxEngUploadPaletteEntryToSurface(hdev,pso,puColorTable,cColors) \
                                   ((BOOL)(CALL_DXENG(UploadPaletteEntryToSurface)(hdev,pso,puColorTable,cColors)))
#define DxEngMarkSurfaceAsDirectDraw(pso,hDdSurf) \
                                   ((BOOL)(CALL_DXENG(MarkSurfaceAsDirectDraw)(pso,hDdSurf)))
#define DxEngSelectPaletteToSurface(pso,hpal) \
                                   ((HPALETTE)(CALL_DXENG(SelectPaletteToSurface)(pso,hpal)))

#define DxEngGetDeviceGammaRamp(hdev,pv) \
                                   ((BOOL)(CALL_DXENG(GetDeviceGammaRamp)(hdev,pv)))
#define DxEngSetDeviceGammaRamp(hdev,pv,b) \
                                   ((BOOL)(CALL_DXENG(SetDeviceGammaRamp)(hdev,pv,b)))

#define DxEngSpTearDownSprites(hdev,prcl,b) \
                                   ((BOOL)(CALL_DXENG(SpTearDownSprites)(hdev,prcl,b)))
#define DxEngSpUnTearDownSprites(hdev,prcl,b) \
                                   ((BOOL)(CALL_DXENG(SpUnTearDownSprites)(hdev,prcl,b)))
#define DxEngSpSpritesVisible(hdev) \
                                   ((BOOL)(CALL_DXENG(SpSpritesVisible)(hdev)))

#define DxEngSetPaletteState(hpal,dwIndex,ulData) \
                                   ((BOOL)(CALL_DXENG(SetPaletteState)(hpal,dwIndex,ulData)))
#define DxEngSyncPaletteTableWithDevice(hpal,hdev) \
                                   ((BOOL)(CALL_DXENG(SyncPaletteTableWithDevice)(hpal,hdev)))

#define DxEngGetRedirectionBitmap(hWnd) \
                                   ((HBITMAP)(CALL_DXENG(GetRedirectionBitmap)(hWnd)))
#define DxEngLoadImage(pwszDriver, bLoadInSessionSpace) \
                                   ((HANDLE)(CALL_DXENG(LoadImage)(pwszDriver,bLoadInSessionSpace)))

#else // DXG_BUILD

//
// Prototype definitions for function body in win32k.sys
//

BOOL   DxEngIsTermSrv(
       VOID
       );

BOOL   DxEngScreenAccessCheck(
       VOID
       );

BOOL   DxEngRedrawDesktop(
       VOID
       );

ULONG  DxEngDispUniq(
       VOID
       );

BOOL   DxEngIncDispUniq(
       VOID
       );

ULONG  DxEngVisRgnUniq(
       VOID
       );

BOOL   DxEngLockShareSem(
       VOID
       );

BOOL   DxEngUnlockShareSem(
       VOID
       );

HDEV   DxEngEnumerateHdev(
       HDEV hdev
       );

// Functions for control HDEV status.

BOOL   DxEngLockHdev(
       HDEV hdev
       );

BOOL   DxEngUnlockHdev(
       HDEV hdev
       );

BOOL   DxEngIsHdevLockedByCurrentThread(
       HDEV hdev
       );

BOOL   DxEngReferenceHdev(
       HDEV hdev
       );

BOOL   DxEngUnreferenceHdev(
       HDEV hdev
       );

BOOL   DxEngGetDeviceGammaRamp(
       HDEV  hdev,
       PVOID pv
       );

BOOL   DxEngSetDeviceGammaRamp(
       HDEV  hdev,
       PVOID pv,
       BOOL  b
       );

BOOL   DxEngSpTearDownSprites(
       HDEV   hdev,
       RECTL* prcl,
       BOOL   b
       );

BOOL   DxEngSpUnTearDownSprites(
       HDEV   hdev,
       RECTL* prcl,
       BOOL   b
       );

BOOL   DxEngSpSpritesVisible(
       HDEV   hdev
       );

ULONG_PTR DxEngGetHdevData(
          HDEV  hdev,
          DWORD dwIndex
          );

BOOL DxEngSetHdevData(
     HDEV  hdev,
     DWORD dwIndex,
     ULONG_PTR ulData
     );

// Functions for control DC

HDC  DxEngCreateMemoryDC(
     HDEV hdev
     );

HDC  DxEngGetDesktopDC(
     ULONG ulType,
     BOOL  bAltType,
     BOOL bValidate
     );

BOOL DxEngDeleteDC(
     HDC  hdc,
     BOOL bForce
     );

BOOL DxEngCleanDC(
     HDC hdc
     );

BOOL DxEngSetDCOwner(
     HDC    hdc,
     W32PID pidOwner
     );

PVOID DxEngLockDC(
     HDC hdc
     );

BOOL DxEngUnlockDC(
     PVOID pvLockedDC
     );

BOOL DxEngSetDCState(
     HDC   hdc,
     DWORD dwState,
     ULONG_PTR ulData
     );

ULONG_PTR DxEngGetDCState(
     HDC   hdc,
     DWORD dwState
     );

// Functions for control Bitmap/Surface

HBITMAP DxEngSelectBitmap(
        HDC     hdc,
        HBITMAP hbm
        );

BOOL DxEngSetBitmapOwner(
     HBITMAP hbm,
     W32PID  pidOwner
     );

BOOL DxEngDeleteSurface(
     HSURF hsurf
     );

ULONG_PTR DxEngGetSurfaceData(
     SURFOBJ* pso,
     DWORD dwIndex);

SURFOBJ *DxEngAltLockSurface(
     HBITMAP hSurf);

BOOL DxEngUploadPaletteEntryToSurface(
     HDEV     hdev,
     SURFOBJ* pso,
     PALETTEENTRY* puColorTable,
     ULONG         cColors
     );

BOOL DxEngMarkSurfaceAsDirectDraw(
     SURFOBJ* pso,
     HANDLE   hDdSurf
     );

HPALETTE DxEngSelectPaletteToSurface(
         SURFOBJ* pso,
         HPALETTE hpal
         );

// Functions for control palette

BOOL DxEngSyncPaletteTableWithDevice(
     HPALETTE hpal,
     HDEV     hdev
     );

BOOL DxEngSetPaletteState(
     HPALETTE  hpal,
     DWORD     dwIndex,
     ULONG_PTR ulData
     );

#define PALSTATE_DIBSECTION        1

// Functions for window handle

HBITMAP DxEngGetRedirectionBitmap(
        HWND hWnd
        );

// Functions to load image file

HANDLE DxEngLoadImage(
       LPWSTR pwszDriver,
       BOOL   bLoadInSessionSpace
       );

#endif // DXG_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\dxkernel\dxgthk\dxgthk.c ===
#include <windows.h>
#include <winddi.h>

#define STANDARD_DEBUG_PREFIX "DXGTHK.SYS:"

ULONG
DriverEntry(
    PVOID DriverObject,
    PVOID RegistryPath
    );

VOID
DebugPrint(
    PCHAR DebugMessage,
    ...
    );

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,DriverEntry)
#pragma alloc_text(PAGE,DebugPrint)
#endif

/***************************************************************************\
* VOID DebugPrint
*
\***************************************************************************/

VOID
DebugPrint(
    PCHAR DebugMessage,
    ...
    )
{
    va_list ap;
    va_start(ap, DebugMessage);
    EngDebugPrint(STANDARD_DEBUG_PREFIX, DebugMessage, ap);
    EngDebugPrint("", "\n", ap);
    va_end(ap);

} // DebugPrint()

/***************************************************************************\
* NTSTATUS DriverEntry
*
* This routine is never actually called, but we need it to link.
*
\***************************************************************************/

ULONG
DriverEntry(
    PVOID DriverObject,
    PVOID RegistryPath
    )
{
    DebugPrint("DriverEntry should not be called");
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\kmode\sources.inc ===
!include $(WINCORE_PATH)\core.inc

MAJORCOMP=ntos
MINORCOMP=w32

SYNCHRONIZE_BLOCK=1

TARGETNAME=win32k
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=EXPORT_DRIVER

PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(DDK_LIB_DEST)\$(DYNLINK_LIBDIR)}

INCLUDES=$(WINCORE_PATH)\w32inc;                    \
         $(WINCORE_PATH)\w32inc\$(O);               \
         $(NTUSER_PATH)\kernel\$(ALT_PROJECT)\$(O); \
         $(NTUSER_PATH)\kernel\$(ALT_PROJECT);      \
         $(BASE_INC_PATH)

SYNCHRONIZE_DRAIN=1

NT_UP=0

TARGETLIBS= \
         $(NTUSER_PATH)\kernel\$(ALT_PROJECT)\$(O)\userk.lib                  \
         $(NTGDI_PATH)\gre\$(ALT_PROJECT)\$(O)\gre.lib                        \
         $(NTGDI_PATH)\fondrv\tt\scaler\$(O)\fscaler.lib                      \
         $(NTGDI_PATH)\fondrv\tt\ttfd\$(ALT_PROJECT)\$(O)\ttfd.lib            \
         $(NTGDI_PATH)\fondrv\bmfd\$(O)\bmfd.lib                              \
         $(NTGDI_PATH)\fondrv\vtfd\$(O)\vtfd.lib                              \
         $(NTGDI_PATH)\math\$(ALT_PROJECT)\$(O)\efloat.lib                    \
         $(NTGDI_PATH)\halftone\ht\$(O)\halftone.lib                          \
         $(SDK_LIB_PATH)\advapi32.lib                                         \
         $(NTUSER_PATH)\rtl\kernel\$(ALT_PROJECT)\$(O)\userkrtl.lib

## Watchdog
TARGETLIBS=$(TARGETLIBS) $(DRIVERS_LIB_PATH)\watchdog.lib

#
# WARNING: Do not remove the dxapi.lib below which makes win32k.sys statically
# link to dxapi.sys. This is because dxapi.sys has got VPE/WDM code which
# video miniports can also link to whoes lifetimes we cant control in win3k.sys
# Hence we link with it statically and get refcount for us so its lifetime is
# bounded by win32k.sys's lifetime.
#

LINKLIBS=$(LINKLIBS)                                                          \
	 $(DDK_LIB_PATH)\dxapi.lib                                            \
         $(DDK_LIB_PATH)\ntoskrnl.lib                                         \
         $(DDK_LIB_PATH)\hal.lib                                              \
         $(NTGDI_PATH)\halftone\ht\$(O)\halftone.lib                          \
         $(NTGDI_PATH)\gre\$(ALT_PROJECT)\$(O)\gre.lib                        \
         $(WINCORE_PATH)\rtl\kernel\$(O)\w32krtl.lib

SOURCES=..\w32init.c \
        ..\guids.c \
        w32rc.rc

DLLDEF=$(O)\win32k.def
DLLORDER=..\$(TARGETNAME).prf

NTTARGETFILE0=$(O)\services.tab

SOURCES_USED=..\sources.inc $(WINCORE_PATH)\core.inc

DLLLIBOBJECTS=$(DLLLIBOBJECTS) \
!if $(386)
	 $(BASE_LIB_PATH)\sehprolg.obj \
!endif
         $(NTGDI_PATH)\gre\$(ALT_PROJECT)\$(O)\guids.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\kmode\w32init.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    w32init.c

Abstract:

    This is the Win32 subsystem driver initializatiion module

Author:

    Mark Lucovsky (markl) 31-Oct-1994


Revision History:

--*/

#include "ntosp.h"
#define DO_INLINE
#include "w32p.h"
#include "windef.h"
#include "wingdi.h"
#include "winerror.h"
#include "winddi.h"
#include "usergdi.h"
#include "w32err.h"

/*
 * Globals declared and initialized in ntuser\kernel\init.c
 */
extern ULONG W32ProcessSize;
extern ULONG W32ProcessTag;
extern ULONG W32ThreadSize;
extern ULONG W32ThreadTag;
extern PFAST_MUTEX gpW32FastMutex;

__inline VOID
ReferenceW32Process(
    IN PW32PROCESS pW32Process
    )
{
    PEPROCESS pEProcess = pW32Process->Process;

    ASSERT(pEProcess != NULL);
    ObReferenceObject(pEProcess);

    ASSERT(pW32Process->RefCount < MAXULONG);
    InterlockedIncrement(&pW32Process->RefCount);
}

VOID
DereferenceW32Process(
    IN PW32PROCESS pW32Process
    )
{
    PEPROCESS pEProcess = pW32Process->Process;

    /*
     * Dereference the object. It'll get freed when ref count goes to zero.
     */
    ASSERT(pW32Process->RefCount > 0);
    if (InterlockedDecrement(&pW32Process->RefCount) == 0) {
        UserDeleteW32Process(pW32Process);
    }

    /*
     * Dereference the kernel object.
     */
    ASSERT(pEProcess != NULL);
    ObDereferenceObject(pEProcess);
}

VOID
LockW32Process(
    IN PW32PROCESS pW32Process,
    IN OUT PTL ptl
    )
{
    PushW32ThreadLock(pW32Process, ptl, DereferenceW32Process);
    if (pW32Process != NULL) {
        ReferenceW32Process(pW32Process);
    }
}

NTSTATUS
AllocateW32Process(
    IN OUT PEPROCESS pEProcess
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PW32PROCESS pW32Process;

    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(gpW32FastMutex);

    /*
     * Allocate the process object if we haven't already done so.
     */
    if ((pW32Process = PsGetProcessWin32Process(pEProcess)) == NULL) {
        pW32Process = Win32AllocPoolWithQuota(W32ProcessSize, W32ProcessTag);
        if (pW32Process) {
            RtlZeroMemory(pW32Process, W32ProcessSize);
            pW32Process->Process = pEProcess;
            Status = PsSetProcessWin32Process(pEProcess, pW32Process, NULL);
            if (NT_SUCCESS (Status)) {
                ReferenceW32Process(pW32Process);
            } else {
                NtCurrentTeb()->LastErrorValue = ERROR_ACCESS_DENIED;
                Win32FreePool(pW32Process);
            }
        } else {
            NtCurrentTeb()->LastErrorValue = ERROR_NOT_ENOUGH_MEMORY;
            Status = STATUS_NO_MEMORY;
        }
    }

    ExReleaseFastMutexUnsafe(gpW32FastMutex);
    KeLeaveCriticalRegion();

    return Status;
}

PEPROCESS gpepCSRSS;

__inline VOID
FreeW32Process(
    IN OUT PW32PROCESS pW32Process
    )
{
    ASSERT(pW32Process == W32GetCurrentProcess());
    ASSERT(pW32Process != NULL);

    if (pW32Process->Process == gpepCSRSS) {

        RIPMSG0(RIP_WARNING, "FreeW32Process: CSRSS going away...");

        /*
         * Cleanup fonts while CSR goes away, on Hydra system only.
         */

        GdiMultiUserFontCleanup();

        ObDereferenceObject(gpepCSRSS);
        gpepCSRSS = NULL;
    }

    /*
     * Dereference the object. It'll get freed when ref count goes to zero.
     */
    DereferenceW32Process(pW32Process);
}

NTSTATUS
W32pProcessCallout(
    IN PEPROCESS Process,
    IN BOOLEAN Initialize
    )

/*++

Routine Description:

    This function is called whenever a Win32 process is created or deleted.
    Creattion occurs when the calling process calls NtConvertToGuiThread.

    Deletion occurs during PspExitthread processing for the last thread in
    a process.

Arguments:

    Process - Supplies the address of the W32PROCESS to initialize

    Initialize - Supplies a boolean value that is true if the process
        is being created

Return Value:

    TBD

--*/

{
    NTSTATUS Status;
    PW32PROCESS pW32Process;

    if ( Initialize ) {
        Status = AllocateW32Process(Process);
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        pW32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);
        pW32Process->W32Pid = W32GetCurrentPID();
    } else {
        pW32Process = (PW32PROCESS)PsGetProcessWin32Process(Process);
    }

    TAGMSG3(DBGTAG_Callout,
            "W32: Process Callout for W32P %#p EP %#p called for %s",
            pW32Process,
            Process,
            Initialize ? "Creation" : "Deletion");

    Status = xxxUserProcessCallout(pW32Process, Initialize);
    if (Status == STATUS_ALREADY_WIN32) {
        return Status;
    }

    /*
     * Always call GDI at cleanup time.
     * If GDI initialiatzion fails, call USER for cleanup.
     */
    if (NT_SUCCESS(Status) || !Initialize) {
        Status = GdiProcessCallout(pW32Process, Initialize);
        if (!NT_SUCCESS(Status) && Initialize) {
            xxxUserProcessCallout(pW32Process, FALSE);
        }
    }

    /*
     * If this is not an initialization or initialization failed, free the
     * W32 process structure.
     */
    if (!Initialize || !NT_SUCCESS(Status)) {
        FreeW32Process(pW32Process);
    }

    return Status;
}


__inline VOID
ReferenceW32Thread(
    IN PW32THREAD pW32Thread
    )
{
    PETHREAD pEThread = pW32Thread->pEThread;

    ASSERT(pEThread != NULL);
    ObReferenceObject(pEThread);

    ASSERT(pW32Thread->RefCount < MAXULONG);
    InterlockedIncrement(&pW32Thread->RefCount);
}

VOID
DereferenceW32Thread(
    IN PW32THREAD pW32Thread
    )
{
    PETHREAD pEThread = pW32Thread->pEThread;

    /*
     * Dereference the object. It'll get freed when ref count goes to zero.
     */
    ASSERT(pW32Thread->RefCount > 0);
    if (InterlockedDecrement(&pW32Thread->RefCount) == 0) {
        UserDeleteW32Thread(pW32Thread);
    }

    /*
     * Dereference the kernel object.
     */
    ASSERT(pEThread != NULL);
    ObDereferenceObject(pEThread);
}

VOID
LockW32Thread(
    IN PW32THREAD pW32Thread,
    IN OUT PTL ptl
    )
{
    PushW32ThreadLock(pW32Thread, ptl, DereferenceW32Thread);
    if (pW32Thread != NULL) {
        ReferenceW32Thread(pW32Thread);
    }
}

VOID
LockExchangeW32Thread(
    IN PW32THREAD pW32Thread,
    IN OUT PTL ptl
    )
{
    if (pW32Thread != NULL) {
        ReferenceW32Thread(pW32Thread);
    }
    ExchangeW32ThreadLock(pW32Thread, ptl);
}

NTSTATUS
AllocateW32Thread(
    IN OUT PETHREAD pEThread
    )
{
    PW32THREAD pW32Thread;

    ASSERT(pEThread == PsGetCurrentThread());

    pW32Thread = Win32AllocPoolWithQuota(W32ThreadSize, W32ThreadTag);
    if (pW32Thread) {
        RtlZeroMemory(pW32Thread, W32ThreadSize);
        pW32Thread->pEThread = pEThread;
        PsSetThreadWin32Thread(pEThread, pW32Thread, NULL);
        ReferenceW32Thread(pW32Thread);
        return STATUS_SUCCESS;
    }

    return STATUS_NO_MEMORY;
}

VOID
CleanupW32ThreadLocks(
    IN PW32THREAD pW32Thread
    )
{
    PTL ptl;

    while (ptl = pW32Thread->ptlW32) {
        PopAndFreeW32ThreadLock(ptl);
    }
}

NTSTATUS
W32pThreadCallout(
    IN PETHREAD pEThread,
    IN PSW32THREADCALLOUTTYPE CalloutType
    )

/*++

Routine Description:

    This function is called whenever a Win32 Thread is initialized,
     exited or deleted.
    Initialization occurs when the calling thread calls NtConvertToGuiThread.
    Exit occurs during PspExitthread processing and deletion during
     PspThreadDelete processing.

Arguments:

    Thread - Supplies the address of the ETHREAD object

    CalloutType - Supplies the callout type


Return Value:

    TBD

--*/

{
    NTSTATUS Status;

    TAGMSG2(DBGTAG_Callout,
            "W32: Thread Callout for ETHREAD %x called for %s\n",
            pEThread,
            CalloutType == PsW32ThreadCalloutInitialize ? "Initialization" :
            CalloutType == PsW32ThreadCalloutExit ? "Exit" : "Deletion");
    TAGMSG2(DBGTAG_Callout,
            "                              PID = %x   TID = %x\n",
            PsGetThreadProcessId(pEThread),
            PsGetThreadId(pEThread));

    if (CalloutType == PsW32ThreadCalloutInitialize) {
        Status = AllocateW32Thread(pEThread);
        if (!NT_SUCCESS(Status)) {
            NtCurrentTeb()->LastErrorValue = ERROR_NOT_ENOUGH_MEMORY;
            return Status;
        }
    }

   /*
    * If CalloutType == PsW32ThreadCalloutInitialize, assuming that:
    *  - GdiThreadCallout never fails.
    *  - If UserThreadCallout fails, there is no need to call
    *    GdiThreadCallout for clean up.
    */
    GdiThreadCallout(pEThread, CalloutType);

    Status = UserThreadCallout(pEThread, CalloutType);

    if (CalloutType == PsW32ThreadCalloutExit || !NT_SUCCESS(Status)) {
        FreeW32Thread(pEThread);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\kmode\makefile.inc ===
SERVICES_DIR=$(O)
SERVICES_TAB=$(SERVICES_DIR)\services.tab

!if $(IA64)
LINK_LIB_IGNORE_FLAG=$(LINK_LIB_IGNORE_FLAG),4210
!endif


$(SERVICES_TAB): ..\services.tab
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@

$(O)\systable.obj: $(O)\systable.$(ASM_SUFFIX)

$(O)\systable.$(ASM_SUFFIX): $(SERVICES_TAB) ..\$(TARGET_DIRECTORY)\table.stb ..\$(TARGET_DIRECTORY)\services.stb
    gensrv -d $(O) -e $(ASM_SUFFIX) -g $(SERVICES_DIR) $(TARGET_BRACES) -C -R -s ..\$(TARGET_DIRECTORY)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\condll.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    condll.h

Abstract:

    This module contains the include files and definitions for the
    console client DLL.

Author:

    Therese Stowell (thereses) 16-Nov-1990

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//Don't include this when building wow64 type/function database.
#if !defined(SORTPP_PASS)
#include <windows.h>
#endif

#include <winuserk.h>   // temporary
#include <conroute.h>
#include "conapi.h"

#include "ntcsrdll.h"
#include "conmsg.h"
#include <string.h>

#if defined(BUILD_WOW64)
#define SET_CONSOLE_HANDLE(HANDLE) (Wow64SetConsoleHandle(HANDLE))
#define GET_CONSOLE_HANDLE (Wow64GetConsoleHandle())
#define SET_LAST_ERROR(ERROR) (Wow64SetLastError(ERROR) )
#define SET_LAST_NT_ERROR(ERROR) (Wow64SetLastError(RtlNtStatusToDosError( ERROR ))  )
#include "ntwow64c.h"
#else
#define SET_CONSOLE_HANDLE(HANDLE) ((NtCurrentPeb())->ProcessParameters->ConsoleHandle = HANDLE)
#define GET_CONSOLE_HANDLE ((NtCurrentPeb())->ProcessParameters->ConsoleHandle)
#define SET_LAST_ERROR(ERROR) (SetLastError( ERROR ) )
#define SET_LAST_NT_ERROR(ERROR) (SetLastError( RtlNtStatusToDosError( ERROR ) ) )
#endif


#define VALID_ACCESSES (GENERIC_READ | GENERIC_WRITE)
#define VALID_SHARE_ACCESSES (FILE_SHARE_READ | FILE_SHARE_WRITE)

#define VALID_DUP_OPTIONS (DUPLICATE_CLOSE_SOURCE | DUPLICATE_SAME_ACCESS)

#define CONSOLE_RECT_SIZE_X(RECT) ((RECT)->Right - (RECT)->Left + 1)
#define CONSOLE_RECT_SIZE_Y(RECT) ((RECT)->Bottom - (RECT)->Top + 1)

//
// this critical section is used to serialize access to the code that
// accesses the ctrl handler data structures and the code that allocs
// and frees consoles.
//

CRITICAL_SECTION DllLock;
#define LockDll() RtlEnterCriticalSection(&DllLock)
#define UnlockDll() RtlLeaveCriticalSection(&DllLock)

NTSTATUS
InitializeCtrlHandling( VOID );

VOID
InitExeName(
    VOID
    );

USHORT
GetCurrentExeName(
    LPWSTR Buffer,
    ULONG BufferLength
    );

HANDLE
APIENTRY
OpenConsoleWInternal(
    IN ULONG HandleType,
    IN ULONG DesiredAccess,
    IN BOOL InheritHandle,
    IN ULONG ShareMode
    );

BOOL
APIENTRY
ReadConsoleInternal(
    IN HANDLE hConsoleInput,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfCharsToRead,
    OUT LPDWORD lpNumberOfCharsRead,
    IN OUT LPVOID lpReserved,
    IN BOOLEAN Unicode,
    IN USHORT ExeNameLength,
    IN LPWSTR ExeName
    );

BOOL
APIENTRY
WriteConsoleInternal(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpBuffer,
    IN DWORD nNumberOfCharsToWrite,
    OUT LPDWORD lpNumberOfCharsWritten,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
RegisterConsoleIMEInternal(
    IN HWND hWndConsoleIME,
    IN DWORD dwConsoleIMEThreadId,
    IN DWORD DesktopLength,
    IN LPWSTR Desktop,
    OUT DWORD *dwConsoleThreadId
    );

BOOL
APIENTRY
UnregisterConsoleIMEInternal(
    IN DWORD dwConsoleIMEThtreadId
    );

BOOL
APIENTRY
GetConsoleInput(
    IN HANDLE hConsoleInput,
    OUT PINPUT_RECORD lpBuffer,
    IN DWORD nLength,
    OUT LPDWORD lpNumberOfEventsRead,
    IN USHORT wFlags,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
WriteConsoleInputInternal(
    IN HANDLE hConsoleInput,
    IN CONST INPUT_RECORD *lpBuffer,
    IN DWORD nLength,
    OUT LPDWORD lpNumberOfEventsWritten,
    IN BOOLEAN Unicode,
    IN BOOLEAN Append
    );

BOOL
APIENTRY
ReadConsoleOutputInternal(
    IN HANDLE hConsoleOutput,
    OUT PCHAR_INFO lpBuffer,
    IN COORD dwBufferSize,
    IN COORD dwBufferCoord,
    IN OUT PSMALL_RECT lpReadRegion,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
WriteConsoleOutputInternal(
    IN HANDLE hConsoleOutput,
    IN CONST CHAR_INFO *lpBuffer,
    IN COORD dwBufferSize,
    IN COORD dwBufferCoord,
    IN PSMALL_RECT lpWriteRegion,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
ReadConsoleOutputString(
    IN HANDLE hConsoleOutput,
    OUT LPVOID lpString,
    IN DWORD nLength,
    IN DWORD nSize,
    IN DWORD fFlags,
    IN COORD dwReadCoord,
    OUT LPDWORD lpNumberOfElementsRead
    );

BOOL
APIENTRY
WriteConsoleOutputString(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpString,
    IN DWORD nLength,
    IN DWORD nSize,
    IN DWORD fFlags,
    IN COORD dwWriteCoord,
    OUT LPDWORD lpNumberOfElementsWritten
    );

BOOL
APIENTRY
FillConsoleOutput(
    IN HANDLE hConsoleOutput,
    IN WORD   Element,
    IN DWORD  nLength,
    IN DWORD  fFlags,
    IN COORD  dwWriteCoord,
    OUT LPDWORD lpNumberOfElementsWritten
    );

BOOL
APIENTRY
GetConsoleKeyboardLayoutNameWorker(
    OUT LPSTR pszLayout,
    IN BOOL bAnsi);

BOOL
APIENTRY
SetConsolePaletteInternal(
    IN HANDLE hConsoleOutput,
    IN HPALETTE hPalette,
    IN UINT dwUsage
    );

BOOL
APIENTRY
ScrollConsoleScreenBufferInternal(
    IN HANDLE hConsoleOutput,
    IN CONST SMALL_RECT *lpScrollRectangle,
    IN CONST SMALL_RECT *lpClipRectangle,
    IN COORD dwDestinationOrigin,
    IN CONST CHAR_INFO *lpFill,
    IN BOOLEAN Unicode
    );

NTSTATUS
APIENTRY
SetConsoleOutputCPInternal(
    IN UINT wCodePageID
    );

VOID
APIENTRY
SetLastConsoleEventActiveInternal(
   VOID
   );

BOOL
APIENTRY
ConnectConsoleInternal(
   IN PWSTR pObjectDirectory,
   IN OUT PCONSOLE_API_CONNECTINFO pConnectInfo,
   OUT PBOOLEAN pServerProcess
   );


BOOL
APIENTRY
AllocConsoleInternal(
   IN LPWSTR lpTitle,
   IN DWORD dwTitleLength,
   IN LPWSTR lpDesktop,
   IN DWORD dwDesktopLength,
   IN LPWSTR lpCurDir,
   IN DWORD dwCurDirLength,
   IN LPWSTR AppName,
   IN DWORD dwAppNameLength,
   IN LPTHREAD_START_ROUTINE CtrlRoutine,
   IN LPTHREAD_START_ROUTINE PropRoutine,
   IN OUT PCONSOLE_INFO pConsoleInfo
   );

BOOL
APIENTRY
FreeConsoleInternal(
   VOID
   );

BOOL
APIENTRY
AttachConsoleInternal(
   IN DWORD dwProcessId,
   IN LPTHREAD_START_ROUTINE CtrlRoutine,
   IN LPTHREAD_START_ROUTINE PropRoutine,
   IN OUT PCONSOLE_INFO pConsoleInfo
   );

BOOL
WINAPI
GetConsoleLangId(
    OUT LANGID *lpLangId
    );

BOOL
APIENTRY
AddConsoleAliasInternal(
    IN LPVOID Source,
    IN UINT   SourceLength,
    IN LPVOID Target,
    IN UINT   TargetLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasInternal(
    IN LPVOID Source,
    IN UINT   SourceLength,
    OUT LPVOID TargetBuffer,
    IN UINT   TargetBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasesLengthInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasExesLengthInternal(
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasesInternal(
    OUT LPVOID AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleAliasExesInternal(
    OUT LPVOID ExeNameBuffer,
    IN DWORD ExeNameBufferLength,
    IN BOOLEAN Unicode
    );

VOID
APIENTRY
ExpungeConsoleCommandHistoryInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

BOOL
APIENTRY
SetConsoleNumberOfCommandsInternal(
    IN DWORD Number,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleCommandHistoryLengthInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleCommandHistoryInternal(
    OUT LPVOID Commands,
    IN DWORD CommandBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    );

DWORD
APIENTRY
GetConsoleTitleInternal(
    OUT PVOID lpConsoleTitle,
    IN  DWORD nSize,
    IN  BOOLEAN Unicode
    );

BOOL
APIENTRY
SetConsoleTitleInternal(
    IN CONST VOID *lpConsoleTitle,
    IN DWORD TitleLength,  // in bytes
    IN BOOLEAN Unicode
    );

VOID
SetTEBLangID(
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\cmdline.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmdline.c

Abstract:

        This file implements command line editing and aliasing.

Author:

    Therese Stowell (thereses) 22-Mar-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

#define CONSOLE_NAME_PATH_SEPARATOR ((WCHAR)L'\\')
#define CONSOLE_NAME_PATH_TERMINATOR ((WCHAR)L'\0')

#if !defined(BUILD_WOW64)

#define FNAME_LENGTH 256
BOOLEAN ExeNameInitialized;
RTL_CRITICAL_SECTION ExeNameCriticalSection;
WCHAR ExeNameBuffer[FNAME_LENGTH];
USHORT ExeNameLength;       // in chars, not bytes
WCHAR StartDirBuffer[MAX_PATH+1];
USHORT StartDirLength;      // in chars, not bytes

VOID
InitExeName( VOID )
{

    PPEB Peb;
    PLDR_DATA_TABLE_ENTRY ImageEntry;

    if (ExeNameInitialized) {
        return;
    }

    RtlInitializeCriticalSection(&ExeNameCriticalSection);
    ExeNameInitialized = TRUE;
    Peb = NtCurrentPeb();
    ImageEntry = (PLDR_DATA_TABLE_ENTRY)Peb->Ldr->InLoadOrderModuleList.Flink;
    ImageEntry = CONTAINING_RECORD(ImageEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
    ExeNameLength = ImageEntry->BaseDllName.Length/sizeof(WCHAR);
    RtlCopyMemory(ExeNameBuffer,
           ImageEntry->BaseDllName.Buffer,
           ImageEntry->BaseDllName.Length
          );
    ExeNameBuffer[ExeNameLength] = CONSOLE_NAME_PATH_TERMINATOR;
    StartDirLength = Peb->ProcessParameters->CurrentDirectory.DosPath.Length/sizeof(WCHAR);
    RtlCopyMemory(StartDirBuffer,
           Peb->ProcessParameters->CurrentDirectory.DosPath.Buffer,
           Peb->ProcessParameters->CurrentDirectory.DosPath.Length
          );
    StartDirBuffer[StartDirLength] = CONSOLE_NAME_PATH_TERMINATOR;
}


USHORT
GetCurrentExeName(
    OUT LPWSTR Buffer,
    IN ULONG BufferLength
    )
{
    if (!ExeNameInitialized) {
        Buffer[0] = UNICODE_NULL;
        return 0;
    }

    RtlEnterCriticalSection(&ExeNameCriticalSection);
    if (BufferLength > ExeNameLength * sizeof( WCHAR )) {
        BufferLength = ExeNameLength * sizeof( WCHAR );
    }
    RtlCopyMemory(Buffer,ExeNameBuffer,BufferLength);
    RtlLeaveCriticalSection(&ExeNameCriticalSection);
    return (USHORT)BufferLength;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

USHORT
GetExeName(
    IN OUT LPVOID *ExeName,
    IN BOOLEAN UnicodeApi,
    OUT PBOOLEAN UnicodeExe
    )
{

    *UnicodeExe = TRUE;
    if (*ExeName == NULL) {
        // Should not get here
        return 0;
    } else if (!UnicodeApi) {
        *UnicodeExe = FALSE;
    }

    if (ExeName == NULL) {
       return 0;
    }
    
    try {
       if (*UnicodeExe) 
           return (USHORT)wcslen(*ExeName)*sizeof(WCHAR);  // returns bytes, not chars
       else
           return (USHORT)strlen(*ExeName);  // returns bytes, not chars
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       return 0;
    }
}

BOOL
APIENTRY
AddConsoleAliasInternal(
    IN LPVOID Source,
    IN UINT   SourceLength,
    IN LPVOID Target,
    IN UINT   TargetLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )

/*++

Parameters:

    Source - String to substitute alias string for, in input stream.

    Target - String to substitute for source.  NULL to delete an existing
        alias.

    ExeName - Exe to set alias in.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    ULONG CapturedMsgPointers;
    PCONSOLE_ADDALIAS_MSG a = &m.u.AddConsoleAliasW;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->SourceLength = (USHORT)SourceLength;
    a->Unicode = Unicode;
    CapturedMsgPointers = 2;

    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);

    if (Target != NULL) {
        a->TargetLength = (USHORT)TargetLength;
        CapturedMsgPointers += 1;
    }
    else {
        a->Target = NULL;
        a->TargetLength = 0;
    }

    CaptureBuffer = CsrAllocateCaptureBuffer( CapturedMsgPointers,
                                              a->SourceLength + a->TargetLength + a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) Source,
                             a->SourceLength,
                             (PVOID *) &a->Source
                           );

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    if (Target != NULL) {
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 (PCHAR) Target,
                                 a->TargetLength,
                                 (PVOID *) &a->Target
                               );
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepAddAlias
                                            ),
                         sizeof( *a )
                       );

    CsrFreeCaptureBuffer( CaptureBuffer );

    if (!NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    return TRUE;

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
AddConsoleAliasW(
    IN LPWSTR Source,
    IN LPWSTR Target,
    IN LPWSTR ExeName
    )
{
    USHORT TargetLength;

    if (Target != NULL) {
        TargetLength = (USHORT) (lstrlenW(Target)*sizeof(WCHAR));
    } else {
        TargetLength = 0;
    }
    return AddConsoleAliasInternal(Source,
                                   lstrlenW(Source)*sizeof(WCHAR),
                                   Target,
                                   TargetLength,
                                   ExeName,
                                   TRUE
                                  );
}

BOOL
APIENTRY
AddConsoleAliasA(
    IN LPTSTR Source,
    IN LPTSTR Target,
    IN LPTSTR ExeName
    )
{
    USHORT TargetLength;

    if (Target != NULL) {
        TargetLength = (USHORT) lstrlenA(Target);
    } else {
        TargetLength = 0;
    }
    return AddConsoleAliasInternal(Source,
                                   lstrlenA(Source),
                                   Target,
                                   TargetLength,
                                   ExeName,
                                   FALSE
                                  );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasInternal(
    IN LPVOID Source,
    IN UINT   SourceLength,
    OUT LPVOID TargetBuffer,
    IN UINT   TargetBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )

/*++

Parameters:

    Source - Name of alias to query.  NULL means query all alias names.

    Target - Where to store value of alias.  If Source is NULL, then
        value is one or more null terminated strings terminated by an extra
        null byte.  Each null terminated string is the name of an alias.

Return Value:

    Non-zero - The operation was successful, and the return value is the
        number of characters stored in the Target buffer.

    Zero - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    ULONG CapturedMsgPointers;
    PCONSOLE_GETALIAS_MSG a = &m.u.GetConsoleAliasW;

    if (Source == NULL) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Unicode = Unicode;

    CapturedMsgPointers = 3;

    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);

    a->SourceLength = (USHORT) SourceLength;
    a->TargetLength = (USHORT) TargetBufferLength;

    CaptureBuffer = CsrAllocateCaptureBuffer( CapturedMsgPointers,
                                              a->SourceLength + a->TargetLength + a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) Source,
                             a->SourceLength,
                             (PVOID *) &a->Source
                           );

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) NULL,
                             a->TargetLength,
                             (PVOID *) &a->Target
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAlias
                                            ),
                         sizeof( *a )
                       );

    if (NT_SUCCESS( m.ReturnValue )) {
        RtlCopyMemory( TargetBuffer, a->Target, a->TargetLength );
    }
    else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        if (m.ReturnValue != STATUS_BUFFER_TOO_SMALL) {
            a->TargetLength = 0;
        }
    }

    CsrFreeCaptureBuffer( CaptureBuffer );

    return a->TargetLength;

}

#endif !defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
APIENTRY
GetConsoleAliasW(
    IN LPWSTR Source,
    OUT LPWSTR TargetBuffer,
    IN DWORD TargetBufferLength,
    IN LPWSTR ExeName
    )
{
    return GetConsoleAliasInternal(Source,
                                   lstrlenW(Source)*sizeof(WCHAR),
                                   TargetBuffer,
                                   TargetBufferLength,
                                   ExeName,
                                   TRUE
                                  );
}

DWORD
APIENTRY
GetConsoleAliasA(
    IN LPTSTR Source,
    OUT LPTSTR TargetBuffer,
    IN DWORD TargetBufferLength,
    IN LPTSTR ExeName
    )
{
    return GetConsoleAliasInternal(Source,
                                   lstrlenA(Source),
                                   TargetBuffer,
                                   TargetBufferLength,
                                   ExeName,
                                   FALSE
                                  );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasesLengthInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETALIASESLENGTH_MSG a = &m.u.GetConsoleAliasesLengthW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);
    a->Unicode = Unicode;

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAliasesLength
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( CaptureBuffer );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->AliasesLength;
    } else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
APIENTRY
GetConsoleAliasesLengthW(
    IN LPWSTR ExeName
    )
{
    return GetConsoleAliasesLengthInternal(ExeName,
                                           TRUE
                                          );
}

DWORD
APIENTRY
GetConsoleAliasesLengthA(
    IN LPTSTR ExeName
    )
{
    return GetConsoleAliasesLengthInternal(ExeName,
                                           FALSE
                                          );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasExesLengthInternal(
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETALIASEXESLENGTH_MSG a = &m.u.GetConsoleAliasExesLengthW;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Unicode = Unicode;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAliasExesLength
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->AliasExesLength;
    } else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
APIENTRY
GetConsoleAliasExesLengthW( VOID )
{
    return GetConsoleAliasExesLengthInternal( TRUE );
}

DWORD
APIENTRY
GetConsoleAliasExesLengthA( VOID )
{
    return GetConsoleAliasExesLengthInternal( FALSE );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasesInternal(
    OUT LPVOID AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETALIASES_MSG a = &m.u.GetConsoleAliasesW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);
    a->Unicode = Unicode;
    a->AliasesBufferLength = AliasBufferLength;

    CaptureBuffer = CsrAllocateCaptureBuffer( 2,
                                              a->ExeLength + AliasBufferLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );
    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) NULL,
                             a->AliasesBufferLength,
                             (PVOID *) &a->AliasesBuffer
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAliases
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( AliasBuffer, a->AliasesBuffer, a->AliasesBufferLength );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
        CsrFreeCaptureBuffer( CaptureBuffer );
        return a->AliasesBufferLength;
    } else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
GetConsoleAliasesW(
    OUT LPWSTR AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPWSTR ExeName
    )
{
    return GetConsoleAliasesInternal(AliasBuffer,
                                     AliasBufferLength,
                                     ExeName,
                                     TRUE
                                    );
}

DWORD
GetConsoleAliasesA(
    OUT LPTSTR AliasBuffer,
    IN DWORD AliasBufferLength,
    IN LPTSTR ExeName
    )
{
    return GetConsoleAliasesInternal(AliasBuffer,
                                     AliasBufferLength,
                                     ExeName,
                                     FALSE
                                    );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleAliasExesInternal(
    OUT LPVOID ExeNameBuffer,
    IN DWORD ExeNameBufferLength,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETALIASEXES_MSG a = &m.u.GetConsoleAliasExesW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->AliasExesBufferLength = ExeNameBufferLength;
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              ExeNameBufferLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) NULL,
                             a->AliasExesBufferLength,
                             (PVOID *) &a->AliasExesBuffer
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetAliasExes
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( ExeNameBuffer, a->AliasExesBuffer, a->AliasExesBufferLength );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
        CsrFreeCaptureBuffer( CaptureBuffer );
        return a->AliasExesBufferLength;
    } else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
GetConsoleAliasExesW(
    OUT LPWSTR ExeNameBuffer,
    IN DWORD ExeNameBufferLength
    )
{
    return GetConsoleAliasExesInternal(ExeNameBuffer,
                                       ExeNameBufferLength,
                                       TRUE
                                      );
}

DWORD
GetConsoleAliasExesA(
    OUT LPTSTR ExeNameBuffer,
    IN DWORD ExeNameBufferLength
    )
{
    return GetConsoleAliasExesInternal(ExeNameBuffer,
                                       ExeNameBufferLength,
                                       FALSE
                                      );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

VOID
APIENTRY
ExpungeConsoleCommandHistoryInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_EXPUNGECOMMANDHISTORY_MSG a = &m.u.ExpungeConsoleCommandHistoryW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);
    a->Unicode = Unicode;

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepExpungeCommandHistory
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( CaptureBuffer );

}


#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

VOID
ExpungeConsoleCommandHistoryW(
    IN LPWSTR ExeName
    )
{
    ExpungeConsoleCommandHistoryInternal(ExeName,TRUE);
}

VOID
ExpungeConsoleCommandHistoryA(
    IN LPTSTR ExeName
    )
{
    ExpungeConsoleCommandHistoryInternal(ExeName,FALSE);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
SetConsoleNumberOfCommandsInternal(
    IN DWORD Number,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_SETNUMBEROFCOMMANDS_MSG a = &m.u.SetConsoleNumberOfCommandsW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->NumCommands = Number;
    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetNumberOfCommands
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( CaptureBuffer );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
SetConsoleNumberOfCommandsW(
    IN DWORD Number,
    IN LPWSTR ExeName
    )
{
    return SetConsoleNumberOfCommandsInternal(Number,
                                              ExeName,
                                              TRUE
                                             );
}

BOOL
SetConsoleNumberOfCommandsA(
    IN DWORD Number,
    IN LPTSTR ExeName
    )
{
    return SetConsoleNumberOfCommandsInternal(Number,
                                              ExeName,
                                              FALSE
                                             );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleCommandHistoryLengthInternal(
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{    
    CONSOLE_API_MSG m;
    PCONSOLE_GETCOMMANDHISTORYLENGTH_MSG a = &m.u.GetConsoleCommandHistoryLengthW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCommandHistoryLength
                                            ),
                         sizeof( *a )
                       );
    CsrFreeCaptureBuffer( CaptureBuffer );
    return a->CommandHistoryLength;

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
GetConsoleCommandHistoryLengthW(
    IN LPWSTR ExeName
    )
{
    return GetConsoleCommandHistoryLengthInternal(ExeName,
                                                  TRUE
                                                 );
}

DWORD
GetConsoleCommandHistoryLengthA(
    IN LPTSTR ExeName
    )
{
    return GetConsoleCommandHistoryLengthInternal(ExeName,
                                                  FALSE
                                                 );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

DWORD
APIENTRY
GetConsoleCommandHistoryInternal(
    OUT LPVOID Commands,
    IN DWORD CommandBufferLength,
    IN LPVOID ExeName,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETCOMMANDHISTORY_MSG a = &m.u.GetConsoleCommandHistoryW;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->CommandBufferLength = CommandBufferLength;
    a->ExeLength = GetExeName(&ExeName,Unicode,&a->UnicodeExe);
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 2,
                                              CommandBufferLength + a->ExeLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }


    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) ExeName,
                             a->ExeLength,
                             (PVOID *) &a->Exe
                           );

    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) NULL,
                             a->CommandBufferLength,
                             (PVOID *) &a->CommandBuffer
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCommandHistory
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( Commands, a->CommandBuffer, a->CommandBufferLength );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
        CsrFreeCaptureBuffer( CaptureBuffer );
        return a->CommandBufferLength;
    } else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR(m.ReturnValue);
        return 0;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
GetConsoleCommandHistoryW(
    OUT LPWSTR Commands,
    IN DWORD CommandBufferLength,
    IN LPWSTR ExeName
    )
{
    return GetConsoleCommandHistoryInternal(Commands,
                                            CommandBufferLength,
                                            ExeName,
                                            TRUE
                                           );
}

DWORD
GetConsoleCommandHistoryA(
    OUT LPTSTR Commands,
    IN DWORD CommandBufferLength,
    IN LPTSTR ExeName
    )
{
    return GetConsoleCommandHistoryInternal(Commands,
                                            CommandBufferLength,
                                            ExeName,
                                            FALSE
                                           );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
SetConsoleCommandHistoryMode(
    IN DWORD Flags
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_SETCOMMANDHISTORYMODE_MSG a = &m.u.SetConsoleCommandHistoryMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Flags = Flags;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCommandHistoryMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
}

DWORD
APIENTRY
GetConsoleTitleInternal(
    OUT PVOID lpConsoleTitle,
    IN DWORD nSize,
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETTITLE_MSG a = &m.u.GetConsoleTitle;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    if (nSize == 0) {
        return 0;
    }
    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->TitleLength = nSize;
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              a->TitleLength
                                            );
    if (CaptureBuffer == NULL) {
        return 0;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             NULL,
                             a->TitleLength,
                             (PVOID *) &a->Title
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetTitle
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( lpConsoleTitle, a->Title, a->TitleLength);
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
    }
    else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR (m.ReturnValue);
        return 0;
    }
    CsrFreeCaptureBuffer( CaptureBuffer );
    return a->TitleLength;

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

DWORD
APIENTRY
GetConsoleTitleA(
    LPSTR lpConsoleTitle,
    DWORD nSize
    )
{
    DWORD NumBytes;
    NumBytes = GetConsoleTitleInternal(lpConsoleTitle,
                                   nSize-sizeof(CHAR), // allow room for null
                                   FALSE
                                  );
    if (NumBytes) {
        lpConsoleTitle[NumBytes] = '\0';   // NULL terminate
    }
    return NumBytes;
}

DWORD
APIENTRY
GetConsoleTitleW(
    LPWSTR lpConsoleTitle,
    DWORD nSize
    )
{
    DWORD NumBytes;
    NumBytes = GetConsoleTitleInternal(lpConsoleTitle,
                                   (nSize-1)*sizeof(WCHAR), // allow room for null
                                   TRUE
                                  );
    if (NumBytes) {
        NumBytes /= sizeof(WCHAR);
        lpConsoleTitle[NumBytes] = CONSOLE_NAME_PATH_TERMINATOR;   // NULL terminate
    }
    return NumBytes;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
SetConsoleTitleInternal(
    IN CONST VOID *lpConsoleTitle,
    IN DWORD TitleLength,  // in bytes
    IN BOOLEAN Unicode
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_SETTITLE_MSG a = &m.u.SetConsoleTitle;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->TitleLength = TitleLength;
    a->Unicode = Unicode;
    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              a->TitleLength
                                            );
    if (CaptureBuffer == NULL) {
        return FALSE;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             (PCHAR) lpConsoleTitle,
                             a->TitleLength,
                             (PVOID *) &a->Title
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetTitle
                                            ),
                         sizeof( *a )
                       );

    CsrFreeCaptureBuffer( CaptureBuffer );

    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    }
    else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
SetConsoleTitleA(
    LPCSTR lpConsoleTitle
    )
{
    DWORD TitleLength;
    try {
        TitleLength = strlen(lpConsoleTitle);
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    return SetConsoleTitleInternal(lpConsoleTitle,
                                   TitleLength,
                                   FALSE);
}

BOOL
APIENTRY
SetConsoleTitleW(
    LPCWSTR lpConsoleTitle
    )
{
    DWORD TitleLength;
    try {
        TitleLength = wcslen(lpConsoleTitle)*sizeof(WCHAR);
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    return SetConsoleTitleInternal(lpConsoleTitle,
                                   TitleLength,
                                   TRUE);
}


DWORD
GetConsoleInputExeNameA(
    IN DWORD nBufferLength,
    OUT LPSTR lpBuffer
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    WCHAR TempExeNameBuffer[FNAME_LENGTH];
    DWORD n;

    n = GetConsoleInputExeNameW(FNAME_LENGTH, TempExeNameBuffer);
    if (n != 0 && n < FNAME_LENGTH) {
        RtlInitUnicodeString(&UnicodeString, TempExeNameBuffer);
        AnsiString.Buffer = lpBuffer;
        AnsiString.Length = 0;
        AnsiString.MaximumLength = (USHORT)nBufferLength;
        Status = RtlUnicodeStringToAnsiString(&AnsiString, &UnicodeString, FALSE);
        if (!NT_SUCCESS(Status)) {
            if (Status == STATUS_BUFFER_OVERFLOW) {
                SET_LAST_ERROR(ERROR_BUFFER_OVERFLOW);
                return n+1;
            } else {
                SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
            }
        }
    }
    return n;
}

DWORD
GetConsoleInputExeNameW(
    IN DWORD nBufferLength,
    OUT LPWSTR lpBuffer
    )
{
    DWORD n;

    n = ExeNameLength;
    if (n >= nBufferLength) {
        SET_LAST_ERROR(ERROR_BUFFER_OVERFLOW);
        return n+1;
    }

    try {
        RtlEnterCriticalSection(&ExeNameCriticalSection);
        RtlCopyMemory(lpBuffer, ExeNameBuffer, n*sizeof(WCHAR));
        lpBuffer[n] = UNICODE_NULL;
    } finally {
        RtlLeaveCriticalSection(&ExeNameCriticalSection);
    }

    return TRUE;
}

BOOL
SetConsoleInputExeNameA(
    IN LPSTR lpExeName
    )
{
    PUNICODE_STRING Unicode;
    ANSI_STRING AnsiString;
    NTSTATUS Status;

    Unicode = &NtCurrentTeb()->StaticUnicodeString;
    RtlInitAnsiString(&AnsiString,lpExeName);
    Status = RtlAnsiStringToUnicodeString(Unicode,&AnsiString,FALSE);
    if (!NT_SUCCESS(Status)) {
        if (Status == STATUS_BUFFER_OVERFLOW) {
            SET_LAST_ERROR(ERROR_FILENAME_EXCED_RANGE);
        } else {
            SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        }
        return FALSE;
    }

    return SetConsoleInputExeNameW(Unicode->Buffer);
}

BOOL
SetConsoleInputExeNameW(
    IN LPWSTR lpExeName
    )
{
    DWORD n;

    n = lstrlenW(lpExeName);
    if (n == 0 || n >= FNAME_LENGTH) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    RtlEnterCriticalSection(&ExeNameCriticalSection);
    try {
        RtlCopyMemory(ExeNameBuffer,lpExeName,n*sizeof(WCHAR));
        ExeNameLength = (USHORT)n;
    } finally {
        RtlLeaveCriticalSection(&ExeNameCriticalSection);
    }

    return TRUE;
}

#endif //!defined(BUILD_WOW64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\dbcs.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dbcs.c

Abstract:

Author:

    KazuM May.11.1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(FE_SB)
#include "conime.h"

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
GetConsoleNlsMode(
    IN HANDLE hConsoleHandle,
    OUT LPDWORD lpNlsMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    lpNlsMode - Supplies a pointer to the NLS mode.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

#if defined(FE_IME)
    CONSOLE_API_MSG m;
    PCONSOLE_NLS_MODE_MSG a = &m.u.GetConsoleNlsMode;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->Ready = FALSE;

    Status = NtCreateEvent(&(a->hEvent),
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           (BOOLEAN)FALSE
                           );
    if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetNlsMode
                                            ),
                         sizeof( *a )
                       );

    if (NT_SUCCESS( m.ReturnValue )) {
	Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);

        if (a->Ready == FALSE)
        {
            /*
             * If not ready conversion status on this console,
             * then one more try get status.
             */
            CsrClientCallServer( (PCSR_API_MSG)&m,
                                 NULL,
                                 CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                                      ConsolepGetNlsMode
                                                    ),
                                 sizeof( *a )
                               );
            if (! NT_SUCCESS( m.ReturnValue )) {
                SET_LAST_NT_ERROR (m.ReturnValue);
                NtClose(a->hEvent);
                return FALSE;
            }
            else
            {
	        Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);
            }
        }

	NtClose(a->hEvent);

        try {
            *lpNlsMode = a->NlsMode;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        NtClose(a->hEvent);
        return FALSE;
    }
#else
    return FALSE;
#endif

}

BOOL
APIENTRY
SetConsoleNlsMode(
    IN HANDLE hConsoleHandle,
    IN DWORD dwNlsMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    dwNlsMode - Supplies NLS mode.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

#if defined(FE_IME)
    CONSOLE_API_MSG m;
    PCONSOLE_NLS_MODE_MSG a = &m.u.SetConsoleNlsMode;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->NlsMode = dwNlsMode;

    Status = NtCreateEvent(&(a->hEvent),
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           (BOOLEAN)FALSE
                           );
    if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetNlsMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
	Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);
        NtClose(a->hEvent);	
	if (Status != 0) {
	    SET_LAST_NT_ERROR(Status);
	    return FALSE;
	}
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        NtClose(a->hEvent);
        return FALSE;
    }
#else
    return FALSE;
#endif

}

BOOL
APIENTRY
GetConsoleCharType(
    IN HANDLE hConsoleHandle,
    IN COORD coordCheck,
    OUT PDWORD pdwType
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    coordCheck - set check position to these coordinates

    pdwType - receive character type

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CHAR_TYPE_MSG a = &m.u.GetConsoleCharType;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->coordCheck = coordCheck;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepCharType
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *pdwType = a->dwType;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
APIENTRY
SetConsoleLocalEUDC(
    IN HANDLE hConsoleHandle,
    IN WORD   wCodePoint,
    IN COORD  cFontSize,
    IN PCHAR  lpSB
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    wCodePoint - Code point of font by Shift JIS code.

    cFontSize - FontSize of Font

    lpSB - Pointer of font bitmap Buffer

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_LOCAL_EUDC_MSG a = &m.u.SetConsoleLocalEUDC;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    ULONG DataLength;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->CodePoint = wCodePoint;
    a->FontSize = cFontSize;

    DataLength = ((cFontSize.X + 7) / 8) * cFontSize.Y;

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              DataLength
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             lpSB,
                             DataLength,
                             (PVOID *) &a->FontFace
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetLocalEUDC
                                            ),
                         sizeof( *a )
                       );
        CsrFreeCaptureBuffer( CaptureBuffer );

    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
APIENTRY
SetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    IN BOOL   Blink,
    IN BOOL   DBEnable
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    Blink - Blinking enable/disable switch.

    DBEnable - Double Byte width enable/disable switch.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CURSOR_MODE_MSG a = &m.u.SetConsoleCursorMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->Blink = Blink;
    a->DBEnable = DBEnable;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCursorMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
APIENTRY
GetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    OUT PBOOL  pbBlink,
    OUT PBOOL  pbDBEnable
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    Blink - Blinking enable/disable switch.

    DBEnable - Double Byte width enable/disable switch.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CURSOR_MODE_MSG a = &m.u.GetConsoleCursorMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCursorMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *pbBlink = a->Blink;
            *pbDBEnable = a->DBEnable;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
APIENTRY
RegisterConsoleOS2(
    IN BOOL fOs2Register
    )

/*++

Description:

    This routine registers the OS/2 with the console.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_REGISTEROS2_MSG a = &m.u.RegisterConsoleOS2;
    NTSTATUS Status;


    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->fOs2Register  = fOs2Register;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepRegisterOS2
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }
}

BOOL
APIENTRY
SetConsoleOS2OemFormat(
    IN BOOL fOs2OemFormat
    )

/*++

Description:

    This routine sets the OS/2 OEM Format with the console.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_SETOS2OEMFORMAT_MSG a = &m.u.SetConsoleOS2OemFormat;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->fOs2OemFormat = fOs2OemFormat;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetOS2OemFormat
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }
}

#endif //!defined(BUILD_WOW6432)

#if defined(FE_IME)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
RegisterConsoleIMEInternal(
    IN HWND hWndConsoleIME,
    IN DWORD dwConsoleIMEThreadId,
    IN DWORD DesktopLength,
    IN LPWSTR Desktop,
    OUT DWORD *dwConsoleThreadId
    )
{

   CONSOLE_API_MSG m;
   PCONSOLE_REGISTER_CONSOLEIME_MSG a = &m.u.RegisterConsoleIME;
   PCSR_CAPTURE_HEADER CaptureBuffer = NULL;

   a->ConsoleHandle        = GET_CONSOLE_HANDLE;
   a->hWndConsoleIME       = hWndConsoleIME;
   a->dwConsoleIMEThreadId = dwConsoleIMEThreadId;
   a->DesktopLength        = DesktopLength;

   CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                             DesktopLength
                                            );
   if (CaptureBuffer == NULL) {
       SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
       return FALSE;
   }

   CsrCaptureMessageBuffer( CaptureBuffer,
                            Desktop,
                            a->DesktopLength,
                            (PVOID *) &a->Desktop
                          );

   //
   // Connect to the server process
   //

   CsrClientCallServer( (PCSR_API_MSG)&m,
                        CaptureBuffer,
                        CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                             ConsolepRegisterConsoleIME
                                           ),
                        sizeof( *a )
                      );

//HS Jan.20    if (CaptureBuffer) {
       CsrFreeCaptureBuffer( CaptureBuffer );
//HS Jan.20    }

   if (!NT_SUCCESS( m.ReturnValue)) {
       SET_LAST_NT_ERROR(m.ReturnValue);
       return FALSE;
   }
   else {
       try {
           if (dwConsoleThreadId != NULL)
               *dwConsoleThreadId = a->dwConsoleThreadId;
       } except( EXCEPTION_EXECUTE_HANDLER ) {
           SET_LAST_ERROR (ERROR_INVALID_ACCESS);
           return FALSE;
       }
       return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
RegisterConsoleIME(
    IN HWND  hWndConsoleIME,
    OUT DWORD *dwConsoleThreadId
    )

/*++

Description:

    This routine register the Console IME on the current desktop.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{
    STARTUPINFOW StartupInfo;
    DWORD dwDesktopLength;
    GetStartupInfoW(&StartupInfo);

    if (StartupInfo.lpDesktop != NULL && *StartupInfo.lpDesktop != 0) {
        dwDesktopLength = (USHORT)((wcslen(StartupInfo.lpDesktop)+1)*sizeof(WCHAR));
        dwDesktopLength = (USHORT)(min(dwDesktopLength,MAX_TITLE_LENGTH));
    } else {
        dwDesktopLength = 0;
    }

    return RegisterConsoleIMEInternal(hWndConsoleIME,
                                      GetCurrentThreadId(),
                                      dwDesktopLength,
                                      StartupInfo.lpDesktop,
                                      dwConsoleThreadId);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
UnregisterConsoleIMEInternal(
    IN DWORD dwConsoleIMEThtreadId
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_UNREGISTER_CONSOLEIME_MSG a = &m.u.UnregisterConsoleIME;

    a->ConsoleHandle        = GET_CONSOLE_HANDLE;
    a->dwConsoleIMEThreadId = dwConsoleIMEThtreadId;

    //
    // Connect to the server process
    //

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepUnregisterConsoleIME
                                            ),
                         sizeof( *a )
                       );

    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
UnregisterConsoleIME(
    )

/*++

Description:

    This routine unregister the Console IME on the current desktop.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    return UnregisterConsoleIMEInternal(GetCurrentThreadId());

}

NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtOpenKey(
              phResult,
              KEY_READ,
              &Obja
              );
}

NTSTATUS
MyRegQueryValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + dwValueLength + ValueName.Length;;
    KeyValueInformation = LocalAlloc(LPTR,BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValueFullInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->DataLength <= dwValueLength);
        RtlMoveMemory(lpData,
            (PBYTE)KeyValueInformation + KeyValueInformation->DataOffset,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwValueLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    LocalFree(KeyValueInformation);
    return Status;
}

VOID
GetCommandLineString(
    IN LPWSTR CommandLine,
    IN DWORD  dwSize
    )
{
    NTSTATUS Status;
    HANDLE hkRegistry;
    WCHAR awchBuffer[ 512 ];
    DWORD dwRet;

    dwRet = GetSystemDirectoryW(CommandLine, dwSize);
    if (dwRet)
    {
        CommandLine[dwRet++] = L'\\';
        CommandLine[dwRet]   = L'\0';
        dwSize -= dwRet;

    }
    else
    {
        CommandLine[0] = L'\0';
    }

    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE,
                          &hkRegistry);
    if (NT_SUCCESS( Status ))
    {
        Status = MyRegQueryValue(hkRegistry,
                                 MACHINE_REGISTRY_CONSOLEIME,
                                 sizeof(awchBuffer), (PBYTE)&awchBuffer);
        if (NT_SUCCESS( Status ))
        {
            dwRet = wcslen(awchBuffer);
            if (dwRet < dwSize)
            {
                wcscat(CommandLine, awchBuffer);
            }
            else
            {
                CommandLine[0] = L'\0';
                goto ErrorExit;
            }
        }
        else
        {
            goto ErrorExit;
        }

        NtClose(hkRegistry);
    }
    else
    {
        goto ErrorExit;
    }

    return;

ErrorExit:
    wcscat(CommandLine, L"conime.exe");
    return;
}


DWORD
ConsoleIMERoutine(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This thread is created when the create input thread.
    It invokes the console IME process.

Arguments:

    lpThreadParameter - not use.

Return Value:

    STATUS_SUCCESS - function was successful

--*/

{
    NTSTATUS Status;
    BOOL fRet;
    static BOOL fInConIMERoutine = FALSE;

    DWORD fdwCreate;
    STARTUPINFOW StartupInfo;
    STARTUPINFOW StartupInfoConsole;
    WCHAR CommandLine[MAX_PATH*2];
    PROCESS_INFORMATION ProcessInformation;
    HANDLE hEvent;
    DWORD dwWait;

    Status = STATUS_SUCCESS;

    //
    // Prevent the user from launching multiple applets attached
    // to a single console
    //

    if (fInConIMERoutine) {
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

    fInConIMERoutine = TRUE;

    //
    // Create event
    //
    hEvent = CreateEventW(NULL,                 // Security attributes
                          FALSE,                // Manual reset
                          FALSE,                // Initial state
                          CONSOLEIME_EVENT);    // Event object name
    if (hEvent == NULL)
    {
        goto ErrorExit;
    }
    if (GetLastError() == ERROR_ALREADY_EXISTS)
    {
        goto ErrorExit;
    }

    //
    // Get Console IME process name and event name
    //

    GetCommandLineString(CommandLine, sizeof(CommandLine)/sizeof(WCHAR));

    GetStartupInfoW(&StartupInfoConsole);
    RtlZeroMemory(&StartupInfo, sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.wShowWindow = SW_HIDE;
    StartupInfo.dwFlags = STARTF_FORCEONFEEDBACK;
    StartupInfo.lpDesktop = StartupInfoConsole.lpDesktop;

    //
    // create Console IME process
    //

    fdwCreate = NORMAL_PRIORITY_CLASS | CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP;
    fRet = CreateProcessW(NULL,                // Application name
                          CommandLine,         // Command line
                          NULL,                // process security attributes
                          NULL,                // thread security attributes
                          FALSE,               // inherit handles
                          fdwCreate,           // create flags
                          NULL,                // environment
                          NULL,                // current directory
                          &StartupInfo,        // Start up information
                          &ProcessInformation  // process information
                         );
    if (! fRet)
    {
        Status = GetLastError();
    }
    else
    {
        dwWait = WaitForSingleObject(hEvent, 10 * 1000);    // wait 10 sec for console IME process
        if (dwWait == WAIT_TIMEOUT)
        {
            TerminateProcess(ProcessInformation.hProcess, 0);
        }
        CloseHandle(ProcessInformation.hThread) ;
        CloseHandle(ProcessInformation.hProcess) ;
    }

    CloseHandle(hEvent);

ErrorExit:

    fInConIMERoutine = FALSE;

    return Status;
}

#endif //!defined(BUILD_WOW6432)

#endif // FE_IME


#else // FE_SB

// Followings are stub functions for FE Console Support


#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
GetConsoleNlsMode(
    IN HANDLE hConsoleHandle,
    OUT LPDWORD lpNlsMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    lpNlsMode - Supplies a pointer to the NLS mode.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    return FALSE;
}

BOOL
APIENTRY
SetConsoleNlsMode(
    IN HANDLE hConsoleHandle,
    IN DWORD dwNlsMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    dwNlsMode - Supplies NLS mode.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
GetConsoleCharType(
    IN HANDLE hConsoleHandle,
    IN COORD coordCheck,
    OUT PDWORD pdwType
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    coordCheck - set check position to these coordinates

    pdwType - receive character type

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    return FALSE;
}

BOOL
APIENTRY
SetConsoleLocalEUDC(
    IN HANDLE hConsoleHandle,
    IN WORD   wCodePoint,
    IN COORD  cFontSize,
    IN PCHAR  lpSB
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    wCodePoint - Code point of font by Shift JIS code.

    cFontSize - FontSize of Font

    lpSB - Pointer of font bitmap Buffer

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
SetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    IN BOOL   Blink,
    IN BOOL   DBEnable
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    Blink - Blinking enable/disable switch.

    DBEnable - Double Byte width enable/disable switch.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
GetConsoleCursorMode(
    IN HANDLE hConsoleHandle,
    OUT PBOOL  pbBlink,
    OUT PBOOL  pbDBEnable
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    Blink - Blinking enable/disable switch.

    DBEnable - Double Byte width enable/disable switch.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
RegisterConsoleOS2(
    IN BOOL fOs2Register
    )

/*++

Description:

    This routine registers the OS/2 with the console.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

BOOL
APIENTRY
SetConsoleOS2OemFormat(
    IN BOOL fOs2OemFormat
    )

/*++

Description:

    This routine sets the OS/2 OEM Format with the console.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    return FALSE;
}

#endif //!defined(BUILD_WOW6432)

#if defined(FE_IME)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
RegisterConsoleIME(
    IN HWND  hWndConsoleIME,
    OUT DWORD *dwConsoleThreadId
    )

/*++

Description:

    This routine register the Console IME on the current desktop.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    return FALSE;

}

BOOL
APIENTRY
UnregisterConsoleIME(
    )

/*++

Description:

    This routine unregister the Console IME on the current desktop.

Parameters:

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed.

--*/

{

    return FALSE;

}

#endif //!defined(BUILD_WOW64)

#endif // FE_IME

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\dllinit.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dllinit.c

Abstract:

    This module implements console dll initialization

Author:

    Therese Stowell (thereses) 11-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if !defined(BUILD_WOW64)

#include <cpl.h>

#define DEFAULT_WINDOW_TITLE (L"Command Prompt")

extern HANDLE InputWaitHandle;
extern WCHAR ExeNameBuffer[];
extern USHORT ExeNameLength;
extern WCHAR StartDirBuffer[];
extern USHORT StartDirLength;

DWORD
CtrlRoutine(
    IN LPVOID lpThreadParameter
    );

DWORD
PropRoutine(
    IN LPVOID lpThreadParameter
    );

#if defined(FE_SB)
#if defined(FE_IME)
DWORD
ConsoleIMERoutine(
    IN LPVOID lpThreadParameter
    );
#endif // FE_IME
#endif // FE_SB


#define MAX_SESSION_PATH   256
#define SESSION_ROOT       L"\\Sessions"

BOOLEAN
ConsoleApp( VOID )

/*++

    This routine determines whether the current process is a console or
    windows app.

Parameters:

    none.

Return Value:

    TRUE if console app.

--*/

{
    PIMAGE_NT_HEADERS NtHeaders;

    NtHeaders = RtlImageNtHeader(GetModuleHandle(NULL));
    return ((NtHeaders != NULL) &&
            (NtHeaders->OptionalHeader.Subsystem == IMAGE_SUBSYSTEM_WINDOWS_CUI)) ? TRUE : FALSE;
}


VOID
SetUpAppName(
    IN OUT LPDWORD CurDirLength,
    OUT LPWSTR CurDir,
    IN OUT LPDWORD AppNameLength,
    OUT LPWSTR AppName
    )
{
    DWORD Length;

    *CurDirLength -= sizeof(WCHAR);
    Length = (StartDirLength*sizeof(WCHAR)) > *CurDirLength ? *CurDirLength : (StartDirLength*sizeof(WCHAR));
    RtlCopyMemory(CurDir,StartDirBuffer,Length+sizeof(WCHAR));
    *CurDirLength = Length + sizeof(WCHAR);   // add terminating NULL

    *AppNameLength -= sizeof(WCHAR);
    Length = (ExeNameLength*sizeof(WCHAR)) > *AppNameLength ? *AppNameLength : (ExeNameLength*sizeof(WCHAR));
    RtlCopyMemory(AppName,ExeNameBuffer,Length+sizeof(WCHAR));
    *AppNameLength = Length + sizeof(WCHAR);   // add terminating NULL
}


ULONG
ParseReserved(
    WCHAR *pchReserved,
    WCHAR *pchFind
    )
{
    ULONG dw;
    WCHAR *pch, *pchT, ch;
    UNICODE_STRING uString;

    dw = 0;
    if ((pch = wcsstr(pchReserved, pchFind)) != NULL) {
        pch += lstrlenW(pchFind);

        pchT = pch;
        while (*pchT >= '0' && *pchT <= '9')
            pchT++;

        ch = *pchT;
        *pchT = 0;
        RtlInitUnicodeString(&uString, pch);
        *pchT = ch;

        RtlUnicodeStringToInteger(&uString, 0, &dw);
    }

    return dw;
}


VOID
SetUpConsoleInfo(
    IN BOOL DllInit,
    OUT LPDWORD TitleLength,
    OUT LPWSTR Title OPTIONAL,
    OUT LPDWORD DesktopLength,
    OUT LPWSTR *Desktop OPTIONAL,
    OUT PCONSOLE_INFO ConsoleInfo
    )

/*++

    This routine fills in the ConsoleInfo structure with the values
    specified by the user.

Parameters:

    ConsoleInfo - pointer to structure to fill in.

Return Value:

    none.

--*/

{
    STARTUPINFOW StartupInfo;
    HANDLE h;
    int id;
    HANDLE ghInstance;
    BOOL Success;


    GetStartupInfoW(&StartupInfo);
    ghInstance = (HANDLE)((PVOID)NtCurrentPeb()->ImageBaseAddress );

    // these will eventually be filled in using menu input

    ConsoleInfo->nFont = 0;
    ConsoleInfo->nInputBufferSize = 0;
    ConsoleInfo->hIcon = NULL;
    ConsoleInfo->hSmIcon = NULL;
    ConsoleInfo->iIconId = 0;
    ConsoleInfo->dwStartupFlags = StartupInfo.dwFlags;
#if defined(FE_SB)
    ConsoleInfo->uCodePage = GetOEMCP();
#endif
    if (StartupInfo.lpTitle == NULL) {
        StartupInfo.lpTitle = DEFAULT_WINDOW_TITLE;
    }

    //
    // if the desktop name was specified, set up the pointers.
    //

    if (DllInit && Desktop != NULL &&
            StartupInfo.lpDesktop != NULL && *StartupInfo.lpDesktop != 0) {
        *DesktopLength = (lstrlenW(StartupInfo.lpDesktop) + 1) * sizeof(WCHAR);
        *Desktop = StartupInfo.lpDesktop;
    } else {
        *DesktopLength = 0;
        if (Desktop != NULL)
            *Desktop = NULL;
    }

    // Nope, do normal initialization (TitleLength is in BYTES, not CHARS!)
    *TitleLength = (USHORT)((lstrlenW(StartupInfo.lpTitle)+1)*sizeof(WCHAR));
    *TitleLength = (USHORT)(min(*TitleLength,MAX_TITLE_LENGTH));
    if (DllInit) {
        RtlCopyMemory(Title,StartupInfo.lpTitle,*TitleLength);
        // ensure the title is NULL terminated
        if (*TitleLength == MAX_TITLE_LENGTH)
            Title[ (MAX_TITLE_LENGTH/sizeof(WCHAR)) - 1 ] = L'\0';
    }

    if (StartupInfo.dwFlags & STARTF_USESHOWWINDOW) {
        ConsoleInfo->wShowWindow = StartupInfo.wShowWindow;
    }
    if (StartupInfo.dwFlags & STARTF_USEFILLATTRIBUTE) {
        ConsoleInfo->wFillAttribute = (WORD)StartupInfo.dwFillAttribute;
    }
    if (StartupInfo.dwFlags & STARTF_USECOUNTCHARS) {
        ConsoleInfo->dwScreenBufferSize.X = (WORD)(StartupInfo.dwXCountChars);
        ConsoleInfo->dwScreenBufferSize.Y = (WORD)(StartupInfo.dwYCountChars);
    }
    if (StartupInfo.dwFlags & STARTF_USESIZE) {
        ConsoleInfo->dwWindowSize.X = (WORD)(StartupInfo.dwXSize);
        ConsoleInfo->dwWindowSize.Y = (WORD)(StartupInfo.dwYSize);
    }
    if (StartupInfo.dwFlags & STARTF_USEPOSITION) {
        ConsoleInfo->dwWindowOrigin.X = (WORD)(StartupInfo.dwX);
        ConsoleInfo->dwWindowOrigin.Y = (WORD)(StartupInfo.dwY);
    }

    //
    // Grab information passed on lpReserved line...
    //

    if (StartupInfo.lpReserved != 0) {

        //
        // the program manager has an icon for the exe.  store the
        // index in the iIconId field.
        //

        ConsoleInfo->iIconId = ParseReserved(StartupInfo.lpReserved, L"dde.");

        //
        // The new "Chicago" way of doing things is to pass the hotkey in the
        // hStdInput field and set the STARTF_USEHOTKEY flag.  So, if this is
        // specified, we get the hotkey from there instead
        //

        if (StartupInfo.dwFlags & STARTF_USEHOTKEY) {
            ConsoleInfo->dwHotKey = HandleToUlong(StartupInfo.hStdInput);
        } else {
            ConsoleInfo->dwHotKey = ParseReserved(StartupInfo.lpReserved, L"hotkey.");
        }
    }

}

VOID
SetUpHandles(
    IN PCONSOLE_INFO ConsoleInfo
    )

/*++

    This routine sets up the console and std* handles for the process.

Parameters:

    ConsoleInfo - pointer to structure containing handles.

Return Value:

    none.

--*/

{
    if (ConsoleInfo->dwStartupFlags & STARTF_USEHOTKEY) {
        NtCurrentPeb()->ProcessParameters->WindowFlags &= ~STARTF_USEHOTKEY;
    }

    if (ConsoleInfo->dwStartupFlags & STARTF_HASSHELLDATA) {
        NtCurrentPeb()->ProcessParameters->WindowFlags &= ~STARTF_HASSHELLDATA;
    }

    SET_CONSOLE_HANDLE(ConsoleInfo->ConsoleHandle);

    if (!(ConsoleInfo->dwStartupFlags & STARTF_USESTDHANDLES)) {
        SetStdHandle(STD_INPUT_HANDLE,ConsoleInfo->StdIn);
        SetStdHandle(STD_OUTPUT_HANDLE,ConsoleInfo->StdOut);
        SetStdHandle(STD_ERROR_HANDLE,ConsoleInfo->StdErr);
    }
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
GetConsoleLangId(
    OUT LANGID *lpLangId
    )

/*++

Parameters:

    lpLangId - Supplies a pointer to a LANGID in which to store the Language ID.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_LANGID_MSG a = &m.u.GetConsoleLangId;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetLangId
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpLangId = a->LangId;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            return FALSE;
        }
        return TRUE;
    } else {
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

VOID
SetTEBLangID(
    VOID
    )

/*++

    Sets the Language Id in the TEB to Far East if code page CP are
    Japanese/Korean/Chinese.  This is done in order for FormatMessage
    to display any Far East character when cmd is running in its code page.
    All messages displayed in non-FE code page will be displayed in English.

--*/

{
    LANGID LangId;

    if (GetConsoleLangId(&LangId)) {
        SetThreadLocale( MAKELCID(LangId, SORT_DEFAULT) );
    }
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
ConnectConsoleInternal(IN PWSTR pObjectDirectory,
                       IN OUT PCONSOLE_API_CONNECTINFO pConnectInfo,
                       OUT PBOOLEAN pServerProcess
                      )
/*++

Routine Description:

    Helper function for establishing a connection with the console server.
    Waits for the server to signal completion.

Arguments:

    pObjectDirectory -  Supplies a null terminated string that is the same
        as the value of the ObjectDirectory= argument passed to the CSRSS
        program.

    pConnectInfo - Supplies and recieves the connection information.

    pServerProcess - Recieves TRUE if this is a server process.

Return Value:

    TRUE - Success

    FALSE - An error occured.

--*/
{

   NTSTATUS Status;
   ULONG ConnectionInformationLength = sizeof(CONSOLE_API_CONNECTINFO);

   Status = CsrClientConnectToServer( pObjectDirectory,
                                      CONSRV_SERVERDLL_INDEX,
                                      pConnectInfo,
                                      &ConnectionInformationLength,
                                      pServerProcess
                                    );

   if (!NT_SUCCESS( Status )) {
       return FALSE;
   }

   //
   // we return success although no console api can be called because
   // loading shouldn't fail.  we'll fail the api calls later.
   //

   if (*pServerProcess) {
       return TRUE;
   }


   //
   // if this is not a console app, return success - nothing else to do.
   //

   if (!pConnectInfo->ConsoleApp) {
       return TRUE;
   }

   //
   // wait for initialization to complete.  we have to use the NT
   // wait because the heap hasn't been initialized yet.
   //

   Status = NtWaitForMultipleObjects(NUMBER_OF_INITIALIZATION_EVENTS,
                                        pConnectInfo->ConsoleInfo.InitEvents,
                                        WaitAny,
                                        FALSE,
                                        NULL
                                        );

   if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
   }

   NtClose(pConnectInfo->ConsoleInfo.InitEvents[INITIALIZATION_SUCCEEDED]);
   NtClose(pConnectInfo->ConsoleInfo.InitEvents[INITIALIZATION_FAILED]);
   if (Status != INITIALIZATION_SUCCEEDED) {
       SET_CONSOLE_HANDLE(NULL);
       return FALSE;
   }

   return TRUE;
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOLEAN
ConDllInitialize(
    IN ULONG Reason,
    IN PWSTR pObjectDirectory OPTIONAL
    )

/*++

Routine Description:

    This function implements console dll initialization.

Arguments:

    Reason - DLL_PROCESS_ATTACH, DLL_THREAD_ATTACH, etc.

    pObjectDiretory - Session directory name; only valid/required when
                      Reason == DLL_PROCESS_ATTACH.

Return Value:

    STATUS_SUCCESS

--*/

{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL bStatus;
    BOOLEAN ServerProcess;

    //
    // if we're attaching the DLL, we need to connect to the server.
    // if no console exists, we also need to create it and set up stdin,
    // stdout, and stderr.
    //

    if (Reason == DLL_PROCESS_ATTACH) {
        CONSOLE_API_CONNECTINFO ConnectionInformation;

        //
        // Remember in the connect information if this app is a console
        // app. need to actually connect to the console server for windowed
        // apps so that we know NOT to do any special work during
        // ConsoleClientDisconnectRoutine(). Store ConsoleApp info in the
        // CSR managed per-process data.
        //

        Status = RtlInitializeCriticalSection(&DllLock);
        if (!NT_SUCCESS(Status)) {
            return FALSE;
        }

        ConnectionInformation.CtrlRoutine = CtrlRoutine;
        ConnectionInformation.PropRoutine = PropRoutine;
#if defined(FE_SB)
#if defined(FE_IME)
        ConnectionInformation.ConsoleIMERoutine = ConsoleIMERoutine;
#endif // FE_IME
#endif // FE_SB

        ConnectionInformation.WindowVisible = TRUE;
        ConnectionInformation.ConsoleApp = ConsoleApp();
        if (GET_CONSOLE_HANDLE == (HANDLE)CONSOLE_DETACHED_PROCESS) {
            SET_CONSOLE_HANDLE(NULL);
            ConnectionInformation.ConsoleApp = FALSE;
        } else if (GET_CONSOLE_HANDLE == (HANDLE)CONSOLE_NEW_CONSOLE) {
            SET_CONSOLE_HANDLE(NULL);
        } else if (GET_CONSOLE_HANDLE == (HANDLE)CONSOLE_CREATE_NO_WINDOW) {
            SET_CONSOLE_HANDLE(NULL);
            ConnectionInformation.WindowVisible = FALSE;
        }
        if (!ConnectionInformation.ConsoleApp) {
            SET_CONSOLE_HANDLE(NULL);
        }
        ConnectionInformation.ConsoleInfo.ConsoleHandle = GET_CONSOLE_HANDLE;

        //
        // if no console exists, pass parameters for console creation
        //

        if (GET_CONSOLE_HANDLE == NULL && ConnectionInformation.ConsoleApp) {
            SetUpConsoleInfo(TRUE,
                             &ConnectionInformation.TitleLength,
                             ConnectionInformation.Title,
                             &ConnectionInformation.DesktopLength,
                             &ConnectionInformation.Desktop,
                             &ConnectionInformation.ConsoleInfo);
        } else {
            ConnectionInformation.TitleLength = 0;
            ConnectionInformation.DesktopLength = 0;
        }

        if (ConnectionInformation.ConsoleApp) {
            InitExeName();
            ConnectionInformation.CurDirLength = sizeof(ConnectionInformation.CurDir);
            ConnectionInformation.AppNameLength = sizeof(ConnectionInformation.AppName);
            SetUpAppName(&ConnectionInformation.CurDirLength,
                         ConnectionInformation.CurDir,
                         &ConnectionInformation.AppNameLength,
                         ConnectionInformation.AppName);
        } else {
            ConnectionInformation.AppNameLength = 0;
            ConnectionInformation.CurDirLength = 0;
        }

        //
        // initialize ctrl handling. This should work for all apps, so
        // initialize it before we check for ConsoleApp (which means the
        // console bit was set in the module header).
        //

        InitializeCtrlHandling();

        //
        // Connect to the server process
        //

        ASSERT(pObjectDirectory != NULL);
        bStatus = ConnectConsoleInternal(pObjectDirectory,
                                         &ConnectionInformation,
                                         &ServerProcess
                                         );

        if (!bStatus) {
            return FALSE;
        }

        //
        // we return success although no console api can be called because
        // loading shouldn't fail.  we'll fail the api calls later.
        //
        if (ServerProcess) {
            return TRUE;
        }

        //
        // if this is not a console app, return success - nothing else to do.
        //

        if (!ConnectionInformation.ConsoleApp) {
            return TRUE;
        }

        //
        // if console was just created, fill in peb values
        //

        if (GET_CONSOLE_HANDLE == NULL) {
            SetUpHandles(&ConnectionInformation.ConsoleInfo);
        }

        InputWaitHandle = ConnectionInformation.ConsoleInfo.InputWaitHandle;

        SetTEBLangID();

    } else if (Reason == DLL_THREAD_ATTACH) {
        if (ConsoleApp()) {
            SetTEBLangID();
        }
    }

    return TRUE;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
AllocConsoleInternal(IN LPWSTR lpTitle,
                     IN DWORD dwTitleLength,
                     IN LPWSTR lpDesktop,
                     IN DWORD dwDesktopLength,
                     IN LPWSTR lpCurDir,
                     IN DWORD dwCurDirLength,
                     IN LPWSTR lpAppName,
                     IN DWORD dwAppNameLength,
                     IN LPTHREAD_START_ROUTINE CtrlRoutine,
                     IN LPTHREAD_START_ROUTINE PropRoutine,
                     IN OUT PCONSOLE_INFO pConsoleInfo
                     )
/*++

Routine Description:

   Marshels the parameters for the ConsolepAlloc command.

Arguments:

   See the CONSOLE_ALLOC_MSG structure and AllocConsole.

Return Value:

    TRUE - Success

    FALSE - An error occured.

--*/
{
   CONSOLE_API_MSG m;
   PCONSOLE_ALLOC_MSG a = &m.u.AllocConsole;
   PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
   BOOL bStatus = FALSE;
   NTSTATUS Status;

   try {

        a->CtrlRoutine = CtrlRoutine;
        a->PropRoutine = PropRoutine;

        // Allocate 4 extra pointer sizes to compensate for any alignment done
        // by CsrCaptureMessageBuffer.

        CaptureBuffer = CsrAllocateCaptureBuffer( 5,
                                                  dwTitleLength + dwDesktopLength + dwCurDirLength +
                                                  dwAppNameLength + sizeof( CONSOLE_INFO ) + (4 * sizeof(PVOID))
                                                 );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            bStatus = FALSE;
            leave;
        }

        // Allocate the CONSOLE_INFO first so that it is aligned on a pointer
        // boundry.  This is necessary since NtWaitForMultipleObject expects
        // its arguments aligned on a handle boundry.

        CsrCaptureMessageBuffer( CaptureBuffer,
                                 pConsoleInfo,
                                 sizeof( CONSOLE_INFO ),
                                 (PVOID *) &a->ConsoleInfo
                               );

        a->TitleLength = dwTitleLength;
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpTitle,
                                 dwTitleLength,
                                 (PVOID *) &a->Title
                               );

        a->DesktopLength = dwDesktopLength;
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpDesktop,
                                 dwDesktopLength,
                                 (PVOID *) &a->Desktop
                               );

        a->CurDirLength = dwCurDirLength;
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpCurDir,
                                 dwCurDirLength,
                                 (PVOID *) &a->CurDir
                               );

        a->AppNameLength = dwAppNameLength;
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpAppName,
                                 dwAppNameLength,
                                 (PVOID *) &a->AppName
                               );

        //
        // Connect to the server process
        //

        CsrClientCallServer( (PCSR_API_MSG)&m,
                             CaptureBuffer,
                             CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                                  ConsolepAlloc
                                                ),
                             sizeof( *a )
                           );
        if (!NT_SUCCESS( m.ReturnValue )) {
            SET_LAST_NT_ERROR (m.ReturnValue);
            bStatus = FALSE;
            leave;
        }

        Status = NtWaitForMultipleObjects(NUMBER_OF_INITIALIZATION_EVENTS,
                                      a->ConsoleInfo->InitEvents,
                                      WaitAny,
                                      FALSE,
                                      NULL
                                      );
        if (!NT_SUCCESS(Status)) {
           SET_LAST_NT_ERROR(Status);
           bStatus = FALSE;
           leave;
        }

        //The handles to be closed are events, so NtClose works fine.
        NtClose(a->ConsoleInfo->InitEvents[INITIALIZATION_SUCCEEDED]);
        NtClose(a->ConsoleInfo->InitEvents[INITIALIZATION_FAILED]);
        if (Status != INITIALIZATION_SUCCEEDED) {
            SET_CONSOLE_HANDLE(NULL);
            bStatus = FALSE;
            leave;
        }
        RtlCopyMemory(pConsoleInfo, a->ConsoleInfo, sizeof(CONSOLE_INFO));
        bStatus = TRUE;
   }
   finally {
      if (CaptureBuffer) {
         CsrFreeCaptureBuffer( CaptureBuffer );
      }
   }

   return bStatus;
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
AllocConsole( VOID )

/*++

Routine Description:

    This API creates a console for the calling process.

Arguments:

    none.

Return Value:

    TRUE - function was successful.

--*/

{
    CONSOLE_INFO ConsoleInfo;
    STARTUPINFOW StartupInfo;
    WCHAR CurDir[MAX_PATH+1];
    WCHAR AppName[MAX_APP_NAME_LENGTH/2];
    BOOL Status = FALSE;

    DWORD dwTitleLength;
    DWORD dwDesktopLength;
    DWORD dwCurDirLength;
    DWORD dwAppNameLength;

    LockDll();
    try {
        if (GET_CONSOLE_HANDLE != NULL) {
            SetLastError(ERROR_ACCESS_DENIED);
            Status = FALSE;
            leave;
        }

        //
        // set up initialization parameters
        //

        SetUpConsoleInfo(FALSE,
                         &dwTitleLength,
                         NULL,
                         &dwDesktopLength,
                         NULL,
                         &ConsoleInfo);

        InitExeName();
        dwCurDirLength = sizeof(CurDir);
        dwAppNameLength = sizeof(AppName);
        SetUpAppName(&dwCurDirLength,
                     CurDir,
                     &dwAppNameLength,
                     AppName);

        GetStartupInfoW(&StartupInfo);

        if (StartupInfo.lpTitle == NULL) {
            StartupInfo.lpTitle = DEFAULT_WINDOW_TITLE;
        }
        dwTitleLength = (USHORT)((lstrlenW(StartupInfo.lpTitle)+1)*sizeof(WCHAR));
        dwTitleLength = (USHORT)(min(dwTitleLength,MAX_TITLE_LENGTH));
        if (StartupInfo.lpDesktop != NULL && *StartupInfo.lpDesktop != 0) {
            dwDesktopLength = (USHORT)((lstrlenW(StartupInfo.lpDesktop)+1)*sizeof(WCHAR));
            dwDesktopLength = (USHORT)(min(dwDesktopLength,MAX_TITLE_LENGTH));
        } else {
            dwDesktopLength = 0;
        }

        Status = AllocConsoleInternal(StartupInfo.lpTitle,
                                      dwTitleLength,
                                      StartupInfo.lpDesktop,
                                      dwDesktopLength,
                                      CurDir,
                                      dwCurDirLength,
                                      AppName,
                                      dwAppNameLength,
                                      CtrlRoutine,
                                      PropRoutine,
                                      &ConsoleInfo
                                      );

        if (!Status) {
           leave;
        }

        //
        // fill in peb values
        //

        SetUpHandles(&ConsoleInfo);

        //
        // create ctrl-c thread
        //

        InitializeCtrlHandling();

        InputWaitHandle = ConsoleInfo.InputWaitHandle;

        SetTEBLangID();

        Status = TRUE;

    } finally {
        UnlockDll();
    }

    return Status;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
FreeConsoleInternal(
     VOID
     )
/*++

Routine Description:

   Marshels the parameters for the ConsolepFree command.

Arguments:

   See the CONSOLE_FREE_MSG structure and FreeConsole.

Return Value:

    TRUE - Success

    FALSE - An error occured.

--*/
{

   CONSOLE_API_MSG m;
   PCONSOLE_FREE_MSG a = &m.u.FreeConsole;

   a->ConsoleHandle = GET_CONSOLE_HANDLE;

   //
   // Connect to the server process
   //

   CsrClientCallServer( (PCSR_API_MSG)&m,
                        NULL,
                        CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                             ConsolepFree
                                           ),
                        sizeof( *a )
                      );

   if (!NT_SUCCESS( m.ReturnValue )) {
      SET_LAST_NT_ERROR (m.ReturnValue);
      return FALSE;

   } else {

      SET_CONSOLE_HANDLE(NULL);
      return TRUE;
   }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
FreeConsole( VOID )

/*++

Routine Description:

    This API frees the calling process's console.

Arguments:

    none.

Return Value:

    TRUE - function was successful.

--*/

{
    BOOL Success=TRUE;

    LockDll();
    if (GET_CONSOLE_HANDLE == NULL) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        Success = FALSE;
    } else {

        Success = FreeConsoleInternal();

        if (Success) {
           CloseHandle(InputWaitHandle);
        }

    }
    UnlockDll();
    return Success;
}


DWORD
PropRoutine(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This thread is created when the user tries to change console
    properties from the system menu. It invokes the control panel
    applet.

Arguments:

    lpThreadParameter - not used.

Return Value:

    STATUS_SUCCESS - function was successful

--*/

{
    NTSTATUS Status;
    HANDLE hLibrary;
    APPLET_PROC pfnCplApplet;
    static BOOL fInPropRoutine = FALSE;

    //
    // Prevent the user from launching multiple applets attached
    // to a single console
    //

    if (fInPropRoutine) {
        if (lpThreadParameter) {
            CloseHandle((HANDLE)lpThreadParameter);
        }
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

    fInPropRoutine = TRUE;
    hLibrary = LoadLibraryW(L"CONSOLE.DLL");
    if (hLibrary != NULL) {
        pfnCplApplet = (APPLET_PROC)GetProcAddress(hLibrary, "CPlApplet");
        if (pfnCplApplet != NULL) {
            (*pfnCplApplet)((HWND)lpThreadParameter, CPL_INIT, 0, 0);
            (*pfnCplApplet)((HWND)lpThreadParameter, CPL_DBLCLK, 0, 0);
            (*pfnCplApplet)((HWND)lpThreadParameter, CPL_EXIT, 0, 0);
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }
        FreeLibrary(hLibrary);
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }
    fInPropRoutine = FALSE;

    return Status;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
AttachConsoleInternal(
    IN DWORD dwProcessId,
    IN LPTHREAD_START_ROUTINE CtrlRoutine,
    IN LPTHREAD_START_ROUTINE PropRoutine,
    IN OUT PCONSOLE_INFO pConsoleInfo
    )

/*++

Routine Description:

   Marshels the parameters for the ConsolepAttach command.

Arguments:

   See the CONSOLE_ATTACH_MSG structure and AttachConsole.

Return Value:

    TRUE - Success

    FALSE - An error occured.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_ATTACH_MSG a = &m.u.AttachConsole;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
    BOOL Status = FALSE;
    NTSTATUS St;

    try {

        a->ProcessId   = dwProcessId;
        a->CtrlRoutine = CtrlRoutine;
        a->PropRoutine = PropRoutine;

        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  sizeof( CONSOLE_INFO )
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            Status = FALSE;
            leave;
        }

        CsrCaptureMessageBuffer( CaptureBuffer,
                                 pConsoleInfo,
                                 sizeof( CONSOLE_INFO ),
                                 (PVOID *) &a->ConsoleInfo
                               );

        //
        // Connect to the server process
        //

        CsrClientCallServer( (PCSR_API_MSG)&m,
                             CaptureBuffer,
                             CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                                  ConsolepAttach
                                                ),
                             sizeof( *a )
                           );
        if (!NT_SUCCESS( m.ReturnValue )) {
            SET_LAST_NT_ERROR (m.ReturnValue);
            Status = FALSE;
            leave;
        }

        St = NtWaitForMultipleObjects(NUMBER_OF_INITIALIZATION_EVENTS,
                                      a->ConsoleInfo->InitEvents,
                                      WaitAny,
                                      FALSE,
                                      NULL
                                      );
        if (!NT_SUCCESS(St)) {
           SET_LAST_NT_ERROR(St);
           Status = FALSE;
           leave;
        }

        //The handles to be closed are events, so NtClose works fine.
        NtClose(a->ConsoleInfo->InitEvents[INITIALIZATION_SUCCEEDED]);
        NtClose(a->ConsoleInfo->InitEvents[INITIALIZATION_FAILED]);
        if (St != INITIALIZATION_SUCCEEDED) {
            SET_CONSOLE_HANDLE(NULL);
            Status = FALSE;
            leave;
        }
        RtlCopyMemory(pConsoleInfo, a->ConsoleInfo, sizeof(CONSOLE_INFO));
        Status = TRUE;
   }
   finally {
      if (CaptureBuffer) {
         CsrFreeCaptureBuffer( CaptureBuffer );
      }
   }

   return Status;
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
AttachConsole(
    IN DWORD dwProcessId
    )

/*++

Routine Description:

    This API attaches the calling process to the console of the given process.

Arguments:

    none.

Return Value:

    TRUE - function was successful.

--*/

{
    CONSOLE_INFO ConsoleInfo;
    DWORD dwTitleLength;
    DWORD dwDesktopLength;
    BOOL Status = FALSE;

    LockDll();
    try {

        //
        // bail if we already have a console
        //

        if (GET_CONSOLE_HANDLE != NULL) {
            SetLastError(ERROR_ACCESS_DENIED);
            Status = FALSE;
            leave;
        }

        //
        // set up initialization parameters
        //

        SetUpConsoleInfo(FALSE,
                         &dwTitleLength,
                         NULL,
                         &dwDesktopLength,
                         NULL,
                         &ConsoleInfo);

        //
        // attach to the console
        //

        Status = AttachConsoleInternal(dwProcessId,
                                       CtrlRoutine,
                                       PropRoutine,
                                       &ConsoleInfo
                                      );

        if (!Status) {
           leave;
        }

        //
        // fill in peb values
        //

        SetUpHandles(&ConsoleInfo);

        //
        // create ctrl-c thread
        //

        InitializeCtrlHandling();

        InputWaitHandle = ConsoleInfo.InputWaitHandle;

        SetTEBLangID();

        Status = TRUE;

    } finally {
        UnlockDll();
    }

    return Status;
}

#endif //!defined(BUILD_WOW64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\convdm.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    vdm.c

Abstract:

    This module contains the console API for MVDM.

Author:


Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

BOOL
APIENTRY
VDMConsoleOperation(
    DWORD  iFunction,
    LPVOID lpData
    )

/*++

Parameters:

    iFunction - Function Index.
    VDM_HIDE_WINDOW

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_VDM_MSG a = &m.u.VDMConsoleOperation;
    LPRECT lpRect;
    LPPOINT lpPoint;
    PBOOL lpBool;
    PCSR_CAPTURE_HEADER CaptureBuffer = NULL;
#if defined(FE_SB)
#if defined(i386)
    LPVDM_IOCTL_PARAM lpIoctlParam;
#endif
#endif // FE_SB

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->iFunction = iFunction;
    if (iFunction == VDM_CLIENT_TO_SCREEN ||
        iFunction == VDM_SCREEN_TO_CLIENT) {
        lpPoint = (LPPOINT)lpData;
        a->Point = *lpPoint;
    } else if (iFunction == VDM_FULLSCREEN_NOPAINT) {
        a->Bool = (lpData != NULL);
    }
#if defined(FE_SB)
    else if (iFunction == VDM_SET_VIDEO_MODE) {
        a->Bool = (lpData != NULL);
    }
#if defined(i386)
    else if (iFunction == VDM_SAVE_RESTORE_HW_STATE) {
        a->Bool = (lpData != NULL);
    }
    else if (iFunction == VDM_VIDEO_IOCTL) {
        lpIoctlParam = (LPVDM_IOCTL_PARAM)lpData;
        a->VDMIoctlParam = *lpIoctlParam;
        if (lpIoctlParam->lpvInBuffer != NULL) {
            if (lpIoctlParam->lpvOutBuffer != NULL || lpIoctlParam->cbInBuffer == 0) {
                SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                      lpIoctlParam->cbInBuffer
                                                    );
            if (CaptureBuffer == NULL) {
                SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            CsrCaptureMessageBuffer( CaptureBuffer,
                                     (PCHAR) lpIoctlParam->lpvInBuffer,
                                     lpIoctlParam->cbInBuffer,
                                     (PVOID *) &a->VDMIoctlParam.lpvInBuffer
                                   );
        }
        if (lpIoctlParam->lpvOutBuffer != NULL) {
            if (lpIoctlParam->cbOutBuffer == 0) {
                SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                      lpIoctlParam->cbOutBuffer
                                                    );
            if (CaptureBuffer == NULL) {
                SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
            CsrCaptureMessageBuffer( CaptureBuffer,
                                     (PCHAR) lpIoctlParam->lpvOutBuffer,
                                     lpIoctlParam->cbOutBuffer,
                                     (PVOID *) &a->VDMIoctlParam.lpvOutBuffer
                                   );
        }
    }
#endif // i386
#endif // FE_SB
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                         ConsolepVDMOperation
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        switch (iFunction) {
            case VDM_IS_ICONIC:
            case VDM_IS_HIDDEN:
                lpBool = (PBOOL)lpData;
                *lpBool = a->Bool;
                break;
            case VDM_CLIENT_RECT:
                lpRect = (LPRECT)lpData;
                *lpRect = a->Rect;
                break;
            case VDM_CLIENT_TO_SCREEN:
            case VDM_SCREEN_TO_CLIENT:
                *lpPoint = a->Point;
                break;
#if defined(FE_SB)
#if defined(i386)
            case VDM_VIDEO_IOCTL:
                if (lpIoctlParam->lpvOutBuffer != NULL) {
                    try {
                        RtlCopyMemory( lpIoctlParam->lpvOutBuffer,
                                       a->VDMIoctlParam.lpvOutBuffer,
                                       lpIoctlParam->cbOutBuffer );
                    } except( EXCEPTION_EXECUTE_HANDLER ) {
                        CsrFreeCaptureBuffer( CaptureBuffer );
                        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
                        return FALSE;
                    }
                }
                if (CaptureBuffer != NULL) {
                    CsrFreeCaptureBuffer( CaptureBuffer );
                }
                break;
#endif // i386
#endif // FE_SB
            default:
                break;
        }
        return TRUE;
    } else {
#if defined(FE_SB)
#if defined(i386)
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        }
#endif // i386
#endif // FE_SB
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\getset.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    getset.c

Abstract:

    This module contains the stubs for the console get/set API.

Author:

    Therese Stowell (thereses) 14-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
GetConsoleMode(
    IN HANDLE hConsoleHandle,
    OUT LPDWORD lpMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    lpMode - Supplies a pointer to a dword in which to store the mode.

        Input Mode Flags:

            ENABLE_LINE_INPUT - line oriented input is on.

            ENABLE_ECHO_INPUT - characters will be written to the screen as they are
                read.

            ENABLE_WINDOW_INPUT - the caller is windows-aware

        Output Mode Flags:

            ENABLE_LINE_OUTPUT - line oriented output is on.

            ENABLE_WRAP_AT_EOL_OUTPUT - the cursor will move to the
                beginning of the next line when the end of the row
                is reached.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_MODE_MSG a = &m.u.GetConsoleMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpMode = a->Mode;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

DWORD
WINAPI
GetNumberOfConsoleFonts(
    VOID
    )

/*++

Parameters:

    none.

Return Value:

    NON-NULL - Returns the number of fonts available.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETNUMBEROFFONTS_MSG a = &m.u.GetNumberOfConsoleFonts;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetNumberOfFonts
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->NumberOfFonts;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
WINAPI
GetNumberOfConsoleInputEvents(
    IN HANDLE hConsoleInput,
    OUT LPDWORD lpNumberOfEvents
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to console input.

    lpNumberOfEvents - Pointer to number of events in input buffer.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETNUMBEROFINPUTEVENTS_MSG a = &m.u.GetNumberOfConsoleInputEvents;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetNumberOfInputEvents
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpNumberOfEvents = a->ReadyEvents;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    }
    else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

COORD
WINAPI
GetLargestConsoleWindowSize(
    IN HANDLE hConsoleOutput
    )

/*++

    Returns largest window possible, given the current font.  The return value
    does not take the screen buffer size into account.

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

Return Value:

    The return value is the maximum window size in rows and columns.  A size
    of zero will be returned if an error occurs.  Extended error information
    can be retrieved by calling the GetLastError function.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETLARGESTWINDOWSIZE_MSG a = &m.u.GetLargestConsoleWindowSize;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetLargestWindowSize
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->Size;
    } else {
        COORD Dummy;
        Dummy.X = Dummy.Y = 0;
        SET_LAST_NT_ERROR (m.ReturnValue);
        return Dummy;
    }

}


BOOL
WINAPI
GetConsoleScreenBufferInfo(
    IN HANDLE hConsoleOutput,
    OUT PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpConsoleScreenBufferInfo - A pointer to a buffer to receive the
        requested information.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETSCREENBUFFERINFO_MSG a = &m.u.GetConsoleScreenBufferInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetScreenBufferInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            lpConsoleScreenBufferInfo->dwSize =              a->Size;
            lpConsoleScreenBufferInfo->dwCursorPosition =    a->CursorPosition;
            lpConsoleScreenBufferInfo->wAttributes =         a->Attributes;
            lpConsoleScreenBufferInfo->srWindow.Left = a->ScrollPosition.X;
            lpConsoleScreenBufferInfo->srWindow.Top = a->ScrollPosition.Y;
            lpConsoleScreenBufferInfo->srWindow.Right = lpConsoleScreenBufferInfo->srWindow.Left + a->CurrentWindowSize.X-1;
            lpConsoleScreenBufferInfo->srWindow.Bottom = lpConsoleScreenBufferInfo->srWindow.Top + a->CurrentWindowSize.Y-1;
            lpConsoleScreenBufferInfo->dwMaximumWindowSize = a->MaximumWindowSize;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
GetConsoleCursorInfo(
    IN HANDLE hConsoleOutput,
    OUT PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpConsoleCursorInfo - A pointer to a buffer to receive the
        requested information.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCURSORINFO_MSG a = &m.u.GetConsoleCursorInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCursorInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            lpConsoleCursorInfo->dwSize = a->CursorSize;
            lpConsoleCursorInfo->bVisible = a->Visible;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
GetConsoleSelectionInfo(
    OUT PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    )

/*++

Parameters:

    lpConsoleSelectionInfo - A pointer to a buffer to receive the
        requested information.

Return Value:

    TRUE - The operation was successful.

    FALSE - The operation failed. Extended error status is available
            using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETSELECTIONINFO_MSG a = &m.u.GetConsoleSelectionInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetSelectionInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpConsoleSelectionInfo = a->SelectionInfo;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }
}

BOOL
WINAPI
GetNumberOfConsoleMouseButtons(
    OUT LPDWORD lpNumberOfMouseButtons
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to console input.

    lpNumberOfMouseButtons - pointer to the number of mouse buttons

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETMOUSEINFO_MSG a = &m.u.GetConsoleMouseInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetMouseInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpNumberOfMouseButtons = a->NumButtons;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR (ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

DWORD
WINAPI
GetConsoleFontInfo(
    IN HANDLE hConsoleOutput,
    IN BOOL bMaximumWindow,
    IN DWORD nLength,
    OUT PCONSOLE_FONT_INFO lpConsoleFontInfo
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    bMaximumWindow - TRUE if caller wants available fonts for the maximum
        window size.  FALSE if caller wants available fonts for the current
        window size.

    nLength - Length of buffer in CONSOLE_FONT_INFOs.

    lpConsoleFontInfo - A pointer to a buffer to receive the
        requested information.

Return Value:

    NON-NULL - Returns the number of fonts returned in lpConsoleFontInfo.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETFONTINFO_MSG a = &m.u.GetConsoleFontInfo;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->MaximumWindow = (BOOLEAN) bMaximumWindow;
    a->NumFonts = nLength;

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              nLength * sizeof(CONSOLE_FONT_INFO)
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    CsrCaptureMessageBuffer( CaptureBuffer,
                             NULL,
                             nLength * sizeof(CONSOLE_FONT_INFO),
                             (PVOID *) &a->BufPtr
                           );

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetFontInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            RtlCopyMemory( lpConsoleFontInfo, a->BufPtr, a->NumFonts * sizeof(CONSOLE_FONT_INFO));
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            CsrFreeCaptureBuffer( CaptureBuffer );
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return 0;
        }
    }
    else {
        SET_LAST_NT_ERROR (m.ReturnValue);
    }
    CsrFreeCaptureBuffer( CaptureBuffer );
    return a->NumFonts;

}

COORD
WINAPI
GetConsoleFontSize(
    IN HANDLE hConsoleOutput,
    IN DWORD nFont
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    nFont - Supplies the index of the font to return the size of.

Return Value:

    The return value is the height and width of each character in the font.
    X field contains width. Y field contains height. Font size
    is expressed in pixels.  If both the x and y sizes are 0, the function
    was unsuccessful.  Extended error information can be retrieved by calling
    the GetLastError function.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETFONTSIZE_MSG a = &m.u.GetConsoleFontSize;
    COORD Dummy;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->FontIndex = nFont;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetFontSize
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->FontSize;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        Dummy.X = Dummy.Y = 0;
        return Dummy;
    }

}

BOOL
WINAPI
GetCurrentConsoleFont(
    IN HANDLE hConsoleOutput,
    IN BOOL bMaximumWindow,
    OUT PCONSOLE_FONT_INFO lpConsoleCurrentFont
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    bMaximumWindow - TRUE if caller wants current font for the maximum
        window size.  FALSE if caller wants current font for the current
        window size.

    lpConsoleCurrentFont - A pointer to a buffer to receive the
        requested information.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCURRENTFONT_MSG a = &m.u.GetCurrentConsoleFont;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->MaximumWindow = (BOOLEAN) bMaximumWindow;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCurrentFont
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            lpConsoleCurrentFont->dwFontSize = a->FontSize;
            lpConsoleCurrentFont->nFont = a->FontIndex;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleMode(
    IN HANDLE hConsoleHandle,
    IN DWORD dwMode
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    dwMode - Supplies mode.

        Input Mode Flags:

            ENABLE_LINE_INPUT - line oriented input is on.

            ENABLE_ECHO_INPUT - characters will be written to the screen as they are
                read.

            ENABLE_WINDOW_INPUT - the caller is windows-aware

        Output Mode Flags:

            ENABLE_LINE_OUTPUT - line oriented output is on.

            ENABLE_WRAP_AT_EOL_OUTPUT - the cursor will move to the
                beginning of the next line when the end of the row
                is reached.


Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_MODE_MSG a = &m.u.SetConsoleMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsoleHandle;
    a->Mode = dwMode;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetMode
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
GenerateConsoleCtrlEvent(
    IN DWORD dwCtrlEvent,
    IN DWORD dwProcessGroupId
    )

/*++

Parameters:

    dwCtrlEvent - Supplies event(s) to generate.

    dwProcessGroupId - Supplies id of process group to generate
                  event for.  Event will be generated in each
                  process with that id within the console.  If 0,
                  specified event will be generated in all processes
                  within the console.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CTRLEVENT_MSG a = &m.u.GenerateConsoleCtrlEvent;

    //
    // Check for valid Ctrl Events
    //

    if ((dwCtrlEvent != CTRL_C_EVENT) && (dwCtrlEvent != CTRL_BREAK_EVENT)) {
        SET_LAST_ERROR (ERROR_INVALID_PARAMETER);
        return(FALSE);
    }


    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->CtrlEvent = dwCtrlEvent;
    a->ProcessGroupId = dwProcessGroupId;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGenerateCtrlEvent
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleActiveScreenBuffer(
    IN HANDLE hConsoleOutput
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.  The screen
        buffer attached to this handle becomes the displayed screen buffer.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETACTIVESCREENBUFFER_MSG a = &m.u.SetConsoleActiveScreenBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetActiveScreenBuffer
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
WINAPI
FlushConsoleInputBuffer(
    IN HANDLE hConsoleInput
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to console input.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_FLUSHINPUTBUFFER_MSG a = &m.u.FlushConsoleInputBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepFlushInputBuffer
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
WINAPI
SetConsoleScreenBufferSize(
    IN HANDLE hConsoleOutput,
    IN COORD dwSize
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to console input.

    dwSize - New size of screen buffer in rows and columns

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETSCREENBUFFERSIZE_MSG a = &m.u.SetConsoleScreenBufferSize;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Size = dwSize;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetScreenBufferSize
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }


}

BOOL
WINAPI
SetConsoleCursorPosition(
    IN HANDLE hConsoleOutput,
    IN COORD dwCursorPosition
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    dwCursorPosition - Position of cursor in screen buffer

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETCURSORPOSITION_MSG a = &m.u.SetConsoleCursorPosition;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->CursorPosition = dwCursorPosition;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCursorPosition
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }


}

BOOL
WINAPI
SetConsoleCursorInfo(
    IN HANDLE hConsoleOutput,
    IN CONST CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpConsoleCursorOrigin - A pointer to a buffer containing the data
        to set.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETCURSORINFO_MSG a = &m.u.SetConsoleCursorInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    try {
        a->CursorSize = lpConsoleCursorInfo->dwSize;
        a->Visible = (BOOLEAN) lpConsoleCursorInfo->bVisible;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCursorInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleWindowInfo(
    IN HANDLE hConsoleOutput,
    IN BOOL bAbsolute,
    IN CONST SMALL_RECT *lpConsoleWindow
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpConsoleWindow - A pointer to a rectangle containing the new
        dimensions of the console window in screen buffer coordinates.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETWINDOWINFO_MSG a = &m.u.SetConsoleWindowInfo;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Absolute = bAbsolute;
    try {
        a->Window = *lpConsoleWindow;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetWindowInfo
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
APIENTRY
ScrollConsoleScreenBufferInternal(
    IN HANDLE hConsoleOutput,
    IN CONST SMALL_RECT *lpScrollRectangle,
    IN CONST SMALL_RECT *lpClipRectangle,
    IN COORD dwDestinationOrigin,
    IN CONST CHAR_INFO *lpFill,
    IN BOOLEAN Unicode
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    lpScrollRectangle - Pointer to region within screen buffer to move.

    lpClipRectangle -  Pointer to region within screen buffer that may be
        affected by this scroll.  This pointer may be NULL.

    dwDestinationOrigin - Upper left corner of new location of ScrollRectangle
        contents.

    lpFill - Pointer to structure containing new contents of ScrollRectangle region.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SCROLLSCREENBUFFER_MSG a = &m.u.ScrollConsoleScreenBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Unicode = Unicode;
    try {
        a->ScrollRectangle = *lpScrollRectangle;
        if (lpClipRectangle != NULL) {
            a->Clip = TRUE;
            a->ClipRectangle = *lpClipRectangle;
        }
        else {
            a->Clip = FALSE;
        }
        a->Fill = *lpFill;
        a->DestinationOrigin = dwDestinationOrigin;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepScrollScreenBuffer
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
ScrollConsoleScreenBufferA(
    HANDLE hConsoleOutput,
    CONST SMALL_RECT *lpScrollRectangle,
    CONST SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    CONST CHAR_INFO *lpFill
    )
{
    return ScrollConsoleScreenBufferInternal(hConsoleOutput,
                                      lpScrollRectangle,
                                      lpClipRectangle,
                                      dwDestinationOrigin,
                                      lpFill,
                                      FALSE);
}

BOOL
APIENTRY
ScrollConsoleScreenBufferW(
    HANDLE hConsoleOutput,
    CONST SMALL_RECT *lpScrollRectangle,
    CONST SMALL_RECT *lpClipRectangle,
    COORD dwDestinationOrigin,
    CONST CHAR_INFO *lpFill
    )
{
    return ScrollConsoleScreenBufferInternal(hConsoleOutput,
                                      lpScrollRectangle,
                                      lpClipRectangle,
                                      dwDestinationOrigin,
                                      lpFill,
                                      TRUE);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
SetConsoleTextAttribute(
    IN HANDLE hConsoleOutput,
    IN WORD wAttributes
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    wAttributes - Character display attributes.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETTEXTATTRIBUTE_MSG a = &m.u.SetConsoleTextAttribute;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Attributes = wAttributes;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetTextAttribute
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleFont(
    IN HANDLE hConsoleOutput,
    IN DWORD nFont
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to console output.

    nFont - Number of font to set as current font

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETFONT_MSG a = &m.u.SetConsoleFont;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->FontIndex = nFont;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetFont
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleIcon(
    IN HICON hIcon
    )

/*++

Parameters:

    hIcon - Supplies an icon handle.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETICON_MSG a = &m.u.SetConsoleIcon;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->hIcon = hIcon;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetIcon
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
SetConsoleMaximumWindowSize(
    HANDLE hConsoleOutput,
    COORD dwWindowSize
    )
{
    UNREFERENCED_PARAMETER(hConsoleOutput);
    UNREFERENCED_PARAMETER(dwWindowSize);

    return TRUE;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

UINT
WINAPI
GetConsoleCP( VOID )

/**++

Parameters:

    none

Return Value:

    The code page id of the current console.  a null return value
    indicates failure.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCP_MSG a = &m.u.GetConsoleCP;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Output = FALSE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCP
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->wCodePageID;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

BOOL
WINAPI
SetConsoleCP(
    IN UINT wCodePageID
    )

/**++

Parameters:

    wCodePageID - the code page is to set for the current console.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETCP_MSG a = &m.u.SetConsoleCP;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Output = FALSE;
    a->wCodePageID = wCodePageID;
#if defined(FE_SB)
    Status = NtCreateEvent(&(a->hEvent),
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           (BOOLEAN)FALSE
                           );
    if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
    }
#endif
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCP
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
#if defined(FE_SB)
        NTSTATUS Status;

        Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);
        NtClose(a->hEvent);
        if (Status != 0) {
            SET_LAST_NT_ERROR(Status);
            return FALSE;
        }
#endif
        return TRUE;
    } else {
#if defined(FE_SB)
        NtClose(a->hEvent);
#endif
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


UINT
WINAPI
GetConsoleOutputCP( VOID )

/**++

Parameters:

    none

Return Value:

    The code page id of the current console output.  a null return value
    indicates failure.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCP_MSG a = &m.u.GetConsoleCP;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Output = TRUE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetCP
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->wCodePageID;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

NTSTATUS
APIENTRY
SetConsoleOutputCPInternal(
    IN UINT wCodePageID
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_SETCP_MSG a = &m.u.SetConsoleCP;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Output = TRUE;
    a->wCodePageID = wCodePageID;
#if defined(FE_SB)
    a->hEvent = NULL;
#endif

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCP
                                            ),
                         sizeof( *a )
                       );

    return m.ReturnValue;
}

#endif //!defined(BUILD_WOW6432)


#if !defined(BUILD_WOW64)

BOOL
WINAPI
SetConsoleOutputCP(
    IN UINT wCodePageID
    )

/**++

Parameters:

    wCodePageID - the code page is to set for the current console output.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{

    NTSTATUS Status;

    Status = SetConsoleOutputCPInternal(wCodePageID);

    if(NT_SUCCESS(Status)) {
        SetTEBLangID();
        return TRUE;
    }
    else {
        SET_LAST_NT_ERROR (Status);
        return FALSE;
    }
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
GetConsoleKeyboardLayoutNameWorker(
    OUT LPSTR pszLayout,
    IN BOOL bAnsi)

/**++

Parameters:

    pszLayout  - address of buffer of least 9 characters
    bAnsi      - TRUE  want ANSI (8-bit) chars
                 FALSE want Unicode (16-bit) chars

Return Value:

    TRUE  - success
    FALSE - failure

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETKEYBOARDLAYOUTNAME_MSG a = &m.u.GetKeyboardLayoutName;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->bAnsi = bAnsi;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetKeyboardLayoutName
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        if (bAnsi) {
           strncpy(pszLayout, a->achLayout, 9);
        } else {
           wcsncpy((LPWSTR)pszLayout, a->awchLayout, 9);
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


#endif //!defined(BUILD_WOW6432)


#if !defined(BUILD_WOW64)

BOOL
GetConsoleKeyboardLayoutNameA(
    LPSTR pszLayout)
{
    return GetConsoleKeyboardLayoutNameWorker(pszLayout, TRUE);
}

BOOL
GetConsoleKeyboardLayoutNameW(
    LPWSTR pwszLayout)
{
    return GetConsoleKeyboardLayoutNameWorker((LPSTR)pwszLayout, FALSE);
}

#endif // !defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

HWND
APIENTRY
GetConsoleWindow(
    VOID)
{

    CONSOLE_API_MSG m;
    PCONSOLE_GETCONSOLEWINDOW_MSG a = &m.u.GetConsoleWindow;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetConsoleWindow
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->hwnd;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return NULL;
    }

}

DWORD
APIENTRY
GetConsoleProcessList(
    OUT LPDWORD lpdwProcessList,
    IN DWORD dwProcessCount)
{
    CONSOLE_API_MSG m;
    PCONSOLE_GETCONSOLEPROCESSLIST_MSG a = &m.u.GetConsoleProcessList;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    if (dwProcessCount == 0 || lpdwProcessList == NULL) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return 0;
    }

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->dwProcessCount = dwProcessCount;

    CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                              dwProcessCount * sizeof(DWORD)
                                            );
    if (CaptureBuffer == NULL) {
        SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    CsrCaptureMessageBuffer( CaptureBuffer,
                             NULL,
                             dwProcessCount * sizeof(DWORD),
                             (PVOID *) &a->lpdwProcessList
                           );
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetConsoleProcessList,
                                            ),
                         sizeof( *a )
                       );

    if (NT_SUCCESS(m.ReturnValue)) {
        if (dwProcessCount >= a->dwProcessCount) {
            try {
                RtlCopyMemory(lpdwProcessList, a->lpdwProcessList, a->dwProcessCount * sizeof(DWORD));
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                CsrFreeCaptureBuffer( CaptureBuffer );
                SET_LAST_ERROR(ERROR_INVALID_ACCESS);
                return 0;
            }
        }
    } else {
        CsrFreeCaptureBuffer( CaptureBuffer );
        SET_LAST_NT_ERROR (m.ReturnValue);
        return 0;
    }

    CsrFreeCaptureBuffer( CaptureBuffer );

    return a->dwProcessCount;
}

#endif // !defined(BUILD_WOW6432)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\ntwow64c.h ===
/*++                 

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ntwow64c.h

Abstract:
    
    Helper functions inplemented in wow64.

Author:

    21-Sept-1998 BarryBo

Revision History:

--*/

HANDLE
Wow64GetConsoleHandle(
    VOID
    );

VOID
Wow64SetConsoleHandle(
    HANDLE hHandle
    );

VOID
Wow64SetLastError(
    DWORD dwError
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\ctrlc.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    ctrlc.c

Abstract:

    This module implements ctrl-c handling

Author:

    Therese Stowell (thereses) 1-Mar-1991

Revision History:   

--*/

#include "precomp.h"
#pragma hdrstop

#if !defined(BUILD_WOW64)

#define LIST_INCREMENT 2    // amount to grow handler list
#define INITIAL_LIST_SIZE 1 // initial length of handler list

PHANDLER_ROUTINE SingleHandler[INITIAL_LIST_SIZE]; // initial handler list
ULONG HandlerListLength;            // used length of handler list
ULONG AllocatedHandlerListLength;   // allocated length of handler list
PHANDLER_ROUTINE *HandlerList;      // pointer to handler list

#define NUMBER_OF_CTRL_EVENTS 7     // number of ctrl events
#define SYSTEM_CLOSE_EVENT 4

#define IGNORE_CTRL_C   0x01

BOOL LastConsoleEventActive;


BOOL
DefaultHandler(
    IN ULONG CtrlType
    )

/*++

    This is the default ctrl handler.

Parameters:

    CtrlType - type of ctrl event (ctrl-c, ctrl-break).

Return Value:

    none.

--*/

{
    ExitProcess((DWORD)CONTROL_C_EXIT);
    return TRUE;
    UNREFERENCED_PARAMETER(CtrlType);
}

NTSTATUS
InitializeCtrlHandling( VOID )

/*++

    This routine initializes ctrl handling.  It is called by AllocConsole
    and the dll initialization code.

Parameters:

    none.

Return Value:

    none.

--*/

{
    AllocatedHandlerListLength = HandlerListLength = INITIAL_LIST_SIZE;
    HandlerList = SingleHandler;
    SingleHandler[0] = DefaultHandler;
    return STATUS_SUCCESS;
}

DWORD
CtrlRoutine(
    IN LPVOID lpThreadParameter
    )

/*++

Routine Description:

    This thread is created when ctrl-c or ctrl-break is entered,
    or when close is selected.  it calls the appropriate handlers.

Arguments:

    lpThreadParameter - what type of event happened.

Return Value:

    STATUS_SUCCESS

--*/

{
    ULONG i;
    ULONG EventNumber,OriginalEventNumber;
    DWORD fNoExit;
    DWORD dwExitCode;
    EXCEPTION_RECORD ExceptionRecord;

    SetThreadPriority(NtCurrentThread(), THREAD_PRIORITY_HIGHEST);
    OriginalEventNumber = EventNumber = PtrToUlong(lpThreadParameter);

    //
    // If this bit is set, it means we don't want to cause this process
    // to exit itself if it is a logoff or shutdown event.
    //
    fNoExit = 0x80000000 & EventNumber;
    EventNumber &= ~0x80000000;

    //
    // the ctrl_close event is set when the user selects the window
    // close option from the system menu, or EndTask, or Settings-Terminate.
    // the system close event is used when another ctrl-thread times out.
    //

    switch (EventNumber) {
    default:
        ASSERT (EventNumber < NUMBER_OF_CTRL_EVENTS);
        if (EventNumber >= NUMBER_OF_CTRL_EVENTS)
            return (DWORD)STATUS_UNSUCCESSFUL;
        break;

    case CTRL_C_EVENT:
    case CTRL_BREAK_EVENT:
        //
        // If the process is being debugged, give the debugger
        // a shot. If the debugger handles the exception, then
        // go back and wait.
        //

        if (!IsDebuggerPresent())
            break;

        if ( EventNumber == CTRL_C_EVENT ) {
            ExceptionRecord.ExceptionCode = DBG_CONTROL_C;
            }
        else {
            ExceptionRecord.ExceptionCode = DBG_CONTROL_BREAK;
            }
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionRecord = NULL;
        ExceptionRecord.ExceptionAddress = (PVOID)DefaultHandler;
        ExceptionRecord.NumberParameters = 0;

        try {
            RtlRaiseException(&ExceptionRecord);
        } except (EXCEPTION_EXECUTE_HANDLER) {
            LockDll();
            try {
                if (EventNumber != CTRL_C_EVENT ||
                        NtCurrentPeb()->ProcessParameters->ConsoleFlags != IGNORE_CTRL_C) {
                    for (i=HandlerListLength;i>0;i--) {
                        if ((HandlerList[i-1])(EventNumber)) {
                            break;
                        }
                    }
                }
            } finally {
                UnlockDll();
            }
        }
        ExitThread(0);
        break;

    case SYSTEM_CLOSE_EVENT:
        ExitProcess((DWORD)CONTROL_C_EXIT);
        break;

    case SYSTEM_ROOT_CONSOLE_EVENT:
        if (!LastConsoleEventActive)
            ExitThread(0);
        break;

    case CTRL_CLOSE_EVENT:
    case CTRL_LOGOFF_EVENT:
    case CTRL_SHUTDOWN_EVENT:
        //if (LastConsoleEventActive)
            //EventNumber = SYSTEM_ROOT_CONSOLE_EVENT;
        break;
    }

    LockDll();
    dwExitCode = 0;
    try {
        if (EventNumber != CTRL_C_EVENT ||
                NtCurrentPeb()->ProcessParameters->ConsoleFlags != IGNORE_CTRL_C) {
            for (i=HandlerListLength;i>0;i--) {

                //
                // Don't call the last handler (the default one which calls
                // ExitProcess() if this process isn't supposed to exit (system
                // process are not supposed to exit because of shutdown or
                // logoff event notification).
                //

                if ((i-1) == 0 && fNoExit) {
                    if (EventNumber == CTRL_LOGOFF_EVENT ||
                        EventNumber == CTRL_SHUTDOWN_EVENT) {
                        break;
                    }
                }

                if ((HandlerList[i-1])(EventNumber)) {
                    switch (EventNumber) {
                    case CTRL_CLOSE_EVENT:
                    case CTRL_LOGOFF_EVENT:
                    case CTRL_SHUTDOWN_EVENT:
                    case SYSTEM_ROOT_CONSOLE_EVENT:
                        dwExitCode = OriginalEventNumber;
                        break;
                    }
                    break;
                }
            }
        }
    } finally {
        UnlockDll();
    }
    ExitThread(dwExitCode);
    return STATUS_SUCCESS;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

VOID
APIENTRY
SetLastConsoleEventActiveInternal( VOID )

/*++

Routine Description:

    Sends a ConsolepNotifyLastClose command to the server.

Arguments:

    none.

Return Value:

    None.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_NOTIFYLASTCLOSE_MSG a = &m.u.SetLastConsoleEventActive;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepNotifyLastClose
                                            ),
                         sizeof( *a )
                       );
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

VOID
APIENTRY
SetLastConsoleEventActive( VOID )
// private api
{

    LastConsoleEventActive = TRUE;
    SetLastConsoleEventActiveInternal();
}

BOOL
SetCtrlHandler(
    IN PHANDLER_ROUTINE HandlerRoutine
    )

/*++

Routine Description:

    This routine adds a ctrl handler to the process's list.

Arguments:

    HandlerRoutine - pointer to ctrl handler.

Return Value:

    TRUE - success.

--*/

{
    PHANDLER_ROUTINE *NewHandlerList;

    //
    // NULL handler routine is not stored in table. It is
    // used to temporarily inhibit ^C event handling
    //

    if ( !HandlerRoutine ) {
        NtCurrentPeb()->ProcessParameters->ConsoleFlags = IGNORE_CTRL_C;
        return TRUE;
        }

    if (HandlerListLength == AllocatedHandlerListLength) {

        //
        // grow list
        //

        NewHandlerList = (PHANDLER_ROUTINE *) RtlAllocateHeap( RtlProcessHeap(), 0,
                                                 sizeof(PHANDLER_ROUTINE) * (HandlerListLength + LIST_INCREMENT));
        if (!NewHandlerList) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }

        //
        // copy list
        //

        RtlCopyMemory(NewHandlerList,HandlerList,sizeof(PHANDLER_ROUTINE) * HandlerListLength);

        if (HandlerList != SingleHandler) {

            //
            // free old list
            //

            RtlFreeHeap(RtlProcessHeap(), 0, HandlerList);
        }
        HandlerList = NewHandlerList;
        AllocatedHandlerListLength += LIST_INCREMENT;
    }
    ASSERT (HandlerListLength < AllocatedHandlerListLength);

    HandlerList[HandlerListLength] = HandlerRoutine;
    HandlerListLength++;
    return TRUE;
}

BOOL
RemoveCtrlHandler(
    IN PHANDLER_ROUTINE HandlerRoutine
    )

/*++

Routine Description:

    This routine removes a ctrl handler from the process's list.

Arguments:

    HandlerRoutine - pointer to ctrl handler.

Return Value:

    TRUE - success.

--*/

{
    ULONG i;

    //
    // NULL handler routine is not stored in table. It is
    // used to temporarily inhibit ^C event handling. Removing
    // this handler allows normal processing to occur
    //

    if ( !HandlerRoutine ) {
        NtCurrentPeb()->ProcessParameters->ConsoleFlags = 0;
        return TRUE;
        }

    for (i=0;i<HandlerListLength;i++) {
        if (*(HandlerList+i) == HandlerRoutine) {
            if (i < (HandlerListLength-1)) {
                memmove(&HandlerList[i],&HandlerList[i+1],sizeof(PHANDLER_ROUTINE) * (HandlerListLength - i - 1));
            }
            HandlerListLength -= 1;
            return TRUE;
        }
    }
    SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
    return FALSE;
}

BOOL
APIENTRY
SetConsoleCtrlHandler(
    IN PHANDLER_ROUTINE HandlerRoutine,
    IN BOOL Add       // add or delete
    )

/*++

Routine Description:

    This routine adds or removes a ctrl handler from the process's list.

Arguments:

    HandlerRoutine - pointer to ctrl handler.

    Add - if TRUE, add handler.  else remove.

Return Value:

    TRUE - success.

--*/

{
    BOOL Success;

    LockDll();
    if (Add) {
        Success = SetCtrlHandler(HandlerRoutine);
    }
    else {
        Success = RemoveCtrlHandler(HandlerRoutine);
    }
    UnlockDll();
    return Success;
}

#endif //!defined(BUILD_WOW64)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\iostubs.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    iostubs.c

Abstract:

    This module contains the stubs for the console I/O API.

Author:

    Therese Stowell (thereses) 14-Nov-1990

Revision History:
    
--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
GetConsoleInput(
    IN HANDLE hConsoleInput,
    OUT PINPUT_RECORD lpBuffer,
    IN DWORD nLength,
    OUT LPDWORD lpNumberOfEventsRead,
    IN USHORT wFlags,
    IN BOOLEAN Unicode
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        read.  The handle must have been created with GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsRead - Pointer to number of events read.

    wFlags - Flags that control how data is read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_GETCONSOLEINPUT_MSG a = &m.u.GetConsoleInput;

    //
    // If it's not a well formed handle, don't bother going to the server.
    //

    if (!CONSOLE_HANDLE(hConsoleInput)) {
        try {
            *lpNumberOfEventsRead = 0;
            SET_LAST_ERROR(ERROR_INVALID_HANDLE);
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        }
        return FALSE;
    }

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    a->NumRecords = nLength;
    a->Flags = wFlags;
    a->Unicode = Unicode;

    //
    // for speed in the case where we're only reading a few records, we have
    // a buffer in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    if (nLength > INPUT_RECORD_BUFFER_SIZE) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  nLength * sizeof(INPUT_RECORD)
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 NULL,
                                 nLength * sizeof(INPUT_RECORD),
                                 (PVOID *) &a->BufPtr
                               );

    } else {
        a->BufPtr = a->Record;
        CaptureBuffer = NULL;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetConsoleInput
                                            ),
                         sizeof( *a )
                       );

    try {
        if (NT_SUCCESS( m.ReturnValue )) {
            *lpNumberOfEventsRead = a->NumRecords;
            RtlCopyMemory(lpBuffer, a->BufPtr, a->NumRecords * sizeof(INPUT_RECORD));
        }
        else {
            *lpNumberOfEventsRead = 0;
            SET_LAST_NT_ERROR(m.ReturnValue);
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        }
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }

    return NT_SUCCESS(m.ReturnValue);

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
PeekConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    )

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           CONSOLE_READ_NOREMOVE | CONSOLE_READ_NOWAIT,
                           FALSE);
}

BOOL
APIENTRY
PeekConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        read.  The handle must have been created with GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsRead - Pointer to number of events read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           CONSOLE_READ_NOREMOVE | CONSOLE_READ_NOWAIT,
                           TRUE);
}

BOOL
APIENTRY
ReadConsoleInputA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    )

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           0,
                           FALSE);
}

BOOL
APIENTRY
ReadConsoleInputW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        read.  The handle must have been created with GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsRead - Pointer to number of events read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           0,
                           TRUE);
}

BOOL
APIENTRY
ReadConsoleInputExA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead,
    USHORT wFlags
    )

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           wFlags,
                           FALSE);
}

BOOL
APIENTRY
ReadConsoleInputExW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsRead,
    USHORT wFlags
    )

/*++

Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        read.  The handle must have been created with GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsRead - Pointer to number of events read.

    wFlags - Flags that control how data is read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return GetConsoleInput(hConsoleInput,
                           lpBuffer,
                           nLength,
                           lpNumberOfEventsRead,
                           wFlags,
                           TRUE);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
WriteConsoleInputInternal(
    IN HANDLE hConsoleInput,
    IN CONST INPUT_RECORD *lpBuffer,
    IN DWORD nLength,
    OUT LPDWORD lpNumberOfEventsWritten,
    IN BOOLEAN Unicode,
    IN BOOLEAN Append
    )

/*++
Parameters:

    hConsoleInput - Supplies an open handle to CONIN$ that is to be
        written.  The handle must have been created with GENERIC_WRITE access.

    lpBuffer - Supplies the address of a buffer containing the input records
        to write to the input buffer.

    nLength - Supplies the length of lpBuffer in INPUT_RECORDs.

    lpNumberOfEventsWritten - Pointer to number of events written.

    Unicode - TRUE if characters are unicode

    Append - TRUE if append to end of input stream.  if FALSE, write to the
    beginning of the input stream (used by VDM).

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_WRITECONSOLEINPUT_MSG a = &m.u.WriteConsoleInput;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    a->NumRecords = nLength;
    a->Unicode = Unicode;
    a->Append = Append;

    //
    // for speed in the case where we're only writing a few records, we have
    // a buffer in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    if (nLength > INPUT_RECORD_BUFFER_SIZE) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  nLength * sizeof(INPUT_RECORD)
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 (PCHAR) lpBuffer,
                                 nLength * sizeof(INPUT_RECORD),
                                 (PVOID *) &a->BufPtr
                               );

    } else {
        a->BufPtr = a->Record;
        CaptureBuffer = NULL;
        try {
            RtlCopyMemory(a->BufPtr, lpBuffer, nLength * sizeof(INPUT_RECORD));
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepWriteConsoleInput
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    try {
        *lpNumberOfEventsWritten = a->NumRecords;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
WriteConsoleInputA(
    HANDLE hConsoleInput,
    CONST INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    )
{
    return WriteConsoleInputInternal(hConsoleInput,lpBuffer,nLength,lpNumberOfEventsWritten,FALSE,TRUE);
}

BOOL
APIENTRY
WriteConsoleInputW(
    HANDLE hConsoleInput,
    CONST INPUT_RECORD *lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    )
{
    return WriteConsoleInputInternal(hConsoleInput,lpBuffer,nLength,lpNumberOfEventsWritten,TRUE,TRUE);
}


#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

VOID
CopyRectangle(
    IN CONST CHAR_INFO *Source,
    IN COORD SourceSize,
    IN PSMALL_RECT SourceRect,
    OUT PCHAR_INFO Target,
    IN COORD TargetSize,
    IN COORD TargetPoint
    )

/*++

Routine Description:

    This routine copies a rectangular region, doing any necessary clipping.

Arguments:

    Source - pointer to source buffer

    SourceSize - dimensions of source buffer

    SourceRect - rectangle in source buffer to copy

    Target - pointer to target buffer

    TargetSize - dimensions of target buffer

    TargetPoint - upper left coordinates of target rectangle

Return Value:


--*/

{

#define SCREEN_BUFFER_POINTER(BASE,X,Y,XSIZE,CELLSIZE) ((ULONG_PTR)BASE + ((XSIZE * (Y)) + (X)) * (ULONG)CELLSIZE)

    CONST CHAR_INFO *SourcePtr;
    PCHAR_INFO TargetPtr;
    SHORT i,j;
    SHORT XSize,YSize;
    BOOLEAN WholeSource,WholeTarget;

    XSize = (SHORT)CONSOLE_RECT_SIZE_X(SourceRect);
    YSize = (SHORT)CONSOLE_RECT_SIZE_Y(SourceRect);

    // do clipping.  we only clip for target, not source.

    if (XSize > (SHORT)(TargetSize.X - TargetPoint.X + 1)) {
        XSize = (SHORT)(TargetSize.X - TargetPoint.X + 1);
    }
    if (YSize > (SHORT)(TargetSize.Y - TargetPoint.Y + 1)) {
        YSize = (SHORT)(TargetSize.Y - TargetPoint.Y + 1);
    }

    WholeSource = WholeTarget = FALSE;
    if (XSize == SourceSize.X) {
        ASSERT (SourceRect->Left == 0);
        if (SourceRect->Top == 0) {
            SourcePtr = Source;
        }
        else {
            SourcePtr = (PCHAR_INFO) SCREEN_BUFFER_POINTER(Source,
                                                           SourceRect->Left,
                                                           SourceRect->Top,
                                                           SourceSize.X,
                                                           sizeof(CHAR_INFO));
        }
        WholeSource = TRUE;
    }
    if (XSize == TargetSize.X) {
        ASSERT (TargetPoint.X == 0);
        if (TargetPoint.Y == 0) {
            TargetPtr = Target;
        }
        else {
            TargetPtr = (PCHAR_INFO) SCREEN_BUFFER_POINTER(Target,
                                                           TargetPoint.X,
                                                           TargetPoint.Y,
                                                           TargetSize.X,
                                                           sizeof(CHAR_INFO));
        }
        WholeTarget = TRUE;
    }
    if (WholeSource && WholeTarget) {
        memmove(TargetPtr,SourcePtr,XSize*YSize*sizeof(CHAR_INFO));
        return;
    }

    for (i=0;i<YSize;i++) {
        if (!WholeTarget) {
            TargetPtr = (PCHAR_INFO) SCREEN_BUFFER_POINTER(Target,
                                                           TargetPoint.X,
                                                           TargetPoint.Y+i,
                                                           TargetSize.X,
                                                           sizeof(CHAR_INFO));
        }
        if (!WholeSource) {
            SourcePtr = (PCHAR_INFO) SCREEN_BUFFER_POINTER(Source,
                                                           SourceRect->Left,
                                                           SourceRect->Top+i,
                                                           SourceSize.X,
                                                           sizeof(CHAR_INFO));
        }
        for (j=0;j<XSize;j++,SourcePtr++,TargetPtr++) {
            *TargetPtr = *SourcePtr;
        }
    }
}

BOOL
APIENTRY
ReadConsoleOutputInternal(
    IN HANDLE hConsoleOutput,
    OUT PCHAR_INFO lpBuffer,
    IN COORD dwBufferSize,
    IN COORD dwBufferCoord,
    IN OUT PSMALL_RECT lpReadRegion,
    IN BOOLEAN Unicode
    )

/*++
Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be read.  The handle must have been created with
        GENERIC_READ access.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the screen buffer.  This pointer is treated as the origin of
        a two dimensional array of size dwBufferSize.

    dwBufferSize - size of lpBuffer

    dwBufferCoord - coordinates of upper left point in buffer to receive
        read data.

    lpReadRegion - Supplies on input the address of a structure indicating the
        rectangle within the screen buffer to read from.  The fields in
        the structure are column and row coordinates.  On output, the fields
        contain the actual region read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_READCONSOLEOUTPUT_MSG a = &m.u.ReadConsoleOutput;
    ULONG NumChars;
    COORD SourceSize;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Unicode = Unicode;

    //
    // clip region to read based on caller's buffer size
    //

    SourceSize.X = (SHORT)CONSOLE_RECT_SIZE_X(lpReadRegion);
    if (SourceSize.X > dwBufferSize.X-dwBufferCoord.X)
        SourceSize.X = dwBufferSize.X-dwBufferCoord.X;
    SourceSize.Y = (SHORT)CONSOLE_RECT_SIZE_Y(lpReadRegion);
    if (SourceSize.Y > dwBufferSize.Y-dwBufferCoord.Y)
        SourceSize.Y = dwBufferSize.Y-dwBufferCoord.Y;

    a->CharRegion.Left = lpReadRegion->Left;
    a->CharRegion.Right = (SHORT)(lpReadRegion->Left + SourceSize.X - 1);
    a->CharRegion.Top  = lpReadRegion->Top;
    a->CharRegion.Bottom = (SHORT)(lpReadRegion->Top + SourceSize.Y - 1);

    //
    // for speed in the case where we're only reading one character, we have
    // a buffer in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    NumChars = SourceSize.X * SourceSize.Y;
    if (NumChars > 1) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  NumChars * sizeof(CHAR_INFO)
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 NULL,
                                 NumChars * sizeof(CHAR_INFO),
                                 (PVOID *) &a->BufPtr
                               );
    }
    else {
        CaptureBuffer = NULL;
        a->BufPtr = &a->Char;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepReadConsoleOutput
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            SMALL_RECT SourceRect;

            SourceRect.Left = a->CharRegion.Left - lpReadRegion->Left;
            SourceRect.Top = a->CharRegion.Top - lpReadRegion->Top;
            SourceRect.Right = SourceRect.Left +
                    (a->CharRegion.Right - a->CharRegion.Left);
            SourceRect.Bottom =  SourceRect.Top +
                    (a->CharRegion.Bottom - a->CharRegion.Top);
            dwBufferCoord.X += SourceRect.Left;
            dwBufferCoord.Y += SourceRect.Top;
            CopyRectangle(a->BufPtr,
                          SourceSize,
                          &SourceRect,
                          lpBuffer,
                          dwBufferSize,
                          dwBufferCoord
                         );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            if (CaptureBuffer != NULL) {
                CsrFreeCaptureBuffer( CaptureBuffer );
            }
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
    }
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    *lpReadRegion = a->CharRegion;
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
ReadConsoleOutputW(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    )
{
    return ReadConsoleOutputInternal(hConsoleOutput,
                                     lpBuffer,
                                     dwBufferSize,
                                     dwBufferCoord,
                                     lpReadRegion,
                                     TRUE
                                    );
}

BOOL
APIENTRY
ReadConsoleOutputA(
    HANDLE hConsoleOutput,
    PCHAR_INFO lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpReadRegion
    )
{
    return ReadConsoleOutputInternal(hConsoleOutput,
                                     lpBuffer,
                                     dwBufferSize,
                                     dwBufferCoord,
                                     lpReadRegion,
                                     FALSE
                                    );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
WriteConsoleOutputInternal(
    IN HANDLE hConsoleOutput,
    IN CONST CHAR_INFO *lpBuffer,
    IN COORD dwBufferSize,
    IN COORD dwBufferCoord,
    IN PSMALL_RECT lpWriteRegion,
    IN BOOLEAN Unicode
    )

/*++
Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    lpBuffer - Supplies the address of a buffer containing the data to write
        to the screen buffer.  This buffer is treated as a two dimensional
        array.

    dwBufferSize - size of lpBuffer

    dwBufferCoord - coordinates of upper left point in buffer to write data
        from.

    lpWriteRegion - Supplies on input the address of a structure indicating the
        rectangle within the screen buffer to write to.  The fields in
        the structure are column and row coordinates.  On output, the fields
        contain the actual region written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.
--*/

{

    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_WRITECONSOLEOUTPUT_MSG a = &m.u.WriteConsoleOutput;
    ULONG NumChars;
    COORD SourceSize;
    COORD TargetPoint;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Unicode = Unicode;

    //
    // clip region to write based on caller's buffer size
    //

    SourceSize.X = (SHORT)CONSOLE_RECT_SIZE_X(lpWriteRegion);
    if (SourceSize.X > dwBufferSize.X-dwBufferCoord.X)
        SourceSize.X = dwBufferSize.X-dwBufferCoord.X;
    SourceSize.Y = (SHORT)CONSOLE_RECT_SIZE_Y(lpWriteRegion);
    if (SourceSize.Y > dwBufferSize.Y-dwBufferCoord.Y)
        SourceSize.Y = dwBufferSize.Y-dwBufferCoord.Y;

    if (SourceSize.X <= 0 ||
        SourceSize.Y <= 0) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    a->CharRegion.Left = lpWriteRegion->Left;
    a->CharRegion.Right = (SHORT)(lpWriteRegion->Left + SourceSize.X - 1);
    a->CharRegion.Top  = lpWriteRegion->Top;
    a->CharRegion.Bottom = (SHORT)(lpWriteRegion->Top + SourceSize.Y - 1);

    //
    // for speed in the case where we're only writing one character, we have
    // a buffer in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    NumChars = SourceSize.X * SourceSize.Y;
    if (NumChars > 1) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  NumChars * sizeof(CHAR_INFO)
                                                );
        if (CaptureBuffer == NULL) {
            a->ReadVM=TRUE;
            a->BufPtr = RtlAllocateHeap( RtlProcessHeap(), 0, NumChars * sizeof(CHAR_INFO));
            if (a->BufPtr == NULL) {
                SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
                return FALSE;
            }
        } else {
            a->ReadVM=FALSE;
            CsrCaptureMessageBuffer( CaptureBuffer,
                                     NULL,
                                     NumChars * sizeof(CHAR_INFO),
                                     (PVOID *) &a->BufPtr
                                   );
        }
    }
    else {
        a->ReadVM=FALSE;
        CaptureBuffer = NULL;
        a->BufPtr = &a->Char;
    }
    try {
        SMALL_RECT SourceRect;

        SourceRect.Left = dwBufferCoord.X;
        SourceRect.Top = dwBufferCoord.Y;
        SourceRect.Right = (SHORT)(dwBufferCoord.X+SourceSize.X-1);
        SourceRect.Bottom = (SHORT)(dwBufferCoord.Y+SourceSize.Y-1);
        TargetPoint.X = 0;
        TargetPoint.Y = 0;
        CopyRectangle(lpBuffer,
                      dwBufferSize,
                      &SourceRect,
                      a->BufPtr,
                      SourceSize,
                      TargetPoint
                     );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        } else if (a->ReadVM) {
            // a->BufPtr was allocated with RtlAllocateHeap.
            RtlFreeHeap( RtlProcessHeap(), 0, a->BufPtr);  
        }
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepWriteConsoleOutput
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    } else if (a->ReadVM) {
        // a->BufPtr was allocated with RtlAllocateHeap.
        RtlFreeHeap(RtlProcessHeap(),0,a->BufPtr);       
    }
    *lpWriteRegion = a->CharRegion;
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
WriteConsoleOutputW(
    HANDLE hConsoleOutput,
    CONST CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    )
{
    return WriteConsoleOutputInternal(hConsoleOutput,
                                      lpBuffer,
                                      dwBufferSize,
                                      dwBufferCoord,
                                      lpWriteRegion,
                                      TRUE
                                      );
}

BOOL
APIENTRY
WriteConsoleOutputA(
    HANDLE hConsoleOutput,
    CONST CHAR_INFO *lpBuffer,
    COORD dwBufferSize,
    COORD dwBufferCoord,
    PSMALL_RECT lpWriteRegion
    )
{
    return WriteConsoleOutputInternal(hConsoleOutput,
                                      lpBuffer,
                                      dwBufferSize,
                                      dwBufferCoord,
                                      lpWriteRegion,
                                      FALSE
                                      );
}

#endif //defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
ReadConsoleOutputString(
    IN HANDLE hConsoleOutput,
    OUT LPVOID lpString,
    IN DWORD nLength,
    IN DWORD nSize,
    IN DWORD fFlags,
    IN COORD dwReadCoord,
    OUT LPDWORD lpNumberOfElementsRead
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be read.  The handle must have been created with
        GENERIC_READ access.

    lpString - Supplies the address of a buffer to receive the character
        or attribute string read from the screen buffer.

    nLength - Size of lpCharacter buffer in elements.

    nSize - Size of element to read.

    fFlags - flag indicating what type of string to copy

    dwReadCoord - Screen buffer coordinates of string to read.
        read data.

    lpNumberOfElementsRead - Pointer to number of events read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_READCONSOLEOUTPUTSTRING_MSG a = &m.u.ReadConsoleOutputString;
    ULONG DataLength;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->NumRecords = nLength;
    a->StringType = fFlags;
    a->ReadCoord = dwReadCoord;

    DataLength = nLength*nSize;

    //
    // for speed in the case where the string is small, we have a buffer
    // in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    if (DataLength > sizeof(a->String)) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  DataLength
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 NULL,
                                 DataLength,
                                 (PVOID *) &a->BufPtr
                               );

    }
    else {
        a->BufPtr = a->String;
        CaptureBuffer = NULL;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepReadConsoleOutputString
                                            ),
                         sizeof( *a )
                       );

    try {
       *lpNumberOfElementsRead = a->NumRecords;
        if (NT_SUCCESS( m.ReturnValue )) {
            RtlCopyMemory(lpString, a->BufPtr, a->NumRecords * nSize);
        }
        else {
            SET_LAST_NT_ERROR(m.ReturnValue);
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        }
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    return NT_SUCCESS(m.ReturnValue);
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
ReadConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be read.  The handle must have been created with
        GENERIC_READ access.

    lpCharacter - Supplies the address of a buffer to receive the character
        string read from the screen buffer.

    nLength - Size of lpCharacter buffer in characters.

    dwReadCoord - Screen buffer coordinates of string to read.
        read data.

    lpNumberOfCharsRead - Pointer to number of chars read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return ReadConsoleOutputString(hConsoleOutput,
                                   lpCharacter,
                                   nLength,
                                   sizeof(CHAR),
                                   CONSOLE_ASCII,
                                   dwReadCoord,
                                   lpNumberOfCharsRead
                                  );
}


BOOL
APIENTRY
ReadConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPWSTR lpCharacter,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfCharsRead
    )

{
    return ReadConsoleOutputString(hConsoleOutput,
                                   lpCharacter,
                                   nLength,
                                   sizeof(WCHAR),
                                   CONSOLE_REAL_UNICODE,
                                   dwReadCoord,
                                   lpNumberOfCharsRead
                                  );
}


BOOL
APIENTRY
ReadConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    LPWORD lpAttribute,
    DWORD nLength,
    COORD dwReadCoord,
    LPDWORD lpNumberOfAttrsRead
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be read.  The handle must have been created with
        GENERIC_READ access.

    lpAttribute - Supplies the address of a buffer to receive the attribute
        string read from the screen buffer.

    nLength - Size of lpAttribute buffer in bytes.

    dwReadCoord - Screen buffer coordinates of string to read.
        read data.

    lpNumberOfAttrsRead - Pointer to number of attrs read.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return ReadConsoleOutputString(hConsoleOutput,
                                   lpAttribute,
                                   nLength,
                                   sizeof(WORD),
                                   CONSOLE_ATTRIBUTE,
                                   dwReadCoord,
                                   lpNumberOfAttrsRead
                                  );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
WriteConsoleOutputString(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpString,
    IN DWORD nLength,
    IN DWORD nSize,
    IN DWORD fFlags,
    IN COORD dwWriteCoord,
    OUT LPDWORD lpNumberOfElementsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    lpString - Supplies the address of a buffer containing the character
        or attribute string to write to the screen buffer.

    nLength - Length of string to write, in elements.

    nSize - Size of element to read.

    fFlags - flag indicating what type of string to copy

    dwWriteCoord - Screen buffer coordinates to write the string to.

    lpNumberOfElementsWritten - Pointer to number of elements written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{

    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_WRITECONSOLEOUTPUTSTRING_MSG a = &m.u.WriteConsoleOutputString;
    ULONG DataLength;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->NumRecords = nLength;
    a->StringType = fFlags;
    a->WriteCoord = dwWriteCoord;

    //
    // for speed in the case where the string is small, we have a buffer
    // in the msg we pass to the server. this means we don't have to
    // allocate a capture buffer.
    //

    DataLength = nLength*nSize;
    if (DataLength > sizeof(a->String)) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  DataLength
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 (PCHAR) lpString,
                                 DataLength,
                                 (PVOID *) &a->BufPtr
                               );
    }
    else {
        a->BufPtr = a->String;
        CaptureBuffer = NULL;

        try {
            RtlCopyMemory(a->BufPtr, lpString, DataLength);
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepWriteConsoleOutputString
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    try {
        *lpNumberOfElementsWritten = a->NumRecords;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
WriteConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    LPCSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    lpCharacter - Supplies the address of a buffer containing the character
        string to write to the screen buffer.

    nLength - Length of string to write, in characters.

    dwWriteCoord - Screen buffer coordinates to write the string to.

    lpNumberOfCharsWritten - Pointer to number of chars written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return WriteConsoleOutputString(hConsoleOutput,
                                    lpCharacter,
                                    nLength,
                                    sizeof(CHAR),
                                    CONSOLE_ASCII,
                                    dwWriteCoord,
                                    lpNumberOfCharsWritten
                                   );
}

BOOL
APIENTRY
WriteConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    LPCWSTR lpCharacter,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    )

{
    return WriteConsoleOutputString(hConsoleOutput,
                                    lpCharacter,
                                    nLength,
                                    sizeof(WCHAR),
                                    CONSOLE_REAL_UNICODE,
                                    dwWriteCoord,
                                    lpNumberOfCharsWritten
                                   );
}

BOOL
APIENTRY
WriteConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    CONST WORD *lpAttribute,
    DWORD nLength,
    COORD dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    lpAttribute - Supplies the address of a buffer containing the attribute
        string to write to the screen buffer.

    nLength - Length of string to write.

    dwWriteCoord - Screen buffer coordinates to write the string to.

    lpNumberOfAttrsWritten - Pointer to number of attrs written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return WriteConsoleOutputString(hConsoleOutput,
                                    lpAttribute,
                                    nLength,
                                    sizeof(WORD),
                                    CONSOLE_ATTRIBUTE,
                                    dwWriteCoord,
                                    lpNumberOfAttrsWritten
                                   );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
FillConsoleOutput(
    IN HANDLE hConsoleOutput,
    IN WORD   Element,
    IN DWORD  nLength,
    IN DWORD  fFlags,
    IN COORD  dwWriteCoord,
    OUT LPDWORD lpNumberOfElementsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    Element - The attribute or character to write.

    nLength - Number of times to write the element.

    fFlags - flag indicating what type of element to write.

    dwWriteCoord - Screen buffer coordinates to write the element to.

    lpNumberOfElementsWritten - Pointer to number of elements written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_FILLCONSOLEOUTPUT_MSG a = &m.u.FillConsoleOutput;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Length = nLength;
    a->ElementType = fFlags;
    a->Element = Element;
    a->WriteCoord = dwWriteCoord;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepFillConsoleOutput
                                            ),
                         sizeof( *a )
                       );
    try {
        *lpNumberOfElementsWritten = a->Length;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
FillConsoleOutputCharacterA(
    HANDLE hConsoleOutput,
    CHAR   cCharacter,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    cCharacter - Supplies the ASCII character to write to the screen buffer.

    nLength - Number of times to write the character.

    dwWriteCoord - Screen buffer coordinates to begin writing the character
        to.

    lpNumberOfCharsWritten - Pointer to number of chars written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return FillConsoleOutput(hConsoleOutput,
                             (USHORT) cCharacter,
                             nLength,
                             CONSOLE_ASCII,
                             dwWriteCoord,
                             lpNumberOfCharsWritten
                            );
}

BOOL
APIENTRY
FillConsoleOutputCharacterW(
    HANDLE hConsoleOutput,
    WCHAR   cCharacter,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfCharsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    cCharacter - Supplies the ASCII character to write to the screen buffer.

    nLength - Number of times to write the character.

    dwWriteCoord - Screen buffer coordinates to begin writing the character
        to.

    lpNumberOfCharsWritten - Pointer to number of chars written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return FillConsoleOutput(hConsoleOutput,
                             (USHORT) cCharacter,
                             nLength,
                             CONSOLE_REAL_UNICODE,
                             dwWriteCoord,
                             lpNumberOfCharsWritten
                            );
}

BOOL
APIENTRY
FillConsoleOutputAttribute(
    HANDLE hConsoleOutput,
    WORD   wAttribute,
    DWORD  nLength,
    COORD  dwWriteCoord,
    LPDWORD lpNumberOfAttrsWritten
    )

/*++

Parameters:

    hConsoleOutput - Supplies an open handle to the screen buffer (CONOUT$)
        that is to be written.  The handle must have been created with
        GENERIC_WRITE access.

    wAttribute - Supplies the attribute to write to the screen buffer.

    nLength - Number of times to write the attribute.

    dwWriteCoord - Screen buffer coordinates to begin writing the attribute
        to.

    lpNumberOfAttrsWritten - Pointer to number of attrs written.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.

--*/

{
    return FillConsoleOutput(hConsoleOutput,
                             wAttribute,
                             nLength,
                             CONSOLE_ATTRIBUTE,
                             dwWriteCoord,
                             lpNumberOfAttrsWritten
                            );
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

HANDLE
WINAPI
CreateConsoleScreenBuffer(
    IN DWORD dwDesiredAccess,
    IN DWORD dwShareMode,
    IN CONST SECURITY_ATTRIBUTES *lpSecurityAttributes,
    IN DWORD dwFlags,
    IN PVOID lpScreenBufferData OPTIONAL
    )
{
    CONSOLE_API_MSG m;
    PCONSOLE_CREATESCREENBUFFER_MSG a = &m.u.CreateConsoleScreenBuffer;
    PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsBufferInfo;
    PCSR_CAPTURE_HEADER CaptureBuffer=NULL;

    if (dwDesiredAccess & ~VALID_ACCESSES ||
        dwShareMode & ~VALID_SHARE_ACCESSES ||
        (dwFlags != CONSOLE_TEXTMODE_BUFFER &&
         dwFlags != CONSOLE_GRAPHICS_BUFFER)) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }
    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->DesiredAccess = dwDesiredAccess;
    if (ARGUMENT_PRESENT(lpSecurityAttributes)) {
        a->InheritHandle = lpSecurityAttributes->bInheritHandle;
    }
    else {
        a->InheritHandle = FALSE;
    }
    a->ShareMode = dwShareMode;
    a->Flags = dwFlags;
    if (dwFlags == CONSOLE_GRAPHICS_BUFFER) {
        if (a->InheritHandle || lpScreenBufferData == NULL) {
            SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }
        GraphicsBufferInfo = lpScreenBufferData;
        try {
            a->GraphicsBufferInfo = *GraphicsBufferInfo;
            CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                      a->GraphicsBufferInfo.dwBitMapInfoLength
                                                    );
            if (CaptureBuffer == NULL) {
                SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
                return INVALID_HANDLE_VALUE;
            }
            CsrCaptureMessageBuffer( CaptureBuffer,
                                     (PCHAR) GraphicsBufferInfo->lpBitMapInfo,
                                     a->GraphicsBufferInfo.dwBitMapInfoLength,
                                     (PVOID *) &a->GraphicsBufferInfo.lpBitMapInfo
                                   );

        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return INVALID_HANDLE_VALUE;
        }
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepCreateScreenBuffer
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    if (!NT_SUCCESS(m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return INVALID_HANDLE_VALUE;
    }
    else {
        if (dwFlags == CONSOLE_GRAPHICS_BUFFER) {
            try {
                GraphicsBufferInfo->hMutex = a->hMutex;
                GraphicsBufferInfo->lpBitMap = a->lpBitmap;
            } except( EXCEPTION_EXECUTE_HANDLER ) {
                SET_LAST_ERROR(ERROR_INVALID_ACCESS);
                return INVALID_HANDLE_VALUE;
            }
        }
        return a->Handle;
    }
}

BOOL
WINAPI
InvalidateConsoleDIBits(
    IN HANDLE hConsoleOutput,
    IN PSMALL_RECT lpRect
    )

/*++

Parameters:

    hConsoleHandle - Supplies a console input or output handle.

    lpRect - the region that needs to be updated to the screen.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.


--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_INVALIDATERECT_MSG a = &m.u.InvalidateConsoleBitmapRect;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    try {
        a->Rect = *lpRect;
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return ERROR_INVALID_ACCESS;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepInvalidateBitmapRect
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }
}

#endif //!defined(BUILD_WOW6432)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\precomp.h ===
#include "condll.h"
#include <windows.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "winbasep.h"
#include "winconp.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\private.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    private.c

Abstract:

    This file implements private APIs for Hardware Desktop Support.

Author:

    Therese Stowell (thereses) 12-13-1991

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop
#pragma hdrstop

#if !defined(BUILD_WOW64)

typedef HANDLE (*PCONVPALFUNC)(HANDLE);
PCONVPALFUNC pfnGdiConvertPalette;

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
WINAPI
SetConsoleCursor(
    IN HANDLE hConsoleOutput,
    IN HCURSOR hCursor
    )

/*++

Description:

    Sets the mouse pointer for the specified screen buffer.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    hCursor - win32 cursor handle, should be NULL to set the default
        cursor.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETCURSOR_MSG a = &m.u.SetConsoleCursor;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->CursorHandle = hCursor;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetCursor
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

int
WINAPI
ShowConsoleCursor(
    IN HANDLE hConsoleOutput,
    IN BOOL bShow
    )

/*++

Description:

    Sets the mouse pointer visibility counter.  If the counter is less than
    zero, the mouse pointer is not shown.

Parameters:

    hOutput - Supplies a console output handle.

    bShow - if TRUE, the display count is to be increased. if FALSE,
        decreased.

Return value:

    The return value specifies the new display count.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SHOWCURSOR_MSG a = &m.u.ShowConsoleCursor;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->bShow = bShow;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepShowCursor
                                            ),
                         sizeof( *a )
                       );
    return a->DisplayCount;

}

HMENU
APIENTRY
ConsoleMenuControl(
    IN HANDLE hConsoleOutput,
    IN UINT dwCommandIdLow,
    IN UINT dwCommandIdHigh
    )

/*++

Description:

    Sets the command id range for the current screen buffer and returns the
    menu handle.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwCommandIdLow - Specifies the lowest command id to store in the input buffer.

    dwCommandIdHigh - Specifies the highest command id to store in the input
        buffer.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_MENUCONTROL_MSG a = &m.u.ConsoleMenuControl;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->CommandIdLow =dwCommandIdLow;
    a->CommandIdHigh = dwCommandIdHigh;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepMenuControl
                                            ),
                         sizeof( *a )
                       );
    return a->hMenu;

}

BOOL
APIENTRY
SetConsolePaletteInternal(
    IN HANDLE hConsoleOutput,
    IN HPALETTE hPalette,
    IN UINT dwUsage
    )
{

    CONSOLE_API_MSG m;
    PCONSOLE_SETPALETTE_MSG a = &m.u.SetConsolePalette;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->hPalette = hPalette;
    a->dwUsage = dwUsage;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetPalette
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

BOOL
APIENTRY
SetConsoleDisplayMode(
    IN HANDLE hConsoleOutput,
    IN DWORD dwFlags,
    OUT PCOORD lpNewScreenBufferDimensions
    )

/*++

Description:

    This routine sets the console display mode for an output buffer.
    This API is only supported on x86 machines.  Frame buffer consoles
    are always windowed.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwFlags - Specifies the display mode. Options are:

        CONSOLE_FULLSCREEN_MODE - data is displayed fullscreen

        CONSOLE_WINDOWED_MODE - data is displayed in a window

    lpNewScreenBufferDimensions - On output, contains the new dimensions of
        the screen buffer.  The dimensions are in rows and columns for
        textmode screen buffers.
Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETDISPLAYMODE_MSG a = &m.u.SetConsoleDisplayMode;
    NTSTATUS Status;

#if !defined(_X86_)
    return FALSE;
#else

    Status = NtCreateEvent(&(a->hEvent),
                           EVENT_ALL_ACCESS,
                           NULL,
                           SynchronizationEvent,
                           (BOOLEAN)FALSE
                           );
    if (!NT_SUCCESS(Status)) {
       SET_LAST_NT_ERROR(Status);
       return FALSE;
    }

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->dwFlags = dwFlags;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetDisplayMode
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        NtClose(a->hEvent);
        return FALSE;

    }
    else {
             Status = NtWaitForSingleObject(a->hEvent, FALSE, NULL);
        NtClose(a->hEvent);

         if (Status != 0) {
            SET_LAST_NT_ERROR(Status);
            return FALSE;
         }
        try {
            *lpNewScreenBufferDimensions = a->ScreenBufferDimensions;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    }

#endif

}

BOOL
APIENTRY
RegisterConsoleVDM(
    IN DWORD dwRegisterFlags,
    IN HANDLE hStartHardwareEvent,
    IN HANDLE hEndHardwareEvent,
    IN HANDLE hErrorHardwareEvent,
    IN DWORD Reserved,
    OUT LPDWORD lpStateLength,
    OUT PVOID *lpState,
    IN LPWSTR lpVDMBufferSectionName,
    IN DWORD dwVDMBufferSectionNameLength,
    IN COORD VDMBufferSize OPTIONAL,
    OUT PVOID *lpVDMBuffer
    )

/*++

Description:

    This routine registers the VDM with the console.

Parameters:

    hStartHardwareEvent - the event the VDM waits on to be
        notified of gaining/losing control of the hardware.

    hEndHardwareEvent - the event the VDM sets when it is done
        saving/restoring the hardware.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    CONSOLE_API_MSG m;
    PCONSOLE_REGISTERVDM_MSG a = &m.u.RegisterConsoleVDM;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->RegisterFlags = dwRegisterFlags;
    if (dwRegisterFlags) {
        a->StartEvent = hStartHardwareEvent;
        a->EndEvent = hEndHardwareEvent;
        a->ErrorEvent = hErrorHardwareEvent;
        a->VDMBufferSectionNameLength = dwVDMBufferSectionNameLength;
        a->VDMBufferSize = VDMBufferSize;
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  dwVDMBufferSectionNameLength
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpVDMBufferSectionName,
                                 dwVDMBufferSectionNameLength,
                                 (PVOID *) &a->VDMBufferSectionName
                                   );
    } else {
        CaptureBuffer = NULL;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepRegisterVDM
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        if (dwRegisterFlags) {
            try {
                *lpStateLength = a->StateLength;
                *lpState = a->StateBuffer;
                *lpVDMBuffer = a->VDMBuffer;
            } except (EXCEPTION_EXECUTE_HANDLER) {
                SET_LAST_ERROR(ERROR_INVALID_ACCESS);
                return FALSE;
            }
        }
        return TRUE;
    }
}

BOOL
APIENTRY
GetConsoleHardwareState(
    IN HANDLE hConsoleOutput,
    OUT PCOORD lpResolution,
    OUT PCOORD lpFontSize
    )

/*++

Description:

    This routine returns the video resolution and font.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    lpResolution - Pointer to structure to store screen
        resolution in.  Resolution is returned in pixels.

    lpFontSize - Pointer to structure to store font size in.
        Font size is returned in pixels.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETHARDWARESTATE_MSG a = &m.u.GetConsoleHardwareState;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetHardwareState
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        try {
            *lpResolution = a->Resolution;
            *lpFontSize = a->FontSize;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    }

}

BOOL
APIENTRY
SetConsoleHardwareState(
    IN HANDLE hConsoleOutput,
    IN COORD dwResolution,
    IN COORD dwFontSize
    )

/*++

Description:

    This routine set the video resolution and font.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwResolution - Contains screen resolution to set.
        Resolution is returned in pixels.

    dwFontSize - Contains font size to set.
        Font size is returned in pixels.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETHARDWARESTATE_MSG a = &m.u.SetConsoleHardwareState;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;
    a->Resolution = dwResolution;
    a->FontSize = dwFontSize;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetHardwareState
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

BOOL
APIENTRY
GetConsoleDisplayMode(
    OUT LPDWORD lpModeFlags
    )

/*++

Description:

    This routine returns the display mode of the console.

Parameters:

    lpModeFlags - pointer to store display mode in.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETDISPLAYMODE_MSG a = &m.u.GetConsoleDisplayMode;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetDisplayMode
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        try {
            *lpModeFlags = a->ModeFlags;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    }

}

BOOL
APIENTRY
SetConsoleKeyShortcuts(
    IN BOOL bSet,
    IN BYTE bReserveKeys,
    IN LPAPPKEY lpAppKeys,
    IN DWORD dwNumAppKeys
    )

/*++

Description:

    Only one set of key shortcuts is valid per console.  Calling
    SetConsoleKeyShortcuts(set) overwrites any previous settings.
    SetConsoleKeyShortcuts(!set) removes any shortcuts.

Parameters:

    bSet - if TRUE, set shortcuts.  else remove shortcuts.

    bReserveKeys - byte containing reserve key info.

    lpAppKeys - pointer to application-defined shortcut keys.  can be null.

    dwNumAppKeys - number of app keys contained in lpAppKeys.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETKEYSHORTCUTS_MSG a = &m.u.SetConsoleKeyShortcuts;
    PCSR_CAPTURE_HEADER CaptureBuffer;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Set = bSet;
    a->ReserveKeys = bReserveKeys;
    if (lpAppKeys == NULL || dwNumAppKeys == 0) {
        a->NumAppKeys = 0;
        CaptureBuffer = NULL;
    } else {
        a->NumAppKeys = dwNumAppKeys;
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  dwNumAppKeys * sizeof(APPKEY)
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 lpAppKeys,
                                 dwNumAppKeys * sizeof(APPKEY),
                                 (PVOID *) &a->AppKeys
                               );
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetKeyShortcuts
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer)
        CsrFreeCaptureBuffer( CaptureBuffer );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

BOOL
APIENTRY
SetConsoleMenuClose(
    IN BOOL bEnable
    )

/*++

Description:

    This routine returns the display mode of the console.

Parameters:

    bEnable - if TRUE, close is enabled in the system menu.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETMENUCLOSE_MSG a = &m.u.SetConsoleMenuClose;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Enable = bEnable;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetMenuClose
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    else {
        return TRUE;
    }

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
SetConsolePalette(
    IN HANDLE hConsoleOutput,
    IN HPALETTE hPalette,
    IN UINT dwUsage
    )

/*++

Description:

    Sets the palette for the console screen buffer.

Parameters:

    hOutput - Supplies a console output handle.

    hPalette - Supplies a handle to the palette to set.

    dwUsage - Specifies use of the system palette.

        SYSPAL_NOSTATIC - System palette contains no static colors
                          except black and white.

        SYSPAL_STATIC -   System palette contains static colors
                          which will not change when an application
                          realizes its logical palette.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    HANDLE hmodGdi;
    UNICODE_STRING ModuleNameString;
    NTSTATUS Status;

    if ( !pfnGdiConvertPalette ) {
        RtlInitUnicodeString( &ModuleNameString, L"gdi32" );
        Status = LdrLoadDll( UNICODE_NULL, NULL, &ModuleNameString, &hmodGdi );
        if ( !NT_SUCCESS(Status) ) {
            SET_LAST_NT_ERROR(Status);
            return FALSE;
            }
        pfnGdiConvertPalette = (PCONVPALFUNC)GetProcAddress(hmodGdi, "GdiConvertPalette");
        if (pfnGdiConvertPalette == NULL) {
            SET_LAST_NT_ERROR(STATUS_PROCEDURE_NOT_FOUND);
            return FALSE;
            }

        }

    hPalette = (*pfnGdiConvertPalette)(hPalette);

    return SetConsolePaletteInternal(hConsoleOutput,
                                     hPalette,
                                     dwUsage);
}

BOOL
APIENTRY
WriteConsoleInputVDMA(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    )
{
    return WriteConsoleInputInternal(hConsoleInput,lpBuffer,nLength,lpNumberOfEventsWritten,FALSE,FALSE);
}

BOOL
APIENTRY
WriteConsoleInputVDMW(
    HANDLE hConsoleInput,
    PINPUT_RECORD lpBuffer,
    DWORD nLength,
    LPDWORD lpNumberOfEventsWritten
    )
{
    return WriteConsoleInputInternal(hConsoleInput,lpBuffer,nLength,lpNumberOfEventsWritten,TRUE,FALSE);
}

#endif //!defined(BUILD_WOW6432)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\conimep.h ===
// Copyright (c) 1985 - 1999, Microsoft Corporation

/*--------------------------------------------------------------------------*/
/*  Constants                                                               */
/*--------------------------------------------------------------------------*/

#if DBG==1
//#define DEBUG_MODE
//#define DEBUG_PRINT
//#define DEBUG_INFO
#endif


/*
 * Resource defines
 */
#define WINDOWMENU           1
#define ID_CONSOLEIME_ICON   2

/*
 * Menu ID's
 */
#define MM_ABOUT            8001
#define MM_EXIT                 8002
#define MM_ACCESS_VIOLATION     8003


/* String Table Defines */
#define errTitle        0
#define IDS_MENUNAME           12
#define IDS_APPNAME            13
#define IDS_CLASSNAME          14
#define IDS_TITLE              15

#define IDS_LAST               15       // Put New Strings Before this one




#ifdef DEBUG_PRINT
  #define DBGPRINT(_params_)  DbgPrint _params_
#else
  #define DBGPRINT(_params_)
#endif

#define CONSOLE_INITIAL_TABLE 10
#define CONSOLE_CONSOLE_TABLE_INCREMENT 5
#define HKL_INITIAL_TABLE 1
#define HKL_TABLE_INCREMENT 1

#define CVMAX            2048
#define NUMMAX           100
#define CMAX             160
#define MAXROW           1
#define MAXCOL           80
#define FIRSTROW         0
#define FIRSTCOL         0
#define LASTROW         (MAXROW-1)
#define LASTCOL         (MAXCOL-1)
#define TABSTOP          8
#define MAX_LISTCAND     32
#define MAX_CHARS_PER_LINE   10
#define MAX_COMP_STRING_LEN  10
#define DEFAULT_CAND_NUM_PER_PAGE 5
#define X_INDENT         10
#define Y_INDENT         10
#define DELIMITERWIDTH   3      // 1:xxx 2:xxx
#define DEFAULTCANDTABLE 100
#define DISPCHANGELIMIT  188
#define CODEDISPLEN      7      // '[F040] '
#define DEFAULT_TEMP_WIDTH 80

#define KEY_TOGGLED 0x01

#define MaxBufSize    256
#define KBDLAYOUT     TEXT("SYSTEM\\CurrentControlSet\\Control\\Keyboard Layouts")
#define KBDLAYOUTTEXT TEXT("layout text")
#define KBDSEPALATER  TEXT("\\")

#define LANG_ID_TAIWAN  MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_TRADITIONAL) // 0x0404
#define LANG_ID_JAPAN   MAKELANGID(LANG_JAPANESE,SUBLANG_DEFAULT)            // 0x0411
#define LANG_ID_KOREA   MAKELANGID(LANG_KOREAN,SUBLANG_DEFAULT)              // 0x0412
#define LANG_ID_PRC     MAKELANGID(LANG_CHINESE,SUBLANG_CHINESE_SIMPLIFIED)  // 0x0804

typedef struct _HKL_TABLE {
    HKL hkl;
    DWORD dwConversion;
} HKL_TABLE, *LPHKL_TABLE;

typedef struct _CONSOLE_TABLE {
    /*
     * Console Information
     */
    HANDLE hConsole;             // Handle of Console
    HWND hWndCon;               // Window handle of Console
    COORD ScreenBufferSize;      // Screen Buffer Size of Console
    /*
     * IMM/IME Basic Information
     */
    HKL hklActive;
    HIMC hIMC_Current;           // Handle of Input Context for current
    HIMC hIMC_Original;          // Handle of Input Context for original
    BOOL fOpen;                 // Open flag
    DWORD dwConversion;         // Conversion mode
    DWORD dwSentence;           // Sentence mode
    WORD ConsoleCP;
    WORD ConsoleOutputCP;
    WCHAR LayoutName[MaxBufSize];
    WCHAR GuideLine[10];
    /*
     * IMM/IME Composition String Information
     */
    BOOL fInComposition;         // Flag of in compositionning.
    LPCONIME_UICOMPMESSAGE lpCompStrMem;
    WORD  CompAttrColor[8];
    /*
     * IMM/IME Candidate Information
     */
    BOOL fInCandidate;           // Flag of in candidating
    LPCANDIDATELIST lpCandListMem[ MAX_LISTCAND ];
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    DWORD CandListMemAllocSize[ MAX_LISTCAND ];
    DWORD CandOff;
    DWORD CandMax;
    LPDWORD CandSep;
    DWORD CandSepAllocSize;
    BOOL fNestCandidate;
    DWORD ImmGetProperty;
    /*
     * misc
     */
    BOOL Enable;
    BOOL LateRemove;
    INT  hklListMax;
    LPHKL_TABLE lphklList;
#ifdef DEBUG_MODE
    DWORD ImeCandNum;
    DWORD CandidateCount;
    HWND hListCand[ MAX_LISTCAND ];
    WCHAR DispBuf[CMAX];
#endif
} CONSOLE_TABLE, *PCONSOLE_TABLE;

#define IPHK_HOTKEY                     0x0001          //
#define IPHK_PROCESSBYIME               0x0002          //
#define IPHK_CHECKCTRL                  0x0004          //

#define IS_IME_KBDLAYOUT(hkl) ((HIWORD(HandleToUlong(hkl)) & 0xf000) == 0xe000)
#define HKL_TO_LANGID(hkl)    (LOWORD(HandleToUlong(hkl)))

DWORD
ImmCallImeConsoleIME(
    HWND   hWnd,
    UINT   Message,
    WPARAM wParam,
    LPARAM lParam,
    PUINT  puVKey
    );

BOOL
ImmTranslateMessage(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
    );

BOOL
ImmSetActiveContextConsoleIME(
    HWND   hWnd,
    BOOL   fFlag
    );

#define UNICODE_BACKSPACE ((WCHAR)0x08)
#define UNICODE_BACKSPACE2 ((WCHAR)0x25d8)
#define UNICODE_CARRIAGERETURN ((WCHAR)0x0d)
#define UNICODE_LINEFEED ((WCHAR)0x0a)
#define UNICODE_BELL ((WCHAR)0x07)
#define UNICODE_TAB ((WCHAR)0x09)
#define UNICODE_SPACE ((WCHAR)0x20)
#define UNICODE_ZERO ((WCHAR)'0')
#define UNICODE_SLASH ((WCHAR)'/')
#define UNICODE_COLON ((WCHAR)':')
#define UNICODE_LEFT ((WCHAR)'[')
#define UNICODE_RIGHT ((WCHAR)']')
#define UNICODE_HEXBASE ((WCHAR)'7')

#define JAPAN_CODEPAGE 932
#define PRC_CODEPAGE 936
#define KOREA_CODEPAGE 949
#define TAIWAN_CODEPAGE 950

#define PRCCOMPWIDTH 10

#define MODEDISP_NONE     0
#define MODEDISP_PLAURAL  1
#define MODEDISP_SINGLE   2
#define MODEDISP_AUTO     3
#define MODEDISP_PHRASE   4

// for Japanese
#define IMECModeRomanLen    4
#define IMECModeKanaLen     4
#define IMECModeAHANLen     3
#define IMECModeAZENLen     2
#define IMECModeHHANLen     3
#define IMECModeHZENLen     2
#define IMECModeKHANLen     3
#define IMECModeKZENLen     2

// for CHT /Taiwan
#define IMECModeFullShapeLen 1
#define IMECModeHalfShapeLen 1
#define IMECModeKeyboardLen  2
#define IMECModeSymbolLen    2
#define IMECGuideLen         5
#define IMECNameLength       4

/*****************************************************
 * Function definition
 *****************************************************/

//
// CONIME.C
//

BOOL
InitConsoleIME(
    HINSTANCE hInstance
    );

LRESULT FAR PASCAL
WndProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
ExitList(
    HWND hWnd
    );

BOOL
InsertConsole(
    HWND    hWnd,
    HANDLE  hConsole,
    HWND    hWndConsole
    );

BOOL
GrowConsoleTable(
    VOID
    );


PCONSOLE_TABLE
SearchConsole(
    HANDLE hConsole
    );

BOOL
RemoveConsole(
    HWND hwnd,
    HANDLE hConsole
    );

BOOL
RemoveConsoleWorker(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );

BOOL
InsertNewConsole(
    HWND   hWnd,
    HANDLE hConsole,
    HWND   hWndConsole
    );


BOOL
ConsoleSetFocus(
    HWND hWnd,
    HANDLE hConsole,
    HKL hKL
    );

BOOL
ConsoleKillFocus(
    HWND hWnd,
    HANDLE hConsole
    );

BOOL
ConsoleScreenBufferSize(
    HWND hWnd,
    HANDLE hConsolewParam,
    COORD ScreenBufferSize
    );

BOOL
ConImeInputLangchangeRequest(
    HWND hWnd,
    HANDLE hConsole,
    HKL hkl,
    int Direction
    );

BOOL
ConImeInputLangchange(
    HWND hWnd,
    HANDLE hConsole,
    HKL hkl
    );

LRESULT
ConsoleImeSendMessage(
    HWND   hWndConsoleIME,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
InputLangchange(
    HWND hWnd,
    DWORD CharSet,
    HKL hkl );

#ifdef DEBUG_MODE

VOID
DisplayConvInformation(
    HWND hWnd
    );

VOID
DisplayInformation(
    HWND hWnd,
    HANDLE hConsole
    );

VOID
RealReDraw(
    HDC r_hdc
    );

VOID
ReDraw(
    HWND hWnd
    );
#endif

//
// CONSUBS.C
//

INT
Create(
    HWND hWnd
    );

void
ImeUIStartComposition(
    HWND hwnd
    );

void
ImeUIEndComposition(
    HWND hwnd
    );

void
ImeUIComposition(
    HWND hwnd,
    WPARAM wParam,
    LPARAM CompFlag
    );

void
DisplayCompString(
    HWND hwnd,
    int Length,
    PWCHAR CharBuf,
    PUCHAR AttrBuf
    );

void
DisplayResultString(
    HWND hwnd,
    LPWSTR lpStr
    );

BOOL
ImeUINotify(
    HWND hwnd,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
IsUnicodeFullWidth(
    IN WCHAR wch
    );


BOOL
ImeUIOpenStatusWindow(
    HWND hwnd
    );

BOOL
ImeUIChangeCandidate(
   HWND hwnd,
   DWORD lParam
   );

BOOL
ImeUISetOpenStatus(
    HWND hwnd
    );

BOOL
ImeUISetConversionMode(
    HWND hwnd
    );

BOOL
    ImeUIGuideLine(
    HWND hwnd
    );

DWORD
GetNLSMode(
    HWND hWnd,
    HANDLE hConsole
    );

BOOL
SetNLSMode(
    HWND hWnd,
    HANDLE hConsole,
    DWORD fdwConversion
    );


VOID
CopyDataProcess(
    HWND hWnd,
    PCOPYDATASTRUCT CopyData
    );

BOOL
ImeSysPropertyWindow(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    );

//
//  IMEFULL.C
//
VOID
ImeOpenClose(
    HWND hWnd,
    BOOL fFlag
    );

VOID
VirtualKeyHandler(
    HWND hWnd,
    UINT wParam,
    UINT lParam
    );

VOID
CharHandlerFromConsole(
    HWND hWnd,
    UINT Message,
    ULONG wParam,
    ULONG lParam
    );

VOID
CharHandlerToConsole(
    HWND hWnd,
    UINT Message,
    ULONG wParam,
    ULONG lParam
    );

#ifdef DEBUG_MODE
VOID
ImeUIMoveCandWin(
    HWND hwnd
    );
#endif

BOOL
IsDBCSTrailByte(
    char *base,
    char *p
    );

#ifdef DEBUG_MODE
VOID
ResetCaret(
    HWND hWnd
    );

BOOL
MoveCaret(
    HWND hwnd
    );
#endif

#ifdef DEBUG_MODE
VOID
StoreChar(
    HWND hWnd,
    WORD ch,
    UCHAR atr
    );
#endif

BOOL
ConsoleCodepageChange(
    HWND hWnd,
    HANDLE hConsole,
    BOOL Output,
    WORD CodePage
    );

//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
//L                                       L
//L     COUNTRY.C                         L
//L                                       L
//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

BOOL
ConimeHotkey(
    HWND hWnd,
    HANDLE hConsole,
    DWORD HotkeyID
    );

BOOL
GetIMEName(
    PCONSOLE_TABLE ConTbl
    );

BOOL
GetOpenStatusByCodepage(
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl
    );

BOOL
ImeUIMakeInfoString(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

BOOL
MakeInfoStringJapan(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

BOOL
MakeInfoStringTaiwan(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

DWORD
MakeStatusStrTaiwan1(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
MakeStatusStrTaiwan2(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
IncludeCompositionT(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
IncludeCandidateT(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
DispLenStructedUnicode(
    PCHAR_INFO lpString,
    DWORD SrcLength
    );

BOOL
MakeInfoStringPRC(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

DWORD
MakeStatusStrPRC1(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
MakeStatusStrPRC2(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
IncludeCompositionP(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

DWORD
IncludeCandidateP(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    );

BOOL
MakeInfoStringKorea(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    );

//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
//L                                       L
//L     COUNTRY2.C                        L
//L                                       L
//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

BOOL
ImeUIOpenCandidate(
   HWND hwnd,
   DWORD lParam,
   BOOL OpenFlag
   );

BOOL
OpenCandidateJapan(
    HWND hwnd,
    HIMC  hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    );

BOOL
OpenCandidateTaiwan(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    );

BOOL
OpenCandidatePRC(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    );

BOOL
OpenCandidateKorea(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    );

DWORD
DispLenUnicode(
    LPWSTR lpString
    );

DWORD
GetSystemLineJ(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole,
    BOOL EnableCodePoint
    );

DWORD
GetSystemLineT(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole
    );

DWORD
GetSystemLineP(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole
    );

VOID
NumString(
    LPWSTR StrToWrite,
    DWORD NumToDisp,
    DWORD CountDispWidth
    );

BOOL
ImeUICloseCandidate(
   HWND hwnd,
   DWORD lParam
   );

BOOL
CloseCandidateJapan(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   );

BOOL
CloseCandidateTaiwan(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   );

BOOL
CloseCandidatePRC(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   );

BOOL
CloseCandidateKorea(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   );

//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
//L                                       L
//L     COUNTRY3.C                        L
//L                                       L
//LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

void
GetCompositionStr(
    HWND hwnd,
    LPARAM CompFlag,
    WPARAM CompChar
    );

void
GetCompStrJapan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    );

void
GetCompStrTaiwan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    );

void
GetCompStrPRC(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    );

void
GetCompStrKorea(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag,
    WPARAM CompChar
    );

VOID
ReDisplayCompositionStr (
    HWND hwnd
    );

VOID
ReDisplayCompStrJapan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );

VOID
ReDisplayCompStrTaiwan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );

VOID
ReDisplayCompStrPRC(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );

VOID
ReDisplayCompStrKorea(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\consubs.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   ConSubs.c
//
//  PURPOSE:   Console IME control.
//
//  PLATFORMS: Windows NT-FE 3.51
//
//  FUNCTIONS:
//
//  History:
//
//  27.Jul.1995 v-HirShi (Hirotoshi Shimizu)    created
//  10.Jul.1996 v-HirShi (Hirotoshi Shimizu)    adupt FE edition
//
//  COMMENTS:
//

#include "precomp.h"
#pragma hdrstop

INT
Create( HWND hWnd )
{
    ghDefaultIMC = ImmGetContext(hWnd) ;

#ifdef DEBUG_MODE
    {
        //
        // Select fixed pitch system font and get its text metrics
        //

        HDC hdc;
        TEXTMETRIC tm;
        WORD       patern = 0xA4A4;
        SIZE       size;
        HFONT hfntFixed;                      // fixed-pitch font
        HFONT hfntOld;                        // default font holder

        hdc = GetDC( hWnd );
        hfntFixed = GetStockObject( SYSTEM_FIXED_FONT );
        hfntOld = SelectObject( hdc, hfntFixed );
        GetTextMetrics( hdc, &tm );

        GetTextExtentPoint32( hdc, (LPWSTR)&patern, sizeof(WORD), (LPSIZE) &size );
        cxMetrics = (UINT) size.cx / 2;
        cyMetrics = (UINT) size.cy;
        ReleaseDC( hWnd, hdc );

        xPos = 0 ;
        CaretWidth = GetSystemMetrics( SM_CXBORDER );
    }
#endif

    return 0;

}

//**********************************************************************
//
// void ImeUIStartComposition()
//
// This handles WM_IME_STARTCOMPOSITION message.
//
//**********************************************************************

void ImeUIStartComposition( HWND hwnd )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    //
    // Set fInComposition variables.
    //
    ConTbl->fInComposition = TRUE;

#ifdef DEBUG_MODE
    {
        int i ;
        for (i = FIRSTCOL ; i < MAXCOL ; i++) {
            ConvertLine[i] = UNICODE_SPACE ;
            ConvertLineAtr[i] = 0 ;
        }
    }
#endif
#ifdef DEBUG_INFO
    xPos = FIRSTCOL;
    xPosLast = FIRSTCOL;
    HideCaret( hwnd );
    DisplayConvInformation( hwnd ) ;
    ResetCaret( hwnd );
#endif
}

//**********************************************************************
//
// void ImeUIEndComposition
//
// This handles WM_IME_ENDCOMPOSITION message.
//
//**********************************************************************

void ImeUIEndComposition( HWND hwnd )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    //
    // Reset fInComposition variables.
    //
    ConTbl->fInComposition = FALSE;

    if (ConTbl->lpCompStrMem)
        LocalFree( ConTbl->lpCompStrMem );
    ConTbl->lpCompStrMem = NULL ;

#ifdef DEBUG_MODE
    {
        int i ;
        //
        // Reset the length of composition string to zero.
        //
        for (i = FIRSTCOL ; i < MAXCOL ; i++) {
            ConvertLine[i] = UNICODE_SPACE ;
            ConvertLineAtr[i] = 0 ;
        }
    }
#endif
#ifdef DEBUG_INFO
    xPos = FIRSTCOL;
    xPosLast = FIRSTCOL;
    HideCaret( hwnd );
    DisplayConvInformation( hwnd ) ;
    ResetCaret( hwnd );
#endif
}

//**********************************************************************
//
// void ImeUIComposition()
//
// This handles WM_IME_COMPOSITION message. It here just handles
// composition string and result string. For normal case, it should
// examine all posibile flags indicated by CompFlag, then do some
// actitions to reflect what kinds of composition info. IME conversion
// engine informs.
//
//**********************************************************************

void ImeUIComposition( HWND hwnd, WPARAM CompChar, LPARAM CompFlag )
{

    DBGPRINT(("CONIME: WM_IME_COMPOSITION %08x %08x\n",CompChar,CompFlag));

#ifdef DEBUG_MODE
    {
        int i ;
        for (i = FIRSTCOL ; i < MAXCOL ; i++) {
            ConvertLine[i] = UNICODE_SPACE ;
            ConvertLineAtr[i] = 0 ;
        }
        xPos = FIRSTCOL;
        xPosLast = FIRSTCOL;
    }
#endif

    if ( CompFlag == 0 ) {
        DBGPRINT(("                           None\n"));
        GetCompositionStr( hwnd, CompFlag, CompChar);
    }
    if ( CompFlag & GCS_RESULTSTR ) {
        DBGPRINT(("                           GCS_RESULTSTR\n"));
        GetCompositionStr( hwnd, ( CompFlag & GCS_RESULTSTR ), CompChar );
    }
    if ( CompFlag & GCS_COMPSTR ) {
        DBGPRINT(("                           GCS_COMPSTR\n"));
        GetCompositionStr( hwnd, ( CompFlag & (GCS_COMPSTR|GCS_COMPATTR)), CompChar);
    }
    if ( CompFlag & CS_INSERTCHAR ) {
        DBGPRINT(("                           CS_INSERTCHAR\n"));
        GetCompositionStr( hwnd, ( CompFlag & (CS_INSERTCHAR|GCS_COMPATTR)), CompChar);
    }
    if ( CompFlag & CS_NOMOVECARET ) {
        DBGPRINT(("                           CS_NOMOVECARET\n"));
        GetCompositionStr( hwnd, ( CompFlag & (CS_NOMOVECARET|GCS_COMPATTR)), CompChar);
    }
}


#ifdef DEBUG_INFO
//*********************************************************************
//
// void DisplayCompString()
//
// This displays composition string.
//
// This function send string to Console.
//
//*********************************************************************

void DisplayCompString( HWND hwnd, int Length, PWCHAR CharBuf, PUCHAR AttrBuf )
{
    int         i;
    CopyMemory(ConvertLine, CharBuf, Length * sizeof(WCHAR) ) ;
    if ( AttrBuf == NULL ) {
        for ( i = 0 ; i < Length ; i++ )
            ConvertLineAtr[i] = 0 ;
    }
    else {
        CopyMemory(ConvertLineAtr, AttrBuf, Length) ;
    }
    HideCaret( hwnd );
    DisplayConvInformation( hwnd ) ;
    ResetCaret( hwnd );

}

//*********************************************************************
//
// void DisplayResultString()
//
// This displays result string.
//
// This function supports only fixed pitch font.
//
//*********************************************************************

void DisplayResultString( HWND hwnd, LPWSTR lpwStr )
{

    int         StrLen = lstrlenW( lpwStr );

    CopyMemory(ConvertLine, lpwStr, StrLen*sizeof(WCHAR)) ;
    HideCaret( hwnd );
    DisplayConvInformation( hwnd ) ;
    ResetCaret( hwnd );

    // gImeUIData.uCompLen = 0;

}
#endif

//**********************************************************************
//
// BOOL ImeUINotify()
//
// This handles WM_IME_NOTIFY message.
//
//**********************************************************************

BOOL ImeUINotify( HWND hwnd, WPARAM wParam, LPARAM lParam )
{
    switch (wParam )
    {
        case IMN_OPENSTATUSWINDOW:
            ImeUIOpenStatusWindow(hwnd) ;
            break;
        case IMN_CHANGECANDIDATE:
            ImeUIChangeCandidate( hwnd, (DWORD)lParam );
            break;
        case IMN_CLOSECANDIDATE:
            ImeUICloseCandidate( hwnd, (DWORD)lParam );
            break;
        case IMN_OPENCANDIDATE:
            ImeUIOpenCandidate( hwnd, (DWORD)lParam, TRUE);
            break;
        case IMN_SETCONVERSIONMODE:
            ImeUISetConversionMode(hwnd) ;
            // IMN_SETCONVERSIONMODE should be pass to DefWindowProc
            // becuase ImeNotifyHandler in User32 does notify to shell and keyboard.
            return FALSE;
        case IMN_SETOPENSTATUS:
            ImeUISetOpenStatus( hwnd );
            // IMN_SETOPENSTATUS should be pass to DefWindowProc
            // becuase ImeNotifyHandler in User32 does notify to shell and keyboard.
            return FALSE;
        case IMN_GUIDELINE:
            ImeUIGuideLine(hwnd) ;
            break;
        default:
            return FALSE;

    }
    return TRUE;
}

/***************************************************************************\
* BOOL IsConsoleFullWidth(DWORD CodePage,WCHAR wch)
*
* Determine if the given Unicode char is fullwidth or not.
*
* History:
* 04-08-92 ShunK       Created.
* Jul-27-1992 KazuM    Added Screen Information and Code Page Information.
* Jan-29-1992 V-Hirots Substruct Screen Information.
* Oct-06-1996 KazuM    Not use RtlUnicodeToMultiByteSize and WideCharToMultiByte
*                      Because 950 only defined 13500 chars,
*                      and unicode defined almost 18000 chars.
*                      So there are almost 4000 chars can not be mapped to big5 code.
\***************************************************************************/

BOOL IsUnicodeFullWidth(
    IN WCHAR wch
    )
{
    if (0x20 <= wch && wch <= 0x7e)
        /* ASCII */
        return FALSE;
    else if (0x3041 <= wch && wch <= 0x3094)
        /* Hiragana */
        return TRUE;
    else if (0x30a1 <= wch && wch <= 0x30f6)
        /* Katakana */
        return TRUE;
    else if (0x3105 <= wch && wch <= 0x312c)
        /* Bopomofo */
        return TRUE;
    else if (0x3131 <= wch && wch <= 0x318e)
        /* Hangul Elements */
        return TRUE;
    else if (0xac00 <= wch && wch <= 0xd7a3)
        /* Korean Hangul Syllables */
        return TRUE;
    else if (0xff01 <= wch && wch <= 0xff5e)
        /* Fullwidth ASCII variants */
        return TRUE;
    else if (0xff61 <= wch && wch <= 0xff9f)
        /* Halfwidth Katakana variants */
        return FALSE;
    else if ( (0xffa0 <= wch && wch <= 0xffbe) ||
              (0xffc2 <= wch && wch <= 0xffc7) ||
              (0xffca <= wch && wch <= 0xffcf) ||
              (0xffd2 <= wch && wch <= 0xffd7) ||
              (0xffda <= wch && wch <= 0xffdc)   )
        /* Halfwidth Hangule variants */
        return FALSE;
    else if (0xffe0 <= wch && wch <= 0xffe6)
        /* Fullwidth symbol variants */
        return TRUE;
    else if (0x4e00 <= wch && wch <= 0x9fa5)
        /* Han Ideographic */
        return TRUE;
    else if (0xf900 <= wch && wch <= 0xfa2d)
        /* Han Ideographic Compatibility */
        return TRUE;
    else
    {
#if 0
        /*
         * Hack this block for I don't know FONT of Console Window.
         *
         * If you would like perfect result from IsUnicodeFullWidth routine,
         * then you should enable this block and
         * you should know FONT of Console Window.
         */

        INT Width;
        TEXTMETRIC tmi;

        /* Unknown character */

        GetTextMetricsW(hDC, &tmi);
        if (IS_ANY_DBCS_CHARSET(tmi.tmCharSet))
            tmi.tmMaxCharWidth /= 2;

        GetCharWidth32(hDC, wch, wch, &Width);
        if (Width == tmi.tmMaxCharWidth)
            return FALSE;
        else if (Width == tmi.tmMaxCharWidth*2)
            return TRUE;
#else
        ULONG MultiByteSize;

        RtlUnicodeToMultiByteSize(&MultiByteSize, &wch, sizeof(WCHAR));
        if (MultiByteSize == 2)
            return TRUE ;
        else
            return FALSE ;
#endif
    }
    ASSERT(FALSE);
    return FALSE;
#if 0
    ULONG MultiByteSize;

    RtlUnicodeToMultiByteSize(&MultiByteSize, &wch, sizeof(WCHAR));
    if (MultiByteSize == 2)
        return TRUE ;
    else
        return FALSE ;
#endif
}


BOOL
ImeUIOpenStatusWindow(
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC        hIMC;                   // Input context handle.
    LPCONIME_UIMODEINFO lpModeInfo ;
    COPYDATASTRUCT CopyData ;

    DBGPRINT(("CONIME: Get IMN_OPENSTATUSWINDOW Message\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd ) ;
    if ( hIMC == 0 )
        return FALSE;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) ) ;
    if ( lpModeInfo == NULL) {
        ImmReleaseContext( hwnd, hIMC );
        return FALSE;
    }

    ImmGetConversionStatus(hIMC,
                           (LPDWORD)&ConTbl->dwConversion,
                           (LPDWORD)&ConTbl->dwSentence) ;

    CopyData.dwData = CI_CONIMEMODEINFO ;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO) ;
    CopyData.lpData = lpModeInfo ;
    if (ImeUIMakeInfoString(ConTbl,
                            lpModeInfo))
    {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              ) ;
    }

    LocalFree( lpModeInfo );

    ImmReleaseContext( hwnd, hIMC );

    return TRUE ;
}


BOOL
ImeUIChangeCandidate(
   HWND hwnd,
   DWORD lParam
   )
{
    return ImeUIOpenCandidate( hwnd, lParam, FALSE) ;
}


BOOL
ImeUISetOpenStatus(
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC        hIMC;                   // Input context handle.
    LPCONIME_UIMODEINFO lpModeInfo ;
    COPYDATASTRUCT CopyData ;

    DBGPRINT(("CONIME: Get IMN_SETOPENSTATUS Message\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd ) ;
    if ( hIMC == 0 )
        return FALSE;

    ConTbl->fOpen = GetOpenStatusByCodepage( hIMC, ConTbl ) ;

    ImmGetConversionStatus(hIMC,
                           (LPDWORD)&ConTbl->dwConversion,
                           (LPDWORD)&ConTbl->dwSentence) ;

    if (ConTbl->ScreenBufferSize.X != 0) {

        lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO)) ;
        if ( lpModeInfo == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return FALSE;
        }

        CopyData.dwData = CI_CONIMEMODEINFO ;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO) ;
        CopyData.lpData = lpModeInfo ;
        if (ImeUIMakeInfoString(ConTbl,
                                lpModeInfo))
        {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                  ) ;
        }
        LocalFree( lpModeInfo );
    }
    ImmReleaseContext( hwnd, hIMC );

    return TRUE ;
}

BOOL
ImeUISetConversionMode(
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC        hIMC;                   // Input context handle.
    LPCONIME_UIMODEINFO lpModeInfo ;
    COPYDATASTRUCT CopyData ;
    DWORD OldConversion ;


    DBGPRINT(("CONIME: Get IMN_SETCONVERSIONMODE Message\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd ) ;
    if ( hIMC == 0 )
        return FALSE;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) ) ;
    if ( lpModeInfo == NULL) {
        ImmReleaseContext( hwnd, hIMC );
        return FALSE;
    }

    OldConversion = ConTbl->dwConversion ;

    ImmGetConversionStatus(hIMC,
                           (LPDWORD)&ConTbl->dwConversion,
                           (LPDWORD)&ConTbl->dwSentence) ;

    CopyData.dwData = CI_CONIMEMODEINFO ;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO) ;
    CopyData.lpData = lpModeInfo ;
    if (ImeUIMakeInfoString(ConTbl,
                            lpModeInfo))
    {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             ) ;
    }

    LocalFree( lpModeInfo );
    ImmReleaseContext( hwnd, hIMC );
    return TRUE ;

}

BOOL
ImeUIGuideLine(
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC        hIMC ;                   // Input context handle.
    DWORD       Level ;
    DWORD       Index ;
    DWORD       Length ;
    LPCONIME_UIMESSAGE GuideLine ;
    COPYDATASTRUCT CopyData ;

    DBGPRINT(("CONIME: Get IMN_GUIDELINE Message "));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd ) ;
    if ( hIMC == 0 )
        return FALSE;

    Level = ImmGetGuideLine(hIMC, GGL_LEVEL, NULL, 0) ;
    Index = ImmGetGuideLine(hIMC, GGL_INDEX, NULL, 0) ;
    Length = ImmGetGuideLine(hIMC, GGL_STRING, NULL, 0) ;
    DBGPRINT(("Level=%d Index=%d Length=%d",Level,Index,Length));
    if (Length == 0) {
        CopyData.dwData = CI_CONIMESYSINFO ;
        CopyData.cbData = Length ;
        CopyData.lpData = NULL ;

        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              ) ;
    }
    else{
        GuideLine = (LPCONIME_UIMESSAGE)LocalAlloc(LPTR, Length + sizeof(WCHAR)) ;
        if (GuideLine == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return FALSE;
        }

        CopyData.dwData = CI_CONIMESYSINFO ;
        CopyData.cbData = Length + sizeof(WCHAR) ;
        CopyData.lpData = GuideLine ;
        Length = ImmGetGuideLine(hIMC, GGL_STRING, GuideLine->String, Length) ;

        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              ) ;

        LocalFree( GuideLine ) ;
    }
    ImmReleaseContext( hwnd, hIMC );
    DBGPRINT(("\n"));

    return TRUE ;
}

DWORD
GetNLSMode(
    HWND hWnd,
    HANDLE hConsole
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC hIMC;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return 0;
    }

    hIMC = ImmGetContext( hWnd ) ;
    if ( hIMC == (HIMC)NULL )
        return IME_CMODE_DISABLE;

    ImmGetConversionStatus(hIMC,
                           &ConTbl->dwConversion,
                           &ConTbl->dwSentence);
    ConTbl->fOpen = GetOpenStatusByCodepage( hIMC, ConTbl ) ;

    ImmReleaseContext( hWnd, hIMC );


    return ((ConTbl->fOpen ? IME_CMODE_OPEN : 0) + ConTbl->dwConversion);
}

BOOL
SetNLSMode(
    HWND hWnd,
    HANDLE hConsole,
    DWORD fdwConversion
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC hIMC;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    if (fdwConversion & IME_CMODE_DISABLE)
    {
        ImmSetActiveContextConsoleIME(hWnd, FALSE) ;
        ImmAssociateContext(hWnd, (HIMC)NULL);
        ConTbl->hIMC_Current = (HIMC)NULL;
    }
    else
    {
        ImmAssociateContext(hWnd, ConTbl->hIMC_Original);
        ImmSetActiveContextConsoleIME(hWnd, TRUE) ;
        ConTbl->hIMC_Current = ConTbl->hIMC_Original;
    }

    hIMC = ImmGetContext( hWnd ) ;
    if ( hIMC == (HIMC)NULL )
        return TRUE;

    ConTbl->fOpen =(fdwConversion & IME_CMODE_OPEN) ? TRUE : FALSE ;
    ImmSetOpenStatus(hIMC, ConTbl->fOpen);

    fdwConversion &= ~(IME_CMODE_DISABLE | IME_CMODE_OPEN);
    if (ConTbl->dwConversion != fdwConversion)
    {
        ConTbl->dwConversion = fdwConversion;
        ImmSetConversionStatus(hIMC,
                               ConTbl->dwConversion,
                               ConTbl->dwSentence );
    }

    ImmReleaseContext( hWnd, hIMC );

    return TRUE;
}

BOOL
ConsoleCodepageChange(
    HWND hWnd,
    HANDLE hConsole,
    BOOL Output,
    WORD CodePage
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    if (Output)
    {
        ConTbl->ConsoleOutputCP = CodePage ;
    }
    else
    {
        ConTbl->ConsoleCP = CodePage ;
    }
    return (TRUE) ;
}

BOOL
ImeSysPropertyWindow(
    HWND hWnd,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PCONSOLE_TABLE ConTbl;
    COPYDATASTRUCT CopyData;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    CopyData.dwData = CI_CONIMEPROPERTYINFO;
    CopyData.cbData = sizeof(WPARAM);
    CopyData.lpData = &wParam;

    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hWnd,
                           (LPARAM)&CopyData
                          );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\sources.inc ===
W32_SB=1

MAJORCOMP=windows
MINORCOMP=console

TARGETNAME=conlibk
TARGETPATH=$(_OBJ_DIR)
PASS1_PUBLISH=\
    {$(DYNLINK_LIB)=$(WINDOWS_LIB_DEST)\$(DYNLINK_LIBDIR)}
TARGETTYPE=LIBRARY

INCLUDES=..;                    \
   ..\..\inc;                   \
   $(WINCORE_PATH)\w32inc;      \
   $(WINCORE_PATH)\w32inc\$(O); \
   $(BASE_INC_PATH)

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=$(C_DEFINES) -D_KERNEL32_

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\country.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   country.c
//
//  PURPOSE:   Console IME control.
//             FarEast country specific module for conime.
//
//  PLATFORMS: Windows NT-FE 3.51
//
//  FUNCTIONS:
//    ImeUIMakeInfoString() - routine for make status string
//
//  History:
//
//  10.Jul.1996 v-HirShi (Hirotoshi Shimizu)    Created for TAIWAN & KOREA & PRC
//
//  COMMENTS:
//
#include "precomp.h"
#pragma hdrstop

// for Japanese
//                             none  plaural single    auto  phrase
WCHAR IMECMode[]          = { 0x7121, 0x8907, 0x5358, 0x81ea, 0x9023 };
WCHAR IMECModeRoman[]     = { 0xff9b, 0xff70, 0xff8f, 0x0020 };
WCHAR IMECModeKana[]      = { 0xff76, 0xff85, 0x0020, 0x0020 };
WCHAR IMECModeAHAN[]      = { 0x534a, 0x0041, 0x0020 };
WCHAR IMECModeAZEN[]      = { 0x5168, 0xff21 };
WCHAR IMECModeHHAN[]      = { 0x534a, 0xff71, 0x0020 };
WCHAR IMECModeHZEN[]      = { 0x5168, 0x3042 };
WCHAR IMECModeKHAN[]      = { 0x534a, 0xff76, 0x0020 };
WCHAR IMECModeKZEN[]      = { 0x5168, 0x30ab };

// for CHT /Taiwan
WCHAR IMECModeFullShape[] = { 0x5168, 0x5f62 };
WCHAR IMECModeHalfShape[] = { 0x534a, 0x5f62 };
WCHAR IMECModeKeyboard[]  = { 0x9375, 0x76e4 };
WCHAR IMECModeSymbol[]    = { 0x7b26, 0x53f7 };
WCHAR IMECGuide[9][7]     = {{ 0x5009, 0x9821, 0x8acb, 0x8f38, 0x5165, 0x5b57, 0x6839 },    // kura
                             { 0x5167, 0x78bc, 0x8acb, 0x8f38, 0x5165, 0x5167, 0x78bc },    // naima
                             { 0x55ae, 0x78bc, 0x8acb, 0x8f38, 0x5165, 0x55ae, 0x78bc },    // tanma
                             { 0x901f, 0x6210, 0x8acb, 0x8f38, 0x5165, 0x5b57, 0x6839 },    // sokusei
                             { 0x5927, 0x6613, 0x8acb, 0x8f38, 0x5165, 0x5b57, 0x6839 },    // taieki
                             { 0x82f1, 0x6570, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000 },    // eisuu
                             { 0xff55, 0xff53, 0x3000, 0x3000, 0x3000, 0x3000, 0x3000 },    // US
                             { 0x6ce8, 0x97f3, 0x8acb, 0x8f38, 0x5165, 0x7b26, 0x865f },    // chuon fugou
                             { 0x6ce8, 0x97f3, 0x8acb, 0x3000, 0x9078, 0x3000, 0x5b57 } }; // chuon senji
/*
WCHAR IMECNAMEPRC[9][7]   = { 0x5168, 0x62fc, 0 };                   // zenhei
                            { 0x53cc, 0x62fc, 0 };                   // souhei
                            { 0x6807, 0x51c6, 0 };                   // sijun
                            { 0x53cc, 0x6253, 0 };                   // souda
                            { 0x90d1, 0x7801, 0 };                   // hou?
                            { 0x8868, 0x5f62, 0x7801, 0 };           // hyoukei
                            { 0x7e41, 0x4f53, 0x6ce8, 0x97f3, 0 };   // chuon
                            { 0x7e41, 0x4f53, 0x4ed3, 0x9889, 0 };   // kaihou
                            { 0x533a, 0x4f4d, 0 };                   // kui
                            { 0x0047, 0x0042, 0x004a, 0x5185, 0x7801, 0 };   // GBKnaikou
                            { 0x0055, 0x006e, 0x0069, 0x0063, 0x006f, 0x0064, 0x0065, 0 };   // Unicode
*/

BOOL
ConimeHotkey(
    HWND hWnd,
    HANDLE hConsole,
    DWORD HotkeyID
    )
{
//    PCONSOLE_TABLE ConTbl;
//
//    ConTbl = SearchConsole(hConsole);
//    if (ConTbl == NULL) {
//        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
//        return FALSE;
//    }

    return ImmSimulateHotKey(hWnd,(DWORD)HotkeyID);
}

BOOL
GetIMEName(
    PCONSOLE_TABLE ConTbl
    )
{
    WCHAR buf[MaxBufSize];
    WCHAR name[MaxBufSize];
    DWORD bufsize = MaxBufSize;
    LONG lResult;
    HKEY hkLayout;
    int i;

    ConTbl->LayoutName[0] = TEXT('\0');
    ConTbl->GuideLine[0] = TEXT('\0');

    if (ImmEscape(ConTbl->hklActive, ConTbl->hIMC_Current, IME_ESC_IME_NAME, (LPTSTR)&name) == 0)
    {
        if (!ImmGetIMEFileName(ConTbl->hklActive, (LPTSTR)&name, MaxBufSize ) )
        {
            if (GetKeyboardLayoutName((LPTSTR)&name) ) 
            {
                /*
                 * quick dirty ImmIsIME
                 */
                if (name[0] != TEXT('E') &&
                    name[0] != TEXT('e'))
                {
                    return FALSE;
                }

                lstrcpy( buf, KBDLAYOUT );
                lstrcat( buf, KBDSEPALATER );
                lstrcat( buf, name );
                lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       (LPCTSTR)buf,
                                       0,
                                       KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
                                       &hkLayout );
                if ( lResult == ERROR_SUCCESS ) {
                    lResult = RegQueryValueEx( hkLayout,
                                               KBDLAYOUTTEXT,
                                               NULL,
                                               NULL,
                                               (LPBYTE)ConTbl->LayoutName,
                                               &bufsize );
                    RegCloseKey( hkLayout );
                    if (ConTbl->LayoutName[0] != TEXT('\0')) {
                        for (i = 0; i < 8; i ++){
                            if ((ConTbl->LayoutName[0] == IMECGuide[i][0]) &&
                                (ConTbl->LayoutName[1] == IMECGuide[i][1]) ) {
                                lstrcpyn(&(ConTbl->GuideLine[0]), &(IMECGuide[i][2]), IMECGuideLen+1);
                                break;
                            }
                        }
                    }
                }
                else{
                    return FALSE;
                }
            }
            else
            {
                return FALSE;
            }
        }
        else
        {
            lstrcpy( ConTbl->LayoutName, name );
        }
    }
    else
    {
        lstrcpy( ConTbl->LayoutName, name);
    }

    return TRUE;
}

BOOL
GetOpenStatusByCodepage(
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl
    )
{
    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            return ImmGetOpenStatus(hIMC);
            break;
        case    LANG_ID_TAIWAN:
        case    LANG_ID_PRC:
        case    LANG_ID_KOREA:
            if (ImmGetOpenStatus(hIMC)) {
                return ImmIsIME(ConTbl->hklActive);
            }
            break;
        default:
            return FALSE;
    }
    return FALSE;
}

BOOL
ImeUIMakeInfoString(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{

    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            return MakeInfoStringJapan(ConTbl, lpModeInfo);
            break;
        case    LANG_ID_TAIWAN:
            return MakeInfoStringTaiwan(ConTbl, lpModeInfo);
            break;
        case    LANG_ID_PRC:
            return MakeInfoStringPRC(ConTbl, lpModeInfo);
            break;
        case    LANG_ID_KOREA:
            return MakeInfoStringKorea(ConTbl, lpModeInfo);
            break;
        default:
            return FALSE;
    }
}

BOOL
MakeInfoStringJapan(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{
    int i , j;
    DWORD dwConversion;
    DWORD dwSentence;

    dwConversion = ConTbl->dwConversion;
    dwSentence = ConTbl->dwSentence;

    i = j = 0;
    if (ConTbl->fOpen){
        if (dwConversion & IME_CMODE_FULLSHAPE) {
            if (dwConversion & IME_CMODE_NATIVE) {
                if (dwConversion & IME_CMODE_KATAKANA) {
                    for (j = 0; j < IMECModeKZENLen; j++, i++)
                        lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeKZEN[j];
                }
                else {
                    for (j = 0; j < IMECModeHZENLen; j++, i++)
                        lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeHZEN[j];
                }
            }
            else {
                for (j = 0; j < IMECModeAZENLen; j++, i++)
                    lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeAZEN[j];
            }
        }
        else {
            if (dwConversion & IME_CMODE_NATIVE) {
                if (dwConversion & IME_CMODE_KATAKANA) {
                    for (j = 0; j < IMECModeKHANLen; j++, i++)
                        lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeKHAN[j];
                }
                else {
                    for (j = 0; j < IMECModeHHANLen; j++, i++)
                        lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeHHAN[j];
                }
            }
            else {
                for (j = 0; j < IMECModeAHANLen; j++, i++)
                    lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeAHAN[j];
            }
        }

        if (dwSentence & IME_SMODE_NONE)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_NONE];
        else if (dwSentence & IME_SMODE_PLAURALCLAUSE)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_PLAURAL];
        else if (dwSentence & IME_SMODE_SINGLECONVERT)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_SINGLE];
        else if (dwSentence & IME_SMODE_AUTOMATIC)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_AUTO];
        else if (dwSentence & IME_SMODE_PHRASEPREDICT)
            lpModeInfo->ModeString[i].Char.UnicodeChar = IMECMode[MODEDISP_PHRASE];
        else {
            lpModeInfo->ModeString[i++].Char.UnicodeChar = 0x0020;
            lpModeInfo->ModeString[i].Char.UnicodeChar = 0x0020;
        }
        i++;

        if (GetKeyState(VK_KANA) & 1) {
            for (j = 0; j < IMECModeKanaLen; j++, i++)
                lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeKana[j];
        }
        else if (dwConversion & IME_CMODE_ROMAN) {
            for (j = 0; j < IMECModeRomanLen; j++, i++)
                lpModeInfo->ModeString[i].Char.UnicodeChar = IMECModeRoman[j];
        }
    }
    else {
        /*
         * In this case, fOpen is 0 (==close).
         * Should be fill mode text buffer in console.
         * So, console can do fill up that pass to 0 length.
         */
        i = 0;
    }
    for (j = 0; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    lpModeInfo->ModeStringLen = i;
    lpModeInfo->Position = VIEW_RIGHT;
    return TRUE;
}


BOOL
MakeInfoStringTaiwan(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{
    DWORD j;
    DWORD ModeInfoPtr;
    DWORD LengthForDisp;

    ModeInfoPtr = 0;

    if (ImmIsIME(ConTbl->hklActive) ){
        ModeInfoPtr = MakeStatusStrTaiwan1(ConTbl, lpModeInfo, ModeInfoPtr);
        if (ConTbl->fInComposition) {
            if (ConTbl->fInCandidate){
                ModeInfoPtr = IncludeCandidateT(ConTbl, lpModeInfo, ModeInfoPtr);
            }
            else{
                ModeInfoPtr = IncludeCompositionT(ConTbl, lpModeInfo, ModeInfoPtr);
            }
        }
        ModeInfoPtr = MakeStatusStrTaiwan2(ConTbl, lpModeInfo, ModeInfoPtr);
    }

    lpModeInfo->ModeStringLen = ModeInfoPtr;
    lpModeInfo->Position = VIEW_LEFT;
    return TRUE;
}

DWORD
MakeStatusStrTaiwan1(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD Length;
    DWORD dwConversion;

    dwConversion = ConTbl->dwConversion;

    i = ModeInfoPtr;
    j = 0;
    Length = 0;
    while (Length < IMECNameLength ) {
        if (ConTbl->LayoutName[j] == 0 )
            break;
        lpModeInfo->ModeString[i].Char.UnicodeChar = ConTbl->LayoutName[j];
        Length += IsUnicodeFullWidth(lpModeInfo->ModeString[i].Char.UnicodeChar) ? 2 : 1;
        j++;
        i++;
    }
    if (Length < IMECNameLength+1) {
        for (j = Length; j < IMECNameLength+1; j++ ) {
            lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
        }
    }

    if (dwConversion & IME_CMODE_FULLSHAPE) {
        for (j = 0; j < IMECModeFullShapeLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeFullShape[j];
    }
    else{
        for (j = 0; j < IMECModeHalfShapeLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeHalfShape[j];
    }

    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;

#if defined (CANDCOUNTPRC) //for wider candidate list space Oct.16.1996
    if (ConTbl->fInCandidate){
        for (j = 0; j < IMECGuideLen; j++ )
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECGuide[8][2+j];
    }
    else if (ConTbl->GuideLine[0]){
        for (j = 0; j < IMECGuideLen; j++ )
            lpModeInfo->ModeString[i++].Char.UnicodeChar = ConTbl->GuideLine[j];
    }
#endif

    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_COLON;

    for (j = 0; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    return i;
}

DWORD
MakeStatusStrTaiwan2(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD LengthOfStr;
    DWORD LengthForNum;
    DWORD LengthForNum2;
    DWORD CountDispWidth;
    DWORD StatusWidth;
    DWORD i;
    DWORD j;

    i = ModeInfoPtr;

    StatusWidth = ConTbl->ScreenBufferSize.X;
    if (StatusWidth > MAXSTATUSCOL) {
        StatusWidth = MAXSTATUSCOL;
    }
#if defined (CANDCOUNTCHT) //for wider candidate list space v-hirshi Oct.16.1996
    LengthOfStr = DispLenStructedUnicode(lpModeInfo->ModeString,ModeInfoPtr) + 1 + 4;
#else
    LengthOfStr = DispLenStructedUnicode(lpModeInfo->ModeString,ModeInfoPtr);
#endif

    if (LengthOfStr > StatusWidth) {
        for ( ; LengthOfStr > StatusWidth; i-- ) {
            LengthOfStr -= (IsUnicodeFullWidth(lpModeInfo->ModeString[i].Char.UnicodeChar) ? 2 : 1 );
        }
    }

    for (j = 0; j < (StatusWidth - LengthOfStr); j++) {
        lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
    }

#if defined (CANDCOUNTCHT) //for wider candidate list space v-hirshi Oct.16.1996
    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;

    if (ConTbl->dwConversion & IME_CMODE_SYMBOL) {
        for (j = 0; j < IMECModeSymbolLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeSymbol[j];
    }
    else{
        for (j = 0; j < IMECModeKeyboardLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeKeyboard[j];
    }
#endif

    for (j = ModeInfoPtr; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    return i;
}

DWORD
IncludeCompositionT(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD k;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    i = ModeInfoPtr;
    if (ConTbl->lpCompStrMem == NULL) {
        return i;
    }
    lpCompStrMem = ConTbl->lpCompStrMem;
    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lpCompStrMem->dwCompStrLen +  sizeof(WCHAR));

    k = 0;
    for (j = 0; k < lpCompStrMem->dwCompStrLen; j++, k += sizeof(WCHAR)) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
    }
    return i;
}

DWORD
IncludeCandidateT(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD dwLength;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LPCONIME_CANDMESSAGE SystemLine;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;
    lpCompStrMem = ConTbl->lpCompStrMem;

    i = ModeInfoPtr;
    if (ConTbl->SystemLine == NULL) {
        return i;
    }
    SystemLine = ConTbl->SystemLine;
    dwLength = (SystemLine->AttrOff - sizeof(DWORD) ) / sizeof(WCHAR) ;
    TempBuf  = (PWCHAR)(SystemLine->String);
    TempBufA = (PUCHAR)((LPSTR)SystemLine + SystemLine->AttrOff);

    for (j = 0; TempBuf[j] != 0; j++ ) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
    }

    return i;
}

DWORD
DispLenStructedUnicode(
    PCHAR_INFO lpString,
    DWORD SrcLength
    )
{
    DWORD i;
    DWORD Length;

    Length = 0;

    for ( i = 0; i < SrcLength; i++) {
        Length += IsUnicodeFullWidth(lpString[i].Char.UnicodeChar) ? 2 : 1;
    }
    return Length;
}


BOOL
MakeInfoStringPRC(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{
    DWORD j;
    DWORD ModeInfoPtr;
    DWORD LengthForDisp;

    ModeInfoPtr = 0;

    if (ImmIsIME(ConTbl->hklActive) ){
        ModeInfoPtr = MakeStatusStrPRC1(ConTbl, lpModeInfo, ModeInfoPtr);
        if (ConTbl->fInComposition) {
            if (ConTbl->fInCandidate){
                ModeInfoPtr = IncludeCandidateP(ConTbl, lpModeInfo, ModeInfoPtr);
            }
            else{
                ModeInfoPtr = IncludeCompositionP(ConTbl, lpModeInfo, ModeInfoPtr);
            }
        }
        ModeInfoPtr = MakeStatusStrPRC2(ConTbl, lpModeInfo, ModeInfoPtr);
    }

    lpModeInfo->ModeStringLen = ModeInfoPtr;
    lpModeInfo->Position = VIEW_LEFT;
    return TRUE;
}

DWORD
MakeStatusStrPRC1(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD dwConversion;
    DWORD Length;

    dwConversion = ConTbl->dwConversion;

    i = ModeInfoPtr;
    j = 0;
    Length = 0;
    while (Length < 9) {
        if (ConTbl->LayoutName[j] == 0 )
            break;
        if (ConTbl->LayoutName[j] == 0x8f93)
            break;
        lpModeInfo->ModeString[i].Char.UnicodeChar = ConTbl->LayoutName[j];
        Length += IsUnicodeFullWidth(lpModeInfo->ModeString[i].Char.UnicodeChar) ? 2 : 1;
        j++;
        i++;
    }
    if (Length < 9) {
        for (j = Length; j < 9; j++ ) {
            lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
        }
    }


    if (dwConversion & IME_CMODE_FULLSHAPE) {
        for (j = 0; j < IMECModeFullShapeLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeFullShape[j];
    }
    else{
        for (j = 0; j < IMECModeHalfShapeLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeHalfShape[j];
    }

// v-HirShi Oct.14.1996 delete it for get space
//  lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;

    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_COLON;

    for (j = 0; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    return i;
}

DWORD
MakeStatusStrPRC2(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD LengthOfStr;
    DWORD LengthForNum;
    DWORD LengthForNum2;
    DWORD CountDispWidth;
    DWORD StatusWidth;
    DWORD i;
    DWORD j;

    i = ModeInfoPtr;

    StatusWidth = ConTbl->ScreenBufferSize.X;
    if (StatusWidth > MAXSTATUSCOL) {
        StatusWidth = MAXSTATUSCOL;
    }
#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
    LengthOfStr = DispLenStructedUnicode(lpModeInfo->ModeString,ModeInfoPtr) + 1 + 4;
#else
    LengthOfStr = DispLenStructedUnicode(lpModeInfo->ModeString,ModeInfoPtr);
#endif

    if (LengthOfStr > StatusWidth) {
        for ( ; LengthOfStr > StatusWidth; i-- ) {
            LengthOfStr -= (IsUnicodeFullWidth(lpModeInfo->ModeString[i].Char.UnicodeChar) ? 2 : 1 );
        }
    }
    for (j = 0; j < (StatusWidth - LengthOfStr); j++) {
        lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
    }
#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;

    if (ConTbl->dwConversion & IME_CMODE_SYMBOL) {
        for (j = 0; j < IMECModeSymbolLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeSymbol[j];
    }
    else{
        for (j = 0; j < IMECModeKeyboardLen; j++)
            lpModeInfo->ModeString[i++].Char.UnicodeChar = IMECModeKeyboard[j];
    }
#endif

    for (j = ModeInfoPtr; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    return i;
}

DWORD
IncludeCompositionP(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD k;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    i = ModeInfoPtr;
    if (ConTbl->lpCompStrMem == NULL) {
        return i;
    }
    lpCompStrMem = ConTbl->lpCompStrMem;
    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lpCompStrMem->dwCompStrLen +  sizeof(WCHAR));

    k = 0;
    for (j = 0; k < lpCompStrMem->dwCompStrLen; j++, k += sizeof(WCHAR)) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
    }
    return i;
}

DWORD
IncludeCandidateP(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo,
    DWORD ModeInfoPtr
    )
{
    DWORD i;
    DWORD j;
    DWORD k;
    DWORD UnicodeLen;
    DWORD dwLength;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LPCONIME_CANDMESSAGE SystemLine;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    i = ModeInfoPtr;
    if (ConTbl->SystemLine == NULL) {
        return i;
    }
    lpCompStrMem = ConTbl->lpCompStrMem;
    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lpCompStrMem->dwCompStrLen +  sizeof(WCHAR));

    k = 0;
    UnicodeLen = 0;
    for (j = 0; (k < lpCompStrMem->dwCompStrLen )&&(UnicodeLen < PRCCOMPWIDTH); j++, k += sizeof(WCHAR)) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
       UnicodeLen += IsUnicodeFullWidth(TempBuf[j]) ? 2 : 1;
    }

    for ( j = UnicodeLen; j < PRCCOMPWIDTH; j++) {
        lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
    }
    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_COLON;

    SystemLine = ConTbl->SystemLine;
    dwLength = (SystemLine->AttrOff - sizeof(DWORD) ) / sizeof(WCHAR) ;
    TempBuf  = (PWCHAR)(SystemLine->String);
    TempBufA = (PUCHAR)((LPSTR)SystemLine + SystemLine->AttrOff);

    for (j = 0; TempBuf[j] != 0; j++ ) {
       lpModeInfo->ModeString[i].Char.UnicodeChar = TempBuf[j];
       lpModeInfo->ModeString[i++].Attributes = lpCompStrMem->CompAttrColor[TempBufA[j]];
    }

    return i;
}

BOOL
MakeInfoStringKorea(
    PCONSOLE_TABLE ConTbl,
    LPCONIME_UIMODEINFO lpModeInfo
    )
{
    int i , j;

    i = 0;
    lpModeInfo->ModeString[i++].Char.UnicodeChar = UNICODE_SPACE;
    for (j = 0; j < i; j++ )
        lpModeInfo->ModeString[j].Attributes = 0x0007;
    lpModeInfo->ModeStringLen = i;
    lpModeInfo->Position = VIEW_RIGHT;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\client\stream.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    stream.c

Abstract:

    This module contains the stubs for the console stream API.

Author:

    Therese Stowell (thereses) 3-Dec-1990

Revision History:

    
    
--*/

#include "precomp.h"
#pragma hdrstop

#if !defined(BUILD_WOW64)

HANDLE InputWaitHandle = INVALID_HANDLE_VALUE;

HANDLE
APIENTRY
GetConsoleInputWaitHandle( VOID )
{
    return InputWaitHandle;
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

HANDLE
APIENTRY
OpenConsoleWInternal(
    IN ULONG HandleType,
    IN ULONG DesiredAccess,
    IN BOOL InheritHandle,
    IN ULONG ShareMode
    )
/*++

Routine Description:

   Marshals parameters for the ConsolepOpenConsole command.

Arguments:

   See the CONSOLE_OPENCONSOLE_MSG structure and OpenConsoleW.

Return Value:

    INVALID_HANDLE_VALUE - An error occured.

--*/
{

    CONSOLE_API_MSG m;
    PCONSOLE_OPENCONSOLE_MSG a = &m.u.OpenConsole;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->HandleType    = HandleType;
    a->DesiredAccess = DesiredAccess;
    a->InheritHandle = InheritHandle;
    a->ShareMode= ShareMode;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepOpenConsole
                                            ),
                         sizeof( *a )
                       );
    if (!NT_SUCCESS( m.ReturnValue)) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return INVALID_HANDLE_VALUE;
    }
    else {
        return a->Handle;
    }

}

#endif // !defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

HANDLE
APIENTRY
OpenConsoleW(
    IN LPWSTR lpConsoleDevice,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwShareMode
    )

/*++

Parameters:

    lpConsoleDevice - Supplies the console device name to open.  "CONIN$"
        indicates console input.  "CONOUT$" indicates console output.  The
        caller must have appropriate access to the console for this call to
        succeed.

    dwDesiredAccess - Supplies the caller's desired access to the console
        device.

        DesiredAccess Flags:

        GENERIC_READ - Read access to the console device is requested.  This
            allows data to be read from the console device.

        GENERIC_WRITE - Write access to the console device is requested.  This
            allows data to be written to the console device.

    bInheritHandle - Supplies a flag that indicates whether or not the
        returned handle is to be inherited by a new process
        during a CreateProcess.  A value of TRUE indicates that the
        new process will inherit the handle.

    dwShareMode - Supplies a set of flags that indicates how this console
        device is to be shared with other openers of the console device.  A
        value of zero for this parameter indicates no sharing of the console,
        or exclusive access to the console is to occur.

        ShareMode Flags:

        FILE_SHARE_READ - Other open operations may be performed on the
            console device for read access.

        FILE_SHARE_WRITE - Other open operations may be performed on the
            console device for write access.

Return Value:

    Not -1 - Returns an open handle to the specified console device.
        Subsequent access to the file is controlled by the DesiredAccess
        parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.
--*/

{
    ULONG HandleType;

    try {
        if (!lstrcmpiW(CONSOLE_INPUT_STRING,lpConsoleDevice)) {
            HandleType = CONSOLE_INPUT_HANDLE;
        }
        else if (!lstrcmpiW(CONSOLE_OUTPUT_STRING,lpConsoleDevice)) {
            HandleType = CONSOLE_OUTPUT_HANDLE;
        }
        else {
            SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
            return INVALID_HANDLE_VALUE;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return INVALID_HANDLE_VALUE;
    }
    if (dwDesiredAccess & ~VALID_ACCESSES ||
        dwShareMode & ~VALID_SHARE_ACCESSES) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    return OpenConsoleWInternal(HandleType,
                                dwDesiredAccess,
                                bInheritHandle,
                                dwShareMode
                                );

}

#endif // !defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
ReadConsoleInternal(
    IN HANDLE hConsoleInput,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfCharsToRead,
    OUT LPDWORD lpNumberOfCharsRead,
    IN OUT LPVOID lpReserved,
    IN BOOLEAN Unicode,
    IN USHORT ExeNameLength,
    IN LPWSTR ExeName
    )
/*++
Parameters:

    hConsoleInput - Supplies an open handle to "CONIN$" open for GENERIC_READ
        or the StdIn handle.

    lpBuffer - Supplies the address of a buffer to receive the data read
        from the console input.

    nNumberOfBytesToRead - Supplies the number of bytes to read from the
        input buffer.

    lpReserved - Ignore unless 4.0 application, in which case it points
        to a CONSOLE_READCONSOLE_CONTROL data structure.  UNICODE only.
        If !Unicode, then call fails if this parameter is non-NULL

    Unicode - TRUE if call from ReadConsoleW, FALSE if ReadConsoleA


Return Value:

    NON-NULL - Returns the number of bytes actually read from the input buffer.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.
--*/

{
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_READCONSOLE_MSG a = &m.u.ReadConsole;
    BOOLEAN Dummy;
    PCONSOLE_READCONSOLE_CONTROL pInputControl;
    NTSTATUS Status;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->InputHandle = hConsoleInput;
    a->ExeNameLength = ExeNameLength;
    RtlCopyMemory(a->Buffer, ExeName, ExeNameLength);
    a->Unicode = Unicode;

    //
    // if ansi, make capture buffer large enough to hold translated
    // string.  this will make server side code much simpler.
    //

    a->CaptureBufferSize = a->NumBytes = nNumberOfCharsToRead * sizeof(WCHAR);
    if (a->CaptureBufferSize > BUFFER_SIZE) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  a->CaptureBufferSize
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 NULL,
                                 a->CaptureBufferSize,
                                 (PVOID *) &a->BufPtr
                               );

    }
    else {
        a->BufPtr = a->Buffer;
        CaptureBuffer = NULL;
    }


    pInputControl = (PCONSOLE_READCONSOLE_CONTROL)lpReserved;
    a->InitialNumBytes = 0;
    a->CtrlWakeupMask = 0;
    a->ControlKeyState = 0;
    Status = STATUS_SUCCESS;
    try {
        if (Unicode &&
            ARGUMENT_PRESENT(lpReserved) &&
            NtCurrentPeb()->ImageSubsystemMajorVersion >= 4 &&
            pInputControl->nLength == sizeof(*pInputControl)
           ) {
            if ((pInputControl->nInitialChars > nNumberOfCharsToRead)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
                a->InitialNumBytes = pInputControl->nInitialChars * sizeof(WCHAR);
                if (pInputControl->nInitialChars != 0) {
                    RtlCopyMemory( a->BufPtr, lpBuffer, a->InitialNumBytes );
                }
                a->CtrlWakeupMask = pInputControl->dwCtrlWakeupMask;
            }
        } else {
            pInputControl = NULL;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        Status = GetExceptionCode();
    }

    if (!NT_SUCCESS(Status) && pInputControl != NULL) {
        if (CaptureBuffer != NULL) {
            CsrFreeCaptureBuffer( CaptureBuffer );
        }
        SET_LAST_NT_ERROR(Status);
        return FALSE;
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepReadConsole
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
            *lpNumberOfCharsRead = a->NumBytes;
            if (Unicode) {
                *lpNumberOfCharsRead /= sizeof(WCHAR);
                if (pInputControl != NULL) {
                    pInputControl->dwControlKeyState = a->ControlKeyState;
                }
            }
            RtlCopyMemory( lpBuffer, a->BufPtr, a->NumBytes );
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            if (CaptureBuffer != NULL) {
                CsrFreeCaptureBuffer( CaptureBuffer );
            }
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
    }
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    if (!NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    } else if (m.ReturnValue == STATUS_ALERTED) {
        // ctrl-c or ctrl-break
        NtYieldExecution();
        SET_LAST_ERROR(ERROR_OPERATION_ABORTED);
    }
    return TRUE;
}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
ReadConsoleA(
    IN HANDLE hConsoleInput,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfCharsToRead,
    OUT LPDWORD lpNumberOfCharsRead,
    IN OUT LPVOID lpReserved
    )
{

    WCHAR ExeName[BUFFER_SIZE/2];
    USHORT ExeNameLength;

    ExeNameLength = GetCurrentExeName(ExeName, sizeof(ExeName));

    return ReadConsoleInternal(hConsoleInput,
                               lpBuffer,
                               nNumberOfCharsToRead,
                               lpNumberOfCharsRead,
                               NULL,
                               FALSE,
                               ExeNameLength,
                               ExeName
                              );
    UNREFERENCED_PARAMETER(lpReserved);
}

BOOL
APIENTRY
ReadConsoleW(
    IN HANDLE hConsoleInput,
    OUT LPVOID lpBuffer,
    IN DWORD nNumberOfCharsToRead,
    OUT LPDWORD lpNumberOfCharsRead,
    IN OUT LPVOID lpReserved
    )
{
    WCHAR ExeName[BUFFER_SIZE/2];
    USHORT ExeNameLength;

    ExeNameLength = GetCurrentExeName(ExeName, sizeof(ExeName));

    return ReadConsoleInternal(hConsoleInput,
                               lpBuffer,
                               nNumberOfCharsToRead,
                               lpNumberOfCharsRead,
                               lpReserved,
                               TRUE,
                               ExeNameLength,
                               ExeName
                              );
    UNREFERENCED_PARAMETER(lpReserved);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
WriteConsoleInternal(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpBuffer,
    IN DWORD nNumberOfCharsToWrite,
    OUT LPDWORD lpNumberOfCharsWritten,
    IN BOOLEAN Unicode
    )

/*++
Parameters:

    hFile - Supplies an open handle to to "CONOUT$" open for GENERIC_WRITE
        or the StdOut or StdErr handle.

    lpBuffer - Supplies the address of the data that is to be written to
        the console output.

    nNumberOfBytesToWrite - Supplies the number of bytes to write to the
        console output.

Return Value:

    NON-NULL - Returns the number of bytes actually written to the device.

    FALSE/NULL - The operation failed.
        Extended error status is available using GetLastError.
--*/

{

    PCSR_CAPTURE_HEADER CaptureBuffer;
    CONSOLE_API_MSG m;
    PCONSOLE_WRITECONSOLE_MSG a = &m.u.WriteConsole;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->OutputHandle = hConsoleOutput;

    if (Unicode) {
        a->NumBytes = nNumberOfCharsToWrite * sizeof(WCHAR);
    } else {
        a->NumBytes = nNumberOfCharsToWrite;
    }

    a->Unicode = Unicode;
    if (a->NumBytes > BUFFER_SIZE) {
        CaptureBuffer = CsrAllocateCaptureBuffer( 1,
                                                  a->NumBytes
                                                );
        if (CaptureBuffer == NULL) {
            SET_LAST_ERROR(ERROR_NOT_ENOUGH_MEMORY);
            return FALSE;
        }
        CsrCaptureMessageBuffer( CaptureBuffer,
                                 (PCHAR) lpBuffer,
                                 a->NumBytes,
                                 (PVOID *) &a->BufPtr
                               );
        a->BufferInMessage = FALSE;
    }
    else {
        a->BufPtr = a->Buffer;
        try {
            RtlCopyMemory( a->BufPtr, lpBuffer, a->NumBytes);
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        CaptureBuffer = NULL;
        a->BufferInMessage = TRUE;
    }
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         CaptureBuffer,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepWriteConsole
                                            ),
                         sizeof( *a )
                       );
    if (CaptureBuffer != NULL) {
        CsrFreeCaptureBuffer( CaptureBuffer );
    }
    if (!NT_SUCCESS( m.ReturnValue )) {
        SET_LAST_NT_ERROR(m.ReturnValue);
        return FALSE;
    }
    try {
       *lpNumberOfCharsWritten = a->NumBytes;
       if (Unicode) {
           *lpNumberOfCharsWritten /= sizeof(WCHAR);
       }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        SET_LAST_ERROR(ERROR_INVALID_ACCESS);
        return FALSE;
    }
    return TRUE;

}

#endif //!defined(BUILD_WOW6432)

#if !defined(BUILD_WOW64)

BOOL
APIENTRY
WriteConsoleA(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpBuffer,
    IN DWORD nNumberOfCharsToWrite,
    OUT LPDWORD lpNumberOfCharsWritten,
    IN OUT LPVOID lpReserved
    )
{
    return WriteConsoleInternal(hConsoleOutput,
                                lpBuffer,
                                nNumberOfCharsToWrite,
                                lpNumberOfCharsWritten,
                                FALSE
                               );
    UNREFERENCED_PARAMETER(lpReserved);
}

BOOL
APIENTRY
WriteConsoleW(
    IN HANDLE hConsoleOutput,
    IN CONST VOID *lpBuffer,
    IN DWORD nNumberOfCharsToWrite,
    OUT LPDWORD lpNumberOfCharsWritten,
    IN OUT LPVOID lpReserved
    )
{
    return WriteConsoleInternal(hConsoleOutput,
                                lpBuffer,
                                nNumberOfCharsToWrite,
                                lpNumberOfCharsWritten,
                                TRUE
                               );
    UNREFERENCED_PARAMETER(lpReserved);
}

#endif //!defined(BUILD_WOW64)

#if !defined(BUILD_WOW6432)

BOOL
APIENTRY
CloseConsoleHandle(
    IN HANDLE hConsole
    )

/*++

Parameters:

    hConsole - An open handle to console input or output.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_CLOSEHANDLE_MSG a = &m.u.CloseHandle;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hConsole;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepCloseHandle
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}

HANDLE
APIENTRY
DuplicateConsoleHandle(
    IN HANDLE hSourceHandle,
    IN DWORD dwDesiredAccess,
    IN BOOL bInheritHandle,
    IN DWORD dwOptions
    )
/*++
Parameters:

    hSourceHandle - An open handle to the console device.

    dwDesiredAccess - The access requested to for the new handle.  This
        access must be equal to or a proper subset of the granted access
        associated with the SourceHandle.  This parameter is ignored if
        the DUPLICATE_SAME_ACCESS option is specified.

    bInheritHandle - Supplies a flag that if TRUE, marks the target
        handle as inheritable.  If this is the case, then the target
        handle will be inherited to new processes each time the target
        process creates a new process using CreateProcess.

    dwOptions - Specifies optional behaviors for the caller.

        Options Flags:

        DUPLICATE_CLOSE_SOURCE - The SourceHandle will be closed by
            this service prior to returning to the caller.  This occurs
            regardless of any error status returned.

        DUPLICATE_SAME_ACCESS - The DesiredAccess parameter is ignored
            and instead the GrantedAccess associated with SourceHandle
            is used as the DesiredAccess when creating the TargetHandle.


Return Value:

    Not -1 - Returns an open handle to the specified console device.
        Subsequent access to the file is controlled by the DesiredAccess
        parameter.

    0xffffffff - The operation failed. Extended error status is available
        using GetLastError.
--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_DUPHANDLE_MSG a = &m.u.DuplicateHandle;

    if (dwOptions & ~VALID_DUP_OPTIONS) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }
    if (((dwOptions & DUPLICATE_SAME_ACCESS) == 0) &&
         (dwDesiredAccess & ~VALID_ACCESSES)) {
        SET_LAST_ERROR(ERROR_INVALID_PARAMETER);
        return INVALID_HANDLE_VALUE;
    }

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->SourceHandle = hSourceHandle;
    a->DesiredAccess = dwDesiredAccess;
    a->InheritHandle = (BOOLEAN) bInheritHandle;
    a->Options = dwOptions;
    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepDupHandle
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->TargetHandle;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return INVALID_HANDLE_VALUE;
    }

}


BOOL
APIENTRY
GetConsoleHandleInformation(
    IN HANDLE hObject,
    OUT LPDWORD lpdwFlags
    )

/*++
Parameters:

    hObject - An open handle to console input or output.

    lpdwFlags - Receives flags for console object.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_GETHANDLEINFORMATION_MSG a = &m.u.GetHandleInformation;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hObject;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepGetHandleInformation
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        try {
           *lpdwFlags = a->Flags;
        } except( EXCEPTION_EXECUTE_HANDLER ) {
            SET_LAST_ERROR(ERROR_INVALID_ACCESS);
            return FALSE;
        }
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
APIENTRY
SetConsoleHandleInformation(
    IN HANDLE hObject,
    IN DWORD dwMask,
    IN DWORD dwFlags
    )

/*++
Parameters:

    hObject - An open handle to console input or output.

    dwMask - Flags to change.

    dwFlags - New values for flags.

Return Value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_SETHANDLEINFORMATION_MSG a = &m.u.SetHandleInformation;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hObject;
    a->Mask = dwMask;
    a->Flags = dwFlags;

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepSetHandleInformation
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return TRUE;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }

}


BOOL
APIENTRY
VerifyConsoleIoHandle(
    IN HANDLE hIoHandle
    )

/*++
Parameters:

    hIoHandle - Handle to verify

Return Value:

    TRUE - handle is a valid console handle.

    FALSE - handle is not a valid console handle.

--*/

{

    CONSOLE_API_MSG m;
    PCONSOLE_VERIFYIOHANDLE_MSG a = &m.u.VerifyConsoleIoHandle;

    a->ConsoleHandle = GET_CONSOLE_HANDLE;
    a->Handle = hIoHandle;

    //
    // If this process doesn't have a console handle, bail immediately.
    //

    if (a->ConsoleHandle == NULL) {
        return FALSE;
    }

    CsrClientCallServer( (PCSR_API_MSG)&m,
                         NULL,
                         CSR_MAKE_API_NUMBER( CONSRV_SERVERDLL_INDEX,
                                              ConsolepVerifyIoHandle
                                            ),
                         sizeof( *a )
                       );
    if (NT_SUCCESS( m.ReturnValue )) {
        return a->Valid;
    } else {
        SET_LAST_NT_ERROR (m.ReturnValue);
        return FALSE;
    }


}

#endif //!defined(BUILD_WOW6432)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\conime.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   ConIme.c
//
//  PURPOSE:   Console IME control.
//
//  PLATFORMS: Windows NT-J 3.51
//
//  FUNCTIONS:
//    WinMain() - calls initialization functions, processes message loop
//    WndProc - Processes messages for the main window.
//
//  History:
//
//  27.Jul.1995 v-HirShi (Hirotoshi Shimizu)    created
//
//  COMMENTS:
//

#include "precomp.h"
#pragma hdrstop


// Global Variables

HANDLE          LastConsole;
HIMC            ghDefaultIMC;

PCONSOLE_TABLE  *ConsoleTable;
ULONG           NumberOfConsoleTable;

CRITICAL_SECTION ConsoleTableLock; // serialize console table access
#define LockConsoleTable()   RtlEnterCriticalSection(&ConsoleTableLock)
#define UnlockConsoleTable() RtlLeaveCriticalSection(&ConsoleTableLock)


BOOL            gfDoNotKillFocus;


DWORD           dwConsoleThreadId = 0;


#if DBG
ULONG InputExceptionFilter(
    PEXCEPTION_POINTERS pexi)
{
    if (pexi->ExceptionRecord->ExceptionCode != STATUS_PORT_DISCONNECTED) {
        DbgPrint("CONIME: Unexpected exception - %x, pexi = %x\n",
                pexi->ExceptionRecord->ExceptionCode, pexi);
        DbgBreakPoint();
    }

    return EXCEPTION_EXECUTE_HANDLER;
}
#else
#define InputExceptionFilter(pexi) EXCEPTION_EXECUTE_HANDLER
#endif


int
APIENTRY
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR     lpCmdLine,
    int       nCmdShow
    )
{
    MSG msg;
    WCHAR systemPath[MAX_PATH];

    if (GetSystemDirectory ( systemPath, MAX_PATH ) > 0 )
        SetCurrentDirectory ( systemPath );

#ifdef CUAS_ENABLE
    //
    // Disable CUAS on the conime.exe process
    //
    ImmDisableTextFrameService( -1 );
#endif

    if (!InitConsoleIME(hInstance) ) {
        DBGPRINT(("CONIME: InitConsoleIME failure!\n"));
        return FALSE;
    }
    else {
        DBGPRINT(("CONIME: InitConsoleIME successful!\n"));
    }

    try {

        while (TRUE)  {
            if (GetMessage(&msg, NULL, 0, 0)) {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            } else {
                break;
            }
        }

    } except (InputExceptionFilter(GetExceptionInformation())) {

        if (dwConsoleThreadId)
        {
            DBGPRINT(("CONIME: Exception on WinMain!!\n"));
            UnregisterConsoleIME();
            dwConsoleThreadId = 0;
        }

    }

    return (int)msg.wParam;
}

BOOL
InitConsoleIME(
    HINSTANCE hInstance
    )
{
    HANDLE   hEvent = NULL;
    ATOM     atom   = 0;
    HWND     hWnd   = NULL;
    WNDCLASS ConsoleIMEClass;
    int      cxExecStart;
    int      cyExecStart;
    WCHAR    szMenuName[16];                 // The name of Menu
    WCHAR    szClassName[16];                // The class name of this application
    WCHAR    szTitle[16];                    // The title bar text

#ifdef DEBUG_MODE
    WCHAR    szAppName[16];                  // The name of this application

    LoadString(hInstance, IDS_TITLE,     szTitle,     sizeof(szTitle));
#else
    szTitle[0] = L'\0';
#endif

    DBGPRINT(("CONIME: Enter InitConsoleIMEl!\n"));

    RtlInitializeCriticalSection(&ConsoleTableLock);

    ConsoleTable = (PCONSOLE_TABLE *)LocalAlloc(LPTR, CONSOLE_INITIAL_TABLE * sizeof(PCONSOLE_TABLE));
    if (ConsoleTable == NULL) {
        return FALSE;
    }
    RtlZeroMemory(ConsoleTable, CONSOLE_INITIAL_TABLE * sizeof(PCONSOLE_TABLE));
    NumberOfConsoleTable = CONSOLE_INITIAL_TABLE;

    // Load the application name and description strings.
    LoadString(hInstance, IDS_MENUNAME,  szMenuName,  sizeof(szMenuName)/sizeof(szMenuName[0]));
    LoadString(hInstance, IDS_CLASSNAME, szClassName, sizeof(szClassName)/sizeof(szClassName[0]));

    hEvent = OpenEvent(EVENT_MODIFY_STATE,    // Access flag
                       FALSE,                 // Inherit
                       CONSOLEIME_EVENT);     // Event object name
    if (hEvent == NULL)
    {
        DBGPRINT(("CONIME: OpenEvent failure! %d\n",GetLastError()));
        goto ErrorExit;
    }

    // Fill in window class structure with parameters that describe the
    // main window.

    ConsoleIMEClass.style         = 0;                       // Class style(s).
    ConsoleIMEClass.lpfnWndProc   = WndProc;                 // Window Procedure
    ConsoleIMEClass.cbClsExtra    = 0;                       // No per-class extra data.
    ConsoleIMEClass.cbWndExtra    = 0;                       // No per-window extra data.
    ConsoleIMEClass.hInstance     = hInstance;               // Owner of this class
    ConsoleIMEClass.hIcon         = LoadIcon(hInstance, MAKEINTRESOURCE(ID_CONSOLEIME_ICON));
    ConsoleIMEClass.hCursor       = LoadCursor(NULL, IDC_ARROW); // Cursor
    ConsoleIMEClass.hbrBackground = GetStockObject(WHITE_BRUSH); // Default color
    ConsoleIMEClass.lpszMenuName  = szMenuName;              // Menu name from .RC
    ConsoleIMEClass.lpszClassName = szClassName;             // Class Name

    // Register the window class and return FALSE if unsuccesful.

    atom = RegisterClass(&ConsoleIMEClass);
    if (atom == 0)
    {
        DBGPRINT(("CONIME: RegisterClass failure! %d\n",GetLastError()));
        goto ErrorExit;
    }
    else {
        DBGPRINT(("CONIME: RegisterClass Successful!\n"));
    }

    // Guess size for now.
    cxExecStart = GetSystemMetrics(SM_CXSCREEN);
    cyExecStart = GetSystemMetrics(SM_CYMENU);

    // Create a main window for this application instance.
    hWnd = CreateWindow(szClassName,                 // See RegisterClass() call.
                        szTitle,                     // Text for window title bar.
                        WS_OVERLAPPEDWINDOW,
                        cxExecStart - (cxExecStart / 3) ,
                        cyExecStart ,
                        cxExecStart / 3 ,
                        cyExecStart * 10 ,
                        NULL,                        // Overlapped has no parent.
                        NULL,                        // Use the window class menu.
                        hInstance,
                        (LPVOID)NULL);

    // If window could not be created, return "failure"
    if (hWnd == NULL) {
        DBGPRINT(("CONIME: CreateWindow failured! %d\n",GetLastError()));
        goto ErrorExit;
    }
    else{
        DBGPRINT(("CONIME: CreateWindow Successful!\n"));
    }

    if (! RegisterConsoleIME(hWnd, &dwConsoleThreadId))
    {
        DBGPRINT(("CONIME: RegisterConsoleIME failured! %d\n",GetLastError()));
        goto ErrorExit;
    }

    if (! AttachThreadInput(GetCurrentThreadId(), dwConsoleThreadId, TRUE))
    {
        DBGPRINT(("CONIME: AttachThreadInput failured! %d\n",GetLastError()));
        goto ErrorExit;
    }

    /*
     * dwConsoleThreadId is locked until event sets of hEvent
     */
    SetEvent(hEvent);
    CloseHandle(hEvent);

#ifdef DEBUG_MODE
    LoadString(hInstance, IDS_APPNAME,   szAppName,   sizeof(szAppName));

    // Make the window visible; update its client area; and return "success"
    ShowWindow(hWnd, SW_MINIMIZE); // Show the window
    SetWindowText(hWnd, szAppName);
    UpdateWindow(hWnd);         // Sends WM_PAINT message

    {
        int i;

        for (i = 0; i < CVMAX; i++) {
            ConvertLine[i] = UNICODE_SPACE;
            ConvertLineAtr[i] = 0;
        }
        xPos = 0;
        xPosLast = 0;
    }

#endif

    return TRUE;                // We succeeded...

ErrorExit:
    if (dwConsoleThreadId)
        UnregisterConsoleIME();
    if (hWnd)
        DestroyWindow(hWnd);
    if (atom)
        UnregisterClass(szClassName,hInstance);
    if (hEvent)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
    return FALSE;
}


//
//  FUNCTION: WndProc(HWND, UINT, WPARAM, LPARAM)
//
//  PURPOSE:  Processes messages
//
//  PARAMETERS:
//    hwnd     - window handle
//    uMessage - message number
//    wparam   - additional information (dependant of message number)
//    lparam   - additional information (dependant of message number)
//
//  MESSAGES:
//
//    WM_COMMAND    - exit command
//    WM_DESTROY    - destroy window
//
//  RETURN VALUE:
//
//    Depends on the message number.
//
//  COMMENTS:
//
//

LRESULT FAR PASCAL WndProc( HWND hWnd,
                         UINT Message,
                         WPARAM wParam,
                         LPARAM lParam)
{
    DWORD dwImmRet = 0;        // return value of ImmSrvProcessKey()

    try {

        switch (Message)
        {
            case CONIME_CREATE:
                DBGPRINT(("CONIME: CONIME_CREATE: Console Handle=%08x\n", wParam));
                return InsertNewConsole(hWnd,(HANDLE)wParam,(HWND)lParam);

            case CONIME_DESTROY:
                DBGPRINT(("CONIME: CONIME_DESTROY: Console Handle=%08x\n", wParam));
                return RemoveConsole(hWnd, (HANDLE)wParam);

            case CONIME_SETFOCUS:
                DBGPRINT(("CONIME: CONIME_SETFOCUS: Console Handle=%08x\n", wParam));
                return ConsoleSetFocus(hWnd, (HANDLE)wParam, (HKL)lParam);

            case CONIME_KILLFOCUS:
                DBGPRINT(("CONIME: CONIME_KILLFOCUS: Console Handle=%08x\n", wParam));
                return ConsoleKillFocus(hWnd, (HANDLE)wParam);

            case CONIME_GET_NLSMODE:
                DBGPRINT(("CONIME: CONIME_GET_NLSMODE: Console Handle=%08x\n", wParam));
                return GetNLSMode(hWnd, (HANDLE)wParam);

            case CONIME_SET_NLSMODE:
                DBGPRINT(("CONIME: CONIME_SET_NLSMODE: Console Handle=%08x\n", wParam));
                return SetNLSMode(hWnd, (HANDLE)wParam, (DWORD)lParam);

            case CONIME_HOTKEY:
                DBGPRINT(("CONIME: CONIME_HOTKEY\n"));
                return ConimeHotkey(hWnd, (HANDLE)wParam, (DWORD)lParam);

            case CONIME_NOTIFY_VK_KANA:
                DBGPRINT(("CONIME: CONIME_NOTIFY_VK_KANA\n"));
                return ImeUISetConversionMode(hWnd);

            case CONIME_NOTIFY_SCREENBUFFERSIZE: {
                COORD ScreenBufferSize;
                DBGPRINT(("CONIME: CONIME_NOTIFY_SCREENBUFFERSIZE: Console Handle=%08x\n", wParam));
                ScreenBufferSize.X = LOWORD(lParam);
                ScreenBufferSize.Y = HIWORD(lParam);
                return ConsoleScreenBufferSize(hWnd, (HANDLE)wParam, ScreenBufferSize);
            }

            case CONIME_INPUTLANGCHANGE: {
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGE: Console Handle=%08x \n",wParam));
                ConImeInputLangchange(hWnd, (HANDLE)wParam, (HKL)lParam );
                return TRUE;
            }

            case CONIME_NOTIFY_CODEPAGE: {
                BOOL Output;
                WORD Codepage;

                Codepage = HIWORD(lParam);
                Output = LOWORD(lParam);
                DBGPRINT(("CONIME: CONIME_NOTIFY_CODEPAGE: Console Handle=%08x %04x %04x\n",wParam, Output, Codepage));
                return ConsoleCodepageChange(hWnd, (HANDLE)wParam, Output, Codepage);
            }

            case WM_KEYDOWN    +CONIME_KEYDATA:
            case WM_KEYUP      +CONIME_KEYDATA:
            case WM_SYSKEYDOWN +CONIME_KEYDATA:
            case WM_SYSKEYUP   +CONIME_KEYDATA:
            case WM_DEADCHAR   +CONIME_KEYDATA:
            case WM_SYSDEADCHAR+CONIME_KEYDATA:
            case WM_SYSCHAR    +CONIME_KEYDATA:
            case WM_CHAR       +CONIME_KEYDATA:
                CharHandlerFromConsole( hWnd, Message, (ULONG)wParam, (ULONG)lParam );
                break;
            case WM_KEYDOWN:
            case WM_KEYUP:
            case WM_SYSKEYDOWN:
            case WM_SYSKEYUP:
            case WM_DEADCHAR:
            case WM_SYSDEADCHAR:
            case WM_SYSCHAR:
            case WM_CHAR:
                CharHandlerToConsole( hWnd, Message, (ULONG)wParam, (ULONG)lParam );
                break;

            case WM_INPUTLANGCHANGE:
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGE: Console Handle=%08x \n",wParam));
                InputLangchange(hWnd, (DWORD)wParam, (HKL)lParam );
                return TRUE;

            case WM_INPUTLANGCHANGEREQUEST:
                // Console IME never receive this message for this window is hidden
                // and doesn't have focus.
                //
                // However, Hot key of IME_CHOTKEY_IME_NONIME_TOGGLE/IME_THOTKEY_IME_NONIME_TOGGLE
                // are send this message by ImmSimulateHotKey API.
                //
                // If nothing processing by this message, then DefWindowProc calls
                // ActivateKeyboardLayout on kernel side.
                // And, ActivateKeyboardLayout send WM_INPUTLANGCHANGE message to focus window
                // on this message queue.
                // It window is console window procedure.
                // Console window procedure can do send CONIME_INPUTLANGCHANGE message to
                // console IME window.
                // In console window is windowed case, this sequence as well.
                // But, In console window is full screen case, message queue have not focus.
                // WM_INPUTLANGCHANGE message can not send to console window procedure.
                //
                // This code avoid console full screen mode problem.
                // Send message to console window procedure when this window receive it.
                //
                {
                    PCONSOLE_TABLE ConTbl;

                    ConTbl = SearchConsole(LastConsole);
                    if (ConTbl == NULL) {
                        return DefWindowProc(hWnd, Message, wParam, lParam);
                    }

                    PostMessage(ConTbl->hWndCon, Message, wParam, lParam);
                }
                return TRUE;    // TRUE : process this message by application

            case CONIME_INPUTLANGCHANGEREQUEST:
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGEREQUEST: Console Handle=%08x \n",wParam));
                return ConImeInputLangchangeRequest(hWnd, (HANDLE)wParam, (HKL)lParam, CONIME_DIRECT);

            case CONIME_INPUTLANGCHANGEREQUESTFORWARD:
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGEREQUEST: Console Handle=%08x \n",wParam));
                return ConImeInputLangchangeRequest(hWnd, (HANDLE)wParam, (HKL)lParam, CONIME_FORWARD);

            case CONIME_INPUTLANGCHANGEREQUESTBACKWARD:
                DBGPRINT(("CONIME: CONIME_INPUTLANGCHANGEREQUEST: Console Handle=%08x \n",wParam));
                return ConImeInputLangchangeRequest(hWnd, (HANDLE)wParam, (HKL)lParam, CONIME_BACKWARD);

#ifdef DEBUG_MODE
            case WM_MOVE:
                ImeUIMoveCandWin( hWnd );
                break;

            case WM_COMMAND: // message: command from application menu

                // Message packing of wparam and lparam have changed for Win32,
                // so use the GET_WM_COMMAND macro to unpack the commnad

                switch (LOWORD(wParam)) {
                    case MM_EXIT:
                        PostMessage(hWnd,WM_CLOSE,0,0L);
                        break;

                    case MM_ACCESS_VIOLATION:
                        {
                            PBYTE p = 0;
                            *p = 0;
                        }
                        break;
                }
                break;
#endif

            case WM_IME_STARTCOMPOSITION:
                ImeUIStartComposition( hWnd );
                break;
            case WM_IME_ENDCOMPOSITION:
                ImeUIEndComposition( hWnd );
                break;
            case WM_IME_COMPOSITION:
                ImeUIComposition( hWnd, wParam, lParam );
                break;
            case WM_IME_COMPOSITIONFULL:
                break;
            case WM_IME_NOTIFY:
                if ( !ImeUINotify( hWnd, wParam, lParam ) ) {
                    return DefWindowProc(hWnd, Message, wParam, lParam);
                }
                break;
            case WM_IME_SETCONTEXT:
                //
                // The application have to pass WM_IME_SETCONTEXT to DefWindowProc.
                // When the application want to handle the IME at the timing of
                // focus changing, the application should use WM_GETFOCUS or
                // WM_KILLFOCUS.
                //
                lParam &= ~ISC_SHOWUIALL;

                return DefWindowProc( hWnd, Message, wParam, lParam );
            case WM_IME_SYSTEM:
                switch (wParam) {
                    case IMS_CLOSEPROPERTYWINDOW:
                    case IMS_OPENPROPERTYWINDOW:
                        ImeSysPropertyWindow(hWnd, wParam, lParam);
                        break;
                    default:
                        return DefWindowProc( hWnd, Message, wParam, lParam );
                }
                break;

            case WM_CREATE:
                return Create(hWnd);
                break;

            case WM_DESTROY:
                DBGPRINT(("CONIME:Recieve WM_DESTROY\n"));
                ExitList(hWnd);
                PostQuitMessage(0);
                return 0;
                break;

            case WM_CLOSE:
                DBGPRINT(("CONIME:Recieve WM_CLOSE\n"));
                DestroyWindow(hWnd);
                return 0;
                break;

            case WM_ENABLE:{
                PCONSOLE_TABLE FocusedConsole;
                if (!wParam) {
                    FocusedConsole = SearchConsole(LastConsole);
                    if (FocusedConsole != NULL &&
                        FocusedConsole->hConsole != NULL) {
                        FocusedConsole->Enable = FALSE;
                        EnableWindow(FocusedConsole->hWndCon,FALSE);
                        gfDoNotKillFocus = TRUE;
                    }
                }
                else{
                    DWORD i;
                    LockConsoleTable();
                    for ( i = 1; i < NumberOfConsoleTable; i ++){
                        FocusedConsole = ConsoleTable[i];
                        if (FocusedConsole != NULL)
                        {
                            if ((FocusedConsole->hConsole != NULL)&&
                                (!FocusedConsole->Enable)&&
                                (!IsWindowEnabled(FocusedConsole->hWndCon))){
                                EnableWindow(FocusedConsole->hWndCon,TRUE);
                                FocusedConsole->Enable = TRUE;
                                if (!FocusedConsole->LateRemove)
                                    SetForegroundWindow(FocusedConsole->hWndCon);
                            }
                        }
                    }
                    UnlockConsoleTable();
                }
                return DefWindowProc(hWnd, Message, wParam, lParam);
                break;
            }

#ifdef DEBUG_MODE
            case WM_SETFOCUS:
                CreateCaret( hWnd,
                             NULL,
                             IsUnicodeFullWidth( ConvertLine[xPos] ) ?
                             CaretWidth*2 : CaretWidth,
                             (UINT)cyMetrics );
                SetCaretPos( xPos * cxMetrics, 0 );
                ShowCaret( hWnd );
                break;

            case WM_KILLFOCUS:
                HideCaret( hWnd );
                DestroyCaret();
                break;

            case WM_PAINT:
                {
                    PAINTSTRUCT pstruc;
                    HDC  hDC;
                    hDC = BeginPaint(hWnd,&pstruc);
                    ReDraw(hWnd);
                    EndPaint(hWnd,&pstruc);
                    break;
                }
#endif

            case WM_QUERYENDSESSION:
#ifdef HIRSHI_DEBUG
                /*
                 * If specified ntsd debugger on this process,
                 * then never catch WM_QUERYENDSESSION when logoff/shutdown because
                 * this process will terminate when ntsd process terminated.
                 */
                {
                    int i;
                    i = MessageBox(hWnd,TEXT("Could you approve exit session?"), TEXT("Console IME"),
                                   MB_ICONSTOP | MB_YESNO);
                    return (i == IDYES ? TRUE : FALSE);
                }
#endif
                return TRUE;           // Logoff or shutdown time.

            case WM_ENDSESSION:
                DBGPRINT(("CONIME:Recieve WM_ENDSESSION\n"));
                ExitList(hWnd);
                return 0;

            default:          // Passes it on if unproccessed
                return DefWindowProc(hWnd, Message, wParam, lParam);
        }

    } except (InputExceptionFilter(GetExceptionInformation())) {

        if (dwConsoleThreadId)
        {
            DBGPRINT(("CONIME: Exception on WndProc!!\n"));
            UnregisterConsoleIME();
            dwConsoleThreadId = 0;

            DestroyWindow(hWnd);
            return 0;
        }

    }


    return TRUE;
}


VOID
ExitList(
    HWND hWnd
    )
{
    ULONG i ,j;
    PCONSOLE_TABLE FocusedConsole;

    DBGPRINT(("CONIME:ExitList Processing\n"));
    ImmAssociateContext(hWnd,ghDefaultIMC);

    LockConsoleTable();

    for (i = 1; i < NumberOfConsoleTable; i++) {
        FocusedConsole = ConsoleTable[i];
        if (FocusedConsole != NULL)
        {
            if (FocusedConsole->hConsole != NULL) {
                if (FocusedConsole->Enable) {
                    ImmDestroyContext(FocusedConsole->hIMC_Original);
                    if ( FocusedConsole->lpCompStrMem != NULL) {
                        LocalFree( FocusedConsole->lpCompStrMem );
                        FocusedConsole->lpCompStrMem = NULL;
                    }
                    for (j = 0; j < MAX_LISTCAND; j++){
                        if (FocusedConsole->lpCandListMem[j] != NULL) {
                            LocalFree(FocusedConsole->lpCandListMem[j]);
                            FocusedConsole->lpCandListMem[j] = NULL;
                            FocusedConsole->CandListMemAllocSize[j] = 0;
                        }
                    }
                    if (FocusedConsole->CandSep != NULL) {
                        LocalFree(FocusedConsole->CandSep);
                        FocusedConsole->CandSepAllocSize = 0;
                    }
                    FocusedConsole->Enable = FALSE;
                }
                else
                    FocusedConsole->LateRemove = TRUE;
            }
        }
    }
    LocalFree( ConsoleTable );
    ConsoleTable = NULL;
    UnlockConsoleTable();

    if (dwConsoleThreadId)
    {
        AttachThreadInput(GetCurrentThreadId(), dwConsoleThreadId, FALSE);
        UnregisterConsoleIME();
        dwConsoleThreadId = 0;
    }
}

BOOL
InsertConsole(
    HWND    hWnd,
    HANDLE  hConsole,
    HWND    hWndConsole
    )
{
    ULONG i;
    PCONSOLE_TABLE FocusedConsole;

    i = 1;

    do {
        for (; i < NumberOfConsoleTable; i++) {
            FocusedConsole = ConsoleTable[i];

            if (FocusedConsole == NULL)
            {
                FocusedConsole = LocalAlloc(LPTR, sizeof(CONSOLE_TABLE));
                if (FocusedConsole == NULL)
                    return FALSE;
                ConsoleTable[i] = FocusedConsole;
            }

            if ((FocusedConsole->hConsole != NULL) &&
                (FocusedConsole->LateRemove)&&
                (FocusedConsole->Enable)) {
                RemoveConsoleWorker(hWnd, FocusedConsole);
            }

            if (FocusedConsole->hConsole == NULL) {
                RtlZeroMemory(FocusedConsole, sizeof(CONSOLE_TABLE));
                FocusedConsole->lphklList = LocalAlloc(LPTR, sizeof(HKL_TABLE)*HKL_INITIAL_TABLE);
                if (FocusedConsole->lphklList == NULL)
                {
                    return FALSE;
                }
                RtlZeroMemory(FocusedConsole->lphklList, sizeof(HKL_TABLE)*HKL_INITIAL_TABLE);
                FocusedConsole->hklListMax = HKL_INITIAL_TABLE ;

                FocusedConsole->hIMC_Current = ImmCreateContext();
                if (FocusedConsole->hIMC_Current == (HIMC)NULL) {
                    LocalFree(FocusedConsole);
                    FocusedConsole = NULL;
                    return FALSE;
                }

                FocusedConsole->hIMC_Original = FocusedConsole->hIMC_Current;
                FocusedConsole->hConsole      = hConsole;
                FocusedConsole->hWndCon       = hWndConsole;
//                FocusedConsole->hklActive     = NULL;
                FocusedConsole->Enable        = TRUE;
//                FocusedConsole->LateRemove    = FALSE;
//                FocusedConsole->fNestCandidate = FALSE;
//                FocusedConsole->fInComposition = FALSE;
//                FocusedConsole->fInCandidate = FALSE;
                FocusedConsole->ScreenBufferSize.X = DEFAULT_TEMP_WIDTH;

                FocusedConsole->CompAttrColor[0] = DEFAULT_COMP_ENTERED;
                FocusedConsole->CompAttrColor[1] = DEFAULT_COMP_ALREADY_CONVERTED;
                FocusedConsole->CompAttrColor[2] = DEFAULT_COMP_CONVERSION;
                FocusedConsole->CompAttrColor[3] = DEFAULT_COMP_YET_CONVERTED;
                FocusedConsole->CompAttrColor[4] = DEFAULT_COMP_INPUT_ERROR;
                FocusedConsole->CompAttrColor[5] = DEFAULT_COMP_INPUT_ERROR;
                FocusedConsole->CompAttrColor[6] = DEFAULT_COMP_INPUT_ERROR;
                FocusedConsole->CompAttrColor[7] = DEFAULT_COMP_INPUT_ERROR;

                GetIMEName(FocusedConsole);

                return TRUE;
            }
        }
    } while (GrowConsoleTable());

    DBGPRINT(("CONIME: Cannot grow Console Table\n"));
    return FALSE;
}

BOOL
GrowConsoleTable(
    VOID
    )
{
    PCONSOLE_TABLE *NewTable;
    PCONSOLE_TABLE *OldTable;
    ULONG MaxConsoleTable;

    MaxConsoleTable = NumberOfConsoleTable + CONSOLE_CONSOLE_TABLE_INCREMENT;
    NewTable = (PCONSOLE_TABLE *)LocalAlloc(LPTR, MaxConsoleTable * sizeof(PCONSOLE_TABLE));
    if (NewTable == NULL) {
        return FALSE;
    }
    CopyMemory(NewTable, ConsoleTable, NumberOfConsoleTable * sizeof(PCONSOLE_TABLE));

    OldTable = ConsoleTable;
    ConsoleTable = NewTable;
    NumberOfConsoleTable = MaxConsoleTable;

    LocalFree(OldTable);

    return TRUE;
}

PCONSOLE_TABLE
SearchConsole(
    HANDLE hConsole
    )
{
    ULONG i;
    PCONSOLE_TABLE FocusedConsole;

    LockConsoleTable();

    // conime receive ime message from console before 1st console registered.
    // this will happen after restart conime when conime dead by bogus ime's AV or 
    // other problem
    // so this fail safe code is  necessary to protect consrv.
    if (LastConsole == 0) {
        LastConsole = hConsole ;
    }

    for (i = 1; i < NumberOfConsoleTable; i++) {
        FocusedConsole = ConsoleTable[i];
        if (FocusedConsole != NULL)
        {
            if ((FocusedConsole->hConsole == hConsole)&&
                (!FocusedConsole->LateRemove)) {

                UnlockConsoleTable();
                return FocusedConsole;
            }
        }
    }
    UnlockConsoleTable();
    return NULL;
}

BOOL
RemoveConsole(
    HWND hwnd,
    HANDLE hConsole
    )
{
    PCONSOLE_TABLE ConTbl;
    BOOL ret;

    LockConsoleTable();

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL)
    {
        UnlockConsoleTable();
        return FALSE;
    }
    ret = RemoveConsoleWorker(hwnd, ConTbl);

    UnlockConsoleTable();
    return ret;
}

BOOL
RemoveConsoleWorker(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{
    DWORD j;

    if (ConTbl->Enable) {
        ConTbl->hConsole = NULL;
        ConTbl->ScreenBufferSize.X = 0;
        ConTbl->ConsoleCP = 0;
        ConTbl->ConsoleOutputCP = 0;
        ConTbl->hklActive = 0;

        ImmDestroyContext(ConTbl->hIMC_Original);

        if (ConTbl->lpCompStrMem != NULL){
            LocalFree(ConTbl->lpCompStrMem);
        }
        for (j = 0; j < MAX_LISTCAND; j++){
            if (ConTbl->lpCandListMem[j] != NULL) {
                LocalFree(ConTbl->lpCandListMem[j]);
            }
        }
        if (ConTbl->CandSep != NULL) {
            LocalFree(ConTbl->CandSep);
        }

        if (ConTbl->lphklList != NULL) {
            LocalFree(ConTbl->lphklList) ;
        }

        ConTbl->Enable     = FALSE;
        ConTbl->LateRemove = FALSE;
    }
    else
        ConTbl->LateRemove = TRUE;

#ifdef DEBUG_MODE
    InvalidateRect(hwnd,NULL,TRUE);
#endif
    return TRUE;
}

BOOL
InsertNewConsole(
    HWND   hWnd,
    HANDLE hConsole,
    HWND   hWndConsole
    )
{
    // conime receive ime message from console before 1st console registered.
    // this will happen after restart conime when conime dead by bogus ime's AV or 
    // other problem
    // so this fail safe code is  necessary to protect consrv.
    if (SearchConsole(hConsole) != NULL) {
        return TRUE;
    }

    LockConsoleTable();

    if (!InsertConsole(hWnd, hConsole, hWndConsole)) {
        UnlockConsoleTable();
        return FALSE;
    }

#ifdef DEBUG_MODE
    DisplayInformation(hWnd, hConsole);
#endif

    ImeUISetOpenStatus( hWndConsole );

    UnlockConsoleTable();

    return TRUE;
}


BOOL
ConsoleSetFocus(
    HWND hWnd,
    HANDLE hConsole,
    HKL hKL
    )
{
    PCONSOLE_TABLE ConTbl;
    HKL OldhKL;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    if ( gfDoNotKillFocus ){
        gfDoNotKillFocus = FALSE;
    }

    OldhKL = ConTbl->hklActive ;
    ConTbl->hklActive = hKL;
    ActivateKeyboardLayout(ConTbl->hklActive, 0);
    ImmAssociateContext(hWnd, ConTbl->hIMC_Current);

    if (OldhKL == 0) {
        GetIMEName( ConTbl );
        ConTbl->ImmGetProperty = ImmGetProperty(ConTbl->hklActive , IGP_PROPERTY);
    }

//v-hirshi Jun.13.1996 #if defined(LATER_DBCS)  // kazum
    ImmSetActiveContextConsoleIME(hWnd, TRUE);
//v-hirshi Jun.13.1996 #endif

    LastConsole = hConsole;

#ifdef DEBUG_MODE
    DisplayInformation(hWnd, hConsole);
#endif

    ImeUISetOpenStatus( hWnd );
    if (ConTbl->lpCompStrMem != NULL)
        ReDisplayCompositionStr( hWnd );

    return TRUE;
}

BOOL
ConsoleKillFocus(
    HWND hWnd,
    HANDLE hConsole
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    if ( gfDoNotKillFocus ){
        gfDoNotKillFocus = FALSE;
    }
    else{
//v-hirshi Jun.13.1996 #if defined(LATER_DBCS)  // kazum
        ImmSetActiveContextConsoleIME(hWnd, FALSE);
//v-hirshi Jun.13.1996 #endif
        ImmAssociateContext(hWnd, ghDefaultIMC);
    }

#ifdef DEBUG_MODE
    DisplayInformation(hWnd, hConsole);
#endif

    return TRUE;
}

BOOL
ConsoleScreenBufferSize(
    HWND hWnd,
    HANDLE hConsole,
    COORD ScreenBufferSize
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    ConTbl->ScreenBufferSize = ScreenBufferSize;
    return TRUE;
}

BOOL
ConImeInputLangchangeRequest(
    HWND hWnd,
    HANDLE hConsole,
    HKL hkl,
    int Direction
    )
{
    PCONSOLE_TABLE ConTbl;
    int nLayouts;
    LPHKL lphkl;
    DWORD RequiredLID = 0;
    int StartPos;
    int CurrentHklPos;
    int i;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: cannot find registered Console\n"));
        return FALSE;
    }

    switch (ConTbl->ConsoleOutputCP) {
        case JAPAN_CODEPAGE:
            RequiredLID = LANG_ID_JAPAN;
            break;
        case PRC_CODEPAGE:
            RequiredLID = LANG_ID_PRC;
            break;
        case KOREA_CODEPAGE:
            RequiredLID = LANG_ID_KOREA;
            break;
        case TAIWAN_CODEPAGE:
            RequiredLID = LANG_ID_TAIWAN;
            break;
        default:
            break;
    }

    if ( !IS_IME_KBDLAYOUT(hkl) ||
        ( HKL_TO_LANGID(hkl) == RequiredLID)) {
        return TRUE;
    }
    if (Direction == CONIME_DIRECT) {
        return FALSE;
    }

    nLayouts = GetKeyboardLayoutList(0, NULL);
    if (nLayouts == 0) {
        return FALSE;
    }
    lphkl = LocalAlloc(LPTR, nLayouts * sizeof(HKL));
    if (lphkl == NULL) {
        return FALSE;
    }
    GetKeyboardLayoutList(nLayouts, lphkl);

    for (CurrentHklPos = 0; CurrentHklPos < nLayouts; CurrentHklPos++) {
        if (ConTbl->hklActive == lphkl[CurrentHklPos] ) {
            break;
        }
    }
    if (CurrentHklPos >= nLayouts) {
        LocalFree(lphkl);
        return FALSE;
    }

    StartPos = CurrentHklPos;

    for (i = 0; i < nLayouts; i++) {
        StartPos+=Direction;
        if (StartPos < 0) {
            StartPos = nLayouts-1;
        }
        else if (StartPos >= nLayouts) {
            StartPos = 0;
        }
        
        if ((( HandleToUlong(lphkl[StartPos]) & 0xf0000000) == 0x00000000) ||
            (( HandleToUlong(lphkl[StartPos]) & 0x0000ffff) == RequiredLID)) {
            PostMessage( ConTbl->hWndCon,
                         CM_CONIME_KL_ACTIVATE,
                          HandleToUlong(lphkl[StartPos]),
                         0);
            LocalFree(lphkl);
            return FALSE;
        }
    }

    LocalFree(lphkl);
    return FALSE;

}

BOOL
ConImeInputLangchange(
    HWND hWnd,
    HANDLE hConsole,
    HKL hkl
    )
{
    PCONSOLE_TABLE ConTbl;
    LPCONIME_UIMODEINFO lpModeInfo;
    COPYDATASTRUCT CopyData;
    INT counter ;
    LPHKL_TABLE lphklListNew ;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        // cannot find specified console.
        // It might be last console lost focus.
        // try Last Console.
        ConTbl = SearchConsole(LastConsole);
        if (ConTbl == NULL) {
            DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
            return FALSE;
        }
    }

    if (ConTbl->lphklList == NULL) {
        return FALSE;
    }

    if (IS_IME_KBDLAYOUT(ConTbl->hklActive)) {
        for (counter = 0 ; counter < ConTbl->hklListMax ;counter ++) 
        {
            if (ConTbl->lphklList[counter].hkl == 0 || ConTbl->lphklList[counter].hkl == ConTbl->hklActive) {
                break;
            }
        }

        if (counter >= ConTbl->hklListMax)
        {
            ASSERT(counter == ConTbl->hklListMax);
            // reallocation
            lphklListNew = LocalAlloc(LPTR, sizeof(HKL_TABLE) * (ConTbl->hklListMax + HKL_TABLE_INCREMENT) ) ;
            if (lphklListNew != NULL)
            {
                CopyMemory(lphklListNew , ConTbl->lphklList , sizeof(HKL_TABLE) * ConTbl->hklListMax) ;
                ConTbl->hklListMax += HKL_TABLE_INCREMENT ;
                LocalFree(ConTbl->lphklList);
                ConTbl->lphklList = lphklListNew;
            }
            else {
                return FALSE ;
            }
        }
        ASSERT(ConTbl->lphklList != NULL);
        ConTbl->lphklList[counter].hkl = ConTbl->hklActive;
        ConTbl->lphklList[counter].dwConversion = ConTbl->dwConversion | (ConTbl->fOpen ? IME_CMODE_OPEN : 0)  ;
    }

    ActivateKeyboardLayout(hkl, 0);
    ConTbl->hklActive = hkl;
    GetIMEName( ConTbl );
    ImeUIOpenStatusWindow(hWnd);
    ConTbl->ImmGetProperty = ImmGetProperty(ConTbl->hklActive , IGP_PROPERTY);

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) ) ;
    if ( lpModeInfo == NULL) {
        return FALSE;
    }
    CopyData.dwData = CI_CONIMEMODEINFO ;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO) ;
    CopyData.lpData = lpModeInfo ;

    if (IS_IME_KBDLAYOUT(hkl)) {

        for (counter=0; counter < ConTbl->hklListMax ; counter++)
        {
            if (ConTbl->lphklList[counter].hkl == hkl)
            {
                SetNLSMode(hWnd, hConsole,ConTbl->lphklList[counter].dwConversion ) ;
                ImeUIOpenStatusWindow(hWnd) ;
                if (ImeUIMakeInfoString(ConTbl,
                                        lpModeInfo))
                {
                    ConsoleImeSendMessage( ConTbl->hWndCon,
                                           (WPARAM)hWnd,
                                           (LPARAM)&CopyData
                                         ) ;
                }
            }
        }
    }
    else
    {

        SetNLSMode(hWnd, hConsole,ConTbl->dwConversion & ~IME_CMODE_OPEN ) ;
        lpModeInfo->ModeStringLen = 0 ;
        lpModeInfo->Position = VIEW_RIGHT ;
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hWnd,
                               (LPARAM)&CopyData
                              ) ;
    }

    LocalFree( lpModeInfo );

    return TRUE;
}

BOOL
InputLangchange(
    HWND hWnd,
    DWORD CharSet,
    HKL hkl
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    ConTbl->hklActive = hkl;
    ActivateKeyboardLayout(ConTbl->hklActive, 0);
    GetIMEName( ConTbl );
    ImeUIOpenStatusWindow(hWnd);
    return TRUE;
}

/*
 * Console IME message pump.
 */
LRESULT
ConsoleImeSendMessage(
    HWND   hWndConsoleIME,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT lResult;
    LRESULT fNoTimeout;

    if (hWndConsoleIME == NULL)
    {
        return FALSE;
    }

    fNoTimeout = SendMessageTimeout(hWndConsoleIME,
                                    WM_COPYDATA,
                                    wParam,
                                    lParam,
                                    SMTO_ABORTIFHUNG | SMTO_NORMAL,
                                    CONIME_SENDMSG_TIMEOUT,
                                    &lResult);

    if (fNoTimeout)
    {
        return TRUE;
    }


    /*
     * ConsoleImeMessagePump give up SendMessage to conime.
     * CONIME is hung up.
     * probably, consrv also hung up.
     */
    KdPrint(("ConsoleImeSendMessage: CONIME_SENDMSG_COUNT is hung up\n"));

    return FALSE;

}

#ifdef DEBUG_MODE

int             cxMetrics;
int             cyMetrics;
int             cxOverTypeCaret;
int             xPos;
int             xPosLast;
int             CaretWidth;                     // insert/overtype mode caret width

WCHAR           ConvertLine[CVMAX];
unsigned char   ConvertLineAtr[CVMAX];

WCHAR           DispTitle[] = TEXT(" Console Handle");

DWORD CompColor[ 8 ] = { RGB(   0,   0,   0 ),  // ATTR_INPUT
                         RGB(   0,   0, 255 ),  // ATTR_TARGET_CONVERTED
                         RGB(   0, 255,   0 ),  // ATTR_CONVERTED
                         RGB( 255,   0,   0 ),  // ATTR_TARGET_NOTCONVERTED
                         RGB( 255,   0, 255 ),  // ATTR_INPUT_ERROR
                         RGB(   0, 255, 255 ),  // ATTR_DEFAULT
                         RGB( 255, 255,   0 ),  // ATTR_DEFAULT
                         RGB( 255, 255, 255 ) };// ATTR_DEFAULT

VOID
DisplayConvInformation(
    HWND hWnd
    )
{
    RECT      Rect;
    HDC       lhdc;

    lhdc = GetDC(hWnd);
    GetClientRect(hWnd, &Rect);

    InvalidateRect(hWnd,NULL,FALSE);
    UpdateWindow(hWnd);
    ReleaseDC(hWnd, lhdc);
}

VOID
DisplayInformation(
    HWND hWnd,
    HANDLE hConsole
    )
{
    PCONSOLE_TABLE ConTbl;
    RECT      Rect;
    HDC       lhdc;

    ConTbl = SearchConsole(hConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    lhdc = GetDC(hWnd);
    GetClientRect(hWnd, &Rect);

    wsprintf(ConTbl->DispBuf, TEXT("%08x"), (ULONG)hConsole);

    InvalidateRect(hWnd,NULL,FALSE);
    UpdateWindow(hWnd);
    ReleaseDC(hWnd, lhdc);
}

VOID
RealReDraw(
    HDC r_hdc
    )
{
    PCONSOLE_TABLE ConTbl;
    INT     ix, iy, i, rx, sx;
    ULONG   cnt;
    int     ColorIndex;
    int     PrevColorIndex;
    DWORD   dwColor;

    iy = 0;

    dwColor = GetTextColor( r_hdc );

    ColorIndex = ( ((int)ConvertLineAtr[0]) < 0 ) ? 0 : (int)ConvertLineAtr[0];
    ColorIndex = ( ColorIndex > 7 ) ? 0 : ColorIndex;
    PrevColorIndex = ColorIndex;
    SetTextColor( r_hdc, CompColor[ ColorIndex ] );

    rx = 0;
    sx = 0;
    for (ix = 0; ix < MAXCOL; ) {
        for (i = ix; i < MAXCOL; i++) {
            if (PrevColorIndex != (int)ConvertLineAtr[i])
                break;
            rx += IsUnicodeFullWidth(ConvertLine[ix]) ? 2 : 1;
        }
        TextOut( r_hdc, sx * cxMetrics, iy, &ConvertLine[ix], i-ix );
        sx = rx;
        ColorIndex = ( ((int)ConvertLineAtr[i]) < 0 ) ? 0 : (int)ConvertLineAtr[i];
        ColorIndex = ( ColorIndex > 7 ) ? 0 : ColorIndex;
        PrevColorIndex = ColorIndex;
        SetTextColor( r_hdc, CompColor[ ColorIndex ] );
        ix = i;
    }

    ix = 0;
    SetTextColor( r_hdc, dwColor );
    iy += cyMetrics;
    TextOut( r_hdc, ix, iy, DispTitle, lstrlenW(DispTitle));

    iy += cyMetrics;

    LockConsoleTable();

    for (cnt = 1; cnt < NumberOfConsoleTable; cnt++, iy += cyMetrics){
        ConTbl = ConsoleTable[cnt];
        if (ConTbl != NULL)
        {
            if (ConTbl->hConsole)
            {
                TextOut( r_hdc, ix, iy, ConTbl->DispBuf, lstrlenW(ConTbl->DispBuf) );
            }
        }
    }

    UnlockConsoleTable();

    return;
}

VOID
ReDraw(
    HWND hWnd
    )
{
    HDC r_hdc;
    RECT ClientRect;

    GetClientRect(hWnd, &ClientRect);
    r_hdc = GetDC(hWnd);
    FillRect(r_hdc, &ClientRect, GetStockObject(WHITE_BRUSH));
    RealReDraw(r_hdc);
    ReleaseDC(hWnd, r_hdc);
    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\country3.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   country3.c
//
//  PURPOSE:   Console IME control.
//             FarEast country specific module for conime.
//
//  PLATFORMS: Windows NT-FE 3.51
//
//  FUNCTIONS:
//    GetCompositionStr() - routine for Get Composition String
//    ReDisplayCompositionStr() - foutine for re-Display Composition String
//
//  History:
//
//  17.Jul.1996 v-HirShi (Hirotoshi Shimizu)    Created for TAIWAN & KOREA & PRC
//
//  COMMENTS:
//
#include "precomp.h"
#pragma hdrstop

//**********************************************************************
//
// void GetCompositionStr()
//
// This handles WM_IME_COMPOSITION message with GCS_COMPSTR flag on.
//
//**********************************************************************

void
GetCompositionStr(
    HWND hwnd,
    LPARAM CompFlag,
    WPARAM CompChar
    )
{
    PCONSOLE_TABLE ConTbl;

    DBGPRINT(("CONIME: GetCompositionStr\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    switch (ConTbl->ConsoleOutputCP)
    {
        case    JAPAN_CODEPAGE:
            GetCompStrJapan(hwnd, ConTbl, CompFlag);
            break;
        case    TAIWAN_CODEPAGE:
            GetCompStrTaiwan(hwnd, ConTbl, CompFlag);
            break;
        case    PRC_CODEPAGE:
            GetCompStrPRC(hwnd, ConTbl, CompFlag);
            break;
        case    KOREA_CODEPAGE:
            GetCompStrKorea(hwnd, ConTbl, CompFlag, CompChar);
            break;
        default:
            break;
    }
    return;

}

void
GetCompStrJapan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    )
{
    HIMC        hIMC;                   // Input context handle.
    LONG        lBufLen;                // Storage for len. of composition str
    LONG        lBufLenAttr;
    COPYDATASTRUCT CopyData;
    DWORD       SizeToAlloc;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    DWORD       i;
    DWORD       CursorPos;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    //
    // If fail to get input context handle then do nothing.
    // Applications should call ImmGetContext API to get
    // input context handle.
    //
    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
         return;

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Determines how much memory space to store the composition string.
        // Applications should call ImmGetCompositionString with
        // GCS_COMPSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, (void FAR*)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        if ( CompFlag & GCS_COMPATTR )
        {
            DBGPRINT(("                           GCS_COMPATTR\n"));
            lBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR,( void FAR *)NULL, 0l );
            if ( lBufLenAttr < 0 ) {
                lBufLenAttr = 0;
            }
        }
        else {
            lBufLenAttr = 0;
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Determines how much memory space to store the result string.
        // Applications should call ImmGetCompositionString with
        // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, (void FAR *)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        lBufLenAttr = 0;
    }
    else if (CompFlag == 0)
    {
        lBufLen = 0;
        lBufLenAttr = 0;
    }

    SizeToAlloc = (UINT)( sizeof(CONIME_UICOMPMESSAGE) +
                          lBufLen     + sizeof(WCHAR) +
                          lBufLenAttr + sizeof(BYTE)   );

    if ( ConTbl->lpCompStrMem != NULL &&
         SizeToAlloc > ConTbl->lpCompStrMem->dwSize
       )
    {
        LocalFree( ConTbl->lpCompStrMem );
        ConTbl->lpCompStrMem = NULL;
    }

    if (ConTbl->lpCompStrMem == NULL) {
        ConTbl->lpCompStrMem = (LPCONIME_UICOMPMESSAGE)LocalAlloc(LPTR, SizeToAlloc );
        if ( ConTbl->lpCompStrMem == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        ConTbl->lpCompStrMem->dwSize = SizeToAlloc;
    }

    lpCompStrMem = ConTbl->lpCompStrMem;
    RtlZeroMemory(&lpCompStrMem->dwCompAttrLen,
                  lpCompStrMem->dwSize - sizeof(lpCompStrMem->dwSize)
                 );

    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lBufLen +  sizeof(WCHAR));

    CopyMemory(lpCompStrMem->CompAttrColor , ConTbl->CompAttrColor , 8 * sizeof(WCHAR));

    CopyData.dwData = CI_CONIMECOMPOSITION;
    CopyData.cbData = lpCompStrMem->dwSize;
    CopyData.lpData = lpCompStrMem;

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Reads in the composition string.
        //
        ImmGetCompositionString( hIMC, GCS_COMPSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        //
        // If GCS_COMPATTR flag is on, then we need to take care of it.
        //
        if ( lBufLenAttr != 0 )
        {
            ImmGetCompositionString( hIMC,
                                     GCS_COMPATTR,
                                     TempBufA,
                                     lBufLenAttr );
            TempBufA[ lBufLenAttr ] = (BYTE)0;
        }

        CursorPos = ImmGetCompositionString( hIMC, GCS_CURSORPOS, NULL, 0 );
        if (CursorPos == 0)
            TempBufA[ CursorPos ]   |= (BYTE)0x20;
        else
            TempBufA[ CursorPos-1 ] |= (BYTE)0x10;

#ifdef DEBUG_INFO
        //
        // Display new composition chars.
        //
        xPos = (UINT)lBufLen;
        xPosLast = (UINT)lBufLen;

        DisplayCompString( hwnd, lBufLen / sizeof(WCHAR), TempBuf, TempBufA );
#endif

        lpCompStrMem->dwCompStrLen      = lBufLen;
        if (lpCompStrMem->dwCompStrLen)
            lpCompStrMem->dwCompStrOffset = sizeof(CONIME_UICOMPMESSAGE);

        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        if (lpCompStrMem->dwCompAttrLen)
            lpCompStrMem->dwCompAttrOffset = sizeof(CONIME_UICOMPMESSAGE) + lBufLen +  sizeof(WCHAR);
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Reads in the result string.
        //
        ImmGetCompositionString( hIMC, GCS_RESULTSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

#ifdef DEBUG_INFO
        //
        // Displays the result string.
        //
        DisplayResultString( hwnd, TempBuf );
#endif

        lpCompStrMem->dwResultStrLen    = lBufLen;
        if (lpCompStrMem->dwResultStrLen)
            lpCompStrMem->dwResultStrOffset = sizeof(CONIME_UICOMPMESSAGE);
    }
    else if (CompFlag == 0)
    {
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        TempBufA[ lBufLenAttr ] = (BYTE)0;
        lpCompStrMem->dwResultStrLen    = lBufLen;
        lpCompStrMem->dwCompStrLen      = lBufLen;
        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
    }

    //
    // send character to Console
    //
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

    ImmReleaseContext( hwnd, hIMC );

}


void
GetCompStrTaiwan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    )
{
    HIMC        hIMC;                   // Input context handle.
    LONG        lBufLen;               // Storage for len. of composition str
    LONG        lBufLenAttr;
    DWORD       SizeToAlloc;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    DWORD       i;
    DWORD       CursorPos;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    //
    // If fail to get input context handle then do nothing.
    // Applications should call ImmGetContext API to get
    // input context handle.
    //
    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
        return;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        ImmReleaseContext( hwnd, hIMC );
        return;
    }

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Determines how much memory space to store the composition string.
        // Applications should call ImmGetCompositionString with
        // GCS_COMPSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, (void FAR*)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        if ( CompFlag & GCS_COMPATTR )
        {
            DBGPRINT(("                           GCS_COMPATTR\n"));
            lBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR,( void FAR *)NULL, 0l );
            if ( lBufLenAttr < 0 ) {
                lBufLenAttr = 0;
            }
        }
        else {
            lBufLenAttr = 0;
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Determines how much memory space to store the result string.
        // Applications should call ImmGetCompositionString with
        // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, (void FAR *)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        lBufLenAttr = 0;
    }
    else if (CompFlag == 0)
    {
        lBufLen = 0;
        lBufLenAttr = 0;
    }

    SizeToAlloc = (UINT)( sizeof(CONIME_UICOMPMESSAGE) +
                          lBufLen     + sizeof(WCHAR) +
                          lBufLenAttr + sizeof(BYTE)   );

    if ( ConTbl->lpCompStrMem != NULL &&
         SizeToAlloc > ConTbl->lpCompStrMem->dwSize
       )
    {
        LocalFree( ConTbl->lpCompStrMem );
        ConTbl->lpCompStrMem = NULL;
    }

    if (ConTbl->lpCompStrMem == NULL) {
        ConTbl->lpCompStrMem = (LPCONIME_UICOMPMESSAGE)LocalAlloc(LPTR, SizeToAlloc );
        if ( ConTbl->lpCompStrMem == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        ConTbl->lpCompStrMem->dwSize = SizeToAlloc;
    }

    lpCompStrMem = ConTbl->lpCompStrMem;
    RtlZeroMemory(&lpCompStrMem->dwCompAttrLen,
                  lpCompStrMem->dwSize - sizeof(lpCompStrMem->dwSize)
                 );

    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lBufLen +  sizeof(WCHAR));

    CopyMemory(lpCompStrMem->CompAttrColor , ConTbl->CompAttrColor , 8 * sizeof(WCHAR));

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Reads in the composition string.
        //
        ImmGetCompositionString( hIMC, GCS_COMPSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        //
        // If GCS_COMPATTR flag is on, then we need to take care of it.
        //
        if ( lBufLenAttr != 0 )
        {
            ImmGetCompositionString( hIMC,
                                     GCS_COMPATTR,
                                     TempBufA,
                                     lBufLenAttr );
            TempBufA[ lBufLenAttr ] = (BYTE)0;
        }

        lpCompStrMem->dwCompStrLen      = lBufLen;
        if (lpCompStrMem->dwCompStrLen)
            lpCompStrMem->dwCompStrOffset = sizeof(CONIME_UICOMPMESSAGE);

        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        if (lpCompStrMem->dwCompAttrLen)
            lpCompStrMem->dwCompAttrOffset = sizeof(CONIME_UICOMPMESSAGE) + lBufLen +  sizeof(WCHAR);
        //
        // Display character to Console
        //
        CopyData.dwData = CI_CONIMEMODEINFO;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO);
        CopyData.lpData = lpModeInfo;

        if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Reads in the result string.
        //
        ImmGetCompositionString( hIMC, GCS_RESULTSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        lpCompStrMem->dwResultStrLen    = lBufLen;
        if (lpCompStrMem->dwResultStrLen)
            lpCompStrMem->dwResultStrOffset = sizeof(CONIME_UICOMPMESSAGE);
        //
        // send character to Console
        //
        CopyData.dwData = CI_CONIMECOMPOSITION;
        CopyData.cbData = lpCompStrMem->dwSize;
        CopyData.lpData = lpCompStrMem;
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              );

    }
    else if (CompFlag == 0)
    {
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        TempBufA[ lBufLenAttr ] = (BYTE)0;
        lpCompStrMem->dwResultStrLen    = lBufLen;
        lpCompStrMem->dwCompStrLen      = lBufLen;
        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        //
        // Display character to Console
        //
        CopyData.dwData = CI_CONIMEMODEINFO;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO);
        CopyData.lpData = lpModeInfo;

        if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }


    LocalFree( lpModeInfo );

    ImmReleaseContext( hwnd, hIMC );
    return;

}

void
GetCompStrPRC(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag
    )
{
    HIMC        hIMC;                   // Input context handle.
    LONG        lBufLen;                // Storage for len. of composition str
    LONG        lBufLenAttr;
    DWORD       SizeToAlloc;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    DWORD       i;
    DWORD       CursorPos;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    //
    // If fail to get input context handle then do nothing.
    // Applications should call ImmGetContext API to get
    // input context handle.
    //
    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
        return;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        ImmReleaseContext( hwnd, hIMC );
        return;
    }

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Determines how much memory space to store the composition string.
        // Applications should call ImmGetCompositionString with
        // GCS_COMPSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, (void FAR*)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        if ( CompFlag & GCS_COMPATTR )
        {
            DBGPRINT(("                           GCS_COMPATTR\n"));
            lBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR,( void FAR *)NULL, 0l );
            if ( lBufLenAttr < 0 ) {
                lBufLenAttr = 0;
            }
        }
        else {
            lBufLenAttr = 0;
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Determines how much memory space to store the result string.
        // Applications should call ImmGetCompositionString with
        // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, (void FAR *)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        lBufLenAttr = 0;
    }
    else if (CompFlag == 0)
    {
        lBufLen = 0;
        lBufLenAttr = 0;
    }

    SizeToAlloc = (UINT)( sizeof(CONIME_UICOMPMESSAGE) +
                          lBufLen     + sizeof(WCHAR) +
                          lBufLenAttr + sizeof(BYTE)   );

    if ( ConTbl->lpCompStrMem != NULL &&
         SizeToAlloc > ConTbl->lpCompStrMem->dwSize
       )
    {
        LocalFree( ConTbl->lpCompStrMem );
        ConTbl->lpCompStrMem = NULL;
    }

    if (ConTbl->lpCompStrMem == NULL) {
        ConTbl->lpCompStrMem = (LPCONIME_UICOMPMESSAGE)LocalAlloc(LPTR, SizeToAlloc );
        if ( ConTbl->lpCompStrMem == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        ConTbl->lpCompStrMem->dwSize = SizeToAlloc;
    }

    lpCompStrMem = ConTbl->lpCompStrMem;
    RtlZeroMemory(&lpCompStrMem->dwCompAttrLen,
                  lpCompStrMem->dwSize - sizeof(lpCompStrMem->dwSize)
                 );

    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lBufLen +  sizeof(WCHAR));

    CopyMemory(lpCompStrMem->CompAttrColor , ConTbl->CompAttrColor , 8 * sizeof(WCHAR));

    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Reads in the composition string.
        //
        ImmGetCompositionString( hIMC, GCS_COMPSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        //
        // If GCS_COMPATTR flag is on, then we need to take care of it.
        //
        if ( lBufLenAttr != 0 )
        {
            ImmGetCompositionString( hIMC,
                                     GCS_COMPATTR,
                                     TempBufA,
                                     lBufLenAttr );
            TempBufA[ lBufLenAttr ] = (BYTE)0;
        }

        lpCompStrMem->dwCompStrLen      = lBufLen;
        if (lpCompStrMem->dwCompStrLen)
            lpCompStrMem->dwCompStrOffset = sizeof(CONIME_UICOMPMESSAGE);

        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        if (lpCompStrMem->dwCompAttrLen)
            lpCompStrMem->dwCompAttrOffset = sizeof(CONIME_UICOMPMESSAGE) + lBufLen +  sizeof(WCHAR);
        //
        // Display character to Console
        //
        CopyData.dwData = CI_CONIMEMODEINFO;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO);
        CopyData.lpData = lpModeInfo;

        if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Reads in the result string.
        //
        ImmGetCompositionString( hIMC, GCS_RESULTSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        lpCompStrMem->dwResultStrLen    = lBufLen;
        if (lpCompStrMem->dwResultStrLen)
            lpCompStrMem->dwResultStrOffset = sizeof(CONIME_UICOMPMESSAGE);
        //
        // send character to Console
        //
        CopyData.dwData = CI_CONIMECOMPOSITION;
        CopyData.cbData = lpCompStrMem->dwSize;
        CopyData.lpData = lpCompStrMem;
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                              );

    }
    else if (CompFlag == 0)
    {
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        TempBufA[ lBufLenAttr ] = (BYTE)0;
        lpCompStrMem->dwResultStrLen    = lBufLen;
        lpCompStrMem->dwCompStrLen      = lBufLen;
        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        //
        // Display character to Console
        //
        CopyData.dwData = CI_CONIMEMODEINFO;
        CopyData.cbData = sizeof(CONIME_UIMODEINFO);
        CopyData.lpData = lpModeInfo;

        if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }


    LocalFree( lpModeInfo );

    ImmReleaseContext( hwnd, hIMC );
    return;

}

void
GetCompStrKorea(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl,
    LPARAM CompFlag,
    WPARAM CompChar
    )
{
    HIMC        hIMC;                   // Input context handle.
    LONG        lBufLen;                // Storage for len. of composition str
    LONG        lBufLenAttr;
    COPYDATASTRUCT CopyData;
    DWORD       SizeToAlloc;
    PWCHAR      TempBuf;
    PUCHAR      TempBufA;
    LONG        i;
    DWORD       CursorPos;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    //
    // If fail to get input context handle then do nothing.
    // Applications should call ImmGetContext API to get
    // input context handle.
    //
    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
         return;

//    if (CompFlag & CS_INSERTCHAR)
//    {
//        lBufLen = 1;
//        lBufLenAttr = 1;
//    }
//    else
    if (CompFlag & GCS_COMPSTR)
    {
        //
        // Determines how much memory space to store the composition string.
        // Applications should call ImmGetCompositionString with
        // GCS_COMPSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_COMPSTR, (void FAR*)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        if ( CompFlag & GCS_COMPATTR )
        {
            DBGPRINT(("                           GCS_COMPATTR\n"));
            lBufLenAttr = ImmGetCompositionString( hIMC, GCS_COMPATTR,( void FAR *)NULL, 0l );
            if ( lBufLenAttr < 0 ) {
                lBufLenAttr = 0;
            }
        }
        else {
            lBufLenAttr = lBufLen;
        }
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Determines how much memory space to store the result string.
        // Applications should call ImmGetCompositionString with
        // GCS_RESULTSTR flag on, buffer length zero, to get the bullfer
        // length.
        //
        lBufLen = ImmGetCompositionString( hIMC, GCS_RESULTSTR, (void FAR *)NULL, 0l );
        if ( lBufLen < 0 ) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        lBufLenAttr = 0;
    }
    else if (CompFlag == 0)
    {
        lBufLen = 0;
        lBufLenAttr = 0;
    }
    else
    {
        return;
    }

    SizeToAlloc = (UINT)( sizeof(CONIME_UICOMPMESSAGE) +
                          lBufLen     + sizeof(WCHAR) +
                          lBufLenAttr + sizeof(BYTE)   );

    if ( ConTbl->lpCompStrMem != NULL &&
         SizeToAlloc > ConTbl->lpCompStrMem->dwSize
       )
    {
        LocalFree( ConTbl->lpCompStrMem );
        ConTbl->lpCompStrMem = NULL;
    }

    if (ConTbl->lpCompStrMem == NULL) {
        ConTbl->lpCompStrMem = (LPCONIME_UICOMPMESSAGE)LocalAlloc(LPTR, SizeToAlloc );
        if ( ConTbl->lpCompStrMem == NULL) {
            ImmReleaseContext( hwnd, hIMC );
            return;
        }
        ConTbl->lpCompStrMem->dwSize = SizeToAlloc;
    }

    lpCompStrMem = ConTbl->lpCompStrMem;
    RtlZeroMemory(&lpCompStrMem->dwCompAttrLen,
                  lpCompStrMem->dwSize - sizeof(lpCompStrMem->dwSize)
                 );

    TempBuf  = (PWCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE));
    TempBufA = (PUCHAR)((PUCHAR)lpCompStrMem + sizeof(CONIME_UICOMPMESSAGE) +
                       lBufLen +  sizeof(WCHAR));

    CopyMemory(lpCompStrMem->CompAttrColor , ConTbl->CompAttrColor , 8 * sizeof(WCHAR));

    CopyData.dwData = CI_CONIMECOMPOSITION;
    CopyData.cbData = lpCompStrMem->dwSize;
    CopyData.lpData = lpCompStrMem;

    if (CompFlag & CS_INSERTCHAR)
    {
        *TempBuf = (WORD)CompChar;
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        *TempBufA = (BYTE)ATTR_TARGET_CONVERTED;
        TempBufA[ lBufLenAttr ] = (BYTE)0;
    }
    else if (CompFlag & GCS_COMPSTR)
    {
        //
        // Reads in the composition string.
        //
        ImmGetCompositionString( hIMC, GCS_COMPSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

        //
        // If GCS_COMPATTR flag is on, then we need to take care of it.
        //
        if ( lBufLenAttr != 0 )
        {
            if ( CompFlag & GCS_COMPATTR )
            {
                ImmGetCompositionString( hIMC,
                                         GCS_COMPATTR,
                                         TempBufA,
                                         lBufLenAttr );
                TempBufA[ lBufLenAttr ] = (BYTE)0;
            }
            else
            {
                for (i = 0; i <= lBufLenAttr; i++)
                    TempBufA[ i ] = (BYTE)1;
            }
        }

// Korean  NT does not need IME cursor. v-hirshi
//        CursorPos = ImmGetCompositionString( hIMC, GCS_CURSORPOS, NULL, 0 );
//        if (CursorPos == 0)
//            TempBufA[ CursorPos ]   |= (BYTE)0x20;
//        else
//            TempBufA[ CursorPos-1 ] |= (BYTE)0x10;

#ifdef DEBUG_INFO
        //
        // Display new composition chars.
        //
        xPos = (UINT)lBufLen;
        xPosLast = (UINT)lBufLen;

        DisplayCompString( hwnd, lBufLen / sizeof(WCHAR), TempBuf, TempBufA );
#endif

        lpCompStrMem->dwCompStrLen      = lBufLen;
        if (lpCompStrMem->dwCompStrLen)
            lpCompStrMem->dwCompStrOffset = sizeof(CONIME_UICOMPMESSAGE);

        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
        if (lpCompStrMem->dwCompAttrLen)
            lpCompStrMem->dwCompAttrOffset = sizeof(CONIME_UICOMPMESSAGE) + lBufLen +  sizeof(WCHAR);
    }
    else if (CompFlag & GCS_RESULTSTR)
    {
        //
        // Reads in the result string.
        //
        ImmGetCompositionString( hIMC, GCS_RESULTSTR, TempBuf, lBufLen );

        //
        // Null terminated.
        //
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');

#ifdef DEBUG_INFO
        //
        // Displays the result string.
        //
        DisplayResultString( hwnd, TempBuf );
#endif

        lpCompStrMem->dwResultStrLen    = lBufLen;
        if (lpCompStrMem->dwResultStrLen)
            lpCompStrMem->dwResultStrOffset = sizeof(CONIME_UICOMPMESSAGE);
    }
    else if (CompFlag == 0)
    {
        TempBuf[ lBufLen / sizeof(WCHAR) ] = TEXT('\0');
        TempBufA[ lBufLenAttr ] = (BYTE)0;
        lpCompStrMem->dwResultStrLen    = lBufLen;
        lpCompStrMem->dwCompStrLen      = lBufLen;
        lpCompStrMem->dwCompAttrLen     = lBufLenAttr;
    }

    //
    // send character to Console
    //
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

    ImmReleaseContext( hwnd, hIMC );

}

VOID
ReDisplayCompositionStr (
    HWND hwnd
    )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    if (! ConTbl->fInComposition)
       return;

    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            ReDisplayCompStrJapan(hwnd, ConTbl);
            break;
        case    LANG_ID_TAIWAN:
            ReDisplayCompStrTaiwan(hwnd, ConTbl);
            break;
        case    LANG_ID_PRC:
            ReDisplayCompStrPRC(hwnd, ConTbl);
            break;
        case    LANG_ID_KOREA:
            ReDisplayCompStrKorea(hwnd, ConTbl);
            break;
        default:
            break;
    }
    return;
}

VOID
ReDisplayCompStrJapan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{
    COPYDATASTRUCT CopyData;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    lpCompStrMem = ConTbl->lpCompStrMem;
    CopyData.dwData = CI_CONIMECOMPOSITION;
    CopyData.cbData = lpCompStrMem->dwSize;
    CopyData.lpData = lpCompStrMem;
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );
}

VOID
ReDisplayCompStrTaiwan(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return;
    }
    //
    // Display character to Console
    //
    CopyData.dwData = CI_CONIMEMODEINFO;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO);
    CopyData.lpData = lpModeInfo;

    if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             );
    }

    LocalFree( lpModeInfo );
}

VOID
ReDisplayCompStrPRC(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc(LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return;
    }
    //
    // Display character to Console
    //
    CopyData.dwData = CI_CONIMEMODEINFO;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO);
    CopyData.lpData = lpModeInfo;

    if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             );
    }
    LocalFree( lpModeInfo );
}

VOID
ReDisplayCompStrKorea(
    HWND hwnd,
    PCONSOLE_TABLE ConTbl
    )
{

    COPYDATASTRUCT CopyData;
    LPCONIME_UICOMPMESSAGE lpCompStrMem;

    lpCompStrMem = ConTbl->lpCompStrMem;
    CopyData.dwData = CI_CONIMECOMPOSITION;
    CopyData.cbData = lpCompStrMem->dwSize;
    CopyData.lpData = lpCompStrMem;
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\country2.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   country2.c
//
//  PURPOSE:   Console IME control.
//             FarEast country specific module 2 for conime.
//
//  PLATFORMS: Windows NT-FE 3.51
//
//  FUNCTIONS:
//    ImeUIOpenCandidate() - routine for make system line string
//
//  History:
//
//  15.Jul.1996 v-HirShi (Hirotoshi Shimizu)    Created for TAIWAN & KOREA & PRC
//
//  COMMENTS:
//
#include "precomp.h"
#pragma hdrstop


BOOL
ImeUIOpenCandidate(
    HWND hwnd,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    PCONSOLE_TABLE ConTbl;
    HIMC  hIMC;

    DBGPRINT(("CONIME: Get IMN_OPENCANDIDATE Message\n"));


    ConTbl = SearchConsole(LastConsole);

    if (ConTbl->fNestCandidate)
        return TRUE;

    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
        return FALSE;

    //
    // Set fInCandidate variables.
    //
    ConTbl->fInCandidate = TRUE;

    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            OpenCandidateJapan(hwnd, hIMC, ConTbl, CandList, OpenFlag );
            break;
        case    LANG_ID_TAIWAN:
            OpenCandidateTaiwan(hwnd, hIMC, ConTbl, CandList, OpenFlag );
            break;
        case    LANG_ID_PRC:
            OpenCandidatePRC(hwnd, hIMC, ConTbl, CandList, OpenFlag );
            break;
        case    LANG_ID_KOREA:
            OpenCandidateKorea(hwnd, hIMC, ConTbl, CandList, OpenFlag );
            break;
        default:
            return FALSE;
    }

    ImmReleaseContext( hwnd, hIMC );

    return TRUE;
}


BOOL
OpenCandidateJapan(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    DWORD dwLength;
    DWORD dwIndex;
    DWORD i;
    DWORD j;
    LPWSTR lpStr;
    DWORD dwDspLen;
    DWORD width;
    DWORD StartIndex;
    DWORD CountDispWidth;
    DWORD AllocLength;
    LPCANDIDATELIST lpCandList;
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    COPYDATASTRUCT CopyData;
    BOOL EnableCodePoint;

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            dwLength = ImmGetCandidateList(hIMC, dwIndex, NULL, 0);
            if (dwLength == 0)
                return FALSE;
            if ( (ConTbl->CandListMemAllocSize[dwIndex] != dwLength ) &&
                 (ConTbl->lpCandListMem[dwIndex] != NULL)) {
                LocalFree(ConTbl->lpCandListMem[dwIndex]);
                ConTbl->CandListMemAllocSize[dwIndex] = 0;
                ConTbl->lpCandListMem[dwIndex] = NULL;
            }
            if (ConTbl->lpCandListMem[dwIndex] == NULL) {
                ConTbl->lpCandListMem[dwIndex] = LocalAlloc(LPTR, dwLength);
                if (ConTbl->lpCandListMem[dwIndex] == NULL)
                    return FALSE;
                ConTbl->CandListMemAllocSize[dwIndex] = dwLength;
            }
            lpCandList = ConTbl->lpCandListMem[dwIndex];
            ImmGetCandidateList(hIMC, dwIndex, lpCandList, dwLength);

            //
            // check each offset value is not over than buffer size.
            //
            if ((lpCandList->dwCount > 1) &&
                (lpCandList->dwSelection >= dwLength ||
                 lpCandList->dwPageStart >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwSelection] >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwPageStart] >= dwLength    )
               )
                break;

            dwLength = ConTbl->ScreenBufferSize.X;
            dwLength = (dwLength > 128) ? 128 : dwLength ;
            dwLength = ((dwLength < 12) ? 12 : dwLength );

            j = (dwLength-7)/(DELIMITERWIDTH+sizeof(WCHAR));
            j = ((j > 9)?9:j);
            j = lpCandList->dwCount / j + 10;
            AllocLength = (j > DEFAULTCANDTABLE) ? j : DEFAULTCANDTABLE;

            if (lpCandList->dwStyle == IME_CAND_CODE){
                EnableCodePoint = TRUE;
            }
            else{
                EnableCodePoint = FALSE;
            }

            if (EnableCodePoint){
                CountDispWidth = CODEDISPLEN;
            }
            else {
                for (CountDispWidth = 0 ,j = 1; j <= lpCandList->dwCount; CountDispWidth++)
                     j *= 10;
                CountDispWidth *= 2;
                CountDispWidth++;
            }

            if ((ConTbl->CandSepAllocSize != sizeof(DWORD)*AllocLength) &&
                (ConTbl->CandSep != NULL)) {
                LocalFree(ConTbl->CandSep);
                ConTbl->CandSep = NULL;
                ConTbl->CandSepAllocSize = 0;
            }
            if (ConTbl->CandSep == NULL) {
                ConTbl->CandSep= LocalAlloc(LPTR, sizeof(DWORD)*AllocLength);
                if (ConTbl->CandSep == NULL)
                    return FALSE;
                ConTbl->CandSepAllocSize = sizeof(DWORD)*AllocLength;
            }

            if ( EnableCodePoint ){
                j = 0;
                ConTbl->CandSep[j++] = 0;
                if (OpenFlag) {
                    ConTbl->CandOff = lpCandList->dwSelection % 9;
                }
                i = ConTbl->CandOff;
                for (; i < lpCandList->dwCount; i+= 9 ) {
                    ConTbl->CandSep[j++] = i;
                }
                if (i > lpCandList->dwCount) {
                    i = lpCandList->dwCount;
                }
            }
            else{
                j = 0;
                if (OpenFlag) {
                    ConTbl->CandOff = 0;
                }
                ConTbl->CandSep[j++] = ConTbl->CandOff;
                lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ 0 ]);
                dwDspLen = DispLenUnicode( lpStr );
                width = dwDspLen + DELIMITERWIDTH;                  // '1:xxxx 2:xxxx '
                for( i = 1; i < lpCandList->dwCount; i++ ) {
                    lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
                    dwDspLen = DispLenUnicode( lpStr );
                    width += dwDspLen + DELIMITERWIDTH;
                    if ((width > dwLength-CountDispWidth) ||
                        ( i - ConTbl->CandSep[j-1] >= 9)){
                        ConTbl->CandSep[j++] = i;
                        width = dwDspLen + DELIMITERWIDTH;
                    }
                }
            }
            ConTbl->CandSep[j] = i;
            ConTbl->CandMax = j;

            SystemLineSize = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            if (ConTbl->SystemLineSize < SystemLineSize ){
                if (ConTbl->SystemLine != NULL){
                    LocalFree( ConTbl->SystemLine );
                    ConTbl->SystemLine = NULL;
                    ConTbl->SystemLineSize = 0;
                }
                ConTbl->SystemLine = (LPCONIME_CANDMESSAGE)LocalAlloc(LPTR, SystemLineSize );
                if (ConTbl->SystemLine == NULL) {
                    return FALSE;
                }
                ConTbl->SystemLineSize = SystemLineSize;
            }
            SystemLine = ConTbl->SystemLine;

            SystemLine->AttrOff = sizeof(WCHAR) * dwLength + sizeof(DWORD);

            CopyData.dwData = CI_CONIMECANDINFO;
            CopyData.cbData = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            CopyData.lpData = SystemLine;
            StartIndex = GetSystemLineJ( lpCandList,
                           SystemLine->String,
                           (LPSTR)SystemLine + SystemLine->AttrOff,
                           dwLength,
                           CountDispWidth,
                           ConTbl,
                           EnableCodePoint);

            ConTbl->fNestCandidate = TRUE;    // ImmNotyfyIME call back OpenCandidate Message
                                        // by same data.
                                        // so We ignore this mesage.
            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESTART,
                         dwIndex,
                         ConTbl->CandSep[StartIndex]);

            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESIZE,
                         dwIndex,
                         ConTbl->CandSep[StartIndex+1] -
                         ConTbl->CandSep[StartIndex]);
            ConTbl->fNestCandidate = FALSE;

            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                  );
        }
    }
    return TRUE;
}

BOOL
OpenCandidateTaiwan(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    DWORD dwLength;
    DWORD dwIndex;
    DWORD i;
    DWORD j;
    LPWSTR lpStr;
    DWORD dwDspLen;
    DWORD width;
    DWORD StartIndex;
    DWORD CountDispWidth;
    DWORD AllocLength;
    LPCANDIDATELIST lpCandList;
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            dwLength = ImmGetCandidateList(hIMC, dwIndex, NULL, 0);
            if (dwLength == 0)
                return FALSE;
            if ( (ConTbl->CandListMemAllocSize[dwIndex] != dwLength ) &&
                 (ConTbl->lpCandListMem[dwIndex] != NULL)) {
                LocalFree(ConTbl->lpCandListMem[dwIndex]);
                ConTbl->CandListMemAllocSize[dwIndex] = 0;
                ConTbl->lpCandListMem[dwIndex] = NULL;
            }
            if (ConTbl->lpCandListMem[dwIndex] == NULL) {
                ConTbl->lpCandListMem[dwIndex] = LocalAlloc(LPTR, dwLength);
                if (ConTbl->lpCandListMem[dwIndex] == NULL)
                    return FALSE;
                ConTbl->CandListMemAllocSize[dwIndex] = dwLength;
            }
            lpCandList = ConTbl->lpCandListMem[dwIndex];
            ImmGetCandidateList(hIMC, dwIndex, lpCandList, dwLength);

            //
            // check each offset value is not over than buffer size.
            //
            if ((lpCandList->dwCount > 1) &&
                (lpCandList->dwSelection >= dwLength ||
                 lpCandList->dwPageStart >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwSelection] >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwPageStart] >= dwLength    )
               )
                break;

            dwLength = ConTbl->ScreenBufferSize.X;
            dwLength = (dwLength > 128) ? 128 : dwLength ;
            dwLength = ((dwLength < 12) ? 12 : dwLength );
#if defined (CANDCOUNTCHT) //for wider candidate list space v-hirshi Oct.16.1996
            dwLength -= 28; // 6+1+4+1+10+1+....+4+1
#else
            dwLength -= IMECNameLength+1+IMECModeFullShapeLen*2+1; // 4+1+2+1+....
#endif

            j = (dwLength-7)/(DELIMITERWIDTH+sizeof(WCHAR));
            j = ((j > 9)?9:j);
            j = lpCandList->dwCount / j + 10;
            AllocLength = (j > DEFAULTCANDTABLE) ? j : DEFAULTCANDTABLE;

            for (CountDispWidth = 0 ,j = 1; j <= lpCandList->dwCount; CountDispWidth++)
                 j *= 10;
            CountDispWidth *= 2;
            CountDispWidth++;

            if ((ConTbl->CandSepAllocSize != sizeof(DWORD)*AllocLength) &&
                (ConTbl->CandSep != NULL)) {
                LocalFree(ConTbl->CandSep);
                ConTbl->CandSep = NULL;
                ConTbl->CandSepAllocSize = 0;
            }
            if (ConTbl->CandSep == NULL) {
                ConTbl->CandSep= LocalAlloc(LPTR, sizeof(DWORD)*AllocLength);
                if (ConTbl->CandSep == NULL)
                    return FALSE;
                ConTbl->CandSepAllocSize = sizeof(DWORD)*AllocLength;
            }

            j = 0;
            if (OpenFlag) {
                ConTbl->CandOff = 0;
            }
            ConTbl->CandSep[j++] = ConTbl->CandOff;
            lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ 0 ]);
            dwDspLen = DispLenUnicode( lpStr );
            width = dwDspLen + DELIMITERWIDTH;                  // '1:xxxx 2:xxxx '
            for( i = 1; i < lpCandList->dwCount; i++ ) {
                lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
                dwDspLen = DispLenUnicode( lpStr );
                width += dwDspLen + DELIMITERWIDTH;
                if ((width > dwLength-CountDispWidth) ||
                    ( i - ConTbl->CandSep[j-1] >= 9)){
                    ConTbl->CandSep[j++] = i;
                    width = dwDspLen + DELIMITERWIDTH;
                }
            }
            ConTbl->CandSep[j] = i;
            ConTbl->CandMax = j;

            SystemLineSize = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            if (ConTbl->SystemLineSize < SystemLineSize ){
                if (ConTbl->SystemLine != NULL){
                    LocalFree( ConTbl->SystemLine );
                    ConTbl->SystemLine = NULL;
                    ConTbl->SystemLineSize = 0;
                }
                ConTbl->SystemLine = (LPCONIME_CANDMESSAGE)LocalAlloc(LPTR, SystemLineSize );
                if (ConTbl->SystemLine == NULL) {
                    return FALSE;
                }
                ConTbl->SystemLineSize = SystemLineSize;
            }
            SystemLine = ConTbl->SystemLine;

            SystemLine->AttrOff = sizeof(WCHAR) * dwLength + sizeof(DWORD);

            StartIndex = GetSystemLineT( lpCandList,
                           SystemLine->String,
                           (LPSTR)SystemLine + SystemLine->AttrOff,
                           dwLength,
                           CountDispWidth,
                           ConTbl
                           );

            ConTbl->fNestCandidate = TRUE;    // ImmNotyfyIME call back OpenCandidate Message
                                        // by same data.
                                        // so We ignore this mesage.
            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESTART,
                         dwIndex,
                         ConTbl->CandSep[StartIndex]);

            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESIZE,
                         dwIndex,
                         ConTbl->CandSep[StartIndex+1] -
                         ConTbl->CandSep[StartIndex]);
            ConTbl->fNestCandidate = FALSE;

            CopyData.dwData = CI_CONIMEMODEINFO;
            CopyData.cbData = sizeof(CONIME_UIMODEINFO);
            CopyData.lpData = lpModeInfo;
            if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
                ConsoleImeSendMessage( ConTbl->hWndCon,
                                       (WPARAM)hwnd,
                                       (LPARAM)&CopyData
                                     );
            }
        }
    }
    LocalFree( lpModeInfo );
    return TRUE;
}

BOOL
OpenCandidatePRC(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    DWORD dwLength;
    DWORD dwIndex;
    DWORD i;
    DWORD j;
    LPWSTR lpStr;
    DWORD dwDspLen;
    DWORD width;
    DWORD StartIndex;
    DWORD CountDispWidth;
    DWORD AllocLength;
    LPCANDIDATELIST lpCandList;
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;

    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            dwLength = ImmGetCandidateList(hIMC, dwIndex, NULL, 0);
            if (dwLength == 0)
                return FALSE;
            if ( (ConTbl->CandListMemAllocSize[dwIndex] != dwLength ) &&
                 (ConTbl->lpCandListMem[dwIndex] != NULL)) {
                LocalFree(ConTbl->lpCandListMem[dwIndex]);
                ConTbl->CandListMemAllocSize[dwIndex] = 0;
                ConTbl->lpCandListMem[dwIndex] = NULL;
            }
            if (ConTbl->lpCandListMem[dwIndex] == NULL) {
                ConTbl->lpCandListMem[dwIndex] = LocalAlloc(LPTR, dwLength);
                if (ConTbl->lpCandListMem[dwIndex] == NULL)
                    return FALSE;
                ConTbl->CandListMemAllocSize[dwIndex] = dwLength;
            }
            lpCandList = ConTbl->lpCandListMem[dwIndex];
            ImmGetCandidateList(hIMC, dwIndex, lpCandList, dwLength);

            //
            // check each offset value is not over than buffer size.
            //
            if ((lpCandList->dwCount > 1) &&
                (lpCandList->dwSelection >= dwLength ||
                 lpCandList->dwPageStart >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwSelection] >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwPageStart] >= dwLength    )
               )
                break;

            dwLength = ConTbl->ScreenBufferSize.X;
            dwLength = (dwLength > 128) ? 128 : dwLength ;
            dwLength = ((dwLength < 12) ? 12 : dwLength );
#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
            dwLength -= (20 + PRCCOMPWIDTH); //(8+1+4+1+PRCCOMPWIDTH+1+...+5)
#else
            dwLength -= (15 + PRCCOMPWIDTH); //(8+1+4+1+PRCCOMPWIDTH+1+...)
#endif

            j = (dwLength-7)/(DELIMITERWIDTH+sizeof(WCHAR));
            j = ((j > 9)?9:j);
            j = lpCandList->dwCount / j + 10;
            AllocLength = (j > DEFAULTCANDTABLE) ? j : DEFAULTCANDTABLE;

#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
            for (CountDispWidth = 0 ,j = 1; j <= lpCandList->dwCount; CountDispWidth++)
                 j *= 10;
            CountDispWidth *= 2;
            CountDispWidth++;
#else
            CountDispWidth = 0;
#endif

            if ((ConTbl->CandSepAllocSize != sizeof(DWORD)*AllocLength) &&
                (ConTbl->CandSep != NULL)) {
                LocalFree(ConTbl->CandSep);
                ConTbl->CandSep = NULL;
                ConTbl->CandSepAllocSize = 0;
            }
            if (ConTbl->CandSep == NULL) {
                ConTbl->CandSep= LocalAlloc(LPTR, sizeof(DWORD)*AllocLength);
                if (ConTbl->CandSep == NULL)
                    return FALSE;
                ConTbl->CandSepAllocSize = sizeof(DWORD)*AllocLength;
            }

            j = 0;
            if (OpenFlag) {
                ConTbl->CandOff = 0;
            }
            ConTbl->CandSep[j++] = ConTbl->CandOff;
            lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ 0 ]);
            dwDspLen = DispLenUnicode( lpStr );
            width = dwDspLen + DELIMITERWIDTH;                  // '1:xxxx 2:xxxx '
            for( i = 1; i < lpCandList->dwCount; i++ ) {
                lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
                dwDspLen = DispLenUnicode( lpStr );
                width += dwDspLen + DELIMITERWIDTH;
                if ((width > dwLength-CountDispWidth) ||
                    ( i - ConTbl->CandSep[j-1] >= 9)){
                    ConTbl->CandSep[j++] = i;
                    width = dwDspLen + DELIMITERWIDTH;
                }
            }
            ConTbl->CandSep[j] = i;
            ConTbl->CandMax = j;

            SystemLineSize = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            if (ConTbl->SystemLineSize < SystemLineSize ){
                if (ConTbl->SystemLine != NULL){
                    LocalFree( ConTbl->SystemLine );
                    ConTbl->SystemLine = NULL;
                    ConTbl->SystemLineSize = 0;
                }
                ConTbl->SystemLine = (LPCONIME_CANDMESSAGE)LocalAlloc(LPTR, SystemLineSize );
                if (ConTbl->SystemLine == NULL) {
                    return FALSE;
                }
                ConTbl->SystemLineSize = SystemLineSize;
            }
            SystemLine = ConTbl->SystemLine;

            SystemLine->AttrOff = sizeof(WCHAR) * dwLength + sizeof(DWORD);

            StartIndex = GetSystemLineP( lpCandList,
                           SystemLine->String,
                           (LPSTR)SystemLine + SystemLine->AttrOff,
                           dwLength,
                           CountDispWidth,
                           ConTbl
                           );

            ConTbl->fNestCandidate = TRUE;    // ImmNotyfyIME call back OpenCandidate Message
                                        // by same data.
                                        // so We ignore this mesage.
            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESTART,
                         dwIndex,
                         ConTbl->CandSep[StartIndex]);

            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESIZE,
                         dwIndex,
                         ConTbl->CandSep[StartIndex+1] -
                         ConTbl->CandSep[StartIndex]);
            ConTbl->fNestCandidate = FALSE;

            CopyData.dwData = CI_CONIMEMODEINFO;
            CopyData.cbData = sizeof(CONIME_UIMODEINFO);
            CopyData.lpData = lpModeInfo;
            if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
                ConsoleImeSendMessage( ConTbl->hWndCon,
                                       (WPARAM)hwnd,
                                       (LPARAM)&CopyData
                                     );
            }
        }
    }
    LocalFree( lpModeInfo );
    return TRUE;
}

BOOL
OpenCandidateKorea(
    HWND hwnd,
    HIMC  hIMC ,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList,
    BOOL OpenFlag
    )
{
    DWORD dwLength;
    DWORD dwIndex;
    DWORD i;
    DWORD j;
    LPWSTR lpStr;
    DWORD dwDspLen;
    DWORD width;
    DWORD StartIndex;
    DWORD CountDispWidth;
    DWORD AllocLength;
    LPCANDIDATELIST lpCandList;
    LPCONIME_CANDMESSAGE SystemLine;
    DWORD SystemLineSize;
    COPYDATASTRUCT CopyData;
    BOOL EnableCodePoint;

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            dwLength = ImmGetCandidateList(hIMC, dwIndex, NULL, 0);
            if (dwLength == 0)
                return FALSE;
            if ( (ConTbl->CandListMemAllocSize[dwIndex] != dwLength ) &&
                 (ConTbl->lpCandListMem[dwIndex] != NULL)) {
                LocalFree(ConTbl->lpCandListMem[dwIndex]);
                ConTbl->CandListMemAllocSize[dwIndex] = 0;
                ConTbl->lpCandListMem[dwIndex] = NULL;
            }
            if (ConTbl->lpCandListMem[dwIndex] == NULL) {
                ConTbl->lpCandListMem[dwIndex] = LocalAlloc(LPTR, dwLength);
                if (ConTbl->lpCandListMem[dwIndex] == NULL)
                    return FALSE;
                ConTbl->CandListMemAllocSize[dwIndex] = dwLength;
            }
            lpCandList = ConTbl->lpCandListMem[dwIndex];
            ImmGetCandidateList(hIMC, dwIndex, lpCandList, dwLength);

            //
            // check each offset value is not over than buffer size.
            //
            if ((lpCandList->dwCount > 1) &&
                (lpCandList->dwSelection >= dwLength ||
                 lpCandList->dwPageStart >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwSelection] >= dwLength ||
                 lpCandList->dwOffset[lpCandList->dwPageStart] >= dwLength    )
               )
                break;

            dwLength = ConTbl->ScreenBufferSize.X;
            dwLength = (dwLength > 128) ? 128 : dwLength ;
            dwLength = ((dwLength < 12) ? 12 : dwLength );

            j = (dwLength-7)/(DELIMITERWIDTH+sizeof(WCHAR));
            j = ((j > 9)?9:j);
            j = lpCandList->dwCount / j + 10;
            AllocLength = (j > DEFAULTCANDTABLE) ? j : DEFAULTCANDTABLE;

            if (lpCandList->dwStyle == IME_CAND_CODE){
                EnableCodePoint = TRUE;
            }
            else{
                EnableCodePoint = FALSE;
            }

            if (EnableCodePoint){
                CountDispWidth = CODEDISPLEN;
            }
            else {
                for (CountDispWidth = 0 ,j = 1; j <= lpCandList->dwCount; CountDispWidth++)
                     j *= 10;
                CountDispWidth *= 2;
                CountDispWidth++;
            }

            if ((ConTbl->CandSepAllocSize != sizeof(DWORD)*AllocLength) &&
                (ConTbl->CandSep != NULL)) {
                LocalFree(ConTbl->CandSep);
                ConTbl->CandSep = NULL;
                ConTbl->CandSepAllocSize = 0;
            }
            if (ConTbl->CandSep == NULL) {
                ConTbl->CandSep= LocalAlloc(LPTR, sizeof(DWORD)*AllocLength);
                if (ConTbl->CandSep == NULL)
                    return FALSE;
                ConTbl->CandSepAllocSize = sizeof(DWORD)*AllocLength;
            }

            if ( EnableCodePoint ){
                j = 0;
                ConTbl->CandSep[j++] = 0;
                if (OpenFlag) {
                    ConTbl->CandOff = lpCandList->dwSelection % 9;
                }
                i = ConTbl->CandOff;
                for (; i < lpCandList->dwCount; i+= 9 ) {
                    ConTbl->CandSep[j++] = i;
                }
                if (i > lpCandList->dwCount) {
                    i = lpCandList->dwCount;
                }
            }
            else{
                j = 0;
                if (OpenFlag) {
                    ConTbl->CandOff = 0;
                }
                ConTbl->CandSep[j++] = ConTbl->CandOff;
                lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ 0 ]);
                dwDspLen = DispLenUnicode( lpStr );
                width = dwDspLen + DELIMITERWIDTH;                  // '1:xxxx 2:xxxx '
                for( i = 1; i < lpCandList->dwCount; i++ ) {
                    lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
                    dwDspLen = DispLenUnicode( lpStr );
                    width += dwDspLen + DELIMITERWIDTH;
                    if ((width > dwLength-CountDispWidth) ||
                        ( i - ConTbl->CandSep[j-1] >= 9)){
                        ConTbl->CandSep[j++] = i;
                        width = dwDspLen + DELIMITERWIDTH;
                    }
                }
            }
            ConTbl->CandSep[j] = i;
            ConTbl->CandMax = j;

            SystemLineSize = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            if (ConTbl->SystemLineSize < SystemLineSize ){
                if (ConTbl->SystemLine != NULL){
                    LocalFree( ConTbl->SystemLine );
                    ConTbl->SystemLine = NULL;
                    ConTbl->SystemLineSize = 0;
                }
                ConTbl->SystemLine = (LPCONIME_CANDMESSAGE)LocalAlloc(LPTR, SystemLineSize );
                if (ConTbl->SystemLine == NULL) {
                    return FALSE;
                }
                ConTbl->SystemLineSize = SystemLineSize;
            }
            SystemLine = ConTbl->SystemLine;

            SystemLine->AttrOff = sizeof(WCHAR) * dwLength + sizeof(DWORD);

            CopyData.dwData = CI_CONIMECANDINFO;
            CopyData.cbData = (sizeof(WCHAR)+sizeof(UCHAR))*dwLength + sizeof(DWORD);
            CopyData.lpData = SystemLine;
            StartIndex = GetSystemLineJ( lpCandList,
                           SystemLine->String,
                           (LPSTR)SystemLine + SystemLine->AttrOff,
                           dwLength,
                           CountDispWidth,
                           ConTbl,
                           EnableCodePoint);

            ConTbl->fNestCandidate = TRUE;    // ImmNotyfyIME call back OpenCandidate Message
                                        // by same data.
                                        // so We ignore this mesage.
            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESTART,
                         dwIndex,
                         ConTbl->CandSep[StartIndex]);

            ImmNotifyIME(hIMC,
                         NI_SETCANDIDATE_PAGESIZE,
                         dwIndex,
                         ConTbl->CandSep[StartIndex+1] -
                         ConTbl->CandSep[StartIndex]);
            ConTbl->fNestCandidate = FALSE;

            ConsoleImeSendMessage( ConTbl->hWndCon,
                                   (WPARAM)hwnd,
                                   (LPARAM)&CopyData
                                 );
        }
    }
    return TRUE;
}

DWORD
DispLenUnicode(
    LPWSTR lpString )
{
    DWORD i;
    DWORD Length;

    Length = 0;

    for ( i = 0; lpString[i] != 0; i++) {
        Length += IsUnicodeFullWidth(lpString[i]) ? 2 : 1;
    }
    return Length;
}

DWORD
GetSystemLineJ(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole,
    BOOL EnableCodePoint)
{
    DWORD dwStrLen;
    DWORD dwDspLen;
    DWORD i;
    DWORD j;
    DWORD SepIndex;
    DWORD SelCount;
    DWORD Length;
    DWORD dwWholeLen;
    BOOL lfBreak = FALSE;
    LPWSTR StrToWrite;
    LPSTR AttrToSel;
    LPWSTR lpStr;
    USHORT MultiChar;
    USHORT TempMulti;

    if (lpCandList->dwSelection > lpCandList->dwCount) {
        lpCandList->dwSelection = 0;
    }

    for ( SepIndex = FocusedConsole->CandMax; SepIndex > 0; SepIndex--) {
        if (lpCandList->dwSelection >= FocusedConsole->CandSep[SepIndex])
            break;
    }
    if (SepIndex == FocusedConsole->CandMax)
        SepIndex = 0;

    for ( i = 0; i < dwLength; i++) {
        Attr[i] = 0x0000;
    }
    StrToWrite = String;
    AttrToSel = Attr;
    dwWholeLen = 0;
#if 1
    // HACK HACK ntbug #69699
    // MS-IME97 & MS-IME97A does not return correct value for IME_PROP_CANDLIST_START_FROM_1.
    // These always return its starting from 0.
    // Currently there is not IME starting from 0. So we hack.
    // Actually IME should be fixed.
    SelCount = 1;
#else
    if (FocusedConsole->ImmGetProperty & IME_PROP_CANDLIST_START_FROM_1)
        SelCount = 1;
    else
        SelCount = 0;
#endif

    if (EnableCodePoint){
        lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[lpCandList->dwSelection]);
        WideCharToMultiByte(CP_OEMCP, 0, lpStr, 1, (PBYTE)&TempMulti, 2, NULL, NULL);
        *StrToWrite = UNICODE_LEFT;
        StrToWrite++;
        MultiChar = (USHORT)(HIBYTE(TempMulti)| LOBYTE(TempMulti)<<8);
        for (i = 0; i < 4; i++) {
            j = (MultiChar & 0xf000 ) >> 12;
            if ( j <= 9)
                *StrToWrite = (USHORT)(j + UNICODE_ZERO);
            else
                *StrToWrite = (USHORT)(j + UNICODE_HEXBASE);
            StrToWrite++;
            MultiChar = (USHORT)(MultiChar << 4);
        }
        *StrToWrite = UNICODE_RIGHT;
        StrToWrite++;
        *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        AttrToSel += CountDispWidth;
        dwWholeLen += CountDispWidth;
        CountDispWidth = 0;
    }

    for (i = FocusedConsole->CandSep[SepIndex]; i < FocusedConsole->CandSep[SepIndex+1]; i++) {
        //
        // check each offset value is not over than buffer size.
        //
        if (lpCandList->dwOffset[i] >= lpCandList->dwSize)
            break;

        lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
        dwStrLen = lstrlenW( lpStr );
        dwDspLen = DispLenUnicode( lpStr );

        if ( dwWholeLen + dwDspLen + DELIMITERWIDTH  > dwLength - CountDispWidth ){
            Length = 0;
            lfBreak = TRUE;
            for (j = 0; j < dwStrLen; j++ ){
                Length += IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                if (dwWholeLen + Length > dwLength - (CountDispWidth + DELIMITERWIDTH)){
                    dwStrLen = j-1;
                    dwDspLen = Length - IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                    break;
                }
            }
        }
        if ((dwWholeLen + dwDspLen + DELIMITERWIDTH + CountDispWidth ) <= dwLength )      // if minus value
            dwWholeLen += (dwDspLen + DELIMITERWIDTH);
        else {
            break;
        }

        if (i == lpCandList->dwSelection) {
            for (j = 0; j < dwStrLen+2; j++)
                *(AttrToSel+j) = 1;
        }
        *StrToWrite = (USHORT)(SelCount + UNICODE_ZERO);
        StrToWrite++;
        *StrToWrite = UNICODE_COLON;
        StrToWrite++;
        CopyMemory(StrToWrite, lpStr, dwStrLen * sizeof(WCHAR));
        StrToWrite += dwStrLen;
        *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        AttrToSel += dwStrLen+DELIMITERWIDTH;
        SelCount++;
        if (lfBreak)
            break;
    }
    *StrToWrite = 0;
    dwDspLen = DispLenUnicode( String );
    if (dwDspLen > (dwLength - CountDispWidth))
        return SepIndex;

    if (EnableCodePoint){
        for (i = dwDspLen; i < dwLength; i++) {
            *StrToWrite = UNICODE_SPACE;
            StrToWrite++;
        }
    }
    else {
        for (i = dwDspLen; i < (dwLength - CountDispWidth); i++) {
            *StrToWrite = UNICODE_SPACE;
            StrToWrite++;
        }

        i = (CountDispWidth-1) / 2;
        NumString(StrToWrite,lpCandList->dwSelection+1,i);
        StrToWrite+=i;
        *StrToWrite = UNICODE_SLASH;
        StrToWrite++;
        NumString(StrToWrite,lpCandList->dwCount, i);
        StrToWrite+=i;
    }
    *StrToWrite = 0;

    return SepIndex;
}

DWORD
GetSystemLineT(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole
    )
{
    DWORD dwStrLen;
    DWORD dwDspLen;
    DWORD i;
    DWORD j;
    DWORD SepIndex;
    DWORD SelCount;
    DWORD Length;
    DWORD dwWholeLen;
    BOOL lfBreak = FALSE;
    LPWSTR StrToWrite;
    LPSTR AttrToSel;
    LPWSTR lpStr;
    USHORT MultiChar;
    USHORT TempMulti;

    if (lpCandList->dwSelection > lpCandList->dwCount) {
        lpCandList->dwSelection = 0;
    }

    for ( SepIndex = FocusedConsole->CandMax; SepIndex > 0; SepIndex--) {
        if (lpCandList->dwSelection >= FocusedConsole->CandSep[SepIndex])
            break;
    }
    if (SepIndex == FocusedConsole->CandMax)
        SepIndex = 0;

    for ( i = 0; i < dwLength; i++) {
        Attr[i] = 0x0000;
    }
    StrToWrite = String;
    AttrToSel = Attr;
    dwWholeLen = 0;
    if (FocusedConsole->ImmGetProperty & IME_PROP_CANDLIST_START_FROM_1)
        SelCount = 1;
    else
        SelCount = 0;


    for (i = FocusedConsole->CandSep[SepIndex]; i < FocusedConsole->CandSep[SepIndex+1]; i++) {
        lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
        dwStrLen = lstrlenW( lpStr );
        dwDspLen = DispLenUnicode( lpStr );

        if ( dwWholeLen + dwDspLen + DELIMITERWIDTH  > dwLength - CountDispWidth ){
            Length = 0;
            lfBreak = TRUE;
            for (j = 0; j < dwStrLen; j++ ){
                Length += IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                if (dwWholeLen + Length > dwLength - (CountDispWidth + DELIMITERWIDTH)){
                    dwStrLen = j-1;
                    dwDspLen = Length - IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                    break;
                }
            }
        }
        if ((dwWholeLen + dwDspLen + DELIMITERWIDTH + CountDispWidth ) <= dwLength )      // if minus value
            dwWholeLen += (dwDspLen + DELIMITERWIDTH);
        else {
            break;
        }

        if (i == lpCandList->dwSelection) {
            for (j = 0; j < dwStrLen+2; j++)
                *(AttrToSel+j) = 1;
        }
        *StrToWrite = (USHORT)(SelCount + UNICODE_ZERO);
        StrToWrite++;
        *StrToWrite = UNICODE_COLON;
        StrToWrite++;
        CopyMemory(StrToWrite, lpStr, dwStrLen * sizeof(WCHAR));
        StrToWrite += dwStrLen;
        *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        AttrToSel += dwStrLen+DELIMITERWIDTH;
        SelCount++;
        if (lfBreak)
            break;
    }
    *StrToWrite = 0;
    dwDspLen = DispLenUnicode( String );
    if (dwDspLen > (dwLength - CountDispWidth))
        return SepIndex;

    *StrToWrite = UNICODE_SPACE;
    StrToWrite++;

    i = (CountDispWidth-1) / 2;
    NumString(StrToWrite,lpCandList->dwSelection+1,i);
    StrToWrite+=i;
    *StrToWrite = UNICODE_SLASH;
    StrToWrite++;
    NumString(StrToWrite,lpCandList->dwCount, i);
    StrToWrite+=i;
    *StrToWrite = 0;

    return SepIndex;
}

DWORD
GetSystemLineP(
    LPCANDIDATELIST lpCandList ,
    LPWSTR String,
    LPSTR Attr,
    DWORD dwLength,
    DWORD CountDispWidth,
    PCONSOLE_TABLE FocusedConsole
    )
{
    DWORD dwStrLen;
    DWORD dwDspLen;
    DWORD i;
    DWORD j;
    DWORD SepIndex;
    DWORD SelCount;
    DWORD Length;
    DWORD dwWholeLen;
    BOOL lfBreak = FALSE;
    LPWSTR StrToWrite;
    LPSTR AttrToSel;
    LPWSTR lpStr;
    USHORT MultiChar;
    USHORT TempMulti;

    if (lpCandList->dwSelection > lpCandList->dwCount) {
        lpCandList->dwSelection = 0;
    }

    for ( SepIndex = FocusedConsole->CandMax; SepIndex > 0; SepIndex--) {
        if (lpCandList->dwSelection >= FocusedConsole->CandSep[SepIndex])
            break;
    }
    if (SepIndex == FocusedConsole->CandMax)
        SepIndex = 0;

    for ( i = 0; i < dwLength; i++) {
        Attr[i] = 0x0000;
    }
    StrToWrite = String;
    AttrToSel = Attr;
    dwWholeLen = 0;
    if (FocusedConsole->ImmGetProperty & IME_PROP_CANDLIST_START_FROM_1)
        SelCount = 1;
    else
        SelCount = 0;

    for (i = FocusedConsole->CandSep[SepIndex]; i < FocusedConsole->CandSep[SepIndex+1]; i++) {
        lpStr = (LPWSTR)((LPSTR)lpCandList + lpCandList->dwOffset[ i ]);
        dwStrLen = lstrlenW( lpStr );
        dwDspLen = DispLenUnicode( lpStr );

        if ( dwWholeLen + dwDspLen + DELIMITERWIDTH  > dwLength - CountDispWidth ){
            Length = 0;
            lfBreak = TRUE;
            for (j = 0; j < dwStrLen; j++ ){
                Length += IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                if (dwWholeLen + Length > dwLength - (CountDispWidth + DELIMITERWIDTH)){
                    dwStrLen = j-1;
                    dwDspLen = Length - IsUnicodeFullWidth(lpStr[j]) ? 2 : 1;
                    break;
                }
            }
        }
        if ((dwWholeLen + dwDspLen + DELIMITERWIDTH + CountDispWidth ) <= dwLength )      // if minus value
            dwWholeLen += (dwDspLen + DELIMITERWIDTH);
        else {
            break;
        }

        if (i == lpCandList->dwSelection) {
            for (j = 0; j < dwStrLen+2; j++)
                *(AttrToSel+j) = 1;
        }
        *StrToWrite = (USHORT)(SelCount + UNICODE_ZERO);
        StrToWrite++;
        *StrToWrite = UNICODE_COLON;
        StrToWrite++;
        CopyMemory(StrToWrite, lpStr, dwStrLen * sizeof(WCHAR));
        StrToWrite += dwStrLen;
        *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        AttrToSel += dwStrLen+DELIMITERWIDTH;
        SelCount++;
        if (lfBreak)
            break;
    }
    *StrToWrite = 0;
    dwDspLen = DispLenUnicode( String );
    if (dwDspLen > (dwLength - CountDispWidth))
        return SepIndex;

#if defined (CANDCOUNTPRC) //for wider candidate list space v-hirshi Oct.16.1996
    *StrToWrite = UNICODE_SPACE;
    StrToWrite++;

    i = (CountDispWidth-1) / 2;
    NumString(StrToWrite,lpCandList->dwSelection+1,i);
    StrToWrite+=i;
    *StrToWrite = UNICODE_SLASH;
    StrToWrite++;
    NumString(StrToWrite,lpCandList->dwCount, i);
    StrToWrite+=i;
#endif

    *StrToWrite = 0;

    return SepIndex;
}

VOID
NumString(
    LPWSTR StrToWrite,
    DWORD NumToDisp,
    DWORD CountDispWidth)
{
    DWORD i;
    DWORD k;
    k = 1;
    for (i = 1; i < CountDispWidth; i++)
        k *= 10;
    for (i = k; i > 0; i /= 10){
        k = (NumToDisp / i);
        *StrToWrite = (USHORT)(k + UNICODE_ZERO);
        if ((*StrToWrite == UNICODE_ZERO) &&
            ((*(StrToWrite-1) == UNICODE_SPACE)||(*(StrToWrite-1) == UNICODE_SLASH)) )
            *StrToWrite = UNICODE_SPACE;
        StrToWrite++;
        NumToDisp -= (i*k);
    }
}

BOOL
ImeUICloseCandidate(
   HWND hwnd,
   DWORD CandList
   )
{
    HIMC  hIMC;
    PCONSOLE_TABLE ConTbl;

    DBGPRINT(("CONIME: Get IMN_CLOSECANDIDATE Message\n"));

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return FALSE;
    }

    hIMC = ImmGetContext( hwnd );
    if ( hIMC == 0 )
        return FALSE;

    //
    // Reset fInCandidate variables.
    //
    ConTbl->fInCandidate = FALSE;

    switch ( HKL_TO_LANGID(ConTbl->hklActive))
    {
        case    LANG_ID_JAPAN:
            CloseCandidateJapan(hwnd, hIMC, ConTbl, CandList );
            break;
        case    LANG_ID_TAIWAN:
            CloseCandidateTaiwan(hwnd, hIMC, ConTbl, CandList );
            break;
        case    LANG_ID_PRC:
            CloseCandidatePRC(hwnd, hIMC, ConTbl, CandList );
            break;
        case    LANG_ID_KOREA:
            CloseCandidateKorea(hwnd, hIMC, ConTbl, CandList );
            break;
        default:
            return FALSE;
            break;
    }
    ImmReleaseContext( hwnd, hIMC );

    return TRUE;
}

BOOL
CloseCandidateJapan(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   )
{
    DWORD dwIndex;
    COPYDATASTRUCT CopyData;

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            if (ConTbl->lpCandListMem[dwIndex] != NULL ) {
                 LocalFree(ConTbl->lpCandListMem[dwIndex]);
                 ConTbl->lpCandListMem[dwIndex] = NULL;
                 ConTbl->CandListMemAllocSize[dwIndex] = 0;
            }
        }
    }

    CopyData.dwData = CI_CONIMECANDINFO;
    CopyData.cbData = 0;
    CopyData.lpData = NULL;
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

    return TRUE;
}

BOOL
CloseCandidateTaiwan(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   )
{
    DWORD dwIndex;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;
    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            if (ConTbl->lpCandListMem[dwIndex] != NULL ) {
                 LocalFree(ConTbl->lpCandListMem[dwIndex]);
                 ConTbl->lpCandListMem[dwIndex] = NULL;
                 ConTbl->CandListMemAllocSize[dwIndex] = 0;
            }
        }
    }

    CopyData.dwData = CI_CONIMEMODEINFO;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO);
    CopyData.lpData = lpModeInfo;
    if (MakeInfoStringTaiwan(ConTbl, lpModeInfo) ) {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             );
    }

    LocalFree( lpModeInfo );
    return TRUE;

}

BOOL
CloseCandidatePRC(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   )
{
    DWORD dwIndex;
    COPYDATASTRUCT CopyData;
    LPCONIME_UIMODEINFO lpModeInfo;
    lpModeInfo = (LPCONIME_UIMODEINFO)LocalAlloc( LPTR, sizeof(CONIME_UIMODEINFO) );
    if ( lpModeInfo == NULL) {
        return FALSE;
    }

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            if (ConTbl->lpCandListMem[dwIndex] != NULL ) {
                 LocalFree(ConTbl->lpCandListMem[dwIndex]);
                 ConTbl->lpCandListMem[dwIndex] = NULL;
                 ConTbl->CandListMemAllocSize[dwIndex] = 0;
            }
        }
    }

    CopyData.dwData = CI_CONIMEMODEINFO;
    CopyData.cbData = sizeof(CONIME_UIMODEINFO);
    CopyData.lpData = lpModeInfo;
    if (MakeInfoStringPRC(ConTbl, lpModeInfo) ) {
        ConsoleImeSendMessage( ConTbl->hWndCon,
                               (WPARAM)hwnd,
                               (LPARAM)&CopyData
                             );
    }

    LocalFree( lpModeInfo );
    return TRUE;

}

BOOL
CloseCandidateKorea(
    HWND hwnd,
    HIMC hIMC,
    PCONSOLE_TABLE ConTbl,
    DWORD CandList
   )
{
    DWORD dwIndex;
    COPYDATASTRUCT CopyData;

    for (dwIndex = 0; dwIndex < MAX_LISTCAND ; dwIndex ++ ) {
        if ( CandList & ( 1 << dwIndex ) ) {
            if (ConTbl->lpCandListMem[dwIndex] != NULL ) {
                 LocalFree(ConTbl->lpCandListMem[dwIndex]);
                 ConTbl->lpCandListMem[dwIndex] = NULL;
                 ConTbl->CandListMemAllocSize[dwIndex] = 0;
            }
        }
    }

    CopyData.dwData = CI_CONIMECANDINFO;
    CopyData.cbData = 0;
    CopyData.lpData = NULL;
    ConsoleImeSendMessage( ConTbl->hWndCon,
                           (WPARAM)hwnd,
                           (LPARAM)&CopyData
                          );

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\globals.h ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   Globals.h
//
//  PURPOSE:   Contains declarations for all globally scoped names in the program.
//
//  PLATFORMS: Windows NT-J 3.51
//
//  FUNCTIONS:
//
//  History:
//
//  27.Jul.1995 v-HirShi (Hirotoshi Shimizu)    created
//
//  COMMENTS:
//

extern HANDLE    LastConsole ;
extern HIMC      ghDefaultIMC ;





#ifdef DEBUG_MODE
extern int       cxMetrics ;
extern int       cyMetrics ;
extern int       cxOverTypeCaret ;
extern int       xPos ;
extern int       xPosLast ;
extern int       CaretWidth;               // insert/overtype mode caret width

extern WCHAR           ConvertLine[CVMAX] ;
extern unsigned char   ConvertLineAtr[CVMAX] ;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\sources.inc ===
!IF 0

Copyright (c) 1995  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Hirotoshi Shimizu(v-HirShi) 21-Jun-1995

!ENDIF


MAJORCOMP=windows
MINORCOMP=console

TARGETNAME=conime
TARGETPATH=$(_OBJ_DIR)
TARGETTYPE=PROGRAM

INCLUDES=..\..\inc;                             \
         $(WINCORE_PATH);                       \
         ..\; \
         $(BASE_INC_PATH)

USE_MSVCRT=1

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

C_DEFINES=-DWIN32 -DNT -DUNICODE -D_UNICODE \
          -DCUAS_ENABLE

SOURCES=..\conime.c \
        ..\consubs.c \
        ..\imefull.c \
        ..\country.c \
        ..\country2.c \
        ..\country3.c \
        ..\conime.rc

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

UMTYPE=windows
UMENTRY=winmain
UMAPPL=conime
UMLIBS=$(SDK_LIB_PATH)\kernel32.lib        \
       $(SDK_LIB_PATH)\kernl32p.lib        \
       $(SDK_LIB_PATH)\user32.lib          \
       $(SDK_LIB_PATH)\ntdll.lib           \
       $(SDK_LIB_PATH)\imm32.lib           \
       $(WINDOWS_LIB_PATH)\imm32p.lib      \
       $(SDK_LIB_PATH)\gdi32.lib           \
       $(SDK_LIB_PATH)\shell32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "winbasep.h"
#include "winconp.h"
#include "winuserp.h"
#include "immp.h"
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <ime.h>
#include "conapi.h"
#include "conime.h"
#include "conimep.h"
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\exts\exts.h ===
/************************************************************************\
*
* MODULE: exts.h
*
* DESCRIPTION: macro driving file for use with stdexts.h and stdexts.c.
*
\************************************************************************/

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

DOIT(   ds
        ,"ds                          - Dump SCREEN_INFORMATION struct.\n"
        ,"ds [screen_info]\n"
        ,""
        ,STDARGS1)

DOIT(   dt
        ,"dt -f -v[n] <pcon>               - Dump text buffer information.\n"
        ,"dt <pconsole>\n"
        ,"fv"
        ,STDARGS1)

DOIT(   dc
        ,"dc                           - Dump CONSOLE_INFORMATION struct.\n"
        ,"dc [pconsole]\n"
        ,"fvh"
        ,STDARGS1)

DOIT(   df
        ,"df                           - Dump font information.\n"
        ,"df\n"
        ,""
        ,NOARGS)

DOIT(   di
        ,"di [pconsole]                 - Dump input buffer.\n"
        ,"  di         - dump input buffer for all consoles.\n"
         "  di <pconsole> - dump input buffer for console pconsole.\n"
        ,""
        ,STDARGS1)

DOIT(   dir
        ,"dir [pinput]                  - Dump input record.\n"
        ,"dir [pinput] [n]\n"
        ,""
        ,STDARGS2)

DOIT(   dcpt
        ,"dcpt                          - Dump CPTAGBLEINFO\n"
        ,"  dcpt addr - dumps the CPTABLEINFO at addr\n"
         "  dcpt      - dumps the CPTABLEINFO at GlyphCP"
        ,""
        ,STDARGS1)

DOIT(   dch
        ,"dch <addr>                    - Dump COMMAND_HISTORY at addr.\n"
        ,"  dch <addr> - Dumps the COMMAND_HISTORY struct at addr.\n"
        ,""
        ,STDARGS1)

DOIT(   dmem
        ,"dmem -v [pconsole]            - Displays console memory usage.\n"
        ,"  dmem\n"
        ,"v"
        ,STDARGS1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\exts\conexts.c ===
/***************************** Module Header ******************************\
* Module Name: conexts.c
*
* Copyright (c) 1985 - 2001, Microsoft Corporation
*
* This module contains console-related debugging functions.
*
* History:
* ????
* 30-Jan-2001 JasonSch    Moved to ntcon\exts and made to fix the STDEXTS model.
\***************************************************************************/

#include "precomp.h"
#pragma hdrstop

CONST PSTR pszExtName = "CONEXTS";

#include <stdext64.h>
#include <stdext64.c>

#define SYM(s)  "winsrv!" #s
#define NO_FLAG IntToPtr(0xFFFFFFFF)  // use this for non-meaningful entries.

VOID
DbgGetConsoleTitle(
    IN ULONG64 pConsole,
    OUT PWCHAR buffer,
    IN UINT cbSize);

BOOL
CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax);

WINDBG_EXTENSION_APIS  ExtensionApis;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;
BOOL                   bDebuggingChecked;

EXT_API_VERSION ApiVersion = { VER_PRODUCTVERSION_W >> 8,
                               VER_PRODUCTVERSION_W & 0xff,
                               EXT_API_VERSION_NUMBER64, 0 };

#define GF_CONSOLE  1
LPSTR apszConsoleFlags[] = {
   "CONSOLE_IS_ICONIC"              , // 0x000001
   "CONSOLE_OUTPUT_SUSPENDED"       , // 0x000002
   "CONSOLE_HAS_FOCUS"              , // 0x000004
   "CONSOLE_IGNORE_NEXT_MOUSE_INPUT", // 0x000008
   "CONSOLE_SELECTING"              , // 0x000010
   "CONSOLE_SCROLLING"              , // 0x000020
   "CONSOLE_DISABLE_CLOSE"          , // 0x000040
   "CONSOLE_NOTIFY_LAST_CLOSE"      , // 0x000080
   "CONSOLE_NO_WINDOW"              , // 0x000100
   "CONSOLE_VDM_REGISTERED"         , // 0x000200
   "CONSOLE_UPDATING_SCROLL_BARS"   , // 0x000400
   "CONSOLE_QUICK_EDIT_MODE"        , // 0x000800
   "CONSOLE_TERMINATING"            , // 0x001000
   "CONSOLE_CONNECTED_TO_EMULATOR"  , // 0x002000
   "CONSOLE_FULLSCREEN_NOPAINT"     , // 0x004000
   "CONSOLE_SHUTTING_DOWN"          , // 0x008000
   "CONSOLE_AUTO_POSITION"          , // 0x010000
   "CONSOLE_IGNORE_NEXT_KEYUP"      , // 0x020000
   "CONSOLE_WOW_REGISTERED"         , // 0x040000
   "CONSOLE_USE_PRIVATE_FLAGS"      , // 0x080000
   "CONSOLE_HISTORY_NODUP"          , // 0x100000
   "CONSOLE_SCROLLBAR_TRACKING"     , // 0x200000
   "CONSOLE_IN_DESTRUCTION"         , // 0x400000
   "CONSOLE_SETTING_WINDOW_SIZE"    , // 0x800000
   "CONSOLE_DEFAULT_BUFFER_SIZE"    , // 0x0100000
    NULL                              // no more
};

#define GF_CONSOLESEL  2
LPSTR apszConsoleSelectionFlags[] = {
   "CONSOLE_SELECTION_NOT_EMPTY"    , // 1
   "CONSOLE_MOUSE_SELECTION"        , // 2
   "CONSOLE_MOUSE_DOWN"             , // 4
   "CONSOLE_SELECTION_INVERTED"     , // 8
   NULL                               // no more
};

#define GF_FULLSCREEN  3
LPSTR apszFullScreenFlags[] = {
   "CONSOLE_FULLSCREEN",             // 0
   "CONSOLE_FULLSCREEN_HARDWARE",    // 1
   NULL
};

#define GF_CMDHIST     4
LPSTR apszCommandHistoryFlags[] = {
   "CLE_ALLOCATED",                  // 0x01
   "CLE_RESET",                      // 0x02
   NULL
};


/*
 * Converts a 32bit set of flags into an appropriate string.
 * pszBuf should be large enough to hold this string, no checks are done.
 * pszBuf can be NULL, allowing use of a local static buffer but note that
 * this is not reentrant.
 * Output string has the form: " = FLAG1 | FLAG2 ..."
 */
LPSTR GetFlags(
WORD wType,
DWORD dwFlags,
LPSTR pszBuf)
{
    static char szT[400];
    DWORD i;
    BOOL fFirst = TRUE;
    BOOL fNoMoreNames = FALSE;
    LPSTR *apszFlags;

    if (pszBuf == NULL) {
        pszBuf = szT;
    }
    *pszBuf = '\0';

    switch (wType) {
    case GF_CONSOLE:
        apszFlags = apszConsoleFlags;
        break;

    case GF_CONSOLESEL:
        apszFlags = apszConsoleSelectionFlags;
        break;

    case GF_FULLSCREEN:
        apszFlags = apszFullScreenFlags;
        break;

    case GF_CMDHIST:
        apszFlags = apszCommandHistoryFlags;
        break;

    default:
        strcpy(pszBuf, " = Invalid flag type.");
        return(pszBuf);
    }

    for (i = 0; dwFlags; dwFlags >>= 1, i++) {

        if (!fNoMoreNames && (apszFlags[i] == NULL)) {
            fNoMoreNames = TRUE;
        }
        if (dwFlags & 1) {
            if (!fFirst) {
                strcat(pszBuf, " | ");
            } else {
                strcat(pszBuf, " = ");
                fFirst = FALSE;
            }
            if (fNoMoreNames || (apszFlags[i] == NO_FLAG)) {
                char ach[16];
                sprintf(ach, "0x%lx", 1 << i);
                strcat(pszBuf, ach);
            } else {
                strcat(pszBuf, apszFlags[i]);
            }
        }
    }
    return pszBuf;
}


/***************************************************************************\
* dc - Dump Console - dump CONSOLE_INFORMATION struct
*
* dc address    - dumps simple info for console at address
*                 (takes handle too)
\***************************************************************************/
BOOL Idc(
    DWORD opts,
    ULONG64 pConsole)
{
    BOOL fPrintLine;
    ULONG i, NumberOfConsoleHandles;
    DWORD dwOffset, dwOffset2;
    WCHAR buffer[256];

    if (!pConsole) {
        /*
         * If no console is specified, loop through all of them
         */
        moveExpValue(&NumberOfConsoleHandles,
                     SYM(NumberOfConsoleHandles));
        moveExpValuePtr(&pConsole,
                        SYM(ConsoleHandles));
        fPrintLine = FALSE;
        for (i = 0; i < NumberOfConsoleHandles; i++) {
            ULONG64 pc;

            ReadPtr(pConsole, &pc);
            if (pc && InitTypeRead(pc, SYM(CONSOLE_INFORMATION))) {
                if (fPrintLine) {
                    Print("==========================================\n");
                }
                Idc(opts, pc);
                fPrintLine = TRUE;
            }
            (ULONG_PTR)pConsole += GetTypeSize(SYM(PCONSOLE_INFORMATION));
        }

        return TRUE;
    }

    if (!InitTypeRead(pConsole, SYM(CONSOLE_INFORMATION))) {
        Print("Couldn't read console at 0x%p\n", pConsole);
        return FALSE;
    }

    DbgGetConsoleTitle(pConsole, buffer, ARRAY_SIZE(buffer));
    Print("PCONSOLE @ %#p   \"%ws\"\n", pConsole, buffer);

    if (opts & OFLAG(h)) {
        ULONG64 ListHead, ListNext, pHistory;

        GetFieldOffset(SYM(CONSOLE_INFORMATION), "CommandHistoryList", &dwOffset);
        ListHead = pConsole + dwOffset;
        ListNext = ReadField(CommandHistoryList.Flink);
        while (ListNext != ListHead) {
            pHistory = (ULONG64)CONTAINING_RECORD(ListNext, COMMAND_HISTORY, ListLink);
            Idch(0, pHistory);
            GetFieldValue(ListNext, SYM(LIST_ENTRY), "Flink", ListNext);
            Print("----\n");
        }

        return TRUE;
    }

    GetFieldOffset(SYM(CONSOLE_INFORMATION), "ConsoleLock", &dwOffset);
    GetFieldOffset(SYM(CONSOLE_INFORMATION), "InputBuffer", &dwOffset2);
    Print("\t pConsoleLock           %#p\n"
          "\t RefCount               0x%04lX\n"
          "\t WaitCount              0x%04lX\n"
          "\t pInputBuffer           %#p\n"
          "\t pCurrentScreenBuffer   %#p\n"
          "\t pScreenBuffers         %#p\n"
          "\t hWnd                   0x%08lX\n"
          "\t hDC                    0x%08lX\n"
          "\t LastAttributes         0x%04lX\n",
          pConsole + dwOffset,
          ReadField(RefCount),
          ReadField(WaitCount),
          pConsole + dwOffset2,
          ReadField(CurrentScreenBuffer),
          ReadField(ScreenBuffers),
          ReadField(hWnd),
          ReadField(hDC),
          ReadField(LastAttributes));

    Print("\t Flags                  0x%08lX%s\n",
          ReadField(Flags), GetFlags(GF_CONSOLE, (DWORD)ReadField(Flags), NULL));
    Print("\t FullScreenFlags        0x%04lX%s\n",
          ReadField(FullScreenFlags),
          GetFlags(GF_FULLSCREEN, (DWORD)ReadField(FullScreenFlags), NULL));
    Print("\t ConsoleHandle          0x%08lX\n"
          "\t CtrlFlags              0x%08lX\n",
          ReadField(ConsoleHandle),
          ReadField(CtrlFlags)
          );

    if (opts & OFLAG(v)) {
        Print("\t hMenu                  0x%08lX\n"
              "\t hHeirMenu              0x%08lX\n"
              "\t hSysPalette            0x%08lX\n"
              "\t WindowRect.L T R B     0x%08lX 0x%08lX 0x%08lX 0x%08lX\n"
              "\t ResizeFlags            0x%08lX\n"
              "\t OutputQueue.F B        0x%08lX 0x%08lX\n"
              "\t InitEvents[]           0x%08lX 0x%08lX\n"
              "\t ClientThreadHandle     0x%08lX\n"
              "\t ProcessHandleList.F B  %#p %#p\n"
              "\t CommandHistoryList.F B %#p %#p\n"
              "\t ExeAliasList.F B       %#p %#p\n",
              ReadField(hMenu),
              ReadField(hHeirMenu),
              ReadField(hSysPalette),
              ReadField(WindowRect.left),
              ReadField(WindowRect.top),
              ReadField(WindowRect.right),
              ReadField(WindowRect.bottom),
              ReadField(ResizeFlags),
              ReadField(OutputQueue.Flink),
              ReadField(OutputQueue.Blink),
              ReadField(InitEvents[0]),
              ReadField(InitEvents[1]),
              ReadField(ClientThreadHandle),
              ReadField(ProcessHandleList.Flink),
              ReadField(ProcessHandleList.Blink),
              ReadField(CommandHistoryList.Flink),
              ReadField(CommandHistoryList.Blink),
              ReadField(ExeAliasList.Flink),
              ReadField(ExeAliasList.Blink)
              );
        Print("\t NumCommandHistories    0x%04lX\n"
              "\t MaxCommandHistories    0x%04lX\n"
              "\t CommandHistorySize     0x%04lX\n"
              "\t OriginalTitleLength    0x%04lX\n"
              "\t TitleLength            0x%04lX\n"
              "\t OriginalTitle          %ws\n"
              "\t dwHotKey               0x%08lX\n"
              "\t hIcon                  0x%08lX\n"
              "\t iIcondId               0x%08lX\n"
              "\t ReserveKeys            0x%02lX\n"
              "\t WaitQueue              0x%08lX\n",
              ReadField(NumCommandHistories),
              ReadField(MaxCommandHistories),
              ReadField(CommandHistorySize),
              ReadField(OriginalTitleLength),
              ReadField(TitleLength),
              ReadField(dwHotKey),
              ReadField(hIcon),
              ReadField(iIconId),
              ReadField(ReserveKeys),
              ReadField(WaitQueue)
              );
        Print("\t SelectionFlags         0x%08lX%s\n"
              "\t SelectionRect.L T R B  0x%04lX 0x%04lX 0x%04lX 0x%04lX\n"
              "\t SelectionAnchor.X Y    0x%04lX 0x%04lX\n"
              "\t TextCursorPosition.X Y 0x%04lX 0x%04lX\n"
              "\t TextCursorSize         0x%08lX\n"
              "\t TextCursorVisible      0x%02lX\n"
              "\t InsertMode             0x%02lX\n"
              "\t wShowWindow            0x%04lX\n"
              "\t dwWindowOriginX        0x%08lX\n"
              "\t dwWindowOriginY        0x%08lX\n"
              "\t PopupCount             0x%04lX\n",
              ReadField(SelectionFlags),
              GetFlags(GF_CONSOLESEL, (DWORD)ReadField(SelectionFlags), NULL),
              ReadField(SelectionRect.Left),
              ReadField(SelectionRect.Top),
              ReadField(SelectionRect.Right),
              ReadField(SelectionRect.Bottom),
              ReadField(SelectionAnchor.X),
              ReadField(SelectionAnchor.Y),
              ReadField(TextCursorPosition.X),
              ReadField(TextCursorPosition.Y),
              ReadField(TextCursorSize),
              ReadField(TextCursorVisible),
              ReadField(InsertMode),
              ReadField(wShowWindow),
              ReadField(dwWindowOriginX),
              ReadField(dwWindowOriginY),
              ReadField(PopupCount)
              );
        Print("\t VDMStartHardwareEvent  0x%08lX\n"
              "\t VDMEndHardwareEvent    0x%08lX\n"
              "\t VDMProcessHandle       0x%08lX\n"
              "\t VDMProcessId           0x%08lX\n"
              "\t VDMBufferSectionHandle 0x%08lX\n"
              "\t VDMBuffer              0x%08lX\n"
              "\t VDMBufferClient        0x%08lX\n"
              "\t VDMBufferSize.X Y      0x%04lX 0x%04lX\n"
              "\t StateSectionHandle     0x%08lX\n"
              "\t StateBuffer            0x%08lX\n"
              "\t StateBufferClient      0x%08lX\n"
              "\t StateLength            0x%08lX\n",
              ReadField(VDMStartHardwareEvent),
              ReadField(VDMEndHardwareEvent),
              ReadField(VDMProcessHandle),
              ReadField(VDMProcessId),
              ReadField(VDMBufferSectionHandle),
              ReadField(VDMBuffer),
              ReadField(VDMBufferClient),
              ReadField(VDMBufferSize.X),
              ReadField(VDMBufferSize.Y),
              ReadField(StateSectionHandle),
              ReadField(StateBuffer),
              ReadField(StateBufferClient),
              ReadField(StateLength)
              );
        Print("\t CP                     0x%08lX\n"
              "\t OutputCP               0x%08lX\n"
              "\t hWndProgMan            0x%08lX\n"
              "\t bIconInit              0x%08lX\n"
              "\t LimitingProcessId      0x%08lX\n"
              "\t TerminationEvent       0x%08lX\n"
              "\t VerticalClientToWin    0x%04lX\n"
              "\t HorizontalClientToWin  0x%04lX\n",
              ReadField(CP),
              ReadField(OutputCP),
              ReadField(hWndProgMan),
              ReadField(bIconInit),
              ReadField(LimitingProcessId),
              ReadField(TerminationEvent),
              ReadField(VerticalClientToWindow),
              ReadField(HorizontalClientToWindow)
              );
#ifdef FE_SB
        Print("\t EudcInformation        0x%08lX\n"
              "\t FontCacheInformation   0x%08lX\n",
              ReadField(EudcInformation),
              ReadField(FontCacheInformation)
              );
#ifdef FE_IME
        Print("\tConsoleIme:\n"
              "\t ScrollFlag             0x%08lX\n"
              "\t ScrollWaitTimeout      0x%08lX\n"
              "\t ScrollWaitCountDown    0x%08lX\n"
              "\t CompStrData            0x%08lX\n"
              "\t ConvAreaMode           0x%08lX\n"
              "\t ConvAreaSystem         0x%08lX\n"
              "\t NumberOfConvAreaCompStr 0x%08lX\n"
              "\t ConvAreaCompStr         0x%08lX\n"
              "\t ConvAreaRoot           0x%08lX\n",
              ReadField(ConsoleIme.ScrollFlag),
              ReadField(ConsoleIme.ScrollWaitTimeout),
              ReadField(ConsoleIme.ScrollWaitCountDown),
              ReadField(ConsoleIme.CompStrData),
              ReadField(ConsoleIme.ConvAreaMode),
              ReadField(ConsoleIme.ConvAreaSystem),
              ReadField(ConsoleIme.NumberOfConvAreaCompStr),
              ReadField(ConsoleIme.ConvAreaCompStr),
              ReadField(ConsoleIme.ConvAreaRoot)
              );
#endif // FE_IME
#endif // FE_SB
    }

    return TRUE;
}

/***************************************************************************\
* dt - Dump Text - dump text buffer information
*
* dt address    - dumps text buffer information  for console at address
*
\***************************************************************************/
BOOL Idt(
    DWORD opts,
    ULONG64 pConsole)
{
    BOOL fPrintLine;
    ULONG i, NumberOfConsoleHandles;
    SHORT sh;
    DWORD FrameBufPtr;
    ULONG64 pRow;

    if (!pConsole) {
        /*
         * If no console is specified, dt all of them
         */
        moveExpValue(&NumberOfConsoleHandles,
                     SYM(NumberOfConsoleHandles));
        Print("got %d handles", NumberOfConsoleHandles); // TODO
        moveExpValuePtr(&pConsole,
                        SYM(ConsoleHandles));
        Print("got ConsoleHandles ptr at %#p", pConsole); // TODO
        fPrintLine = FALSE;
        for (i = 0; i < NumberOfConsoleHandles; i++) {
            if (pConsole) {
                InitTypeRead(pConsole, SYM(CONSOLE_INFORMATION));
                if (fPrintLine) {
                    Print("==========================================\n");
                }
                if (!Idt(opts, pConsole)) {
                    return FALSE;
                }
                fPrintLine = TRUE;
            }
            (ULONG_PTR)pConsole += GetTypeSize(SYM(PCONSOLE_INFORMATION));
        }

        return TRUE;
    }

    InitTypeRead(pConsole, SYM(CONSOLE_INFORMATION));

    Print("PCONSOLE @ %#p\n", pConsole);
    Print("\t Title                %ws\n"
          "\t pCurrentScreenBuffer 0x%08lX\n"
          "\t pScreenBuffers       0x%08lX\n"
          "\t VDMBuffer            0x%08lx\n"
          "\t CP %d,  OutputCP %d\n",
          ReadField(Title),
          ReadField(CurrentScreenBuffer),
          ReadField(ScreenBuffers),
          ReadField(VDMBuffer),
          ReadField(Console.CP),
          ReadField(OutputCP)
          );

    moveExpValue(&FrameBufPtr, SYM(FrameBufPtr));
    InitTypeRead(ReadField(CurrentScreenBuffer), SYM(SCREEN_INFORMATION));
    if (ReadField(Flags) & CONSOLE_TEXTMODE_BUFFER) {
        Print("\t TextInfo.Rows         0x%08X\n"
              "\t TextInfo.TextRows     0x%08X\n"
              "\t TextInfo.FirstRow     0x%08X\n"
              "\t FrameBufPtr           0x%08X\n",
              ReadField(BufferInfo.TextInfo.Rows),
              ReadField(BufferInfo.TextInfo.TextRows),
              ReadField(BufferInfo.TextInfo.FirstRow),
              FrameBufPtr);
    }

    pRow = ReadField(BufferInfo.TextInfo.Rows);
    if (opts & OFLAG(c)) {
        SHORT Y = (SHORT)ReadField(ScreenBufferSize.Y);

        Print("Checking BufferInfo...\n");
        for (sh = 0; sh < Y; sh++) {
            InitTypeRead(pRow, SYM(ROW));

            /*
             * Check that Attrs points to the in-place AttrPair if there
             * if only one AttrPair for this Row.
             */
            if (ReadField(AttrRow.Length) == 1) {
                DWORD dwOffset;
                GetFieldOffset(SYM(ATTR_ROW), "AttrPair", &dwOffset);
                if (ReadField(AttrRow.Attrs) != ReadField(AttrRow) + dwOffset) {
                    Print("Bad Row[%lx]:  Attrs %#p should be %lx\n",
                        sh, ReadField(AttrRow.Attrs), ReadField(AttrRow) + dwOffset);
                }
            }

            /*
             * Some other checks?
             */

            (ULONG_PTR)pRow += GetTypeSize(SYM(PROW));
        }
        Print("...check completed\n");
    }

#if 0

//
// BUGBUG
// This routine had some screwy logic where -v was followed by an integer
// (nLines). I'm ignoring that for now.
//

    if (!(opts & OFLAG(v))) {
        return TRUE;
    }

    
    GetFieldValue(pScreen, SYM(SCREEN_INFORMATION), "BufferInfo.TextInfo.Rows", pRow);
    for (i = 0; i < nLines; i++) {
        InitTypeRead(pRow, SYM(ROW));

        Print("Row %2d: %4x %4x, %4x %4x, %lx:\"%ws\"\n",
            i,
            (USHORT)ReadField(CharRow.Right),
            (USHORT)ReadField(CharRow.OldRight),
            (USHORT)ReadField(CharRow.Left),
            (USHORT)ReadField(CharRow.OldLeft),
            ReadField(CharRow.Chars), ReadField(CharRow.Chars));
        Print("      %4x %4x,%04x or %lx\n",
            (USHORT)ReadField(AttrRow.Length),
            (USHORT)ReadField(AttrRow.AttrPair.Length),
            (WORD)ReadField(Row.AttrRow.AttrPair.Attr),
            ReadField(AttrRow.Attrs));
        (ULONG_PTR)pRow += GetTypeSize(SYM(PROW));
    }
#endif

    return TRUE;
}

/***************************************************************************\
* df - Dump Font - dump Font information
*
* df address    - dumps simple info for console at address
*                 (takes handle too)
\***************************************************************************/
BOOL Idf(
    VOID)
{
    ULONG64 pFN, pFontInfo;
    DWORD NumberOfFonts, FontInfoLength, dw;

    Print("Faces:\n");
    moveExpValuePtr(&pFN, SYM(gpFaceNames));
    while (pFN != 0) {
        InitTypeRead(pFN, SYM(FACENODE));
        Print(" \"%ls\"\t%s %s %s %s %s %s\n",
              ReadField(awch[0]),
              ReadField(dwFlag) & EF_NEW        ? "NEW"        : "   ",
              ReadField(dwFlag) & EF_OLD        ? "OLD"        : "   ",
              ReadField(dwFlag) & EF_ENUMERATED ? "ENUMERATED" : "          ",
              ReadField(dwFlag) & EF_OEMFONT    ? "OEMFONT"    : "       ",
              ReadField(dwFlag) & EF_TTFONT     ? "TTFONT"     : "      ",
              ReadField(dwFlag) & EF_DEFFACE    ? "DEFFACE"    : "       ");
        pFN = ReadField(pNext);
    }

    moveExpValue(&FontInfoLength, SYM(FontInfoLength));
    moveExpValue(&NumberOfFonts, SYM(NumberOfFonts));
    moveExpValuePtr(&pFontInfo, SYM(FontInfo));

    Print("0x%lx fonts cached, 0x%lx allocated:\n", NumberOfFonts, FontInfoLength);

    for (dw = 0; dw < NumberOfFonts; dw++, pFontInfo++) {
        InitTypeRead(pFontInfo, SYM(FONTINFO));
        Print("%04x hFont    0x%08lX \"%ls\"\n"
              "     SizeWant (%d;%d)\n"
              "     Size     (%d;%d)\n"
              "     Family   %02X\n"
              "     Weight   0x%08lX\n",
              dw,
              ReadField(hFont),
              ReadField(FaceName),
              ReadField(SizeWant.X), ReadField(FontInfo.SizeWant.Y),
              ReadField(Size.X), ReadField(Size.Y),
              ReadField(Family),
              ReadField(Weight));

#ifdef FE_SB
        Print("     CharSet  0x%02X\n",
              ReadField(tmCharSet));
#endif // FE_SB
    }

    return TRUE;
}

/***************************************************************************\
* di - Dump Input - dump input buffer
*
* di address    - dumps simple info for input at address
*
\***************************************************************************/
BOOL Idi(
    DWORD opts,
    ULONG64 pInput)
{
    /*
     * If no INPUT_INFORMATION is specified, dt all of them
     */
    if (!pInput) {
        BOOL fPrintLine;
        ULONG64 pConsole;
        ULONG NumberOfConsoleHandles, i;

        moveExpValue(&NumberOfConsoleHandles, SYM(NumberOfConsoleHandles));
        moveExpValuePtr(&pConsole, SYM(ConsoleHandles));
        fPrintLine = FALSE;
        for (i = 0; i < NumberOfConsoleHandles; i++) {
            if (pConsole) {
                DWORD dwOffset;

                if (fPrintLine) {
                    Print("---\n");
                }

                GetFieldOffset(SYM(CONSOLE_INFORMATION), "InputBuffer", &dwOffset);
                pInput = pConsole + dwOffset;
                if (!Idi(opts, pInput)) {
                    return FALSE;
                }
                fPrintLine = TRUE;
            }
            (ULONG_PTR)pConsole += GetTypeSize(SYM(PCONSOLE_INFORMATION));
        }

        return TRUE;
    }

    InitTypeRead(pInput, SYM(INPUT_INFORMATION));

    Print("PINPUT @ 0x%lX\n", pInput);
    Print("\t pInputBuffer         %#p\n"
          "\t InputBufferSize      0x%08lX\n"
          "\t AllocatedBufferSize  0x%08lX\n"
          "\t InputMode            0x%08lX\n"
          "\t RefCount             0x%08lX\n"
          "\t First                %#p\n"
          "\t In                   %#p\n"
          "\t Out                  %#p\n"
          "\t Last                 %#p\n"
          "\t ReadWaitQueue.Flink  %#p\n"
          "\t ReadWaitQueue.Blink  %#p\n"
          "\t InputWaitEvent       %#p\n",
          ReadField(InputBuffer),
          ReadField(InputBufferSize),
          ReadField(AllocatedBufferSize),
          ReadField(InputMode),
          ReadField(RefCount),
          ReadField(First),
          ReadField(In),
          ReadField(Out),
          ReadField(Last),
          ReadField(ReadWaitQueue.Flink),
          ReadField(ReadWaitQueue.Blink),
          ReadField(InputWaitEvent)
          );

    return TRUE;
}

/***************************************************************************\
* dir - Dump Input Record - dump input buffer
*
* dir address number    - dumps simple info for input at address
*
\***************************************************************************/
BOOL Idir(
    DWORD opts,
    ULONG64 pInputRecord,
    ULONG64 NumRecords)
{
    DWORD i;

    UNREFERENCED_PARAMETER(opts);

    if (NumRecords == 0) {
        NumRecords = 25;
    }

    Print("%x PINPUTRECORDs @ %#p\n", NumRecords, pInputRecord);
    for (i = 0; i < NumRecords; ++i) {
        InitTypeRead(pInputRecord, SYM(INPUT_RECORD));

        switch (ReadField(EventType)) {
            case KEY_EVENT:
                Print("\t KEY_EVENT\n");
                if (ReadField(Event.KeyEvent.bKeyDown)) {
                    Print("\t  KeyDown\n");
                } else {
                    Print("\t  KeyUp\n");
                }

                Print("\t  wRepeatCount %d\n",
                      ReadField(Event.KeyEvent.wRepeatCount));
                Print("\t  wVirtualKeyCode %x\n",
                      ReadField(Event.KeyEvent.wVirtualKeyCode));
                Print("\t  wVirtualScanCode %x\n",
                      ReadField(Event.KeyEvent.wVirtualScanCode));
                Print("\t  aChar is %c",
                      ReadField(Event.KeyEvent.uChar.AsciiChar));
                Print("\n");
                Print("\t  uChar is %x\n",
                      ReadField(Event.KeyEvent.uChar.UnicodeChar));
                Print("\t  dwControlKeyState %x\n",
                      ReadField(Event.KeyEvent.dwControlKeyState));
                break;
            case MOUSE_EVENT:
                Print("\t MOUSE_EVENT\n"
                      "\t   dwMousePosition %x %x\n"
                      "\t   dwButtonState %x\n"
                      "\t   dwControlKeyState %x\n"
                      "\t   dwEventFlags %x\n",
                      ReadField(Event.MouseEvent.dwMousePosition.X),
                      ReadField(Event.MouseEvent.dwMousePosition.Y),
                      ReadField(Event.MouseEvent.dwButtonState),
                      ReadField(Event.MouseEvent.dwControlKeyState),
                      ReadField(Event.MouseEvent.dwEventFlags)
                     );

                break;
            case WINDOW_BUFFER_SIZE_EVENT:
                Print("\t WINDOW_BUFFER_SIZE_EVENT\n"
                      "\t   dwSize %x %x\n",
                      ReadField(Event.WindowBufferSizeEvent.dwSize.X),
                      ReadField(Event.WindowBufferSizeEvent.dwSize.Y)
                     );
                break;
            case MENU_EVENT:
                Print("\t MENU_EVENT\n"
                      "\t   dwCommandId %x\n",
                      ReadField(Event.MenuEvent.dwCommandId)
                     );
                break;
            case FOCUS_EVENT:
                Print("\t FOCUS_EVENT\n");
                if (ReadField(Event.FocusEvent.bSetFocus)) {
                    Print("\t bSetFocus is TRUE\n");
                } else {
                    Print("\t bSetFocus is FALSE\n");
                }
                break;
            default:
                Print("\t Unknown event type 0x%x\n", ReadField(EventType));
                break;
        }
        (ULONG_PTR)pInputRecord += GetTypeSize(SYM(INPUT_RECORD));
    }

    return TRUE;
}

/***************************************************************************\
* ds - Dump Screen - dump SCREEN_INFORMATION struct
*
* ds address    - dumps simple info for input at address
\***************************************************************************/
BOOL Ids(
    DWORD opts,
    ULONG64 pScreen)
{
    UNREFERENCED_PARAMETER(opts);

    InitTypeRead(pScreen, SYM(SCREEN_INFORMATION));

    Print("PSCREEN @ %#p\n", pScreen);
    Print("\t pConsole             %#p\n"
          "\t Flags                0x%08lX %s | %s\n"
          "\t OutputMode           0x%08lX\n"
          "\t RefCount             0x%08lX\n"
          "\t ScreenBufferSize.X Y 0x%08X 0x%08X\n"
          "\t Window.L T R B       0x%08X 0x%08X 0x%08X 0x%08X\n"
          "\t ResizingWindow       0x%08X\n",
          ReadField(Console),
          ReadField(Flags),
          ReadField(Flags) & CONSOLE_TEXTMODE_BUFFER ? "TEXTMODE" : "GRAPHICS",
          ReadField(Flags) & CONSOLE_OEMFONT_DISPLAY ? "OEMFONT" : "TT FONT",
          ReadField(OutputMode),
          ReadField(RefCount),
          (DWORD)ReadField(ScreenBufferSize.X),
          (DWORD)ReadField(ScreenBufferSize.Y),
          (DWORD)ReadField(Window.Left),
          (DWORD)ReadField(Window.Top),
          (DWORD)ReadField(Window.Right),
          (DWORD)ReadField(Window.Bottom),
          ReadField(ResizingWindow)
          );
    Print("\t Attributes           0x%08X\n"
          "\t PopupAttributes      0x%08X\n"
          "\t WindowMaximizedX     0x%08X\n"
          "\t WindowMaximizedY     0x%08X\n"
          "\t WindowMaximized      0x%08X\n"
          "\t CommandIdLow High    0x%08X 0x%08X\n"
          "\t CursorHandle         0x%08X\n"
          "\t hPalette             0x%08X\n"
          "\t dwUsage              0x%08X\n"
          "\t CursorDisplayCount   0x%08X\n"
          "\t WheelDelta           0x%08X\n",
          ReadField(Attributes),
          ReadField(PopupAttributes),
          ReadField(WindowMaximizedX),
          ReadField(WindowMaximizedY),
          ReadField(WindowMaximized),
          ReadField(CommandIdLow),
          ReadField(CommandIdHigh),
          ReadField(CursorHandle),
          ReadField(hPalette),
          ReadField(dwUsage),
          ReadField(CursorDisplayCount),
          ReadField(WheelDelta)
          );
    if (ReadField(Flags) & CONSOLE_TEXTMODE_BUFFER) {
        Print("\t TextInfo.Rows         %#p\n"
              "\t TextInfo.TextRows     %#p\n"
              "\t TextInfo.FirstRow     0x%08X\n",
              ReadField(BufferInfo.TextInfo.Rows),
              ReadField(BufferInfo.TextInfo.TextRows),
              ReadField(BufferInfo.TextInfo.FirstRow));

        Print("\t TextInfo.CurrentTextBufferFont.FontSize       0x%04X,0x%04X\n"
              "\t TextInfo.CurrentTextBufferFont.FontNumber     0x%08X\n",
              ReadField(BufferInfo.TextInfo.CurrentTextBufferFont.FontSize.X),
              ReadField(BufferInfo.TextInfo.CurrentTextBufferFont.FontSize.Y),
              ReadField(Screen.BufferInfo.TextInfo.CurrentTextBufferFont.FontNumber));

        Print("\t TextInfo.CurrentTextBufferFont.Family, Weight 0x%08X, 0x%08X\n"
              "\t TextInfo.CurrentTextBufferFont.FaceName       %ls\n"
              "\t TextInfo.CurrentTextBufferFont.FontCodePage   %d\n",
              ReadField(BufferInfo.TextInfo.CurrentTextBufferFont.Family),
              ReadField(Screen.BufferInfo.TextInfo.CurrentTextBufferFont.Weight),
              ReadField(BufferInfo.TextInfo.CurrentTextBufferFont.FaceName),
              ReadField(BufferInfo.TextInfo.CurrentTextBufferFont.FontCodePage));

        if (ReadField(BufferInfo.TextInfo.ListOfTextBufferFont)) {
            ULONG64 pLinkFont;
            ULONG Count = 0;

            pLinkFont = ReadField(BufferInfo.TextInfo.ListOfTextBufferFont);

            while (pLinkFont != 0) {
                InitTypeRead(pLinkFont, SYM(TEXT_BUFFER_FONT_INFO));

                Print("\t Link Font #%d\n", Count++);
                Print("\t  TextInfo.LinkOfTextBufferFont.FontSize       0x%04X,0x%04X\n"
                      "\t  TextInfo.LinkOfTextBufferFont.FontNumber     0x%08X\n",
                      ReadField(FontSize.X),
                      ReadField(FontSize.Y),
                      ReadField(FontNumber));

                Print("\t  TextInfo.LinkOfTextBufferFont.Family, Weight 0x%08X, 0x%08X\n"
                      "\t  TextInfo.LinkOfTextBufferFont.FaceName       %ls\n"
                      "\t  TextInfo.LinkOfTextBufferFont.FontCodePage   %d\n",
                      ReadField(Family),
                      ReadField(Weight),
                      ReadField(FaceName),
                      ReadField(FontCodePage));

                pLinkFont = ReadField(NextTextBufferFont);
            }
            Print("\n");
        }

        InitTypeRead(pScreen, SYM(SCREEN_INFORMATION));

        Print("\t TextInfo.ModeIndex         0x%08X\n"
#ifdef i386
              "\t TextInfo.WindowedWindowSize.X Y 0x%08X 0x%08X\n"
              "\t TextInfo.WindowedScreenSize.X Y 0x%08X 0x%08X\n"
              "\t TextInfo.MousePosition.X Y 0x%08X 0x%08X\n"
#endif
              "\t TextInfo.Flags             0x%08X\n",

              ReadField(BufferInfo.TextInfo.ModeIndex),
#ifdef i386
              ReadField(BufferInfo.TextInfo.WindowedWindowSize.X),
              ReadField(BufferInfo.TextInfo.WindowedWindowSize.Y),
              ReadField(BufferInfo.TextInfo.WindowedScreenSize.X),
              ReadField(BufferInfo.TextInfo.WindowedScreenSize.Y),
              ReadField(BufferInfo.TextInfo.MousePosition.X),
              ReadField(BufferInfo.TextInfo.MousePosition.Y),
#endif
              ReadField(BufferInfo.TextInfo.Flags));

        Print("\t TextInfo.CursorVisible        0x%08X\n"
              "\t TextInfo.CursorOn             0x%08X\n"
              "\t TextInfo.DelayCursor          0x%08X\n"
              "\t TextInfo.CursorPosition.X Y   0x%08X 0x%08X\n"
              "\t TextInfo.CursorSize           0x%08X\n"
              "\t TextInfo.CursorYSize          0x%08X\n"
              "\t TextInfo.UpdatingScreen       0x%08X\n",
              ReadField(BufferInfo.TextInfo.CursorVisible),
              ReadField(BufferInfo.TextInfo.CursorOn),
              ReadField(BufferInfo.TextInfo.DelayCursor),
              ReadField(BufferInfo.TextInfo.CursorPosition.X),
              ReadField(BufferInfo.TextInfo.CursorPosition.Y),
              ReadField(BufferInfo.TextInfo.CursorSize),
              ReadField(BufferInfo.TextInfo.CursorYSize),
              ReadField(BufferInfo.TextInfo.UpdatingScreen));

    } else {
        Print("\t GraphicsInfo.BitMapInfoLength 0x%08X\n"
              "\t GraphicsInfo.lpBitMapInfo     0x%08X\n"
              "\t GraphicsInfo.BitMap           0x%08X\n"
              "\t GraphicsInfo.ClientBitMap     0x%08X\n"
              "\t GraphicsInfo.ClientProcess    0x%08X\n"
              "\t GraphicsInfo.hMutex           0x%08X\n"
              "\t GraphicsInfo.hSection         0x%08X\n"
              "\t GraphicsInfo.dwUsage          0x%08X\n",
              ReadField(BufferInfo.GraphicsInfo.BitMapInfoLength),
              ReadField(BufferInfo.GraphicsInfo.lpBitMapInfo),
              ReadField(BufferInfo.GraphicsInfo.BitMap),
              ReadField(BufferInfo.GraphicsInfo.ClientBitMap),
              ReadField(BufferInfo.GraphicsInfo.ClientProcess),
              ReadField(BufferInfo.GraphicsInfo.hMutex),
              ReadField(BufferInfo.GraphicsInfo.hSection),
              ReadField(BufferInfo.GraphicsInfo.dwUsage)
        );
    }

    return TRUE;
}

/***************************************************************************\
* dcpt - Dump CPTABLEINFO
*
* dcpt address    - dumps CPTABLEINFO at address
* dcpt            - dumps CPTABLEINFO at GlyphCP
*
\***************************************************************************/
BOOL Idcpt(
    DWORD opts,
    ULONG64 pcpt)
{
    UNREFERENCED_PARAMETER(opts);

    if (!pcpt) {
        moveExpValuePtr(&pcpt, SYM(GlyphCP));
    }

    InitTypeRead(pcpt, SYM(CPTABLEINFO));
    Print("CPTABLEINFO @ %#p\n", pcpt);

    Print("  CodePage = 0x%x (%d)\n"
          "  MaximumCharacterSize = %x\n"
          "  DefaultChar = %x\n",
          ReadField(CodePage), ReadField(CodePage),
          ReadField(MaximumCharacterSize),
          ReadField(DefaultChar));

    Print("  UniDefaultChar = 0x%04x\n"
          "  TransDefaultChar = %x\n"
          "  TransUniDefaultChar = 0x%04x\n"
          "  DBCSCodePage = 0x%x (%d)\n",
          ReadField(UniDefaultChar),
          ReadField(TransDefaultChar),
          ReadField(TransUniDefaultChar),
          ReadField(DBCSCodePage), ReadField(DBCSCodePage));

    Print("  LeadByte[MAXIMUM_LEADBYTES] = %04x,%04x,%04x,...\n"
          "  MultiByteTable = %x\n"
          "  WideCharTable = %lx\n"
          "  DBCSRanges = %lx\n"
          "  DBCSOffsets = %lx\n",
          ReadField(LeadByte[0]), ReadField(LeadByte[1]), ReadField(LeadByte[2]),
          ReadField(MultiByteTable),
          ReadField(WideCharTable),
          ReadField(DBCSRanges),
          ReadField(DBCSOffsets));

    return TRUE;
}

/***************************************************************************\
* dch  - Dump Command History
*
* dch address    - dumps COMMAND_HISTORY at address
*
\***************************************************************************/
BOOL Idch(
    DWORD opts,
    ULONG64 pCmdHist)
{
    SHORT NumberOfCommands;
    DWORD dwTypeSize, dwOffset, CommandLength;
    WCHAR Buffer[512];
    int i;

    UNREFERENCED_PARAMETER(opts);

    InitTypeRead(pCmdHist, SYM(COMMAND_HISTORY));
    Print("COMMAND_HISTORY @ %#p\n", pCmdHist);

    Print("  Flags            = 0x%08lX%s\n",
          ReadField(Flags),  GetFlags(GF_CMDHIST, (DWORD)ReadField(Flags), NULL));
    Print("  ListLink.F B     = %#p %#p\n",
          ReadField(ListLink.Flink), ReadField(ListLink.Blink));

    Print("  AppName          = %ws\n", ReadField(AppName));

    Print("  NumberOfCommands = 0x%lx\n"
          "  LastAdded        = 0x%lx\n"
          "  LastDisplayed    = 0x%lx\n"
          "  FirstCommand     = 0x%lx\n"
          "  MaximumNumberOfCommands = 0x%lx\n",
          ReadField(NumberOfCommands),
          ReadField(LastAdded),
          ReadField(LastDisplayed),
          ReadField(FirstCommand),
          ReadField(MaximumNumberOfCommands));

    Print("  ProcessHandle    = 0x%08lX\n",
          ReadField(ProcessHandle));

    Print("  PopupList.F B    = %#p %#p\n",
          ReadField(PopupList.Flink), ReadField(PopupList.Blink));

    dwTypeSize = GetTypeSize(SYM(COMMAND));
    NumberOfCommands = (SHORT)ReadField(NumberOfCommands);
    GetFieldOffset(SYM(COMMAND_HISTORY), "Command", &dwOffset);
    for (i = 0; i < NumberOfCommands; i++) {
        ULONG64 pCmd = pCmdHist + i * dwTypeSize;

        GetFieldValue(pCmd, SYM(COMMAND_HISTORY), "CommandLength", CommandLength);
        
        moveBlock(Buffer, pCmd + dwOffset, min(CommandLength, ARRAY_SIZE(Buffer)));
        Print("   %03d: %d chars = \"%ws\"\n", i,
                CommandLength,
                Buffer);
        if (i == ReadField(LastAdded)) {
            Print("        (Last Added)\n");
        } else if (i == ReadField(LastDisplayed)) {
            Print("        (Last Displayed)\n");
        } else if (i == ReadField(FirstCommand)) {
            Print("        (First Command)\n");
        }
    }

    return TRUE;
}

#define HEAP_GRANULARITY    8
#define HEAP_SIZE(Size)     (((Size) + (HEAP_GRANULARITY - 1) + HEAP_GRANULARITY) & ~(HEAP_GRANULARITY - 1))

/***************************************************************************\
* dmem - Dump Memory - Dumps memory used by console stuff.
*
\***************************************************************************/
BOOL Idmem(
    DWORD opts,
    ULONG64 pConsole)
{
    ULONG i, NumberOfConsoleHandles;
    ULONG64 pScreen;
    ULONG cbTotal = 0;
    ULONG cbConsole = 0;
    ULONG cbInput = 0;
    ULONG cbOutput = 0;
    ULONG cbFE = 0;
    WCHAR buffer[256];

    if (!pConsole) {
        /*
         * If no console is specified, loop through all of them
         */
        moveExpValue(&NumberOfConsoleHandles,
                     SYM(NumberOfConsoleHandles));
        moveExpValuePtr(&pConsole,
                        SYM(ConsoleHandles));
        for (i = 0; i < NumberOfConsoleHandles; i++) {
            ULONG64 ptr;
            ReadPointer(pConsole, &ptr);
            if (ptr) {
                cbTotal += Idmem(opts, ptr);
                Print("==========================================\n");
            }
            (ULONG_PTR)pConsole += GetTypeSize(SYM(PCONSOLE_INFORMATION));
        }
        Print("Total Size for all consoles = %d bytes\n", cbTotal);

        return cbTotal;
    }

    InitTypeRead(pConsole, winsrv!CONSOLE_INFORMATION);

    DbgGetConsoleTitle(pConsole, buffer, ARRAY_SIZE(buffer));
    Print("PCONSOLE @ %#p   \"%ws\"\n", pConsole, buffer);

    cbConsole = HEAP_SIZE(GetTypeSize(SYM(CONSOLE_INFORMATION))) +
                HEAP_SIZE((ULONG)ReadField(TitleLength)) +
                HEAP_SIZE((ULONG)ReadField(OriginalTitleLength));

    cbInput = HEAP_SIZE((ULONG)ReadField(InputBuffer.AllocatedBufferSize));

    pScreen = ReadField(ScreenBuffers);
    while (pScreen) {
        InitTypeRead(pScreen, winsrv!SCREEN_INFORMATION);
        cbOutput += HEAP_SIZE(GetTypeSize(SYM(SCREEN_INFORMATION)));

        if (ReadField(Flags) & CONSOLE_TEXTMODE_BUFFER) {
            cbOutput += HEAP_SIZE((ULONG)ReadField(ScreenBufferSize.Y) *
                                      GetTypeSize(SYM(ROW))) +
                        HEAP_SIZE((ULONG)ReadField(ScreenBufferSize.X) *
                                      (ULONG)ReadField(ScreenBufferSize.Y) *
                                      sizeof(WCHAR));

            if (ReadField(BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter)) {
                cbFE += HEAP_SIZE((ULONG)ReadField(ScreenBufferSize.X) *
                            (ULONG)ReadField(ScreenBufferSize.Y * sizeof(WCHAR)));
            }

            if (ReadField(BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferAttribute)) {
                cbFE += HEAP_SIZE((ULONG)ReadField(ScreenBufferSize.X) *
                            (ULONG)ReadField(ScreenBufferSize.Y) * sizeof(BYTE));
            }

            if (ReadField(BufferInfo.TextInfo.DbcsScreenBuffer.TransWriteConsole)) {
                cbFE += HEAP_SIZE((ULONG)ReadField(ScreenBufferSize.X) *
                            (ULONG)ReadField(ScreenBufferSize.Y) * sizeof(WCHAR));
            }

            if (ReadField(BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows)) {
                cbFE += HEAP_SIZE((ULONG)ReadField(ScreenBufferSize.X) *
                            (ULONG)ReadField(ScreenBufferSize.Y) * sizeof(BYTE));
            }
        }

        pScreen = ReadField(Next);
    }

    cbTotal = cbConsole + cbInput + cbOutput + cbFE;

    if (opts & OFLAG(v)) {
        Print("    Console Size = %7d\n", cbConsole);
        Print("    Input Size   = %7d\n", cbInput);
        Print("    Output Size  = %7d\n", cbOutput);
        Print("    FE Size      = %7d\n", cbFE);
    }

    Print("Total Size       = %7d\n", cbTotal);

    return cbTotal;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID)
{
    return &ApiVersion;
}

VOID
WinDbgExtensionDllInit(
    WINDBG_EXTENSION_APIS *lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    bDebuggingChecked = (SavedMajorVersion == 0x0c);
}

BOOL
CopyUnicodeString(
    IN  ULONG64 pData,
    IN  char * pszStructName,
    IN  char * pszFieldName,
    OUT WCHAR *pszDest,
    IN  ULONG cchMax)
{
    ULONG Length;
    ULONG64 Buffer;
    char szLengthName[256];
    char szBufferName[256];

    if (pData == 0) {
        pszDest[0] = '\0';
        return FALSE;
    }

    strcpy(szLengthName, pszFieldName);
    strcat(szLengthName, ".Length");
    strcpy(szBufferName, pszFieldName);
    strcat(szBufferName, ".Buffer");

    if (GetFieldValue(pData, pszStructName, szLengthName, Length) ||
        GetFieldValue(pData, pszStructName, szBufferName, Buffer)) {

        Print("1\n");
        wcscpy(pszDest, L"<< Can't get name >>");
        return FALSE;
    }

    if (Buffer == 0) {
        wcscpy(pszDest, L"<null>");
    } else {
        ULONG cbText;
        cbText = min(cchMax, Length + sizeof(WCHAR));
        if (!(tryMoveBlock(pszDest, Buffer, cbText))) {
            wcscpy(pszDest, L"<< Can't get value >>");
            Print("2\n");
            return FALSE;
        }
    }

    pszDest[cchMax] = L'\0';
    return TRUE;
}

VOID
DbgGetConsoleTitle(
    IN ULONG64 pConsole,
    OUT PWCHAR buffer,
    IN UINT cbSize)
{
    ULONG64 ptr;
    ULONG dwOffset, TitleLength;

    GetFieldOffset(SYM(CONSOLE_INFORMATION), "Title", &dwOffset);
    ReadPointer(pConsole + dwOffset, &ptr);
    GetFieldValue(pConsole, SYM(CONSOLE_INFORMATION), "TitleLength", TitleLength);
    cbSize = min(cbSize, TitleLength);
    moveBlock(buffer, ptr, (DWORD)ReadField(TitleLength) * sizeof(WCHAR));
    buffer[cbSize] = L'\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\conime\imefull.c ===
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//  MODULE:   imefull.c
//
//  PURPOSE:   Console IME control.
//
//  PLATFORMS: Windows NT-J 3.51
//
//  FUNCTIONS:
//    ImeOpenClose() - calls initialization functions, processes message loop
//
//  History:
//
//  27.Jul.1995 v-HirShi (Hirotoshi Shimizu)    created
//
//  COMMENTS:
//

#include "precomp.h"
#pragma hdrstop

//**********************************************************************
//
// IMEOpenClose()
//
// This routines calls IMM API to open or close IME.
//
//**********************************************************************

VOID ImeOpenClose( HWND hWnd, BOOL fFlag )
{
    HIMC            hIMC;

    //
    // If fFlag is true then open IME; otherwise close it.
    //

    if ( !( hIMC = ImmGetContext( hWnd ) ) )
        return;

    ImmSetOpenStatus( hIMC, fFlag );

    ImmReleaseContext( hWnd, hIMC );

}

#ifdef DEBUG_MODE
/************************************************************************
*
*   VirtualKeyHandler - WM_KEYDOWN handler
*
*
*   INPUT:  HWND - handle to the window for repainting output.
*           UINT - virtual key code.
*
************************************************************************/

VOID VirtualKeyHandler( HWND hWnd, UINT wParam, UINT lParam )
{
    PCONSOLE_TABLE ConTbl;
    int i;
    static int delta ;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    if ( ConTbl->fInCandidate ||
         ( ConTbl->fInComposition && !MoveCaret( hWnd ) )
       )
        return;

    switch( wParam )
    {
    case VK_HOME:   // beginning of line
        xPos = FIRSTCOL;
        break;

    case VK_END:    // end of line
        xPos = xPosLast ;
        break;

    case VK_RIGHT:
        if ( IsUnicodeFullWidth( ConvertLine[xPos] ) ){
            if (xPos > xPosLast - 2 ) break;  //last character don't move
            xPos += 2;                     //skip 2 for DB Character
        }
        else
            xPos = min( xPos+1, xPosLast );
        break;

    case VK_LEFT:

        xPos = max( xPos-1, FIRSTCOL );

        if ( IsUnicodeFullWidth( ConvertLine[xPos] ) )
            xPos--;
        break;

    case VK_BACK:   // backspace

        if ( xPos > FIRSTCOL ) {
            delta = 1 ;

            //
            // DB Character so backup one more to allign on boundary
            //
            if ( IsUnicodeFullWidth( ConvertLine[xPos] ) )
                delta = 2 ;
            //
            // Fall Through to VK_DELETE to adjust row
            //
            xPos -= delta ;
            for ( i = xPos ; i < xPosLast+2 ; i++) {
                ConvertLine[i] = ConvertLine[i+delta] ;
                ConvertLineAtr[i] = ConvertLineAtr[i+delta] ;
            }
            xPosLast -= delta ;
        }
        else     //FIRST COLUMN  don't backup -- this would change for wrapping
           break;
        goto Repaint ;
        break;
    case VK_DELETE:
        if ( !IsUnicodeFullWidth( ConvertLine[xPos] ) ) {

            //
            // Move rest of line left by one, then blank out last character
            //

            for ( i = xPos; i < xPosLast; i++ ) {
                ConvertLine[i] = ConvertLine[i+1];
                ConvertLineAtr[i] = ConvertLineAtr[i+1];
            }
            xPosLast-- ;

        } else {

            //
            // Move line left by two bytes, blank out last two bytes
            //

            for ( i = xPos; i < xPosLast; i++ ) {
                ConvertLine[i] = ConvertLine[i+2];
                ConvertLineAtr[i] = ConvertLineAtr[i+2];
            }
            xPosLast -= 2 ;
        }

        goto Repaint ;
        break;

    case VK_TAB:    // tab  -- tabs are column allignment not character
        {
         int xTabMax = xPos + TABSTOP;
         int xPosPrev;

         do {
             xPosPrev = xPos;
            if ( IsUnicodeFullWidth( ConvertLine[xPos] ) ){
                if (xPos > xPosLast - 2 ) break;  //last character don't move
                xPos += 2;                     //skip 2 for DB Character
            }
            else
                xPos = min( xPos+1, xPosLast );

         } while ( (xPos % TABSTOP) &&
                   (xPos < xTabMax) &&
                   (xPos != xPosPrev));

        }
        goto Repaint ;
        break;

    case VK_RETURN: // linefeed
        for (i = FIRSTCOL ; i < MAXCOL ; i++) {
            ConvertLine[i] = ' ' ;
            ConvertLineAtr[i] = 0 ;
        }
        xPos = FIRSTCOL;
        xPosLast = FIRSTCOL;
Repaint:
        {
        //
        // Repaint the entire line
        //
        HDC hdc;

        hdc = GetDC( hWnd );
        HideCaret( hWnd );
        DisplayConvInformation( hWnd ) ;
        ReleaseDC( hWnd, hdc );
        }
        break;
    }
    ResetCaret( hWnd );
}
#endif

/************************************************************************
*
*   CharHandler - WM_CHAR handler
*
************************************************************************/

VOID CharHandlerFromConsole( HWND hWnd, UINT Message, ULONG wParam, ULONG lParam)
{
    UINT TmpMessage ;
    DWORD dwImmRet ;
    UINT uVKey ;
    UINT wParamSave ;

    if (HIWORD(wParam) == 0){
        wParamSave = wParam ;
    }
    else {
        if (Message == WM_KEYDOWN   +CONIME_KEYDATA || Message == WM_KEYUP   +CONIME_KEYDATA ||
            Message == WM_SYSKEYDOWN+CONIME_KEYDATA || Message == WM_SYSKEYUP+CONIME_KEYDATA){
            wParamSave = 0 ;
        }
        else if(HIWORD(wParam) > 0x00ff){
            WCHAR WideChar ;
            UCHAR MultiChar ;
            WideChar = HIWORD(wParam) ;
            WideCharToMultiByte(CP_OEMCP, 0, &WideChar, 1, &MultiChar, 1, NULL, NULL) ;
            wParamSave = MultiChar ;
        }
        else {
            wParamSave = HIWORD(wParam) ;
        }
    }

    if (HIWORD(lParam) & KF_UP) // KEY_TRANSITION_UP
        TmpMessage = WM_KEYUP ;
    else
        TmpMessage = WM_KEYDOWN ;


    // Return Value of ClientImmProcessKeyConsoleIME
    // IPHK_HOTKEY          1   - the vkey is IME hotkey
    // IPHK_PROCESSBYIME    2   - the vkey is the one that the IME is waiting for
    // IPHK_CHECKCTRL       4   - not used by NT IME
    dwImmRet = ImmCallImeConsoleIME(hWnd, TmpMessage, wParam, lParam, &uVKey) ;

    if ( dwImmRet & IPHK_HOTKEY ) {
    //
    // if this vkey is the IME hotkey, we won't pass
    // it to application or hook procedure.
    // This is what Win95 does. [takaok]
    //
       return ;
    }
    else if (dwImmRet & IPHK_PROCESSBYIME) {
        BOOL Status ;

//3.51
//      uVKey = (wParamSave<<8) | uVKey ;
//      Status = ClientImmTranslateMessageMain( hWnd,uVKey,lParam);

        Status = ImmTranslateMessage(hWnd, TmpMessage, wParam, lParam);


    }
    else if (dwImmRet & IPHK_CHECKCTRL) {
        CharHandlerToConsole( hWnd, Message-CONIME_KEYDATA, wParamSave, lParam);
    }
    else
    {
        if ((Message == WM_CHAR   +CONIME_KEYDATA)||
            (Message == WM_SYSCHAR+CONIME_KEYDATA)) {
            CharHandlerToConsole( hWnd, Message-CONIME_KEYDATA, wParamSave, lParam);
        }
        else
            CharHandlerToConsole( hWnd, Message-CONIME_KEYDATA, wParam, lParam);
    }

}

VOID CharHandlerToConsole( HWND hWnd, UINT Message, ULONG wParam, ULONG lParam)
{
    PCONSOLE_TABLE ConTbl;
    WORD  ch ;
    int   NumByte = 0 ;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    if (HIWORD(lParam) & KF_UP ) {
        PostMessage( ConTbl->hWndCon,
                     Message+CONIME_KEYDATA,
                     wParam,
                     lParam) ;
        return ;
    }

    ch = LOWORD(wParam) ;
    if ((ch < UNICODE_SPACE) ||
        ((ch >= UNICODE_SPACE) &&
        ((Message == WM_KEYDOWN) || (Message == WM_SYSKEYDOWN) ))) {
#ifdef DEBUG_MODE
        VirtualKeyHandler( hWnd, wParam ,lParam) ;
#endif
        PostMessage( ConTbl->hWndCon,
                     Message+CONIME_KEYDATA,
                     wParam,
                     lParam) ;
        return ;
    }

#ifdef DEBUG_MODE
    StoreChar( hWnd, ch, 0);
#endif

    PostMessage( ConTbl->hWndCon,
                 Message+CONIME_KEYDATA,
                 wParam,          //*Dest,
                 lParam) ;
}

#ifdef DEBUG_MODE
//**********************************************************************
//
// void ImeUIMove()
//
// Handler routine of WM_MOVE message.
//
//*********************************************************************

VOID ImeUIMoveCandWin( HWND hwnd )
{
    PCONSOLE_TABLE ConTbl;

    ConTbl = SearchConsole(LastConsole);
    if (ConTbl == NULL) {
        DBGPRINT(("CONIME: Error! Cannot found registed Console\n"));
        return;
    }

    if ( ConTbl->fInCandidate )
    {
        POINT           point;          // Storage for caret position.
        int             i;              // loop counter.
        int             NumCandWin;     // Storage for num of cand win.
        RECT            rect;           // Storage for client rect.

        //
        // If current IME state is in chosing candidate, here we
        // move all candidate windows, if any, to the appropriate
        // position based on the parent window's position.
        //

        NumCandWin = 0;

        GetCaretPos( (LPPOINT)&point );
        ClientToScreen( hwnd, (LPPOINT)&point );

        for ( i = 0; i < MAX_LISTCAND ; i++ )
        {
            if ( ConTbl->hListCand[ i ] )
            {
                GetClientRect( ConTbl->hListCand[ i ], &rect );

                MoveWindow( ConTbl->hListCand[ i ],
                            point.x + X_INDENT * NumCandWin,
                            point.y + Y_INDENT * NumCandWin + cyMetrics,
                            ( rect.right - rect.left + 1 ),
                            ( rect.bottom - rect.top + 1 ), TRUE );

                NumCandWin++;
            }
        }
    }
}
#endif

#ifdef DEBUG_MODE
/************************************************************************
*
*   ResetCaret - Reset caret shape to match input mode (overtype/insert)
*
************************************************************************/

VOID ResetCaret( HWND hWnd )
{

    HideCaret( hWnd );
    DestroyCaret();
    CreateCaret( hWnd,
         NULL,
         IsUnicodeFullWidth( ConvertLine[xPos] ) ?
           CaretWidth*2 : CaretWidth,
         cyMetrics );
    SetCaretPos( xPos * cxMetrics, 0 );
    ShowCaret( hWnd );

}

//**********************************************************************
//
// BOOL MoveCaret()
//
//**********************************************************************

BOOL MoveCaret( HWND hwnd )
{
    HIMC        hIMC;
    BOOL        retVal = TRUE;

    if ( !( hIMC = ImmGetContext( hwnd ) ) )
    return retVal;

    if ( ImmGetCompositionString( hIMC, GCS_CURSORPOS,
                  (void FAR *)NULL, 0 ) )
    retVal = FALSE;

    ImmReleaseContext( hwnd, hIMC );

    return retVal;
}
#endif

#ifdef DEBUG_MODE
/************************************************************************
*
*   StoreChar - Stores one character into text buffer and advances
*               cursor
*
************************************************************************/

VOID StoreChar( HWND hWnd, WORD ch, UCHAR atr )
{
    HDC hdc;

    if ( xPos >= CVMAX-3 )
        return;

    //
    // Store input character at current caret position
    //
    ConvertLine[xPos] = ch;
    ConvertLineAtr[xPos] = atr;
    xPos++ ;
    xPosLast = max(xPosLast,xPos) ;

    //
    // Repaint the entire line
    //
    hdc = GetDC( hWnd );
    HideCaret( hWnd );
    DisplayConvInformation( hWnd ) ;
    ResetCaret( hWnd );
    ReleaseDC( hWnd, hdc );

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\exts\genuedef.c ===
LIBRARY USEREXTS

;
; This file generates userexts.def or userkdx.def depending on the
; state of KERNEL.  This allows one file (exts.h) to
; be used to generate extension exports, entrypoints, and help text.
;
; To add an extension, add the appropriate entry to exts.h and matching
; code to userexts.c
;

EXPORTS
#define DOIT(name, helpstring1, helpstring2, validflags, argtype) name
#include "exts.h"

;--------------------------------------------------------------------
;
; these are the extension service functions provided for the debugger
;
;--------------------------------------------------------------------

    WinDbgExtensionDllInit
    ExtensionApiVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\exts\makefile.inc ===
HDEPENDENCIES=exts.h $(WINDOWS_INC_PATH)\stdexts.h

$(O)\conexts.def: genuedef.c $(HDEPENDENCIES)
        $(CXX_COMPILER_NAME) $(GENUEDEFDEFINES) /EP genuedef.c > $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\exts\precomp.h ===
#ifndef __CONEXTS__
#define __CONEXTS__

#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <windows.h>
#include <conroute.h>
#include <ntddvdeo.h>
#include "shellapi.h"
#include "shlobj.h"
#include "shlwapi.h"
#define NO_SHLWAPI_STRFCNS
#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_REG
#define NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_HTTP
#define NO_SHLWAPI_INTERNAL
#include "shlwapip.h"
#include "shlobjp.h"
#undef _DROPFILES
#undef DROPFILES
#undef LPDROPFILES
#include "conapi.h"
#include "conmsg.h"
#include "usersrv.h"
#include "server.h"
#include "winconp.h"
#include "cmdline.h"
#include "font.h"
#include "heap.h"
#include "consrv.h"
#include "directio.h"
#include "globals.h"
#include "menu.h"
#include "stream.h"
#include "winuserp.h"
#include "winbasep.h"
#ifdef FE_SB
#include "dbcs.h"
#include "dispatch.h"
#include "eudc.h"
#include "foncache.h"
#include "machine.h"
#ifdef FE_IME
#include "conv.h"
#include <immp.h>
#endif // FE_IME
#endif // FE_SB

#include <ntosp.h>
#include <w32p.h>
#include <ntverp.h>

#endif // __CONEXTS__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\exts\stdext64.h ===
/****************************** Module Header ******************************\
* Module Name: stdexts.h
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbghelp.h>


/*
 * Preceeding this header the following must have been defined:
 * PSTR pszExtName;
 *
 * This module includes "exts.h" which defines what exported functions are
 * supported by each extension and contains all help text and legal option
 * information.  At a minimum exts.h must have:

DOIT(   help
        ,"help -v [cmd]                 - Displays this list or gives details on command\n"
        ,"  help      - To dump short help text on all commands.\n"
         "  help -v   - To dump long help text on all commands.\n"
         "  help cmd  - To dump long help on given command.\n"
        ,"v"
        ,CUSTOM)

 */


extern HANDLE                  hCurrentProcess;
extern HANDLE                  hCurrentThread;
extern ULONG64                 dwCurrentPc;
extern WINDBG_EXTENSION_APIS  *lpExtensionApis;
extern DWORD                   dwProcessor;
extern WINDBG_EXTENSION_APIS   ExtensionApis;

#define Print           (lpExtensionApis->lpOutputRoutine)
#define OUTAHERE()      RtlRaiseStatus(STATUS_NONCONTINUABLE_EXCEPTION);
#define GetSym          (lpExtensionApis->lpGetSymbolRoutine)
#define ReadMem         (lpExtensionApis->lpReadProcessMemoryRoutine)
#define IsWinDbg()      (lpExtensionApis->nSize >= sizeof(WINDBG_EXTENSION_APIS))
#define SAFEWHILE(exp)  while (!IsCtrlCHit() && (exp))

extern PSTR pszAccessViolation;
extern PSTR pszMoveException;
extern PSTR pszReadFailure;

#define OPTS_ERROR 0xFFFFFFFF

#define OFLAG(l)        (1L << ((DWORD)#@l - (DWORD)'a'))
#define move(dst, src)  moveBlock(&(dst), src, sizeof(dst))
#define tryMove(dst, src)  tryMoveBlock(&(dst), src, sizeof(dst))
#define tryDword(pdst, src) tryMoveBlock(pdst, src, sizeof(DWORD))
//#define DEBUGPRINT      Print       // set this when debuging your extensions
#define DEBUGPRINT

VOID moveBlock(PVOID pdst, ULONG64 src, DWORD size);
BOOL tryMoveBlock(PVOID pdst, ULONG64 src, DWORD size);
VOID moveExp(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExp(PVOID pdst, LPSTR pszExp);
VOID moveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpValue(PVOID pdst, LPSTR pszExp);
BOOL tryMoveExpPtr(PULONG64 pdst, LPSTR pszExp);
VOID moveExpValuePtr(PULONG64 pdst, LPSTR pszExp);
BOOL IsCtrlCHit(VOID);

ULONG64 OptEvalExp(LPSTR psz);
ULONG64 OptEvalExp2(LPSTR *ppsz);
DWORD StringToOpts(LPSTR psz);
DWORD GetOpts(LPSTR *ppszArgs, LPSTR pszLegalArgs);
VOID PrintHuge(LPSTR psz);
ULONG64 EvalExp(LPSTR psz);

/*
 * entrypoint function type values
 */
#define NOARGS      0
#define STDARGS0    1
#define STDARGS1    2
#define STDARGS2    3
#define STDARGS3    4
#define STDARGS4    5
#define CUSTOM      9

/*
 * worker function prototype types
 */
typedef BOOL (* TYPE_NOARGS)(VOID);
typedef BOOL (* TYPE_STDARGS0)(DWORD);
typedef BOOL (* TYPE_STDARGS1)(DWORD, ULONG64);
typedef BOOL (* TYPE_STDARGS2)(DWORD, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS3)(DWORD, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_STDARGS4)(DWORD, ULONG64, ULONG64, ULONG64, ULONG64);
typedef BOOL (* TYPE_CUSTOM)(DWORD, LPSTR);

/*
 * worker function proto-prototypes
 */
#define PROTO_NOARGS(name, opts)   BOOL I##name(VOID)
#define PROTO_STDARGS0(name, opts) BOOL I##name(DWORD options)
#define PROTO_STDARGS1(name, opts) BOOL I##name(DWORD options, ULONG64 param1)
#define PROTO_STDARGS2(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2)
#define PROTO_STDARGS3(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3)
#define PROTO_STDARGS4(name, opts) BOOL I##name(DWORD options, ULONG64 param1, ULONG64 param2, ULONG64 param3, ULONG64 param4)
#define PROTO_CUSTOM(name, opts)   BOOL I##name(DWORD options, LPSTR pszArg)

/*
 * worker function prototypes (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type) PROTO_##type(name, opts);
#include "exts.h"
#undef DOIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\exts\stdext64.c ===
/****************************** Module Header ******************************\
* Module Name: stdexts.c
*
* Copyright (c) 1995-1998, Microsoft Corporation
*
* This module contains standard routines for creating sane debuging extensions.
* It is meant to be included after stdexts.h in one of the files comprising
* the debug extsnsions for a given product or module.
*
* History:
* 11-Apr-1995 Sanfords  Created
\***************************************************************************/

#include <stdext64.h>


HANDLE                  hCurrentProcess;
HANDLE                  hCurrentThread;
ULONG64                 dwCurrentPc;
WINDBG_EXTENSION_APIS  *lpExtensionApis;
DWORD                   dwProcessor;

PSTR pszAccessViolation = "%s: Access violation on \"%s\".\n";
PSTR pszMoveException   = "%s: exception in moveBlock()\n";
PSTR pszReadFailure     = "%s: lpReadProcessMemoryRoutine failed!\n";
PSTR pszCantContinue    = "%s: Non-continuable exception.\n";
BOOL fCtrlCHit = FALSE;


/*
 * This function returns TRUE once the user has hit a Ctrl-C.
 * This allows proper operation of nested SAFEWHILE loops so
 * that all levels exit.
 *
 * The globall fCtrlCHit flag needs to be reset manually and
 * is done so in the CommandEP function.
 */
BOOL IsCtrlCHit(
    VOID)
{
    if ((lpExtensionApis->lpCheckControlCRoutine)()) {
        fCtrlCHit = TRUE;
    }

    return fCtrlCHit;
}


VOID moveBlock(
    PVOID pdst,
    ULONG64 src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess,
                    (PVOID)src, pdst, size, NULL))) {
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        Print(pszMoveException, pszExtName);
        fSuccess = FALSE;
    }
    if (!fSuccess) {
        DEBUGPRINT("%s: moveBlock(%p, %p, %x) failed.\n",
                pszExtName, pdst, src, size);
        OUTAHERE();
    }
}


BOOL tryMoveBlock(
    PVOID pdst,
    ULONG64 src,
    DWORD size)
{
    BOOL fSuccess = TRUE;
    ULONG Result;

    try {
        if (IsWinDbg()) {
            if (!ReadMem(src, pdst, size, &Result)) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
             }
        } else {
            if (!NT_SUCCESS(NtReadVirtualMemory(hCurrentProcess, (PVOID)src, pdst, size, NULL))) {
                DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) failed.\n", pszExtName, pdst, src, size);
                fSuccess = FALSE;
            }
        }
    } except (EXCEPTION_EXECUTE_HANDLER) {
        DEBUGPRINT("%s: tryMoveBlock(%p, %p, %x) faulted.\n", pszExtName, pdst, src, size);
        fSuccess = FALSE;
    }

    return fSuccess;
}



VOID moveExp(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        fSuccess = FALSE;
    }

    if (!fSuccess) {
        Print("%s: moveExp failed on %s.\n", pszExtName, pszExp);
        OUTAHERE();
    }
}


BOOL tryMoveExp(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExp(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }

    return fSuccess;
}


VOID moveExpValue(
    PVOID pdst,
    LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMoveBlock(&dw, addr, sizeof(DWORD))) {
            *((PDWORD)pdst) = dw;
            return;
        }
    }
    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


BOOL tryMoveExpValue(
    PVOID pdst,
    LPSTR pszExp)
{
    DWORD dw;
    ULONG64 addr;

    if (tryMoveExp(&addr, pszExp)) {
        if (tryMove(dw, addr)) {
            *((PDWORD)pdst) = dw;
            return TRUE;
        }
    }
    DEBUGPRINT("%s: tryMoveExpValue failed on %s.\n", pszExtName, pszExp);
    return FALSE;
}


BOOL tryMoveExpPtr(
    PULONG64 pdst,
    LPSTR pszExp)
{
    BOOL fSuccess = TRUE;

    try {
        *pdst = EvalExp(pszExp);
    } except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszAccessViolation, pszExtName, pszExp);
        DEBUGPRINT("%s: tryMoveExpPtr(%p, %s) faulted.\n", pszExtName, pdst, pszExp);
        fSuccess = FALSE;
    }

    return fSuccess;
}


VOID moveExpValuePtr(
    PULONG64 pdst,
    LPSTR pszExp)
{
    ULONG64 dw;

    if (tryMoveExpPtr(&dw, pszExp)) {
        if (tryMoveBlock(&dw, dw, sizeof(dw))) {
            *pdst = dw;
            return;
        }
    }

    Print("%s: moveExpValue failed on %s.\n", pszExtName, pszExp);
    OUTAHERE();
}


ULONG64 EvalExp(
    LPSTR psz)
{
    ULONG64 p;

    p = (lpExtensionApis->lpGetExpressionRoutine)(psz);
    if (p == 0) {
        Print("%s: EvalExp failed to evaluate %s.\n", pszExtName, psz);
    }

    return p;
}



ULONG64 OptEvalExp(
    LPSTR psz)
{
    while (*psz == ' ') {
        psz++;
    }

    if (*psz == '\0') {
        return 0;
    }

    return EvalExp(psz);
}



ULONG64 OptEvalExp2(
    LPSTR *ppsz)
{
    LPSTR psz = *ppsz;
    ULONG64 dwRet = 0;

    while (*psz == ' ') {
        psz++;
    }

    if (*psz != '\0') {
        dwRet = EvalExp(psz);
        while (*psz != '\0' && *psz != ' ') {
            psz++;
        }
    }
    *ppsz = psz;

    return dwRet;
}


DWORD StringToOpts(
    LPSTR psz)
{
    DWORD opts = 0;

    while (*psz != '\0' && *psz != ' ') {
        if (*psz >= 'a' && *psz <= 'z') {
            opts |= 1 << (*psz - 'a');
        } else if (*psz >= 'A' && *psz <= 'Z') {
            opts |= 1 << (*psz - 'A');
        } else {
            return OPTS_ERROR;     // any non-letter option is an error.
        }
        psz++;
    }

    return opts;
}


/*
 * Function to convert an option string to a DWORD of flags.  pszLegalArgs
 * is used to allow option validation at the same time.
 *
 * *ppszArgs is set to point to after the options on exit.
 * On error, returns OPTS_ERROR.
 */
DWORD GetOpts(
    LPSTR *ppszArgs,
    LPSTR pszLegalArgs OPTIONAL)
{
    DWORD Opts = 0;
    LPSTR pszArgs = *ppszArgs;

    /*
     * Skip whitespace
     */
    while (*pszArgs == ' ') {
        pszArgs++;
    }
    /*
     * process '-' prepended options.
     */
    while (*pszArgs == '-') {
        pszArgs++;
        Opts = StringToOpts(pszArgs);
        /*
         * skip to whitespace or end.
         */
        while (*pszArgs != '\0' && *pszArgs != ' ') {
            pszArgs++;
        }
        /*
         * skip trailing whitespace.
         */
        while (*pszArgs == ' ') {
            pszArgs++;
        }
        *ppszArgs = pszArgs;

        /*
         * optionally validate against LegalArgs
         */
        if (pszLegalArgs != NULL && ((Opts & StringToOpts(pszLegalArgs)) != Opts)) {
            Opts = OPTS_ERROR;
            Print("Bad options.\n");
            return Opts;
        }
    }

    return Opts;
}


/*
 * Dispatcher function used by generated entrypoint functions.
 */
VOID CommonEP(
    PVOID pFunction,
    LPSTR pszName,
    int type,
    LPSTR pszLegalOpts,
    HANDLE hcp,
    HANDLE hct,
    ULONG64 dwcp,
    DWORD dwp,
    LPSTR lpas)
{
    BOOL dwOptions, fSuccess;
    ULONG64 param1, param2, param3;

    hCurrentProcess = hcp;
    hCurrentThread = hct;
    dwCurrentPc = dwcp;
    dwProcessor = dwp;
    lpExtensionApis = &ExtensionApis;

    fCtrlCHit = FALSE;  // reset this with each command. (SAFEWHILE fix)
    switch (type) {
    case NOARGS:
        fSuccess = ((TYPE_NOARGS)pFunction)();
        goto Exit;
    }

    dwOptions = GetOpts(&lpas, pszLegalOpts);
    if (dwOptions == OPTS_ERROR) {
        fSuccess = Ihelp(0, pszName);
        goto Exit;
    }

    try {
        switch (type) {
        case CUSTOM:
            fSuccess = ((TYPE_CUSTOM)pFunction)(dwOptions, lpas);
            break;

        case STDARGS0:
            fSuccess = ((TYPE_STDARGS0)pFunction)(dwOptions);
            break;

        case STDARGS1:
            fSuccess = ((TYPE_STDARGS1)pFunction)(dwOptions, OptEvalExp(lpas));
            break;

        case STDARGS2:
            param1 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS2)pFunction)(dwOptions, param1, OptEvalExp(lpas));
            break;

        case STDARGS3:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS3)pFunction)(dwOptions, param1, param2, OptEvalExp(lpas));
            break;

        case STDARGS4:
            param1 = OptEvalExp2(&lpas);
            param2 = OptEvalExp2(&lpas);
            param3 = OptEvalExp2(&lpas);
            fSuccess = ((TYPE_STDARGS4)pFunction)(dwOptions, param1, param2, param3, OptEvalExp(lpas));
            break;

        default:
            Print("CommonEP: Don't recognize function type %d.\n", type);
            break;
        }
    } except (GetExceptionCode() == STATUS_NONCONTINUABLE_EXCEPTION ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH) {
        Print(pszCantContinue, pszExtName);
    }

Exit:
    if (!fSuccess) {
        Print("%s failed.\n", pszName);
        Ihelp(0, pszName);
    }
}

/*
 * Entrypoint functions (generated from exts.h)
 */
#define DOIT(name, h1, h2, opts, type)                  \
VOID name##(                                            \
    HANDLE hcp,                                         \
    HANDLE hct,                                         \
    ULONG64 dwcp,                                       \
    DWORD dwp,                                          \
    LPSTR lpas)                                         \
{                                                       \
    CommonEP(I##name, #name, type, opts, hcp, hct, dwcp, dwp, lpas); \
}
#include "exts.h"
#undef DOIT


/*
 * Standard help extension - present in all standard extensions.
 */
BOOL Ihelp(
    DWORD opts,
    LPSTR lpas)
{
#define DOIT(name, help1, help2, opts, type)  { #name, help1, help2 },

    static struct {
        LPSTR pszCmdName;
        LPSTR pszHelp1;
        LPSTR pszHelp2;
    } he[] = {
#include "exts.h"
    };
#undef DOIT
    int i;

    while (*lpas == ' ') {
        lpas++;
    }

    if (*lpas == '\0') {
        Print("-------------- %s Debug Extension help:--------------\n\n", pszExtName);
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            Print(he[i].pszHelp1);
            if (opts & OFLAG(v)) {
                Print(he[i].pszHelp2);
            }
        }
        return TRUE;
    } else {
        for (i = 0; i < sizeof(he) / sizeof(he[0]); i++) {
            if (IsCtrlCHit()) {
                break;
            }
            if (strcmp(lpas, he[i].pszCmdName) == 0) {
                Print(he[i].pszHelp1);
                Print(he[i].pszHelp2);
                return TRUE;
            }
        }
        Print("%s is not supported.\n", lpas);
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\conmsg.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    conmsg.h

Abstract:

    This include file defines the message formats used to communicate
    between the client and server portions of the CONSOLE portion of the
    Windows subsystem.

Author:

    Therese Stowell (thereses) 10-Nov-1990

Revision History:

--*/

#ifndef _CONMSG_H_
#define _CONMSG_H_

#define CONSOLE_INPUT_HANDLE 1
#define CONSOLE_OUTPUT_HANDLE 2

// max lengths, in bytes!
#define MAX_TITLE_LENGTH ((MAX_PATH+1)*sizeof(WCHAR))
#define MAX_APP_NAME_LENGTH 256

#define INITIALIZATION_SUCCEEDED 0
#define INITIALIZATION_FAILED 1
#define NUMBER_OF_INITIALIZATION_EVENTS 2

#if defined(FE_SB) // for Kernel32 Single Binary
#include "winconp.h"  // need FONT_SELECT
#endif // FE_SB

typedef struct _CONSOLE_INFO {
    IN OUT HANDLE ConsoleHandle;
    OUT HANDLE InputWaitHandle;
    OUT HANDLE StdIn;
    OUT HANDLE StdOut;
    OUT HANDLE StdErr;
    OUT HANDLE InitEvents[NUMBER_OF_INITIALIZATION_EVENTS];
    IN UINT   iIconId;
    IN HICON  hIcon;
    IN HICON  hSmIcon;
    IN DWORD dwHotKey;
    IN DWORD dwStartupFlags;
    IN WORD  wFillAttribute OPTIONAL;
    IN WORD  wPopupFillAttribute OPTIONAL;
    IN WORD  wShowWindow OPTIONAL;
    IN WORD  wReserved OPTIONAL;
    IN COORD dwScreenBufferSize OPTIONAL;
    IN COORD dwWindowSize OPTIONAL;
    IN COORD dwWindowOrigin OPTIONAL;
    IN DWORD nFont OPTIONAL;
    IN DWORD nInputBufferSize OPTIONAL;
    IN COORD dwFontSize OPTIONAL;
    IN UINT  uFontFamily OPTIONAL;
    IN UINT  uFontWeight OPTIONAL;
    IN WCHAR FaceName[LF_FACESIZE];
    IN UINT  uCursorSize OPTIONAL;
    IN BOOL  bFullScreen OPTIONAL;
    IN BOOL  bQuickEdit  OPTIONAL;
    IN BOOL  bInsertMode OPTIONAL;
    IN BOOL  bAutoPosition OPTIONAL;
    IN UINT  uHistoryBufferSize OPTIONAL;
    IN UINT  uNumberOfHistoryBuffers OPTIONAL;
    IN BOOL  bHistoryNoDup OPTIONAL;
    IN COLORREF ColorTable[ 16 ] OPTIONAL;
#if defined(FE_SB) // for Kernel32 Single Binary
    IN UINT  uCodePage;
#endif // FE_SB
} CONSOLE_INFO, *PCONSOLE_INFO;


//
// This structure is filled in by the client prior to connecting to the CONSRV
// DLL in the Windows subsystem server.  The server DLL will fill in the OUT
// fields if prior to accepting the connection.
//

typedef struct _CONSOLE_API_CONNECTINFO {
    IN OUT CONSOLE_INFO ConsoleInfo;
    IN BOOLEAN ConsoleApp;
    IN BOOLEAN WindowVisible;
    IN LPTHREAD_START_ROUTINE CtrlRoutine;
    IN LPTHREAD_START_ROUTINE PropRoutine;
#if defined(FE_SB)
#if defined(FE_IME)
    IN LPTHREAD_START_ROUTINE ConsoleIMERoutine;
#endif // FE_IME
#endif // FE_SB
    IN DWORD TitleLength;
    IN WCHAR Title[MAX_TITLE_LENGTH/2];
    IN DWORD DesktopLength;
    IN LPWSTR Desktop;
    IN DWORD AppNameLength;
    IN WCHAR AppName[MAX_APP_NAME_LENGTH/2];
    IN DWORD CurDirLength;
    IN WCHAR CurDir[MAX_PATH+1];
} CONSOLE_API_CONNECTINFO, *PCONSOLE_API_CONNECTINFO;

//
// Message format for messages sent from the client to the server
//

typedef enum _CONSOLE_API_NUMBER {
    ConsolepOpenConsole = CONSRV_FIRST_API_NUMBER,
    ConsolepGetConsoleInput,
    ConsolepWriteConsoleInput,
    ConsolepReadConsoleOutput,
    ConsolepWriteConsoleOutput,
    ConsolepReadConsoleOutputString,
    ConsolepWriteConsoleOutputString,
    ConsolepFillConsoleOutput,
    ConsolepGetMode,
    ConsolepGetNumberOfFonts,
    ConsolepGetNumberOfInputEvents,
    ConsolepGetScreenBufferInfo,
    ConsolepGetCursorInfo,
    ConsolepGetMouseInfo,
    ConsolepGetFontInfo,
    ConsolepGetFontSize,
    ConsolepGetCurrentFont,
    ConsolepSetMode,
    ConsolepSetActiveScreenBuffer,
    ConsolepFlushInputBuffer,
    ConsolepGetLargestWindowSize,
    ConsolepSetScreenBufferSize,
    ConsolepSetCursorPosition,
    ConsolepSetCursorInfo,
    ConsolepSetWindowInfo,
    ConsolepScrollScreenBuffer,
    ConsolepSetTextAttribute,
    ConsolepSetFont,
    ConsolepSetIcon,
    ConsolepReadConsole,
    ConsolepWriteConsole,
    ConsolepDupHandle,
    ConsolepGetHandleInformation,
    ConsolepSetHandleInformation,
    ConsolepCloseHandle,
    ConsolepVerifyIoHandle,
    ConsolepAlloc,
    ConsolepFree,
    ConsolepGetTitle,
    ConsolepSetTitle,
    ConsolepCreateScreenBuffer,
    ConsolepInvalidateBitmapRect,
    ConsolepVDMOperation,
    ConsolepSetCursor,
    ConsolepShowCursor,
    ConsolepMenuControl,
    ConsolepSetPalette,
    ConsolepSetDisplayMode,
    ConsolepRegisterVDM,
    ConsolepGetHardwareState,
    ConsolepSetHardwareState,
    ConsolepGetDisplayMode,
    ConsolepAddAlias,
    ConsolepGetAlias,
    ConsolepGetAliasesLength,
    ConsolepGetAliasExesLength,
    ConsolepGetAliases,
    ConsolepGetAliasExes,
    ConsolepExpungeCommandHistory,
    ConsolepSetNumberOfCommands,
    ConsolepGetCommandHistoryLength,
    ConsolepGetCommandHistory,
    ConsolepSetCommandHistoryMode,
    ConsolepGetCP,
    ConsolepSetCP,
    ConsolepSetKeyShortcuts,
    ConsolepSetMenuClose,
    ConsolepNotifyLastClose,
    ConsolepGenerateCtrlEvent,
    ConsolepGetKeyboardLayoutName,
    ConsolepGetConsoleWindow,
#if defined(FE_SB) // for Kernel32 Single Binary
    ConsolepCharType,
    ConsolepSetLocalEUDC,
    ConsolepSetCursorMode,
    ConsolepGetCursorMode,
    ConsolepRegisterOS2,
    ConsolepSetOS2OemFormat,
#if defined(FE_IME)
    ConsolepGetNlsMode,
    ConsolepSetNlsMode,
    ConsolepRegisterConsoleIME,
    ConsolepUnregisterConsoleIME,
#endif // FE_IME
#endif // FE_SB
    ConsolepGetLangId,
    ConsolepAttach,
    ConsolepGetSelectionInfo,
    ConsolepGetConsoleProcessList,
    ConsolepMaxApiNumber
} CONSOLE_API_NUMBER, *PCONSOLE_API_NUMBER;

typedef struct _CONSOLE_CREATESCREENBUFFER_MSG {
    IN HANDLE ConsoleHandle;
    IN ULONG DesiredAccess;
    IN BOOL InheritHandle;
    IN ULONG ShareMode;
    IN DWORD Flags;
    IN OUT CONSOLE_GRAPHICS_BUFFER_INFO GraphicsBufferInfo;
    OUT HANDLE hMutex;
    OUT PVOID lpBitmap;
    OUT HANDLE Handle;
} CONSOLE_CREATESCREENBUFFER_MSG, *PCONSOLE_CREATESCREENBUFFER_MSG;

typedef struct _CONSOLE_OPENCONSOLE_MSG {
    IN HANDLE ConsoleHandle;
    IN ULONG HandleType;
    IN ULONG DesiredAccess;
    IN BOOL InheritHandle;
    IN ULONG ShareMode;
    OUT HANDLE Handle;
} CONSOLE_OPENCONSOLE_MSG, *PCONSOLE_OPENCONSOLE_MSG;

#define INPUT_RECORD_BUFFER_SIZE 5

typedef struct _CONSOLE_GETCONSOLEINPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
    OUT INPUT_RECORD Record[INPUT_RECORD_BUFFER_SIZE];
    OUT PINPUT_RECORD  BufPtr;
    IN OUT ULONG  NumRecords;   // this value is valid even for error cases
    IN USHORT Flags;
    BOOLEAN Unicode;
} CONSOLE_GETCONSOLEINPUT_MSG, *PCONSOLE_GETCONSOLEINPUT_MSG;

typedef struct _CONSOLE_WRITECONSOLEINPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
    IN INPUT_RECORD Record[INPUT_RECORD_BUFFER_SIZE];
    IN PINPUT_RECORD  BufPtr;
    IN OUT ULONG  NumRecords;  // this value is valid even for error cases
    BOOLEAN Unicode;
    BOOLEAN Append;
} CONSOLE_WRITECONSOLEINPUT_MSG, *PCONSOLE_WRITECONSOLEINPUT_MSG;

typedef struct _CONSOLE_READCONSOLEOUTPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT CHAR_INFO Char;
    OUT PCHAR_INFO BufPtr;
    IN OUT SMALL_RECT CharRegion; // this value is valid even for error cases
    BOOLEAN Unicode;
} CONSOLE_READCONSOLEOUTPUT_MSG, *PCONSOLE_READCONSOLEOUTPUT_MSG;

typedef struct _CONSOLE_WRITECONSOLEOUTPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN CHAR_INFO Char;
    IN PCHAR_INFO BufPtr;
    IN OUT SMALL_RECT CharRegion; // this value is valid even for error cases
    BOOLEAN Unicode;
    BOOLEAN ReadVM;
} CONSOLE_WRITECONSOLEOUTPUT_MSG, *PCONSOLE_WRITECONSOLEOUTPUT_MSG;

#define BUFFER_SIZE 80

/*
 * WriteOutputString and ReadInputString types
 */
#define CONSOLE_ASCII             0x1
#define CONSOLE_REAL_UNICODE      0x2
#define CONSOLE_ATTRIBUTE         0x3
#define CONSOLE_FALSE_UNICODE     0x4

typedef struct _CONSOLE_READCONSOLEOUTPUTSTRING_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD ReadCoord;
    IN DWORD  StringType;
    OUT WCHAR String[BUFFER_SIZE/2];
    OUT PWCHAR BufPtr;
    IN OUT ULONG NumRecords; // this value is valid even for error cases
} CONSOLE_READCONSOLEOUTPUTSTRING_MSG, *PCONSOLE_READCONSOLEOUTPUTSTRING_MSG;

typedef struct _CONSOLE_WRITECONSOLEOUTPUTSTRING_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD WriteCoord;
    IN DWORD  StringType;
    OUT WCHAR String[BUFFER_SIZE/2];
    IN PWCHAR BufPtr;
    IN OUT ULONG NumRecords; // this value is valid even for error cases
} CONSOLE_WRITECONSOLEOUTPUTSTRING_MSG, *PCONSOLE_WRITECONSOLEOUTPUTSTRING_MSG;

typedef struct _CONSOLE_FILLCONSOLEOUTPUT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD WriteCoord;
    IN DWORD  ElementType;
    IN WORD Element;
    IN OUT ULONG Length; // this value is valid even for error cases
} CONSOLE_FILLCONSOLEOUTPUT_MSG, *PCONSOLE_FILLCONSOLEOUTPUT_MSG;

typedef struct _CONSOLE_MODE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN DWORD Mode;
} CONSOLE_MODE_MSG, *PCONSOLE_MODE_MSG;

typedef struct _CONSOLE_GETNUMBEROFFONTS_MSG {
    IN HANDLE ConsoleHandle;
    OUT ULONG NumberOfFonts;
} CONSOLE_GETNUMBEROFFONTS_MSG, *PCONSOLE_GETNUMBEROFFONTS_MSG;

typedef struct _CONSOLE_GETNUMBEROFINPUTEVENTS_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
    OUT DWORD ReadyEvents;
} CONSOLE_GETNUMBEROFINPUTEVENTS_MSG, *PCONSOLE_GETNUMBEROFINPUTEVENTS_MSG;

typedef struct _CONSOLE_GETLARGESTWINDOWSIZE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT COORD  Size;
} CONSOLE_GETLARGESTWINDOWSIZE_MSG, *PCONSOLE_GETLARGESTWINDOWSIZE_MSG;

typedef struct _CONSOLE_GETSCREENBUFFERINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT COORD Size;
    OUT COORD CursorPosition;
    OUT COORD ScrollPosition;
    OUT WORD  Attributes;
    OUT COORD CurrentWindowSize;
    OUT COORD MaximumWindowSize;
} CONSOLE_GETSCREENBUFFERINFO_MSG, *PCONSOLE_GETSCREENBUFFERINFO_MSG;

typedef struct _CONSOLE_GETCURSORINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT DWORD CursorSize;
    OUT BOOLEAN Visible;
} CONSOLE_GETCURSORINFO_MSG, *PCONSOLE_GETCURSORINFO_MSG;

typedef struct _CONSOLE_GETSELECTIONINFO_MSG {
    IN HANDLE ConsoleHandle;
    OUT CONSOLE_SELECTION_INFO SelectionInfo;
} CONSOLE_GETSELECTIONINFO_MSG, *PCONSOLE_GETSELECTIONINFO_MSG;

typedef struct _CONSOLE_GETMOUSEINFO_MSG {
    IN HANDLE ConsoleHandle;
    OUT ULONG NumButtons;
} CONSOLE_GETMOUSEINFO_MSG, *PCONSOLE_GETMOUSEINFO_MSG;

typedef struct _CONSOLE_GETFONTINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN BOOLEAN MaximumWindow;
    OUT PCHAR BufPtr;
    IN OUT ULONG NumFonts;  // this value is valid even for error cases
} CONSOLE_GETFONTINFO_MSG, *PCONSOLE_GETFONTINFO_MSG;

typedef struct _CONSOLE_GETFONTSIZE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN DWORD  FontIndex;
    OUT COORD FontSize;
} CONSOLE_GETFONTSIZE_MSG, *PCONSOLE_GETFONTSIZE_MSG;

typedef struct _CONSOLE_GETCURRENTFONT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN BOOLEAN MaximumWindow;
    OUT DWORD FontIndex;
    OUT COORD FontSize;
} CONSOLE_GETCURRENTFONT_MSG, *PCONSOLE_GETCURRENTFONT_MSG;

typedef struct _CONSOLE_SETACTIVESCREENBUFFER_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
} CONSOLE_SETACTIVESCREENBUFFER_MSG, *PCONSOLE_SETACTIVESCREENBUFFER_MSG;

typedef struct _CONSOLE_FLUSHINPUTBUFFER_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
} CONSOLE_FLUSHINPUTBUFFER_MSG, *PCONSOLE_FLUSHINPUTBUFFER_MSG;

typedef struct _CONSOLE_SETSCREENBUFFERSIZE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD  Size;
} CONSOLE_SETSCREENBUFFERSIZE_MSG, *PCONSOLE_SETSCREENBUFFERSIZE_MSG;

typedef struct _CONSOLE_SETCURSORPOSITION_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD  CursorPosition;
} CONSOLE_SETCURSORPOSITION_MSG, *PCONSOLE_SETCURSORPOSITION_MSG;

typedef struct _CONSOLE_SETCURSORINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN DWORD  CursorSize;
    IN BOOLEAN Visible;
} CONSOLE_SETCURSORINFO_MSG, *PCONSOLE_SETCURSORINFO_MSG;

typedef struct _CONSOLE_SETWINDOWINFO_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN BOOL Absolute;
    IN SMALL_RECT Window;
} CONSOLE_SETWINDOWINFO_MSG, *PCONSOLE_SETWINDOWINFO_MSG;

typedef struct _CONSOLE_SCROLLSCREENBUFFER_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN SMALL_RECT ScrollRectangle;
    IN SMALL_RECT ClipRectangle;
    IN BOOL Clip;
    IN COORD  DestinationOrigin;
    IN CHAR_INFO Fill;
    IN BOOLEAN Unicode;
} CONSOLE_SCROLLSCREENBUFFER_MSG, *PCONSOLE_SCROLLSCREENBUFFER_MSG;

typedef struct _CONSOLE_SETTEXTATTRIBUTE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN WORD   Attributes;
} CONSOLE_SETTEXTATTRIBUTE_MSG, *PCONSOLE_SETTEXTATTRIBUTE_MSG;

typedef struct _CONSOLE_SETFONT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN DWORD  FontIndex;
} CONSOLE_SETFONT_MSG, *PCONSOLE_SETFONT_MSG;

typedef struct _CONSOLE_SETICON_MSG {
    IN HANDLE ConsoleHandle;
    IN HICON hIcon;
} CONSOLE_SETICON_MSG, *PCONSOLE_SETICON_MSG;

typedef struct _CONSOLE_READCONSOLE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE InputHandle;
    IN USHORT ExeNameLength;
    IN OUT WCHAR   Buffer[BUFFER_SIZE/2];
    OUT PVOID  BufPtr;
    IN OUT ULONG  NumBytes;    // this value is valid even for error cases
    IN ULONG CaptureBufferSize;
    IN ULONG InitialNumBytes;
    IN ULONG CtrlWakeupMask;
    OUT ULONG ControlKeyState;
    IN BOOLEAN Unicode;
} CONSOLE_READCONSOLE_MSG, *PCONSOLE_READCONSOLE_MSG;

typedef struct _CONSOLE_WRITECONSOLE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN WCHAR   Buffer[BUFFER_SIZE/2];
    IN PVOID  BufPtr;
    IN OUT ULONG  NumBytes;    // this value is valid even for error cases
    PWCHAR TransBuffer;         // used by server side only
    IN BOOLEAN BufferInMessage;
    IN BOOLEAN Unicode;
    BOOLEAN StackBuffer;        // used by server side only
    DWORD WriteFlags;           // used by server side only
} CONSOLE_WRITECONSOLE_MSG, *PCONSOLE_WRITECONSOLE_MSG;

typedef struct _CONSOLE_CLOSEHANDLE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
} CONSOLE_CLOSEHANDLE_MSG, *PCONSOLE_CLOSEHANDLE_MSG;

typedef struct _CONSOLE_DUPHANDLE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE SourceHandle;
    IN DWORD  DesiredAccess;
    IN BOOLEAN InheritHandle;
    IN DWORD Options;
    OUT HANDLE TargetHandle;
} CONSOLE_DUPHANDLE_MSG, *PCONSOLE_DUPHANDLE_MSG;

typedef struct _CONSOLE_GETHANDLEINFORMATION_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    OUT DWORD Flags;
} CONSOLE_GETHANDLEINFORMATION_MSG, *PCONSOLE_GETHANDLEINFORMATION_MSG;

typedef struct _CONSOLE_SETHANDLEINFORMATION_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN DWORD Mask;
    IN DWORD Flags;
} CONSOLE_SETHANDLEINFORMATION_MSG, *PCONSOLE_SETHANDLEINFORMATION_MSG;

typedef struct _CONSOLE_ADDALIAS_MSG {
    HANDLE ConsoleHandle;
    USHORT SourceLength;
    USHORT TargetLength;
    USHORT ExeLength;
    PVOID Source;
    PVOID Target;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_ADDALIAS_MSG, *PCONSOLE_ADDALIAS_MSG;

typedef struct _CONSOLE_GETALIAS_MSG {
    HANDLE ConsoleHandle;
    USHORT SourceLength;
    USHORT TargetLength;
    USHORT ExeLength;
    PVOID Source;
    PVOID Target;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_GETALIAS_MSG, *PCONSOLE_GETALIAS_MSG;

typedef struct _CONSOLE_GETALIASESLENGTH_MSG {
    HANDLE ConsoleHandle;
    USHORT ExeLength;
    PVOID Exe;
    DWORD AliasesLength;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_GETALIASESLENGTH_MSG, *PCONSOLE_GETALIASESLENGTH_MSG;

typedef struct _CONSOLE_GETALIASEXESLENGTH_MSG {
    HANDLE ConsoleHandle;
    DWORD AliasExesLength;
    BOOLEAN Unicode;
} CONSOLE_GETALIASEXESLENGTH_MSG, *PCONSOLE_GETALIASEXESLENGTH_MSG;

typedef struct _CONSOLE_GETALIASES_MSG {
    HANDLE ConsoleHandle;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
    DWORD AliasesBufferLength;
    PVOID AliasesBuffer;
} CONSOLE_GETALIASES_MSG, *PCONSOLE_GETALIASES_MSG;

typedef struct _CONSOLE_GETALIASEXES_MSG {
    HANDLE ConsoleHandle;
    DWORD AliasExesBufferLength;
    PVOID AliasExesBuffer;
    BOOLEAN Unicode;
} CONSOLE_GETALIASEXES_MSG, *PCONSOLE_GETALIASEXES_MSG;

typedef struct _CONSOLE_EXPUNGECOMMANDHISTORY_MSG {
    HANDLE ConsoleHandle;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_EXPUNGECOMMANDHISTORY_MSG, *PCONSOLE_EXPUNGECOMMANDHISTORY_MSG;

typedef struct _CONSOLE_SETNUMBEROFCOMMANDS_MSG {
    HANDLE ConsoleHandle;
    DWORD NumCommands;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_SETNUMBEROFCOMMANDS_MSG, *PCONSOLE_SETNUMBEROFCOMMANDS_MSG;

typedef struct _CONSOLE_GETCOMMANDHISTORYLENGTH_MSG {
    HANDLE ConsoleHandle;
    DWORD CommandHistoryLength;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_GETCOMMANDHISTORYLENGTH_MSG, *PCONSOLE_GETCOMMANDHISTORYLENGTH_MSG;

typedef struct _CONSOLE_GETCOMMANDHISTORY_MSG {
    HANDLE ConsoleHandle;
    DWORD CommandBufferLength;
    PVOID CommandBuffer;
    USHORT ExeLength;
    PVOID Exe;
    BOOLEAN Unicode;
    BOOLEAN UnicodeExe;
} CONSOLE_GETCOMMANDHISTORY_MSG, *PCONSOLE_GETCOMMANDHISTORY_MSG;

typedef struct _CONSOLE_SETCOMMANDHISTORYMODE_MSG {
    HANDLE ConsoleHandle;
    DWORD Flags;
} CONSOLE_SETCOMMANDHISTORYMODE_MSG, *PCONSOLE_SETCOMMANDHISTORYMODE_MSG;

typedef struct _CONSOLE_VERIFYIOHANDLE_MSG {
    BOOL Valid;
    HANDLE ConsoleHandle;
    HANDLE Handle;
} CONSOLE_VERIFYIOHANDLE_MSG, *PCONSOLE_VERIFYIOHANDLE_MSG;

typedef struct _CONSOLE_ALLOC_MSG {
    IN PCONSOLE_INFO ConsoleInfo;
    IN DWORD TitleLength;
    IN LPWSTR Title;
    IN DWORD DesktopLength;
    IN LPWSTR Desktop;
    IN DWORD AppNameLength;
    IN LPWSTR AppName;
    IN DWORD CurDirLength;
    IN LPWSTR CurDir;
    IN LPTHREAD_START_ROUTINE CtrlRoutine;
    IN LPTHREAD_START_ROUTINE PropRoutine;
} CONSOLE_ALLOC_MSG, *PCONSOLE_ALLOC_MSG;

typedef struct _CONSOLE_FREE_MSG {
    IN HANDLE ConsoleHandle;
} CONSOLE_FREE_MSG, *PCONSOLE_FREE_MSG;

typedef struct _CONSOLE_ATTACH_MSG {
    IN DWORD ProcessId;
    IN PCONSOLE_INFO ConsoleInfo;
    IN LPTHREAD_START_ROUTINE CtrlRoutine;
    IN LPTHREAD_START_ROUTINE PropRoutine;
} CONSOLE_ATTACH_MSG, *PCONSOLE_ATTACH_MSG;

typedef struct _CONSOLE_GETTITLE_MSG {
    IN HANDLE ConsoleHandle;
    IN OUT DWORD TitleLength;
    OUT PVOID Title;
    BOOLEAN Unicode;
} CONSOLE_GETTITLE_MSG, *PCONSOLE_GETTITLE_MSG;

typedef struct _CONSOLE_SETTITLE_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD TitleLength;
    IN PVOID Title;
    BOOLEAN Unicode;
} CONSOLE_SETTITLE_MSG, *PCONSOLE_SETTITLE_MSG;

typedef struct _CONSOLE_INVALIDATERECT_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    SMALL_RECT Rect;
} CONSOLE_INVALIDATERECT_MSG, *PCONSOLE_INVALIDATERECT_MSG;

typedef struct _CONSOLE_VDM_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD  iFunction;
    OUT BOOL Bool;
    IN OUT POINT Point;
    OUT RECT Rect;
#if defined(FE_SB) && defined(i386) // for Kernel32 Single Binary
    IN OUT VDM_IOCTL_PARAM VDMIoctlParam;
#endif // FE_SB
} CONSOLE_VDM_MSG, *PCONSOLE_VDM_MSG;

typedef struct _CONSOLE_SETCURSOR_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN HCURSOR CursorHandle;
} CONSOLE_SETCURSOR_MSG, *PCONSOLE_SETCURSOR_MSG;

typedef struct _CONSOLE_SHOWCURSOR_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN BOOL bShow;
    OUT int DisplayCount;
} CONSOLE_SHOWCURSOR_MSG, *PCONSOLE_SHOWCURSOR_MSG;

typedef struct _CONSOLE_MENUCONTROL_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN UINT CommandIdLow;
    IN UINT CommandIdHigh;
    OUT HMENU hMenu;
} CONSOLE_MENUCONTROL_MSG, *PCONSOLE_MENUCONTROL_MSG;

typedef struct _CONSOLE_SETPALETTE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN HPALETTE hPalette;
    IN UINT dwUsage;
} CONSOLE_SETPALETTE_MSG, *PCONSOLE_SETPALETTE_MSG;

typedef struct _CONSOLE_SETDISPLAYMODE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN DWORD dwFlags;
    OUT COORD ScreenBufferDimensions;
    IN HANDLE hEvent;
} CONSOLE_SETDISPLAYMODE_MSG, *PCONSOLE_SETDISPLAYMODE_MSG;

typedef struct _CONSOLE_REGISTERVDM_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD RegisterFlags;
    IN HANDLE StartEvent;
    IN HANDLE EndEvent;
    IN HANDLE ErrorEvent;
    IN DWORD Reserved;
    OUT ULONG StateLength;
    OUT PVOID StateBuffer;
    IN LPWSTR VDMBufferSectionName;
    IN DWORD VDMBufferSectionNameLength;
    IN COORD VDMBufferSize;
    OUT PVOID VDMBuffer;
} CONSOLE_REGISTERVDM_MSG, *PCONSOLE_REGISTERVDM_MSG;

typedef struct _CONSOLE_GETHARDWARESTATE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    OUT COORD Resolution;
    OUT COORD FontSize;
} CONSOLE_GETHARDWARESTATE_MSG, *PCONSOLE_GETHARDWARESTATE_MSG;

typedef struct _CONSOLE_SETHARDWARESTATE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE OutputHandle;
    IN COORD Resolution;
    IN COORD FontSize;
} CONSOLE_SETHARDWARESTATE_MSG, *PCONSOLE_SETHARDWARESTATE_MSG;

typedef struct _CONSOLE_GETDISPLAYMODE_MSG {
    IN HANDLE ConsoleHandle;
    OUT ULONG ModeFlags;
} CONSOLE_GETDISPLAYMODE_MSG, *PCONSOLE_GETDISPLAYMODE_MSG;

typedef struct _CONSOLE_GETCP_MSG {
    IN HANDLE ConsoleHandle;
    UINT wCodePageID;
    BOOL Output;
} CONSOLE_GETCP_MSG, *PCONSOLE_GETCP_MSG;

typedef struct _CONSOLE_SETCP_MSG {
    IN HANDLE ConsoleHandle;
    UINT wCodePageID;
    BOOL Output;
#if defined(FE_SB) // for Kernel32 Single Binary
    HANDLE hEvent;
#endif // FE_SB
} CONSOLE_SETCP_MSG, *PCONSOLE_SETCP_MSG;

typedef struct _CONSOLE_GETKEYBOARDLAYOUTNAME_MSG {
    IN HANDLE ConsoleHandle;
    union {
        WCHAR awchLayout[9];
        char achLayout[9];
    };
    BOOL bAnsi;
} CONSOLE_GETKEYBOARDLAYOUTNAME_MSG, *PCONSOLE_GETKEYBOARDLAYOUTNAME_MSG;

typedef struct _CONSOLE_SETKEYSHORTCUTS_MSG {
    IN HANDLE ConsoleHandle;
    BOOL Set;
    BYTE ReserveKeys;
    DWORD NumAppKeys;
    LPAPPKEY AppKeys;
} CONSOLE_SETKEYSHORTCUTS_MSG, *PCONSOLE_SETKEYSHORTCUTS_MSG;

typedef struct _CONSOLE_SETMENUCLOSE_MSG {
    IN HANDLE ConsoleHandle;
    BOOL Enable;
} CONSOLE_SETMENUCLOSE_MSG, *PCONSOLE_SETMENUCLOSE_MSG;

typedef struct _CONSOLE_NOTIFYLASTCLOSE_MSG {
    IN HANDLE ConsoleHandle;
} CONSOLE_NOTIFYLASTCLOSE_MSG, *PCONSOLE_NOTIFYLASTCLOSE_MSG;

typedef struct _CONSOLE_CTRLEVENT_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD CtrlEvent;
    IN DWORD ProcessGroupId;
} CONSOLE_CTRLEVENT_MSG, *PCONSOLE_CTRLEVENT_MSG;

#if defined(FE_SB) // for Kernel32 Single Binary
typedef struct _CONSOLE_CHAR_TYPE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN COORD coordCheck;
    OUT DWORD dwType;
} CONSOLE_CHAR_TYPE_MSG, *PCONSOLE_CHAR_TYPE_MSG;

typedef struct _CONSOLE_LOCAL_EUDC_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN WORD CodePoint;
    IN COORD FontSize;
    IN PCHAR FontFace;
} CONSOLE_LOCAL_EUDC_MSG, *PCONSOLE_LOCAL_EUDC_MSG;

typedef struct _CONSOLE_CURSOR_MODE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN BOOL Blink;
    IN BOOL DBEnable;
} CONSOLE_CURSOR_MODE_MSG, *PCONSOLE_CURSOR_MODE_MSG;

typedef struct _CONSOLE_REGISTEROS2_MSG {
    IN HANDLE ConsoleHandle;
    IN BOOL fOs2Register;
} CONSOLE_REGISTEROS2_MSG, *PCONSOLE_REGISTEROS2_MSG;

typedef struct _CONSOLE_SETOS2OEMFORMAT_MSG {
    IN HANDLE ConsoleHandle;
    IN BOOL fOs2OemFormat;
} CONSOLE_SETOS2OEMFORMAT_MSG, *PCONSOLE_SETOS2OEMFORMAT_MSG;

#if defined(FE_IME)
typedef struct _CONSOLE_NLS_MODE_MSG {
    IN HANDLE ConsoleHandle;
    IN HANDLE Handle;
    IN OUT BOOL Ready;
    IN DWORD NlsMode;
    IN HANDLE hEvent;
} CONSOLE_NLS_MODE_MSG, *PCONSOLE_NLS_MODE_MSG;

typedef struct _CONSOLE_REGISTER_CONSOLEIME_MSG {
    IN HANDLE ConsoleHandle;
    IN HWND hWndConsoleIME;
    IN DWORD dwConsoleIMEThreadId;
    IN DWORD DesktopLength;
    IN LPWSTR Desktop;
    OUT DWORD dwConsoleThreadId;
} CONSOLE_REGISTER_CONSOLEIME_MSG, *PCONSOLE_REGISTER_CONSOLEIME_MSG;

typedef struct _CONSOLE_UNREGISTER_CONSOLEIME_MSG {
    IN HANDLE ConsoleHandle;
    IN DWORD dwConsoleIMEThreadId;
} CONSOLE_UNREGISTER_CONSOLEIME_MSG, *PCONSOLE_UNREGISTER_CONSOLEIME_MSG;
#endif // FE_IME

#endif // FE_SB

typedef struct _CONSOLE_GETCONSOLEWINDOW_MSG {
    IN HANDLE ConsoleHandle;
    OUT HWND hwnd;
} CONSOLE_GETCONSOLEWINDOW_MSG, *PCONSOLE_GETCONSOLEWINDOW_MSG;

typedef struct _CONSOLE_LANGID_MSG {
    IN HANDLE ConsoleHandle;
    OUT LANGID LangId;
} CONSOLE_LANGID_MSG, *PCONSOLE_LANGID_MSG;

typedef struct _CONSOLE_GETPROCESSLIST_MSG {
    IN HANDLE ConsoleHandle;
    IN OUT DWORD dwProcessCount;
    OUT LPDWORD lpdwProcessList;
} CONSOLE_GETCONSOLEPROCESSLIST_MSG, *PCONSOLE_GETCONSOLEPROCESSLIST_MSG;

typedef struct _CONSOLE_API_MSG {
    PORT_MESSAGE h;
    PCSR_CAPTURE_HEADER CaptureBuffer;
    CSR_API_NUMBER ApiNumber;
    ULONG ReturnValue;
    ULONG Reserved;
    union {
        CONSOLE_OPENCONSOLE_MSG OpenConsole;
        CONSOLE_GETCONSOLEINPUT_MSG GetConsoleInput;
        CONSOLE_WRITECONSOLEINPUT_MSG WriteConsoleInput;
        CONSOLE_READCONSOLEOUTPUT_MSG ReadConsoleOutput;
        CONSOLE_WRITECONSOLEOUTPUT_MSG WriteConsoleOutput;
        CONSOLE_READCONSOLEOUTPUTSTRING_MSG ReadConsoleOutputString;
        CONSOLE_WRITECONSOLEOUTPUTSTRING_MSG WriteConsoleOutputString;
        CONSOLE_FILLCONSOLEOUTPUT_MSG FillConsoleOutput;
        CONSOLE_MODE_MSG GetConsoleMode;
        CONSOLE_GETNUMBEROFFONTS_MSG GetNumberOfConsoleFonts;
        CONSOLE_GETNUMBEROFINPUTEVENTS_MSG GetNumberOfConsoleInputEvents;
        CONSOLE_GETSCREENBUFFERINFO_MSG GetConsoleScreenBufferInfo;
        CONSOLE_GETCURSORINFO_MSG GetConsoleCursorInfo;
        CONSOLE_GETMOUSEINFO_MSG GetConsoleMouseInfo;
        CONSOLE_GETFONTINFO_MSG GetConsoleFontInfo;
        CONSOLE_GETFONTSIZE_MSG GetConsoleFontSize;
        CONSOLE_GETCURRENTFONT_MSG GetCurrentConsoleFont;
        CONSOLE_MODE_MSG SetConsoleMode;
        CONSOLE_SETACTIVESCREENBUFFER_MSG SetConsoleActiveScreenBuffer;
        CONSOLE_FLUSHINPUTBUFFER_MSG FlushConsoleInputBuffer;
        CONSOLE_GETLARGESTWINDOWSIZE_MSG GetLargestConsoleWindowSize;
        CONSOLE_SETSCREENBUFFERSIZE_MSG SetConsoleScreenBufferSize;
        CONSOLE_SETCURSORPOSITION_MSG SetConsoleCursorPosition;
        CONSOLE_SETCURSORINFO_MSG SetConsoleCursorInfo;
        CONSOLE_SETWINDOWINFO_MSG SetConsoleWindowInfo;
        CONSOLE_SCROLLSCREENBUFFER_MSG ScrollConsoleScreenBuffer;
        CONSOLE_SETTEXTATTRIBUTE_MSG SetConsoleTextAttribute;
        CONSOLE_SETFONT_MSG SetConsoleFont;
        CONSOLE_SETICON_MSG SetConsoleIcon;
        CONSOLE_READCONSOLE_MSG ReadConsole;
        CONSOLE_WRITECONSOLE_MSG WriteConsole;
        CONSOLE_DUPHANDLE_MSG DuplicateHandle;
        CONSOLE_GETHANDLEINFORMATION_MSG GetHandleInformation;
        CONSOLE_SETHANDLEINFORMATION_MSG SetHandleInformation;
        CONSOLE_CLOSEHANDLE_MSG CloseHandle;
        CONSOLE_VERIFYIOHANDLE_MSG VerifyConsoleIoHandle;
        CONSOLE_ALLOC_MSG AllocConsole;
        CONSOLE_FREE_MSG FreeConsole;
        CONSOLE_GETTITLE_MSG GetConsoleTitle;
        CONSOLE_SETTITLE_MSG SetConsoleTitle;
        CONSOLE_CREATESCREENBUFFER_MSG CreateConsoleScreenBuffer;
        CONSOLE_INVALIDATERECT_MSG InvalidateConsoleBitmapRect;
        CONSOLE_VDM_MSG VDMConsoleOperation;
        CONSOLE_SETCURSOR_MSG SetConsoleCursor;
        CONSOLE_SHOWCURSOR_MSG ShowConsoleCursor;
        CONSOLE_MENUCONTROL_MSG ConsoleMenuControl;
        CONSOLE_SETPALETTE_MSG SetConsolePalette;
        CONSOLE_SETDISPLAYMODE_MSG SetConsoleDisplayMode;
        CONSOLE_REGISTERVDM_MSG RegisterConsoleVDM;
        CONSOLE_GETHARDWARESTATE_MSG GetConsoleHardwareState;
        CONSOLE_SETHARDWARESTATE_MSG SetConsoleHardwareState;
        CONSOLE_GETDISPLAYMODE_MSG GetConsoleDisplayMode;
        CONSOLE_ADDALIAS_MSG AddConsoleAliasW;
        CONSOLE_GETALIAS_MSG GetConsoleAliasW;
        CONSOLE_GETALIASESLENGTH_MSG GetConsoleAliasesLengthW;
        CONSOLE_GETALIASEXESLENGTH_MSG GetConsoleAliasExesLengthW;
        CONSOLE_GETALIASES_MSG GetConsoleAliasesW;
        CONSOLE_GETALIASEXES_MSG GetConsoleAliasExesW;
        CONSOLE_EXPUNGECOMMANDHISTORY_MSG ExpungeConsoleCommandHistoryW;
        CONSOLE_SETNUMBEROFCOMMANDS_MSG SetConsoleNumberOfCommandsW;
        CONSOLE_GETCOMMANDHISTORYLENGTH_MSG GetConsoleCommandHistoryLengthW;
        CONSOLE_GETCOMMANDHISTORY_MSG GetConsoleCommandHistoryW;
        CONSOLE_SETCOMMANDHISTORYMODE_MSG SetConsoleCommandHistoryMode;
        CONSOLE_GETCP_MSG GetConsoleCP;
        CONSOLE_SETCP_MSG SetConsoleCP;
        CONSOLE_SETKEYSHORTCUTS_MSG SetConsoleKeyShortcuts;
        CONSOLE_SETMENUCLOSE_MSG SetConsoleMenuClose;
        CONSOLE_NOTIFYLASTCLOSE_MSG SetLastConsoleEventActive;
        CONSOLE_CTRLEVENT_MSG GenerateConsoleCtrlEvent;
        CONSOLE_GETKEYBOARDLAYOUTNAME_MSG GetKeyboardLayoutName;
        CONSOLE_GETCONSOLEWINDOW_MSG GetConsoleWindow;
#if defined(FE_SB) // for Kernel32 Single Binary
        CONSOLE_CHAR_TYPE_MSG GetConsoleCharType;
        CONSOLE_LOCAL_EUDC_MSG SetConsoleLocalEUDC;
        CONSOLE_CURSOR_MODE_MSG SetConsoleCursorMode;
        CONSOLE_CURSOR_MODE_MSG GetConsoleCursorMode;
        CONSOLE_REGISTEROS2_MSG RegisterConsoleOS2;
        CONSOLE_SETOS2OEMFORMAT_MSG SetConsoleOS2OemFormat;
#if defined(FE_IME)
        CONSOLE_NLS_MODE_MSG GetConsoleNlsMode;
        CONSOLE_NLS_MODE_MSG SetConsoleNlsMode;
        CONSOLE_REGISTER_CONSOLEIME_MSG RegisterConsoleIME;
        CONSOLE_UNREGISTER_CONSOLEIME_MSG UnregisterConsoleIME;
#endif // FE_IME
#endif // FE_SB
        CONSOLE_LANGID_MSG GetConsoleLangId;
        CONSOLE_ATTACH_MSG AttachConsole;
        CONSOLE_GETSELECTIONINFO_MSG GetConsoleSelectionInfo;
        CONSOLE_GETCONSOLEPROCESSLIST_MSG GetConsoleProcessList;
    } u;
} CONSOLE_API_MSG, *PCONSOLE_API_MSG;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\convarea.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    convarea.h

Abstract:

    This module contains the internal structures and definitions used
    by the conversion area.

Author:

    KazuM Mar.8,1993

Revision History:

--*/

#ifndef _CONVAREA_H_
#define _CONVAREA_H_

#if defined(FE_IME)
typedef struct _CONVERSION_AREA_BUFFER_INFO {
    COORD      coordCaBuffer;
    SMALL_RECT rcViewCaWindow;
    COORD      coordConView;
} CONVERSION_AREA_BUFFER_INFO,*PCONVERSION_AREA_BUFFER_INFO;



typedef struct _CONVERSIONAREA_INFORMATION {
    DWORD  ConversionAreaMode;
        #define CA_HIDDEN      0x01        // Set:Hidden    Reset:Active
        #define CA_STATUS_LINE 0x04
        #define CA_HIDE_FOR_SCROLL              0x10

    CONVERSION_AREA_BUFFER_INFO CaInfo;
    struct _SCREEN_INFORMATION *ScreenBuffer;

    struct _CONVERSIONAREA_INFORMATION *ConvAreaNext;
} CONVERSIONAREA_INFORMATION, *PCONVERSIONAREA_INFORMATION;



typedef struct _CONSOLE_IME_INFORMATION {
    DWORD ScrollFlag;
        #define HIDE_FOR_SCROLL               0x01
    LONG ScrollWaitTimeout;
        #define SCROLL_WAIT_TIMER         2
    LONG ScrollWaitCountDown;

    //
    // Composition String information
    //
    LPCONIME_UICOMPMESSAGE CompStrData;
    BOOLEAN SavedCursorVisible;  // whether cursor is visible (set by user)

    //
    // IME status/mode information
    //
    PCONVERSIONAREA_INFORMATION ConvAreaMode;
    PCONVERSIONAREA_INFORMATION ConvAreaSystem;
    DWORD  ConvAreaModePosition;
        // VIEW_LEFT  0
        // VIEW_RIGHT 1


    //
    // IME compositon string information
    //
    ULONG NumberOfConvAreaCompStr;
    PCONVERSIONAREA_INFORMATION *ConvAreaCompStr;

    //
    // Root of conversion area information
    //
    PCONVERSIONAREA_INFORMATION ConvAreaRoot;

} CONSOLE_IME_INFORMATION, *PCONSOLE_IME_INFORMATION;

#endif // FE_IME

#endif  // _CONVAREA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\conime.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    conime.h

Abstract:

    This module contains the internal structures and definitions used
    by the console IME.

Author:

    v-HirShi Jul.4.1995

Revision History:

--*/


#define CONSOLEIME_EVENT  (L"ConsoleIME_StartUp_Event")

typedef struct _CONIME_CANDMESSAGE {
    DWORD AttrOff;
    WCHAR String[];
} CONIME_CANDMESSAGE, *LPCONIME_CANDMESSAGE;

typedef struct _CONIME_UIMESSAGE {
    WCHAR String[];
} CONIME_UIMESSAGE, *LPCONIME_UIMESSAGE;

typedef struct _CONIME_UICOMPMESSAGE {
    DWORD dwSize;
    DWORD dwCompAttrLen;
    DWORD dwCompAttrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwResultStrLen;
    DWORD dwResultStrOffset;
    WORD  CompAttrColor[8];
} CONIME_UICOMPMESSAGE, *LPCONIME_UICOMPMESSAGE;

#define VIEW_LEFT  0
#define VIEW_RIGHT 1
#define MAXSTATUSCOL 160
typedef struct _CONIME_UIMODEINFO {
    DWORD ModeStringLen;
    BOOL Position;
    CHAR_INFO ModeString[MAXSTATUSCOL];
} CONIME_UIMODEINFO, *LPCONIME_UIMODEINFO;


//
// This is PCOPYDATASTRUCT->dwData values for WM_COPYDAT message consrv from conime.
//
#define CI_CONIMECOMPOSITION    0x4B425930
#define CI_CONIMEMODEINFO       0x4B425931
#define CI_CONIMESYSINFO        0x4B425932
#define CI_CONIMECANDINFO       0x4B425935
#define CI_CONIMEPROPERTYINFO   0x4B425936



//
// This message values for send/post message conime from consrv
//
#define CONIME_CREATE                   (WM_USER+0)
#define CONIME_DESTROY                  (WM_USER+1)
#define CONIME_SETFOCUS                 (WM_USER+2)
#define CONIME_KILLFOCUS                (WM_USER+3)
#define CONIME_HOTKEY                   (WM_USER+4)
#define CONIME_GET_NLSMODE              (WM_USER+5)
#define CONIME_SET_NLSMODE              (WM_USER+6)
#define CONIME_NOTIFY_SCREENBUFFERSIZE  (WM_USER+7)
#define CONIME_NOTIFY_VK_KANA           (WM_USER+8)
#define CONIME_INPUTLANGCHANGE          (WM_USER+9)
#define CONIME_NOTIFY_CODEPAGE          (WM_USER+10)
#define CONIME_INPUTLANGCHANGEREQUEST   (WM_USER+11)
#define CONIME_INPUTLANGCHANGEREQUESTFORWARD   (WM_USER+12)
#define CONIME_INPUTLANGCHANGEREQUESTBACKWARD   (WM_USER+13)
#define CONIME_KEYDATA                  (WM_USER+1024)

//
// This message values for set direction of conime langchange
//
#define CONIME_DIRECT                    0
#define CONIME_FORWARD                   1
#define CONIME_BACKWARD                 -1

//
// This message value is for send/post message to consrv
//
#define CM_CONIME_KL_ACTIVATE           (WM_USER+15)

#define CONIME_SENDMSG_TIMEOUT          (3 * 1000)    // Wait for 3sec.




//
// Default composition color attributes
//
#define DEFAULT_COMP_ENTERED            \
    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED |                        \
     COMMON_LVB_UNDERSCORE)
#define DEFAULT_COMP_ALREADY_CONVERTED  \
    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED |                        \
     BACKGROUND_BLUE )
#define DEFAULT_COMP_CONVERSION         \
    (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED |                        \
     COMMON_LVB_UNDERSCORE)
#define DEFAULT_COMP_YET_CONVERTED      \
    (FOREGROUND_BLUE |                                                            \
     BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED |                        \
     COMMON_LVB_UNDERSCORE)
#define DEFAULT_COMP_INPUT_ERROR        \
    (                                     FOREGROUND_RED |                        \
     COMMON_LVB_UNDERSCORE)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\eudc.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    eudc.h

Abstract:

Author:

    KazuM Apr.19.1996

Revision History:

--*/

typedef struct _EUDC_INFORMATION {
    BOOL LocalVDMEudcMode;
    BOOL LocalKeisenEudcMode;

    HDC hDCLocalEudc;                   // Double colored DBCS hDC
    HBITMAP hBmpLocalEudc;

    PVOID EudcFontCacheInformation;     // Same as PFONT_CACHE_INFORMATION

    COORD LocalEudcSize;

    INT EudcRangeSize;
        #define EUDC_RANGE_SIZE 16
    WCHAR EudcRange[EUDC_RANGE_SIZE];
} EUDC_INFORMATION, *PEUDC_INFORMATION;


NTSTATUS
CreateEUDC(
    PCONSOLE_INFORMATION Console
    );

VOID
DeleteEUDC(
    PCONSOLE_INFORMATION Console
    );

NTSTATUS
RegisterLocalEUDC(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN PCHAR FontFace
    );

VOID
FreeLocalEUDC(
    IN PCONSOLE_INFORMATION Console
    );

VOID
GetFitLocalEUDCFont(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR wChar
    );

BOOL
IsEudcRange(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR ch
    );

BOOL
CheckEudcRangeInString(
    IN PCONSOLE_INFORMATION Console,
    IN  PWCHAR string,
    IN  SHORT  len,
    OUT SHORT  *find_pos
    );

INT
GetSystemEUDCRangeW(
    WORD  *pwEUDCCharTable,
    UINT   cjSize
    );

WORD
ConvertStringToHex(
    LPWSTR lpch,
    LPWSTR *endptr
    );

WORD
ConvertStringToDec(
    LPWSTR lpch,
    LPWSTR *endptr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\font.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    font.h

Abstract:

    This module contains the data structures, data types,
    and procedures related to fonts.

Author:

    Therese Stowell (thereses) 15-Jan-1991

Revision History:

--*/

#define INITIAL_FONTS 20
#define FONT_INCREMENT 3

/*
 * FONT_INFO
 *
 * The distinction between the desired and actual font dimensions obtained
 * is important in the case of TrueType fonts, in which there is no guarantee
 * that what you ask for is what you will get.
 *
 * Note that the correspondence between "Desired" and "Actual" is broken
 * whenever the user changes his display driver, because GDI uses driver
 * parameters to control the font rasterization.
 *
 * The SizeDesired is {0, 0} if the font is a raster font.
 */
typedef struct _FONT_INFO {
    HFONT hFont;
    COORD Size;      // font size obtained
    COORD SizeWant;  // 0;0 if Raster font
    LONG  Weight;
    LPWSTR FaceName;
    BYTE  Family;
#if defined(FE_SB)
    BYTE tmCharSet;
#endif
} FONT_INFO, *PFONT_INFO;

#define TM_IS_TT_FONT(x)     (((x) & TMPF_TRUETYPE) == TMPF_TRUETYPE)
#define IS_BOLD(w)           ((w) >= FW_SEMIBOLD)
#define SIZE_EQUAL(s1, s2)   (((s1).X == (s2).X) && ((s1).Y == (s2).Y))
#define POINTS_PER_INCH 72
#define MIN_PIXEL_HEIGHT 5
#define MAX_PIXEL_HEIGHT 72
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\input.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    input.h

Abstract:

    This module contains the internal structures and definitions used
    by the input (keyboard and mouse) component of the NT console subsystem.

Author:

    Therese Stowell (thereses) 12-Nov-1990

Revision History:

--*/

#define DEFAULT_NUMBER_OF_EVENTS 50
#define INPUT_BUFFER_SIZE_INCREMENT 10

typedef struct _INPUT_INFORMATION {
    PINPUT_RECORD InputBuffer;
    DWORD InputBufferSize;      // size in events
    CONSOLE_SHARE_ACCESS ShareAccess;   // share mode
    DWORD AllocatedBufferSize;  // size in bytes of entire buffer
    DWORD InputMode;
    ULONG RefCount;             // number of handles to input buffer
    ULONG_PTR First;             // ptr to base of circular buffer
    ULONG_PTR In;                // ptr to next free event
    ULONG_PTR Out;               // ptr to next available event
    ULONG_PTR Last;              // ptr to end+1 of buffer
    LIST_ENTRY ReadWaitQueue;
    HANDLE InputWaitEvent;
#if defined(FE_SB)
#if defined(FE_IME)
    struct {
        DWORD Disable     : 1;  // High   : specifies input code page or enable/disable in NLS state
        DWORD Unavailable : 1;  // Middle : specifies console window doing menu loop or size move
        DWORD Open        : 1;  // Low    : specifies open/close in NLS state or IME hot key

        DWORD ReadyConversion:1;// if conversion mode is ready by succeed communicate to ConIME.
                                // then this field is TRUE.
        DWORD Conversion;       // conversion mode of ime (i.e IME_CMODE_xxx).
                                // this field uses by GetConsoleNlsMode
    } ImeMode;
    HWND hWndConsoleIME;        // validate hWnd when open property window by ImmConfigureIME
#endif // FE_IME
    struct _CONSOLE_INFORMATION *Console;
    INPUT_RECORD ReadConInpDbcsLeadByte;
    INPUT_RECORD WriteConInpDbcsLeadByte[2];
#endif
} INPUT_INFORMATION, *PINPUT_INFORMATION;

typedef struct _INPUT_READ_HANDLE_DATA {

    //
    // the following seven fields are solely used for input reads.
    //

    CRITICAL_SECTION ReadCountLock; // serializes access to read count
    ULONG ReadCount;            // number of reads waiting
    ULONG InputHandleFlags;

    //
    // the following four fields are used to remember input data that
    // wasn't returned on a cooked-mode read.  we do our own buffering
    // and don't return data until the user hits enter so that she can
    // edit the input.  as a result, there is often data that doesn't fit
    // into the caller's buffer.  we save it so we can return it on the
    // next cooked-mode read to this handle.
    //

    ULONG BytesAvailable;
    PWCHAR CurrentBufPtr;
    PWCHAR BufPtr;
} INPUT_READ_HANDLE_DATA, *PINPUT_READ_HANDLE_DATA;

#define UNICODE_BACKSPACE ((WCHAR)0x08)
#define UNICODE_BACKSPACE2 ((WCHAR)0x25d8)
#define UNICODE_CARRIAGERETURN ((WCHAR)0x0d)
#define UNICODE_LINEFEED ((WCHAR)0x0a)
#define UNICODE_BELL ((WCHAR)0x07)
#define UNICODE_TAB ((WCHAR)0x09)
#define UNICODE_SPACE ((WCHAR)0x20)

#define TAB_SIZE 8
#define TAB_MASK (TAB_SIZE-1)
#define NUMBER_OF_SPACES_IN_TAB(POSITION) (TAB_SIZE - ((POSITION) & TAB_MASK))

#define AT_EOL(COOKEDREADDATA) ((COOKEDREADDATA)->BytesRead == ((COOKEDREADDATA)->CurrentPosition*2))
#define INSERT_MODE(COOKEDREADDATA) ((COOKEDREADDATA)->InsertMode)

#define VIRTUAL_KEY_CODE_S 0x53
#define VIRTUAL_KEY_CODE_C 0x43

#define VK_OEM_SCROLL    0x91

#define KEY_PRESSED 0x8000
#define KEY_TOGGLED 0x01
#define KEY_ENHANCED 0x01000000
#define KEY_UP_TRANSITION 1
#define KEY_PREVIOUS_DOWN 0x40000000
#define KEY_TRANSITION_UP 0x80000000

#define CONSOLE_CTRL_C_SEEN  1
#define CONSOLE_CTRL_BREAK_SEEN 2

#define LockReadCount(HANDLEPTR) RtlEnterCriticalSection(&(HANDLEPTR)->InputReadData->ReadCountLock)
#define UnlockReadCount(HANDLEPTR) RtlLeaveCriticalSection(&(HANDLEPTR)->InputReadData->ReadCountLock)

#define LoadKeyEvent(PEVENT,KEYDOWN,CHAR,KEYCODE,SCANCODE,KEYSTATE) { \
        (PEVENT)->EventType = KEY_EVENT;                              \
        (PEVENT)->Event.KeyEvent.bKeyDown = KEYDOWN;                  \
        (PEVENT)->Event.KeyEvent.wRepeatCount = 1;                    \
        (PEVENT)->Event.KeyEvent.uChar.UnicodeChar = CHAR;            \
        (PEVENT)->Event.KeyEvent.wVirtualKeyCode = KEYCODE;           \
        (PEVENT)->Event.KeyEvent.wVirtualScanCode = SCANCODE;         \
        (PEVENT)->Event.KeyEvent.dwControlKeyState = KEYSTATE;        \
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\machine.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    machine.h

Abstract:

    This is the include file that defines detect of machine type.

Author:

    kazum    10-Aug-1994

Revision History:

--*/

#ifndef _MACHINE_ID_
#define _MACHINE_ID_

#if defined(i386)
//
// These definition is only for Intel platform.
//
//
// Hardware platform ID
//

#define PC_AT_COMPATIBLE      0x00000000
#define PC_9800_COMPATIBLE    0x00000001
#define FMR_COMPATIBLE        0x00000002

//
// NT Vendor ID
//

#define NT_MICROSOFT          0x00010000
#define NT_NEC                0x00020000
#define NT_FUJITSU            0x00040000

//
// Vendor/Machine IDs
//
// DWORD MachineID
//
// 31           15             0
// +-------------+-------------+
// |  Vendor ID  | Platform ID |
// +-------------+-------------+
//

#define MACHINEID_MS_PCAT     (NT_MICROSOFT|PC_AT_COMPATIBLE)
#define MACHINEID_MS_PC98     (NT_MICROSOFT|PC_9800_COMPATIBLE)
#define MACHINEID_NEC_PC98    (NT_NEC      |PC_9800_COMPATIBLE)
#define MACHINEID_FUJITSU_FMR (NT_FUJITSU  |FMR_COMPATIBLE)

//
// Build 683 compatibility.
//
// !!! should be removed.

#define MACHINEID_MICROSOFT   MACHINEID_MS_PCAT

//
// Macros
//

#define ISNECPC98(x)    (x == MACHINEID_NEC_PC98)
#define ISFUJITSUFMR(x) (x == MACHINEID_FUJITSU_FMR)
#define ISMICROSOFT(x)  (x == MACHINEID_MS_PCAT)

//
// Functions.
//

//
// User mode ( NT API )
//

LONG
NtGetMachineIdentifierValue(
    IN OUT PULONG Value
    );

//
// User mode ( Win32 API )
//

LONG
RegGetMachineIdentifierValue(
    IN OUT PULONG Value
    );

#endif // defined(i386)
#endif // _MACHINE_ID_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\foncache.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    foncache.h

Abstract:

        This file is definition of fullscreen dll

Author:

    Kazuhiko  Matsubara  21-June-1994

Revision History:

Notes:

--*/



typedef struct _FONT_IMAGE {
    LIST_ENTRY ImageList;                            // link list of other font size.
    COORD FontSize;
    PBYTE ImageBits;                                 // WORD aligned.
} FONT_IMAGE, *PFONT_IMAGE;

typedef struct _FONT_LOW_OFFSET {
    PFONT_IMAGE FontOffsetLow[256];                  // array is low order of Unicode <i.e LOBYTE(Unicode)>
} FONT_LOW_OFFSET, *PFONT_LOW_OFFSET;

typedef struct _FONT_HIGHLOW_OFFSET {
    PFONT_LOW_OFFSET  FontOffsetHighLow[16];         // array is high (3-0bit) order of Unicode <i.e LO4BIT(HIBYTE(Unicode))>
} FONT_HIGHLOW_OFFSET, *PFONT_HIGHLOW_OFFSET;

typedef struct _FONT_HIGHHIGH_OFFSET {
    PFONT_HIGHLOW_OFFSET FontOffsetHighHigh[16];     // array is high (7-4bit) order of Unicode <i.e HI4BIT(HIBYTE(Unicode))>
} FONT_HIGHHIGH_OFFSET, *PFONT_HIGHHIGH_OFFSET;



typedef struct _FONT_CACHE_INFORMATION {
    ULONG  FullScreenFontIndex;
    COORD  FullScreenFontSize;
    PBYTE  BaseImageBits;
    FONT_HIGHHIGH_OFFSET FontTable;
} FONT_CACHE_INFORMATION, *PFONT_CACHE_INFORMATION;


#define FONT_MATCHED   1
#define FONT_STRETCHED 2

#define ADD_IMAGE     1
#define REPLACE_IMAGE 2

#define BITMAP_BITS_BYTE_ALIGN   8                   // BYTE align is 8 bit
#define BITMAP_BITS_WORD_ALIGN  16                   // WORD align is 16 bit
#define BITMAP_ARRAY_BYTE  3                         // BYTE array is 8 bit  (shift count = 3)


typedef struct _FONT_CACHE_AREA {
    PFONT_IMAGE FontImage;
    DWORD       Area;
} FONT_CACHE_AREA, *PFONT_CACHE_AREA;


#define BITMAP_PLANES      1
#define BITMAP_BITS_PIXEL  1


#define BYTE_ALIGN  sizeof(BYTE)
#define WORD_ALIGN  sizeof(WORD)

//
// Font cache manager
//
ULONG
CreateFontCache(
    OUT PFONT_CACHE_INFORMATION *FontCache
    );

ULONG
DestroyFontCache(
    IN PFONT_CACHE_INFORMATION FontCache
    );

ULONG
GetFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    OUT VOID *ImageBits
    );

ULONG
GetStretchedFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    OUT VOID *ImageBits
    );

ULONG
GetFontImagePointer(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    OUT PFONT_IMAGE *FontImage
    );

ULONG
SetFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    IN CONST VOID *ImageBits
    );

DWORD
CalcBitmapBufferSize(
    IN COORD FontSize,
    IN DWORD dwAlign
    );

NTSTATUS
GetExpandFontImage(
    PFONT_CACHE_INFORMATION FontCache,
    WCHAR wChar,
    COORD InputFontSize,
    COORD OutputFontSize,
    PWORD OutputFontImage
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\server.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    server.h

Abstract:

    This module contains the internal structures and definitions used
    by the console server.

Author:

    Therese Stowell (thereses) 12-Nov-1990

Revision History:

--*/

#ifndef _SERVER_H_
#define _SERVER_H_

//
// This message is used to notify the input thread that a console window should
// go away.
//

typedef struct _CONSOLE_SHARE_ACCESS {
    ULONG OpenCount;
    ULONG Readers;
    ULONG Writers;
    ULONG SharedRead;
    ULONG SharedWrite;
} CONSOLE_SHARE_ACCESS, *PCONSOLE_SHARE_ACCESS;

#include "input.h"
#include "output.h"
#if defined(FE_IME)
#include "conime.h"
#include "convarea.h"
#endif

typedef struct _CONSOLE_PROCESS_HANDLE {
    LIST_ENTRY ListLink;
    HANDLE ProcessHandle;
    PCSR_PROCESS Process;
    ULONG TerminateCount;
    LPTHREAD_START_ROUTINE CtrlRoutine;
    LPTHREAD_START_ROUTINE PropRoutine;
} CONSOLE_PROCESS_HANDLE, *PCONSOLE_PROCESS_HANDLE;

typedef struct _INPUT_THREAD_INFO {
    HANDLE ThreadHandle;
    DWORD ThreadId;
    HDESK Desktop;
    HWINSTA WindowStation;
    ULONG WindowCount;
#if defined(FE_IME)
    HWND  hWndConsoleIME;
#endif
} INPUT_THREAD_INFO, *PINPUT_THREAD_INFO;

typedef struct _INPUT_THREAD_INIT_INFO {
    HANDLE ThreadHandle;
    HANDLE InitCompleteEventHandle;
    HDESK DesktopHandle;
    HWINSTA WinstaHandle;
    NTSTATUS InitStatus;
} INPUT_THREAD_INIT_INFO, *PINPUT_THREAD_INIT_INFO;

typedef struct _CONSOLE_MSG {
    LIST_ENTRY ListLink;
    UINT       Message;
    WPARAM     wParam;
    LPARAM     lParam;
} CONSOLE_MSG, *PCONSOLE_MSG;

typedef struct _CONSOLE_THREAD_MSG {
    CONSOLE_MSG;
    DWORD dwThreadId;
} CONSOLE_THREAD_MSG, *PCONSOLE_THREAD_MSG;

// Flags flags

#define CONSOLE_IS_ICONIC               0x00000001
#define CONSOLE_OUTPUT_SUSPENDED        0x00000002
#define CONSOLE_HAS_FOCUS               0x00000004
#define CONSOLE_IGNORE_NEXT_MOUSE_INPUT 0x00000008
#define CONSOLE_SELECTING               0x00000010
#define CONSOLE_SCROLLING               0x00000020
#define CONSOLE_DISABLE_CLOSE           0x00000040
#define CONSOLE_NOTIFY_LAST_CLOSE       0x00000080
#define CONSOLE_NO_WINDOW               0x00000100
#define CONSOLE_VDM_REGISTERED          0x00000200
#define CONSOLE_UPDATING_SCROLL_BARS    0x00000400
#define CONSOLE_QUICK_EDIT_MODE         0x00000800
#define CONSOLE_TERMINATING             0x00001000
#define CONSOLE_CONNECTED_TO_EMULATOR   0x00002000
#define CONSOLE_FULLSCREEN_NOPAINT      0x00004000
#define CONSOLE_SHUTTING_DOWN           0x00008000
#define CONSOLE_AUTO_POSITION           0x00010000
#define CONSOLE_IGNORE_NEXT_KEYUP       0x00020000
#define CONSOLE_WOW_REGISTERED          0x00040000
#define CONSOLE_USE_PRIVATE_FLAGS       0x00080000
#define CONSOLE_HISTORY_NODUP           0x00100000
#define CONSOLE_SCROLLBAR_TRACKING      0x00200000
#define CONSOLE_IN_DESTRUCTION          0x00400000
#define CONSOLE_SETTING_WINDOW_SIZE     0x00800000
#define CONSOLE_DEFAULT_BUFFER_SIZE     0x01000000
#define CONSOLE_VDM_HIDDEN_WINDOW       0x02000000
#if defined(FE_SB)
#define CONSOLE_OS2_REGISTERED          0x20000000
#define CONSOLE_OS2_OEM_FORMAT          0x40000000
#if defined(FE_IME)
#define CONSOLE_JUST_VDM_UNREGISTERED   0x80000000
#endif // FE_IME
#endif

#define CONSOLE_SUSPENDED (CONSOLE_OUTPUT_SUSPENDED)

typedef struct _CONSOLE_INFORMATION {
    CRITICAL_SECTION ConsoleLock;   // serialize input and output using this
    ULONG RefCount;
    ULONG WaitCount;
    INPUT_INFORMATION InputBuffer;
    PSCREEN_INFORMATION CurrentScreenBuffer;
    PSCREEN_INFORMATION ScreenBuffers;  // singly linked list
    HWINSTA hWinSta;                // server handle to windowstation
    HDESK hDesk;                    // server handle to desktop
    HWND hWnd;
    HKL hklActive;                  // keyboard layout for this console window
    HDC hDC;                        // server side hDC
    HMENU hMenu;                    // handle to system menu
    HMENU hHeirMenu;                // handle to menu we append to system menu
    HPALETTE hSysPalette;
    RECT WindowRect;
    DWORD ResizeFlags;
    LIST_ENTRY OutputQueue;
    HANDLE InitEvents[NUMBER_OF_INITIALIZATION_EVENTS];
    HANDLE ClientThreadHandle;
    LIST_ENTRY ProcessHandleList;
    LIST_ENTRY CommandHistoryList;
    LIST_ENTRY ExeAliasList;
    SHORT NumCommandHistories;
    SHORT MaxCommandHistories;
    SHORT CommandHistorySize;
    USHORT OriginalTitleLength;
    USHORT TitleLength;
    LPWSTR OriginalTitle;
    LPWSTR Title;
    DWORD dwHotKey;
    HICON hIcon;
    HICON hSmIcon;
    INT iIconId;
    WORD LastAttributes;
    BYTE ReserveKeys;           // keys reserved by app (i.e. ctrl-esc)
    DWORD Flags;

    // if a wait has been satisfied, the pointer to the wait queue is stored
    // here.

    PLIST_ENTRY WaitQueue;

    // the following fields are used for selection

    DWORD SelectionFlags;
    SMALL_RECT SelectionRect;
    COORD SelectionAnchor;
    COORD TextCursorPosition;   // current position on screen (in screen buffer coords).
    ULONG TextCursorSize;
    BOOLEAN TextCursorVisible;    // whether cursor is visible (set by user)

    BOOLEAN InsertMode;     // used by command line editing

    // following fields are used when window is created

    WORD wShowWindow;
    int dwWindowOriginX;
    int dwWindowOriginY;

    WORD FullScreenFlags;
    WORD PopupCount;

    // following fields are used for the VDM

    HANDLE VDMStartHardwareEvent;
    HANDLE VDMEndHardwareEvent;
    HANDLE VDMErrorHardwareEvent;
    HANDLE VDMProcessHandle;
    HANDLE VDMProcessId;

    HANDLE VDMBufferSectionHandle;
    PCHAR_INFO VDMBuffer;
    PCHAR_INFO VDMBufferClient;
    COORD VDMBufferSize;

    HANDLE StateSectionHandle; // used for get/sethardwarestate
    PVOID StateBuffer;
    PVOID StateBufferClient;
    DWORD StateLength;

    // the following fields are used for ansi-unicode translation

    UINT CP;
    UINT OutputCP;

    //
    // these two fields are used while getting the icon from the
    // program manager via DDE.
    //

    HWND hWndProgMan;
    BOOL bIconInit;

    HANDLE ConsoleHandle;

    ULONG CtrlFlags;            // indicates outstanding ctrl requests
    ULONG LimitingProcessId;
    HANDLE TerminationEvent;

    SHORT VerticalClientToWindow;
    SHORT HorizontalClientToWindow;

    COLORREF  ColorTable[ 16 ];
    HANDLE hProcessLastNotifyClose;     // process handle of last-close-notify
    HANDLE ProcessIdLastNotifyClose;    // process unique id of last-close-notify
    HWND hWndProperties;

    PINPUT_THREAD_INFO InputThreadInfo;     // console thread info

    LIST_ENTRY MessageQueue;

#if defined(FE_SB)
    CPINFO CPInfo;
    CPINFO OutputCPInfo;

    DWORD ReadConInpNumBytesUnicode;
    DWORD ReadConInpNumBytesTemp;

    DWORD WriteConOutNumBytesUnicode;
    DWORD WriteConOutNumBytesTemp;

    PVOID lpCookedReadData;             // Same as PCOOKED_READ_DATA

    PVOID EudcInformation;              // Same as PEUDC_INFORMATION

    PVOID FontCacheInformation;         // Same as PFONT_CACHE_INFORMATION

#if defined(FE_IME)
    CONSOLE_IME_INFORMATION ConsoleIme;
#endif // FE_IME

    HDC FonthDC;                        // Double colored DBCS hDC
    HBITMAP hBitmap;
#if defined(i386)
    SMALL_RECT Os2SavedWindowRect;
#endif
    BOOLEAN fVDMVideoMode;              // FALSE : VGA Format
                                        // TRUE  : Common LVB Format
    BOOLEAN fIsDBCSCP;
    BOOLEAN fIsDBCSOutputCP;

#endif
} CONSOLE_INFORMATION, *PCONSOLE_INFORMATION;

//
// CtrlFlags definitions
//

#define CONSOLE_CTRL_C_FLAG                     1
#define CONSOLE_CTRL_BREAK_FLAG                 2
#define CONSOLE_CTRL_CLOSE_FLAG                 4
#define CONSOLE_FORCE_SHUTDOWN_FLAG             8
#define CONSOLE_CTRL_LOGOFF_FLAG                16
#define CONSOLE_CTRL_SHUTDOWN_FLAG              32

#define ADD_SCROLL_BARS_X 0x1
#define REMOVE_SCROLL_BARS_X 0x2
#define ADD_SCROLL_BARS_Y 0x4
#define REMOVE_SCROLL_BARS_Y 0x8
#define RESIZE_SCROLL_BARS 0x10
#define SCROLL_BAR_CHANGE (ADD_SCROLL_BARS_X | REMOVE_SCROLL_BARS_X | ADD_SCROLL_BARS_Y | REMOVE_SCROLL_BARS_Y | RESIZE_SCROLL_BARS)
#define BORDER_CHANGE 0x20
#define SCREEN_BUFFER_CHANGE 0x40

#define CONSOLE_INITIAL_IO_HANDLES 3
#define CONSOLE_IO_HANDLE_INCREMENT 3

#define CONSOLE_FREE_HANDLE 0
//#define CONSOLE_INPUT_HANDLE 1
//#define CONSOLE_OUTPUT_HANDLE 2
#define CONSOLE_GRAPHICS_OUTPUT_HANDLE 4
#define CONSOLE_INHERITABLE 8
#define CONSOLE_ANY_HANDLE ((ULONG)(-1))

//
// input handle flags
//

#define HANDLE_CLOSING 1
#define HANDLE_INPUT_PENDING 2
#define HANDLE_MULTI_LINE_INPUT 4

typedef struct _HANDLE_DATA {
    ULONG HandleType;
    ACCESS_MASK Access;
    ULONG ShareAccess;
    union {
        PSCREEN_INFORMATION ScreenBuffer;
        PINPUT_INFORMATION InputBuffer;
    } Buffer;
    PINPUT_READ_HANDLE_DATA InputReadData; // used only by input reads
} HANDLE_DATA, *PHANDLE_DATA;

typedef struct _CONSOLE_PER_PROCESS_DATA {
    HANDLE ConsoleHandle;
    HANDLE_DATA HandleTable[CONSOLE_INITIAL_IO_HANDLES];
    ULONG HandleTableSize;
    PHANDLE_DATA HandleTablePtr;
    BOOLEAN ConsoleApp;
    BOOLEAN RootProcess;
    DWORD ParentProcessId;
#if defined(FE_IME)
    HDESK hDesk;
    HWINSTA hWinSta;
#endif
} CONSOLE_PER_PROCESS_DATA, *PCONSOLE_PER_PROCESS_DATA;

#define CONSOLE_INITIAL_CONSOLES 10
#define CONSOLE_CONSOLE_HANDLE_INCREMENT 5
#define CONSOLE_HANDLE_ALLOCATED 1

#define INDEX_TO_HANDLE(INDEX) ((HANDLE)(((ULONG_PTR)INDEX << 2) | CONSOLE_HANDLE_SIGNATURE))
#define HANDLE_TO_INDEX(CONHANDLE) ((HANDLE)((ULONG_PTR)CONHANDLE >> 2))

#define INPUT_MODES (ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT | ENABLE_WINDOW_INPUT | ENABLE_MOUSE_INPUT)
#define OUTPUT_MODES (ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT)
#define PRIVATE_MODES (ENABLE_INSERT_MODE | ENABLE_QUICK_EDIT_MODE | ENABLE_PRIVATE_FLAGS)

#define CURSOR_PERCENTAGE_TO_TOP_SCAN_LINE(FONTSIZE,PERCENTAGE) ((FONTSIZE) - ((FONTSIZE) * (PERCENTAGE) / 100))

#define ConsoleLocked(CONSOLEPTR) (((CONSOLEPTR)->ConsoleLock.OwningThread) == NtCurrentTeb()->ClientId.UniqueThread)

#define CONSOLE_STATUS_WAIT ((NTSTATUS)0xC0030001L)
#define CONSOLE_STATUS_READ_COMPLETE ((NTSTATUS)0xC0030002L)
#define CONSOLE_STATUS_WAIT_NO_BLOCK ((NTSTATUS)0xC0030003L)

#define CM_CREATE_CONSOLE_WINDOW (WM_USER+0)
#define CM_DESTROY_WINDOW        (WM_USER+1)
#define CM_SET_WINDOW_SIZE       (WM_USER+2)
#define CM_BEEP                  (WM_USER+3)
#define CM_UPDATE_SCROLL_BARS    (WM_USER+4)
#define CM_UPDATE_TITLE          (WM_USER+5)
//
// CM_MODE_TRANSITION is hard-coded to WM_USER+6 in kernel\winmgr.c
//
#define CM_MODE_TRANSITION       (WM_USER+6)
#define CM_CONSOLE_SHUTDOWN      (WM_USER+7)
#define CM_HIDE_WINDOW           (WM_USER+8)
#if defined(FE_IME)
#define CM_CONIME_CREATE         (WM_USER+9)
#define CM_SET_CONSOLEIME_WINDOW (WM_USER+10)
#define CM_WAIT_CONIME_PROCESS   (WM_USER+11)
#define CM_SET_IME_CODEPAGE      (WM_USER+12)
#define CM_SET_NLSMODE           (WM_USER+13)
#define CM_GET_NLSMODE           (WM_USER+14)
#define CM_CONIME_KL_ACTIVATE    (WM_USER+15)
#endif
#define CM_CONSOLE_MSG           (WM_USER+16)
#define CM_CONSOLE_INPUT_THREAD_MSG (WM_USER+17)

#define CONSOLE_CLIENTTHREADHANDLE(pcsrthread) ((pcsrthread)->ThreadHandle)

#define CONSOLE_CLIENTPROCESSHANDLE() \
    ((CSR_SERVER_QUERYCLIENTTHREAD())->Process->ProcessHandle)

#define CONSOLE_CLIENTPROCESSID() \
    ((CSR_SERVER_QUERYCLIENTTHREAD())->Process->ClientId.UniqueProcess)

#define CONSOLE_FROMPROCESSPROCESSHANDLE(pcsrprocess) \
                                               ((pcsrprocess)->ProcessHandle)

#define CONSOLE_FROMPROCESSPERPROCESSDATA(pcsrprocess) \
    ((pcsrprocess)->ServerDllPerProcessData[CONSRV_SERVERDLL_INDEX])

#define CONSOLE_FROMTHREADPERPROCESSDATA(pcsrthread) \
    CONSOLE_FROMPROCESSPERPROCESSDATA((pcsrthread)->Process)

#define CONSOLE_PERPROCESSDATA() \
    CONSOLE_FROMTHREADPERPROCESSDATA(CSR_SERVER_QUERYCLIENTTHREAD())

#define CONSOLE_GETCONSOLEAPP() (((PCONSOLE_PER_PROCESS_DATA)CONSOLE_PERPROCESSDATA())->ConsoleApp)
#define CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(PROCESSDATA) ((PROCESSDATA)->ConsoleApp)
#define CONSOLE_SETCONSOLEAPP(VALUE) (((PCONSOLE_PER_PROCESS_DATA)CONSOLE_PERPROCESSDATA())->ConsoleApp = VALUE)
#define CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(PROCESSDATA,VALUE) ((PROCESSDATA)->ConsoleApp = VALUE)

#define CONSOLE_GETCONSOLEHANDLE() (((PCONSOLE_PER_PROCESS_DATA)CONSOLE_PERPROCESSDATA())->ConsoleHandle)
#define CONSOLE_SETCONSOLEHANDLE(VALUE) (((PCONSOLE_PER_PROCESS_DATA)CONSOLE_PERPROCESSDATA())->ConsoleHandle = VALUE)
#define CONSOLE_GETCONSOLEHANDLEFROMPROCESSDATA(PROCESSDATA) ((PROCESSDATA)->ConsoleHandle)
#define CONSOLE_SETCONSOLEHANDLEFROMPROCESSDATA(PROCESSDATA,VALUE) ((PROCESSDATA)->ConsoleHandle = VALUE)

#endif

//
// registry information structure
//

typedef struct _CONSOLE_REGISTRY_INFO {
    COORD     ScreenBufferSize;
    COORD     WindowSize;
    COORD     WindowOrigin;
    COORD     FontSize;
    UINT      FontFamily;
    UINT      FontWeight;
    WCHAR     FaceName[LF_FACESIZE];
    UINT      CursorSize;
    BOOL      FullScreen;
    BOOL      QuickEdit;
    BOOL      InsertMode;
    BOOL      AutoPosition;
    CHAR_INFO ScreenFill;
    CHAR_INFO PopupFill;
    UINT      HistoryBufferSize;
    UINT      NumberOfHistoryBuffers;
    BOOL      HistoryNoDup;
    COLORREF  ColorTable[ 16 ];
    LONGLONG  LastWriteTime;
#if defined(FE_SB) // scotthsu
    DWORD     CodePage;
#endif
} CONSOLE_REGISTRY_INFO, *PCONSOLE_REGISTRY_INFO;


//
// window class
//

#define CONSOLE_WINDOW_CLASS (L"ConsoleWindowClass")

#define CONSOLE_MAX_APP_SHORTCUTS 1

//
// this structure is used to store relevant information from the
// console for ctrl processing so we can do it without holding the
// console lock.
//

typedef struct _CONSOLE_PROCESS_TERMINATION_RECORD {
    HANDLE ProcessHandle;
    ULONG TerminateCount;
    BOOL bDebugee;
    LPTHREAD_START_ROUTINE CtrlRoutine;
} CONSOLE_PROCESS_TERMINATION_RECORD, *PCONSOLE_PROCESS_TERMINATION_RECORD;

//
// this value is used to determine the size of stack buffers for
// strings.  it should be long enough to contain the width of a
// normal screen buffer.
//

#define STACK_BUFFER_SIZE 132

//
// link information
//


#define LINK_PROP_MAIN_SIG          0x00000001
#define LINK_PROP_NT_CONSOLE_SIG    0x00000002

#if 0  // no one currently uses this...
typedef struct {

    WCHAR  pszLinkName[ MAX_PATH ];
    WCHAR  pszName[ MAX_PATH ];
    WCHAR  pszRelPath[ MAX_PATH ];
    WCHAR  pszWorkingDir[ MAX_PATH ];
    WCHAR  pszArgs[ MAX_PATH ];
    WCHAR  pszIconLocation[ MAX_PATH ];
    int    iIcon;
    int    iShowCmd;
    int    wHotKey;

} LNKPROPMAIN, * LPLNKPROPMAIN;
#endif

#ifndef _USERKDX_ /* debugging extensions */
typedef struct {

    WCHAR    pszName[ MAX_PATH ];
    WCHAR    pszIconLocation[ MAX_PATH ];
    UINT     uIcon;
    UINT     uShowCmd;
    UINT     uHotKey;
    NT_CONSOLE_PROPS console_props;
#ifdef FE_SB
    NT_FE_CONSOLE_PROPS fe_console_props;
#endif


} LNKPROPNTCONSOLE, *LPLNKPROPNTCONSOLE;
#endif

#ifndef _USERKDX_ /* debugging extensions */
typedef struct {
    LPWSTR              pszCurFile;     // current file from IPersistFile
    LPWSTR              pszRelSource;   // overrides pszCurFile in relative tracking

    LPWSTR              pszName;        // title on short volumes
    LPWSTR              pszRelPath;
    LPWSTR              pszWorkingDir;
    LPWSTR              pszArgs;
    LPWSTR              pszIconLocation;

    LPSTR               pExtraData;     // extra data to preserve for future compatibility

    SHELL_LINK_DATA     sld;
} CShellLink;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\inc\output.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    output.h

Abstract:

    This module contains the internal structures and definitions used
    by the output (screen) component of the NT console subsystem.

Author:

    Therese Stowell (thereses) 12-Nov-1990

Revision History:

--*/

// the characters of one row of screen buffer
// we keep the following values so that we don't write
// more pixels to the screen than we have to:
// left is initialized to screenbuffer width.  right is
// initialized to zero.
//
//      [     foo.bar    12-12-61                       ]
//       ^    ^                  ^                     ^
//       |    |                  |                     |
//     Chars Left               Right                end of Chars buffer

typedef struct _CHAR_ROW {
    SHORT Right;            // one past rightmost bound of chars in Chars array (array will be full width)
    SHORT OldRight;         // old one past rightmost bound of chars in Chars array (array will be full width)
    SHORT Left;             // leftmost bound of chars in Chars array (array will be full width)
    SHORT OldLeft;          // old leftmost bound of chars in Chars array (array will be full width)
    PWCHAR Chars;            // all chars in row up to last non-space char
#if defined(FE_SB)
    PBYTE KAttrs;            // all DBCS lead & trail bit in row
        #define ATTR_LEADING_BYTE  0x01
        #define ATTR_TRAILING_BYTE 0x02
        #define ATTR_DBCSSBCS_BYTE 0x03
        #define ATTR_SEPARATE_BYTE 0x10
        #define ATTR_EUDCFLAG_BYTE 0x20
#endif
} CHAR_ROW, *PCHAR_ROW;

// run-length encoded data structure for attributes

typedef struct _ATTR_PAIR {
    SHORT Length;            // number of times attribute appears
    WORD Attr;              // attribute
} ATTR_PAIR, *PATTR_PAIR;

// the attributes of one row of screen buffer

typedef struct _ATTR_ROW {
    SHORT Length;            // length of attr pair array
    ATTR_PAIR AttrPair;     // use this if only one pair
    PATTR_PAIR Attrs;       // attr pair array
} ATTR_ROW, *PATTR_ROW;

// information associated with one row of screen buffer

typedef struct _ROW {
    CHAR_ROW CharRow;
    ATTR_ROW AttrRow;
} ROW, *PROW;

#if defined(FE_SB)
typedef struct _DBCS_SCREEN_BUFFER {
    /*
     * all DBCS lead & trail bit buffer
     */
    PBYTE KAttrRows;
    /*
     * Temporary buffer for translate Unicode<--ASCII.
     *
     * Used as follows routine:
     *   WriteOutputString
     *   WriteRegionToScreen
     *   DoWriteConsole
     */
    PWCHAR TransBufferCharacter;
    PBYTE  TransBufferAttribute;
    /*
     * Used as follows routine:
     *   SrvWriteConsole
     */
    PWCHAR TransWriteConsole;
} DBCS_SCREEN_BUFFER, *PDBCS_SCREEN_BUFFER;
#endif

typedef struct _TEXT_BUFFER_FONT_INFO {
    struct _TEXT_BUFFER_FONT_INFO *NextTextBufferFont;
    COORD FontSize;     // Desired size.  Pixels (x,y) or Points (0, -p)
    DWORD FontNumber;   // index into fontinfo[]  -  sometimes out of date
    WCHAR FaceName[LF_FACESIZE];
    LONG Weight;
    BYTE Family;
    UINT FontCodePage;  // Code page for this font
} TEXT_BUFFER_FONT_INFO, *PTEXT_BUFFER_FONT_INFO;

typedef struct _TEXT_BUFFER_INFO {
    PROW Rows;
    PWCHAR TextRows;
    SHORT FirstRow;  // indexes top row (not necessarily 0)
    BOOLEAN CursorMoved;
    BOOLEAN CursorVisible;  // whether cursor is visible (set by user)
    BOOLEAN CursorOn;       // whether blinking cursor is on or not
    BOOLEAN DoubleCursor;   // whether the cursor size should be doubled
    BOOLEAN DelayCursor;    // don't toggle cursor on next timer message
    COORD CursorPosition;   // current position on screen (in screen buffer coords).
    ULONG CursorSize;
    WORD CursorYSize;
    WORD  UpdatingScreen;   // whether cursor is visible (set by console)
    ULONG ModeIndex;     // fullscreen font and mode
#ifdef i386
    // the following fields are used only by fullscreen textmode
    COORD WindowedWindowSize; // window size in windowed mode
    COORD WindowedScreenSize; // screen buffer size in windowed mode
    COORD MousePosition;
#endif
    ULONG Flags;        // indicate screen update hint state

    PTEXT_BUFFER_FONT_INFO ListOfTextBufferFont;
    TEXT_BUFFER_FONT_INFO  CurrentTextBufferFont;

#if defined(FE_SB)
    BOOLEAN CursorBlink;
    BOOLEAN CursorDBEnable;
    DBCS_SCREEN_BUFFER DbcsScreenBuffer;
#endif
} TEXT_BUFFER_INFO, *PTEXT_BUFFER_INFO;

typedef struct _GRAPHICS_BUFFER_INFO {
    ULONG BitMapInfoLength;
    LPBITMAPINFO lpBitMapInfo;
    PVOID BitMap;
    PVOID ClientBitMap;
    HANDLE ClientProcess;
    HANDLE hMutex;
    HANDLE hSection;
    DWORD dwUsage;
} GRAPHICS_BUFFER_INFO, *PGRAPHICS_BUFFER_INFO;

#define CONSOLE_TEXTMODE_BUFFER 1
#define CONSOLE_GRAPHICS_BUFFER 2
#define CONSOLE_OEMFONT_DISPLAY 4

typedef struct _SCREEN_INFORMATION {
    struct _CONSOLE_INFORMATION *Console;
    ULONG Flags;
    DWORD OutputMode;
    ULONG RefCount;
    CONSOLE_SHARE_ACCESS ShareAccess;   // share mode
    COORD ScreenBufferSize; // dimensions of buffer
    SMALL_RECT  Window;       // window location in screen buffer coordinates
    WORD ResizingWindow;   // > 0 if we should ignore WM_SIZE messages
    WORD Attributes;        // attributes of written text
    WORD PopupAttributes;   // attributes of popup text
    BOOLEAN WindowMaximizedX;
    BOOLEAN WindowMaximizedY;
    BOOLEAN WindowMaximized;
    UINT CommandIdLow;
    UINT CommandIdHigh;
    HCURSOR CursorHandle;
    HPALETTE hPalette;
    UINT dwUsage;
    int CursorDisplayCount;
    int WheelDelta;
    union {
        TEXT_BUFFER_INFO TextInfo;
        GRAPHICS_BUFFER_INFO GraphicsInfo;
    } BufferInfo;
    struct _SCREEN_INFORMATION *Next;
#if defined(FE_SB)
    BYTE   WriteConsoleDbcsLeadByte[2];
    BYTE   FillOutDbcsLeadChar;
    WCHAR  LineChar[6];
        #define UPPER_LEFT_CORNER   0
        #define UPPER_RIGHT_CORNER  1
        #define HORIZONTAL_LINE     2
        #define VERTICAL_LINE       3
        #define BOTTOM_LEFT_CORNER  4
        #define BOTTOM_RIGHT_CORNER 5
    BYTE BisectFlag;
        #define BISECT_LEFT   0x01
        #define BISECT_TOP    0x02
        #define BISECT_RIGHT  0x04
        #define BISECT_BOTTOM 0x08
#if defined(FE_IME)
    struct _CONVERSIONAREA_INFORMATION *ConvScreenInfo;
#else
    PVOID ConvScreenInfo;
#endif // FE_IME
#endif
} SCREEN_INFORMATION, *PSCREEN_INFORMATION;

typedef struct _WINDOW_LIMITS {
    COORD MinimumWindowSize;    // minimum dimensions of window
    COORD MaximumWindowSize;    // maximum dimensions of window
    COORD MaxWindow;            // in pixels
    COORD FullScreenSize;
} WINDOW_LIMITS, *PWINDOW_LIMITS;

//
// the following values are used for TextInfo.Flags
//

#define TEXT_VALID_HINT 1
#define SINGLE_ATTRIBUTES_PER_LINE 2    // only one attribute per line
#if defined(FE_IME)
#define CONSOLE_CONVERSION_AREA_REDRAW 4
#endif

//
// the following value is put in CharInfo.OldLength if the value shouldn't
// be used.
//

#define INVALID_OLD_LENGTH -1

//
// the following mask is used to test for valid text attributes.
//

#if defined(FE_SB)
#define VALID_TEXT_ATTRIBUTES (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY | BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY | \
COMMON_LVB_LEADING_BYTE | COMMON_LVB_TRAILING_BYTE | COMMON_LVB_GRID_HORIZONTAL | COMMON_LVB_GRID_LVERTICAL | COMMON_LVB_GRID_RVERTICAL | COMMON_LVB_REVERSE_VIDEO | COMMON_LVB_UNDERSCORE )
#else
#define VALID_TEXT_ATTRIBUTES (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY | BACKGROUND_BLUE | BACKGROUND_GREEN | BACKGROUND_RED | BACKGROUND_INTENSITY)
#endif

//
// the following macros are used to calculate 1) the cursor size in pixels
// and 2) the upper left pixel in the cursor, given the font size and
// the cursor size.
//

#define CURSOR_SIZE_IN_PIXELS(FONT_SIZE_Y,SIZE) ((((FONT_SIZE_Y)*(SIZE))+99)/100)
#define CURSOR_Y_OFFSET_IN_PIXELS(FONT_SIZE_Y,YSIZE) ((FONT_SIZE_Y) - (YSIZE))

//
// the following values are used to create the textmode cursor.
//

#define CURSOR_TIMER 1
#define CURSOR_SMALL_SIZE 25    // large enough to be one pixel on a six pixel font
#define CURSOR_BIG_SIZE 50

//
// the following macro returns TRUE if the given screen buffer is the
// active screen buffer.
//

#define ACTIVE_SCREEN_BUFFER(SCREEN_INFO) ((SCREEN_INFO)->Console->CurrentScreenBuffer == SCREEN_INFO)

//
// the following mask is used to create console windows.
//

#define CONSOLE_WINDOW_FLAGS (WS_OVERLAPPEDWINDOW | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL)
#define CONSOLE_WINDOW_EX_FLAGS (WS_EX_OVERLAPPEDWINDOW | WS_EX_ACCEPTFILES | WS_EX_APPWINDOW )

#define WINDOW_SIZE_X(WINDOW) ((SHORT)(((WINDOW)->Right - (WINDOW)->Left + 1)))
#define WINDOW_SIZE_Y(WINDOW) ((SHORT)(((WINDOW)->Bottom - (WINDOW)->Top + 1)))
#define CONSOLE_WINDOW_SIZE_X(SCREEN) (WINDOW_SIZE_X(&(SCREEN)->Window))
#define CONSOLE_WINDOW_SIZE_Y(SCREEN) (WINDOW_SIZE_Y(&(SCREEN)->Window))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\clipbrd.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    clipbrd.c

Abstract:

        This file implements the clipboard functions.

Author:

    Therese Stowell (thereses) Jan-24-1992

--*/

#include "precomp.h"
#pragma hdrstop

/*++

    Here's the pseudocode for various clipboard operations

    init keyboard select (mark)
    ---------------------------
    if (already selecting)
        cancel selection
    init flags
    hidecursor
    createcursor
    init select rect
    set win text

    convert to mouse select (select)
    --------------------------------
    set flags
    destroy cursor
    showcursor
    invert old select rect
    init select rect
    invert select rect
    set win text

    re-init mouse select
    --------------------
    invert old select rect
    init select rect
    invert select rect

    cancel mouse select
    -------------------
    set flags
    reset win text
    invert old select rect

    cancel key select
    -----------------
    set flags
    reset win text
    destroy cursor
    showcursor
    invert old select rect

--*/


BOOL
MyInvert(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT SmallRect
    )

/*++

    invert a rect

--*/

{
    RECT Rect;
    PSCREEN_INFORMATION ScreenInfo;
#ifdef FE_SB
    SMALL_RECT SmallRect2;
    COORD TargetPoint;
    SHORT StringLength;
#endif  // FE_SB

    ScreenInfo = Console->CurrentScreenBuffer;
#ifdef FE_SB
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
            ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        for (SmallRect2.Top=SmallRect->Top; SmallRect2.Top <= SmallRect->Bottom;SmallRect2.Top++) {
            SmallRect2.Bottom = SmallRect2.Top;
            SmallRect2.Left = SmallRect->Left;
            SmallRect2.Right = SmallRect->Right;

            TargetPoint.X = SmallRect2.Left;
            TargetPoint.Y = SmallRect2.Top;
            StringLength = SmallRect2.Right - SmallRect2.Left + 1;
            BisectClipbrd(StringLength,TargetPoint,ScreenInfo,&SmallRect2);

            if (SmallRect2.Left <= SmallRect2.Right) {
                Rect.left = SmallRect2.Left-ScreenInfo->Window.Left;
                Rect.top = SmallRect2.Top-ScreenInfo->Window.Top;
                Rect.right = SmallRect2.Right+1-ScreenInfo->Window.Left;
                Rect.bottom = SmallRect2.Bottom+1-ScreenInfo->Window.Top;
                Rect.left *= SCR_FONTSIZE(ScreenInfo).X;
                Rect.top *= SCR_FONTSIZE(ScreenInfo).Y;
                Rect.right *= SCR_FONTSIZE(ScreenInfo).X;
                Rect.bottom *= SCR_FONTSIZE(ScreenInfo).Y;
                PatBlt(Console->hDC,
                       Rect.left,
                       Rect.top,
                       Rect.right  - Rect.left,
                       Rect.bottom - Rect.top,
                       DSTINVERT
                      );
            }
        }
    } else
#endif  // FE_SB
    {
        Rect.left = SmallRect->Left-ScreenInfo->Window.Left;
        Rect.top = SmallRect->Top-ScreenInfo->Window.Top;
        Rect.right = SmallRect->Right+1-ScreenInfo->Window.Left;
        Rect.bottom = SmallRect->Bottom+1-ScreenInfo->Window.Top;
#ifdef FE_SB
        if (!CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)
#else
        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)
#endif
        {
            Rect.left *= SCR_FONTSIZE(ScreenInfo).X;
            Rect.top *= SCR_FONTSIZE(ScreenInfo).Y;
            Rect.right *= SCR_FONTSIZE(ScreenInfo).X;
            Rect.bottom *= SCR_FONTSIZE(ScreenInfo).Y;
        }

        PatBlt(Console->hDC,
                  Rect.left,
                  Rect.top,
                  Rect.right  - Rect.left,
                  Rect.bottom - Rect.top,
                  DSTINVERT
                 );
    }

    return(TRUE);
}

VOID
InvertSelection(
    IN PCONSOLE_INFORMATION Console,
    BOOL Inverting
    )
{
    BOOL Inverted;
    if (Console->Flags & CONSOLE_SELECTING &&
        Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) {
        Inverted = (Console->SelectionFlags & CONSOLE_SELECTION_INVERTED) ? TRUE : FALSE;
        if (Inverting == Inverted) {
            return;
        }
        if (Inverting) {
            Console->SelectionFlags |= CONSOLE_SELECTION_INVERTED;
        } else {
            Console->SelectionFlags &= ~CONSOLE_SELECTION_INVERTED;
        }
        MyInvert(Console,&Console->SelectionRect);
    }

}

VOID
InitializeMouseSelection(
    IN PCONSOLE_INFORMATION Console,
    IN COORD CursorPosition
    )

/*++

    This routine initializes a selection region.

--*/

{
    Console->SelectionAnchor = CursorPosition;
    Console->SelectionRect.Left = Console->SelectionRect.Right = CursorPosition.X;
    Console->SelectionRect.Top = Console->SelectionRect.Bottom = CursorPosition.Y;

    //
    // Fire off an event to let accessibility apps know the selection has changed.
    //

    ConsoleNotifyWinEvent(Console,
                          EVENT_CONSOLE_CARET,
                          CONSOLE_CARET_SELECTION,
                          PACKCOORD(CursorPosition));
}

VOID
ExtendSelection(
    IN PCONSOLE_INFORMATION Console,
    IN COORD CursorPosition
    )

/*++

    This routine extends a selection region.

--*/

{
    SMALL_RECT OldSelectionRect;
    HRGN OldRegion,NewRegion,CombineRegion;
    COORD FontSize;
    PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;

    if (CursorPosition.X < 0) {
        CursorPosition.X = 0;
    } else if (CursorPosition.X >= ScreenInfo->ScreenBufferSize.X) {
        CursorPosition.X = ScreenInfo->ScreenBufferSize.X-1;
    }

    if (CursorPosition.Y < 0) {
        CursorPosition.Y = 0;
    } else if (CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y) {
        CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-1;
    }

    if (!(Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY)) {

        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            // scroll if necessary to make cursor visible.
            MakeCursorVisible(ScreenInfo, CursorPosition);
            ASSERT(!(Console->SelectionFlags & CONSOLE_MOUSE_SELECTION));

            //
            // if the selection rect hasn't actually been started,
            // the selection cursor is still blinking.  turn it off.
            //

            ConsoleHideCursor(ScreenInfo);
        }
        Console->SelectionFlags |= CONSOLE_SELECTION_NOT_EMPTY;
        Console->SelectionRect.Left =Console->SelectionRect.Right = Console->SelectionAnchor.X;
        Console->SelectionRect.Top = Console->SelectionRect.Bottom = Console->SelectionAnchor.Y;

        // invert the cursor corner

#ifdef FE_SB
        if (!CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)
#else
        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)
#endif
        {
            MyInvert(Console,&Console->SelectionRect);
        }
    } else {

        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            // scroll if necessary to make cursor visible.
            MakeCursorVisible(ScreenInfo,CursorPosition);
        }
#ifdef FE_SB
        //
        // uninvert old selection
        //
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
            MyInvert(Console, &Console->SelectionRect);
        }
#endif  // FE_SB
    }

    //
    // update selection rect
    //

    OldSelectionRect = Console->SelectionRect;
    if (CursorPosition.X <= Console->SelectionAnchor.X) {
        Console->SelectionRect.Left = CursorPosition.X;
        Console->SelectionRect.Right = Console->SelectionAnchor.X;
    } else if (CursorPosition.X > Console->SelectionAnchor.X) {
        Console->SelectionRect.Right = CursorPosition.X;
        Console->SelectionRect.Left = Console->SelectionAnchor.X;
    }
    if (CursorPosition.Y <= Console->SelectionAnchor.Y) {
        Console->SelectionRect.Top = CursorPosition.Y;
        Console->SelectionRect.Bottom = Console->SelectionAnchor.Y;
    } else if (CursorPosition.Y > Console->SelectionAnchor.Y) {
        Console->SelectionRect.Bottom = CursorPosition.Y;
        Console->SelectionRect.Top = Console->SelectionAnchor.Y;
    }

    //
    // change inverted selection
    //
#ifdef FE_SB
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
        MyInvert(Console, &Console->SelectionRect);
    } else
#endif
    {
        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            FontSize = CON_FONTSIZE(Console);
        } else {
            FontSize.X = 1;
            FontSize.Y = 1;
        }
        CombineRegion = CreateRectRgn(0,0,0,0);
        OldRegion = CreateRectRgn((OldSelectionRect.Left-ScreenInfo->Window.Left)*FontSize.X,
                                  (OldSelectionRect.Top-ScreenInfo->Window.Top)*FontSize.Y,
                                  (OldSelectionRect.Right-ScreenInfo->Window.Left+1)*FontSize.X,
                                  (OldSelectionRect.Bottom-ScreenInfo->Window.Top+1)*FontSize.Y
                                 );
        NewRegion = CreateRectRgn((Console->SelectionRect.Left-ScreenInfo->Window.Left)*FontSize.X,
                                  (Console->SelectionRect.Top-ScreenInfo->Window.Top)*FontSize.Y,
                                  (Console->SelectionRect.Right-ScreenInfo->Window.Left+1)*FontSize.X,
                                  (Console->SelectionRect.Bottom-ScreenInfo->Window.Top+1)*FontSize.Y
                                 );
        CombineRgn(CombineRegion,OldRegion,NewRegion,RGN_XOR);

        InvertRgn(Console->hDC,CombineRegion);
        DeleteObject(OldRegion);
        DeleteObject(NewRegion);
        DeleteObject(CombineRegion);
    }

    //
    // Fire off an event to let accessibility apps know the selection has changed.
    //

    ConsoleNotifyWinEvent(Console,
                          EVENT_CONSOLE_CARET,
                          CONSOLE_CARET_SELECTION,
                          PACKCOORD(CursorPosition));
}

VOID
CancelMouseSelection(
    IN PCONSOLE_INFORMATION Console
    )

/*++

    This routine terminates a mouse selection.

--*/

{
    PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;

    //
    // turn off selection flag
    //

    Console->Flags &= ~CONSOLE_SELECTING;

    SetWinText(Console,msgSelectMode,FALSE);

    //
    // invert old select rect.  if we're selecting by mouse, we
    // always have a selection rect.
    //

    MyInvert(Console,&Console->SelectionRect);

    ReleaseCapture();

    //
    // Mark the cursor position as changed so we'll fire off a win event.
    //

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        ScreenInfo->BufferInfo.TextInfo.CursorMoved = TRUE;
    }
}

VOID
CancelKeySelection(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL JustCursor
    )

/*++

    This routine terminates a key selection.

--*/

{
    PSCREEN_INFORMATION ScreenInfo;

    if (!JustCursor) {

        //
        // turn off selection flag
        //

        Console->Flags &= ~CONSOLE_SELECTING;

        SetWinText(Console,msgMarkMode,FALSE);
    }

    //
    // invert old select rect, if we have one.
    //

    ScreenInfo = Console->CurrentScreenBuffer;
    if (Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) {
        MyInvert(Console,&Console->SelectionRect);
    } else {
        ConsoleHideCursor(ScreenInfo);
    }

    // restore text cursor

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        SetCursorInformation(ScreenInfo,
                             Console->TextCursorSize,
                             Console->TextCursorVisible
                            );
        SetCursorPosition(ScreenInfo,
                          Console->TextCursorPosition,
                          TRUE
                         );
    }
    ConsoleShowCursor(ScreenInfo);
}

VOID
ConvertToMouseSelect(
    IN PCONSOLE_INFORMATION Console,
    IN COORD MousePosition
    )

/*++

    This routine converts to a mouse selection from a key selection.

--*/

{
    Console->SelectionFlags |= CONSOLE_MOUSE_SELECTION | CONSOLE_MOUSE_DOWN;

    //
    // undo key selection
    //

    CancelKeySelection(Console,TRUE);

    Console->SelectionFlags |= CONSOLE_SELECTION_NOT_EMPTY;

    //
    // invert new selection
    //

    InitializeMouseSelection(Console, MousePosition);
    MyInvert(Console,&Console->SelectionRect);

    //
    // update title bar
    //

    SetWinText(Console,msgMarkMode,FALSE);
    SetWinText(Console,msgSelectMode,TRUE);

    //
    // capture mouse movement
    //

    SetCapture(Console->hWnd);
}


VOID
ClearSelection(
    IN PCONSOLE_INFORMATION Console
    )
{
    if (Console->Flags & CONSOLE_SELECTING) {
        if (Console->SelectionFlags & CONSOLE_MOUSE_SELECTION) {
            CancelMouseSelection(Console);
        } else {
            CancelKeySelection(Console,FALSE);
        }
        UnblockWriteConsole(Console, CONSOLE_SELECTING);
    }
}

VOID
StoreSelection(
    IN PCONSOLE_INFORMATION Console
    )

/*++

 StoreSelection - Store selection (if present) into the Clipboard

--*/

{
    PCHAR_INFO Selection,CurCharInfo;
    COORD SourcePoint;
    COORD TargetSize;
    SMALL_RECT TargetRect;
    PWCHAR CurChar,CharBuf;
    HANDLE ClipboardDataHandle;
    SHORT i,j;
    BOOL Success;
    PSCREEN_INFORMATION ScreenInfo;
    BOOL bFalseUnicode;
    BOOL bMungeData;
#if defined(FE_SB)
    COORD TargetSize2;
    PWCHAR TmpClipboardData;
    SMALL_RECT SmallRect2;
    COORD TargetPoint;
    SHORT StringLength;
    WCHAR wchCARRIAGERETURN;
    WCHAR wchLINEFEED;
    int iExtra = 0;
    int iFeReserve = 1;
#endif

    //
    // See if there is a selection to get
    //

    if (!(Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY)) {
        return;
    }

    //
    // read selection rectangle.  clip it first.
    //

    ScreenInfo = Console->CurrentScreenBuffer;
    if (Console->SelectionRect.Left < 0) {
        Console->SelectionRect.Left = 0;
    }
    if (Console->SelectionRect.Top < 0) {
        Console->SelectionRect.Top = 0;
    }
    if (Console->SelectionRect.Right >= ScreenInfo->ScreenBufferSize.X) {
        Console->SelectionRect.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    if (Console->SelectionRect.Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        Console->SelectionRect.Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
    }

    TargetSize.X = WINDOW_SIZE_X(&Console->SelectionRect);
    TargetSize.Y = WINDOW_SIZE_Y(&Console->SelectionRect);
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
#if defined(FE_SB)

        if (CONSOLE_IS_DBCS_CP(Console)) {
            iExtra = 4 ;     // 4 is for DBCS lead or tail extra
            iFeReserve = 2 ; // FE does this for safety
            TmpClipboardData = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),(sizeof(WCHAR) * TargetSize.Y * (TargetSize.X + iExtra) + sizeof(WCHAR)));
            if (TmpClipboardData == NULL) {
                return;
            }
        } else {
            TmpClipboardData = NULL;
        }

        Selection = (PCHAR_INFO)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),sizeof(CHAR_INFO) * (TargetSize.X + iExtra) * TargetSize.Y * iFeReserve);
        if (Selection == NULL)
        {
            if (TmpClipboardData)
                ConsoleHeapFree(TmpClipboardData);
            return;
        }
#else
        Selection = (PCHAR_INFO)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),sizeof(CHAR_INFO) * TargetSize.X * TargetSize.Y);
        if (Selection == NULL)
            return;
#endif

#if defined(FE_SB)
    if (!CONSOLE_IS_DBCS_CP(Console)) {
#endif

#ifdef i386
        if ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) &&
            (Console->Flags & CONSOLE_VDM_REGISTERED)) {
            ReadRegionFromScreenHW(ScreenInfo,
                                   &Console->SelectionRect,
                                   Selection);
            CurCharInfo = Selection;
            for (i=0; i<TargetSize.Y; i++) {
                for (j=0; j<TargetSize.X; j++,CurCharInfo++) {
                    CurCharInfo->Char.UnicodeChar = SB_CharToWcharGlyph(Console->OutputCP, CurCharInfo->Char.AsciiChar);
                }
            }
        } else {
#endif
            SourcePoint.X = Console->SelectionRect.Left;
            SourcePoint.Y = Console->SelectionRect.Top;
            TargetRect.Left = TargetRect.Top = 0;
            TargetRect.Right = (SHORT)(TargetSize.X-1);
            TargetRect.Bottom = (SHORT)(TargetSize.Y-1);
            ReadRectFromScreenBuffer(ScreenInfo,
                                     SourcePoint,
                                     Selection,
                                     TargetSize,
                                     &TargetRect);
#ifdef i386
        }
#endif

        // extra 2 per line is for CRLF, extra 1 is for null
        ClipboardDataHandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                (TargetSize.Y * (TargetSize.X + 2) + 1) * sizeof(WCHAR));
        if (ClipboardDataHandle == NULL) {
            ConsoleHeapFree(Selection);
            return;
        }
#if defined(FE_SB)
    }
#endif

        //
        // convert to clipboard form
        //

#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_CP(Console)) {
            if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                    !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                /*
                 * False Unicode is obtained, so we will have to convert it to
                 * Real Unicode, in which case we can't put CR or LF in now, since
                 * they will be converted into 0x266A and 0x25d9.  Temporarily
                 * mark the CR/LF positions with 0x0000 instead.
                 */
                wchCARRIAGERETURN = 0x0000;
                wchLINEFEED = 0x0000;
            } else {
                wchCARRIAGERETURN = UNICODE_CARRIAGERETURN;
                wchLINEFEED = UNICODE_LINEFEED;
            }

            CurChar = TmpClipboardData;
            bMungeData = (GetKeyState(VK_SHIFT) & KEY_PRESSED) == 0;
            for (i=0;i<TargetSize.Y;i++) {
                PWCHAR pwchLineStart = CurChar;

                SourcePoint.X = Console->SelectionRect.Left;
                SourcePoint.Y = Console->SelectionRect.Top + i;
                TargetSize2.X = TargetSize.X;
                TargetSize2.Y = 1;

                SmallRect2.Left = SourcePoint.X;
                SmallRect2.Top = SourcePoint.Y;
                SmallRect2.Right = SourcePoint.X + TargetSize2.X - 1;
                SmallRect2.Bottom = SourcePoint.Y;
                TargetPoint = SourcePoint;
                StringLength = TargetSize2.X;
                BisectClipbrd(StringLength,TargetPoint,ScreenInfo,&SmallRect2);

                SourcePoint.X = SmallRect2.Left;
                SourcePoint.Y = SmallRect2.Top;
                TargetSize2.X = SmallRect2.Right - SmallRect2.Left + 1;
                TargetSize2.Y = 1;
                TargetRect.Left = TargetRect.Top = TargetRect.Bottom = 0;
                TargetRect.Right = (SHORT)(TargetSize2.X-1);

                ReadRectFromScreenBuffer(ScreenInfo,
                                         SourcePoint,
                                         Selection,
                                         TargetSize2,
                                         &TargetRect);

                CurCharInfo = Selection;
                for (j=0;j<TargetSize2.X;j++,CurCharInfo++) {
                    if (!(CurCharInfo->Attributes & COMMON_LVB_TRAILING_BYTE))
                        *CurChar++ = CurCharInfo->Char.UnicodeChar;
                }
                // trim trailing spaces
                if (bMungeData) {
                    CurChar--;
                    while ((CurChar >= pwchLineStart) && (*CurChar == UNICODE_SPACE))
                        CurChar--;
                    CurChar++;
                    *CurChar++ = wchCARRIAGERETURN;
                    *CurChar++ = wchLINEFEED;
                }
            }
        }
        else {
#endif
        CurCharInfo = Selection;
        CurChar = CharBuf = GlobalLock(ClipboardDataHandle);
        bFalseUnicode = ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(Console->FullScreenFlags & CONSOLE_FULLSCREEN));
        bMungeData = (GetKeyState(VK_SHIFT) & KEY_PRESSED) == 0;
        for (i=0;i<TargetSize.Y;i++) {
            PWCHAR pwchLineStart = CurChar;

            for (j=0;j<TargetSize.X;j++,CurCharInfo++,CurChar++) {
                *CurChar = CurCharInfo->Char.UnicodeChar;
                if (*CurChar == 0) {
                    *CurChar = UNICODE_SPACE;
                }
            }
            // trim trailing spaces
            if (bMungeData) {
                CurChar--;
                while ((CurChar >= pwchLineStart) && (*CurChar == UNICODE_SPACE))
                    CurChar--;
                CurChar++;
            }

            if (bFalseUnicode) {
                FalseUnicodeToRealUnicode(pwchLineStart,
                        (ULONG)(CurChar - pwchLineStart), Console->OutputCP);
            }
            if (bMungeData) {
                *CurChar++ = UNICODE_CARRIAGERETURN;
                *CurChar++ = UNICODE_LINEFEED;
            }
        }
#if defined(FE_SB)
        }
#endif
        if (bMungeData) {
            if (TargetSize.Y)
                CurChar -= 2;   // don't put CRLF on last line
        }
        *CurChar = '\0';    // null terminate

#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_CP(Console)) {
            // extra 4 is for CRLF and DBCS Reserved, extra 1 is for null
            ClipboardDataHandle = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE,
                    (sizeof(WCHAR) * TargetSize.Y * (TargetSize.X+(4*sizeof(WCHAR)))) +
                                                        (1*sizeof(WCHAR)));
            if (ClipboardDataHandle == NULL) {
                ConsoleHeapFree(Selection);
                ConsoleHeapFree(TmpClipboardData);
                return;
            }

            CharBuf = GlobalLock(ClipboardDataHandle);
            RtlCopyMemory(CharBuf,TmpClipboardData,ConsoleHeapSize(TmpClipboardData));
            CurChar = CharBuf + (CurChar - TmpClipboardData);

            if (wchCARRIAGERETURN == 0x0000) {
                /*
                 * We have False Unicode, so we temporarily represented CRLFs with
                 * 0x0000s to avoid undesirable conversions (above).
                 * Convert to Real Unicode and restore real CRLFs.
                 */
                PWCHAR pwch;
                FalseUnicodeToRealUnicode(CharBuf,
                                    (ULONG)(CurChar - CharBuf),
                                    Console->OutputCP
                                   );
                for (pwch = CharBuf; pwch < CurChar; pwch++) {
                    if ((*pwch == 0x0000) && (pwch[1] == 0x0000)) {
                        *pwch++ = UNICODE_CARRIAGERETURN;
                        *pwch = UNICODE_LINEFEED;
                    }
                }
            }
        }
#endif

        GlobalUnlock(ClipboardDataHandle);
#if defined(FE_SB)
        if (TmpClipboardData)
            ConsoleHeapFree(TmpClipboardData);
#endif
        ConsoleHeapFree(Selection);
        Success = OpenClipboard(Console->hWnd);
        if (!Success) {
            GlobalFree(ClipboardDataHandle);
            return;
        }

        Success = EmptyClipboard();
        if (!Success) {
            GlobalFree(ClipboardDataHandle);
            return;
        }

        SetClipboardData(CF_UNICODETEXT,ClipboardDataHandle);
        CloseClipboard();   // Close clipboard
    } else {
        HBITMAP hBitmapTarget, hBitmapOld;
        HDC hDCMem;
        HPALETTE hPaletteOld;
        int Height;

        NtWaitForSingleObject(ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
                              FALSE, NULL);

        hDCMem = CreateCompatibleDC(Console->hDC);
        hBitmapTarget = CreateCompatibleBitmap(Console->hDC,
                                                  TargetSize.X,
                                                  TargetSize.Y);
        if (hBitmapTarget) {
            hBitmapOld = SelectObject(hDCMem, hBitmapTarget);
            if (ScreenInfo->hPalette) {
                hPaletteOld = SelectPalette(hDCMem,
                                             ScreenInfo->hPalette,
                                             FALSE);
            }
            MyInvert(Console,&Console->SelectionRect);

            // if (DIB is a top-down)
            //      ySrc = abs(height) - rect.bottom - 1;
            // else
            //      ySrc = rect.Bottom.
            //
            Height = ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo->bmiHeader.biHeight;

            StretchDIBits(hDCMem, 0, 0,
                        TargetSize.X, TargetSize.Y,
                        Console->SelectionRect.Left + ScreenInfo->Window.Left,
                        (Height < 0) ? -Height - (Console->SelectionRect.Bottom + ScreenInfo->Window.Top) -  1
                        : Console->SelectionRect.Bottom + ScreenInfo->Window.Top,
                        TargetSize.X, TargetSize.Y,
                        ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                        ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
                        ScreenInfo->BufferInfo.GraphicsInfo.dwUsage,
                        SRCCOPY);
            MyInvert(Console,&Console->SelectionRect);
            if (ScreenInfo->hPalette) {
                SelectPalette(hDCMem, hPaletteOld, FALSE);
            }
            SelectObject(hDCMem, hBitmapOld);
            OpenClipboard(Console->hWnd);
            EmptyClipboard();
            SetClipboardData(CF_BITMAP,hBitmapTarget);
            CloseClipboard();
        }
        DeleteDC(hDCMem);
        NtReleaseMutant(ScreenInfo->BufferInfo.GraphicsInfo.hMutex, NULL);
    }

}

VOID
DoCopy(
    IN PCONSOLE_INFORMATION Console
    )
{
    StoreSelection(Console);        // store selection in clipboard
    ClearSelection(Console);        // clear selection in console
}


VOID
ColorSelection(
    IN PCONSOLE_INFORMATION Console,
    IN ULONG                Attr
    )
{
    PSCREEN_INFORMATION ScreenInfo;
    COORD TargetSize, Target;
    DWORD Written;

    ASSERT( Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER);
    ASSERT( Attr <= 0xff);

    //
    // See if there is a selection to get
    //

    if (!(Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY)) {
        return;
    }

    //
    // read selection rectangle.  clip it first.
    //

    ScreenInfo = Console->CurrentScreenBuffer;
    if (Console->SelectionRect.Left < 0) {
        Console->SelectionRect.Left = 0;
    }
    if (Console->SelectionRect.Top < 0) {
        Console->SelectionRect.Top = 0;
    }
    if (Console->SelectionRect.Right >= ScreenInfo->ScreenBufferSize.X) {
        Console->SelectionRect.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    if (Console->SelectionRect.Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        Console->SelectionRect.Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
    }

    TargetSize.X = WINDOW_SIZE_X(&Console->SelectionRect);
    TargetSize.Y = WINDOW_SIZE_Y(&Console->SelectionRect);

    //
    //  Now color the selection a line at a time,  since this seems to be
    //  the only way to do it?
    //

    Target.X = Console->SelectionRect.Left;
    Target.Y = Console->SelectionRect.Top;

    for ( ; (Target.Y < Console->SelectionRect.Top + TargetSize.Y); ++Target.Y)  {

        Written = TargetSize.X;

        (VOID)FillOutput(  Console->CurrentScreenBuffer,
                           (USHORT)Attr,
                           Target,
                           CONSOLE_ATTRIBUTE,
                           &Written);
    }

    ClearSelection(Console);        // clear selection in console
}


/*++

Routine Description:

    This routine pastes given Unicode string into the console window.

Arguments:
    Console  -   Pointer to CONSOLE_INFORMATION structure
    pwStr    -   Unicode string that is pasted to the console window
    DataSize -   Size of the Unicode String in characters


Return Value:
    None


--*/


VOID
DoStringPaste(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR pwStr,
    IN UINT DataSize
    )
{
    PINPUT_RECORD StringData,CurRecord;
    PWCHAR CurChar;
    WCHAR Char;
    DWORD i;
    DWORD ChunkSize,j;
    ULONG EventsWritten;


    if(!pwStr) {
       return;
    }

    if (DataSize > DATA_CHUNK_SIZE) {
        ChunkSize = DATA_CHUNK_SIZE;
    } else {
        ChunkSize = DataSize;
    }

    //
    // allocate space to copy data.
    //

    StringData = (PINPUT_RECORD)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),ChunkSize*sizeof(INPUT_RECORD)*8); // 8 is maximum number of events per char
    if (StringData == NULL) {
        return;
    }

    //
    // transfer data to the input buffer in chunks
    //

    CurChar = pwStr;   // LATER remove this
    for (j = 0; j < DataSize; j += ChunkSize) {
        if (ChunkSize > DataSize - j) {
            ChunkSize = DataSize - j;
        }
        CurRecord = StringData;
        for (i = 0, EventsWritten = 0; i < ChunkSize; i++) {
            // filter out LF if not first char and preceded by CR
            Char = *CurChar;
            if (Char != UNICODE_LINEFEED || (i==0 && j==0) || (*(CurChar-1)) != UNICODE_CARRIAGERETURN) {
                SHORT KeyState;
                BYTE KeyFlags;
                BOOL AltGr=FALSE;
                BOOL Shift=FALSE;

                if (Char == 0) {
                    j = DataSize;
                    break;
                }

                KeyState = VkKeyScan(Char);
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_ENABLED() &&
                    (KeyState == -1)) {
                    WORD CharType;
                    //
                    // Determine DBCS character because these character doesn't know by VkKeyScan.
                    // GetStringTypeW(CT_CTYPE3) & C3_ALPHA can determine all linguistic characters.
                    // However, this is not include symbolic character for DBCS.
                    // IsConsoleFullWidth can help for DBCS symbolic character.
                    //
                    GetStringTypeW(CT_CTYPE3,&Char,1,&CharType);
                    if ((CharType & C3_ALPHA) ||
                        IsConsoleFullWidth(Console->hDC,Console->OutputCP,Char)) {
                        KeyState = 0;
 