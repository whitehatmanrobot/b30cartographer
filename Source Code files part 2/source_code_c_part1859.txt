**Public*Routine******************************\
* BOOL PFEOBJ::bFilterNotEnum()
*
* Used by bFilterOut() in GreEnumOpen(). It checks whether the pfe should
* be filtered out because it is either an embedded font or it is loaded to
* the system with FR_NOT_ENUM bit set.
*
* Returns:
*   TRUE if embedded or FR_NOT_ENUM set, FALSE otherwise.
*
* History:
*
*  12-Jun-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/
BOOL PFEOBJ::bFilterNotEnum()
{
    PFFOBJ  pffo(pPFF());
    ASSERTGDI(pffo.bValid(), "win32k!PFEOBJ::bFilterEmbPvt(): invalid PPFF\n");
    PVTDATA *pPvtData;
    BOOL  bRet = TRUE;

    if (pffo.bInPrivatePFT())
    {
        // Look for a PvtData block for the current process

        if ((pPvtData = pffo.pPvtDataMatch()) && (pPvtData->cNotEnum == 0))
        {
            bRet = FALSE;
        }
    }

    // public fonts, filter out FR_NOT_ENUM only

    else if (pffo.cLoaded())
    {
        bRet = FALSE;
    }

    return bRet;
}

/***********************Public*Routine***********************\
* BOOL PFEOBJ::bPrivate()
*
* Determine whether the pfe is in private PFT table
*
* History:
*
*  16-April-1997   -by- Xudong Wu [TessieW]
* Wrote it.
*************************************************************/
BOOL PFEOBJ::bPrivate()
{
    return (ppfe->pPFF->pPFT == gpPFTPrivate);
}


/******************************Public*Routine******************************\
* BOOL PFEOBJ::bEmbedOk()
*
* Determine if the font is added as embedded by the current process
*
* Returns:
*   TRUE   if the font is added by the current process as embedded font
*   FALSE  otherwise.
*
* History:
*
*  24-Sept-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/
BOOL PFEOBJ::bEmbedOk()
{
    PVTDATA *pPvtData;

    PFFOBJ  pffo(pPFF());
    ASSERTGDI(pffo.bValid(), "win32k!PFEOBJ::bEmbedOk(): invalid PPFF\n");
    ASSERTGDI(pffo.bInPrivatePFT(), "win32k!PFEOBJ::bEmbedOk(): pfe not in private PFT\n");

    // embedded font added by the current process

    if ((pPvtData = pffo.pPvtDataMatch()) && (pPvtData->fl & (FRW_EMB_TID | FRW_EMB_PID)))
    {
        return TRUE;
    }

    return FALSE;
}


/******************************Public*Routine******************************\
* BOOL PFEOBJ::bEmbPvtOk()
*
* Determine whether the current process has right to mapping this font
*
* Returns:
*   TRUE    pfe in public PFT or
*           font has been loaded into Private PFT by the current process
*
*   FALSE   otherwise
*
* History:
*
*  24-Sept-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/
BOOL PFEOBJ::bEmbPvtOk()
{
    PFFOBJ  pffo(pPFF());
    ASSERTGDI(pffo.bValid(), "win32k!PFEOBJ::bEmbPvtOk(): invalid PPFF\n");

    // can't find the current process ID in the PvtData link list

    if (pffo.bInPrivatePFT() && (pffo.pPvtDataMatch() == NULL))
    {
        return FALSE;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* HPFEC   PFEOBJ::hpfecGet()
*
* Get the handle of PFE collect, a new object to reduce the consumption of object handle
*
* Returns:
*   Hanlde of PFEC object
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

HPFEC   PFEOBJ::hpfecGet()
{
    PFFOBJ pffo(ppfe->pPFF);

    ASSERTGDI(((HPFEC)pffo.pfec()->hGet()) != HPFEC_INVALID, " PFEOBJ::hpfecGet error\n");
    return((HPFEC)pffo.pfec()->hGet());
}

/******************************Public*Routine******************************\
* BOOL PFEOBJ::bFilteredOut(EFFILTER_INFO *peffi)
*
* Determine if this PFE should be rejected from the enumeration.  Various
* filtering parameters are passed in via the EFFILTER_INFO structure.
*
* Returns:
*   TRUE if font should be rejected, FALSE otherwise.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFEOBJ::bFilteredOut(EFFILTER_INFO *peffi)
{
    IFIOBJ ifio(pifi());

// Always filter out "dead" (fonts waiting to be deleted) fonts and "ghost"
// fonts.

    if ( bDead() || ifio.bGhostFont() )
        return TRUE;

#ifdef FE_SB
// Always filter out fonts that have been loaded as EUDC fonts.

    if( bEUDC() )
        return TRUE;
#endif

// Raster font filtering.

    if (peffi->bRasterFilter && ifio.bBitmap())
        return TRUE;

// TrueType font filtering.  The flag is somewhat of a misnomer as it
// is intended to exclude TrueType, even though the flag is named
// bNonTrueTypeFilter.

    if (peffi->bNonTrueTypeFilter && ifio.bTrueType())
        return(TRUE);

// Non-TrueType font filtering.  The flag is somewhat of a misnomer as it
// is intended to exclude non-TrueType, even though the flag is named
// bTrueTypeFilter.

    if (peffi->bTrueTypeFilter && !ifio.bTrueType())
        return TRUE;

// Aspect ratio filtering.  If an engine bitmap font, we will filter out
// unsuitable resolutions.

    if ( peffi->bAspectFilter
         && (!bDeviceFont())
         && ifio.bBitmap()
         && ( (peffi->ptlDeviceAspect.x != ifio.pptlAspect()->x)
               || (peffi->ptlDeviceAspect.y != ifio.pptlAspect()->y) ) )
        return TRUE;

// GACF_TTIGNORERASTERDUPE compatibility flag filtering.
// If any raster fonts exist in the same list as a TrueType font, then
// they should be excluded.

    if ( peffi->bTrueTypeDupeFilter
         && peffi->cTrueType
         && ifio.bBitmap())
        return TRUE;

// Filter out embedded fonts or the fonts with FR_NOT_ENUM bit set.

    if (bFilterNotEnum())
        return TRUE;

// In the case of a Generic text driver we must filter out all engine fonts

    if( ( peffi->bEngineFilter ) && !bDeviceFont() )
    {
        return(TRUE);
    }

// if this is a remote/memory font we don't want to enumerate it

    if( ppfe->flPFE & (PFE_REMOTEFONT | PFE_MEMORYFONT) )
    {
        return(TRUE);
    }

// finally check out if the font should be eliminated from the
// enumeration because it does not contain the charset requested:

    if (peffi->lfCharSetFilter != DEFAULT_CHARSET)
    {
    // the specific charset has been requested, let us see if the font
    // in question supports it:

        BYTE jCharSet = jMapCharset((BYTE)peffi->lfCharSetFilter, *this);

        if (jCharSet != (BYTE)peffi->lfCharSetFilter)
            return TRUE; // does not support it, filter this font out.
    }

// Passed all tests.

    return FALSE;
}


 #if DBG

/******************************Public*Routine******************************\
* VOID PFEOBJ::vDump ()
*
* Debugging code.
*
* History:
*  25-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFEOBJ::vPrint()
{
    IFIOBJ ifio(pifi());

    DbgPrint("\nContents of PFE, PPFE = 0x%p\n", ppfeGet());
    DbgPrint("pPFF   = 0x%p\n", ppfe->pPFF);
    DbgPrint("iFont  = 0x%lx\n", ppfe->iFont);

    DbgPrint("lfHeight          = 0x%x\n",  ifio.lfHeight());
    DbgPrint(
        "Family Name       = %ws\n",
        ifio.pwszFamilyName()
        );
    DbgPrint(
        "Face Name         = %ws\n",
        ifio.pwszFaceName()
        );
    DbgPrint(
        "Unique Name       = %s\n\n",
        ifio.pwszUniqueName()
        );
}


/******************************Public*Routine******************************\
* VOID PFEOBJ::vDumpIFI ()
*
* Debugging code.  Prints PFE header and IFI metrics.
*
\**************************************************************************/

VOID PFEOBJ::vPrintAll()
{
    DbgPrint("\nContents of PFE, PPFE = 0x%p\n", ppfeGet());
    DbgPrint("pPFF   = 0x%p\n", ppfe->pPFF);
    DbgPrint("iFont  = 0x%p\n", ppfe->iFont);
    DbgPrint("IFI Metrics\n");
     vPrintIFIMETRICS(ppfe->pifi);
    DbgPrint("\n");
}
#endif

/******************************Public*Routine******************************\
* EFSMEMOBJ::EFSMEMOBJ(COUNT cefe)
*
* Constructor for font enumeration state (EFSTATE) memory object.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

EFSMEMOBJ::EFSMEMOBJ(COUNT cefe, ULONG iEnumType_)
{
    fs = 0;
    pefs = (PEFSTATE) HmgAlloc((offsetof(EFSTATE, aefe) + cefe * sizeof(EFENTRY)),
                               EFSTATE_TYPE,
                               HMGR_ALLOC_LOCK);

    if (pefs != PEFSTATENULL)
    {
        vInit(cefe, iEnumType_);
    }
}

/******************************Public*Routine******************************\
* EFSMEMOBJ::~EFSMEMOBJ()
*
* Destructor for font enumeration state (EFSTATE) memory object.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

EFSMEMOBJ::~EFSMEMOBJ()
{
// If object pointer not null, try to free the object's memory.

    if (pefs != PEFSTATENULL)
    {
        if (fs & EFSMO_KEEPIT)
        {
            DEC_EXCLUSIVE_REF_CNT(pefs);
        }
        else
        {
#if DBG
            if (pefs->cExclusiveLock != 1)
            {
               RIP("Not 1 EFSMEMOBJ\n");
            }
#endif

            HmgFree((HOBJ) pefs->hGet());
        }

        pefs = NULL;
    }
}

#define EFS_QUANTUM     16

/******************************Public*Routine******************************\
* BOOL EFSOBJ::bGrow
*
* Expand the EFENTRY table by the quantum amount.
*
* Returns:
*   TRUE if successful, FALSE if failed.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL EFSOBJ::bGrow (COUNT cefeMinIncrement)
{
    COUNT cefe;
    BOOL bRet = FALSE;

// Allocate a new EFSTATE bigger by the quantum amount.

    cefe = (COUNT) (pefs->pefeBufferEnd - pefs->aefe);

    if (cefeMinIncrement < EFS_QUANTUM)
        cefeMinIncrement = EFS_QUANTUM;
    cefe += cefeMinIncrement;

    EFSMEMOBJ efsmo(cefe, this->pefs->iEnumType);

// Validate new EFSTATE.

    if (efsmo.bValid())
    {
    // Copy the enumeration table.

        efsmo.vXerox(pefs);

    // Swap the EFSTATEs.

        if (HmgSwapHandleContents((HOBJ) hefs(),0,(HOBJ) efsmo.hefs(),0,EFSTATE_TYPE))
        {
        // swap pointers

            PEFSTATE pefsTmp = pefs;
            pefs = efsmo.pefs;
            efsmo.pefs = pefsTmp;               // destructor will delete old PFT
            bRet = TRUE;
        }
        else
            WARNING("gdisrv!bGrowEFSOBJ(): handle swap failed\n");
    }
    else
        WARNING("bGrowEFSOBJ failed alloc\n");

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL EFSOBJ::bAdd                                                        *
*                                                                          *
* Add a new EFENTRY to the table with the HPFE and ENUMFONTSTYLE.          *
*                                                                          *
* Returns:                                                                 *
*   FALSE if an error occurs, TRUE otherwise.                              *
*                                                                          *
* History:                                                                 *
*  07-Aug-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL EFSOBJ::bAdd(PFE *ppfe, ENUMFONTSTYLE efsty, FLONG fl, ULONG lfCharSetFilter)
{
// Check if the buffer needs to be expanded.

    COUNT cefeMinIncrement = 1; // will always enumerate at least one pfe

// if EnumFontFamilies is called, will enumerate the font under cAlt more names

    if (!(fl & FL_ENUMFAMILIESEX))
        cefeMinIncrement += ppfe->cAlt;

// if EnumFontFamiliesEx is called, and this font supports multiple charsets,
// this font will be enumerated no more than MAXCHARSETS times.

    if
    (
        (fl & FL_ENUMFAMILIESEX)             &&
        (lfCharSetFilter == DEFAULT_CHARSET) &&
        ppfe->pifi->dpCharSets
    )
    {
        cefeMinIncrement = MAXCHARSETS;
    }

    if ((pefs->pefeDataEnd + cefeMinIncrement) >= pefs->pefeBufferEnd)
    {
        if (!bGrow(cefeMinIncrement))
        {
        // Error code will be saved for us.

            WARNING("gdisrv!EFSOBJ__bAdd: cannot grow enumeration table\n");
            return FALSE;
        }
    }

// Add the new data and increment the data pointer.

    PFEOBJ pfeo(ppfe);

    HPFEC hpfec = pfeo.hpfecGet();
    ULONG iFont = ppfe->iFont;
    pefs->pefeDataEnd->hpfec  = hpfec;
    pefs->pefeDataEnd->iFont = iFont;

    pefs->pefeDataEnd->efsty = efsty;
    pefs->pefeDataEnd->fjOverride = 0; // do not override

    if (fl & FL_ENUMFAMILIESEX)
        pefs->pefeDataEnd->fjOverride |= FJ_CHARSETOVERRIDE;

    pefs->pefeDataEnd->jCharSetOverride = (BYTE)lfCharSetFilter;
    pefs->pefeDataEnd       += 1;
    pefs->cjEfdwTotal += ppfe->cjEfdwPFE;

// now check if called from EnumFonts or EnumFontFamilies so that the
// names from the
// [FontSubstitutes] section in the registry also need to be enumerated

    if (!(fl & FL_ENUMFAMILIESEX) && ppfe->cAlt) // alt names have to be enumerated too
    {
        for (ULONG i = 0; i < ppfe->cAlt; i++)
        {
        // the same hpfe, style etc. all the time, only lie about the name and charset

            pefs->pefeDataEnd->hpfec  = hpfec;
            pefs->pefeDataEnd->iFont = iFont;
            pefs->pefeDataEnd->efsty = efsty;
            pefs->pefeDataEnd->fjOverride = (FJ_FAMILYOVERRIDE | FJ_CHARSETOVERRIDE);  // do override
            pefs->pefeDataEnd->iOverride = ppfe->aiFamilyName[i];
            pefs->pefeDataEnd->jCharSetOverride =
                gpfsTable[pefs->pefeDataEnd->iOverride].fcsFace.jCharSet;
            pefs->pefeDataEnd       += 1;
            pefs->cjEfdwTotal += ppfe->cjEfdwPFE;
        }
    }

// now see if this is called from EnumFontFamiliesEx

    if ((fl & FL_ENUMFAMILIESEX) && (lfCharSetFilter == DEFAULT_CHARSET))
    {
    // The font needs to be enumerated once for every charset it supports

        if (ppfe->pifi->dpCharSets)
        {
            BYTE *ajCharSets = (BYTE*)ppfe->pifi + ppfe->pifi->dpCharSets;
            BYTE *ajCharSetsEnd = ajCharSets + MAXCHARSETS;

        // first fix up the one entry we just filled above

            (pefs->pefeDataEnd-1)->jCharSetOverride = ajCharSets[0];

        // this is from win95-J sources:

#define FEOEM_CHARSET 254

            for
            (
                BYTE *pjCharSets = ajCharSets + 1; // skip the first one, used already
                (*pjCharSets != DEFAULT_CHARSET) &&
                (*pjCharSets != OEM_CHARSET)     &&
                (*pjCharSets != FEOEM_CHARSET)   &&
                (pjCharSets < ajCharSetsEnd)     ;
                pjCharSets++
            )
            {
            // the same hpfe, style etc. all the time, only lie about the name and charset

                pefs->pefeDataEnd->hpfec  = hpfec;
                pefs->pefeDataEnd->iFont = iFont;
                pefs->pefeDataEnd->efsty = efsty;
                pefs->pefeDataEnd->fjOverride = FJ_CHARSETOVERRIDE;
                pefs->pefeDataEnd->iOverride = 0;
                pefs->pefeDataEnd->jCharSetOverride = *pjCharSets;
                pefs->pefeDataEnd       += 1;
                pefs->cjEfdwTotal += ppfe->cjEfdwPFE;
            }
        }
        else //  fix up the one entry we just filled above
        {
            (pefs->pefeDataEnd-1)->jCharSetOverride = ppfe->pifi->jWinCharSet;
        }
    }

// Success.

    return TRUE;
}



/******************************Public*Routine******************************\
* VOID EFSOBJ::vDelete ()
*
* Destroy the font enumeration state (EFSTATE) memory object.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID EFSOBJ::vDeleteEFSOBJ()
{
    HmgFree((HOBJ) pefs->hGet());
    pefs = PEFSTATENULL;
}


/******************************Member*Function*****************************\
* VOID EFSMEMOBJ::vInit
*
* Initialize the EFSTATE object.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID EFSMEMOBJ::vInit(COUNT cefe, ULONG iEnumType_)
{
// HPFE array empty, so initialize all pointer to the beginning of the array.

    pefs->pefeDataEnd  = pefs->aefe;
    pefs->pefeEnumNext = pefs->aefe;

// Except for this one.  Set this one to the end of the buffer.

    pefs->pefeBufferEnd = &pefs->aefe[cefe];

// Initialize the alternate name to NULL.

    pefs->pfsubOverride = NULL;

// init the enum type:

    pefs->iEnumType = iEnumType_;

// empty for now, total enumeration data size is zero

    pefs->cjEfdwTotal = 0;

// We don't need to bother with initializing the array.
}

/******************************Public*Routine******************************\
* VOID EFSMEMOBJ::vXerox(EFSTATE *pefeSrc)
*
* Copy the EFENTRYs from the source EFSTATE's table into this EFSTATE's table.
* The internal pointers will be updated to be consistent with the data.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID EFSMEMOBJ::vXerox(EFSTATE *pefsSrc)
{
//
// Compute size of the table.
//

// Sundown truncation
    ASSERT4GB ((ULONGLONG)(pefs->pefeDataEnd - pefs->aefe));
    COUNT cefe = (COUNT)(pefsSrc->pefeDataEnd - pefsSrc->aefe);

    ASSERTGDI (
        cefe >= (COUNT)(pefs->pefeDataEnd - pefs->aefe),
        "gdisrv!vXeroxEFSMEMOBJ(): table to small\n"
        );

//
// Copy entries.
//
    RtlCopyMemory((PVOID) pefs->aefe, (PVOID) pefsSrc->aefe, (SIZE_T) cefe * sizeof(EFENTRY));

// Fixup the data pointer and size of enumeration data

    pefs->pefeDataEnd = pefs->aefe + cefe;
    pefs->cjEfdwTotal = pefsSrc->cjEfdwTotal;

// iEnumType has been set at the vInit time, it does not have to be reset now.
// Therefore we are done.


}


/******************************Public*Routine******************************\
* bSetEFSTATEOwner
*
* Set the owner of the EFSTATE
*
* if the owner is set to OBJECTOWNER_NONE, this EFSTATE will not be useable
* until bSetEFSTATEOwner is called to explicitly give the lfnt to someone else.
*
* History:
*  07-Aug-1992 by Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
bSetEFSTATEOwner(
    HEFS hefs,
    W32PID lPid)
{
    if (lPid == OBJECT_OWNER_CURRENT)
    {
        lPid = W32GetCurrentPID();
    }

    return HmgSetOwner((HOBJ) hefs, lPid, EFSTATE_TYPE);
}



/******************************Public*Routine******************************\
* BOOL bSetFontXform
*
* Sets the FD_XFORM such that it can be used to realize the physical font
* with the dimensions specified in the wish list coordinates).  The
* World to Device xform (with translations removed) is also returned.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  Tue 27-Oct-1992 23:18:39 by Kirk Olynyk [kirko]
* Moved it from PFEOBJ.CXX
*  19-Sep-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
PFEOBJ::bSetFontXform (
    XDCOBJ       &dco,               // realize for this device
    LOGFONTW   *pelfw,             // wish list (in logical coords)
    PFD_XFORM   pfd_xf,             // font transform
    FLONG       fl,
    FLONG       flSim,
    POINTL* const pptlSim,
    IFIOBJ&     ifio,
    BOOL        bIsLinkedFont  // TRUE if the font is linked, FALSE otherwise
    )
{
       BOOL bRet;

       EXFORMOBJ xo(dco, WORLD_TO_DEVICE); // synchronize the transformation

        if(dco.pdc->iGraphicsMode() == GM_COMPATIBLE)
        {
            bRet = bGetNtoD_Win31(
                    pfd_xf,
                    pelfw,
                    ifio,
                    (DCOBJ *)&dco,
                    fl,
                    pptlSim,
                    bIsLinkedFont
                    );
        }
        else // GM_ADVANCED
        {
            bRet = bGetNtoD(
                    pfd_xf,
                    pelfw,
                    ifio,
                    (DCOBJ *)&dco,
                    pptlSim
                    );
        }

        if (!bRet)
        {
            WARNING(
                "gdisrv!bSetFontXformPFEOBJ(): failed to get Notional to World xform\n"
                );
            return FALSE;
        }

    //
    // The next line two lines of code flips the sign of the Notional y-coordinates
    // The effect is that the XFORMOBJ passed over the DDI makes the assumption that
    // Notional space is such that the y-coordinate increases towards the bottom.
    // This is opposite to the usual conventions of notional space and the font
    // driver writers must be made aware of this historical anomaly.
    //
        NEGATE_IEEE_FLOAT(pfd_xf->eYX);
        NEGATE_IEEE_FLOAT(pfd_xf->eYY);

    //
    // If the font can be scaled isotropicslly only then we make sure that we send
    // to the font driver isotropic transformations.
    //
    // If a device has set the TA_CR_90 bit, then it is possible
    // that we will send to the driver a transformation that is equivalent to an isotropic
    // transformation rotated by a multiple of 90 degress. This is the reason for the
    // second line of this transformation.
    //
        if (ifio.bIsotropicScalingOnly())
        {
            *(LONG*)&(pfd_xf->eXX) = *(LONG*)&(pfd_xf->eYY);
            *(LONG*)&(pfd_xf->eXY) = *(LONG*)&(pfd_xf->eYX);
            NEGATE_IEEE_FLOAT(pfd_xf->eXY);
        }

    return (TRUE);
}

/******************************Public*Routine******************************\
* PFE * PFECOBJ::GetPFE(ULONG iFont)
*
* Get PFE from PFE collect, a new object to reduce the consumption of object handle
*
* Returns:
*   memory pointer of PFE
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

PFE * PFECOBJ::GetPFE(ULONG iFont)
{
    PFE * ppfe = NULL;

    if (ppfec)
    {
        ASSERTGDI(ppfec->pvPFE, "PFECOBJ::GetPFE ppfset->pvPFE is null \n");
        ppfe = (PFE *) ((PBYTE) ppfec->pvPFE + ((iFont - 1) * ppfec->cjPFE));
    }

    return ppfe;
}

/******************************Public*Routine******************************\
* HPFEC  PFECOBJ::GetHPFEC()
*
* Get handle of PFEC from PFE collect, a new object to reduce the consumption of object handle
*
* Returns:
*   Handle of PFEC
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

HPFEC  PFECOBJ::GetHPFEC()
{
    ASSERTGDI(ppfec, "PFECOBJ::GetHPFEC ppfec is NULL \n");

    return((HPFEC) ppfec->hGet());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pdevobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pdevobj.cxx
*
* Non-inline methods of PDEVOBJ objects.
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern DRVFN gadrvfnPanning[];
extern ULONG gcdrvfnPanning;

//
// This flag is TRUE if the default GUI stock font is partially intialized.
// During stock font initialization there is no display driver and therefore
// we do not have one of the parameters (vertical DPI) needed to compute
// the font height.  Therefore, we do it when the first display driver is
// initialized.
//

extern BOOL gbFinishDefGUIFontInit;

//
// This is size of DirectDraw context which we keep in PDEV.
//

extern DWORD gdwDirectDrawContext;

// Use this as the default height if LOGFONTs provided by DEVINFO do not
// specify.

#define DEFAULT_POINT_SIZE          12L
#define DEFAULT_DPI                 72L

#if ((HT_PATSIZE_2x2         != HTPAT_SIZE_2x2)             || \
     (HT_PATSIZE_2x2_M       != HTPAT_SIZE_2x2_M)           || \
     (HT_PATSIZE_4x4         != HTPAT_SIZE_4x4)             || \
     (HT_PATSIZE_4x4_M       != HTPAT_SIZE_4x4_M)           || \
     (HT_PATSIZE_6x6         != HTPAT_SIZE_6x6)             || \
     (HT_PATSIZE_6x6_M       != HTPAT_SIZE_6x6_M)           || \
     (HT_PATSIZE_8x8         != HTPAT_SIZE_8x8)             || \
     (HT_PATSIZE_8x8_M       != HTPAT_SIZE_8x8_M)           || \
     (HT_PATSIZE_10x10       != HTPAT_SIZE_10x10)           || \
     (HT_PATSIZE_10x10_M     != HTPAT_SIZE_10x10_M)         || \
     (HT_PATSIZE_12x12       != HTPAT_SIZE_12x12)           || \
     (HT_PATSIZE_12x12_M     != HTPAT_SIZE_12x12_M)         || \
     (HT_PATSIZE_14x14       != HTPAT_SIZE_14x14)           || \
     (HT_PATSIZE_14x14_M     != HTPAT_SIZE_14x14_M)         || \
     (HT_PATSIZE_16x16       != HTPAT_SIZE_16x16)           || \
     (HT_PATSIZE_16x16_M     != HTPAT_SIZE_16x16_M)         || \
     (HT_PATSIZE_SUPERCELL   != HTPAT_SIZE_SUPERCELL)       || \
     (HT_PATSIZE_SUPERCELL_M != HTPAT_SIZE_SUPERCELL_M)     || \
     (HT_PATSIZE_USER        != HTPAT_SIZE_USER))
#error * HT_PATSIZE different in winddi.h and ht.h *
#endif

#if ((HT_FLAG_SQUARE_DEVICE_PEL != HIF_SQUARE_DEVICE_PEL) || \
     (HT_FLAG_HAS_BLACK_DYE     != HIF_HAS_BLACK_DYE)     || \
     (HT_FLAG_ADDITIVE_PRIMS    != HIF_ADDITIVE_PRIMS))
#error * HT_FLAG different in winddi.h and ht.h *
#endif

//
// Global linked list of all PDEVs in the system.
//

extern "C"
{
    extern HFASTMUTEX ghfmMemory;
}


PPDEV gppdevList = NULL;
PPDEV gppdevTrueType = NULL;
PPDEV gppdevATMFD = NULL;

VOID
vDeleteBitmapClone(
    SURFOBJ *pso
    );

/******************************Member*Function*****************************\
* PDEVOBJ::bMakeSurface ()
*
* Asks the device driver to create a surface for the PDEV.  This function
* can be called even if the PDEV already has a surface.
*
\**************************************************************************/

BOOL PDEVOBJ::bMakeSurface()
{
    TRACE_INIT(("PDEVOBJ::bMakeSurface: ENTERING\n"));

    BOOL bRet;

    if (ppdev->pSurface != NULL)
        return(TRUE);

    HSURF hTemp = (HSURF) 0;

    // Ask the driver for a surface.

    PDEVOBJ po((HDEV)ppdev);

    GreEnterMonitoredSection(ppdev, WD_DEVLOCK);
    hTemp = (*PPFNDRV(po,EnableSurface))(ppdev->dhpdev);
    GreExitMonitoredSection(ppdev, WD_DEVLOCK);

    if (hTemp == (HSURF) 0)
    {
        WARNING("EnableSurface on device return hsurf 0\n");
        return(FALSE);
    }

    SURFREF sr(hTemp);
    ASSERTGDI(sr.bValid(),"Bad surface for device");

// Mark this as a device surface.

    sr.ps->vPDEVSurface();
    sr.vKeepIt();
    ppdev->pSurface = sr.ps;

// For 1.0 compatibility, set the pSurface iFormat to iDitherFormat.  This can
// be changed to an ASSERT if we no longer wants to support NT 1.0 drivers,
// which has BMF_DEVICE in the iFormat for device surfaces.

    if (sr.ps->iFormat() == BMF_DEVICE)
    {
        sr.ps->iFormat(ppdev->devinfo.iDitherFormat);
        ASSERTGDI(ppdev->devinfo.iDitherFormat != BMF_DEVICE,
            "ERROR iformat is hosed\n");
    }

// Put the PDEV's palette in the main device surface.
// Reference count the palette, it has a new user.

    ppdev->pSurface->ppal(ppdev->ppalSurf);

// If this is surface for layered driver, mark it as mirrored surface.

    if (flGraphicsCaps() & GCAPS_LAYERED)
    {
        sr.ps->vSetMirror();
    }

    HmgShareLock((HOBJ) ppdev->ppalSurf->hGet(), PAL_TYPE);

    TRACE_INIT(("PDEVOBJ::bMakeSurface: SUCCESS\n"));

// We move the mouse point off-screen in order to set an initial position and
// to fix a common driver bug, which is to show uninitialized garbage until 
// the first DrvSetPointerShape call occurs.

    if (bDisplayPDEV())
    {
        GreMovePointer(po.hdev(), -1, -1, MP_PROCEDURAL);
    }

// Enable PDEV components.

    bRet = DxDdEnableDirectDraw(po.hdev(),TRUE);

// Filter the driver hooks after DirectDraw has loaded but before we
// enable sprites, so that the filter can filter DirectX calls and
// the sprite code gets the filtered result.

    vFilterDriverHooks();

    bRet &= bSpEnableSprites(po.hdev());

    vEnableSynchronize(po.hdev());

    vNotify(DN_DRAWING_BEGIN, NULL);

    return(bRet);
}

/******************************Member*Function*****************************\
* PDEVOBJ::bEnableHalftone(pca)
*
*  Creates and initializes a device halftone info.  The space is allocated
*  by the halftone.dll with heapCreate() and heapAlloc() calls.  All
*  the halftone resources are managed by the halftone.dll.
*
* History:
*  07-Nov-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

COLORADJUSTMENT gcaDefault =
{
    sizeof(COLORADJUSTMENT),    // WORD          caSize
    0,                          // WORD          caFlags
    ILLUMINANT_DEFAULT,         // WORD          caIlluminantIndex
    HT_DEF_RGB_GAMMA,           // WORD          caRedPowerGamma
    HT_DEF_RGB_GAMMA,           // WORD          caGreenPowerGamma
    HT_DEF_RGB_GAMMA,           // WORD          caBluePowerGamma
    REFERENCE_BLACK_DEFAULT,    // WORD          caReferenceBlack
    REFERENCE_WHITE_DEFAULT,    // WORD          caReferenceWhite
    CONTRAST_ADJ_DEFAULT,       // SHORT         caContrast
    BRIGHTNESS_ADJ_DEFAULT,     // SHORT         caBrightness
    COLORFULNESS_ADJ_DEFAULT,   // SHORT         caColorfulness
    REDGREENTINT_ADJ_DEFAULT,   // SHORT         caRedGreenTint
};

BOOL PDEVOBJ::bEnableHalftone(PCOLORADJUSTMENT pca)
{
    ASSERTGDI(pDevHTInfo() == NULL, "bEnableHalftone: pDevHTInfo not null\n");

    //
    // Create a halftone palette based on the format specified in GDIINFO.
    //

    PALMEMOBJ palHT;
    if (!palHT.bCreateHTPalette(GdiInfo()->ulHTOutputFormat, GdiInfo()))
        return(FALSE);

    //
    // Create the device halftone info.
    //

    HTINITINFO      htInitInfo;
    HALFTONEPATTERN HTPat;

    htInitInfo.Version        = HTINITINFO_VERSION;
    htInitInfo.Flags          = (WORD)(ppdev->GdiInfo.flHTFlags & 0xFFFF);
    htInitInfo.CMYBitMask8BPP = (BYTE)((ppdev->GdiInfo.flHTFlags &
                                        HT_FLAG_8BPP_CMY332_MASK) >> 24);
    htInitInfo.bReserved = 0;

    if (ppdev->GdiInfo.ulHTPatternSize <= HTPAT_SIZE_MAX_INDEX)
        htInitInfo.HTPatternIndex = (BYTE)ppdev->GdiInfo.ulHTPatternSize;
    else
        htInitInfo.HTPatternIndex = HTPAT_SIZE_DEFAULT;

    PCOLORINFO      pci = &GdiInfo()->ciDevice;
    htInitInfo.DevicePowerGamma = (UDECI4)((pci->RedGamma + pci->GreenGamma +
                                            pci->BlueGamma) / 3);
    htInitInfo.DeviceRGamma = (UDECI4)pci->RedGamma;
    htInitInfo.DeviceGGamma = (UDECI4)pci->GreenGamma;
    htInitInfo.DeviceBGamma = (UDECI4)pci->BlueGamma;

    htInitInfo.HTCallBackFunction = NULL;
    htInitInfo.pHalftonePattern = NULL;
    htInitInfo.pInputRGBInfo = NULL;

    if (htInitInfo.HTPatternIndex == HTPAT_SIZE_USER) {

        if ((ppdev->GdiInfo.cxHTPat >= HT_USERPAT_CX_MIN)   &&
            (ppdev->GdiInfo.cxHTPat <= HT_USERPAT_CX_MAX)   &&
            (ppdev->GdiInfo.cyHTPat >= HT_USERPAT_CY_MIN)   &&
            (ppdev->GdiInfo.cyHTPat <= HT_USERPAT_CY_MAX)   &&
            (ppdev->GdiInfo.pHTPatA)                        &&
            (ppdev->GdiInfo.pHTPatB)                        &&
            (ppdev->GdiInfo.pHTPatC)) {

            HTPat.cbSize  = sizeof(HALFTONEPATTERN);
            HTPat.Flags   = 0;
            HTPat.Width   = (WORD)ppdev->GdiInfo.cxHTPat;
            HTPat.Height  = (WORD)ppdev->GdiInfo.cyHTPat;
            HTPat.pHTPatA = (LPBYTE)ppdev->GdiInfo.pHTPatA;
            HTPat.pHTPatB = (LPBYTE)ppdev->GdiInfo.pHTPatB;
            HTPat.pHTPatC = (LPBYTE)ppdev->GdiInfo.pHTPatC;

            htInitInfo.pHalftonePattern = &HTPat;

        } else {

            htInitInfo.HTPatternIndex = HTPAT_SIZE_DEFAULT;
        }
    }

    CIEINFO cie;

    cie.Red.x = (DECI4)pci->Red.x;
    cie.Red.y = (DECI4)pci->Red.y;
    cie.Red.Y = (DECI4)pci->Red.Y;

    cie.Green.x = (DECI4)pci->Green.x;
    cie.Green.y = (DECI4)pci->Green.y;
    cie.Green.Y = (DECI4)pci->Green.Y;

    cie.Blue.x = (DECI4)pci->Blue.x;
    cie.Blue.y = (DECI4)pci->Blue.y;
    cie.Blue.Y = (DECI4)pci->Blue.Y;

    cie.Cyan.x = (DECI4)pci->Cyan.x;
    cie.Cyan.y = (DECI4)pci->Cyan.y;
    cie.Cyan.Y = (DECI4)pci->Cyan.Y;

    cie.Magenta.x = (DECI4)pci->Magenta.x;
    cie.Magenta.y = (DECI4)pci->Magenta.y;
    cie.Magenta.Y = (DECI4)pci->Magenta.Y;

    cie.Yellow.x = (DECI4)pci->Yellow.x;
    cie.Yellow.y = (DECI4)pci->Yellow.y;
    cie.Yellow.Y = (DECI4)pci->Yellow.Y;

    cie.AlignmentWhite.x = (DECI4)pci->AlignmentWhite.x;
    cie.AlignmentWhite.y = (DECI4)pci->AlignmentWhite.y;
    cie.AlignmentWhite.Y = (DECI4)pci->AlignmentWhite.Y;

    htInitInfo.pDeviceCIEInfo = &cie;

    SOLIDDYESINFO DeviceSolidDyesInfo;

    DeviceSolidDyesInfo.MagentaInCyanDye = (UDECI4)pci->MagentaInCyanDye;
    DeviceSolidDyesInfo.YellowInCyanDye  = (UDECI4)pci->YellowInCyanDye;
    DeviceSolidDyesInfo.CyanInMagentaDye = (UDECI4)pci->CyanInMagentaDye;
    DeviceSolidDyesInfo.YellowInMagentaDye = (UDECI4)pci->YellowInMagentaDye;
    DeviceSolidDyesInfo.CyanInYellowDye = (UDECI4)pci->CyanInYellowDye;
    DeviceSolidDyesInfo.MagentaInYellowDye = (UDECI4)pci->MagentaInYellowDye;

    htInitInfo.pDeviceSolidDyesInfo = &DeviceSolidDyesInfo;

    htInitInfo.DeviceResXDPI = (WORD)ppdev->GdiInfo.ulLogPixelsX;
    htInitInfo.DeviceResYDPI = (WORD)ppdev->GdiInfo.ulLogPixelsY;
    htInitInfo.DevicePelsDPI = (WORD)ppdev->GdiInfo.ulDevicePelsDPI;

    if (pca == NULL)
        htInitInfo.DefHTColorAdjustment = gcaDefault;
    else
        htInitInfo.DefHTColorAdjustment = *pca;

    if (HT_CreateDeviceHalftoneInfo(&htInitInfo,
                         (PPDEVICEHALFTONEINFO)&(ppdev->pDevHTInfo)) <= 0L)
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        ppdev->pDevHTInfo = NULL;
        return(FALSE);
    }

// Check if halftone palette is the same as the device palette.
//
// For now, don't do display devices because dynamic mode changes may
// cause their palette to change at any time.

    vHTPalIsDevPal(FALSE);
    if (!bDisplayPDEV())
    {
        XEPALOBJ palSurf(ppalSurf());
        if (palHT.bEqualEntries(palSurf))
            vHTPalIsDevPal(TRUE);
    }

// Keep the halftone palette since this function won't fail.

    ((DEVICEHALFTONEINFO *)pDevHTInfo())->DeviceOwnData = (ULONG_PTR)palHT.hpal();
    palHT.vSetPID(OBJECT_OWNER_PUBLIC);
    palHT.vKeepIt();

    return(TRUE);
}

/******************************Member*Function*****************************\
* PDEVOBJ::bDisableHalftone()
*
*  Delete the device halftone info structure.
*
* History:
*  07-Nov-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL PDEVOBJ::bDisableHalftone()
{
    ASSERTGDI((pDevHTInfo() != NULL), "bDisableHalftone: DevHTInfo null\n");

    DEVICEHALFTONEINFO *pDevHTInfo_ = (DEVICEHALFTONEINFO *)pDevHTInfo();

    if (fl(PDEV_ALLOCATEDBRUSHES))
    {
        for(int iPat = 0; iPat < HS_DDI_MAX; iPat++)
        {
            bDeleteSurface(ppdev->ahsurf[iPat]);
        }
    }

    ppdev->pDevHTInfo = NULL;

// Delete the halftone palette.

    BOOL bStatusPal = bDeletePalette((HPAL)pDevHTInfo_->DeviceOwnData);
    BOOL bStatusHT  = HT_DestroyDeviceHalftoneInfo(pDevHTInfo_);

    return(bStatusPal && bStatusHT);
}

ULONG gaaulPat[HS_DDI_MAX][8] = {

// Scans have to be DWORD aligned:

    { 0x00,                // ........     HS_HORIZONTAL 0
      0x00,                // ........
      0x00,                // ........
      0xff,                // ********
      0x00,                // ........
      0x00,                // ........
      0x00,                // ........
      0x00 },              // ........

    { 0x08,                // ....*...     HS_VERTICAL 1
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08 },              // ....*...

    { 0x80,                // *.......     HS_FDIAGONAL 2
      0x40,                // .*......
      0x20,                // ..*.....
      0x10,                // ...*....
      0x08,                // ....*...
      0x04,                // .....*..
      0x02,                // ......*.
      0x01 },              // .......*

    { 0x01,                // .......*     HS_BDIAGONAL 3
      0x02,                // ......*.
      0x04,                // .....*..
      0x08,                // ....*...
      0x10,                // ...*....
      0x20,                // ..*.....
      0x40,                // .*......
      0x80 },              // *.......

    { 0x08,                // ....*...     HS_CROSS 4
      0x08,                // ....*...
      0x08,                // ....*...
      0xff,                // ********
      0x08,                // ....*...
      0x08,                // ....*...
      0x08,                // ....*...
      0x08 },              // ....*...

    { 0x81,                // *......*     HS_DIAGCROSS 5
      0x42,                // .*....*.
      0x24,                // ..*..*..
      0x18,                // ...**...
      0x18,                // ...**...
      0x24,                // ..*..*..
      0x42,                // .*....*.
      0x81 }               // *......*
};


/**************************************************************************\
* PDEVOBJ::bCreateDefaultBrushes()
*
\**************************************************************************/

BOOL PDEVOBJ::bCreateDefaultBrushes()
{
    SIZEL   sizl;
    LONG    i;

    sizl.cx = 8;
    sizl.cy = 8;

    for (i = 0; i < HS_DDI_MAX; i++)
    {
        ppdev->ahsurf[i] = (HSURF) EngCreateBitmap(sizl,
                                                   (LONG) sizeof(ULONG),
                                                   BMF_1BPP,
                                                   BMF_TOPDOWN,
                                                   &gaaulPat[i][0]);

        if (ppdev->ahsurf[i] == NULL)
        {
            TRACE_INIT(("Failed bCreateDefaultBrushes - BAD !"));
            return(FALSE);
        }
    }

    return(TRUE);
}


/******************************Member*Function*****************************\
* PDEVOBJ::bCreateHalftoneBrushes()
*
* History:
*    The standard patterns for the NT/window has following order
*
*        Index 0     - Horizontal Line
*        Index 1     - Vertical Line
*        Index 2     - 45 degree line going up
*        Index 3     - 45 degree line going down
*        Index 4     - Horizontal/Vertical cross
*        Index 5     - 45 degree line up/down cross
*        Index 6     - 30 degree line going up
*        Index 7     - 30 degree line going down
*        Index 8     -   0% Lightness (BLACK)
*        Index 9     -  11% Lightness (very light Gray)
*        Index 10    -  22% Lightness
*        Index 11    -  33% Lightness
*        Index 12    -  44% Lightness
*        Index 13    -  56% Lightness
*        Index 14    -  67% Lightness
*        Index 15    -  78% Lightness
*        Index 16    -  89% Lightness
*        Index 17    - 100% Lightness (White)
*        Index 18    -  50% Lightness (GRAY)
*
*Return Value:
*
*    return value is total patterns created, if return value is <= 0 then an
*    error occurred.
*
*
*Author:
*
*    10-Mar-1992 Tue 20:30:44 created  -by-  Daniel Chou (danielc)
*
*    24-Nov-1992 -by-  Eric Kutter [erick] and DanielChou (danielc)
*     moved from printers\lib
\**************************************************************************/

BOOL PDEVOBJ::bCreateHalftoneBrushes()
{
    STDMONOPATTERN      SMP;
    LONG                cbPat;
    LONG                cb2;
    INT                 cPatRet;

    static BYTE         HTStdPatIndex[HS_DDI_MAX] = {

                                HT_SMP_HORZ_LINE,
                                HT_SMP_VERT_LINE,
                                HT_SMP_DIAG_45_LINE_DOWN,
                                HT_SMP_DIAG_45_LINE_UP,
                                HT_SMP_HORZ_VERT_CROSS,
                                HT_SMP_DIAG_45_CROSS
                        };

// better initialize the halftone stuff if it isn't already

    if ((pDevHTInfo() == NULL) && !bEnableHalftone(NULL))
        return(FALSE);

    cbPat = (LONG)sizeof(LPBYTE) * (LONG)(HS_DDI_MAX + 1);

// go through all the standard patterns

    for(cPatRet = 0; cPatRet < HS_DDI_MAX;)
    {

    // We will using default 0.01" line width and 10 lines per inch
    // halftone default

        SMP.Flags              = SMP_TOPDOWN;
        SMP.ScanLineAlignBytes = BMF_ALIGN_DWORD;
        SMP.PatternIndex       = HTStdPatIndex[cPatRet];
        SMP.LineWidth          = 8;
        SMP.LinesPerInch       = 15;

    // Get the cx/cy size of the pattern and total bytes required
    // to stored the pattern

        SMP.pPattern = NULL;                 /* To find the size */

        if ((cbPat = HT_CreateStandardMonoPattern((PDEVICEHALFTONEINFO)pDevHTInfo(), &SMP)) <= 0)
        {
            break;
        }

        //
        // create the bitmap
        //

        DEVBITMAPINFO dbmi;


        dbmi.iFormat  = BMF_1BPP;
        dbmi.cxBitmap = SMP.cxPels;
        dbmi.cyBitmap = SMP.cyPels;
        dbmi.hpal     = (HPALETTE) 0;
        dbmi.fl       = BMF_TOPDOWN;

        SURFMEM SurfDimo;

        SurfDimo.bCreateDIB(&dbmi, NULL);

        if (!SurfDimo.bValid())
        {
            break;
        }

        SurfDimo.vKeepIt();
        SurfDimo.vSetPID(OBJECT_OWNER_PUBLIC);

        ppdev->ahsurf[cPatRet] = SurfDimo.ps->hsurf();
        SMP.pPattern           = (PBYTE)SurfDimo.ps->pvBits();

        //
        // advance the count now so we clean up as appropriate
        //

        ++cPatRet;

    // now set the bits

        if ((cb2 = HT_CreateStandardMonoPattern((PDEVICEHALFTONEINFO)pDevHTInfo(), &SMP)) != cbPat)
        {
            break;
        }
    }

// if we failed, we had better delete what we created.

    if (cPatRet < HS_DDI_MAX)
    {
        while (cPatRet-- > 0)
        {
            bDeleteSurface(ppdev->ahsurf[cPatRet]);
        }

        return(FALSE);
    }

    setfl(TRUE, PDEV_ALLOCATEDBRUSHES);

    return(TRUE);
}

/******************************Public*Routine******************************\
* FLONG flRaster(ulTechnology, flGraphicsCaps)
*
* Computes the appropriate Win3.1 style 'flRaster' flags for the device
* given GDIINFO data.
*
* History:
*  1-Feb-1993 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
*
\**************************************************************************/

FLONG flRaster(ULONG ulTechnology, FLONG flGraphicsCaps)
{
// Flags Win32 never sets:
// -----------------------
//
//   RC_BANDING       -- Banding is always transparent to programmer
//   RC_SCALING       -- Special scaling support is never required
//   RC_GDI20_OUTPUT  -- Win2.0 state blocks in device contexts not supported
//   RC_SAVEBITMAP    -- Bitmap saving is transparent and SaveScreenBitmap not
//                       exported
//   RC_DEVBITS       -- Drivers don't export BitmapBits or SelectBitmap

// Flags Win32 always sets:
// ------------------------

    FLONG fl = (RC_BIGFONT      | // All devices support fonts > 64k
                RC_GDI20_OUTPUT | // We handle most Win 2.0 features

// Set that not-terribly-well documented text flag:

                RC_OP_DX_OUTPUT); // Can do opaque ExtTextOuts with dx array

// Line printers and pen plotters can't support any bitmap BitBlt's:

    if ((ulTechnology != DT_PLOTTER) && (ulTechnology != DT_CHARSTREAM))
    {
        fl |= (RC_BITBLT       | // Can transfer bitmaps
               RC_BITMAP64     | // Can support bitmaps > 64k
               RC_DI_BITMAP    | // Support SetDIBIts and GetDIBits
               RC_DIBTODEV     | // Support SetDIBitsToDevice
               RC_STRETCHBLT   | // Support StretchBlts
               RC_STRETCHDIB);   // Support SetchDIBits
    }

// Printers can't journal FloodFill cals, so only allow raster displays:

    if (ulTechnology == DT_RASDISPLAY)
        fl |= RC_FLOODFILL;

// Set palette flag from capabilities bit:

    if (flGraphicsCaps & GCAPS_PALMANAGED)
        fl |= RC_PALETTE;

    return(fl);
}



/*
*
*   HACK 
*
*/

LPWSTR
EngGetPrinterDataFileName(
    HDEV hdev)
{

    return ((PPDEV)hdev)->pwszDataFile;
}

/*
*
*   HACK 
*
*/

LPWSTR
EngGetDriverName(
    HDEV hdev)
{
    return ((PPDEV)hdev)->pldev->pGdiDriverInfo->DriverName.Buffer;
}

/******************************Public*Routine******************************\
* EngQueryAttribute
*
* This is the engine entry point for device drivers to query device 
* attributes.
*
* hDev must always be a valid device.
*
* This call will return TRUE for success and FALSE for failure.
*
* QDA_ACCELERATION_LEVEL:
*     pvIn - ignored
*     pvInSize - ignored
*     pvOut - pointer to DWORD
*     pvOutSize - sizeof(DWORD)
*
*     The current device acceleration level is returned in pvOut.  Please
*     see ??? for a discussion of acceleration levels.
*
*     NOTE: we should have an enumeration in winddi.h for acceleration
*           levels.
*
*
* History:
*  07-Nov-1998 -by- Bart House bhouse
* Wrote it.
\**************************************************************************/

BOOL
EngQueryDeviceAttribute(
    HDEV                    hdev,
    ENG_DEVICE_ATTRIBUTE    devAttr,
    VOID *                  pvIn,
    ULONG                   ulInSize,
    VOID *                  pvOut,
    ULONG                   ulOutSize)
{
    BOOL    bResult = FALSE;    // assume failure
    PPDEV   ppdev = (PPDEV) hdev;

    if(pvOut != NULL)
    {

        switch(devAttr)
        {
        
        case QDA_ACCELERATION_LEVEL:
            if(ulOutSize == sizeof(DWORD))
            {
                *((DWORD *) pvOut) = ppdev->dwDriverAccelerationLevel;
                bResult = TRUE;
            }
            else
            {
                WARNING("EngQueryDeviceAttribute -- bad ulOutSize");
            }
            break;
    
        default:
            WARNING("EngQueryDeviceAttribute -- unknown device attribte");
            break;
        }
    }
    else
    {
        WARNING("EngQueryDeviceAttribute -- pvOut is NULL");
    }

    return bResult;
}

/******************************Member*Function*****************************\
* PDEVOBJ::PDEVOBJ
*
* Create a PDEVOBJ based on given HDEV.
*
* History:
*  1-Apr-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\**************************************************************************/

// Should be in header to share with icmapi.cxx and ddraw.cxx

#define MAX_COLORTABLE     256

PDEVOBJ::PDEVOBJ
(
    HDEV hdevOrg,
    FLONG fl
)
{
    GDIFunctionID(PDEVOBJ::PDEVOBJ<clone>);

    INT i;

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: ENTERING\n"));

    ppdev = (PDEV *) NULL;

    PDEVOBJ pdoOrg(hdevOrg);

    //
    // Validate input.
    // 
    // 1) Only GCH_CLONE_DISPLAY supported.
    // 2) hdevOrg should be valid.
    // 3) hdevOrg should be display device.
    //
    if ((fl != GCH_CLONE_DISPLAY) || (!pdoOrg.bValid()) || (!pdoOrg.bDisplayPDEV()))
    {
        WARNING("Failed to validate input parameter\n");
        return;
    }

    DEVLOCKOBJ dlo(pdoOrg);

    ppdev = (PDEV *) PALLOCMEM(sizeof(PDEV) - sizeof(DWORD) + gdwDirectDrawContext, 'veDG');

    if (ppdev == NULL)
    {
        WARNING("Failed allocation of PDEV\n");
        return;
    }

    PDEV *ppdevOrg = (PDEV *) pdoOrg.hdev();

    ppdev->pldev       = ppdevOrg->pldev;
    ppdev->ppdevParent = ppdev;
    ppdev->ulTag       = 'Pdev';

    PDEVOBJ pdo((HDEV) ppdev);

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Mirroring original hdev info to clone\n"));

    //
    // Copy fields which can be copied from original.
    //

    ppdev->pfnDrvSetPointerShape = ppdevOrg->pfnDrvSetPointerShape; // Accelerator
    ppdev->pfnDrvMovePointer     = ppdevOrg->pfnDrvMovePointer;     // Accelerator
    ppdev->pfnMovePointer        = ppdevOrg->pfnMovePointer;        // Accelerator
    ppdev->pfnSync               = ppdevOrg->pfnSync;               // Accelerator
    ppdev->pfnSyncSurface        = ppdevOrg->pfnSyncSurface;        // Accelerator
    ppdev->pfnSetPalette         = ppdevOrg->pfnSetPalette;
    ppdev->pfnNotify             = ppdevOrg->pfnNotify;

    ppdev->dhpdev                = ppdevOrg->dhpdev;

    ppdev->ppalSurf              = ppdevOrg->ppalSurf;
    ppdev->devinfo               = ppdevOrg->devinfo;  
    ppdev->GdiInfo               = ppdevOrg->GdiInfo;
    ppdev->hSpooler              = ppdevOrg->hSpooler;
    ppdev->pDesktopId            = ppdevOrg->pDesktopId;
    ppdev->pGraphicsDevice       = ppdevOrg->pGraphicsDevice;
    ppdev->ptlOrigin             = ppdevOrg->ptlOrigin;

    if (ppdevOrg->ppdevDevmode)
    {
         DWORD dwSize = ppdevOrg->ppdevDevmode->dmSize +
                        ppdevOrg->ppdevDevmode->dmDriverExtra;

         ppdev->ppdevDevmode     = (PDEVMODEW) PALLOCNOZ(dwSize,GDITAG_DEVMODE);

         if (ppdev->ppdevDevmode)
         {
             RtlMoveMemory(ppdev->ppdevDevmode,
                           ppdevOrg->ppdevDevmode,
                           dwSize);
         }
         else
         {
             goto ERROR_RETURN;
         }
    }

    ppdev->flAccelerated         = ppdevOrg->flAccelerated;

    ppdev->ptlPointer            = ppdevOrg->ptlPointer;

    ppdev->hlfntDefault          = ppdevOrg->hlfntDefault;
    ppdev->hlfntAnsiVariable     = ppdevOrg->hlfntAnsiVariable;
    ppdev->hlfntAnsiFixed        = ppdevOrg->hlfntAnsiFixed;

    ppdev->pSurface              = ppdevOrg->pSurface;

    for (i = 0; i < HS_DDI_MAX; i++)
    {
        ppdev->ahsurf[i]         = ppdevOrg->ahsurf[i];
    }

    ppdev->pwszDataFile          = ppdevOrg->pwszDataFile;

    if (ppdevOrg->pvGammaRampTable)
    {
        ppdev->pvGammaRampTable  = (LPVOID) PALLOCNOZ(
                         MAX_COLORTABLE * sizeof(WORD) * 3,
                         'mciG');

        if (ppdev->pvGammaRampTable)
        {
            RtlCopyMemory(ppdev->pvGammaRampTable,
                          ppdevOrg->pvGammaRampTable,
                          MAX_COLORTABLE * sizeof(WORD) * 3);
        }
        else
        {
            goto ERROR_RETURN;
        }
    }

    ppdev->sizlMeta              = ppdevOrg->sizlMeta;
    ppdev->pfnUnfilteredBitBlt   = ppdevOrg->pfnUnfilteredBitBlt;
    ppdev->dwDriverCapableOverride
                                 = ppdevOrg->dwDriverCapableOverride;
    ppdev->dwDriverAccelerationLevel
                                 = ppdevOrg->dwDriverAccelerationLevel;

    RtlCopyMemory(ppdev->apfn,ppdevOrg->apfn,sizeof(ppdev->apfn));

    //
    // If the DDI is hooked, we want to make sure that we don't copy
    // the Sp function pointers from ppdevOrg, but get the driver function
    // pointers from the SPRITESTATE instead.  See vSpHook for details.
    //

    if (pdoOrg.pSpriteState()->bHooked)
    {
        SPRITESTATE *pState = pdoOrg.pSpriteState();

        ppdev->apfn[INDEX_DrvStrokePath]        = (PFN) pState->pfnStrokePath;
        ppdev->apfn[INDEX_DrvFillPath]          = (PFN) pState->pfnFillPath;
        ppdev->apfn[INDEX_DrvBitBlt]            = (PFN) pState->pfnBitBlt;
        ppdev->apfn[INDEX_DrvCopyBits]          = (PFN) pState->pfnCopyBits;
        ppdev->apfn[INDEX_DrvStretchBlt]        = (PFN) pState->pfnStretchBlt;
        ppdev->apfn[INDEX_DrvTextOut]           = (PFN) pState->pfnTextOut;
        ppdev->apfn[INDEX_DrvLineTo]            = (PFN) pState->pfnLineTo;
        ppdev->apfn[INDEX_DrvTransparentBlt]    = (PFN) pState->pfnTransparentBlt;
        ppdev->apfn[INDEX_DrvAlphaBlend]        = (PFN) pState->pfnAlphaBlend;
        ppdev->apfn[INDEX_DrvPlgBlt]            = (PFN) pState->pfnPlgBlt;
        ppdev->apfn[INDEX_DrvGradientFill]      = (PFN) pState->pfnGradientFill;
        ppdev->apfn[INDEX_DrvStretchBltROP]     = (PFN) pState->pfnStretchBltROP;
        ppdev->apfn[INDEX_DrvSaveScreenBits]    = (PFN) pState->pfnSaveScreenBits;
        ppdev->apfn[INDEX_DrvDrawStream]        = (PFN) pState->pfnDrawStream;
    }

    //
    // Set up the fields can not just copied from original.
    //

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Setup new hdev info for clone\n"));

    //
    // PDEVOBJ.cPdevRefs and PDEVOBJ.cPdevOpenRefs.
    //

    ppdev->cPdevRefs     = 1; // Number of clients.
    ppdev->cPdevOpenRefs = 1; // OpenCount

    //
    // Setup flags.
    //
    // We only inherit the flag which still has valid in clone, too.
    //

    ppdev->fl = ppdevOrg->fl & (PDEV_DISPLAY |
                                PDEV_GAMMARAMP_TABLE |
                                PDEV_META_DEVICE |
                                PDEV_DRIVER_PUNTED_CALL);

    //
    // PDEVOBJ.hsemDevLock
    //
    
    if ((ppdev->hsemDevLock = GreCreateSemaphore()) == NULL)
        goto ERROR_RETURN;

    //
    // we now load font info only when needed.  The driver still must have
    // setup the default font information.
    //

    bGotFonts(FALSE);

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Create pointer semaphore\n"));

    //
    // PDEVOBJ.hsemPoiner
    //

    ppdev->hsemPointer = GreCreateSemaphore();
    if (!ppdev->hsemPointer)
        goto ERROR_RETURN;

    //
    // Enable DirectDraw (for clone).
    //

    if (!DxDdEnableDirectDraw(pdo.hdev(),FALSE))
        goto ERROR_RETURN;

    //
    // Adjust original pdev as cloned.
    //

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Processing onto new hdev as clone\n"));

    //
    // Mark new pdev as clone.
    //

    pdo.bCloneDriver(TRUE);

    //
    // NOTE: AFTER HERE, ERROR_RETURN COULD NOT BE ALLOWED
    //

#ifdef DDI_WATCHDOG

    //
    // !!! Hack - since watchdog creation requires access to DEVICE_OBJECT now
    // we have to delay watchdog creation till hCreateHDEV where PDEV gets associated
    // with DEVICE_OBJECT. It would be nice to have it here though.
    //

    ppdev->pWatchdogContext = NULL;
    ppdev->pWatchdogData = NULL;

#endif  // DDI_WATCHDOG

    // PDEVOBJ.ppdevNext.
    //
    // Finally, everything done, so put this on global list.
    //

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: Insert new hdev to global list\n"));

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    ppdev->ppdevNext = gppdevList;
    gppdevList = ppdev;

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: LEAVING with success\n"));

    return;

ERROR_RETURN:

    if (ppdev->hsemDevLock)
    {
        GreDeleteSemaphore(ppdev->hsemDevLock);
    }

    if (ppdev->ppdevDevmode)
    {
        VFREEMEM(ppdev->ppdevDevmode);
    }

    if (ppdev->pvGammaRampTable)
    {
        VFREEMEM(ppdev->pvGammaRampTable);
    }

    DxDdDisableDirectDraw(pdo.hdev(),FALSE);

    VFREEMEM(ppdev);

    ppdev = (PDEV *) NULL;

    TRACE_INIT(("PDEVOBJ::PDEVOBJ_: LEAVING with error\n"));

    return;
}

/******************************Member*Function*****************************\
* PDEVOBJ::PDEVOBJ
*
* Allocates and initializes a PDEV, i.e. takes the reference count from
* zero to one.
*
* The object must be completely constructed, otherwise completely destroyed.
*
\**************************************************************************/

PDEVOBJ::PDEVOBJ
(
    PLDEV pldev,
    PDEVMODEW pdriv,
    PWSZ pwszLogAddr,
    PWSZ pwszDataFile,
    PWSZ pwszDeviceName,
    HANDLE hSpool,
    PREMOTETYPEONENODE pRemoteTypeOne,
    PGDIINFO pMirroredGdiInfo,
    PDEVINFO pMirroredDevInfo,
    BOOL     bUMPD,
    DWORD    dwCapableOverride,
    ULONG    dwAccelerationLevel
)
{
    GDIFunctionID(PDEVOBJ::PDEVOBJ);

    TRACE_INIT(("PDEVOBJ::PDEVOBJ: ENTERING\n"));

    ppdev = (PDEV *) PALLOCMEM(sizeof(PDEV) - sizeof(DWORD) + gdwDirectDrawContext, 'veDG');
    if (ppdev == NULL)
    {
        WARNING("Failed allocation of PDEV\n");
        return;
    }

    ppdev->ppdevParent = ppdev;
    ppdev->pldev = pldev;
    ppdev->ulTag = 'Pdev';
    ppdev->dwDriverCapableOverride = dwCapableOverride;
    ppdev->dwDriverAccelerationLevel = dwAccelerationLevel;

    TRACE_INIT(("PDEVOBJ::PDEVOBJ: Calling driver to initialize PDEV\n"));

    PDEVOBJ pdo((HDEV) ppdev);

    //
    // Create semaphores so the device can be locked.
    //

    if (ppdev->pldev->ldevType != LDEV_FONT)
    {
        ppdev->hsemDevLock = GreCreateSemaphore();
        if (!ppdev->hsemDevLock)
            goto ERROR_RETURN;
    }

    if ( dwCapableOverride & DRIVER_NOT_CAPABLE_GDI )
    {
        //
        // If the driver is not capable of GDI, then it is similar to
        // DRIVER_ACCELERATIONS_NONE. Reset the level we stored in PDEV
        //     
        ppdev->dwDriverAccelerationLevel = DRIVER_ACCELERATIONS_NONE;
    }

    //
    // fill in the dispatch table.  If we've been told to allow no
    // driver accelerations, redirect everything to the panning driver,
    // which handles this case.
    //
    if ((ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) &&
        (dwDriverAccelerationsLevel() == DRIVER_ACCELERATIONS_NONE))
    {
        //
        // Fill in function table with Panning driver versions.
        //
        bFillFunctionTable(gadrvfnPanning, 
                           gcdrvfnPanning, 
                           &ppdev->apfn[0]);
    }
    else
    {
        RtlMoveMemory(&(ppdev->apfn[0]),
                      &(ppdev->pldev->apfn[0]),
                      sizeof(PFN) * INDEX_LAST);
    }

    //
    // if we are doing a ResetDC then we need to transfer over remote type 1
    // fonts from previous PDEV
    //

    ppdev->RemoteTypeOne = pRemoteTypeOne;

    //
    // HACK - temporary
    //

    ppdev->pwszDataFile = pwszDataFile;

    //
    // If this is a Mirroring driver, we want to pass in the global GDIINFO
    // and DEVINFO as returned by the primary driver.
    //

    if (pMirroredGdiInfo)
    {
        ppdev->GdiInfo = *pMirroredGdiInfo;
        ppdev->devinfo = *pMirroredDevInfo;
    }

    //
    // Ask the device driver to create a PDEV.
    //

    UMDHPDEV *pUMdhpdev;

    pdo.bUMPD(bUMPD);

    if (bUMPD)
    {
        //
        // NOTE: we store the umpdCookie in dhpdev so that we can pass the
        //       cookie to the UM UMPD layer during DrvEnablePDEV
        //
        ppdev->dhpdev = (DHPDEV) pldev->umpdCookie;
    }

    ppdev->dhpdev = pdo.EnablePDEV (
                      pdriv,            // Driver Data.
                      pwszLogAddr,      // Logical Address.
                      HS_DDI_MAX,       // Count of standard patterns.
                      ppdev->ahsurf,    // Buffer for standard patterns
                      sizeof(GDIINFO),  // Size of GdiInfo
                      &ppdev->GdiInfo,  // Buffer for GdiInfo
                      sizeof(DEVINFO),  // Number of bytes in devinfo.
                      &ppdev->devinfo,  // Device info.
                      (HDEV)ppdev,      // Data File
                      pwszDeviceName,   // Device Name
                      hSpool);          // Base driver handle

    if (ppdev->dhpdev)
    {
        TRACE_INIT(("PDEVOBJ::PDEVOBJ: PDEV initialized by the driver\n"));

        if (ppdev->pldev->ldevType != LDEV_FONT)
        {
            //
            // Make sure that units are in MicroMeters for HorzSize, VertSize
            //

            if ( (LONG)ppdev->GdiInfo.ulHorzSize <= 0 )
            {
                if ( (LONG)ppdev->GdiInfo.ulHorzSize == 0)
                {
                    // Calculate the ulHorzSize using Default DPI.
                    // Width in mm =  (ulHorzRes / DEFAULT_DPI) * 25.4

                    ppdev->GdiInfo.ulHorzSize = (254 *
                        (LONG)ppdev->GdiInfo.ulHorzRes) / (10*DEFAULT_DPI);
                }
                else
                    ppdev->GdiInfo.ulHorzSize = (ULONG)(-(LONG)ppdev->GdiInfo.ulHorzSize);
            }
            else
            {
                ppdev->GdiInfo.ulHorzSize *= 1000;
            }

            if ( (LONG)ppdev->GdiInfo.ulVertSize <= 0 )
            {
                if ( (LONG)ppdev->GdiInfo.ulVertSize == 0)
                {
                    // Calculate the ulVertSize using Default DPI.
                    // Height in mm =  (ulVertRes / DEFAULT_DPI) * 25.4

                    ppdev->GdiInfo.ulVertSize = (254 *
                        (LONG)ppdev->GdiInfo.ulVertRes) / (10*DEFAULT_DPI);
                }
                else
                {
                    ppdev->GdiInfo.ulVertSize = (ULONG)(-(LONG)ppdev->GdiInfo.ulVertSize);
                }
            }
            else
            {
                ppdev->GdiInfo.ulVertSize *= 1000;
            }

            //
            // For compatibility, all displays will have constant style
            // values (plus this helps us because we know the values won't
            // change asynchronously because of dynamic mode changes):
            //

            if (ppdev->GdiInfo.ulTechnology == DT_RASDISPLAY)
            {
                ppdev->GdiInfo.xStyleStep   = 1;
                ppdev->GdiInfo.yStyleStep   = 1;
                ppdev->GdiInfo.denStyleStep = 3;
            }
            else
            {
            #if DBG
                if (ppdev->GdiInfo.xStyleStep == 0)
                    WARNING("Device gave xStyleStep of 0");
                if (ppdev->GdiInfo.yStyleStep == 0)
                    WARNING("Device gave yStyleStep of 0");
                if (ppdev->GdiInfo.denStyleStep == 0)
                    WARNING("Device gave denStyleStep of 0");
            #endif
            }

            //
            // Compute the appropriate raster flags:
            //

            ppdev->GdiInfo.flRaster = flRaster(ppdev->GdiInfo.ulTechnology,
                                               ppdev->devinfo.flGraphicsCaps);

            TRACE_INIT(("PDEVOBJ::PDEVOBJ: Creating the default palette\n"));

            //
            // The default palette is stored in devinfo in the pdev.
            // This will be the palette we use for the main surface enabled.
            //

            ASSERTGDI(ppdev->devinfo.hpalDefault != 0,
                      "ERROR_RETURN devinfo.hpalDefault invalid");

            {
                EPALOBJ palDefault(ppdev->devinfo.hpalDefault);

                ASSERTGDI(palDefault.bValid(), "ERROR_RETURN hpalDefault invalid");

                //
                // Bug #68071:  display drivers often set the ulPrimaryOrder
                // field wrong (because of wrong sample code we gave them),
                // which causes red to be switched with blue in halftone
                // colors.  We fix this by ignoring the ulPrimaryOrder that they
                // pass us and instead compute it from the Palette.
                //
                // 19-Mar-1999 Fri 12:10:22 updated  -by-  Daniel Chou (danielc)
                //  Many ohter drivers also set ulPrimaryOrder wrong when the
                //  surface format >= 16BPP, here we should check for all
                //  devices, not just display, so we removed following line
                //  that only check for the display. This make it check on
                //  every pdev.
                //
                // if (ppdev->GdiInfo.ulTechnology == DT_RASDISPLAY)
                //

                {
                    if (!(palDefault.bIsIndexed()))
                    {
                        //
                        // 6 possibilities here:  to be safe we should account for all of them.
                        // This code can probably be made simpler if we assume that the
                        // values of the PRIMARY_ORDER_xxx constants won't change, but it's
                        // not that big a deal.
                        //
                        if ((palDefault.flRed() > palDefault.flGre()) &&
                            (palDefault.flRed() > palDefault.flBlu()))
                        {
                            if (palDefault.flGre() > palDefault.flBlu())
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_ABC;
                            }
                            else
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_ACB;
                            }
                        }
                        else if ((palDefault.flGre() > palDefault.flRed()) &&
                                 (palDefault.flGre() > palDefault.flBlu()))
                        {
                            if (palDefault.flRed() > palDefault.flBlu())
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_BAC;
                            }
                            else
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_BCA;
                            }
                        }
                        else
                        {
                            // Blue must be greatest (leftmost)
                            if (palDefault.flRed() > palDefault.flGre())
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_CAB;
                            }
                            else
                            {
                                ppdev->GdiInfo.ulPrimaryOrder = PRIMARY_ORDER_CBA;
                            }
                        }
                    }
                }

                if (ppdev->GdiInfo.flRaster & RC_PALETTE)
                {
                    //
                    // Attempt to make it palette managed.
                    // 
                    if(!CreateSurfacePal(palDefault,
                                     PAL_MANAGED,
                                     ppdev->GdiInfo.ulNumColors,
                                     ppdev->GdiInfo.ulNumPalReg))
                    {
                        goto ERROR_RETURN;
                    }
                }

                ppalSurf(palDefault.ppalGet());

                //
                // Leave a reference count of 1 on this palette.
                //

                palDefault.ppalSet(NULL);
            }

            //
            // if the driver didn't fill in the brushes, we'll do it.
            //
            // if it's a display driver, we'll overwrite its brushes with our
            // own, regardless of whether it already filled in the brushes or
            // not.  Note that it's okay even if a display driver filled in
            // these values -- the driver already had to keep its own copy of
            // the handles and will clean them up at DrvDisablePDEV time.
            // Supplying our own defaults also simplifies GreDynamicModeChange.
            //

            if ( (ppdev->ahsurf[0] == NULL) ||
                 (ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) ||
                 (ppdev->pldev->ldevType == LDEV_DEVICE_MIRROR) )
            {
                TRACE_INIT(("PDEVOBJ::PDEVOBJ: Creating brushes dor the driver\n"));

                if (ppdev->pldev->ldevType == LDEV_DEVICE_PRINTER)
                {
                    if (!bCreateHalftoneBrushes())
                        goto ERROR_RETURN;
                }
                else
                {
                    // WINBUG #55204 2-1-2000 bhouse Look into whether we leak default brushes
                    //
                    // Andre Vachon
                    // 6-6-95  Kernel mode cleanup
                    //
                    // The old behaviour is the call the halftoneBrushes function
                    // It ends up in a bunch of very complex halftoning code that I have
                    // no idea what it does.
                    // For now, to clean up drivers in kernel mode, replace this call
                    // with a simple function that will create the 6 bitmaps just
                    // like display drivers did.

                    // Where do these ever get cleaned up?!?  I see where the
                    //     halftone brushes get cleaned up, but not these.

                    if (!bCreateDefaultBrushes())
                        goto ERROR_RETURN;
                }
            }

            //
            // Set the hSpooler first
            //

            hSpooler(hSpool);

            //
            // Create a semaphore of the mouse pointer
            // (only for the driver will handle cursor)
            //

            if ( (ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) ||
                 (ppdev->pldev->ldevType == LDEV_DEVICE_META)    ||
                 (ppdev->pldev->ldevType == LDEV_DEVICE_MIRROR) )
            {
                //
                // Mouse pointer accelerators.
                //

                ppdev->pfnDrvMovePointer     =
                     (PFN_DrvMovePointer) PPFNDRV(pdo,MovePointer);
                ppdev->pfnDrvSetPointerShape =
                     (PFN_DrvSetPointerShape) PPFNDRV(pdo,SetPointerShape);

                //
                // Init fmPointer
                //

                SEMOBJ so(ghsemDriverMgmt);

                TRACE_INIT(("PDEVOBJ::PDEVOBJ: Create pointer semaphore\n"));

                ppdev->hsemPointer = GreCreateSemaphore();
                if (!ppdev->hsemPointer)
                    goto ERROR_RETURN;

                //
                // Mark the PDEV as a display.
                //

                ppdev->fl |= PDEV_DISPLAY;
            }

            ppdev->pfnSetPalette = PPFNDRV(pdo, SetPalette);
            ppdev->pfnSync = PPFNDRV(pdo, Synchronize);
            ppdev->pfnSyncSurface = PPFNDRV(pdo, SynchronizeSurface);
            ppdev->pfnNotify = PPFNDRV(pdo, Notify);

            //
            // we now load font info only when needed.  The driver still must have
            // setup the default font information.
            //

            bGotFonts(FALSE);

            //
            // If any of the LOGFONTs in DEVINFO do not specify a height,
            // substitute the default.
            //

            LONG lHeightDefault = (DEFAULT_POINT_SIZE * ppdev->GdiInfo.ulLogPixelsY) / POINTS_PER_INCH ;
            ENUMLOGFONTEXDVW elfw;

            if ( ppdev->devinfo.lfDefaultFont.lfHeight == 0 )
                ppdev->devinfo.lfDefaultFont.lfHeight = lHeightDefault;

            if ( ppdev->devinfo.lfAnsiVarFont.lfHeight == 0 )
                ppdev->devinfo.lfAnsiVarFont.lfHeight = lHeightDefault;

            if ( ppdev->devinfo.lfAnsiFixFont.lfHeight == 0 )
                ppdev->devinfo.lfAnsiFixFont.lfHeight = lHeightDefault;

            //
            // Create LFONTs from the LOGFONTs in the DEVINFO.
            // the LOGFONTs should become EXTLOGFONTWs
            //

            vConvertLogFontW(&elfw, &(ppdev->devinfo.lfDefaultFont));

#ifdef FE_SB
            // We are doing away with the concept of default device fonts for display
            // drivers since it doesnt make sense.  Assuming this change gets approved
            // I will remove these before SUR ships.

            if ( ppdev->GdiInfo.ulTechnology == DT_RASDISPLAY )
            {
                ppdev->hlfntDefault = STOCKOBJ_SYSFONT;
            }
            else
#endif
            {
                if ((ppdev->hlfntDefault
                      = (HLFONT) hfontCreate(&elfw,
                                             LF_TYPE_DEVICE_DEFAULT,
                                             LF_FLAG_STOCK,
                                             NULL)) == HLFONT_INVALID)
                {
                    ppdev->hlfntDefault = STOCKOBJ_SYSFONT;
                }
                else
                {
                    //
                    // Set to public.
                    //

                    if (!GreSetLFONTOwner(ppdev->hlfntDefault, OBJECT_OWNER_PUBLIC))
                    {
                        //
                        // If it failed, get rid of the LFONT and resort to System font.
                        //

                        bDeleteFont(ppdev->hlfntDefault, TRUE);
                        ppdev->hlfntDefault = STOCKOBJ_SYSFONT;
                    }
                }
            }

            vConvertLogFontW(&elfw, &(ppdev->devinfo.lfAnsiVarFont));

            if ((ppdev->hlfntAnsiVariable
                   = (HLFONT) hfontCreate(&elfw,
                                          LF_TYPE_ANSI_VARIABLE,
                                          LF_FLAG_STOCK,
                                          NULL)) == HLFONT_INVALID)
            {
                ppdev->hlfntAnsiVariable = STOCKOBJ_SYSFONT;
            }
            else
            {
                //
                // Set to public.
                //

                if (!GreSetLFONTOwner(ppdev->hlfntAnsiVariable, OBJECT_OWNER_PUBLIC))
                {
                    //
                    // If it failed, get rid of the LFONT and resort to System font.
                    //

                    bDeleteFont(ppdev->hlfntAnsiVariable, TRUE);
                    ppdev->hlfntAnsiVariable = STOCKOBJ_SYSFONT;
                }
            }

            vConvertLogFontW(&elfw, &(ppdev->devinfo.lfAnsiFixFont));

            if ((ppdev->hlfntAnsiFixed
                  = (HLFONT) hfontCreate(&elfw,
                                         LF_TYPE_ANSI_FIXED,
                                         LF_FLAG_STOCK,
                                         NULL)) == HLFONT_INVALID)
            {
                ppdev->hlfntAnsiFixed = STOCKOBJ_SYSFIXEDFONT;
            }
            else
            {
                //
                // Set to public.
                //

                if (!GreSetLFONTOwner(ppdev->hlfntAnsiFixed, OBJECT_OWNER_PUBLIC))
                {
                    //
                    // If it failed, get rid of the LFONT and resort to System Fixed font.
                    //

                    bDeleteFont(ppdev->hlfntAnsiFixed, TRUE);
                    ppdev->hlfntAnsiFixed = STOCKOBJ_SYSFIXEDFONT;
                }
            }

#ifdef DRIVER_DEBUG
            LFONTOBJ    lfo1(ppdev->hlfntDefault);
            DbgPrint("GRE!PDEVOBJ(): Device default font\n");
            if (lfo1.bValid())
            {
                lfo1.vDump();
            }
            DbgPrint("GRE!PDEVOBJ(): Ansi variable font\n");
            LFONTOBJ    lfo2(ppdev->hlfntAnsiVariable);
            if (lfo2.bValid())
            {
                lfo2.vDump();
            }
            DbgPrint("GRE!PDEVOBJ(): Ansi fixed font\n");
            LFONTOBJ    lfo3(ppdev->hlfntAnsiFixed);
            if (lfo3.bValid())
            {
                lfo3.vDump();
            }
#endif
            //
            // (see bInitDefaultGuiFont() in stockfnt.cxx)
            //
            // If we haven't yet computed the adjusted height of the
            // DEFAULT_GUI_FONT stock object, do so now.  We couldn't do
            // this during normal stock font initialization because the
            // display driver had not yet been loaded.
            //

            if ( gbFinishDefGUIFontInit &&
                 (ppdev->pldev->ldevType == LDEV_DEVICE_DISPLAY) )
            {
                LFONTOBJ lfo(STOCKOBJ_DEFAULTGUIFONT);

                if (lfo.bValid())
                {
                    lfo.plfw()->lfHeight = -(LONG)((lfo.plfw()->lfHeight * ppdev->GdiInfo.ulLogPixelsY + 36) / 72);
                }

                gbFinishDefGUIFontInit = FALSE;
            }
        }

        //
        // Initialize the PDEV fields.
        //

        ppdev->cPdevRefs     = 1;
        ppdev->cPdevOpenRefs = 1;

        //
        // Before adding a display PDEV to the PDEV list, make sure it's
        // disabled.  We do this to protect against GreFlush walking the
        // PDEV list and calling the driver before we've even finished calling
        // DrvEnableSurface.  We mark the PDEV as enabled when all initialization 
        // is complete.
        //

        if (pdo.bDisplayPDEV())
        {
            pdo.bDisabled(TRUE);

            // Once the pdev has been disabled we can safely update
            // magic colors in an indexed palette. DrvEnableMDEV will
            // update the palette when the display is reenabled.
            vResetSurfacePalette(hdev());
        }

        //
        // Just stick it at the start of the list.
        // Make sure this list is protected by the driver semaphore
        //

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

        ppdev->ppdevNext = gppdevList;
        gppdevList = ppdev;

        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        TRACE_INIT(("PDEVOBJ::PDEVOBJ: list of display pdevs %08lx\n", gppdevList));

        //
        // NOTE after this point, the object will be "permanent" and will
        // end up being destroyed by the destructor
        //

#ifdef DDI_WATCHDOG

        //
        // !!! Hack - since watchdog creation requires access to DEVICE_OBJECT now
        // we have to delay watchdog creation till hCreateHDEV where PDEV gets associated
        // with DEVICE_OBJECT. It would be nice to have it here though.
        //

        ppdev->pWatchdogContext = NULL;
        ppdev->pWatchdogData = NULL;

#endif  // DDI_WATCHDOG

        //
        // Inform the driver that the PDEV is complete.
        //

        pdo.CompletePDEV(ppdev->dhpdev,hdev());

        //
        // We will return with success indicated by a non-NULL ppdev.
        //

        return;
    }
    else
    {
        WARNING("Device failed DrvEnablePDEV\n");
        goto ERROR_RETURN;
    }

ERROR_RETURN:

    if (ppdev->hsemDevLock)
    {
        GreDeleteSemaphore(ppdev->hsemDevLock);
    }

    if (ppdev->pDevHTInfo != NULL)
    {
        bDisableHalftone();
    }

    VFREEMEM(ppdev);

    ppdev = (PDEV *) NULL;
}

/******************************Member*Function*****************************\
* PDEVOBJ::cFonts()
*
* History:
*  3-Feb-1994 -by-  Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

ULONG PDEVOBJ::cFonts()
{
    ULONG_PTR id;

    //
    // see if the device already told us how many fonts it has
    //

    if (ppdev->devinfo.cFonts == (ULONG)-1)
    {
        PDEVOBJ pdo(hdev());

        //
        // if not query the device to see how many there are
        //

        if (PPFNDRV(pdo,QueryFont) != NULL)
        {
            ppdev->devinfo.cFonts = (ULONG)(ULONG_PTR)(*PPFNDRV(pdo,QueryFont))(dhpdev(),0,0,&id);
        }
        else
        {
            ppdev->devinfo.cFonts = 0;
        }
    }

    return(ppdev->devinfo.cFonts);
}

/******************************Member*Function*****************************\
* PDEVOBJ::bGetDeviceFonts()
*
* History:
*  27-Jul-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL PDEVOBJ::bGetDeviceFonts()
{

    ASSERTGDI(!bGotFonts(),"PDEVOBJ::bGetDeviceFonts - already gotten\n");

    //
    // mark that we have gotten the fonts.
    //

    bGotFonts(TRUE);

    //
    // need an ldevobj for calling the device
    //

    PDEVOBJ pdo(hdev());

    //
    // compute the number of device fonts
    //

    cFonts();

    //
    // If there are any device fonts, load the device fonts into the public PFT table.
    //

    if (ppdev->devinfo.cFonts)
    {
        DEVICE_PFTOBJ pfto;      // get the device font table
        if (!pfto.bLoadFonts(this))
        {
            WARNING("PDEVOBJ(): couldn't load device fonts\n");
            ppdev->devinfo.cFonts = 0;
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* FilteredBitBlt()
*
* This call allows only simple PATCOPY blts down to the driver; the rest
* are handled by GDI.
*
\**************************************************************************/

BOOL FilteredBitBlt
(
    SURFOBJ  *psoDst,
    SURFOBJ  *psoSrc,
    SURFOBJ  *psoMsk,
    CLIPOBJ  *pco,
    XLATEOBJ *pxlo,
    RECTL    *prclDst,
    POINTL   *pptlSrc,
    POINTL   *pptlMsk,
    BRUSHOBJ *pbo,
    POINTL   *pptlBrush,
    ROP4      rop4
)
{
    PFN_DrvBitBlt pfnBitBlt = EngBitBlt;

    // Allow only solid color blts and SRCCOPY blts to be accelerated:

    if ((rop4 == 0xcccc) ||
        ((rop4 == 0xf0f0) && (pbo->iSolidColor != 0xffffffff)))
    {
        PDEVOBJ po(psoDst->hdev);
        pfnBitBlt = po.ppdev->pfnUnfilteredBitBlt;
    }

    return(pfnBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc, 
                     pptlMsk, pbo, pptlBrush, rop4));
}

/******************************Public*Routine******************************\
* PDEVOBJ::vFilterDriverHooks()
*
* Disables driver functionality as appropriate.  This routine is used to
* disable buggy functionality in third-party drivers.
*
\**************************************************************************/

VOID PDEVOBJ::vFilterDriverHooks()
{
    SYSTEM_GDI_DRIVER_INFORMATION*  pGdiDriverInfo;
    LPWSTR                          pDriverName;
    ULONG                           ulDriverVersion;
    SURFACE*                        pSurface;
    DWORD                           dwLevel;
    DWORD                           dwOverride;

    pGdiDriverInfo = ppdev->pldev->pGdiDriverInfo;
    pSurface       = ppdev->pSurface;

    // Only do this for real drivers.

    if (pGdiDriverInfo == NULL) 
    {
        return;
    }

    ulDriverVersion = ppdev->pldev->ulDriverVersion;

    // Make 'pDriverName' point after the last backslash in the fully
    // qualified driver name:

    pDriverName = wcsrchr(pGdiDriverInfo->DriverName.Buffer, L'\\');

    if (pDriverName != NULL)
        pDriverName++;
    else
        pDriverName = pGdiDriverInfo->DriverName.Buffer;

    if (!_wcsicmp(pDriverName, L"stbv128.dll"))
    {
        // The STB nVidia driver started falling around build 1796.
        // It falls over in the driver on calls from DrawCaptionButtons/
        // BitBltSysBmp/NtGdiBitBlt.  It appears to have a problem when
        // compatible bitmaps are used while DirectDraw is enabled.  As
        // of build 1796, we changed DirectDraw so that it initializes
        // the driver a boot time instead of when the first DirectX
        // application is started.  This appears to have exposed a bug
        // in the driver with compatible bitmaps while DirectDraw is
        // enabled.
        // Note: The driver we tested where this problem occured is
        // STBV128.dll, version(ulDriverVersion) 131072
        // Note: we also tried to disable DrvEnableDirectDraw. But it seems
        // this is not the right fix. The crash occured as well.

        ppdev->apfn[INDEX_DrvCreateDeviceBitmap] = NULL;
    }
    else if (!_wcsicmp(pDriverName, L"s3disp.dll"))
    {
        // Bug#178375, NT4 driver s3disp crashes on SetPointShape().  It
        // sometimes scans past the end of the pointer buffer.

        ppdev->apfn[INDEX_DrvSetPointerShape] = NULL;
    }
    else if ((!_wcsicmp(pDriverName, L"rrctrl1.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl2.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl3.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl4.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl5.dll")) ||
             (!_wcsicmp(pDriverName, L"rrctrl6.dll")))
    {
        // Bug#333453, Quarterdeck/Symantec Rapid Remote driver tries
        // to hook all functionality exported by real display driver,
        // but doesn't support the new NT5 functions.  Limit the driver
        // to >= level 2 accelerations (which also disables DFBs, so
        // we don't need to worry about them hooking unsupported functions
        // there as well).

        if (dwDriverAccelerationsLevel() < 2)
            vSetDriverAccelerationsLevel(2);
    }

    if (bDisplayPDEV())
    {
        dwLevel = dwDriverAccelerationsLevel();
        
        dwOverride = dwDriverCapableOverride();

        if ( dwOverride & DRIVER_NOT_CAPABLE_GDI )
        {
            // If the driver is not capable of GDI, then it is similar to
            // DRIVER_ACCELERATIONS_NONE. Reset the level we stored in PDEV

            dwLevel = DRIVER_ACCELERATIONS_NONE;

            vSetDriverAccelerationsLevel(dwLevel);
        }

        if (dwLevel < DRIVER_ACCELERATIONS_NONE)
        {
            if (dwLevel >= 1)
            {
                // Disable hardware pointers and device bitmaps:
    
                ppdev->apfn[INDEX_DrvSetPointerShape]    = NULL;
                ppdev->apfn[INDEX_DrvCreateDeviceBitmap] = NULL;
            }
            if (dwLevel >= 2)
            {
                // Disable the more sophisticated GDI drawing routines:
    
                pSurface->flags(pSurface->flags() & ~(HOOK_STRETCHBLT        |
                                                      HOOK_PLGBLT            |
                                                      HOOK_FILLPATH          |
                                                      HOOK_STROKEANDFILLPATH |
                                                      HOOK_LINETO            |
                                                      HOOK_STRETCHBLTROP     |
                                                      HOOK_TRANSPARENTBLT    |
                                                      HOOK_ALPHABLEND        |
                                                      HOOK_GRADIENTFILL));
            }
            if (dwLevel >= 3)
            {
                // Disable all DirectDraw and Direct3D accelerations:
                // 
                // Handle by DxDdSetAccelLeve().
            }
            if (dwLevel >= 4)
            {
                // The only GDI accelerations we allow here are the base-line
                // GDI accelerations: DrvTextOut, DrvBitBlt, DrvCopyBits, and
                // DrvStrokePath.
                //
                // NOTE: We also specifically allow DrvMovePointer and
                //       GCAPS_PANNING in case the driver is panning the
                //       display.  (It would be bad if the display doesn't
                //       pan when the user enables safe mode!)
    
                pSurface->flags(pSurface->flags() & (SURF_FLAGS       |
                                                     HOOK_COPYBITS    |
                                                     HOOK_BITBLT      |
                                                     HOOK_TEXTOUT     |
                                                     HOOK_SYNCHRONIZE |
                                                     HOOK_STROKEPATH));

                ppdev->devinfo.flGraphicsCaps &= (GCAPS_PALMANAGED   |
                                                  GCAPS_MONO_DITHER  |
                                                  GCAPS_COLOR_DITHER |
                                                  GCAPS_PANNING      |
                                                  GCAPS_LAYERED);
        
                ppdev->devinfo.flGraphicsCaps2 &= (GCAPS2_SYNCFLUSH |
                                                   GCAPS2_SYNCTIMER);
    
                ppdev->apfn[INDEX_DrvSaveScreenBits]      = NULL;
                ppdev->apfn[INDEX_DrvEscape]              = NULL;
                ppdev->apfn[INDEX_DrvDrawEscape]          = NULL;
                ppdev->apfn[INDEX_DrvResetPDEV]           = NULL;
                ppdev->apfn[INDEX_DrvSetPixelFormat]      = NULL;
                ppdev->apfn[INDEX_DrvDescribePixelFormat] = NULL;
                ppdev->apfn[INDEX_DrvSwapBuffers]         = NULL;

                // Use filtered Blt function.

                ppdev->pfnUnfilteredBitBlt 
                    = (PFN_DrvBitBlt) ppdev->apfn[INDEX_DrvBitBlt];
                ppdev->apfn[INDEX_DrvBitBlt] = (PFN) FilteredBitBlt;
            }

            if ( dwOverride & DRIVER_NOT_CAPABLE_OPENGL )
            {
                // Disable OpenGL routines here

                ppdev->apfn[INDEX_DrvSetPixelFormat]      = NULL;
                ppdev->apfn[INDEX_DrvDescribePixelFormat] = NULL;
                ppdev->apfn[INDEX_DrvSwapBuffers]         = NULL;
            }

            // Call DirectDraw to set accel level.

            DxDdSetAccelLevel(hdev(),dwLevel,dwOverride);
        }
        else
        {
            ASSERTGDI(dwLevel == 5,
                "No-accelerations flag should be modified to reflect change");

            // This case was handled by loading the panning driver.
        }
    }
}

/******************************Public*Routine******************************\
* PDEVOBJ::vProfileDriver()
*
* Profiles the driver to determine what accelerations it supports.
*
* Note that for the multi-mon PDEV, this returns the acceleration 
* capabilities of the primary monitor.
*
\**************************************************************************/

#define PROFILE_DIMENSION 40

VOID PDEVOBJ::vProfileDriver()
{
    DEVBITMAPINFO   dbmi;
    EBLENDOBJ       eBlendObj;
    CLIPOBJ         coClip;
    SURFACE*        psurfScreen;
    BRUSHOBJ        boTransparent;
    BOOL            b;
    HSURF           hsurf;
    RECTL           rclBlt;

    // We only profile display devices.  We could actually do this for
    // printer devices as well, but we would have to re-clear the surface
    // after we did our drawing to it.

    if (!bDisplayPDEV())
        return;

    DEVLOCKOBJ dlo(*this);

    psurfScreen = pSurface();

    XEPALOBJ palScreen(ppalSurf());
    XEPALOBJ palRGB(gppalRGB);
    XEPALOBJ palDefault(ppalDefault);

    // We create the surface fairly big to try and get past drivers that
    // create device surfaces only for 'large' bitmaps.  To test the 
    // driver, we only have to blt a thin strip, though.

    rclBlt.left   = 0;
    rclBlt.top    = 0;
    rclBlt.right  = 16;
    rclBlt.bottom = 1;

    // Fake up a trivial clip object:

    RtlZeroMemory(&coClip, sizeof(coClip));
    coClip.iDComplexity = DC_TRIVIAL;
    coClip.rclBounds    = rclBlt;

    // Ignore any random stuff the driver might have set.  We're going
    // to verify for ourselves what they support!

    GdiInfo()->flShadeBlend = 0;

    // Check whatever we can using a 32bpp surface:

    {
        SURFMEM     SurfDimo;
        EXLATEOBJ   xlo32To32;
        EXLATEOBJ   xloScreenTo32;
        EXLATEOBJ   xlo32ToScreen;

        // Test for per-pixel alpha acceleration.
    
        dbmi.iFormat  = BMF_32BPP;
        dbmi.hpal     = palRGB.hpal();
        dbmi.cxBitmap = PROFILE_DIMENSION;
        dbmi.cyBitmap = PROFILE_DIMENSION;
        dbmi.fl       = BMF_TOPDOWN;
    
        if (SurfDimo.bCreateDIB(&dbmi, NULL))
        {
            if ((xlo32To32.bInitXlateObj(NULL, DC_ICM_OFF, palRGB, palRGB,
                                         palDefault, palDefault, 0, 0, 0)) &&
                (xloScreenTo32.bInitXlateObj(NULL, DC_ICM_OFF, palScreen, palRGB,
                                             palDefault, palDefault, 0, 0, 0)) &&
                (xlo32ToScreen.bInitXlateObj(NULL, DC_ICM_OFF, palRGB, palScreen,
                                             palDefault, palDefault, 0, 0, 0)))
            {
                eBlendObj.BlendFunction.BlendOp             = AC_SRC_OVER;
                eBlendObj.BlendFunction.BlendFlags          = 0;
                eBlendObj.BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
                eBlendObj.BlendFunction.SourceConstantAlpha = 0xff;
                eBlendObj.pxloSrcTo32                       = xlo32To32.pxlo();
                eBlendObj.pxloDstTo32                       = xloScreenTo32.pxlo();
                eBlendObj.pxlo32ToDst                       = xlo32ToScreen.pxlo();

                vDriverPuntedCall(FALSE);

                b = PPFNGET(*this, AlphaBlend, psurfScreen->flags())
                              (psurfScreen->pSurfobj(),
                               SurfDimo.ps->pSurfobj(),
                               &coClip,
                               xlo32ToScreen.pxlo(),
                               &rclBlt,
                               &rclBlt,
                               &eBlendObj);

                if ((b) && (!bDriverPuntedCall()))
                {
                    // WARNING("----- Per-pixel accelerated\n");
                    GdiInfo()->flShadeBlend |= SB_PIXEL_ALPHA;
                    vAccelerated(ACCELERATED_PIXEL_ALPHA);
                }
            }
        }

        // Note that since we didn't apply 'vKeepIt()', the SURFMEM and 
        // EXLATEOBJ destructors will clean up.
    }

    // Check whatever we can using a compatible surface:

    hsurf = hsurfCreateCompatibleSurface(hdev(), 
                                         psurfScreen->iFormat(),
                                         0,
                                         PROFILE_DIMENSION,
                                         PROFILE_DIMENSION,
                                         TRUE);
    if (hsurf)
    {
        SURFREF sr(hsurf);
        ASSERTGDI(sr.bValid(), "Driver returned invalid surface");

        EXLATEOBJ   xloScreenToScreen;
        EXLATEOBJ   xloScreenTo32;
        EXLATEOBJ   xlo32ToScreen;

        if ((xloScreenToScreen.bInitXlateObj(NULL, DC_ICM_OFF, palScreen, palScreen,
                                             palDefault, palDefault, 0, 0, 0)) &&
            (xloScreenTo32.bInitXlateObj(NULL, DC_ICM_OFF, palScreen, palRGB,
                                         palDefault, palDefault, 0, 0, 0)) &&
            (xlo32ToScreen.bInitXlateObj(NULL, DC_ICM_OFF, palRGB, palScreen,
                                         palDefault, palDefault, 0, 0, 0)))
        {
            // Test for constant-alpha acceleration.
    
            eBlendObj.BlendFunction.BlendOp             = AC_SRC_OVER;
            eBlendObj.BlendFunction.BlendFlags          = 0;
            eBlendObj.BlendFunction.AlphaFormat         = 0;
            eBlendObj.BlendFunction.SourceConstantAlpha = 0x85;
            eBlendObj.pxloSrcTo32                       = xloScreenTo32.pxlo();
            eBlendObj.pxloDstTo32                       = xloScreenTo32.pxlo();
            eBlendObj.pxlo32ToDst                       = xlo32ToScreen.pxlo();
    
            vDriverPuntedCall(FALSE);
    
            b = PPFNGET(*this, AlphaBlend, psurfScreen->flags())
                            (psurfScreen->pSurfobj(),
                             sr.ps->pSurfobj(),
                             &coClip,
                             xloScreenToScreen.pxlo(),
                             &rclBlt,
                             &rclBlt,
                             &eBlendObj);
    
            if ((b) && (!bDriverPuntedCall()))
            {
                // WARNING("----- Constant alpha accelerated\n");
                GdiInfo()->flShadeBlend |= SB_CONST_ALPHA;
                vAccelerated(ACCELERATED_CONSTANT_ALPHA);
            }
        }

        // Test for transparent blt acceleration.

        boTransparent.iSolidColor = 1;
        boTransparent.flColorType = 0;

        vDriverPuntedCall(FALSE);

        b = PPFNGET(*this, TransparentBlt, psurfScreen->flags())
                        (psurfScreen->pSurfobj(),
                         sr.ps->pSurfobj(),
                         NULL,
                         NULL,
                         &rclBlt,
                         &rclBlt,
                         1,
                         NULL);

        if ((b) && (!bDriverPuntedCall()))
        {
            // WARNING("----- Transparent blt accelerated\n");
            vAccelerated(ACCELERATED_TRANSPARENT_BLT);
        }
    }

    // Cleanup.

    bDeleteSurface(hsurf);
}

/******************************Public*Routine******************************\
* PDEVOBJ::vDisableSurface()
*
* Disables the surface for the pdev.
*
* Parameters:
*
*   cutype      The CLEANUPTYPE parameter (default value CLEANUP_NONE)
*               is used specify special processing during process cleanup
*               and session cleanup.
*
*               It may be one of the following values:
*
*       Value:              Description
*
*       CLEANUP_NONE        Default.  No special processing.
*
*       CLEANUP_PROCESS     The process cleanup code is used to do
*                           special handling of UMPD; during process
*                           cleanup it is not necessary or desirable
*                           to callback to user-mode to delete
*                           user-mode resources.
*
*       CLEANUP_SESSION     The session cleanup (i.e., hydra shutdown)
*                           code does special handling of HMGR
*                           objects deleted previously by session
*                           cleanup code, but for which stale pointer
*                           may exist in the PDEV.
*
\**************************************************************************/

VOID PDEVOBJ::vDisableSurface(CLEANUPTYPE cutype)
{
    TRACE_INIT(("PDEVOBJ::vDisableSurface: ENTERING\n"));

    //
    // Locate the LDEV.
    //

    PDEVOBJ pdo(hdev());

    //
    // Disable the surface.  Note we don't have to
    // fix up the palette because it doesn't get
    // reference counted when put in the palette.
    //

    //
    // On clone PDEV, those stuff never be enabled.
    // 

    if (!bCloneDriver())
    {
        vDisableSynchronize(hdev());
    }

    vSpDisableSprites(hdev(), cutype);

    //
    // Notify DirectDraw to be disabled.
    //

    DxDdDisableDirectDraw(hdev(),!bCloneDriver());

    if (ppdev->pSurface != NULL)
    {
        SURFREF su(ppdev->pSurface);

        ppdev->pSurface = NULL;

        //
        // Cannot call user-mode driver to delete surface if the user-mode
        // process is gone (i.e., during process or session cleanup).
        //

        if (!pdo.bUMPD() || (cutype == CLEANUP_NONE))
        {
            su.vUnreference();

            (*PPFNDRV(pdo,DisableSurface))(ppdev->dhpdev);
        }
        else
        {
            //
            // If we are here, then this is process or session cleanup
            // and the PDEV is a user-mode driver.  Even though the user-mode
            // portions of the surface are cleaned up as part of the user-mode
            // cleanup, we still need to delete the kernel-mode portion of the
            // surface.
            //

            su.bDeleteSurface(cutype);
        }
    }

    TRACE_INIT(("PDEVOBJ::vDisableSurface: LEAVING\n"));
}

/******************************Member*Function*****************************\
* PDEVOBJ::vReferencePdev()
*
* Adds a reference to the PDEV.
*
\**************************************************************************/

VOID PDEVOBJ::vReferencePdev()
{
    GDIFunctionID(PDEVOBJ::vReferencePdev);

    SEMOBJ so(ghsemDriverMgmt);

    ppdev->cPdevRefs++;
}

extern "C" void vUnmapRemoteFonts(FONTFILEVIEW *);

/***************************************************************************\
*
* VOID vMarkSurfacesWithHDEV.
*
*     Sets hdev of all surfaces in Handle table which reference the PDEV passed
*     in to 0.
*
\***************************************************************************/

VOID vMarkSurfacesWithHDEV(PDEV *ppdev)
{
    SURFACE *pSurface = NULL;
    HOBJ hobj = 0;

    MLOCKFAST mlo;   // Take HandleManager lock so HmgSafeNextObjt can be called

    while (pSurface = (SURFACE*)HmgSafeNextObjt(hobj,SURF_TYPE))
    {
        hobj = (HOBJ) pSurface->hGet();

        if (pSurface->hdev() == (HDEV)ppdev)
        {
            KdPrint(("WARNING: Surface (%p) is owned by HDEV (%p). This HDEV is going to be freed\n", pSurface, ppdev));
            pSurface->hdev((HDEV)0);
        }
    }
}

/******************************Member*Function*****************************\
* PDEVOBJ::vUnreferencePdev()
*
* Removes a reference to the PDEV.  Deletes the PDEV if all references are
* gone.
*
* Parameters:
*
*   cutype      The CLEANUPTYPE parameter (default value CLEANUP_NONE)
*               is used specify special processing during process cleanup
*               and session cleanup.
*
*               It may be one of the following values:
*
*       Value:              Description
*
*       CLEANUP_NONE        Default.  No special processing.
*
*       CLEANUP_PROCESS     The process cleanup code is used to do
*                           special handling of UMPD; during process
*                           cleanup it is not necessary or desirable
*                           to callback to user-mode to delete
*                           user-mode resources.
*
*       CLEANUP_SESSION     The session cleanup (i.e., hydra
*                           shutdown) code does special handling of
*                           HMGR objects deleted previously by session
*                           cleanup code, but for which stale pointer
*                           may exist in the PDEV (for example, palettes).
*
* Note: special session cleanup handling is usually only needed for HMGR
* objects for which the PDEV has cached a pointer.  Objects referenced
* via a handle are safe if they are locked via the HMGR table (if the
* object has already been deleted, then the handle is invalid and the
* lock attempt will fail).
*
\**************************************************************************/

VOID PDEVOBJ::vUnreferencePdev(CLEANUPTYPE cutype)
{
    GDIFunctionID(PDEVOBJ::vUnreferencePdev);

    HANDLE hSpooler = NULL;
    ULONG  cPdevRefs;
    BOOL   bUMPD = ppdev->fl  & PDEV_UMPD;

    //
    // Decrement reference count and remove from list if last reference.
    // This must be done under the protection of the driver mgmt semaphore.
    //

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

    cPdevRefs = --(ppdev->cPdevRefs);

    if (cPdevRefs == 0)
    {
        TRACE_INIT(("PDEVOBJ::vCommonDelete: destroying a PDEV\n"));

        //
        // Delete it from the list.
        //

        if (gppdevList == ppdev)
        {
            gppdevList = ppdev->ppdevNext;
        }
        else
        {
            PDEV *pp;

            for (pp = gppdevList; pp != NULL; pp = pp->ppdevNext)
            {
                if (pp->ppdevNext == ppdev)
                {
                    pp->ppdevNext = ppdev->ppdevNext;
                    break;
                }
            }
        }

    #if DBG

        //
        // If this is DDML driver, make sure one other PDEV referecnes
        // this PDEV as parent.
        //

        if (bMetaDriver())
        {
            PDEV *pp;

            for (pp = gppdevList; pp != NULL; pp = pp->ppdevNext)
            {
                if (pp->ppdevParent == ppdev)
                {
                    WARNING("Deleting parent PDEV which still used\n");
                }
            }
        }

    #endif
    }

    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    //
    // If last reference, delete the PDEV and its resources.  We do this
    // outside of the driver mgmt semaphore because it could cause a
    // deadlock if we need to call back to user-mode (i.e., UMPD).
    //

    if (cPdevRefs == 0)
    {
        //
        // Since we are going to delete this PDEV, there shouldn't be any
        // active RFONTs lying around for this PDEV.
        //

        ASSERTGDI(ppdev->prfntActive == NULL,
            "active rfonts on pdev being deleted!\n");

        //
        // Ordinarily, we would grab the ghsemRFONTList semaphore because
        // we are going to access the RFONT list.  However, since we're in
        // the process of tearing down the PDEV, we don't really need to.
        //

        //
        // Delete all the rfonts on the PDEV.
        //

        PRFONT prfnt;
        while ( (prfnt = ppdev->prfntInactive) != (PRFONT) NULL )
        {
            RFONTTMPOBJ rflo(prfnt);
            PFFOBJ pffo(rflo.pPFF());

            ASSERTGDI (
                pffo.bValid(),
                "bad HPFF"
                );

            rflo.bDeleteRFONT(this, &pffo);  // bDelete keeps the list head ptrs updated
        }

        //
        // If device fonts exist, remove them
        //

        if ((ppdev->devinfo.cFonts != 0) && bGotFonts())
        {
            PFF *pPFF = 0;
            PFF **ppPFF;

            GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);

            DEVICE_PFTOBJ pfto;
            pPFF = pfto.pPFFGet(hdev(), &ppPFF);

            if (!pfto.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, 0))
            {
                WARNING("couldn't unload device fonts\n");
            }
        }

        //
        // If a type one font list exists dereference it
        //

        if(ppdev->TypeOneInfo)
        {
            PTYPEONEINFO FreeTypeOneInfo;

            FreeTypeOneInfo = NULL;

            GreAcquireFastMutex(ghfmMemory);
            ppdev->TypeOneInfo->cRef -= 1;

            if(!ppdev->TypeOneInfo->cRef)
            {
                //
                // Don't free pool while holding a mutex.
                //

                FreeTypeOneInfo = ppdev->TypeOneInfo;
            }

            GreReleaseFastMutex(ghfmMemory);

            if (FreeTypeOneInfo)
            {
                VFREEMEM(FreeTypeOneInfo);
            }
        }

        //
        // If any remote type one fonts exist free those
        //

        PREMOTETYPEONENODE RemoteTypeOne = ppdev->RemoteTypeOne;

        while(RemoteTypeOne)
        {
            PVOID Tmp = (PVOID) RemoteTypeOne;

            //
            // ulRegionSize and hSpoolerSecure will be stored in the PFM fileview
            //

            RemoteTypeOne->fvPFM.cRefCountFD = 1;
            vUnmapRemoteFonts(&RemoteTypeOne->fvPFM);
            RemoteTypeOne = RemoteTypeOne->pNext;
            VFREEMEM(Tmp);

            WARNING1("Freeing Type1\n");
        }

        //
        // Delete GammaRamp table, if allocated.
        //

        if (ppdev->fl & PDEV_GAMMARAMP_TABLE)
        {
            VFREEMEM(ppdev->pvGammaRampTable);
        }

        if (ppdev->ppdevDevmode)
        {
            VFREEMEM(ppdev->ppdevDevmode);
        }

        if (!bCloneDriver())
        {
            //
            // Destroy the LFONTs.
            //

            if (ppdev->hlfntDefault != STOCKOBJ_SYSFONT)
                bDeleteFont(ppdev->hlfntDefault, TRUE);

            if (ppdev->hlfntAnsiVariable != STOCKOBJ_SYSFONT)
                bDeleteFont(ppdev->hlfntAnsiVariable, TRUE);

            if (ppdev->hlfntAnsiFixed != STOCKOBJ_SYSFIXEDFONT)
                bDeleteFont(ppdev->hlfntAnsiFixed, TRUE);

            //
            // Delete the patterns if they are created by the graphics engine on the
            // behalf of the driver.
            // This is what happends for all display drivers.
            //

            if (ppdev->fl & PDEV_DISPLAY)
            {
                for (int iPat = 0; iPat < HS_DDI_MAX; iPat++)
                {
                    bDeleteSurface(ppdev->ahsurf[iPat]);
                }
            }
        }

        //
        // Disable the surface for the pdev.
        //

        vDisableSurface(cutype);

        //
        // Destroy the device halftone info.
        //

        if (ppdev->pDevHTInfo != NULL)
        {
            bDisableHalftone();
        }

        //
        // Nuke the realized gray pattern brush (used to draw the
        // drag rectangles).  Normally, the EBRUSHOBJ destructor
        // will decrement the realized brush ref counts.  However,
        // the EBRUSHOBJ cached in the PDEV is allocated as part
        // of the PDEV so never invokes a destructor.  Therefore,
        // we need to force the realized brushes out explicitly.
        //

        pbo()->vNuke();

        if (!bCloneDriver())
        {
            //
            // Unreference the palette we used for this PDEV.
            //
            // If session cleanup (i.e., Hydra) the palettes are already
            // deleted; therefore, should skip.
            //

            if (cutype != CLEANUP_SESSION)
            {
                if (ppdev->ppalSurf)
                {
                    DEC_SHARE_REF_CNT(ppdev->ppalSurf);
                }
            }

            //
            // Disable the driver's PDEV.
            //
            // We do this odd check to ensure that the driver's DrvDisablePDEV
            // address isn't the same as its DrvEnablePDEV address because an
            // early beta NetMeeting driver had a bug where its table entries
            // for INDEX_DrvEnablePDEV and INDEX_DrvDisablePDEV were the same
            // (this was in SP3 before we enabled dynamic mode changes for
            // DDML drivers).  We made a change recently (this is still before
            // SP3 has shipped, which enabled the DDML) so that we refuse to
            // load DDML drivers that don't have GCAPS_LAYERRED set -- but we
            // have to load the driver first before we can check GCAPS_LAYERED.
            // So if it doesn't have GCAPS_LAYERED set, we have to unload the
            // driver -- but this old NetMeeting driver had a bad DisablePDEV
            // routine!
            //
            // At any rate, to work around the problem where someone has the
            // beta version of the NetMeeting driver installed (which shipped
            // with the IE4 beta and has the DisablePDEV bug) and then upgrades
            // to retail SP3, we simply don't call the driver's bad DisablePDEV
            // routine.  The driver will likely leak memory, but this happens
            // only once per boot and is better than a blue screen.
            //

            if (PPFNDRV((*this),DisablePDEV) != (PFN_DrvDisablePDEV)
                PPFNDRV((*this),EnablePDEV))
            {
                //
                // If the user mode process is gone (i.e, during session
                // or process cleanup), don't callout to user mode.
                //

                if (!bUMPD || (cutype == CLEANUP_NONE))
                    (*PPFNDRV((*this),DisablePDEV))(ppdev->dhpdev);
            }

            //
            // Remove the LDEV reference.
            //
            if (!bUMPD)
                 ldevUnloadImage(ppdev->pldev);
            else
                 UMPD_ldevUnloadImage(ppdev->pldev);

            // If this PDEV referenced an enabled physical device
            // then release its usage for this session.
            if (!bDisabled() && ppdev->pGraphicsDevice != NULL)
            {
                bSetDeviceSessionUsage(ppdev->pGraphicsDevice, FALSE);
            }
        }

        TRACE_INIT(("PDEVOBJ::vCommonDelete: Closing Device handle.\n"));

        if (ppdev->fl & PDEV_PRINTER)
        {
            //
            //  note the spool handle so we can close connection outside
            //  of the spooler management semaphore
            //

            hSpooler = ppdev->hSpooler;
        }

#ifdef DDI_WATCHDOG

        //
        // Stop and free all watchdogs.
        //

        GreDeleteWatchdogs(ppdev->pWatchdogData, WD_NUMBER);
        ppdev->pWatchdogData = NULL;

        //
        // Delete watchdog context.
        //

        GreDeleteWatchdogContext(ppdev->pWatchdogContext);
        ppdev->pWatchdogContext = NULL;

#endif  // DDI_WATCHDOG

        //
        // Free the locks as one of the last steps, in case any of the
        // above decides to try and acquire the locks.
        //

        //
        // If hsemDevLock points "shared devlock", don't delete it.
        //
        if (!(ppdev->fl & PDEV_SHARED_DEVLOCK))
        {
            if (ppdev->hsemDevLock)
            {
                GreDeleteSemaphore(ppdev->hsemDevLock);
            }
        }

        if (ppdev->fl & PDEV_DISPLAY)
        {
            GreDeleteSemaphore(ppdev->hsemPointer);
        }

        // See if there are any surfaces in the handle table still referencing
        // this PDEV. If so mark them such that the bDeleteSurface call will
        // not touch anything which refers the PDEV.

        vMarkSurfacesWithHDEV(ppdev);

        //
        // Free the PDEV.
        //

        VFREEMEM(ppdev);

        ppdev = (PDEV *) NULL;
    }
    
    //
    // this needs to be done outside of the driver management semaphore
    //

    if (!bUMPD && hSpooler)
    {
        ClosePrinter(hSpooler);
    }
}

/******************************Member*Function*****************************\
* PDEVOBJ::vSync()
*
* If the surface hooks synchronization then call the hook.  Note, if
* provided we will call DrvSynchronizeSurface otherwise we will call
* DrvSynchronize.
*
\**************************************************************************/

VOID PDEVOBJ::vSync(
    SURFOBJ*    pso,
    RECTL*      prcl,
    FLONG       fl)
{
    PSURFACE pSurf  = SURFOBJ_TO_SURFACE(pso);

    if(pSurf->flags() & HOOK_SYNCHRONIZE)
    {
        if (!bDisabled())
        {
            if(ppdev->pfnSyncSurface != NULL)
                (ppdev->pfnSyncSurface)(pso, prcl, fl);
            else
                (ppdev->pfnSync)(pso->dhpdev, prcl);
        }
    }
}

/******************************Member*Function*****************************\
* PDEVOBJ::vNotify()
*
* If the driver supplies DrvNotify, then call it.
*
\**************************************************************************/

VOID PDEVOBJ::vNotify(
    ULONG   iType,
    PVOID   pvData)
{
    if(ppdev->pfnNotify != NULL)
    {
        (ppdev->pfnNotify)(ppdev->pSurface->pSurfobj(), iType, pvData);
    }
}

/******************************Member*Function*****************************\
* PDEVOBJ::bDisabled()
*
* Marks a PDEV as enabled or disabled, and modifies all updates the
* cached state in all affected DCs.
*
* NOTE: This assumes the DEVLOCK is held.
*
\**************************************************************************/

BOOL PDEVOBJ::bDisabled
(
    BOOL bDisable
)
{
    HDEV    hdev;
    HOBJ    hobj;
    DC     *pdc;

    ASSERTGDI(bDisplayPDEV(), "Expected only display devices");

    SETFLAG(bDisable, ppdev->fl, PDEV_DISABLED);

    hdev = (HDEV) ppdev;

    //
    // We have to hold the handle manager lock while we traverse all
    // the handle manager objects.
    //

    MLOCKFAST mo;

    hobj = 0;
    while (pdc = (DC*) HmgSafeNextObjt(hobj, DC_TYPE))
    {
        hobj = (HOBJ) pdc->hGet();

        if ((pdc->dctp() == DCTYPE_DIRECT) &&
            (pdc->hdev() == hdev))
        {
            pdc->bInFullScreen(bDisable);
        }
    }

    return(ppdev->fl & PDEV_DISABLED);
}

#if DBG

/******************************Member*Function*****************************\
* PDEVOBJ::AssertDevLock()
*
*   This routine verifies that the DevLock is held.
*
\**************************************************************************/

VOID PDEVOBJ::vAssertDevLock()
{

#if !defined(_GDIPLUS_)

    ASSERTGDI(!bDisplayPDEV()                                       ||
              GreIsSemaphoreOwnedByCurrentThread(hsemDevLock()),
              "PDEVOBJ: Devlock not held");

#endif

}

/******************************Member*Function*****************************\
* PDEVOBJ::AssertNoDevLock()
*
*   This routine verifies that the DevLock is not held.
*
\**************************************************************************/

VOID PDEVOBJ::vAssertNoDevLock()
{
#if !defined(_GDIPLUS_)

    ASSERTGDI(!bDisplayPDEV()                                       ||
              !GreIsSemaphoreOwnedByCurrentThread(hsemDevLock()),
              "PDEVOBJ: Devlock held");

#endif
}

/******************************Member*Function*****************************\
* PDEVOBJ::AssertDynaLock()
*
*   This routine verifies that appropriate locks are held before accessing
*   DC fields that may otherwise be changed asynchronously by the dynamic
*   mode-change code.
*
\**************************************************************************/

VOID PDEVOBJ::vAssertDynaLock()
{
    //
    // One of the following conditions is enough to allow the thread
    // to safely access fields that may be modified by the dyanmic
    // mode changing:
    //
    // 1.  It's a non-display device -- this will not change modes;
    // 2.  That the USER semaphore is held;
    // 3.  That the DEVLOCK is held for this object;
    // 4.  That the DEVLOCK is held for this object's parent;
    // 5.  That the Palette semaphore is held;
    // 6.  That the Handle Manager semaphore is held;
    // 7.  That the Pointer semaphore is held;
    // 8.  That the driver management semaphore is held;
    // 9.  That the parent's pointer Semaphore is held.
    // 10. The pdev is being torn down (i.e., cPdevRefs == 0).
    //

#if !defined(_GDIPLUS_)

    ASSERTGDI(!bDisplayPDEV()                                         ||
              (ppdev->cPdevRefs == 0)                                 ||
              UserIsUserCritSecIn()                                   ||
               GreIsSemaphoreOwnedByCurrentThread(hsemDevLock())      ||
               GreIsSemaphoreOwnedByCurrentThread(
                                  ppdev->ppdevParent->hsemDevLock)    ||
               GreIsSemaphoreSharedByCurrentThread(ghsemShareDevLock) ||
               GreIsSemaphoreOwnedByCurrentThread(ghsemPalette)       ||
               GreIsSemaphoreOwnedByCurrentThread(ghsemHmgr)          ||
               GreIsSemaphoreOwnedByCurrentThread(hsemPointer())      ||
               GreIsSemaphoreOwnedByCurrentThread(ghsemDriverMgmt)    ||
              ((ppdev->ppdevParent != NULL) &&
                GreIsSemaphoreOwnedByCurrentThread(ppdev->ppdevParent->hsemPointer)),
              "PDEVOBJ: A dynamic mode change lock must be held to access this field");

#endif

}

/******************************Member*Function*****************************\
* PDEVOBJ::ppfn()
*
*   This routine verifies that appropriate locks are held before accessing
*   the dispatch table for a PDEV for function pointers that could otherwise
*   be changed asynchronously by a dynamic mode change.
*
\**************************************************************************/

PFN PDEVOBJ::ppfn(ULONG i)
{
    //
    // Font producers and some types of font consumers are not allowed to
    // do dynamic mode changes.  As such, accessing the dispatch table
    // entries specific to those types of drivers does not have to occur
    // under a lock.
    //
    // Note that if this list is expanded, it should also be changed in
    // 'bMatchEnoughForDynamicModeChange':
    //

    if ((i != INDEX_DrvQueryFontCaps) &&
        (i != INDEX_DrvLoadFontFile) &&
        (i != INDEX_DrvQueryFontFile) &&
        (i != INDEX_DrvGetGlyphMode))
    {
        vAssertDynaLock();
    }

    return(ppdev->apfn[i]);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pffobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pffobj.cxx
*
* Non-inline methods for physical font file objects.
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern PW32PROCESS gpidSpool;

// Define the global PFT semaphore.  This must be held to access any of the
// physical font information.

#if DBG
extern FLONG gflFontDebug;
#endif

extern "C" void FreeFileView(PFONTFILEVIEW *ppfv, ULONG cFiles);
extern "C" ULONG ComputeFileviewCheckSum(PVOID, ULONG);

ULONG ComputeFileviewCheckSum(PVOID pvView, ULONG cjView)
{
    ULONG sum;
    PULONG pulCur,pulEnd;

    pulCur = (PULONG) pvView;

    __try
    {
        for (sum = 0, pulEnd = pulCur + cjView / sizeof(ULONG); pulCur < pulEnd; pulCur += 1)
        {
            sum += 256 * sum + *pulCur;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("win32k: exception while computing font check sum\n");
        sum = 0; // oh well, not very unique.
    }

    return ( sum < 2 ) ? 2 : sum;  // 0 is reserved for device fonts
                                      // 1 is reserved for TYPE1 fonts
}

PFFMEMOBJ::PFFMEMOBJ(
    PFF     *pPFFCloned,
    FLONG   fl,             // indicates if a permanent font
    FLONG   flEmbed,         // embedding flag
    PFT     *pPFTParent      // contains this pff
)
{
    if ( pPFF = (PFF *) PALLOCMEM((size_t)pPFFCloned->sizeofThis, 'ffpG'))
    {
        RtlCopyMemory((PBYTE) pPFF, (PBYTE) pPFFCloned, offsetof(PFF,aulData));

        pPFF->pPFFPrev      = 0;
        pPFF->pPFFNext      = 0;

    // Wet the implicit stuff.

        pPFF->cFonts        = 0;       // faces not loaded into table yet
        pPFF->cRFONT        = 0;       // nothing realized from this file yet
        pPFF->flState       = fl;
        pPFF->pfhFace       = 0;
        pPFF->pfhFamily     = 0;
        pPFF->pfhUFI        = 0;
        pPFF->prfntList     = 0;       // initialize to NULL list
        pPFF->pPFT          = pPFTParent;

        pPFF->pPvtDataHead  = NULL;    // initialize to NULL link list

    // loaded with FR_PRIVATE, FR_PRIVATE | FR_NOT_ENUM, FRW_EMB_PID, FRW_EMB_TID
    // the load count (cPirvate or cNotEnum) is initialized in PvtData structure per process

        if (flEmbed & (FR_PRIVATE | FRW_EMB_PID | FRW_EMB_TID))
        {
            pPFF->cLoaded   = 0;
            pPFF->cNotEnum  = 0;
            bAddPvtData(flEmbed);
        }

    // file is loaded as NOT_ENUM only

        else if ( flEmbed & FR_NOT_ENUM )
        {
            pPFF->cLoaded   = 0;
            pPFF->cNotEnum  = 1;
        }

    // file is loaded as public

        else
        {
            pPFF->cLoaded   = 1;
            pPFF->cNotEnum  = 0;
        }

    // Mark this PFF as cloned
        pPFFCloned->pPFFClone = pPFF;
        pPFF->pPFFClone = pPFFCloned;

    }
    else
    {
        WARNING("invalid PFFMEMOBJ\n");
    }
}

/******************************Public*Routine******************************\
* PFFMEMOBJ::PFFMEMOBJ
*
* Constructor for default sized physical font file memory object.
*
* cFonts = # fonts in file or device
* pwsz   = pointer to upper case Unicode string containing the full
*          path to the font file. This pointer is set to zero, by
*          default for fonts loaded from a device.
*
* History:
*  Thu 01-Sep-1994 06:29:47 by Kirk Olynyk [kirko]
* Put the size calculation logic in the constructor thereby modularizing
* and shrinking the code.
*  Tue 09-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Remove from handle manager
*  02-Jan-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PFFMEMOBJ::PFFMEMOBJ(
    unsigned cFonts          // number of fonts in file|device
  , PWSZ     pwsz            // if font file this is an upper case path
  , ULONG    cwc             // number of characters in the mul path above
  , ULONG    cFiles          // number of files
  , DESIGNVECTOR *pdv        // design vector, only present for mm instances
  , ULONG         cjDV       // size of design vector
  , HFF      hffFontFile     // IFI driver's handle to file
  , HDEV     hdevDevice      // physical device handle
  , DHPDEV   dhpdevDevice    // driver's pdev handle
  , PFT     *pPFTParent      // contains this pff
  , FLONG    fl              // indicates if a permanent font
  , FLONG    flEmbed         // embedding flag
  , PFNTCHECKSUM    pFntCheckSum
  , PFONTFILEVIEW   *ppfv      // ptr to FILEVIEW structure
  , PUNIVERSAL_FONT_ID  pufi // ptr to original UFI used in remote printing
  )
{
    ULONG size = offsetof(PFF,aulData) + cFonts * sizeof(PFE*);
    ULONG dpDV = 0;
    ULONG dpPathName = 0;

    ASSERTGDI(hdevDevice, "PFFMEMOBJ passed NULL hdevDevice\n");
    ASSERTGDI(pFntCheckSum, "pFntCheckSum is NULL\n");

    if (pwsz)
    {
        dpPathName = size;
        size += ALIGN4(cwc*sizeof(WCHAR));
    }

    if (cjDV)
    {
        dpDV = size;
        size += cjDV;
    }

    if (pPFF = (PFF *) PALLOCMEM(size, 'ffpG'))
    {
        fs = 0;

        pPFF->sizeofThis    = size;
        pPFF->pPFFPrev      = 0;
        pPFF->pPFFNext      = 0;
        pPFF->hff           = hffFontFile;
        pPFF->hdev          = hdevDevice;
        pPFF->dhpdev        = dhpdevDevice;
        pPFF->pPFT          = pPFTParent;
        pPFF->cFiles        = cFiles;

        pPFF->cwc           = cwc;
        if (cwc)
        {
            pPFF->pwszPathname_ = (PWSZ)((BYTE *)pPFF + dpPathName);
            RtlCopyMemory(pPFF->pwszPathname_, pwsz, cwc * sizeof(WCHAR));
        }
        else
        {
            pPFF->pwszPathname_ = 0;
        }

        pPFF->cjDV_ = cjDV;
        if (cjDV)
        {
            pPFF->pdv_ = (DESIGNVECTOR *)((BYTE *)pPFF + dpDV);
            RtlCopyMemory(pPFF->pdv_, pdv, cjDV);
        }
        else
        {
            pPFF->pdv_ = NULL;
        }

        pPFF->ppfv          = ppfv;

    // Wet the implicit stuff.

        pPFF->cFonts        = 0;       // faces not loaded into table yet
        pPFF->cRFONT        = 0;       // nothing realized from this file yet
        pPFF->flState       = fl;
        pPFF->pfhFace       = 0;
        pPFF->pfhFamily     = 0;
        pPFF->pfhUFI        = 0;
        pPFF->prfntList     = 0;       // initialize to NULL list

        pPFF->pPvtDataHead  = NULL;    // initialize to NULL link list

    // loaded with FR_PRIVATE, FR_PRIVATE | FR_NOT_ENUM, FRW_EMB_PID, FRW_EMB_TID
    // the load count (cPirvate or cNotEnum) is initialized in PvtData structure per process

        if (flEmbed & (FR_PRIVATE | FRW_EMB_PID | FRW_EMB_TID))
        {
            pPFF->cLoaded   = 0;
            pPFF->cNotEnum  = 0;
            bAddPvtData(flEmbed);
        }

    // file is loaded as NOT_ENUM only

        else if ( flEmbed & FR_NOT_ENUM )
        {
            pPFF->cLoaded   = 0;
            pPFF->cNotEnum  = 1;
        }

    // file is loaded as public

        else
        {
            pPFF->cLoaded   = 1;
            pPFF->cNotEnum  = 0;
        }

    // Mark this PFF as not cloned

        pPFF->pPFFClone = NULL;

        pPFF->ulCheckSum = 0; // for device fonts it is zero

        if(pufi != NULL)
        {
            pPFF->ulCheckSum = pufi->CheckSum;
        }
        else
        {
            if (ppfv != NULL)
            {

                pPFF->ulCheckSum = pFntCheckSum->ulCheckSum;


                if (!pPFF->ulCheckSum)
                {
                // not in the boot, or could not find it in the ttfcache for some reason
                // Now compute the UFI

                    KeAttachProcess(PsGetProcessPcb(gpepCSRSS));
                    for (ULONG iFile = 0; iFile < cFiles; iFile ++)
                    {
                        pPFF->ulCheckSum += ComputeFileviewCheckSum(ppfv[iFile]->fv.pvViewFD, ppfv[iFile]->fv.cjView);
                    }
                    KeDetachProcess();

                    PutFNTCacheCheckSum(pFntCheckSum->ulFastCheckSum, pPFF->ulCheckSum);
                }

                ASSERTGDI(pPFF->ulCheckSum, "pPFF->ulCheckSum must not be zero\n");

                if (pPFF->cjDV_)
                {
                    pPFF->ulCheckSum += ComputeFileviewCheckSum(pdv, cjDV);
                }
            }

#if 0
        // do it old way, and compare values in DBG mode

            if (ppfv != NULL)
            {
                ULONG   ulCheckSumTest = 0;

            // Now compute the UFI

                KeAttachProcess(PsGetProcessPcb(gpepCSRSS));
                for (ULONG iFile = 0; iFile < cFiles; iFile ++)
                {
                    ulCheckSumTest += ComputeFileviewCheckSum(ppfv[iFile]->fv.pvViewFD, ppfv[iFile]->fv.cjView);
                }
                KeDetachProcess();

                if (pPFF->cjDV_)
                {
                    ulCheckSumTest += ComputeFileviewCheckSum(pdv, cjDV);
                }

                if (ulCheckSumTest != pPFF->ulCheckSum)
                {
                    DbgPrint(" TrueType font cache failed, if you see these message \n");
                    DbgPrint(" Please contact YungT or NTFonts \n");
                    DbgPrint(" it is ok to hit 'g' \n");
                    DbgBreakPoint();
                }
            }
#endif
        }
    }
    else
    {
        WARNING("invalid PFFMEMOBJ\n");
    }
}

/******************************Public*Routine******************************\
* PFFMEMOBJ::~PFFMEMOBJ()
*
* Destructor for physical font file memory object.
*
* History:
*  Tue 09-Nov-1993 -by- Patrick Haluptzok [patrickh]
* Remove from handle manager
*
*  02-Jan-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PFFMEMOBJ::~PFFMEMOBJ()
{
    if ((fs & PFFMO_KEEPIT) == 0)
    {
        if (pPFF)
        {
            VFREEMEM(pPFF);
        }
    }
}

/******************************Public*Routine******************************\
* BOOL PFFOBJ::bCreatePFEC(ULONG cFonts)
*
* Create the handle of PFE collect, a object to reduce the consumption of object handle
*
* Returns:
*   TRUE means we create successfully
*
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bCreatePFEC(ULONG cFonts)
{
    BOOL  bRet = FALSE;

    ASSERTGDI(cFonts, "PFFOBJ::bCreateHPFE cFonts is zero \n");
    
    pPFF->pPFEC = (PFEC *) HmgAlloc(sizeof(PFEC), PFE_TYPE, HMGR_ALLOC_ALT_LOCK | HMGR_MAKE_PUBLIC);

    if (pPFF->pPFEC)
    {
        pPFF->pPFEC->pvPFE = (PVOID) PALLOCMEM(SZ_PFE(gcfsCharSetTable) * cFonts, 'efpG');
        pPFF->pPFEC->cjPFE = SZ_PFE(gcfsCharSetTable);
        
        if (pPFF->pPFEC->pvPFE)
            bRet = TRUE;
        else
        {
            HmgFree((HOBJ)pPFF->pPFEC->hGet());
            pPFF->pPFEC = NULL;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* VOID PFFOBJ::vDeletePFEC(PVOID *ppvPFE)
*
* Delete the handle of PFE collect, a object to reduce the consumption of object handle
*
* Returns:
*   None
*
* History:
*
*  2-June-1996 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vDeletePFEC(PVOID *ppvPFE)
{
    *ppvPFE = NULL;
    
    if (pPFF->pPFEC != NULL)
    {
        *ppvPFE = pPFF->pPFEC->pvPFE;
        HmgFree((HOBJ)pPFF->pPFEC->hGet());
        pPFF->pPFEC = NULL;
    }
}

/******************************Public*Routine******************************\
* PFFOBJ::bAddHash
*
* Adds the PFF and all its PFEs to the font hashing table.  The font
* hashing tabled modified is in the PFT if a font driver managed font;
* otherwise, the font hashing table is in the PFF itself.
*
* The caller should hold the ghsemPublicPFT while calling this function.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  11-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bAddHash(BOOL bEUDC)
{
// Caller must hold the ghsemPublicPFT semaphore to protect access to
// the hash tables.

//
// Add the entry to the appropriate font hash tables
//
    FONTHASH **ppfhFace, **ppfhFamily,**ppfhUFI;

    if (!bDeviceFonts())
    {
    //
    // Hash tables for the font driver loaded fonts exist off of
    // the font table.
    //
        PUBLIC_PFTOBJ pfto( bInPrivatePFT() ? gpPFTPrivate : gpPFTPublic );
        ASSERTGDI(pfto.bValid(),"PFFOBJ::vAddHash -- invalid Public PFTOBJ\n");

        ppfhFace   = &(pfto.pPFT->pfhFace);
        ppfhFamily = &(pfto.pPFT->pfhFamily);
        ppfhUFI = &(pfto.pPFT->pfhUFI);

    //
    // If this is a TrueType font, increment the count.
    //
        if ( pPFF->hdev == (HDEV) gppdevTrueType )
        {
            gcTrueTypeFonts++;              // protected by ghsemPublicPFT
        }
    }
    else
    {
    //
    // Hash tables for device fonts exist off of the PFF that
    // encapsulates them.
    //

#if DBG
        if (gflFontDebug & DEBUG_FONTTABLE)
        {
            RIP("\n\n[kirko] PFFMEMOBJ::vAddHash -- Adding to the Driver's font hash table\n\n");
        }
#endif

        ppfhFace   = &pPFF->pfhFace;
        ppfhFamily = &pPFF->pfhFamily;
        ppfhUFI = &pPFF->pfhUFI;
    }

//
// Now that we have figured out where the tables are, add the PFEs to them.
//
    FHOBJ fhoFamily(ppfhFamily);
    FHOBJ fhoFace(ppfhFace);
    FHOBJ fhoUFI(ppfhUFI);

    ASSERTGDI(fhoFamily.bValid(), "bAddHashPFFOBJ(): fhoFamily not valid\n");
    ASSERTGDI(fhoFace.bValid(), "bAddHashPFFOBJ(): fhoFace not valid\n");
    ASSERTGDI(fhoUFI.bValid(), "bAddHashPFFOBJ(): fhoUFI not valid\n");

    if (! (fhoUFI.bValid() && fhoFamily.bValid() && fhoFace.bValid()))
        return FALSE;
        
    for (COUNT c = 0; c < pPFF->cFonts; c++)
    {
        PFEOBJ  pfeo(((PFE **) (pPFF->aulData))[c]);
        ASSERTGDI(pfeo.bValid(), "bAddHashPFFOBJ(): bad HPFE\n");

        if(!fhoUFI.bInsert(pfeo) )
        {
            WARNING("PFFOBJ::bAddHash -- fhoUFI.bInsert failed\n");
            return FALSE;
        }

    // If we only need to add it to the UFI hash table (we need to add it there
    // so that the remote printing code can request the bits of it needs to).

        if(bEUDC)
        {
            continue;
        }

        if (!fhoFamily.bInsert(pfeo))
        {
            WARNING("PFFOBJ::bAddHash -- fhoFamily.bInsert failed\n");
            return FALSE;
        }

         #if DBG
        if (gflFontDebug & DEBUG_FONTTABLE)
        {
            DbgPrint("PFFMEMOBJ::vAddHash(\"%ws\")\n",pfeo.pwszFamilyName());
        }
        // Need level 2 checking to see this.
        if (gflFontDebug & DEBUG_FONTTABLE_EXTRA)
        {
            fhoFamily.vPrint((VPRINT) DbgPrint);
        }
        #endif


        #if DBG
        if (gflFontDebug & DEBUG_FONTTABLE)
        {
            UNIVERSAL_FONT_ID ufi;
            pfeo.vUFI(&ufi);
            DbgPrint("PFFMEMOBJ::vAddHash(\"%x\")\n",ufi.CheckSum);
        }
        // Need level 2 checking to see this.
        if (gflFontDebug & DEBUG_FONTTABLE_EXTRA)
        {
            fhoUFI.vPrint((VPRINT) DbgPrint);
        }
        #endif

        if(!fhoFace.bInsert(pfeo))
        {
            WARNING("PFFMEMOBJ::vAddHash -- fhoFace.bInsert failed\n");
            return FALSE;
        }

        #if DBG
        if (gflFontDebug & DEBUG_FONTTABLE)
        {
            DbgPrint("gdisrv!PFFMEMOBJ::vAddHash(\"%ws\")\n",pfeo.pwszFaceName());
        }
        if (gflFontDebug & DEBUG_FONTTABLE_EXTRA)
        {
            fhoFace.vPrint((VPRINT) DbgPrint);
        }
        #endif
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* PFFOBJ::vRemoveHash
*
* Removes the PFF and all its PFEs from the font hashing table, preventing
* the font from being enumerated or mapped.
*
* The caller should hold the ghsemPublicPFT while calling this function.
*
* History:
*  10-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vRemoveHash ()
{
// Caller must hold the ghsemPublicPFT semaphore to protect access to
// the hash tables.

    if (bDeviceFonts())
    {
    //
    // Hash tables for device fonts exist off of the PFF that
    // encapsulates the device fonts.  Font driver loaded fonts
    // are handled later while deleting the PFEs.
    //

    //
    // Kill the entire table for the device. No more processing
    // of font hash table stuff is necssary for device fonts
    // after we leave this scope.
    //

        FHOBJ fhoFace(&(pPFF->pfhFace));
        if (fhoFace.bValid())
        {
            fhoFace.vFree();
        }

        FHOBJ fhoFamily(&(pPFF->pfhFamily));
        if (fhoFamily.bValid())
        {
            fhoFamily.vFree();
        }

        FHOBJ fhoUFI(&(pPFF->pfhUFI));
        if (fhoUFI.bValid())
        {
            fhoUFI.vFree();
        }
    }

    else
    {
        PUBLIC_PFTOBJ pfto( bInPrivatePFT() ? gpPFTPrivate : gpPFTPublic );
        ASSERTGDI(pfto.bValid(),"vRemoveHashPFFOBJ(): invalid PFTOBJ\n");

        //
        // Hash tables for the font driver managed fonts exist off of
        // the font table (PFT).
        //

        FHOBJ fhoFace(&(pfto.pPFT->pfhFace));
        FHOBJ fhoFamily(&(pfto.pPFT->pfhFamily));
        FHOBJ fhoUFI(&(pfto.pPFT->pfhUFI));

        for (COUNT c = 0; c < pPFF->cFonts; c++)
        {
            PFEOBJ pfeo(((PFE **) (pPFF->aulData))[c]);
            ASSERTGDI(pfeo.bValid(), "vRemoveHashPFFOBJ(): bad HPFE\n");

            //
            // Remove PFE from hash tables.
            //

            if( !pfeo.bEUDC() )
            {
            // EUDC fonts arent added to these two tables
                if (fhoFace.bValid())
                    fhoFace.vDelete(pfeo);

                if (fhoFamily.bValid())
                    fhoFamily.vDelete(pfeo);
            }

            if (fhoUFI.bValid())
                fhoUFI.vDelete(pfeo);



            #if DBG
            if (gflFontDebug & DEBUG_FONTTABLE)
            {
                DbgPrint("gdisrv!vRemoveHashPFFOBJ() hpfe 0x%lx (\"%ws\")\n",
                          pfeo.ppfeGet(), pfeo.pwszFamilyName());
            }
            // Need level 2 checking to see this extra detail.
            if (gflFontDebug & DEBUG_FONTTABLE_EXTRA)
            {
                fhoFamily.vPrint((VPRINT) DbgPrint);
            }
            #endif
        }

        //
        // If this is a TrueType font, decrement the count.
        //

        if ( pPFF->hdev == (HDEV) gppdevTrueType )
        {
            gcTrueTypeFonts--;              // protected by ghsemPublicPFT
        }
    }
}

/******************************Public*Routine******************************\
*
* BOOL PFFOBJ::bPermanent()
*
*
* Effects:
*
* Warnings:
*
* History:
*  06-Dec-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

extern LPWSTR pwszBare( LPWSTR pwszPath );
extern UINT iHash(PWSZ pwsz,UINT c);

BOOL PFFOBJ::bPermanent()
{
// in the new version of the code every remote font is flagged at
// AddFontResourceTime. The difference in behavior from 3.51
// is that now fonts added by the applicaitons, if local, will not
// be removed at log on time.

    if (pPFF->flState & PFF_STATE_NETREMOTE_FONT)
        return FALSE;
    else
        return TRUE;

}

/******************************Public*Routine******************************\
* PFFOBJ::vPFFC_Delete
*
* Deletes the PFF and its PFEs.  Information needed to call the driver
* to unload the font file and release driver allocated data is stored
* in the PFFCLEANUP structure.  The PFFCLEANUP structure is allocated
* within this routine.  It is the caller's responsibility to release
* the PFFCLEANUP structure (calling vCleanupFontFile() calls the drivers
* AND releases the structure).
*
* Changed so that it does not return a pointer to a PFFCLEANUP
* structure.  Instead, it takes a pointer to a PFFCLEANUP
* structure as an argument.  Thus, the caller must allocate
* and free the memory to the PFFCLEANUP structure.  [dchinn  11/24/98]
*
* Returns:
*   void.  The contents of the PFFCLEANUP structure passed in will be altered
*   as appropriate.
*
* History:
*  10-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vPFFC_Delete(PFFCLEANUP *pPFFC)
{

    PVOID pvPFE;
    
    TRACE_FONT(("Entering PFFOBJ::vPFFC_Delete()\n\tpPFF=%-#x\n", pPFF));

    // check to see if a NULL pointer to a PFFCLEANUP structure was passed in
    ASSERTGDI(pPFFC, "vPFFC_Delete(): passed in a NULL\n");

    vDeletePFEC(&pvPFE);
    
//
// Delete all the PFE entries.
//
    for (COUNT c = 0; c < pPFF->cFonts; c++)
    {
        PFEOBJ  pfeo(((PFE **) (pPFF->aulData))[c]);
        ASSERTGDI(pfeo.bValid(), "vPFFC_DeletePFFOBJ(): bad HPFE (device font)\n");

    //
    // Delete the PFE.  The vDelete function will copy the driver allocated
    // resource information from the PFE into the PFECLEANUP structure.
    // We will call DrvFree for these resources later (when we're not under
    // semaphore).
    //
        pfeo.vDelete();
    }


//
// Save stuff about the PFF also.
//
    pPFFC->hff  = pPFF->hff;
    pPFFC->hdev = pPFF->hdev;
    pPFFC->pPFFClone = pPFF->pPFFClone;

//
// Free object memory and invalidate pointer.
//

    TRACE_FONT(("Freeing pPFF=%-#x\n",pPFF));

// If this was a remote font then we must delete the memory for the file.
// If this is a normal font then we must still delete the view.

    if (!pPFF->pPFFClone)
    {
        if (pPFF->ppfv && pPFF->cFiles)
        {
            FreeFileView(pPFF->ppfv, pPFF->cFiles);
        }
    }
    else
    {

    // We release the pPFFClone.

        pPFF->pPFFClone->pPFFClone = NULL;
    }

    if (pvPFE)
        VFREEMEM(pvPFE);
        
    VFREEMEM(pPFF);

    pPFF = 0;
    TRACE_FONT(("Exiting PFFOBJ::vPFFC_Delete\n\treturn value = %x\n", pPFFC));
    return;
}


/******************************Public*Routine******************************\
* PFFOBJ::vPFFC_DeleteAndCleanup
*
* This function creates a pointer to a PFFCLEANUP structure, calls vPFFC_Delete(),
* and then calls vCleanupFontFile().  This is the recommended way to handle
* unloading a font file, because it avoids the possibility (when a font file
* contains fewer than CFONTS_PFFCLEANUP fonts) that under a Hydra scenario
* it will fail to free up all the memory.
*
* (The old way of doing the cleanup was to call vPFFC_Delete() and then
* vCleanupFontFile().  However, the old vPFFC_Delete() allocated a PFFCLEANUP
* structure.  If that allocation failed, then the rest of the cleanup would
* not occur, and so memory would leak from a Hydra session.  This new way of
* doing the cleanup does not allocate memory from the heap.  Instead, it allocates
* it on the stack.)
*
* If for some reason the two calls (vPFFC_Delete() and vCleanupFontFile() ) need
* to be done separately (for example, if one of the calls is protected by a
* semaphore), then one must wrap code similar to that below around the two calls.
*
* Returns:
*   void.
*
* History:
*  24-Nov-1998 -by- Donald Chinn [dchinn]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vPFFC_DeleteAndCleanup()
{
    PFFCLEANUP pffc;

    // now call vPFFC_Delete() and vCleanupFontFile()

    vPFFC_Delete (&pffc);
    vCleanupFontFile (&pffc);
}


/******************************Public*Routine******************************\
* BOOL PFFOBJ::bDeleteLoadRef ()
*
* Remove a load reference.  Caller must hold the ghsemPublicPFT semaphore.
*
* Returns:
*   TRUE if caller should delete, FALSE if caller shouldn't delete.
*
* History:
*  23-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bDeleteLoadRef(ULONG fl, PVTDATA *pPvtData, BOOL *pbWrongFlags)
{
// ghsemPublicPFT protects the ref counts (cLoaded and cRFONT).  Caller
// must grab the semaphore before calling this function.

// Decrement the load count.  Must prevent underflow.  Who knows if some
// app might not randomly go around doing extra RemoveFont calls.  Isn't
// it too bad that we have to run APPS on our nice clean OS?  :-)

    BOOL bRet = FALSE;
    *pbWrongFlags = FALSE;

    TRACE_FONT(("Enterning PFFOBJ::bDeleteLoadRef\n"
                "\tpPFF=%-#x\n"
                "\tcLoaded=%d\n",
                "\tcNotEnum=%d\n",pPFF ,pPFF->cLoaded ,pPFF->cNotEnum));

// Embedded/Private fonts

    if (bInPrivatePFT())
    {
        ASSERTGDI(pPvtData, "bDeleteLoadRef: pPvtData is NULL\n");

        if (pPvtData == NULL)
        {
            return bRet;
        }
        // called by cleanup routine when the process terminates

        if (fl == FRW_PVT_CLEANUP)
        {
            pPvtData->cPrivate = 0;
            pPvtData->cNotEnum = 0;
        }

        // decreament cNotEnum for Embedded or FR_NOT_ENUM set font

        else if (fl & (FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID | FR_PRINT_EMB_FONT))
        {
            if (pPvtData->fl & fl)
            {
                if ( pPvtData->cNotEnum )
                {
                    pPvtData->cNotEnum--;
                    if (fl == FR_PRINT_EMB_FONT)
                    {
                        pPvtData->fl &= ~FR_PRINT_EMB_FONT;
                    }
                }
            }
            else
            {
                *pbWrongFlags = TRUE;
            }
        }

        // decreament cPrivate for FR_PRIVATE set only font

        else
        {
            if (pPvtData->fl & fl)
            {
                if ( pPvtData->cPrivate )
                {
                    pPvtData->cPrivate--;
                }
                else
                {
                    *pbWrongFlags = TRUE;
                }
            }
        }

     // Remove the PvtData block if both cPrivate and cNotEnum counts are zero.

        if ((pPvtData->cPrivate | pPvtData->cNotEnum) == 0)
        {
            bRemovePvtData(pPvtData);
        }

     // Mark it to Ready2Die if the PvtData list is NULL.

        if (pPvtDataHeadGet() == NULL)
        {
            ASSERTGDI( (pPFF->cLoaded | pPFF->cNotEnum) == 0, "win32k!bDeleteLoadRef(): global (cLoaded | cNotEnum) in private PFF is not 0\n");

            vKill();
            bRet = TRUE;
        }
    }
    else
    {
        // remove a public font

        if (fl == 0)
        {
            if (pPFF->cLoaded)
            {
                pPFF->cLoaded--;
            }
        }

        // remove a FR_NOT_ENUM font in the public PFT

        else
        {
            ASSERTGDI(fl == FR_NOT_ENUM, "win32k!bDeletLoadRef(): attempt to delete a font in public PFT with fl!=FR_NOT_ENUM \n");

            if (pPFF->cNotEnum)
            {
                pPFF->cNotEnum--;
            }
        }

        if ((pPFF->cLoaded | pPFF->cNotEnum) == 0)
        {
            ASSERTGDI(pPFF->pPvtDataHead == NULL, "win32k!bDeleteLoadRef(): pPvtDataHead in public PFF is not NULL\n");

            vKill();            // mark as "dead"
            bRet = TRUE;
        }
    }

    TRACE_FONT(("Exiting PFFOBJ::bDeleteLoadRef\n\treturn value = %d\n",bRet));
    return( bRet );
}


/******************************Public*Routine******************************\
* BOOL PFFOBJ::bDeleteRFONTRef ()
*
* Destroy the PFF physical font file object (message from a RFONT).
*
* Conditions that need to be met before deletion:
*
*   must delete all RFONTs before PFF can be deleted (cRFONT must be zero)
*   must delete all PFEs before deleting PFF
*
* After decrementing the cRFONT:
*
*   If cRFONT != 0 OR flState != PFF_STATE_READY2DIE, just exit.
*
*   If cRFONT == 0 and flState == PFF_STATE_READY2DIE, delete the PFF.
*
* Note:
*   This function has the side effect of decrementing the RFONT count.
*
* Returns:
*   TRUE if successful, FALSE if error occurs (which means PFF still lives!)
*
* Warning:
*   This should only be called from RFONTOBJ::bDelete()
*
* History:
*  23-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFFOBJ::bDeleteRFONTRef()
{
    PFFCLEANUP pffc;
    BOOL bCleanUp = FALSE;

    {
    // Need to stabilize table to access cRFONT and to modify font table.

        SEMOBJ so(ghsemPublicPFT);

    // Decrement the RFONT count.

        ASSERTGDI(pPFF->cRFONT > 0,"bDeleteRFONTRefPFFOBJ(): bad ref count in PFF\n");
        pPFF->cRFONT--;

    // If load count is zero and no more RFONTs for this PFF, OK to delete.

        if ( (pPFF->cLoaded == 0) && (pPFF->cNotEnum == 0) && (pPFF->pPvtDataHead == NULL) && (pPFF->cRFONT == 0) )
        {
        // If the load count is zero, the PFF is already out of the PFT.
        // It is now safe to delete the PFF.

            vPFFC_Delete(&pffc);
            bCleanUp = TRUE;
        }
    }

// Call the driver outside of the semaphore.

    if (bCleanUp)
        vCleanupFontFile(&pffc);     // function can handle NULL case

    return TRUE;
}


/******************************Public*Routine******************************\
* vKill
*
* Puts the PFF and its PFEs to death.  In other words, the PFF and PFEs are
* put in a dead state that prevents them from being mapped to or enumerated.
* It also means that the font file is in a state in which the system wants
* to delete it (load count is zero), but the deletion is delayed because
* RFONTs still exist which reference this PFF.
*
* History:
*  29-May-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vKill()
{
    // Put into a dead state if not already there.
    TRACE_FONT(("Entering PFFOBJ::vKill\n\tpPFF=%-#x\n", pPFF));
    if ( !bDead() )
    {
        // Set state.
        pPFF->flState |= PFF_STATE_READY2DIE;

        // Run the list of PFEs and set each to death.
        for (COUNT c = 0; c < pPFF->cFonts; c++)
        {
            PFEOBJ pfeo(((PFE **) (pPFF->aulData))[c]);

            if (pfeo.bValid())
            {
                // Mark PFE as dead state.

                pfeo.vKill();
            }
            else
            {
                WARNING("vDiePFFOBJ(): cannot make PFEOBJ\n");
            }
        }
    }
    TRACE_FONT(("Exiting PFFOBJ::vKill\n"));
}


/******************************Public*Routine******************************\
* vRevive
*
* Restores the PFF and its PFEs to life.  In other words, the states are
* cleared so that the PFF and PFEs are available for mapping and enumeration.
*
* History:
*  29-May-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vRevive ()
{
// If dead, then revive.

    if ( bDead() )
    {
    // Reset state.

        pPFF->flState &= ~PFF_STATE_READY2DIE;

    // Run the list of PFEs and revive each one.

        for (COUNT c = 0; c < pPFF->cFonts; c++)
        {
            PFEOBJ  pfeo(((PFE **) (pPFF->aulData))[c]);

            if (pfeo.bValid())
            {
            // Mark PFE as dead state.

                pfeo.vRevive();
            }
            else
            {
                WARNING("vRevivePFFOBJ(): cannot make PFEOBJ\n");
            }
        }
    }
}

/******************************Public*Routine******************************\
* BOOL PFFMEMOBJ::bLoadFontFileTable
*
* Creates a PFE for each of the faces in a font file and loads the IFI
* metrics and mapping tables into each of the PFEs.  The font file is
* uniquely identified by the driver, hoDriver, and IFI font file handle,
* hff, stored in the PFF object.  However, rather than hitting the handle
* manager an extra time, a PFDEVOBJ is passed into this function.
*
* After all the PFE entries are added, the font files pathname is added
* to the end of the data buffer.
*
* It is assumed that the PFF ahpfe table has enough room for cFontsToLoad
* new HPFE handles as well as the font files pathname.
*
* Returns:
*   TRUE if successful, FALSE if error.
*
* History:
*  16-Jan-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL PFFMEMOBJ::bLoadFontFileTable (
    PWSZ     pwszPathname,  // upper case
    COUNT    cFontsToLoad,
    HANDLE   hdc,
    PUNIVERSAL_FONT_ID pufi
#ifdef FE_SB
    ,PEUDCLOAD pEudcLoadData
#endif
    )
{
    ULONG       iFont; // font face index

// Create PFE's for each of the fonts in the font file.
// (Note: iFont indices for IFI fonts are 1-based, not 0-based)

    PDEVOBJ ppdo(hdev());

    if (!bCreatePFEC(cFontsToLoad))
        return FALSE;

    for (iFont = 1; iFont <= cFontsToLoad; iFont++)
    {
        FD_GLYPHSET *pfdg;
        PIFIMETRICS pifi;  // storage for the pointer to ifi
        ULONG_PTR idMetrics;

    // Grab the IFIMETRICS pointer.

        if ( (pifi = ppdo.QueryFont(
                        pPFF->dhpdev,
                        pPFF->hff,
                        iFont,
                        &idMetrics)) == (PIFIMETRICS) NULL )
        {
            WARNING("bLoadFontFileTablePFFMEMOBJ(): error getting metrics\n");
            return (FALSE);
        }

    // Put into a new PFE.

#ifdef FE_SB
        if( bReadyToInitializeFontAssocDefault )
        {
        // This should be Base font, not be EUDC.
        //
            if ( pEudcLoadData == NULL )
            {
            // check this base font should be RE-load as default linked font ?
            // if so, the pathname for this font will be registerd as default linked font.
                FindDefaultLinkedFontEntry(
                    (PWSZ)(((BYTE*) pifi) + pifi->dpwszFamilyName),pwszPathname);
            }
        }

        if (bAddEntry(iFont, NULL, 0, pifi, idMetrics, (HANDLE)0, pufi,
                      pEudcLoadData) == FALSE)
        {
        // Failed to get the FD_GLYPHSET information.  The entry is
        // partially valid (IFIMETRICS), so lets invalidate the good part.

            if (PPFNVALID(ppdo,Free))
            {
                ppdo.Free(pifi, idMetrics);
            }

            WARNING("bLoadFontFileTablePFFMEMOBJ(): error getting glyphset\n");

            return (FALSE);
        }

#endif
    }

    return (TRUE);
}


/*************************Public*Routine**************************\
* BOOL  bExtendGlyphset
*  Check the glyph set returned by the printer driver. Tack on the
* f0xx unicode range if missing for symbol font.
*
* History:
*  Oct-10-97  Xudong Wu [TessieW]
* Wrote it.
*
\*****************************************************************/
BOOL  bExtendGlyphSet(FD_GLYPHSET **ppfdgIn, FD_GLYPHSET **ppfdgOut)
{
    WCHAR   awch[256], *pwsz = awch, wcLow, wcHigh;
    UCHAR   ach[256];
    USHORT AnsiCodePage, OemCodePage;
    INT     cjWChar, cjChar;

    ULONG   cjSize, iRun, jRun, i, j;
    FD_GLYPHSET  *pfdgNew, *pfdg;
    ULONG   cRuns;
    BOOL    bRet = FALSE, bNeedExt = FALSE;

    pfdg = *ppfdgIn;
    cRuns = pfdg->cRuns;
    if (cRuns == 0)
    {
        WARNING("bExtendGlyphSet - empty glyphset\n");
        return FALSE;
    }

    wcLow  = pfdg->awcrun[0].wcLow;
    wcHigh = pfdg->awcrun[cRuns-1].wcLow + (WCHAR)pfdg->awcrun[cRuns-1].cGlyphs - 1 ;

    // mixing CP_SYMBOL mapping
    // e0 is the number of glyphs in f020-f0ff range in symbol CP

    // We shall extend the glypset if [f020,f0ff] does not intersect any
    // of the runs specified in the old pfdg. We check that by making sure that
    // [f020,f0ff] is entirely contained in the complement of the old glyphset.

    if (pfdg->cGlyphsSupported <= 256)
    {
        if ((wcHigh < 0xf020) || (wcLow > 0xf0ff))
        {
            bNeedExt = TRUE;
        }
        else
        {
            // bNeedExt = FALSE; // already initialized

            for (iRun = 0; iRun < (cRuns - 1); iRun++)
            {
                wcLow = pfdg->awcrun[iRun].wcLow + pfdg->awcrun[iRun].cGlyphs - 1;
                wcHigh = pfdg->awcrun[iRun+1].wcLow;

                if ((wcLow < 0xf020) && (wcHigh > 0xf0ff))
                {
                    bNeedExt = TRUE;
                    break;
                }
            }
        }
    }

    if (bNeedExt)
    {
        cjSize = SZ_GLYPHSET(cRuns + 1, pfdg->cGlyphsSupported + 0x00e0);
        pfdgNew = (FD_GLYPHSET*) PALLOCMEM(cjSize,'slgG');

        if (pfdgNew)
        {
            HGLYPH  *phgS, *phgD;

            cjWChar = sizeof(WCHAR) * pfdg->cGlyphsSupported;
            cjChar = 256;

            for (iRun = 0; iRun < cRuns; iRun++)
            {
                for (i = 0; i < pfdg->awcrun[iRun].cGlyphs; i++)
                {
                    *pwsz++ = pfdg->awcrun[iRun].wcLow + (WCHAR)i;
                }
            }

            RtlGetDefaultCodePage(&AnsiCodePage, &OemCodePage);
            if(IS_ANY_DBCS_CODEPAGE(AnsiCodePage))
            {
                AnsiCodePage = 1252;
            }
            EngWideCharToMultiByte(AnsiCodePage, awch, cjWChar, (CHAR*)ach, cjChar);

            pfdgNew->cjThis = cjSize;
            pfdgNew->flAccel = pfdg->flAccel | GS_EXTENDED;

            pfdgNew->cGlyphsSupported = pfdg->cGlyphsSupported + 0x00e0;
            pfdgNew->cRuns = cRuns + 1;

            phgS = phgD = (HGLYPH*) &pfdgNew->awcrun[cRuns+1];

            for ( iRun = 0;
                (iRun < cRuns) && (pfdg->awcrun[iRun].wcLow < 0xf020);
                iRun++)
            {
                pfdgNew->awcrun[iRun].wcLow = pfdg->awcrun[iRun].wcLow;
                pfdgNew->awcrun[iRun].cGlyphs = pfdg->awcrun[iRun].cGlyphs;
                pfdgNew->awcrun[iRun].phg = phgD;

                RtlCopyMemory(phgD, pfdg->awcrun[iRun].phg,
                                sizeof(HGLYPH) * pfdg->awcrun[iRun].cGlyphs);

                phgD += pfdg->awcrun[iRun].cGlyphs;
            }

            // fill in the f0xx range

            pfdgNew->awcrun[iRun].wcLow = 0xf020;
            pfdgNew->awcrun[iRun].cGlyphs = 0x00e0;
            pfdgNew->awcrun[iRun].phg = phgD;

            RtlZeroMemory((PVOID)phgD, 0x00e0 * sizeof(HGLYPH));

            j = 0;
            for (jRun = 0; jRun < cRuns; jRun++)
            {
                for (i = 0; i < pfdg->awcrun[jRun].cGlyphs; i++)
                {
                    if (ach[j] >= 0x20)
                    {
                        phgD[ach[j] - 0x20] = pfdg->awcrun[jRun].phg[i];
                    }
                    j++;
                }
            }

            phgD += 0x00e0;
            for (; iRun < cRuns; iRun++)
            {
                pfdgNew->awcrun[iRun+1].wcLow = pfdg->awcrun[iRun].wcLow;
                pfdgNew->awcrun[iRun+1].cGlyphs = pfdg->awcrun[iRun].cGlyphs;
                pfdgNew->awcrun[iRun+1].phg = phgD;

                RtlCopyMemory(phgD,
                              pfdg->awcrun[iRun].phg,
                              sizeof(HGLYPH) * pfdg->awcrun[iRun].cGlyphs);

                phgD += pfdg->awcrun[iRun].cGlyphs;
            }

            *ppfdgOut = pfdgNew;
            bRet = TRUE;
        }
        else
        {
            WARNING("bExtentGlyphSet(): failed to allocate pGlyphset\n");
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* BOOL PFFMEMOBJ::bLoadDeviceFontTable (
*
* Creates a PFE object for each device font and stores the IFIMETRICS and
* FD_MAPPINGS (UNICODE->HGLYPH) structures of that font.  The device is
* identified by the pair (ppdo, dhpdev).  There are cFonts number of device
* fonts to load.
*
* Note:
*   It is assumed that there is enough storage in the PFF for the number
*   of device fonts requested.
*
* History:
*  18-Mar-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
PFFMEMOBJ::bLoadDeviceFontTable (
    PDEVOBJ  *ppdo              // physical device
    )
{
    ULONG iFont;                // font face index
    ULONG cFonts = ppdo->cFonts();
    BOOL  bUMPD = ppdo->bUMPD();
    BOOL  bRet = FALSE;

    PIFIMETRICS     pifi;           // pointer to font's IFIMETRICS
    FD_GLYPHSET     *pfdg;          // pointer to font's GLYPHSETs

    ULONG_PTR           idifi;          // driver id's
    ULONG_PTR           idfdg;

    if (cFonts)
    {

        if (!bCreatePFEC(cFonts))
            return bRet;

    //
    // If the device has some fonts, allocate two FONTHASH strcutures
    // and save the addresses of the tables on the PFF
    //

        FHMEMOBJ fhmoFace(  &pPFF->pfhFace,   FHT_FACE  , cFonts);
        FHMEMOBJ fhmoFamily(&pPFF->pfhFamily, FHT_FAMILY, cFonts);
        FHMEMOBJ fhmoUFI(&pPFF->pfhUFI, FHT_UFI, cFonts);
    }

// Create PFE's for each of the fonts in the font file
// (Note: iFont indices for device fonts are 1-based, not 0-based)

    for (iFont = 1; iFont<=cFonts; iFont++)
    {

    // Set as NULL before we start to allocate ifi and fd_glyphset
        pfdg = NULL;
        pifi = NULL;
            
    // Get pointer to metrics

        if (( pifi = ppdo->QueryFont(pPFF->dhpdev, 0, iFont, &idifi )) == NULL )
        {
            SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
            #if DBG
            DbgPrint("gdisrv!PFFMEMOBJ::bLoadDeviceFontTable(): error getting metrics \
                     for iFace = %ld\n", iFont);
            #endif
            goto CleanUp;
        }

    // Get pointer to the UNICODE->HGLYPH mappings

        if (bUMPD)
        {
            pfdg = NULL;
        }
        else
        {
            if ( (pfdg = (FD_GLYPHSET *) ppdo->QueryFontTree(
                                            pPFF->dhpdev,
                                            0,
                                            iFont,
                                            QFT_GLYPHSET,
                                            &idfdg)) == NULL )
            {
            // Failed to get the FD_GLYPHSET information.  The entry is
            // partially valid (IFIMETRICS), so lets invalidate the good part.

                SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
                goto CleanUp;
            }

        // extend the glyph set,
        // it may not contain [f020,f0ff] range for the older drivers

            if (pifi->jWinCharSet == SYMBOL_CHARSET)
            {
                FD_GLYPHSET     *pfdgNew = NULL;

                if (bExtendGlyphSet(&pfdg, &pfdgNew))
                {
                    if (PPFNVALID(*ppdo,Free))
                    {
                        ppdo->Free(pfdg, idfdg);
                    }
                    pfdg = pfdgNew;
                }
            }
        }
        
    // Put into a new PFE

    // add entry logs error

        if (bAddEntry(iFont, pfdg, idfdg, pifi, idifi,(HANDLE)0,NULL) == FALSE)
        {
            WARNING("bLoadDeviceFontTable():adding PFE\n");
            goto CleanUp;
        }
    }

    bRet = TRUE;
    
CleanUp:

    if (!bRet)
    {
    
    // Free font hash

        FHOBJ fhoFace(&(pPFF->pfhFace));
        if (fhoFace.bValid())
        {
            fhoFace.vFree();
        }

        FHOBJ fhoFamily(&(pPFF->pfhFamily));
        if (fhoFamily.bValid())
        {
            fhoFamily.vFree();
        }

        FHOBJ fhoUFI(&(pPFF->pfhUFI));
        if (fhoUFI.bValid())
        {
            fhoUFI.vFree();
        }

    // Free pfdg
    
       if ( (pifi != NULL) &&
            (pifi->jWinCharSet == SYMBOL_CHARSET) &&
            (pfdg != NULL) &&
            (pfdg->flAccel & GS_EXTENDED))
        {
            VFREEMEM(pfdg);
        }
        else
        {
            if ((pfdg != NULL) && PPFNVALID(*ppdo,Free))
            {
                ppdo->Free(pfdg, idfdg);
            }
        }   

    // Free pifi

        if (pifi)
        {
            if (PPFNVALID(*ppdo,Free))
            {
                ppdo->Free(pifi, idifi);
            }
        }
        
    }
    
    return bRet;
}


/******************************Public*Routine******************************\
* BOOL PFFMEMOBJ::bAddEntry                                               *
*                                                                          *
* This function creates a new physical font entry object and adds it to the*
* end of the table.  The iFont parameter identifies the font within this   *
* file.  The cjSize and pjMetrics identify a buffer containing face        *
* information including the IFI metrics and the mapping structures         *
* (defining the UNICODE->HGLYPH mapping).                                  *
*                                                                          *
* Returns FALSE if the function fails.                                     *
*                                                                          *
* History:                                                                 *
*  02-Jan-1991 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL PFFMEMOBJ::bAddEntry
(
    ULONG       iFont,              // index of the font (IFI or device)
    FD_GLYPHSET *pfdg,              // pointer to UNICODE->HGLYPH map
    ULONG_PTR       idfdg,              // driver id for FD_GLYPHSET
    PIFIMETRICS pifi,               // pointer to IFIMETRICS
    ULONG_PTR       idifi,              // driver id for IFIMETRICS
    HANDLE      hdc,                // handle of DC if this is a remote font
    PUNIVERSAL_FONT_ID pufi,         // used when adding remote fonts
    PEUDCLOAD   pEudcLoadData       // pointer to EUDCLOAD
)
{

// Allocate memory for a new PFE
    PFECOBJ pfeco(pPFF->pPFEC);
    
    PFEMEMOBJ   pfemo(pfeco.GetPFE(iFont));

// Validate new object, hmgr logs error if needed

    if (!pfemo.bValid())
        return (FALSE);

// Initialize the new PFE

#ifdef FE_SB

    BOOL bEUDC = ( pEudcLoadData != NULL );
    PPFE *pppfeEUDC = ((bEUDC) ? pEudcLoadData->pppfeData : NULL);

    if( !pfemo.bInit(pPFFGet(), iFont, pfdg, idfdg, pifi, idifi, bDeviceFonts(), pufi, bEUDC ))
    {
        return(FALSE);
    }

    if( bEUDC )
    {
    //
    // This font file is loaded as EUDC font.
    //
        if( pEudcLoadData->LinkedFace == NULL )
        {
        //
        // No face name is specified.
        //
            switch( iFont )
            {
            case 1:
                pppfeEUDC[PFE_NORMAL] = pfemo.ppfeGet();
                pppfeEUDC[PFE_VERTICAL] = pppfeEUDC[PFE_NORMAL];
                break;

            case 2:
            //
            // if more than one face name the second face must be an @face
            //
                if( pfemo.pwszFaceName()[0] == (WCHAR) '@' )
                {
                    pppfeEUDC[PFE_VERTICAL] = pfemo.ppfeGet();

                    #if DBG
                    if( gflEUDCDebug & (DEBUG_FONTLINK_LOAD|DEBUG_FONTLINK_INIT) )
                    {
                        DbgPrint("EUDC font has vertical face %ws %x\n",
                                  pfemo.pwszFaceName(), pppfeEUDC[PFE_VERTICAL] );
                    }
                    #endif
                }
                 else
                {
                    WARNING("bAddEntryPFFMEMOBJ -- second face not a @face.\n");
                }
                break;

            default:
                WARNING("bAddEntryPFFMEMOBJ -- too many faces in EUDC font.\n");
            }
        }
         else
        {
            if( iFont == 1 )
            {
                //
                // link first face as default, because this font file might not
                // contains user's specified face name, but the user want to link
                // this font file. I don't know which is better link it as default
                // or fail link.
                //
                pppfeEUDC[PFE_NORMAL] = pfemo.ppfeGet();
                pppfeEUDC[PFE_VERTICAL] = pppfeEUDC[PFE_NORMAL];
            }
            else
            {
                ULONG iPfeOffset   = PFE_NORMAL;
                PWSTR pwszEudcFace = pfemo.pwszFaceName();

                //
                // Is this a vertical face ?
                //
                if( pwszEudcFace[0] == (WCHAR) '@' )
                {
                    iPfeOffset = PFE_VERTICAL;
                }

                //
                // Is this a face that we want ?
                //
                if( pfemo.bCheckFamilyName(pEudcLoadData->LinkedFace,1) )
                {
                    //
                    // Yes....., keep it.
                    //
                    pppfeEUDC[iPfeOffset] = pfemo.ppfeGet();

                    //
                    // if this is a PFE for Normal face, also keep it for Vertical face.
                    // after this, this value might be over-written by CORRRCT vertical
                    // face's PFE.
                    //
                    // NOTE :
                    //  This code assume Normal face come faster than Vertical face...
                    //
                    if( iPfeOffset == PFE_NORMAL )
                        pppfeEUDC[PFE_VERTICAL] = pfemo.ppfeGet();
                }
            }
        }

    // mark the FaceNameEUDC pfe list as NULL

        pfemo.vSetLinkedFontEntry( NULL );
    }
    else
    {

        PWSZ pwszAlias = NULL;
        BOOL bIsFamilyNameAlias = FALSE;
        PFLENTRY pFlEntry = NULL;

    // Here we see if there is an EUDC font for this family name.

        pwszAlias = pfemo.pwszFamilyNameAlias(&bIsFamilyNameAlias);

        pFlEntry = FindBaseFontEntry(pwszAlias);

        if (!pFlEntry && bIsFamilyNameAlias)
        {

            pwszAlias += (wcslen(pwszAlias) + 1);

            if (bIsFamilyNameAlias)
            {
                pFlEntry = FindBaseFontEntry(pwszAlias);
            }
        }

        if( pFlEntry != NULL )
        {
            //
            // set eudc list..
            //

            pfemo.vSetLinkedFontEntry( pFlEntry );

            #if DBG
            if( gflEUDCDebug & DEBUG_FACENAME_EUDC )
            {
                PLIST_ENTRY p = pfemo.pGetLinkedFontList()->Flink;

                DbgPrint("Found FaceName EUDC for %ws is ",pfemo.pwszFamilyName());

                while( p != &(pFlEntry->linkedFontListHead) )
                {
                    PPFEDATA ppfeData = CONTAINING_RECORD(p,PFEDATA,linkedFontList);
                    PFEOBJ pfeo( ppfeData->appfe[PFE_NORMAL] );
                    PFFOBJ pffo( pfeo.pPFF() );

                    DbgPrint(" %ws ",pffo.pwszPathname());

                    p = p->Flink;
                }

                DbgPrint("\n");
            }
            #endif
        }
        else
        {
        // mark the FaceNameEUDC pfe as NULL

            pfemo.vSetLinkedFontEntry( NULL );
        }

    }
#endif
// Put PFE pointer into the PFF's table

    ((PFE **) (pPFF->aulData))[pPFF->cFonts++] = pfemo.ppfeGet();

    return (TRUE);
}


 #if DBG
/******************************Public*Routine******************************\
* VOID PFFOBJ::vDump ()
*
* Debugging code.
*
* History:
*  Thu 02-Apr-1992 12:10:28 by Kirk Olynyk [kirko]
* DbgPrint supports %ws
*
*  25-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFFOBJ::vDump ()
{
    DbgPrint("\nContents of PFF, pPFF = 0x%lx\n", pPFFGet());
    if (*(WCHAR *)pwszPathname())
    {
        DbgPrint("Filename = %ws\n", pwszPathname());
    }
    DbgPrint("flState  = 0x%lx\n", pPFF->flState);
    DbgPrint("cLoaded  = %ld\n", pPFF->cLoaded);
    DbgPrint("cNotEnum = %ld\n", pPFF->cNotEnum);
    DbgPrint("pPvtDataHead = 0x%lx\n", pPFF->pPvtDataHead);
    DbgPrint("cRFONT   = %ld\n", pPFF->cRFONT);
    DbgPrint("hff      = 0x%lx\n", pPFF->hff);
    DbgPrint("cFonts   = %ld\n", pPFF->cFonts);
    DbgPrint("HPFE table\n");
    for (ULONG i=0; i<pPFF->cFonts; i++)
        DbgPrint("    0x%lx\n", ((PFE **) (pPFF->aulData))[i]);
    DbgPrint("\n");
}
#endif


/******************************Public*Routine******************************\
* vCleanupFontFile
*
* Parses the PFFCLEANUP structure and calls the driver to release
* its resources and to unload the font file.
*
* History:
*  10-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vCleanupFontFile(PFFCLEANUP *pPFFC)
{
    // Create PDEV user object so we can call driver functions.

    PDEVOBJ pdo(pPFFC->hdev);

    //
    // If font driver loaded font, call to unload font file.
    //
    if (pPFFC->hff != HFF_INVALID && pPFFC->pPFFClone == NULL)
    {
        BOOL bOK = pdo.UnloadFontFile( pPFFC->hff );
        ASSERTGDI(bOK, "PFFOBJ::vCleanupFontFile(): DrvUnloadFontFile failed\n");
    }
}


/******************************Public*Routine******************************\
* pPvtDataMatch()                                                          *
*                                                                          *
* Search for existing PvtData for the current process                      *
*                                                                          *
* Return                                                                   *
*        if found, return the address of the pPvtData block                *
*                                                                          *
*        otherwise, return NULL
*                                                                          *
* History:                                                                 *
*  11-Aug-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

PVTDATA *PFFOBJ::pPvtDataMatch()
{
    PVTDATA *pPvtDataCur;

    for (pPvtDataCur = pPvtDataHeadGet();
         pPvtDataCur;
         pPvtDataCur = pPvtDataCur->pPvtDataNext)
    {
        if ((pPvtDataCur->fl & FRW_EMB_TID) && (pPvtDataCur->dwID == (DWORD) W32GetCurrentTID()))
        {
            break;
        }

        if (pPvtDataCur->dwID == (DWORD) W32GetCurrentPID())
        {
            break;
        }

        // spooler has the right of using any fonts

        if ((gpidSpool == (PW32PROCESS)W32GetCurrentProcess()) &&
            (pPvtDataCur->fl & FR_PRINT_EMB_FONT))
            break;
    }

    return (pPvtDataCur);
}


/******************************Public*Routine******************************\
* bAddPvtData(ULONG flEmbed)                                               *
*                                                                          *
* Add PvtData data block to the tail of pPvtDataHead link list             *
*                                                                          *
* Return FALSE if function fails                                           *
*                                                                          *
* History:                                                                 *
*  11-Aug-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL PFFOBJ::bAddPvtData(ULONG flEmbed)
{
    PVTDATA  *pPvtData;

 // Search for the existing PvtData block for the current process

    pPvtData = pPvtDataMatch();

 // PvtData exists for the calling process

    if (pPvtData)
    {
        if (flEmbed & (FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID))
        {
            pPvtData->cNotEnum++;
        }
        else
        {
            pPvtData->cPrivate++;
        }

        pPvtData->fl |= flEmbed & (FR_PRIVATE | FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID);

        return TRUE;
    }

// no PvtData exists for the current process

    else
    {
        if (pPvtData = (PVTDATA *) PALLOCMEM(sizeof(PVTDATA), 'pvtG'))
        {
            pPvtData->fl = flEmbed & (FR_PRIVATE | FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID);

        // Embedded fonts can't be enumed, so we set cNotEnum to 1

            if (flEmbed & (FR_NOT_ENUM | FRW_EMB_PID | FRW_EMB_TID))
            {
                pPvtData->cPrivate = 0;
                pPvtData->cNotEnum = 1;
            }
            else
            {
                pPvtData->cPrivate = 1;
                pPvtData->cNotEnum = 0;
            }
            pPvtData->dwID  = (flEmbed & FRW_EMB_TID) ? (DWORD)W32GetCurrentTID() : (DWORD)W32GetCurrentPID() ;

            pPvtData->pPvtDataNext = pPFF->pPvtDataHead;
            pPFF->pPvtDataHead = pPvtData;

            return TRUE;
        }
        else
        {
            WARNING("PFFOBJ::bAddPvtData(): memory allocation failed\n");
            return FALSE;
        }
    }
}


/******************************Public*Routine******************************\
* bRemovePvtData(PVTDATA *pPvtData)                                        *
*                                                                          *
* Rmove the PvtData data block from the pPvtDataHead link list             *
*                                                                          *
* Return FALSE if function fails                                           *
*                                                                          *
* History:                                                                 *
*  27-Set-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL  PFFOBJ::bRemovePvtData(PVTDATA *pPvtData)
{
    PVTDATA *pPrev, *pCur;

    pPrev = pPvtDataHeadGet();

    if (!pPrev)
    {
        WARNING("PFFOBJ::bRemovePvtData: try to remove PvtData block from NULL list\n");
        return FALSE;
    }

    // remove the PvtData block from the head of the list

    if ( pPrev == pPvtData)
    {
        pPFF->pPvtDataHead = pPvtData->pPvtDataNext;

        VFREEMEM(pPvtData);
        return TRUE;
    }

    while (pCur = pPrev->pPvtDataNext)
    {
        if (pCur == pPvtData)
        {
            pPrev->pPvtDataNext = pPvtData->pPvtDataNext;

            VFREEMEM(pPvtData);
            return TRUE;
        }

        pPrev = pCur;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pftobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: pftobj.cxx                                                  *
*                                                                          *
* Non-inline methods for physical font table objects.                      *
*                                                                          *
* Created: 30-Oct-1990 09:32:48                                            *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
*  Tue 09-Aug-1994 10:04:09 by Kirk Olynyk [kirko]                         *
* Prior to build ### there was only a single font table on which all       *
* fonts, be they public (engine) or device, where attached. I have         *
* changed the font architecture so that there will be two font tables.     *
* One for public fonts and the other font device fonts. The public font    *
* table will be string based. That is, the fonts were added to this        *
* using GreAddFontResourceW() with the name of the associated font file.   *
* The name of the font file and path will be hashed and the font files     *
* will hang off of the collision list. The number of hash buckets is       *
* set at boot time.                                                        *
*                                                                          *
* The device font table will be for device fonts (suprise).                *
* In this case the fonts will be placed in hash collisions                 *
* lists depending upon the value of their hdev.                            *
*                                                                          *
* Copyright (c) 1994-1999 Microsoft Corporation                            *
*                                                                          *
\**************************************************************************/

#include "precomp.hxx"

extern "C" BOOL bInitFontTables();
extern "C" void vQueryRegistryForNumberOfBuckets(unsigned *, unsigned *);

#pragma alloc_text(INIT, bInitFontTables)
#pragma alloc_text(INIT, vQueryRegistryForNumberOfBuckets)

#define  CPRIVATEBUCKETS     20

PFT *gpPFTPublic;       // global public font table (for font drivers)
PFT *gpPFTDevice;       // global device font table (for printers)
PFT *gpPFTPrivate = PPFTNULL;   // global public talbe for private fonts, init as NULL

#ifdef LANGPACK
UINT PFFOBJ::uGlobalUniqueness = 0;
#endif

LARGE_INTEGER PFTOBJ::FontChangeTime;    // time of most recent addition or
                                         // removal of a font file
// Definitions for local functions used to remove font files from system.

RFONT*      prfntKillList(PFFOBJ &);
BOOL        bKillRFONTList(PFFOBJ &, RFONT *);
UINT        iHash(PWSZ, UINT);


/******************************Public*Routine******************************\
* pAllocateAndInitializePFT                                                *
*                                                                          *
*   Allocates and initializes a font table with cBuckets                   *
*   This allows the public (engine) font table and the device              *
*   font table to share the same code.                                     *
*                                                                          *
*   input:  cBuckets = number of members in allocated PFF* table           *
*   output: address of new PFT                                             *
*                                                                          *
*   Notes:                                                                 *
*                                                                          *
*   it is not necessary to check for error in the creation                 *
*   of the hash tables because the system will still work                  *
*                                                                          *
*   error:  return 0                                                       *
*                                                                          *
* History:                                                                 *
*  Fri 05-Aug-1994 07:41:50 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

PFT *pAllocateAndInitializePFT(unsigned cBuckets)
{
    PFT *pPFT;

    register ULONGSIZE_T size = offsetof(PFT, apPFF) + cBuckets * sizeof(PFF*);
    if (pPFT = (PFT*) PALLOCMEM(size, 'tfpG'))
    {
        pPFT->cBuckets       = cBuckets;
        pPFT->cFiles         = 0;
    }
    return(pPFT);
}

// strings used to identify values stored in the registry

static CONST PWSZ pwszP0 =  L"NumberOfPublicFontFilesAtLastLogOff";
static CONST PWSZ pwszP1 =  L"NumberOfPublicFontFilesSetByUser";
static CONST PWSZ pwszD0 =  L"NumberOfDeviceFontFilesAtLastLogOff";
static CONST PWSZ pwszD1 =  L"NumberOfDeviceFontFilesSetByUser";
static CONST PWSZ pwszFC =
          L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontCache";

// Define some default values in case the registry numbers are bogus

#define MIN_PUBLIC_BUCKETS 100
#define MAX_PUBLIC_BUCKETS 10000
#define MIN_DRIVER_BUCKETS 5
#define MAX_DRIVER_BUCKETS 100

// PIR :== Put In Range

#define PIR(x,a,b) ((x)<(a)?(a):((x)>(b)?(b):(x)))



/******************************Public*Routine******************************\
* vQueryRegistryForNumberOfBuckets
*
* Gets from the registry the number of buckets needed for the public
* and driver font tables.
*
* History:
*  Mon 26-Sep-1994 09:59:52 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

extern "C" void vQueryRegistryForNumberOfBuckets(
    unsigned *puPublic      // recieves # buckets for Public fonts
  , unsigned *puDevice      // recieves # buckets for Device fonts
  )
{

    RTL_QUERY_REGISTRY_TABLE QueryTable[5];
    HANDLE hDevMode;
    DWORD Status;

    ULONG cPublicBucketsSys  = 0;
    ULONG cPublicBucketsUser = 0;
    ULONG cDeviceBucketsSys  = 0;
    ULONG cDeviceBucketsUser = 0;

    //
    // Initialize registry query table.
    //

    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[0].Name = L"NumberOfPublicFontFilesAtLastLogOff";
    QueryTable[0].EntryContext = &cPublicBucketsSys;
    QueryTable[0].DefaultType = REG_NONE;
    QueryTable[0].DefaultData = NULL;
    QueryTable[0].DefaultLength = 0;

    QueryTable[1].QueryRoutine = NULL;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[1].Name = L"NumberOfPublicFontFilesSetByUser";
    QueryTable[1].EntryContext = &cPublicBucketsUser;
    QueryTable[1].DefaultType = REG_NONE;
    QueryTable[1].DefaultData = NULL;
    QueryTable[1].DefaultLength = 0;

    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[2].Name = L"NumberOfDeviceFontFilesAtLastLogOff";
    QueryTable[2].EntryContext = &cDeviceBucketsSys;
    QueryTable[2].DefaultType = REG_NONE;
    QueryTable[2].DefaultData = NULL;
    QueryTable[2].DefaultLength = 0;

    QueryTable[3].QueryRoutine = NULL;
    QueryTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    QueryTable[3].Name = L"NumberOfDeviceFontFilesSetByUser";
    QueryTable[3].EntryContext = &cDeviceBucketsUser;
    QueryTable[3].DefaultType = REG_NONE;
    QueryTable[3].DefaultData = NULL;
    QueryTable[3].DefaultLength = 0;

    QueryTable[4].QueryRoutine = NULL;
    QueryTable[4].Flags = 0;
    QueryTable[4].Name = NULL;

    //
    // If the open was succesdsful, then query the registry for the
    // specified printer.
    //

    Status = RtlQueryRegistryValues(RTL_REGISTRY_WINDOWS_NT,
                                    L"FontCache",
                                    &QueryTable[0],
                                    NULL,
                                    NULL);

    if (!NT_SUCCESS(Status))
    {
        WARNING1("vQueryRegistryForNumberOfBuckets failure\n");
    }
    else
    {
        if (!cPublicBucketsUser)
        {
            cPublicBucketsUser = cPublicBucketsSys;
        }
        if (!cDeviceBucketsUser)
        {
            cDeviceBucketsUser = cDeviceBucketsSys;
        }
    }
    *puPublic = PIR(cPublicBucketsUser, MIN_PUBLIC_BUCKETS, MAX_PUBLIC_BUCKETS);
    *puDevice = PIR(cDeviceBucketsUser, MIN_DRIVER_BUCKETS, MAX_DRIVER_BUCKETS);
}


/******************************Public*Routine******************************\
* BOOL bInitFontTables                                                    *
*                                                                          *
* Create the global public PFT and driver PFT                              *
*                                                                          *
* Create the public PFT semaphore to serialize access to both the          *
* public and driver font tables and their releated PFF's and PFE's         *
* Access to the RFONT's (realized font instances) are regulated            *
* by a separate semaphore.                                                 *
*                                                                          *
* History:                                                                 *
*  Fri 05-Aug-1994 07:07:27 by Kirk Olynyk [kirko]                         *
* Made it allocate both the public and driver font tables. Both            *
* allocations and initializations are done by a common routine.            *
*  21-Jan-1991 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

extern "C" BOOL bInitFontTables()
{
    unsigned cPublicBuckets;
    unsigned cDeviceBuckets;
    register BOOL bRet = FALSE;

    vQueryRegistryForNumberOfBuckets(&cPublicBuckets, &cDeviceBuckets);
    if (
    bRet = (
        (gpPFTPublic    = pAllocateAndInitializePFT(cPublicBuckets))
     && (gpPFTDevice    = pAllocateAndInitializePFT(cDeviceBuckets))
     && (ghsemPublicPFT = GreCreateSemaphore())
     && (ghsemGlyphSet = GreCreateSemaphore())
     && (ghsemPrintKView = GreCreateSemaphore()))
    )
    {
       FHMEMOBJ fhmo1(&gpPFTPublic->pfhFace  , FHT_FACE  , cPublicBuckets);
       FHMEMOBJ fhmo2(&gpPFTPublic->pfhFamily, FHT_FAMILY, cPublicBuckets);
       FHMEMOBJ fhmo3(&gpPFTPublic->pfhUFI, FHT_UFI, cPublicBuckets);
    }

    #if DBG
        if (!bRet)
        {
            if (!gpPFTPublic)       WARNING("gpPFTPublic == 0\n");
            if (!gpPFTDevice)       WARNING("gpPFTDevice == 0\n");
            if (!ghsemPublicPFT)    WARNING("ghsemPublicPFT == 0\n");
        }
    #endif

    return(bRet);
}


/******************************Public*Routine******************************\
* BOOL bInitPrivatePFT                                                     *
*                                                                          *
* Create the global private PFT                                            *
*                                                                          *
* Create the semaphore for the private PFT to serialize access             *
* to the private PFT and its releated PFF's and PFE's                      *
* Access to the RFONT's (realized font instances) are regulated            *
* by a separate semaphore.                                                 *
*                                                                          *
* History:                                                                 *
*  10-Aug-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bInitPrivatePFT()
{
    register BOOL bRet = FALSE;

    SEMOBJ sem(ghsemPublicPFT);

    if (gpPFTPrivate)
        return TRUE;


    if ( bRet = ((gpPFTPrivate = pAllocateAndInitializePFT(CPRIVATEBUCKETS)) != PPFTNULL )  )
    {
       FHMEMOBJ fhmo1(&gpPFTPrivate->pfhFace  , FHT_FACE  , CPRIVATEBUCKETS);
       FHMEMOBJ fhmo2(&gpPFTPrivate->pfhFamily, FHT_FAMILY, CPRIVATEBUCKETS);
       FHMEMOBJ fhmo3(&gpPFTPrivate->pfhUFI, FHT_UFI, CPRIVATEBUCKETS);
    }

#if DBG
    if (!bRet)
    {
        if (!gpPFTPrivate)      WARNING("gpPFTPrivate== 0\n");
    }
#endif

    return(bRet);
}


/******************************Public*Routine******************************\
* VOID  vCleanupPrivateFonts()                                             *
*                                                                          *
* Clean up the PFF for the dying process pid                               *
*                                                                          *
* History:                                                                 *
*  01-Oct-1996 -by- Xudong Wu [TessieW]                                    *
* Wrote it.                                                                *
\**************************************************************************/

VOID vCleanupPrivateFonts()
{
    ULONG i;
    PFF  *pPFF, **ppPFF, **ppPFFHead;

    // We have seen some stress failures on the Hydra system
    // that ghsemPublicPFT was not even initialized

    if (ghsemPublicPFT)
    {
        GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);

        PUBLIC_PFTOBJ  pftop(gpPFTPrivate);

        if (pftop.bValid())
        {
            //fonts loaded as private

            ppPFFHead = gpPFTPrivate->apPFF;

            for (i=0; i < CPRIVATEBUCKETS; i++)
            {
                ppPFF = ppPFFHead;
                pPFF = *ppPFFHead;

                while ( pPFF )
                {
                    PFF *pPFFNextVictim = pPFF->pPFFNext;

                    // bUnloadWorkhorse should release ghsemPublicPFT

                    if ( pftop.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, FRW_PVT_CLEANUP) )
                    {
                        GreQuerySystemTime( &PFTOBJ::FontChangeTime );
                    }

                    pPFF = pPFFNextVictim;

                    GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);
                }

                ppPFFHead++;
            }
        }

        GreReleaseSemaphoreEx(ghsemPublicPFT);
    }
}

/******************************Public*Routine******************************\
* BOOL PFTOBJ::bDelete()                                                  *
*                                                                          *
* Destroy the PFT physical font table object.                              *
*                                                                          *
*   If this method succeeds the pointer to the public font table is        *
* set to 0 and then this method returns TRUE. If the table contains        *
* any files, then this method will fail and return FALSE.                  *
*                                                                          *
* History:                                                                 *
*  30-Oct-1990 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL PFTOBJ::bDelete()
{
    if (pPFT->cFiles == 0)
    {
        VFREEMEM(pPFT);
        pPFT = 0;
    }
    else
    {
        WARNING("gdisrv!bDeletePFTOBJ(): cFiles != 0");
    }
    return(!pPFT);
}

/******************************Public*Routine******************************\
* PFTOBJ::chpfeIncrPFF                                                     *
*                                                                          *
* If this was an attempt to load a font that was embeded and the           *
* client ID didn't match that in the *.fot file FALSE will be              *
* return via pbEmbedStatus ortherwise TRUE is returned.                    *
*                                                                          *
* If found, the load count of the PFF is incremented.                      *
*                                                                          *
* Note:                                                                    *
*   Caller should be holding the ghsemPublicPFT                            *
*   semaphore when calling this routine in order                           *
*   to access the table and load count.                                    *
*                                                                          *
* Returns:                                                                 *
*   Number of PFEs in the PFF, 0 if PFF not found.                         *
*                                                                          *
* History:                                                                 *
*  Fri 05-Aug-1994 13:37:11 by Kirk Olynyk [kirko]                         *
* The PFF has been found up front and is guaranteed to exist.              *
* I have removed the check to see if it is a device font. This check       *
* is now redundant because you can tell if it is a device font by the      *
* table that you are on. If device fonts cannot be loaded via              *
* AddFontResouce, then this function should not be called for a            *
* device font.                                                             *
*  28-Jun-1991 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

COUNT PFTOBJ::chpfeIncrPFF(
   PFF    *pPFF,               // address of PFF to be, incremented
   BOOL   *pbEmbedStatus,      // tried to load an embeded font illegally
   ULONG  flEmbed,
   PEUDCLOAD pEudcLoadData   // PFE's in file if EUDC
    )
{
    // Caller should be holding ghsemPublicPFT semaphore!

    BOOL bEUDC = ( pEudcLoadData != NULL );

    COUNT cRet = 0;
    PFFOBJ pffo(pPFF);
    if (!pffo.bValid())
    {
        RIP("Invalid PFFOBJ\n");
    }
    else
    {
        if ((bEUDC && pffo.bEUDC()) || (!bEUDC && !pffo.bEUDC()) )
        {
            *pbEmbedStatus = !bIsPrivatePFT() || pffo.bAddPvtData(flEmbed);

            if(*pbEmbedStatus)
            {
                    if(bEUDC)
                    {
                        if((pEudcLoadData->LinkedFace == NULL) &&
                           (pffo.cFonts() > 2))
                        {
                            // EUDC font file can have at most two fonts (one regular
                            // and one @) unless the user specifies a face name.
                            // we return failure by setting embed status to false

                            *pbEmbedStatus = FALSE;

                            // return non-zero so calling function returns right away

                            return(1);
                        }
                        pffo.vGetEUDC(pEudcLoadData);
                    }

                    if (!bIsPrivatePFT())
                    {
                        pffo.vLoadIncr(flEmbed);
                    }

                    cRet = pffo.cFonts();
            }
            else
            {
                cRet = ~cRet;
                ASSERTGDI(cRet,
                    "cRet should be non zero so calling function"
                    " will return right away\n");
            }
        }
    }
    return(cRet);
}

/******************************Public*Routine******************************\
* PFTOBJ::pPFFGet                                                          *
*                                                                          *
* Note:                                                                    *
*   Caller should be holding the ghsemPublicPFT semaphore when             *
*   this method calling this in order to guarantee a stable font           *
*   table.                                                                 *
*   Note that since all the strings in the table are in upper case         *
*   and the input string must be upper case, we are allowed to             *
*   compare strings with the faster case sensitive compare                 *
*   wcscmp().                                                              *
*                                                                          *
* Returns:                                                                 *
*   PPFF of the PFF if found, (PPFF) NULL if the PFF not found.            *
*                                                                          *
* History:                                                                 *
*  Thu 04-Aug-1994 08:18:27 by Kirk Olynyk [kirko]                         *
* Modified to make the public font table hash based                        *
*  06-May-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

PPFF PUBLIC_PFTOBJ::pPFFGet (
    PWSZ pwszPathname   // address of upper case string
  , ULONG cwc
  , ULONG cFiles
  , DESIGNVECTOR *pdv
  , ULONG         cjDV
  , PFF ***pppPFF       // write address of bucket here
  , BOOL bEUDC          // be true if EUDC
  )
{
    PFF *pPFF, **ppPFF;

// it is enough to hash on the first file only, no need to include the
// second and or third file to the hashing routine [bodind]

    ppPFF = pPFT->apPFF + iHash(pwszPathname,pPFT->cBuckets);
    if (pppPFF)
    {
        *pppPFF = ppPFF;
    }

    pPFF = *ppPFF;

    while(pPFF)
    {
        if
        ((bEUDC == ((pPFF->flState & PFF_STATE_EUDC_FONT) != 0)) &&
        (cwc == pPFF->cwc) && (cFiles == pPFF->cFiles) &&
        !memcmp(pPFF->pwszPathname_, pwszPathname, cwc * sizeof(WCHAR)) &&
        (cjDV == pPFF->cjDV_) &&
        (!cjDV || !memcmp(pdv, pPFF->pdv_, pPFF->cjDV_))
        )
        {
            break;
        }
        pPFF = pPFF->pPFFNext;
    }

    return(pPFF);
}


/**********************Public*Routine***************************\
* PFTOBJ::pPFFGetMM                                             *
*                                                               *
* Note:                                                         *
*   Caller should be holding the ghsemPublicPFT semaphore       *
*   when this method calling this in order to guarantee         *
*   a stable font table. Also this should only be called        *
*   when we remove the memory fonts.                            *
*                                                               *
*   We check the PFF_STATE_MEMORY_FONT flag, the ulCheckSum     *
*   and the process ID                                          *
*                                                               *
* Returns:                                                      *
*   PPFF of the PFF if found, (PPFF) NULL if not found.         *
*                                                               *
* History:                                                      *
*  12-Jun-1997  -by-    Xudong Wu [TessieW]                     *
* Wrote it.                                                     *
\***************************************************************/
PPFF PUBLIC_PFTOBJ::pPFFGetMM
(
    ULONG   ulCheckSum,
    PFF     ***pppPFF
)
{
    BOOL    bFind = FALSE;
    PFF     *pPFF, **ppPFFHead;
    int     i;

    ASSERTGDI(pPFT == gpPFTPrivate, "pPFFGetMM(): it is not private PFT table\n");

    ppPFFHead = gpPFTPrivate->apPFF;

    for (i=0; i < CPRIVATEBUCKETS; i++)
    {
        pPFF = *ppPFFHead;

        while (pPFF)
        {
            if ((pPFF->flState & PFF_STATE_MEMORY_FONT) && (pPFF->ulCheckSum == ulCheckSum))
            {
                PFFOBJ  pffo(pPFF);

                if (pffo.pPvtDataMatch())
                {
                    bFind = TRUE;
                    break;
                }
            }

            pPFF = pPFF->pPFFNext;
        }

        if (bFind)
        {
            break;
        }

        ppPFFHead++;
    }

    if (bFind && pppPFF)
    {
        *pppPFF = ppPFFHead;
    }

    return(pPFF);
}



/******************************Public*Routine******************************\
* PFTOBJ::pPFFGet                                                          *
*                                                                          *
* This function searches for the PFF that contains the device fonts for    *
* the PDEV specified by the HPDEV passed in.                               *
*                                                                          *
* Note:                                                                    *
*   Caller should be holding the ghsemPublicPFT semaphore                  *
*   when calling this in order to have access to the font tables.          *
*                                                                          *
* Returns:                                                                 *
*   pointer to the PFF if found. 0 returned on error.                      *
*                                                                          *
* History:                                                                 *
*  Fri 05-Aug-1994 13:39:04 by Kirk Olynyk [kirko]                         *
* Changed this to a hash based search.                                     *
*  06-May-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

#define iHashHPDEV(hdev, c)    (((ULONG_PTR) hdev >> 4) % c)

PPFF DEVICE_PFTOBJ::pPFFGet(
    HDEV hdev
  , PFF ***pppPFF     // write address of bucket here
)
{
    PFF *pPFF, **ppPFF;

    ppPFF = pPFT->apPFF + iHashHPDEV(hdev, pPFT->cBuckets);
    pPFF = *ppPFF;
    if (pppPFF)
    {
        *pppPFF = ppPFF;
    }
    while (pPFF)
    {
        PFFOBJ pffo(pPFF);
        if (!pffo.bValid())
        {
            RIP("PFTOBJ::PPFFGet(HPDEV) encountered invalid PFFOBJ\n");
        }
        else if (hdev == pffo.hdev())
        {
            break;
        }
        pPFF = pPFF->pPFFNext;
    }
    return(pPFF);
}

/******************************Public*Routine******************************\
*
* bLoadAFont, wrapper for one file only
*
*
* History:
*  28-Mar-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL PUBLIC_PFTOBJ::bLoadAFont(
    PWSZ   pwszPathname,             // font file pathname
    PULONG pcFonts,                  // number of fonts faces loaded
    FLONG  fl,                       // permanent
    PPFF    *pPPFF,
    PEUDCLOAD pEudcLoadData
  )
{

    WCHAR awcUcPathName[MAX_PATH + 1];
    ULONG cwc = wcslen(pwszPathname) + 1;
    cCapString(awcUcPathName, pwszPathname, cwc);

    return bLoadFonts(awcUcPathName, cwc, 1, // pwsz, cwc, cFiles
                      NULL, 0,               // pdv, cjDV
                      pcFonts,fl, pPPFF
                      , 0
                      , FALSE
                      , pEudcLoadData
                      );
}

/************************Public*Routine*******************************\
*
* VOID    vLoadFontFileView()
*
* Note: we need to grab semaphore ghsemDriverMgmt before the function
*       call and release the semaphore afterwards.
*
* History:
*   03-June-1997 -by- Xudong Wu [Tessiew]
*  Wrote it.
\*********************************************************************/
VOID  vLoadFontFileView
(
    PWSZ            pwszPathname,             // font file pathname
    ULONG           cwc,                      // cwc in PathName
    FONTFILEVIEW    **apfv,
    ULONG           cFiles,
    PVOID           *apvView,
    ULONG           *acjView,
    DESIGNVECTOR    *pdv,
    ULONG           cjDV,
    HFF             *phffNew,
    PPDEV           *pppDevList,
    PFNTCHECKSUM    pFntCheckSum
)
{
    GDIFunctionID(vLoadFontFileView);

    HFF     hffNew = HFF_INVALID;
    PPDEV   ppDevList = gppdevList, ppDevTmp;
    ULONG   lflag;
    PPDEV   ppDevCache = NULL;
    BOOL    bCached = FALSE;

    pFntCheckSum->ulCheckSum = 0;
    pFntCheckSum->ulFastCheckSum = 0;

    pFntCheckSum->ulCheckSum = LookUpFNTCacheTable( cwc, pwszPathname, &pFntCheckSum->ulFastCheckSum,
                                                    apfv, cFiles, &ppDevList, pdv, cjDV);

    if (pFntCheckSum->ulCheckSum && ppDevList)
    {
        PDEVOBJ pdo((HDEV)ppDevList);

        ASSERTGDI (pdo.bFontDriver(), " Something wrong in font ppDev cache \n" );

        // In case something wrong in font driver.

        if (pdo.bFontDriver())
        {
            // make a reference to the font driver under the protection
            // of the semaphore. This will guarantee that the font
            // driver will not be unloaded unexpectedly. After that

            pdo.vReferencePdev();

            GreReleaseSemaphoreEx(ghsemDriverMgmt);


            // Attempt to load the font file.
            // It is acceptable to release the lock at this point because
            // we know this font driver has at least one reference to it.
            // We also do not care if other font drivers are added or removed
            // from the list while we are scanning it ...

            // We are assuming that DrvLoadFontFile will call EngMapFontFile
            // and EngUnmapFontFile in balanced pairs upon the view.

            // we are trying to add the font using the cached info. If this failed
            // we will try to add it later without using the cached info, in case there
            // is a problem with boot cache. (Defensive programming).

            hffNew = pdo.LoadFontFile( cFiles,
                                       (ULONG_PTR *) apfv,
                                       apvView,
                                       acjView,
                                       pdv,
                                       (ULONG) gusLanguageID,
                                       pFntCheckSum->ulFastCheckSum
                                      );


            if (hffNew == HFF_INVALID)
            {
                hffNew = pdo.LoadFontFile( cFiles,
                                       (ULONG_PTR *) apfv,
                                       apvView,
                                       acjView,
                                       pdv,
                                       (ULONG) gusLanguageID,
                                       0
                                      );

            }

            if (hffNew != HFF_INVALID)
            {
               bCached = TRUE;
            }
            else
            {
                // We did not load the font file properly
                // Release the reference and go on.
                pdo.vUnreferencePdev();
            }

            // Grab the lock again here (so we exit the loop properly)
            GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
        }
    }

    if (!bCached)
    {
        ppDevList = gppdevList;

        do
        {
            PDEVOBJ pdo((HDEV)ppDevList);

            ppDevTmp = NULL;
            if ( pdo.bFontDriver() )
            {
            // make a reference to the font driver under the protection
            // of the semaphore. This will guarantee that the font
            // driver will not be unloaded unexpectedly. After that

                pdo.vReferencePdev();

                GreReleaseSemaphoreEx(ghsemDriverMgmt);

            // Attempt to load the font file.
            // It is acceptable to release the lock at this point because
            // we know this font driver has at least one reference to it.
            // We also do not care if other font drivers are added or removed
            // from the list while we are scanning it ...

            // We are assuming that DrvLoadFontFile will call EngMapFontFile
            // and EngUnmapFontFile in balanced pairs upon the view.

                hffNew = pdo.LoadFontFile( cFiles,
                                       (ULONG_PTR *) apfv,
                                       apvView,
                                       acjView,
                                       pdv,
                                       (ULONG) gusLanguageID,
                                       pFntCheckSum->ulFastCheckSum
                                      );


            // Grab the lock again here (so we exit the loop properly)

                GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);

                if (hffNew != HFF_INVALID)
                {
                    PutFntCacheDrv(pFntCheckSum->ulFastCheckSum, ppDevList);
                    break;
                }
                else
                {
                // We did not load the font file properly
                // Release the reference and go on.

                    ppDevTmp = ppDevList->ppdevNext;
                    pdo.vUnreferencePdev();
                }
            }
            ppDevList = ppDevTmp ? ppDevTmp : ppDevList->ppdevNext;

        } while (ppDevList);
    }

    *pppDevList = ppDevList;
    *phffNew = hffNew;
}



/******************************Public*Routine******************************\
* BOOL PUBLIC_PFTOBJ::bLoadFonts                                          *
*                                                                          *
* The bLoadFont function searches for an IFI font driver which can load    *
* the requested font file.  If a driver is found, a new Pysical Font       *
* File object is created and is used to load the font file.                *
*                                                                          *
* Note that if the font file has already been loaded (i.e., a PFF object   *
* already exists for it), the ref count in the PFF is incremented without  *
* reloading the file.                                                      *
*                                                                          *
* If pppfeEUDC != NULL then we are loading an EUDC font file.  This has    *
* the restriction the font file has only one face or two if the other is   *
* an @face. If either of these aren't true the call fails.  Also, an EUDC  *
* font wont be enumerated.  Finally the PFE will be returned for the one   *
* font in the EUDC font file via pppfeEUDC.                                *
*                                                                          *
* Returns FALSE on failure.                                                *
*                                                                          *
* History:                                                                 *
*  Thu 28-Mar-1996 -by- Bodin Dresevic [BodinD]
* update: added multiple file support
*  Thu 04-Aug-1994 08:04:03 by Kirk Olynyk [kirko]                         *
* Made the font table hash based.                                          *
*  06-Nov-1990 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL PUBLIC_PFTOBJ::bLoadFonts(
    PWSZ   pwszPathname,             // font file pathname
    ULONG  cwc,                      // cwc in PathName
    ULONG  cFiles,                   // number of distinct files in path
    DESIGNVECTOR *pdv,
    ULONG         cjDV,
    PULONG pcFonts,                  // number of fonts faces loaded
    FLONG  fl,                       // permanent
    PPFF    *pPPFF,
    FLONG  flEmbed,
    BOOL   bSkip,               // skip the check if the font is already loaded
    PEUDCLOAD pEudcLoadData     // returns PFE for EUDC font file
    )
{
    GDIFunctionID(PUBLIC_PFTOBJ::bLoadFonts);

    COUNT   cFonts;                   // count of fonts in font file
    BOOL    bRet = FALSE;             // assume failuer
    PFF     *pPFF;                    // convenient pointer2
    PFF     **ppPFF;                    // address of bucket
    BOOL    bEUDC = ( pEudcLoadData != NULL );
    PPFE    *pppfeEUDC = ((bEUDC) ? pEudcLoadData->pppfeData : NULL);
    FNTCHECKSUM fntCheckSum;
    PFF     *pPFFTemp = NULL;
    BOOL    bClone = FALSE;

    if (!pwszPathname)
    {
        RIP("pwszPathname != 0\n");
        return(bRet);
    }

    // we have seen AV caused by uninitialized gpsemPublicPFT
    // on Hydra systems
    // hydra -- we might remove this in Beta3

    //if (!ghsemPublicPFT)
    //{
    //    return bRet;
    //}

    // if (already_loaded) increment_ref_count_then_exit_immediately

    if (!bSkip)
    {
        SEMOBJ so(ghsemPublicPFT);

        *pcFonts = 0;

        if ((*pPPFF = pPFFGet((PWSZ) pwszPathname, cwc, cFiles, pdv, cjDV, &ppPFF, bEUDC)) &&
            (*pcFonts = chpfeIncrPFF(*pPPFF, &bRet, flEmbed, pEudcLoadData)))
        {
            return(bRet);
        }
        else if (pPFFTemp = pPFFGet((PWSZ) pwszPathname, cwc, cFiles, pdv, cjDV, &ppPFF, !bEUDC))
        {
            if (pPFFTemp->pPFFClone == (PFF *) NULL)
                bClone = TRUE;
        }
    }

    // Grab the head of the font driver list under semaphore and find
    // the first font driver in the list that loads the font
    //
    // Release the semaphore so we can go and see if the
    // driver supports the font.  If it does, then keep
    // the reference count and exit.  Otherwise, grab the
    // semaphore again, release the reference count and
    // find the next driver in the list.


// alloc temp memory, this could be done on the stack if it were not
// for the fact that we do not know ahead the upper bound on cFiles

    if (!bClone)
    {
        HFF hffNew = HFF_INVALID;             // IFI handle to font file

        MALLOCOBJ moViews(cFiles * (sizeof(PVOID) + sizeof(ULONG)));
        if (!moViews.bValid())
            return FALSE;

        PVOID *apvView      = (PVOID *)moViews.pv();
        ULONG *acjView      = (ULONG *)&apvView[cFiles];


        FONTFILEVIEW **apfv;

    // apfv - pointer to a block of memory that begins with an array
    //    of cFiles pointers to FONTFILEVIEW structures followed
    //    by a corretly aligned FONTFILEVIEW structure

        unsigned offset;

    // offset - offset of FONTFILEVIEW structure from the beginning
    //     of the block of memory pointed to by apfv. This is equal to the
    //     offset of the nearest double following the array of pointers.
    //     In C, a double is maximally aligned.

        offset = ALIGN8(cFiles * sizeof(void*));

        apfv = (FONTFILEVIEW**) PALLOCMEM(offset + cFiles*sizeof(FONTFILEVIEW),'vffG');

        if (apfv == NULL)
        {
            WARNING("Out of memory\n");
            return(FALSE);
        }

    // pfv - pointer to FONTFILEVIEW structure following the array of
    //     cFiles pointers.

        FONTFILEVIEW *pfv = (FONTFILEVIEW*)(((char*) apfv) + offset);

    // init the data for all files;

        PWSZ   pwszTmp = pwszPathname;
        ULONG  iFile;

        for (iFile = 0; iFile < cFiles; iFile++)
        {
            apfv[iFile] = &pfv[iFile];

            apfv[iFile]->pwszPath = pwszTmp;

            if (!EngMapFontFileFDInternal((ULONG_PTR)apfv[iFile], (PULONG*)&apvView[iFile], &acjView[iFile], FALSE))
            {
                WARNING("EngMapFontFile failed\n");

            // clean up, unmap all of those mapped so far

                for (ULONG jFile = 0; jFile < iFile; jFile++)
                    EngUnmapFontFileFD((ULONG_PTR)apfv[jFile]);

                VFREEMEM(apfv);
                return(FALSE);
            }

            // get to the next file in the multiple path

            while (*pwszTmp++)
                ;
        }

        PPDEV   ppDevList;

        // order of grabbing semaphores important

        GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
        vLoadFontFileView(pwszPathname, cwc, apfv, cFiles, apvView, acjView, pdv, cjDV, &hffNew, &ppDevList, &fntCheckSum);
        PDEVOBJ pdo((HDEV)ppDevList);
        GreReleaseSemaphoreEx(ghsemDriverMgmt);

        ASSERTGDI(bRet==FALSE,"bRet != FALSE\n");

        if (hffNew != HFF_INVALID)
        {
        // cFonts = number of faces in the file

            cFonts = pdo.QueryFontFile( hffNew,
                                        QFF_NUMFACES,
                                        0,
                                        NULL);

            if (cFonts && cFonts != FD_ERROR)
            {
            // EUDC font file can have at most two fonts. If it
            // has two fonts then one of the face names must begin
            // with the '@' character. We check the number of fonts
            // here but we do not check the characters of the
            // face names.

                if (bEUDC && (pEudcLoadData->LinkedFace == NULL) && (cFonts > 2))
                {
                    WARNING("EUDC font file has more than two faces.");
                    return(bRet);
                }

                *pcFonts = cFonts;

            // Create new PFF with table big enough to accomodate
            // the new fonts and pathname.

                PFFCLEANUP *pPFFC = 0;

                PFFMEMOBJ pffmo(cFonts,
                                pwszPathname,cwc, cFiles, pdv, cjDV,
                                hffNew,pdo.hdev(),0,pPFT,fl,flEmbed,&fntCheckSum, apfv, NULL
                               );

                if (pffmo.bValid())
                {
                // Tell the PFF user object to load its table of
                // HPFE's for each font in file.

                    if (!pffmo.bLoadFontFileTable(pwszPathname,
                                                  cFonts,
                                                  (HANDLE) 0,
                                                  NULL,  //PFE_UFIMATCH bit for remote printing
                                                  pEudcLoadData
                                                  ))
                    {
                        *pcFonts = 0;
                    }
                    else
                    {
                    // Font load has succeeded.  If some other process hasn't
                    // already snuck in and added it while the ghsemPublicPFT
                    // semaphore was released, add the new PFF to the PFT.
                    // Stabilize font table before searching or modifying it.

                        SEMOBJ so2(ghsemPublicPFT);

                    // Is PFF already in table?  We check this by
                    // assuming that it already is and attempt to
                    // increment the load count.  If it succeeds, its
                    // there.  If it fails, it not there and we can add
                    // our new PFF to the PFT.

                    #ifdef LANGPACK

                        // do this under the public font table semaphore to
                        // serialize access to the

                        pffmo.vSetUniqueness();
                    #endif

                        if((*pPPFF = pPFFGet(pwszPathname, cwc, cFiles, pdv, cjDV, &ppPFF, bEUDC)) &&
                            (cFonts = chpfeIncrPFF(*pPPFF,&bRet,flEmbed,pEudcLoadData)))
                        {
                        // Some other process got in and put it in before we
                        // could.  chpfeIncrPFF has already incremented the
                        // count for us.  We only need to delete the PFF that
                        // we made which will occur automatically if
                        // bRet = FALSE

                            *pcFonts = cFonts;
                        }
                        else
                        {
                        // Not already in the table, so we really are going
                        // to add it to the PFT.

                            *pPPFF = pffmo.pPFFGet();
                            if(pffmo.bAddHash(bEUDC))
                            {
                            // add entry to head of a doubly linked collision
                            // list

                                pPFT->cFiles++;
                                if (*ppPFF)
                                {
                                    (*ppPFF)->pPFFPrev = *pPPFF;
                                }
                                (*pPPFF)->pPFFNext = *ppPFF;
                                (*pPPFF)->pPFFPrev = 0;
                                *ppPFF = *pPPFF;

                                pffmo.vKeepIt();

                            // need to reset the file paths pointers

                                pwszTmp = pffmo.pwszPathname();

                                for (iFile = 0; iFile < cFiles; iFile++)
                                {
                                    apfv[iFile]->pwszPath = pwszTmp;

                                // get to the next file in the multiple path

                                    while (*pwszTmp++)
                                        ;
                                }
                                bRet           = TRUE;
                            }
                            else
                            {
                                WARNING("pffmo.bAddHash() failed\n");
                                *pcFonts = 0;
                                pffmo.vRemoveHash();
                            }
                        }
                    }

                    if (!bRet)
                    {
                    // must unmap the files before calling pPFFC_Delete()
                    // because this function will delete apfv memory so that unmap
                    // will fail

                        for (iFile = 0; iFile < cFiles; iFile++)
                        {
                            EngUnmapFontFileFD((ULONG_PTR)apfv[iFile]);
                        }

                        pffmo.vPFFC_DeleteAndCleanup();  // new code
                        return bRet;
                    }
                }
            }
        }

    // If you get to here then the font driver recognized the font. Since
    // we cannot be sure that the font will be used immediately, we will
    // unmap font font file and free the memory containing the image of the
    // font file.

        for ( iFile = 0; iFile < cFiles; iFile++ )
        {
            EngUnmapFontFileFD( (ULONG_PTR) apfv[iFile] );
        }

        if (!bRet)
        {
            VFREEMEM(apfv);
        }

        return(bRet);
    }
    else
    {
        PFFCLEANUP *pPFFC = 0;

    // Clone the hffNew and make a new PFF object
        PFFMEMOBJ pffmo(pPFFTemp, fl, flEmbed, pPFT);

        bRet = FALSE;

        cFonts = pPFFTemp->cFonts;

        if (pffmo.bValid())
        {
        // Tell the PFF user object to load its table of
        // HPFE's for each font in file.

            if (!pffmo.bLoadFontFileTable(pwszPathname, cFonts, (HANDLE) 0, NULL, pEudcLoadData))
            {
                *pcFonts = 0;
            }
            else
            {

            // Font load has succeeded.  If some other process hasn't
            // already snuck in and added it while the ghsemPublicPFT
            // semaphore was released, add the new PFF to the PFT.
            // Stabilize font table before searching or modifying it.

                SEMOBJ so2(ghsemPublicPFT);

            // Is PFF already in table?  We check this by
            // assuming that it already is and attempt to
            // increment the load count.  If it succeeds, its
            // there.  If it fails, it not there and we can add
            // our new PFF to the PFT.

            #ifdef LANGPACK

            // do this under the public font table semaphore to
            // serialize access to the

                pffmo.vSetUniqueness();
            #endif

                if((*pPPFF = pPFFGet(pwszPathname, cwc, cFiles, pdv, cjDV, &ppPFF, bEUDC)) &&
                     (cFonts = chpfeIncrPFF(*pPPFF,&bRet,flEmbed,pEudcLoadData)))
                {
                // Some other process got in and put it in before we
                // could.  chpfeIncrPFF has already incremented the
                // count for us.  We only need to delete the PFF that
                // we made which will occur automatically if
                // bRet = FALSE

                    *pcFonts = cFonts;
                }
                else
                {
                // Not already in the table, so we really are going
                // to add it to the PFT.

                    *pPPFF = pffmo.pPFFGet();


                    if(pffmo.bAddHash(bEUDC))
                    {
                    // add entry to head of a doubly linked collision
                    // list

                        pPFT->cFiles++;
                        if (*ppPFF)
                        {
                            (*ppPFF)->pPFFPrev = *pPPFF;
                        }

                        (*pPPFF)->pPFFNext = *ppPFF;
                        (*pPPFF)->pPFFPrev = 0;
                        *ppPFF = *pPPFF;

                        pffmo.vKeepIt();

                        bRet           = TRUE;
                    }
                    else
                    {
                        WARNING("pffmo.bAddHash() failed\n");
                        *pcFonts = 0;
                        pffmo.vRemoveHash();
                    }
                }
            }

            if (!bRet)
            {

            // must unmap the files before calling pPFFC_Delete()
            // because this function will delete apfv memory so that unmap
            // will fail
                pffmo.vPFFC_DeleteAndCleanup();  // new code
            }
        }

        return(bRet);
    }
}


/******************************Public*Routine******************************\
* BOOL PUBLIC_PFTOBJ::bLoadRemoteFonts
*
* Warning:
*
*   This routine or any of the routines that it calls must
*   call EngMapFontFile and EngUnmapFontFile in pairs.
*
* History:
*  Thu 02-Feb-1995 2:04:06 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

#define QUICK_VIEWS  4

ULONG PUBLIC_PFTOBJ::ulRemoteUnique = 0;


BOOL PUBLIC_PFTOBJ::bLoadRemoteFonts(
    XDCOBJ &dco,
    PFONTFILEVIEW *ppfv, // points to a pre mapped view of the font
                         // EngMapFontFile must NOT be called
                         // before sending it to the font driver
                         // EngUnmapFontFile must be called at
                         // the end of this routine for possible
                         // error cleanup
    UINT           cNumFonts, // number of files needed to represent this font
    DESIGNVECTOR  *pdv,        // dv for the mm instance
    PUNIVERSAL_FONT_ID  pufi
    )
{
    COUNT cFonts;                   // count of fonts in font file
    BOOL  bRet = FALSE;             // assume failure
    HFF hffNew = HFF_INVALID;       // IFI handle to font file
    ULONG        cjDV = (pdv ? SIZEOFDV(pdv->dvNumAxes) : 0);
    FNTCHECKSUM  fntCheckSum;

    PVOID pvQuickBuffer[QUICK_VIEWS], *ppvViews;
    ULONG pcjQuickBuffer[QUICK_VIEWS], *pcjViews;

    if(cNumFonts > QUICK_VIEWS)
    {
        if(!(ppvViews = (VOID**) PALLOCMEM((sizeof(void*)+sizeof(ULONG*))*cNumFonts,
                                           'vffG')))
        {
            WARNING("bLoadRemoteFonts unable to allocate memory\n");

            // need to free ppfv if this function (bLoadRemoteFonts) fails
            if (ppfv)
            {
                VFREEMEM (ppfv);
            }
            return(FALSE);
        }

        pcjViews = (ULONG*) &ppvViews[QUICK_VIEWS];
    }
    else
    {
        ppvViews = pvQuickBuffer;
        pcjViews = pcjQuickBuffer;
    }

    UINT i;

    for(i = 0; i < cNumFonts; i++)
    {
        ppvViews[i] = ppfv[i]->fv.pvViewFD;
        pcjViews[i] = ppfv[i]->fv.cjView;
    }

    PPDEV   ppDevList;

// order of grabbing semaphores important

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
    vLoadFontFileView(NULL, 0, ppfv, cNumFonts, ppvViews, pcjViews, pdv, cjDV, &hffNew, &ppDevList, &fntCheckSum);
    PDEVOBJ pdo((HDEV)ppDevList);
    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    if(ppvViews != pvQuickBuffer)
    {
        VFREEMEM(ppvViews);
    }

    ASSERTGDI(bRet==FALSE,"bRet != FALSE\n");

    if (hffNew != HFF_INVALID)
    {
        //
        // cFonts = number of faces in the file
        //

        cFonts = pdo.QueryFontFile( hffNew, QFF_NUMFACES, 0, NULL);

        if (cFonts && cFonts != FD_ERROR)
        {
            WCHAR awc[30];

            // Create a (hopefully) unique file name for
            // the remote font of the form "REMOTE nnnnnnnn"

            swprintf(
                awc,
                L"REMOTE-%u",
                ulGetNewUniqueness(PUBLIC_PFTOBJ::ulRemoteUnique));
                ULONG cwc = wcslen(awc) + 1;

            // Create new PFF with table big enough to accomodate
            // the new fonts and pathname.

            PFFCLEANUP *pPFFC = 0;
            PFFMEMOBJ
            pffmo (cFonts,
                   awc, cwc, cNumFonts,  // pwsz, cwc, cFiles
                   pdv, cjDV,            // pdv, cjDV,
                   hffNew,
                   pdo.hdev(),
                   0,
                   pPFT,
                   PFF_STATE_DCREMOTE_FONT,
                   FR_NOT_ENUM, // never enum fonts that are temporarily
                   &fntCheckSum,
                   ppfv,        // loaded on printer server until print job is done
                   pufi);       // use this ufi instead of calculate from the ppfv for remote printing
            if (pffmo.bValid())
            {
                // Tell the PFF user object to load its table of
                // HPFE's for each font in file.


                if (  pffmo.bLoadFontFileTable(awc,
                                               cFonts,
                                               dco.hdc(),
                                               pufi,   // fonts can be mapped only by bFoundForcedMatch() calls
                                               NULL    // for remote printing.
                                              ))
                {
                    // Stabilize font table before searching or modifying it.

                    SEMOBJ so2(ghsemPublicPFT);

                    if(bRet = pffmo.bAddHash(FALSE))
                    {
                        PFF **ppPFF, *pPFF;

                        pPFF = pPFFGet(awc, cwc, cNumFonts, pdv, cjDV, &ppPFF);

                        if (pPFF)
                        {
                        #if DBG
                            KdPrint(("\"%ws\" has been found on the font table\n"));
                            KdBreakPoint();
                        #endif

                            bRet = FALSE;
                        }
                        else
                        {
                            pPFF = pffmo.pPFFGet();
                            if( bRet = dco.bAddRemoteFont( pPFF ) )
                            {
                                pPFT->cFiles++;

                                // place the pointer to this new remote
                                // PFF at the head of the public PFT.

                                if (*ppPFF)     // head of list exist?
                                {               // yes make it follow new PFF
                                    (*ppPFF)->pPFFPrev = pPFF;
                                }
                                pPFF->pPFFNext = *ppPFF;
                                pPFF->pPFFPrev = 0; // new PFF is first in list
                                *ppPFF = pPFF;

                                pffmo.vKeepIt();
                            }
                        }
                    }
                    else
                    {
                        pffmo.vRemoveHash();
                    }

                    // Here we should add it to our HDC's font table.
                }

                // call this if the above addition to the HDC's font table
                // fails

                if (!bRet)
                {
            pffmo.vPFFC_DeleteAndCleanup();  // new code
        }
            }
        }
    }
    return(bRet);
}


/******************************Public*Routine******************************\
* PFTOBJ::bLoadDeviceFonts
*
* This function loads the device fonts of the device identified by the pair
* (pldo, hdev) into the public table.  There are cFonts number of device
* fonts.
*
* The function will enlarge the PFT and create a PFF to contain the new fonts.
* The actual work of loading each device font into the tables is carrided
* out by PFF::bLoadDeviceFontTable().
*
* Note:
*   All the device fonts of a particular physical device are grouped together
*   as if they were in a single file and are placed all within a single PFF,
*   with each font represented by a single PFE.
*
* Note:
*   The function does not bother to check if the device fonts already are
*   in the tree.*
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  Mon 15-Aug-1994 11:57:14 by Kirk Olynyk [kirko]
* Modified it for the new hashing scheme (not the same thing as font name
* hashing, which remains unchanged).
*  18-Mar-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
DEVICE_PFTOBJ::bLoadFonts(
    PPDEVOBJ    ppdo
    )
{
    PFF *pPFF, **ppPFF;
    BOOL bRet = FALSE;
    FNTCHECKSUM fntCheckSum;

    {
        SEMOBJ so(ghsemPublicPFT);
        if (pPFFGet(ppdo->hdev(), &ppPFF))
        {
            bRet = TRUE;
        }
    }

    if (!bRet)
    {
        //
        // create new PFF with table big enough to accomodate the
        // new device fonts
        //
        // the 'dhpdev' is used only for drivers that are font producers,
        // and consequently are not affected by dynamic mode changing.
        // We have to call 'dhpdevNotDynamic' to avoid an assert
        //

        fntCheckSum.ulFastCheckSum = 0;
        fntCheckSum.ulCheckSum = 0;

        PFFMEMOBJ pffmo(ppdo->cFonts(),
                        NULL,0,0,         // no path, no files,
                        NULL, 0,          // no pdv, cjDV,
                        HFF_INVALID,
                        ppdo->hdev(),
                        ppdo->dhpdevNotDynamic(),
                        pPFT,
                        0,
                        0,       // flEmbed
                        &fntCheckSum,    // pointer to PFNTCHECKSUM, on return fill in slow check sum
                        NULL,    // no views of the mapped font files
                        NULL     // pufi
                        );

        if (pffmo.bValid())
        {
            if (!pffmo.bLoadDeviceFontTable(ppdo))
            {
                WARNING("pffmo.bLoadDeviceFontTable() failed\n");
            }
            else
            {
                SEMOBJ so(ghsemPublicPFT);

                // if (!font_is_loaded_already) add_font_to_table;

                if (!(pPFF = pPFFGet(ppdo->hdev(), &ppPFF)))
                {
                    if (!pffmo.bAddHash(FALSE))
                    {
                        WARNING("gdisrv!bLoadDeviceFontsPFTOBJ()"
                                ": failed to add to font hash\n");
                        pffmo.vRemoveHash();
                    }
                    else
                    {
                        // Add file to font table

                        // Insert PFF at the head of the linked list
                        // pointed to by ppPFF

                        pPFF = pffmo.pPFF;  // convenient pointer.
                        pPFT->cFiles += 1;  // Increment total number
                                            //               of files in table.
                        if (*ppPFF)         // Is there a PFF at the head
                                            //         of the linked list?
                            (*ppPFF)->pPFFPrev = pPFF; // Yes, put this new
                        pPFF->pPFFNext = *ppPFF;       //  PFF in front of old.
                        pPFF->pPFFPrev = 0; // Nothing before new font.
                        *ppPFF = pPFF;      // Reset pointer to head of list.
                        pffmo.vKeepIt();    // Prevent ~PFFMEMOBJ from
                                            //                  freeing memory.
                        bRet = TRUE;
                    }
                }
            }
            if (!bRet)
            {
                pffmo.vPFFC_DeleteAndCleanup();  // new code
            }
        }
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* pwszBareName
*
* Given a string that may be either a complete path or a bare file name
* pwszBareName returns the bare file name with out the path.
*
* History:
*  7-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LPWSTR pwszBare( LPWSTR pwszPath )
{
    LPWSTR pwszTmp,pwszBareName;

    for( pwszTmp = pwszPath, pwszBareName = pwszPath ;
         *pwszTmp != (WCHAR) 0 ;
         pwszTmp ++ )
    {
        if( *pwszTmp == (WCHAR) '\\' )
        {
            pwszBareName = pwszTmp+1;
        }
    }
    return(pwszBareName);
}

#if 0

typedef struct _FONT_STRUCT_DATA {
    ULONG fontDataSize;
    ULONG fontMaxDataSize;
    ULONG cRegistryFonts;
    ULONG cMaxRegistryFonts;
    ULONG cHashBuckets;
    PBYTE pFont;
} FONT_STRUCT_DATA, *PFONT_STRUCT_DATA;

extern "C"
NTSTATUS
QueryRegistryFontListRoutine
(
    PWSTR ValueName,
    ULONG ValueType,
    PVOID ValueData,
    ULONG ValueLength,
    PVOID Context,
    PVOID EntryContext
)
{

    PFONT_STRUCT_DATA pFontStructData = (PFONT_STRUCT_DATA) Context;
    ULONG Length;

    if ( (pFontStructData->fontDataSize + ValueLength >
          pFontStructData->fontMaxDataSize) ||
         (pFontStructData->cRegistryFonts >= pFontStructData->cMaxRegistryFonts) ||
         (pFontStructData->cRegistryFonts >= pFontStructData->cHashBuckets) )
    {
        //
        // The buffer is too small - reallocate it (leave lots of place to
        // build the hash table at the end
        //

        PBYTE pjBuffer;
        ULONG i;
        ULONG oldMaxSize = pFontStructData->fontMaxDataSize;

        pFontStructData->fontMaxDataSize += 0x100;
        pFontStructData->cMaxRegistryFonts += 10;
        pFontStructData->cHashBuckets = pFontStructData->cMaxRegistryFonts * 2;

        pjBuffer = (PBYTE) PALLOCMEM(pFontStructData->fontMaxDataSize +
                                     pFontStructData->cMaxRegistryFonts *
                                         sizeof(PBYTE) +
                                     pFontStructData->cHashBuckets *
                                          sizeof(REGHASHBKT) * 2, 'gerG');

        //
        // The buffer has three sections
        // 1) the first part of the buffer contains all the NULL terminated
        //    strings of the font files.
        // 2) an array of pointers to these strings.
        // 3) space for the hash table
        //
        // When copying the buffer, 1) can just be moved, 2) has to be adjusted
        // and 3) is not touched - has to be zero initialized
        //

        if (pjBuffer)
        {
            //
            // If we have an old one, move it to the new one, and then
            // always reset the pointer.
            //

            if (pFontStructData->fontDataSize)
            {
                //
                // Adjust the pointers - requires doing arithmetic on the
                // pointers themselves !
                //

                for (i=0; i < pFontStructData->cRegistryFonts; i++)
                {
                    *( ((PULONG)(pjBuffer +
                    pFontStructData->fontMaxDataSize)) + i ) =
                        *( ((PULONG)(pFontStructData->pFont + oldMaxSize)) + i )
                        + pjBuffer - pFontStructData->pFont;
                }

                //
                // Copy all the data to the new Buffer
                //

                RtlMoveMemory(pjBuffer,
                              pFontStructData->pFont,
                              pFontStructData->fontDataSize);

                VFREEMEM(pFontStructData->pFont);
            }

            pFontStructData->pFont = pjBuffer;
        }
        else
        {
            //
            // we do not have enough memory - return failiure
            //

            return STATUS_NO_MEMORY;
        }
    }

    Length = cCapString((PWSTR) (pFontStructData->pFont +
                                     pFontStructData->fontDataSize),
                        (PWSTR) ValueData,
                        ValueLength / 2);

    ASSERTGDI(Length * 2 + 2 == ValueLength,
              "QueryRegistryFontListRoutine CapString problem\n");

    * ( ((PBYTE *)(pFontStructData->pFont + pFontStructData->fontMaxDataSize)) +
        pFontStructData->cRegistryFonts) =
            pFontStructData->pFont + pFontStructData->fontDataSize;

    pFontStructData->fontDataSize += ValueLength;
    pFontStructData->cRegistryFonts += 1;

    return STATUS_SUCCESS;

}

#endif

/******************************Public*Routine******************************\
*
* BOOL PFTOBJ::bUnloadAllButPermanentFonts
*
* If bUnloadPermanent == FALSE (default):
*
* Called at log-off time to force unloading off all but permanent
* fonts Permanent fonts are defined as either console fonts or
* fonts from Gre_Initialize section of win.ini (i.e.  registry).
* Fonts from the "Fonts" section in win.ini (registry) are also
* permanent if they are on the local hard drive.  If they are
* remote they will get reloaded at the log on time.  This should
* be done after the net connections from the user profile are
* restored so that the font can get reloaded.
*
* If bUnloadPermanent == TRUE:
*
* All fonts in table are unloaded.  Only used for MultiUserGreCleanupAllFonts
* (i.e, MultiUserGreCleanup or Hydra processing).
*
* History:
*  30-Nov-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

typedef struct _FONTVICTIM
{
    PFF   *pPFFVictim;
    RFONT *prfntVictims;
} FONTVICTIM;

FONTVICTIM gFntVict[64];

BOOL PFTOBJ::bUnloadAllButPermanentFonts (BOOL bUnloadPermanent)
{
    // pointer to the array of cFonts victim structures.  Only as
    // many entries of this array will be initialized as there are
    // non-permanent fonts in the pft.  These fonts will be deleted
    // outside of the pft semaphore.

    FONTVICTIM *pvict, *pvictCur;
    COUNT      cFile, cFonts;
    PFF        *pPFF;
    BOOL        bAlloc = FALSE;

    // Look for the PFF to unload.

    {
        // Stablize table while we scan it for victims.

        SEMOBJ so(ghsemPublicPFT);

        // alloc mem for the array of font victims
        // It is essential that this memory is zero initialized
        // This must be done under semaphore, otherwise cFonts might change;

        cFonts = pPFT->cFiles;

        if (cFonts == 0)
        {
            // gpPFTDevice initialized but no device font loaded.
            // Seen this on Hydra.

            return TRUE;
        }

        if ( cFonts > 64)
        {
            if (!(pvict = (FONTVICTIM *)PALLOCNOZ(cFonts * sizeof(FONTVICTIM),'ivfG')))
            {
                WARNING(
                    "PFTOBJ::bUnloadAllButPermanentFonts failure\n"
                    "Failed to allocate memeory for font victim list\n");

                return FALSE;
            }

            bAlloc = TRUE;
        }
        else
        {
            pvict = &gFntVict[0];
        }

        pvictCur = pvict;

        // Caution with this code: pPFT->cFiles changes in the loop
        // This loop does two things:
        // a) stores the pPFFVictim information in the pvict array
        //    for the fonts that are going to be unloaded outside
        //    the semaphore.
        // b) contracts the pft table to contain only the permanent
        //    fonts upon the exit of the loop

        for (
            PFF **ppPFF = pPFT->apPFF
          ; ppPFF < pPFT->apPFF + pPFT->cBuckets
          ; ppPFF++
        )
        {
          for (pPFF = *ppPFF; pPFF; pPFF = pPFF->pPFFNext)
          {
            // Create a PFF user object.  There shouldn't be any invalid
            // handles in the PFT.

            PFFOBJ  pffo(pPFF);
            ASSERTGDI(pffo.bValid(),
                "gdisrv!bUnloadFontPFTOBJ(file): bad PPFF in public PFT\n");

            // Is it a font driver loaded file?  And if so, is this not a
            // permanent file (listed in Gre_Initialize or loaded by
            // console or local font from "fonts" section of the registry)
            // We also leave alone fonts loaded temporarily for printing

            if (bUnloadPermanent || !(pffo.bPermanent() || pffo.bDCRemote()))
            {
                ASSERTGDI(!pffo.bDCRemote(), "bUnloadAllButPermanentFonts: "
                          "EMF spooler playback fonts still present!\n");

                // Tell PFF to decrement its load count and ask it if is
                // ready to die.  If it returns TRUE, we will need to delete
                // (outside of semaphore since PFF deletion may cause driver
                // to be called).

                // we force the load count to zero. We are forcing the unload
                // of this font

                pffo.vSet_cLoaded((COUNT)0); // not loaded any more,
                                             // avoid asserts
                pffo.vSet_cNotEnum((COUNT)0);

                pffo.vKill();

                {
                    // unlink the PFF from the collision list

                    if (*ppPFF == pPFF)
                    {
                        // The hash bucket contains a pointer to the first
                        // PFF in the collision list. If it turns out that
                        // the victim is this first in the list, then the
                        // address storred in the hash bucket must be changed

                        *ppPFF = pPFF->pPFFNext;
                    }
                    if (pPFF->pPFFNext)
                    {
                        pPFF->pPFFNext->pPFFPrev = pPFF->pPFFPrev;
                    }
                    if (pPFF->pPFFPrev)
                    {
                        pPFF->pPFFPrev->pPFFNext = pPFF->pPFFNext;
                    }
                }
                // Save handle of victim.

                pvictCur->pPFFVictim = pffo.pPFFGet();

                // Remove PFF and PFEs from hash tables.  Fonts in this
                // font file will no longer be enumerated or mapped to.

                pffo.vRemoveHash();
                pPFT->cFiles--;

                // Construct a "kill" list of RFONTs.

                pvictCur->prfntVictims = prfntKillList(pffo);

                // point to the next entry in pvictCur array

                pvictCur++;
            }
            else
            {
                // this is a permanent or a device font, leave them in
                // set init to 1 for the next logon session

                if (pffo.bPermanent() && !(pPFF->flState & PFF_STATE_EUDC_FONT))
                {
                    if ( pffo.cLoaded() )
                    {
                        pffo.vSet_cLoaded((COUNT)1);
                        pffo.vSet_cNotEnum((COUNT)0);
                    }
                    else
                    {
                        pffo.vSet_cLoaded((COUNT)0);
                        pffo.vSet_cNotEnum((COUNT)1);
                    }
                }
            }
          }
        } // end of the for loop

    // at this time if any font were in the private font table, the process
    // cleanup should have removed them (this is logoff time!), therefore there
    // is nothing we need to do about private font table

        #if DBG

        PUBLIC_PFTOBJ pftop(gpPFTPrivate);

        ASSERTGDI((gpPFTPrivate == NULL) || (pftop.cFiles() == 0),
            "some private fonts still around at logoff time\n");

        #endif
    }

// Delete the victims that were found:
// Overload cFonts to mean cFontsToBeDeleted:

// Sundown truncation

    ASSERT4GB((ULONGLONG)(pvictCur - pvict));
    cFonts = (ULONG)(pvictCur - pvict);

    for (cFile = 0; cFile < cFonts; cFile++)
    {
        ASSERTGDI(
            pvict[cFile].pPFFVictim != (PPFF) NULL,
            "GreRemoveAllButPermanentFonts, pPFFVictim IS null\n"
            );
        PFFOBJ pffoVictim(pvict[cFile].pPFFVictim);
        ASSERTGDI(pffoVictim.bValid(),
            "gdisrv!bUnloadFontPFTOBJ(device): PFF victim bad\n");

    // If we need to kill any RFONT victims, now is the time to do it.
    // bKillRFONTList() can handle NULL prfntVictims case.
    // Note that we do not check the return, we go on to the
    // next font [bodind]

        bKillRFONTList(pffoVictim, pvict[cFile].prfntVictims);
    }

// release memory

    if (bAlloc)
        VFREEMEM(pvict);

// We didn't delete anything, but we're ok as long as we found the right
// PFF.  PFF still referenced (either load count or RFONT count) and will
// be deleted later.

    return(TRUE);
}

/******************************Public*Routine******************************\
* bUnloadWorkhorse
*
* History:
*  Mon 15-Aug-1994 14:10:53 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL PFTOBJ::bUnloadWorkhorse(
    PFF *pPFF,
    PFF **ppPFFHead,             // bucket address
    HSEMAPHORE hsem,             // if the pointer is not zero,
                                 //  then this must be a pointer
                                 //  to the public font table
                                 //  semaphore and must be released
                                 //  before this procedure returns
    ULONG   flEmbed              //  Embedding/private flag
)
{
    GDIFunctionID(PFTOBJ::bUnloadWorkhorse);

    PFF *pPFFVictim     = 0;    // Pointer to PFF to be deleted, only
                                // non zero when found and deleted

    BOOL bFoundPFF = FALSE;     // signals PFF was found (does not
                                // indicate deletion status);

    static const PSZ pszReleaseSem = "PFTOBJ::bUnloadWorkhorse()"
                                     " releasing gpPFTPublic";

    TRACE_FONT((
        "Entering PFTOBJ::bUnloadWorkhorse\n"
        "\tpPFF=%-#x\n"
        "\tppPFFHead=%-#x\n",
        "\thsem=%-#x\n",
        pPFF, ppPFFHead, hsem
    ));
    ASSERTGDI(!hsem || hsem==ghsemPublicPFT, "hsem!=ghsemPublicPFT\n");

    if ( pPFF )
    {
        PFFOBJ pffo(pPFF);
        ASSERTGDI(pffo.bValid(), "bad PPFF in public PFT\n");
        PVTDATA *pPvtData = NULL;

        if ((!bIsPrivatePFT()) || (pPvtData = pffo.pPvtDataMatch()))
        {
            // Tell PFF to decrement its load count and ask it if is
            // ready to die.  If it returns TRUE, we will need to
            // delete (outside of semaphore since PFF deletion may
            // cause driver to be called).

            bFoundPFF = TRUE;
            BOOL        bWrongFlags = FALSE;

            if ( pffo.bDeleteLoadRef(flEmbed, pPvtData, &bWrongFlags) )
            {
                // Remove PFF and PFEs from hash tables.  Fonts in this
                // font file will no longer be enumerated or mapped to.

                pffo.vRemoveHash();

                // now remove it from the font table hash

                pPFFVictim = pPFF;

                // If ppPFFHead is NULL then it means that we are
                // unloading  a font that has been added to the DC
                // as a remote font and the this must be the public
                // font table

                PFF **ppPFF = ppPFFHead;
                if( ppPFF == 0 )
                {
                    PUBLIC_PFTOBJ *pTemp;
                    PFF *pPFF_Found;

                    ASSERTGDI(pPFF->pPFT==gpPFTPublic || pPFF->pPFT==gpPFTPrivate,"PFF not in public font table\n");

                    pTemp = (PUBLIC_PFTOBJ*) this;

                    pPFF_Found = pTemp->pPFFGet(pPFF->pwszPathname_,
                                                pPFF->cwc,
                                                pPFF->cFiles,
                                                pPFF->pdv_,
                                                pPFF->cjDV_,
                                                &ppPFF
                                                );

                    ASSERTGDI(pPFF==pPFF_Found,"Could not find remote PFF in the font table\n");
                }
                if (*ppPFF == pPFF)
                {
                    *ppPFF = pPFF->pPFFNext;
                }
                if (pPFF->pPFFNext)
                {
                    (pPFF->pPFFNext)->pPFFPrev = pPFF->pPFFPrev;
                }
                if (pPFF->pPFFPrev)
                {
                    (pPFF->pPFFPrev)->pPFFNext = pPFF->pPFFNext;
                }
                pPFT->cFiles--;
            }
            else
            {
            // Set the return value as FALSE for private/embedded fonts

                if (bIsPrivatePFT() && bWrongFlags)
                {
                    bFoundPFF = FALSE;
                }
            }
        }
        if ( pPFFVictim )
        {
            PFFOBJ pffoVictim(pPFFVictim);
            if ( !pffoVictim.bValid() )
            {
                RIP("pffoVictim is not valid\n");
                bFoundPFF = 0;
            }
            else
            {
                if ( hsem )
                {
                    // The victim has been removed from the table
                    // so the semaphore for the table may be safely
                    // released. It is necessary to do this because
                    // bKillRFONTList() calls RFONTOBJ::bDeleteRFONT()
                    // which in turn locks the display. If we do
                    // not release the font table semaphore before
                    // the device lock, we will have deadlock.

                    TRACE_FONT(("%ws\n", pszReleaseSem));
                    GreReleaseSemaphoreEx(hsem);
                    hsem = 0;
                }

                bFoundPFF = bKillRFONTList( pffoVictim, prfntKillList( pffoVictim ));
            }
        }

        // We didn't delete anything, but we're ok as long as we found
        // the right PFF.  PFF still referenced (either load count or
        // RFONT count) and will be deleted later.
    }

    // Make sure the semampore is released before the procedure ends
    if( hsem )
    {
        TRACE_FONT(("%ws\n", pszReleaseSem));
        GreReleaseSemaphoreEx(hsem);
    }

    TRACE_FONT(("Exiting PFTOBJ::bUnloadWorkhorse\n"
                "\treturn value = %d\n", bFoundPFF));
    return( bFoundPFF );
}

/****************************************************************************
*  INT PFTOBJ::QueryFonts( PUNIVERSAL_FONT_ID, ULONG, PLARGE_INTEGER )
*
*  History:
*   5/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/


INT PUBLIC_PFTOBJ::QueryFonts(
    PUNIVERSAL_FONT_ID pufi,
    ULONG nBufferSize,
    PLARGE_INTEGER pTimeStamp
)
{
    ULONG cFonts = 0;
    *pTimeStamp = PFTOBJ::FontChangeTime;

// if we aren't supplied with a buffer just return the time stamp and number
// of fonts

    if( ( pufi == NULL ) || ( nBufferSize == 0 ) )
    {
        return(pPFT->cFiles + (UFI_TYPE1_RASTERIZER(&gufiLocalType1Rasterizer) ? 1 : 0));
    }

    PFF *pPFF;
    SEMOBJ so(ghsemPublicPFT);

// Fill the first position with the identifier for the local rasterizer if one
// exists.  This must be the first UFI in the list if it exists.

    if(UFI_TYPE1_RASTERIZER(&gufiLocalType1Rasterizer))
    {
        pufi[cFonts++] = gufiLocalType1Rasterizer;
    }

    for (
        PFF **ppPFF = pPFT->apPFF
      ; (ppPFF < pPFT->apPFF + pPFT->cBuckets) && (cFonts < nBufferSize)
      ; ppPFF++
    )
    {
      for (pPFF = *ppPFF; (pPFF) && (cFonts<nBufferSize); pPFF = pPFF->pPFFNext)
      {
        // Create a PFF user object.  There shouldn't be any invalid
        // handles in the PFT.

        PFFOBJ  pffo(pPFF);
        ASSERTGDI(pffo.bValid(),
            "gdisrv!bUnloadFontPFTOBJ(file): bad PPFF in public PFT\n");

        // be sure not to include remote fonts in list

        if (!pffo.bDCRemote())
        {
        // Set the Index to 1.  This value can be anything since we will only
        // be using the UFI's passed back to determine if font file match.
        // We could just pass back checksums but we may need to expand the
        // UFI structure to include more than checksum's which is why I'm
        // using UFI's.

            pufi[cFonts].Index = 1;
            pufi[cFonts++].CheckSum = pffo.ulCheckSum();
        }
      }
    }

    return(cFonts);
}




/******************************Public*Routine******************************\
* prfntKillList
*
* Scans the display PDEV list looking for inactive RFONTs that realized
* from the given PFF.  These RFONTs are put into a linked list (using the
* PDEV RFONTLINKs) that is returned as the function return.
*
* The function is quite aggressinve in its definition of an inactive RFONT.
* In addition to looking for victims on the inactive list of each PDEV,
* the function also scans the DC list off each PDEV for RFONTs that are
* selected into currently unused DCs.
*
* We're not worried about being aggressive with non-display PDEVs.  The
* PDEV cleanup code will destroy extraneous RFONTs directly using the PDEV's
* RFONT list(s).
*
* The reason we are building a list of RFONT victims rather than killing
* them immediately is because we are holding the ghsemPublicPFT semaphore
* when this function is called.
*
* Returns:
*   Pointer to the kill list, NULL if the list is empty.
*
* History:
*  11-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

RFONT *prfntKillList(PFFOBJ &pffoVictim)
{
    TRACE_FONT((
        "Entering prfntKillList\n\tpffoVictim.pPFF = %-#x\n",pffoVictim.pPFF));
    RFONT *prfntDeadMeat = PRFNTNULL;

    // Must hold this semaphore to be sure that the display
    // PDEV list is stable.

    SEMOBJ so1(ghsemDriverMgmt);

    // Must hold this semaphore so we can manipulate the RFONT links and
    // RFONT::cSelected.

    SEMOBJ so2(ghsemRFONTList);
    TRACE_FONT(("Acquiring ghsemRFONTList\n"));

    // Must hold this mutex so that no one else tries to come in and lock
    // a DC while we're scanning the DC lists off the PDEVs.
    //
    // Since we're holding this mutex, we must be extremely careful not
    // to create any user objects that will try to regrab the mutex.
    // That is bad bad bad bad.

    MLOCKFAST mlf;
    TRACE_FONT(("Acquiring handle management semaphore\n"));

    PDEV *pPDEV = gppdevList;

    // Scan through the list of display PDEVs.

    while (pPDEV != NULL)
    {
        if (pPDEV->fl & PDEV_DISPLAY)
        {
            // Scan the RFONT active list for candidates made inactive by our
            // scan of the DC list.

            RFONT *prfntCandidate;

            for ( prfntCandidate = pPDEV->prfntActive;
                  prfntCandidate != PRFNTNULL;
                )
            {
                RFONTTMPOBJ rfo(prfntCandidate);

                // We have to grab the next pointer before we (possibly)
                // remove the current RFONT from the list.

                prfntCandidate = prfntCandidate->rflPDEV.prfntNext;

                // If this is an interesting RFONT (i.e., uses our PFF),
                // then take it out of the list.

                if ( (rfo.pPFF() == pffoVictim.pPFFGet()) && !rfo.bActive() )
                {
                    RFONT *prfntHead = pffoVictim.prfntList();
                    rfo.vRemove(&prfntHead, PFF_LIST);
                    pffoVictim.prfntList(prfntHead);

                    rfo.vRemove(&pPDEV->prfntActive, PDEV_LIST);
                    rfo.vInsert(&prfntDeadMeat, PDEV_LIST);
                }
            }

            // Scan the RFONT inactive list for candidates.

            for (prfntCandidate = pPDEV->prfntInactive;
                 prfntCandidate != PRFNTNULL;
                 )
            {
                RFONTTMPOBJ rfo(prfntCandidate);

                // We have to grab the next pointer before we (possibly)
                // remove the current RFONT from the list.

                prfntCandidate = prfntCandidate->rflPDEV.prfntNext;

                // If this is an interesting RFONT (i.e., uses our PFF),
                // then take it out of the list.

                if ( rfo.pPFF() == pffoVictim.pPFFGet() )
                {
                    RFONT *prfntHead = pffoVictim.prfntList();
                    rfo.vRemove(&prfntHead, PFF_LIST);
                    pffoVictim.prfntList(prfntHead);

                    rfo.vRemove(&pPDEV->prfntInactive, PDEV_LIST);
                    rfo.vInsert(&prfntDeadMeat, PDEV_LIST);

                    // Since we've removed a font from the inactive list, we
                    // need to update the count in the PDEV.

                    pPDEV->cInactive -= 1;
                }
            }
        }
        pPDEV = pPDEV->ppdevNext;
    }
    TRACE_FONT(("Releasing handle management semaphore\n"));
    TRACE_FONT(("Releasing ghsemRFONTList\n"));
    TRACE_FONT(("Releasing ghsemDriverMgmt\n"));
    TRACE_FONT(("Exiting prfntKillList\n\treturn value=%-#x\n", prfntDeadMeat));
    return(prfntDeadMeat);
}

/******************************Public*Routine******************************\
* bKillRFONTList
*
* Runs down a linked list (that is linked via the PDEV RFONTLINK's) and
* deletes each RFONT on it.  Hold no global semaphores while calling this
* because we may call out to a driver.
*
* History:
*  11-Mar-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bKillRFONTList(PFFOBJ &pffoVictim, RFONT *prfntVictims)
{
    // If kill list is NULL, it is already OK to delete the PFF.
    // However, we will have to do the work in here rather than let
    // RFONTOBJ::bDeleteRFONTRef() do the work for us.

    BOOL bRet;
    TRACE_FONT((
        "Entering bKillRFONTList\n"
        "\t*pffoVictim.pPFF=%-#x\n"
        "\tprfntVictims=%-#x\n"
        , pffoVictim.pPFF, prfntVictims
    ));

    if (prfntVictims == (PRFONT) NULL)
    {
        BOOL    bCleanUp = FALSE;

        PFFCLEANUP pffc;

        {
            // Need semaphore to access cRFONT.

            SEMOBJ so(ghsemPublicPFT);

            // If no more RFONTs for this PFF, OK to delete.
            // Load count is implied to be zero
            // (only time we call this function).

            // For private/embedded fonts, pPvtDataHead needs to be NULL too.

            ASSERTGDI( (pffoVictim.cLoaded() == 0 && pffoVictim.cNotEnum() == 0 && pffoVictim.pPvtDataHeadGet() == NULL),
                "gdisrv!bKillRFONTList(): PFF load count not zero\n");

            if (pffoVictim.cRFONT() == 0)
            {
            // It is now safe to delete the PFF.

                pffoVictim.vPFFC_Delete(&pffc);

                bCleanUp = TRUE;
            }
        }

        // Call the driver outside of the semaphore.

        if (bCleanUp)
        {
            vCleanupFontFile(&pffc);     // function can handle NULL case
        }

        bRet = TRUE;

    }
    else
    {

        // Otherwise, we will delete the RFONTs in the kill list.  If and when
        // the last RFONT dies, RFONTOBJ::bDeleteRFONTRef() will delete the PFF.

        PRFONT prfnt;

        while ( (prfnt = prfntVictims) != (PRFONT) NULL )
        {
            prfntVictims = prfntVictims->rflPDEV.prfntNext;

            RFONTTMPOBJ rflo(prfnt);

            ASSERTGDI(!rflo.bActive(),
                "gdisrv!bKillRFONTList(): RFONT still active\n");

            PDEVOBJ pdo(rflo.hdevConsumer());
            ASSERTGDI(pdo.bValid(), "gdisrv!bKillRFONTList(): invalid HPDEV\n");

            rflo.bDeleteRFONT((PDEVOBJ *) NULL, (PFFOBJ *) NULL);
            bRet = pffoVictim.bDeleteRFONTRef();
        }
    }
    TRACE_FONT(("Exiting bKillRFONTList\n\treturn value = %d\n", bRet));
    return(bRet);
}

/******************************Public*Routine******************************\
* cCapString (pwcDst,pwcSrc,cMax)                                          *
*                                                                          *
* A useful routine to capitalize a string.  This is adapted to our name    *
* strings that show up in logical fonts.  They may or may not have NULL    *
* terminators, but they always fit in a given width.                       *
*                                                                          *
* We assume that we may overwrite the last character in the buffer if      *
* there is no terminator!  (That's what the code was doing when I got      *
* to it.)                                                                  *
*                                                                          *
* Returns: The length, in characters, of the resultant string.             *
*                                                                          *
* History:                                                                 *
*  Sun 13-Dec-1992 17:22:25 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

LONG cCapString(WCHAR *pwcDst,WCHAR *pwcSrc,INT cMax)
{
    UNICODE_STRING csSrc,csDst;
    WCHAR *pwc,*pwcEnd;
    INT cLen;

    // Count the length of the given string, but note that we can be given a
    // string with cMax characters and no terminator!
    // In that case, we truncate the last character and replace it with NULL.

    pwc = pwcSrc;
    pwcEnd = pwc + cMax - 1;

    while (pwc<pwcEnd && *pwc)
        pwc++;

    // Sundown: cMax is int, pwcEnd = cMax -1, safe to truncate

    cLen = (int)(pwc - pwcSrc);            // cLen <= cMax-1, always.

    if (cLen)
    {
        // Initialize the counted string structures.

        csSrc.Length = (USHORT)(cLen * sizeof(WCHAR));    // Measured in bytes!
        csSrc.Buffer = pwcSrc;
        csSrc.MaximumLength = (USHORT)(cMax * sizeof(WCHAR));

        csDst.Buffer = pwcDst;
        csDst.MaximumLength = (USHORT)(cMax * sizeof(WCHAR));

        // Convert the string.

        RtlUpcaseUnicodeString(&csDst,&csSrc,FALSE);
    }

    // NULL terminate the result.

    pwcDst[cLen] = 0;
    return(cLen);
}

/******************************Member*Function*****************************\
* UINT iHash                                                               *
*                                                                          *
* A case dependent hashing routine for Unicode strings.                    *
*                                                                          *
* Input:                                                                   *
*                                                                          *
*   pwsz                    pointer to the string to be hashed             *
*   c                       number to be mod'ed against at the end         *
*                                                                          *
* Reutrns:                                                                 *
*                                                                          *
*   a 'random' number in the range 0,1,...,c-1                             *
*                                                                          *
* Note: All strings must be capitalized!                                   *
*                                                                          *
* History:                                                                 *
*  Wed 07-Sep-1994 08:12:22 by Kirk Olynyk [kirko]                         *
* Since chuck is gone the mice are free to play. So I have replaced        *
* it with my own variety. Tests show that this one is better. Of           *
* course, once I have gone someone will replace mine. By the way,          *
* just adding the letters and adding produces bad distributions.           *
*  Tue 15-Dec-1992 03:13:15 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  It looks crazy, but I claim there's a theory behind it.       *
\**************************************************************************/

UINT iHash(PWSZ pwsz, UINT c)
{
    unsigned i = 0;
    while (*pwsz)
    {
        // use the lower byte since that is where most of the
        // interesting stuff happens

        i += 256*i + (UCHAR) *pwsz++;
    }
    return(i % c);
}

/******************************Member*Function*****************************\
* FHOBJ::vInit                                                             *
*                                                                          *
* History:                                                                 *
*  Mon 14-Dec-1992 18:38:35 -by- Charles Whitmer [chuckwh]                 *
* Compressed the table to contain only pointers to buckets.                *
*                                                                          *
*  Tue 14-Apr-1992 13:48:53 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID FHOBJ::vInit(FONTHASHTYPE fht_,UINT c)
{
    pfh->id       = FONTHASH_ID;
    pfh->fht      = fht_;
    pfh->cBuckets = c;

    // Currently, none of the buckets are in use

    pfh->cUsed = 0;
    pfh->cCollisions = 0;
    RtlZeroMemory(pfh->apbkt,sizeof(*(pfh->apbkt)) * pfh->cBuckets);

    // Setup head and tail pointers to the doubly linked list of
    // buckets.  This list is maintained in load order.  The ordinal
    // of a bucket is the load time of the earliest loaded PFE in a
    // bucket's list.

    pfh->pbktFirst = (HASHBUCKET *) NULL;
    pfh->pbktLast  = (HASHBUCKET *) NULL;
}

/******************************Member*Function*****************************\
* FHOBJ::vFree                                                             *
*                                                                          *
* History:                                                                 *
*  Tue 15-Dec-1992 00:53:39 -by- Charles Whitmer [chuckwh]                 *
* Deletes remaining hash buckets.                                          *
*                                                                          *
*  Tue 14-Apr-1992 13:48:56 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID FHOBJ::vFree()
{
    HASHBUCKET *pbkt,*pbktNext;

    if (pfh)
    {
        // Unfortunately, we get called here while a string of PFE's may be
        // hanging on.  One of the PFTOBJ::bUnloadFont calls kills the PFE's
        // separately.
        // We still need to free the small pfel bloks that
        // define enumeration links

        // Clean up any hash buckets.

        for (UINT ii=0; ii<pfh->cBuckets; ii++)
        {
            for
            (
                pbkt = pfh->apbkt[ii];
                pbkt != (HASHBUCKET *) NULL;
                pbkt = pbktNext
            )
            {
                pbktNext = pbkt->pbktCollision;

                // now free the small linking blocks:

                {
                    PFELINK *ppfel = pbkt->ppfelEnumHead;
                    PFELINK *ppfelNext;
                    for ( ; ppfel ; ppfel = ppfelNext)
                    {
                        ppfelNext = ppfel->ppfelNext;
                        VFREEMEM(ppfel);
                    #if DBG
                        if (ppfelNext == NULL)
                        {
                            ASSERTGDI(ppfel == pbkt->ppfelEnumTail,
                               "FHOBJ::vFree(), problem with ppfelEnumTail\n");
                        }
                    #endif
                    }
                }

                VFREEMEM(pbkt);
            }
        }

        // Free the table itself.

        VFREEMEM(pfh);
    }
    pfh   = 0;
    *ppfh = 0;
}

/******************************Member*Function*****************************\
* FHOBJ::pbktSearch (pwsz,pi)                                              *
*                                                                          *
* Tries to locate a HASHBUCKET for the given string.  If found, a pointer  *
* is returned, else NULL.  If pi is non-NULL, the hash index is returned   *
* in either case.                                                          *
*                                                                          *
* History:                                                                 *
*  Mon 14-Dec-1992 21:11:14 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  Differs from KirkO's old iSearch in that it assumes that all  *
* strings are capitalized, and the hash table is full of pointers to       *
* HASHBUCKETs instead of HASHBUCKETs.                                      *
\**************************************************************************/

HASHBUCKET *FHOBJ::pbktSearch(PWSZ pwsz,UINT *pi,PUNIVERSAL_FONT_ID pufi, BOOL bEquiv)
{
    UINT i;
    WCHAR *pwcA,*pwcB;
    HASHBUCKET *pbkt;

// If we are requested to look only for equivalency buckets, and we find it,
// we shall return it.

// If we are asked to look for any kind of bucket, and we found equivalency
// bucket first in the linked list, we shall continue to search the linked
// list until we possibly find a non-equivalency bucket. If found both
// equivalency and non-equivalency bucket, we return non-equivalency bucket.
// If we find a non-equivalency bucket, we shall just return.

    HASHBUCKET *pbktEquiv = NULL;

// Locate the hash entry.

    if( pwsz == NULL )
    {
        i = UFI_HASH_VALUE(pufi) % pfh->cBuckets;
    }
    else
    {
        i = iHash(pwsz,pfh->cBuckets);
    }

// Return the index for those who care.

    if (pi != (UINT *) NULL)
        *pi = i;

// Try to find an existing bucket that matches exactly.

    for
    (
      pbkt =  pfh->apbkt[i];
      pbkt != (HASHBUCKET *) NULL;
      pbkt = pbkt->pbktCollision
    )
    {
        if( pufi != NULL )
        {
            if( UFI_SAME_FILE(&pbkt->u.ufi,pufi) )
            {
                return(pbkt);
            }
        }
        else
        {
            if (!bEquiv || (pbkt->fl & HB_EQUIV_FAMILY))
            {
                for (pwcA=pwsz,pwcB=pbkt->u.wcCapName; *pwcA==*pwcB; pwcA++,pwcB++)
                {
                    if (*pwcA == 0)
                    {
                        if (bEquiv)
                        {
                            return(pbkt);
                        }
                        else
                        {

                            if (pbkt->fl & HB_EQUIV_FAMILY)
                            {
                                pbktEquiv = pbkt;
                                break;
                            }
                            else
                            {
                                return(pbkt);
                            }
                        }
                    }
                }
            }
        }
    }
    return(pbktEquiv);
}


/******************************Public*Routine******************************\
*
* BOOL FHOBJ::bAddPFELink
*
* History:
*  02-Jul-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL FHOBJ::bAddPFELink(
    HASHBUCKET *pbkt,    // pointer to bucket with this family name/ufi (if found)
    UINT        iBucket, // index into hash table for this pfe
    WCHAR      *pwcCap,  // capitalized family name
    PFEOBJ&     pfeoNew, // pfe for which we are adding the link
    BOOL        bEquiv   // create equiv or non-equivalency bucket
)
{

    PFELINK *ppfel = NULL;

    if (ppfel = (PFELINK *)PALLOCMEM(sizeof(PFELINK), 'knlG'))
    {
        ppfel->ppfelNext = NULL; // we have just added it;
        ppfel->ppfe      = pfeoNew.ppfeGet();

    // we will create a new bucket if the bucket with this face name does not exist
    // or if we are attempting to create a non-equivalency bucket and we have only
    // found an equivalency name bucket with this family name.

        if ((pbkt == (HASHBUCKET *) NULL) || (!bEquiv && (pbkt->fl & HB_EQUIV_FAMILY)))
        {
            pbkt = (HASHBUCKET *) PALLOCMEM(sizeof(HASHBUCKET), 'bahG');
            if (pbkt == (HASHBUCKET *) NULL)
            {
                VFREEMEM(ppfel);
                return(FALSE);
            }

            // Link the PFE into the empty lists.

            pbkt->ppfelEnumHead = pbkt->ppfelEnumTail = ppfel;

            // Set up the linked list pointers.  We always add new buckets at the
            // tail of the load order linked list.

            if ( pfh->pbktFirst == (HASHBUCKET *) NULL )
            {
                // Special case: this is the first bucket to be put on the list.

                pfh->pbktFirst = pbkt;
                pfh->pbktLast = pbkt;

                pbkt->pbktPrev = (HASHBUCKET *) NULL;
                pbkt->pbktNext = (HASHBUCKET *) NULL;
            }
            else
            {
                pbkt->pbktPrev = pfh->pbktLast;
                pbkt->pbktNext = (HASHBUCKET *) NULL;

                pfh->pbktLast->pbktNext = pbkt;
                pfh->pbktLast = pbkt;
            }

            // Record the time stamp of the bucket.  Its time stamp is the
            // time stamp of its oldest (or first) PFE.  Since this is a new
            // bucket, the time stamp is automatically that of pfeoNew.

            pbkt->ulTime = pfeoNew.ulTimeStamp();

            // Finish up.

            pbkt->fl        = bEquiv ? HB_EQUIV_FAMILY : 0;
            pbkt->cTrueType = (pfeoNew.flFontType() & TRUETYPE_FONTTYPE) ? 1 : 0;
            pbkt->cRaster   = (pfeoNew.flFontType() & RASTER_FONTTYPE) ? 1 : 0;

            // Copy in the string.

            if( fht() == FHT_UFI )
            {
                pfeoNew.vUFI( &(pbkt->u.ufi) );
            }
            else
            {
                for (INT ii=0; ii<LF_FACESIZE; ii++)
                    pbkt->u.wcCapName[ii] = pwcCap[ii];
            }

            // link the bucket into the hash table.

            pbkt->pbktCollision = pfh->apbkt[iBucket];
            if (pbkt->pbktCollision != (HASHBUCKET *) NULL)
                pfh->cCollisions++;
            pfh->apbkt[iBucket] = pbkt;
            pfh->cUsed++;
        }
        else
        {
            // In the following we have found an existing HASHBUCKET.
            // We can assume that its lists are non-empty.

            // Insert into the font enumeration list.  The new PFE is inserted at
            // the tail because we want to preserve the order in which fonts are
            // added to the system (Windows 3.1 compatibility).

            // Append new PFELINK to old tail and fixup the tail pointer

            pbkt->ppfelEnumTail->ppfelNext = ppfel;
            pbkt->ppfelEnumTail = ppfel;

            // Track the number of TrueType fonts.

            if (pfeoNew.flFontType() & TRUETYPE_FONTTYPE)
                pbkt->cTrueType++;

            // Track the number of Raster fonts.

            if (pfeoNew.flFontType() & RASTER_FONTTYPE)
                pbkt->cRaster++;
        }
    }

    return (ppfel != NULL);
}


/******************************Member*Function*****************************\
* FHOBJ::bInsert                                                           *
*                                                                          *
* Insert a new PFE into the font hash table.                               *
*                                                                          *
* History:                                                                 *
*  Mon 14-Dec-1992 22:51:22 -by- Charles Whitmer [chuckwh]                 *
* Moved HASHBUCKETs out of the hash table.  We now create them as needed.  *
*                                                                          *
*  06-Aug-1992 00:43:37 by Gilman Wong [gilmanw]                           *
* Added support for font enumeration list.                                 *
*                                                                          *
*  Tue 14-Apr-1992 13:49:24 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL FHOBJ::bInsert(PFEOBJ& pfeoNew)
{
// Capitalize the given string.  We will always match on the capitalized
// string.

    WCHAR wcCap[LF_FACESIZE];

    HASHBUCKET *pbkt;
    UINT iBucket;

// Insert into facename hash only if the typographic face name
// is different from the typeographic family name.  Case insensitive
// since searching in the font hash table is case insensitive.

    if ((fht() == FHT_FACE) &&
        !_wcsicmp(pfeoNew.pwszFaceName(),pfeoNew.pwszFamilyName()))
    {
        return TRUE; // nothing to do.
    }

    if( fht() == FHT_UFI )
    {
        UNIVERSAL_FONT_ID ufi;

        pfeoNew.vUFI( &ufi );
        pbkt = pbktSearch(NULL,&iBucket,&ufi);

    }
    else
    {
        cCapString(wcCap,pwszName(pfeoNew),LF_FACESIZE);

    // Locate the hashbucket.

        pbkt = pbktSearch(wcCap,&iBucket);
    }

// link the pfe into appropriate lists:

    if (!bAddPFELink(pbkt, iBucket, wcCap, pfeoNew, FALSE))
        return FALSE;

// Do we need to add equivalence buckets for this pfe to the hash table?
// This way the same pfe may show up in linked lists hanging off several buckets.

    if ( pfeoNew.bEquivNames() && (fht() == FHT_FAMILY) )
    {
        HASHBUCKET *pbktEquiv;
        PWSZ pwszEquivName = pwszName(pfeoNew);

    // Skip to first equiv name.

        while (*pwszEquivName++);

        // Process each equiv. name until we hit the list terminator (NULL).

        while (*pwszEquivName)
        {
        // Capitalize the name.

            cCapString(wcCap,pwszEquivName,LF_FACESIZE);

        // Locate the hashbucket. We only search for equiv buckets

            pbktEquiv = pbktSearch(wcCap,&iBucket, NULL, TRUE);

            if (!bAddPFELink(pbktEquiv, iBucket, wcCap, pfeoNew, TRUE))
                return FALSE;

        // Skip to next name.

            while (*pwszEquivName++);
        }
    }

    return(TRUE);
}



/******************************Public*Routine******************************\
*
* VOID FHOBJ::vDeletePFELink(HASHBUCKET *phbkt, PFEOBJ& pfeoV)
*
* Delete pfe from the linked list hanging off the bucket and possibly
* also remove the bucket itself, after removing the last pfe from the llist
*
* History:
*  27-Jun-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



VOID FHOBJ::vDeletePFELink(HASHBUCKET *phbkt, UINT iBucket,  PFEOBJ& pfeoV)
{
    // Capitalize the search string.

    PFELINK *ppfel, *ppfelV = NULL;

    #if DBG
        BOOL bFoundVictim;      // used only for debugging
    #endif

    // Does the list exist?  It is possible that on the facename list this PFE
    // may not exist.  The set of PFEs in the facename list is a subset of the
    // set of PFEs in the family name list.

    // Return if there is no list.

    if (phbkt == (HASHBUCKET *) NULL)
    {
        // ASSERTGDI(fht() == FHT_FACE, "trying to remove nonexisting pfe\n");
        return;
    }

    // ----------------------------------
    // Remove from font enumeration list.
    // ----------------------------------

    // Check for special case: victim is at the head of list.

    if (phbkt->ppfelEnumHead->ppfe == pfeoV.ppfeGet())
    {
        // remember the pointer, we shall have to free the mem;

        ppfelV = phbkt->ppfelEnumHead;

        // Victim found, new head of list.

        phbkt->ppfelEnumHead = phbkt->ppfelEnumHead->ppfelNext;

        // Tail check.  List may now be empty, so we may need to adjust tail.

        if (phbkt->ppfelEnumHead == NULL)
        {
            phbkt->ppfelEnumTail = NULL;
        }
    }
    else
    {
    // If we're here, victim is either in the middle or end of the list.

        ppfel = phbkt->ppfelEnumHead;

        #if DBG
            bFoundVictim = FALSE;
        #endif

    // Search loop; look for victim on the linked list.

        while (ppfel->ppfelNext)
        {
            if (ppfel->ppfelNext->ppfe == pfeoV.ppfeGet())
            {
                // Victim found.

                ppfelV = ppfel->ppfelNext;
                ppfel->ppfelNext = ppfelV->ppfelNext;

                #if DBG
                    bFoundVictim = TRUE;
                #endif

                // Tail check.  If victim is also the tail, we need a new tail.

                if (ppfelV->ppfelNext == NULL)
                {
                    ASSERTGDI(phbkt->ppfelEnumTail == ppfelV, "ppfelEnumTail problem");
                    phbkt->ppfelEnumTail = ppfel;
                }

                // Get out of search loop.

                break;
            }

            ppfel = ppfel->ppfelNext;
        }

        // PFE must exist somewhere on the list.
        // We saw the case where PFE doesn't exist in the list on Hydra
        // Somehow pffmo.bAddHash failed in bLoadFonts which caused the
        // pffmo.vRemoveHash was called right after.

    }

    if (ppfelV)
    {
    // free the link itself

    VFREEMEM(ppfelV);

    //
    // Track the number of TrueType fonts.
    //

    if (pfeoV.flFontType() & TRUETYPE_FONTTYPE)
    {
        phbkt->cTrueType--;
    }

    //
    // Track the number of Raster fonts.
    //

    if (pfeoV.flFontType() & RASTER_FONTTYPE)
    {
        phbkt->cRaster--;
    }

    //
    // If the bucket has no PFE's attached, delete it.
    //

    if (phbkt->ppfelEnumHead == NULL)
    {
        //
        // We have to remove the HASHBUCKET from the load order linked list.
        //

        if ( phbkt->pbktPrev )
        {
            phbkt->pbktPrev->pbktNext = phbkt->pbktNext;
        }
        else
        {
            pfh->pbktFirst = phbkt->pbktNext;   // new head of list
        }

        if ( phbkt->pbktNext )
        {
            phbkt->pbktNext->pbktPrev = phbkt->pbktPrev;
        }
        else
        {
            pfh->pbktLast = phbkt->pbktPrev;    // new tail of list
        }

        // We also have to remove the HASHBUCKET from the collision list.

        for
        (
          HASHBUCKET **ppbkt = &pfh->apbkt[iBucket];
          *ppbkt != phbkt;
          ppbkt = &((*ppbkt)->pbktCollision)
        )
        {}

        *ppbkt = phbkt->pbktCollision;

        // Reduce the counts in the hash table.

        pfh->cUsed--;
        if (pfh->apbkt[iBucket])
        {
            pfh->cCollisions--;
        }

        // Delete the HASHBUCKET.

        VFREEMEM(phbkt);
    }
    else
    {
        // If we haven't deleted the bucket,
        // check to see if its time stamp should be changed.

        // The time stamp of a bucket is the time stamp of its oldest
        // PFE.  Since the font enumeration PFE list is also maintained
        // in load order, the bucket time stamp is equivalent to the time
        // stamp of the first bucket in its font enumeration list.

        if ( phbkt->ulTime == phbkt->ppfelEnumHead->ppfe->ulTimeStamp )
        {
            // If the time stamps are equal, the head of the list was not
            // deleted.  Therefore, the position of this bucket in the
            // load order list has not changed and we are done.

            return;
        }

        // Update the time stamp.

        phbkt->ulTime = phbkt->ppfelEnumHead->ppfe->ulTimeStamp;

        // The bucket can only get younger if the head of the list is removed.
        // Therefore we need only probe forward for the new position of the
        // hash bucket.

        // We will stop the scan when we are pointing at the bucket that
        // precedes the new position.

        for ( HASHBUCKET *pbktProbe = phbkt;
              (pbktProbe->pbktNext != (HASHBUCKET *) NULL)
              && (pbktProbe->pbktNext->ulTime < phbkt->ulTime);
              pbktProbe = pbktProbe->pbktNext
            );

        // If we found a new position and it isn't the one we already occupy,
        // move the bucket.

        if (pbktProbe != phbkt)
        {
            // Remove the bucket from its current position.

            if (phbkt->pbktPrev )
            {
                phbkt->pbktPrev->pbktNext = phbkt->pbktNext;
            }
            else
            {
                pfh->pbktFirst = phbkt->pbktNext;   // new head of list
            }

            if (phbkt->pbktNext )
            {
                phbkt->pbktNext->pbktPrev = phbkt->pbktPrev;
            }

            // It is not necessary to handle the case of a new tail
            // because if this were the current tail, we would not be
            // attempting to move it.

            // Insert at its new position.  Remember: pbktProbe is pointing to
            // the bucket that should precede this one.

            phbkt->pbktPrev = pbktProbe;
            phbkt->pbktNext = pbktProbe->pbktNext;

            pbktProbe->pbktNext = phbkt;
            if (phbkt->pbktNext )
            {
                phbkt->pbktNext->pbktPrev = phbkt;
            }
            else
            {
                pfh->pbktLast = phbkt;  // new tail for the list
            }
        }
    }
    }
}



/******************************Member*Function*****************************\
* FHOBJ::vDelete                                                           *
*                                                                          *
* Removes a PFE from all the lists hanging off the hash table.             *
*                                                                          *
* History:                                                                 *
*
*  Fri 27-Jun-1997 -by- Bodin Dresevic [BodinD]
* update:
* Added removing pfe's from equivalency buckets, I think this was missing
*
*  Mon 14-Dec-1992 23:39:28 -by- Charles Whitmer [chuckwh]                 *
* Changed to search for buckets.  Made it delete the bucket at the end,    *
* instead of reconstructing the whole table.                               *
*                                                                          *
*  06-Aug-1992 00:43:37 by Gilman Wong [gilmanw]                           *
* New deletion algorithm.  Also, added support for font enumeration list.  *
*                                                                          *
*  Tue 14-Apr-1992 13:49:05 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

VOID FHOBJ::vDelete(PFEOBJ& pfeoV)
{
    // Capitalize the search string.

    WCHAR wcCapName[LF_FACESIZE];
    UINT iBucket;
    HASHBUCKET *phbkt;

// Delete from facename hash only if the typographic face name
// is different from the typeographic family name. Case insensitive
// since searching in the font hash table is case insensitive.

    if ((fht() == FHT_FACE) &&
        !_wcsicmp(pfeoV.pwszFaceName(),pfeoV.pwszFamilyName()))
    {
        return; // nothing to do.
    }

    if( fht() == FHT_UFI )

    {
        UNIVERSAL_FONT_ID ufi;

        pfeoV.vUFI( &ufi );
        phbkt = pbktSearch(NULL,&iBucket,&ufi);

    }
    else
    {
        cCapString(wcCapName,pwszName(pfeoV),LF_FACESIZE);

        // Determine hash position in the table.

        phbkt = pbktSearch(wcCapName,&iBucket);
    }

    vDeletePFELink(phbkt,iBucket,pfeoV);

    // this pfe may need to be deleted from the lists hanging off of
    // equivalency buckets:

    if (pfeoV.bEquivNames() && (fht() == FHT_FAMILY))
    {
        HASHBUCKET *pbktEquiv;
        PWSZ pwszEquivName = pwszName(pfeoV);

    // Skip to first equiv name.

        while (*pwszEquivName++);

        // Process each equiv. name until we hit the list terminator (NULL).

        while (*pwszEquivName)
        {
        // Capitalize the name.

            cCapString(wcCapName,pwszEquivName,LF_FACESIZE);

        // Locate the hashbucket. Only search for equivalency buckets

            pbktEquiv = pbktSearch(wcCapName,&iBucket, NULL, TRUE);
            vDeletePFELink(pbktEquiv,iBucket,pfeoV);

        // Skip to next name.

            while (*pwszEquivName++);
        }
    }

}

/******************************Public*Routine******************************\
* ENUMFONTSTYLE efsCompute(BOOL *abFoundStyle, PFEOBJ &pfeo)
*
* Computes a font enumeration style category for the given pfeo.
*
* An array of flags, abFoundStyle, is passed in.  There is a flag
* for each style classification returned by PFEOBJ::efsCompute().
*
* These flags are set as PFEs for each category are found.
* Once a category is filled, then all subsequent fonts of the
* same category are marked as either EFSTYLE_OTHER (if facename
* is different than family name, thereby allowing us to use it
* to distinguish from other fonts of this family) or EFSTYLE_SKIP
* (if facename is the same as the family name).
*
* This is to support Win 3.1 EnumFonts() behavior which can only
* discriminate 4 different styles for each family of fonts.
*
* History:
*  07-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ENUMFONTSTYLE efstyCompute(BOOL *abFoundStyle, PFEOBJ &pfeo)
{
    ENUMFONTSTYLE efsty = pfeo.efstyCompute();

    if ( !abFoundStyle[efsty] )
    {
        abFoundStyle[efsty] = TRUE;
    }
    else
    {
        if ( _wcsicmp(pfeo.pwszFamilyName(), pfeo.pwszFaceName()) )
        {
            efsty = EFSTYLE_OTHER;
        }
        else
        {
            efsty = EFSTYLE_SKIP;
        }
    }

    return efsty;
}

/******************************Member*Function*****************************\
* BOOL FHOBJ::bScanLists                                                   *
*                                                                          *
* This implements the behavior of EnumFonts() and EnumFontFamilies() when  *
* a NULL name is passed in.  If the bComputeStyles flag is TRUE, the       *
* EnumFonts() behavior of enumerating some fonts by their facename (rather *
* than family name) is used.                                               *
*                                                                          *
* This function puts HPFEs from the hash table and lists into the EFSOBJ.  *
* If bComputeStyles is FALSE, only the font enumeration list heads from    *
* each bucket are added to the EFSOBJ.                                     *
*                                                                          *
* If bComputeStyles is TRUE, then each list is scanned and a style         *
* classification (EFSTYLE) is computed.  Fonts classified as EFSTYLE_OTHER *
* are also added to the EFSOBJ.                                            *
*                                                                          *
* Return:                                                                  *
*   Returns FALSE if an error occurs; TRUE otherwise.                      *
*                                                                          *
* History:                                                                 *
*  15-Jan-1993 -by- Gilman Wong [gilmanw]                                  *
* Changed to use the linked list that preserves PFE load order for outer   *
* loop.                                                                    *
*                                                                          *
*  Mon 14-Dec-1992 23:50:10 -by- Charles Whitmer [chuckwh]                 *
* Changed outer loop logic for new hashing.                                *
*                                                                          *
*  07-Aug-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL FHOBJ::bScanLists (
    EFSOBJ *pefso,          // fill this EFSOBJ
    ULONG   iEnumType,      // Enum Fonts, Families or FamiliesEx
    EFFILTER_INFO *peffi    // filtering information
)
{
    HASHBUCKET *phbkt;
    // better C++ code generation if you always return a variable
    BOOL bRet = FALSE;
    FLONG       flAdd = 0;
    PFELINK     *ppfel;


    if (iEnumType == TYPE_ENUMFONTFAMILIES)
        flAdd |= FL_ENUMFAMILIES;
    if (iEnumType == TYPE_ENUMFONTFAMILIESEX)
        flAdd |= FL_ENUMFAMILIESEX;

// Scan through the hash table using the load ordered linked list.

    for (phbkt = pfh->pbktFirst;
         phbkt != (HASHBUCKET *) NULL;
         phbkt = phbkt->pbktNext
        )
    {
    // If the list exists, need to scan it.  We skip over equiv. name
    // HASHBUCKETs.  These are here only to allow the mapper to alias
    // printer font names to other "equivlaent" names.  We do not
    // enumerate them.

        if (
            phbkt->ppfelEnumHead
            && !(phbkt->fl & HB_EQUIV_FAMILY)
        )
        {
            ppfel = phbkt->ppfelEnumHead;
            PFEOBJ pfeo(ppfel->ppfe);

            ASSERTGDI (
                pfeo.bValid(),
                "gdisrv!bScanListsFHOBJ(NULL): bad HPFE handle\n"
                );

        // This flag is used only if bComputeStyles is TRUE (i.e.,
        // processing an EnumFonts() request).  We use this to track
        // whether or not the first suitable font in the list is found
        // yet.  The first font PLUS fonts that are EFSTYLE_OTHER
        // are put in the enumeration.

            BOOL bFoundFirst = FALSE;

        // These flags are set as PFEs for each category are found.
        // Once a category is filled, then all subsequent fonts of the
        // same category are marked as either EFSTYLE_OTHER (if facename
        // is different than family name, thereby allowing us to use it
        // to distinguish from other fonts of this family) or EFSTYLE_SKIP
        // (if facename is the same as the family name).
        //
        // This is to support Win 3.1 EnumFonts() behavior which can only
        // discriminate 4 different styles for each family of fonts.

            BOOL abFoundStyle[EFSTYLE_MAX];
            RtlZeroMemory((PVOID) abFoundStyle, EFSTYLE_MAX * sizeof(BOOL));

        // Windows 3.1 compatibility
        //
        // When NULL is passed into EnumFonts or EnumFontFamilies,
        // raster fonts are not enumerated if a TrueType font of the same
        // name exists.  We can emulate this behavior by turning on
        // the "TrueType duplicate" filter (the same one used by the
        // (GACF_TTIGNORERASTERDUPE app compatibility flag) for the NULL case.

            peffi->bTrueTypeDupeFilter = TRUE;

        // Win3.1 App compatibility flag GACF_TTIGNORERASTERDUPE.  Need
        // to copy count of TrueType from bucket into EFFILTER_INFO, peffi.

            peffi->cTrueType = phbkt->cTrueType;

            // Scan the list for candidates.

            do
            {
                pfeo.ppfeSet(ppfel); // "relock" ppfe;

            // Skip this PFE if it needs to be filtered out.

                if ( pfeo.bFilteredOut(peffi) )
                    continue;

            // EnumFonts() or EnumFontFamilies() processing (bComputeStyles
            // is TRUE for EnumFonts()).

                if (iEnumType != TYPE_ENUMFONTS)
                {
                // EnumFontFamilies --
                // Need only the first one on the list.

                    if (!pefso->bAdd(pfeo.ppfeGet(),EFSTYLE_REGULAR,flAdd,peffi->lfCharSetFilter))
                    {
                    // Error return.  bAdd() will set error code.

                        WARNING(
                            "gdisrv!bScanListsFHOBJ(NULL): "
                            "abandon enum, cannot grow list\n"
                            );
                        return bRet;
                    }

                // Break out of the do..while loop.
                //
                    break;
                }
                else
                {
                    // Compute the style category for this PFE.

                    ENUMFONTSTYLE efsty = efstyCompute(abFoundStyle, pfeo);

                // EnumFonts --
                // If style is EFSTYLE_OTHER, this font falls into an already
                // occupied category but it has a facename that allow it to be
                // distinguished from other fonts of this family.  So it
                // should be added.
                //
                    if ( !bFoundFirst || (efsty == EFSTYLE_OTHER) )
                    {
                        if (!pefso->bAdd(pfeo.ppfeGet(),efsty))
                        {
                            // Error return.  bAdd() will set error code.

                            WARNING(
                                "gdisrv!bScanListsFHOBJ(NULL): "
                                "abandon enum, cannot grow list\n");
                            return bRet;
                        }

                    //
                    // First one has been found.  From now on, we will only
                    // take EFSTYLE_OTHER fonts.
                    //
                        bFoundFirst = TRUE;
                    }

                }

            } while (ppfel = ppfel->ppfelNext);
        }
    }

// Success.
    bRet = TRUE;
    return bRet;
}

/******************************Member*Function*****************************\
* BOOL FHOBJ::bScanLists                                                   *
*                                                                          *
* This implements the behavior of EnumFonts() and EnumFontFamilies() when  *
* a non-NULL name is passed in.  If the bComputeStyles flag is TRUE, the   *
* EnumFonts() behavior of enumerating some fonts by their facename (rather *
* than family name) is used.                                               *
*                                                                          *
* This function puts HPFEs from the hash table and lists into the EFSOBJ.  *
* If bComputeStyles is FALSE, the entire font enumeration list is added    *
* to the EFSOBJ.                                                           *
*                                                                          *
* If bComputeStyles is TRUE, then each list is scanned and a style         *
* classification (EFSTYLE) is computed.  Fonts classified as EFSTYLE_OTHER *
* are excluded from the EFSOBJ.  (These fonts are enumerated by their      *
* facename rather than their family name).                                 *
*                                                                          *
* Return:                                                                  *
*   Returns FALSE if an error occurs; TRUE otherwise.                      *
*                                                                          *
* History:                                                                 *
*  Mon 14-Dec-1992 23:54:37 -by- Charles Whitmer [chuckwh]                 *
* Modified hash lookup.                                                    *
*                                                                          *
*  07-Aug-1992 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL FHOBJ::bScanLists
(
    EFSOBJ *pefso,              // fill this EFSOBJ
    PWSZ    pwszName,           // search on this name
    ULONG   iEnumType,          // Enum Fonts, Families or FamiliesEx
    EFFILTER_INFO *peffi        // filtering information
)
{

    WCHAR wcCapName[LF_FACESIZE];

    BOOL bRet = FALSE;          // for better code generation
    FLONG       flAdd = 0;
    PFELINK    *ppfel;

    if (iEnumType == TYPE_ENUMFONTFAMILIESEX)
        flAdd |= FL_ENUMFAMILIESEX;

    // Capitalize the search name.

    cCapString(wcCapName,pwszName,LF_FACESIZE);

    // Search for head of the list.

    HASHBUCKET *pbkt = pbktSearch(wcCapName,(UINT *) NULL);

    // If the list exists, need to scan it.  Unless this is an equiv. name
    // HASHBUCKET.  These are here only to allow the mapper to alias
    // printer font names to other "equivlaent" names.  We do not
    // enumerate them.

    if (pbkt)
    {
        ppfel = pbkt->ppfelEnumHead;
        PFEOBJ pfeo(ppfel->ppfe);

        ASSERTGDI (
            pfeo.bValid(),
            "gdisrv!bScanListsFHOBJ(): bad HPFE handle\n"
            );

        // These flags are set as PFEs for each category are found.
        // Once a category is filled, then all subsequent fonts of the
        // same category are marked as either EFSTYLE_OTHER (if facename
        // is different than family name, thereby allowing us to use it
        // to distinguish from other fonts of this family) or EFSTYLE_SKIP
        // (if facename is the same as the family name).
        //
        // This is to support Win 3.1 EnumFonts() behavior which can only
        // discriminate 4 different styles for each family of fonts.

        BOOL abFoundStyle[EFSTYLE_MAX];
        RtlZeroMemory((PVOID) abFoundStyle, EFSTYLE_MAX * sizeof(BOOL));
        ENUMFONTSTYLE efsty = EFSTYLE_REGULAR;

    //
    // Win3.1 App compatibility flag GACF_TTIGNORERASTERDUPE.  Need
    // to copy count of TrueType from bucket into EFFILTER_INFO, peffi.
    //
        peffi->cTrueType = pbkt->cTrueType;

    //
    // Scan the list for candidates.
    //
        do
        {
            pfeo.ppfeSet(ppfel); // "relock" ppfe;

        // Skip this PFE if it needs to be filtered out.

            if ( pfeo.bFilteredOut(peffi) )
                continue;

        // If servicing an EnumFonts() call (bComputeStyles is TRUE),
        // then some fonts may be excluded.  EnumFontFamilies, however,
        // wants the entire list.

            if (iEnumType == TYPE_ENUMFONTS)
            {
            //
            // Compute the style category for this PFE.
            //
                efsty = efstyCompute(abFoundStyle, pfeo);

            // EnumFonts --
            // If style is EFSTYLE_OTHER, this font falls into an
            // already occupied category but it has a facename that allows
            // it to be distinguished from other fonts of this family.
            // So it will be excluded from this enumeration.  (It will
            // be enumerated by its facename).

                if ( efsty == EFSTYLE_OTHER )
                    continue;

            }

            // Add the font to the enumeration.

            if (!pefso->bAdd(pfeo.ppfeGet(),efsty,flAdd, peffi->lfCharSetFilter))
            {
                // Error return.  bAdd() will set error code.

                WARNING(
                    "gdisrv!bScanListsFHOBJ(): "
                    "abandon enum, cannot grow list\n");
                return bRet;
            }

        } while (ppfel = ppfel->ppfelNext);
    }

    // Success.
    bRet = TRUE;
    return bRet;

}

/******************************Member*Function*****************************\
* FHMEMOBJ::FHMEMOBJ                                                       *
*                                                                          *
* Allocates memory for a font hash table.                                  *
*                                                                          *
* History:                                                                 *
*  Tue 14-Apr-1992 14:44:35 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

FHMEMOBJ::FHMEMOBJ(FONTHASH **ppfhNew, FONTHASHTYPE fht_, UINT c)
{
    ppfh = ppfhNew;
    *ppfh = (FONTHASH*)
        PALLOCMEM (offsetof(FONTHASH,apbkt) + sizeof(*(pfh->apbkt)) * c, 'sahG');

    pfh = *ppfh;

    if (pfh != (FONTHASH*) NULL)
    {
        vInit(fht_,c);
    }
}

#if DBG
/******************************Public*Routine******************************\
* VOID PFTOBJ::vDump ()
*
* Debugging code.
*
* History:
*  25-Feb-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID PFTOBJ::vPrint()
{
    PFF *pPFF, **ppPFF;
    int i;

    DbgPrint("\nContents of PFT, PPFT = 0x%p\n", pPFT);
    DbgPrint("pfhFamily = %-#p\n", pPFT->pfhFamily);
    DbgPrint("pfhFace   = %-#p\n", pPFT->pfhFace);
    DbgPrint("pfhUFI   = %-#p\n", pPFT->pfhUFI);
    DbgPrint("cBuckets  = %ld\n", pPFT->cBuckets);
    DbgPrint("cFiles    = %ld\n", pPFT->cFiles);
    DbgPrint("PPFF table\n");
    for (
        ppPFF = pPFT->apPFF,i=0
      ; ppPFF < pPFT->apPFF + pPFT->cBuckets
      ; ppPFF++,i++)
    {
        if (pPFF = *ppPFF)
        {
            DbgPrint("\tPFT->apPFF[%d]\n",i);
            while (pPFF)
            {
                if (!pPFF->hdev)
                {
                    DbgPrint("%p\t\"%ws\" %u\n"
                        , pPFF
                        , pPFF->pwszPathname_
                        , pPFF->sizeofThis
                        );
                }
                else
                {
                    DbgPrint("%p\t%p %u\n"
                      , pPFF
                      , pPFF->hdev
                      , pPFF->sizeofThis
                      );
                }
                pPFF = pPFF->pPFFNext;
            }
        }
    }
    DbgPrint("\n");
}
/******************************Member*Function*****************************\
* FHOBJ::vPrint
*
* History:
*  Tue 14-Apr-1992 13:49:51 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

VOID FHOBJ::vPrint(VPRINT print)
{
    UINT i;
    HASHBUCKET *pbkt;
    PFELINK    *ppfel;

    print("    FHOBJ::vPrint()\n\n");
    print("    ppfh           = %-#8lx\n",ppfh);
    print("    pfh            = %-#8lx\n",pfh);
    print(
        "    pfh->id        = %c%c%c%c\n",
        ((char*) (&pfh->id))[0],
        ((char*) (&pfh->id))[1],
        ((char*) (&pfh->id))[2],
        ((char*) (&pfh->id))[3]
        );
    print(
        "         fht       = %s\n",
        pfh->fht == FHT_FAMILY ? "FHT_FAMILY" :
        (pfh->fht == FHT_FACE   ? "FHT_FACE" :
        (pfh->fht == FHT_UFI    ? "FHT_UFI" : "BOGUS VALUE" ))
        );
    print("         cBuckets    = %d\n",pfh->cBuckets);
    print("         cUsed       = %d\n",pfh->cUsed);
    print("         cCollisions = %d\n",pfh->cCollisions);

    for (i = 0; i < pfh->cBuckets; i++)
    {
      for
      (
        pbkt = pfh->apbkt[i];
        pbkt != (HASHBUCKET *) NULL;
        pbkt = pbkt->pbktCollision
      )
      {
        print("         ahbkt[%04d] \"%ws\"\n",i,pbkt->u.wcCapName);
      }
    }

    print(
        "\n\n        hpfe        %s\n\n",
        pfh->fht ? "FamilyName" : "FaceName"
        );

    for (i = 0; i < pfh->cBuckets; i++)
    {
      BOOL bFirst;

      for
      (
        pbkt = pfh->apbkt[i];
        pbkt != (HASHBUCKET *) NULL;
        pbkt = pbkt->pbktCollision
      )
      {
        ppfel   = pbkt->ppfelEnumHead;
        bFirst = TRUE;
        while (ppfel)
        {
            PFEOBJ pfeo(ppfel->ppfe);

            if (bFirst)
            {
                print("        %-#8x    \"%ws\"\n",ppfel->ppfe,pwszName(pfeo));
                bFirst = FALSE;
            }
            else
            {
                print("        %-#8x\n",ppfel->ppfe);
            }
            ppfel = ppfel->ppfelNext;
        }
      }
    }
    print("\n\n");
}
#endif


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetLanguageID
*
* Routine Description:
*
*   This routines returns the default language ID.  Normally, we would call
*   GetLocaleInfoW to get this information but that API is not available in
*   kernel mode.  Since GetLocaleInfoW gets it from the registry we'll do the
*   same.
*
* Arguments: none
*
* Called by:
*
* Return Value:
*
*   The default language ID.  If the call fails it will just return 409
*   for English.
*
\**************************************************************************/

USHORT GetLanguageID()
{
    NTSTATUS NtStatus;
    USHORT Result = 0x409;
    HANDLE RegistryKeyHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING UnicodeString;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

    #define NLS_TABLE_KEY \
       L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Nls\\Language"

    RtlInitUnicodeString(&UnicodeString, NLS_TABLE_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = ZwOpenKey(&RegistryKeyHandle, GENERIC_READ, &ObjectAttributes);

    if(NT_SUCCESS(NtStatus))
    {
        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;

        ULONG BufferSize = sizeof(WCHAR) * MAX_PATH +
          sizeof(KEY_VALUE_FULL_INFORMATION);

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) PALLOCMEM(BufferSize,'dilG');

        if(KeyValueInformation)
        {
            ULONG ValueReturnedLength;

            RtlInitUnicodeString(&UnicodeString,L"Default");

            NtStatus = ZwQueryValueKey(RegistryKeyHandle,
                                       &UnicodeString,
                                       KeyValuePartialInformation,
                                       KeyValueInformation,
                                       BufferSize,
                                       &BufferSize);

            if(NT_SUCCESS(NtStatus))
            {
                ULONG Temp;
                RtlInitUnicodeString(&UnicodeString,
                                     (PCWSTR) &(KeyValueInformation->Data[0]));
                RtlUnicodeStringToInteger(&UnicodeString, 16, &Temp);
                Result = (USHORT) Temp;
            }
            else
            {
                WARNING("GetLanguageID failed to read registry\n");
            }
            VFREEMEM(KeyValueInformation);
        }
        else
        {
            WARNING("GetLanguageID out of memory\n");
        }

        ZwCloseKey(RegistryKeyHandle);
    }
    else
    {
        WARNING("GetLanguageID failed to open NLS key\n");
    }

    return(Result);
}

BOOL PFTOBJ::bUnloadEUDCFont(PWSZ pwszPathname)
{
    PFF *pPFF, **ppPFF;
    WCHAR szUcPathName[MAX_PATH + 1];
    BOOL bRet = FALSE;

    cCapString(szUcPathName,
               pwszPathname,
               wcslen(pwszPathname)+1);


    PUBLIC_PFTOBJ pfto;              // access the public font table
    GreAcquireSemaphoreEx(ghsemPublicPFT, SEMORDER_PUBLICPFT, NULL);     // This is a very high granularity
                                     // and will prevent text output

    pPFF = pfto.pPFFGet(szUcPathName, wcslen(szUcPathName) + 1, 1,
                        NULL, 0,        // pdv, cjDV
                        &ppPFF,TRUE);

    if (pPFF)
    {
        // bUnloadWorkhorse() guarantees that the public font table
        // semaphore will be released before it returns

        bRet = pfto.bUnloadWorkhorse(pPFF, ppPFF, ghsemPublicPFT, 0);
    }
    else
    {
        GreReleaseSemaphoreEx(ghsemPublicPFT);
    }

    return( bRet );
}


/******************************Public*Routine******************************\
* HANDLE PUBLIC_PFTOBJ::hLoadMemFonts                                      *
*                                                                          **                                                                          *                                                                          *
* Returns zero on failure.                                                 *
*                                                                          *
* History:                                                                 *
*  20-May-1997 -by- Xudong Wu [TessieW}                                    *
* Wrote it.                                                                *
\**************************************************************************/

ULONG PUBLIC_PFTOBJ::ulMemoryUnique = 0;

HANDLE PUBLIC_PFTOBJ::hLoadMemFonts
(
    PFONTFILEVIEW  *ppfv,             // font file image
    DESIGNVECTOR *pdv,
    ULONG       cjDV,
    ULONG       *pcFonts
    )
{
    BOOL    bOK = FALSE;
    HANDLE  hMMFont = 0;
    ULONG   cFonts;
    FNTCHECKSUM fntCheckSum;

    PVOID    ppvViews[1];
    ULONG    pcjViews[1];

    ppvViews[0] = ppfv[0]->fv.pvViewFD;
    pcjViews[0] = ppfv[0]->fv.cjView;

    HFF hffNew = HFF_INVALID;
    PPDEV   ppDevList;

// order of grabbing semaphores important

    GreAcquireSemaphoreEx(ghsemDriverMgmt, SEMORDER_DRIVERMGMT, NULL);
    vLoadFontFileView(NULL, 0, ppfv, 1, ppvViews, pcjViews, pdv, cjDV, &hffNew ,&ppDevList, &fntCheckSum);
    PDEVOBJ pdo((HDEV)ppDevList);
    GreReleaseSemaphoreEx(ghsemDriverMgmt);

    if (hffNew != HFF_INVALID)
    {
        cFonts = pdo.QueryFontFile( hffNew, QFF_NUMFACES, 0, NULL);

        if (cFonts && cFonts != FD_ERROR)
        {
            WCHAR awc[30];

            *pcFonts = cFonts;

            // create a unique file name for the memory font
            // in the form of "Memory NNN"

            swprintf(awc, L"MEMORY-%u", ulGetNewUniqueness(PUBLIC_PFTOBJ::ulMemoryUnique));

            ULONG cwc = wcslen(awc) + 1;

            PFFCLEANUP *pPFFC = 0;

            PFFMEMOBJ
            pffmo(cFonts,
                  awc, cwc, 1,
                  pdv, cjDV,
                  hffNew, pdo.hdev(),
                  0, pPFT,
                  PFF_STATE_MEMORY_FONT,
                  FR_PRIVATE | FR_NOT_ENUM,  //always use FR_PRIVATE | FR_NOT_ENUM for memory fonts
                  &fntCheckSum,
                  ppfv,
                  NULL);          // pufi

            if (pffmo.bValid())
            {
                if (pffmo.bLoadFontFileTable(awc, cFonts, (HANDLE)0, NULL, NULL))
                {
                    SEMOBJ so2(ghsemPublicPFT);

                    if(bOK = pffmo.bAddHash(FALSE))
                    {
                        PFF **ppPFF, *pPFF;

                        pPFF = pPFFGet(awc, cwc, 1, pdv, cjDV, &ppPFF);

                        if (pPFF)
                        {
                            KdPrint(("bLoadMemFonts(): \"%ws\" has been found on the font table\n"));
                            KdBreakPoint();
                            bOK = FALSE;
                        }
                        else
                        {
                            pPFF = pffmo.pPFFGet();
                            pPFT->cFiles++;

                            //place this new pff at the head of the hash bucket list
                            if (*ppPFF)
                            {
                                (*ppPFF)->pPFFPrev = pPFF;
                            }
                            pPFF->pPFFNext = *ppPFF;
                            pPFF->pPFFPrev = 0;
                            *ppPFF = pPFF;

                            pffmo.vKeepIt();

                            //Sundown: hMMFont is not a real handle but the checksum
                            hMMFont = (HANDLE)(ULONG_PTR)pPFF->ulCheckSum;
                        }
                    }
                    else
                    {
                        pffmo.vRemoveHash();
                    }
                }

                if (!bOK)
                {
            pffmo.vPFFC_DeleteAndCleanup();  // new code
        }
            }
        }
    }

    return hMMFont;
}

ULONG PUBLIC_PFTOBJ::GetEmbedFonts()
{
    ULONG i, cEmbedFonts = 0;
    PFF *pPFF, **ppPFF;
    PVTDATA  *pPvtData;
    DWORD pid, tid;

    if (!bIsPrivatePFT())
        return 0;

    pid = (DWORD) W32GetCurrentPID();
    tid = (DWORD) W32GetCurrentTID();

    SEMOBJ so(ghsemPublicPFT);

    for (i = 0; i < CPRIVATEBUCKETS; i++)
    {
        ppPFF = &pPFT->apPFF[i];
        if (ppPFF)
        {
            pPFF = *ppPFF;
            while (pPFF)
            {
                pPvtData = pPFF->pPvtDataHead;
                while (pPvtData)
                {
                    if (pPvtData->fl & FRW_EMB_TID)
                    {
                        if (pPvtData->dwID == tid)
                            cEmbedFonts++;
                    }
                    else
                    {
                        if (pPvtData->dwID == pid)
                            cEmbedFonts++;
                    }
                    pPvtData = pPvtData->pPvtDataNext;
                }
                pPFF = pPFF->pPFFNext;
            }
        }
    }
    return cEmbedFonts;
}

BOOL PUBLIC_PFTOBJ::VerifyFontID(VOID *fontID)
{
    ULONG i;
    PFF *pPFF, **ppPFF;
    BOOL bRet = FALSE;

    if (!bIsPrivatePFT())
        return FALSE;


    SEMOBJ so(ghsemPublicPFT);

    for (i = 0; (i < CPRIVATEBUCKETS && !bRet); i++)
    {
        ppPFF = &pPFT->apPFF[i];
        if (ppPFF)
        {
            pPFF = *ppPFF;
            while (pPFF)
            {
                if ((PFF *)fontID == pPFF)          // PFF match
                {
                    return TRUE;
                }

                pPFF = pPFF->pPFFNext;
            }
        }
    }
    return bRet;
}

BOOL PUBLIC_PFTOBJ::ChangeGhostFont(VOID *fontID, BOOL bLoad)
{
    ULONG i;
    PFF *pPFF, **ppPFF;
    PVTDATA  *pPvtData;
    DWORD pid, tid;
    BOOL bRet = FALSE;

    if (!bIsPrivatePFT())
        return FALSE;

    pid = (DWORD) W32GetCurrentPID();
    tid = (DWORD) W32GetCurrentTID();

    SEMOBJ so(ghsemPublicPFT);

    for (i = 0; (i < CPRIVATEBUCKETS && !bRet); i++)
    {
        ppPFF = &pPFT->apPFF[i];
        if (ppPFF)
        {
            pPFF = *ppPFF;
            while (pPFF)
            {
                if ((PFF *)fontID == pPFF)          // PFF match
                {
                    pPvtData = pPFF->pPvtDataHead;
                    while(pPvtData)
                    {
                        if (((pPvtData->fl & FRW_EMB_TID) && (pPvtData->dwID == tid)) ||
                             ((!(pPvtData->fl & FRW_EMB_TID)) && (pPvtData->dwID == pid)))
                        {
                            if (bLoad)
                            {
                                pPvtData->cNotEnum++;
                                pPvtData->fl |= FR_PRINT_EMB_FONT;
                                bRet = TRUE;
                            }
                            else
                            {
                                if (pPvtData->cNotEnum)
                                {
                                    pPvtData->cNotEnum--;
                                    pPvtData->fl &= ~FR_PRINT_EMB_FONT;
                                }
                            }
                            break;
                        }
                        pPvtData = pPvtData->pPvtDataNext;
                    }
                }

                if (bRet)
                    break;

                pPFF = pPFF->pPFFNext;
            }
        }
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pathwide.cxx ===
/******************************Module*Header*******************************\
* Module Name: pathwide.cxx
*
* This module generates the outlines for geometric wide-lines.  Given
* a path for a line, it generates a new path that, when filled using
* a winding mode fill, yields the resulting widened line.
*
* Geometric wide-lines may have different end-cap and line-join
* attributes.  They may also be styled.
*
* THINGS TO NOTE
*
* The path is already in device coordinates, so the resulting wide-line
* is also calculated in device coordinates.
*
* The key thing to note is that the pen's shape is defined in world space, so
* its shape in device space depends on the current world-to-device
* transform (which may be an arbitrary 2 by 2 affine transform).  Pens
* are circular in world space, with their diameter there defined by the
* pen width.  However, in device space a pen shape is only guaranteed to be
* an ellipse symmetrical about some arbitrary axis.  And vectors that are
* perpendicular in world space are not necessarily perpendicular in device
* space (which is important for calculating flat and square end-caps, and
* bevel joins).
*
* HOW WE DO IT
*
* We implement wide-lines by first generating in device space a convex
* polygonal approximation to the pen's shape.  We 'drag' this polygon
* along the given path; the outline of a widened line is generated by
* the point on the pen polygon that is furthest from the line's ray
* (called the 'draw' vertex).  This point may be found by a simple
* binary search using entirely integer arithmetic.
*
* This approach makes round round joins and round caps very efficient:
* the points for the resulting round part is simply the points between
* draw vertices.
*
* To compute true perpendiculars (for flat and square end-caps, and
* bevel joins) we interpolate between vertices on the pen polygon
* (once again using only integer math).
*
* The lengths of the dashes and gaps for styled lines are defined in
* world space; to do styling we computed every line segment's length
* in world space, and divide it accordingly.
*
* HOBBY WIDE-LINES
*
* Rendering the wide-lines using a polygonized pen allows us to take
* advantage of Hobby wide-lines.  Hobby's wide-line algorithm
* generates 'optimally shaped' pens that will yield lines of constant-
* looking width, independent of the direction of the lines.  (OS/2's
* PM suffers from having its thin wide-lines appear not to be of
* constant width).
*
* Unfortunately, Hobby's algorithm is fairly expensive to generate an
* optimal pen shape polygon given its width and the current transform;
* it is significantly faster for us to generate a quick-and-dirty
* polygon approximation by creating the ellipse out of Bezier curves and
* flattening it.
*
* But Hobby pens are most important for small, near circular pens,
* where the eye can readily detect imperfections in the line.  So we
* support Hobby wide-lines only for small, near circular pens, and we
* keep these pen shapes in a pre-computed table.
*
* See:
*
*   John Hobby, "Digitized Brush Trajectories", PhD Dissertation,
*       Stanford University, August 1985
*
* GENERATING BOTH SIDES AT THE SAME TIME
*
* We also generate both sides of the wide-line outline as we traverse
* the path, keeping track of both sides in separate paths (the outlines
* of the 'left' and 'right' sides of the wide-line).  When the end of a
* figure (that is, the end of a sub-path) is reached, we reverse all the
* points in the 'left' path and append it to the 'right', and close the
* result.
*
* This could have been implemented by traversing the path once to generate
* one side, then traversing it again in the reverse direction to generate
* the other side.  However, most of the hard computations for perpendiculars
* and such would have to be done twice.  Our method is faster, although
* there is more book-keeping.
*
* BEZIERS
*
* We really only know how to widen lines, so we convert Beziers as we
* read them to their polyline approximations.  We 'flatten' Beziers to
* constant error, independent of pen width, and make sure we apply 'round'
* joins to the interior polylines comprising the Bezier.  The round join
* handles extreme cases such as cusps, so there really is no need to
* flatten to less error for larger pens.
*
* (This is in contrast to OS/2's PM which pre-flattens its curves prior
* to widening, and applies the regular joins to the interior of the curve.
* For wider pens, the allowed error in the flattening must be decreased
* because sharp curves would not look 'round' at cusp-points when using
* bevel or miter joins.)
*
* We flatten Bezier curves as we traverse path (instead of only widening
* paths that are already flattened) because it is useful to know the
* Bezier data.  We use the control points to calculate true perpendiculars
* at the end-points of curves, and we have to know when we're in the
* interior of the Bezier to always apply round joins.
*
* Advantages:  o We're much faster
*
*              o Produce better looking curves
*
* Disadvantages:  o More book-keeping
*
*                 o Have to be careful when mixing perpendiculars (such
*                   as from miter joins or flat caps) with round joins
*
*                 o Perpendiculars on styled curves may not be as accurate
*                   for wide-lines -- we use the approximating lines to
*                   calculate the perp, and more lines would give better
*                   perps.
*
*                   However, it can also be argued that due to the
*                   snapping effect of the device-space grid, approximating
*                   the curve into more small lines would actually make
*                   the perps _less_ accurate.
*
* LAZY EVALUATION
*
* Computing draw vectors and perpendiculars are very expensive operations,
* so we lazily evaluate them -- we compute them only when we need them.
* With styling, it may happen we completely skip over some lines (so we
* never do any evaluation), or that we break a line into many small pieces,
* and so re-use perps and draw-vectors (saving us time and ensuring that
* style ends are always perpendicular for styled segments).
*
* Created: 23-Sep-1991
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1991-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "flhack.hxx"
#include "pathwide.hxx"

#ifdef DEBUG_WIDE
    #define INLINE
#else
    #define INLINE inline
#endif

#ifdef DEBUG_WIDE

LONG lConv(EFLOAT ef);

#endif

POINTFIX WIDEPENOBJ::aptfxHobby1[] = {
    {0, 8},    {8, 0},     {0, -8},    {-8, 0}
};

POINTFIX WIDEPENOBJ::aptfxHobby2[] = {
    {8, 16},   {16, 0},    {8, -16},   {-8, -16},
    {-16, 0}
};

POINTFIX WIDEPENOBJ::aptfxHobby3[] = {
    {24, 8},   {24, -8},   {8, -24},   {-8, -24},
    {-24, -8}, {-24, 8}
};

POINTFIX WIDEPENOBJ::aptfxHobby4[] = {
    {32, 8},   {32, -8},   {24, -24},  {8, -32},
    {-8, -32}, {-24, -24}, {-32, -8},  {-32, 8}
};

POINTFIX WIDEPENOBJ::aptfxHobby5[] = {
    {40, 8},   {40, -8},   {32, -24},  {24, -32},
    {8, -40},  {-8, -40},  {-24, -32}, {-32, -24},
    {-40, -8}, {-40, 8}
};

POINTFIX WIDEPENOBJ::aptfxHobby6[] = {
    {48, 8},   {48, -8},   {40, -24},  {24, -40},
    {8, -48},  {-8, -48},  {-24, -40}, {-40, -24},
    {-48, -8}, {-48, 8}
};

HOBBY WIDEPENOBJ::ahob[HOBBY_TABLE_SIZE] = {
    { aptfxHobby1, sizeof(aptfxHobby1) / sizeof(POINTFIX) },
    { aptfxHobby2, sizeof(aptfxHobby2) / sizeof(POINTFIX) },
    { aptfxHobby3, sizeof(aptfxHobby3) / sizeof(POINTFIX) },
    { aptfxHobby4, sizeof(aptfxHobby4) / sizeof(POINTFIX) },
    { aptfxHobby5, sizeof(aptfxHobby5) / sizeof(POINTFIX) },
    { aptfxHobby6, sizeof(aptfxHobby6) / sizeof(POINTFIX) }
};

/******************************Public*Routine******************************\
* bTurnLeftRandom(pa, pb)
*
* Returns TRUE if the sign of the cross product of a X b is positive.
* For simple minds like mine, it returns:
*
*    TRUE if b 'turns left' from a (cross product is < 0)
*    FALSE if b is parallel to or 'turns right' from a (cross is >= 0)
*
* When the vectors are random, half the time we take a short-cut by
* checking the signs.  Remember that we're in device space, where
* positive 'y' is down!
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE BOOL bTurnLeftRandom(
PEVECTORFX pa,
PEVECTORFX pb)
{
    BOOL bRet;

// If the signs are correct, we don't even have to multiply:

    if ((pa->x ^ pa->y ^ pb->x ^ pb->y) < 0)
        bRet = ((pa->x ^ pb->y) < 0);
    else
    {
        LONGLONG ad;
        LONGLONG bc;

    // Check sign of (pa->x * pb->y - pa->y * pb->x) = (ad - bc)

        ad = Int32x32To64(pa->x, pb->y);
        bc = Int32x32To64(pa->y, pb->x);

        bRet = (ad < bc);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::bGrowPath()
*
* Creates a new path record.  Adds to the end of the path, and sets
* 'pptfxPathRecCurrent' and 'pptfxPathRecEnd'.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Stole it from PaulB's pprFlattenRec.
\**************************************************************************/

BOOL WIDEPATHOBJ::bGrowPath()
{
    PPATHALLOC ppa = ppath->ppachain;

    COUNT cMax = 0;

    if (ppa != (PPATHALLOC) NULL)
    {
    // We have a current pathalloc, see how much will fit
    // computation done into temps to avoid compiler assertion!

        PPOINTFIX pptfxStart = &(ppa->pprfreestart->aptfx[0]);
        PPOINTFIX pptfxEnd   = (PPOINTFIX) ((char *)ppa + ppa->siztPathAlloc);

        if (pptfxEnd > pptfxStart)
        {
            //Sundown truncation
            ASSERT4GB((ULONGLONG)(pptfxEnd - pptfxStart));
            cMax = (COUNT)(pptfxEnd - pptfxStart);
        }
    }

// Now we can decide if we need a new pathalloc

    if (cMax < PATHALLOCTHRESHOLD)
    {
    // allocate a new pathalloc, link it into path

        if ( (ppa = newpathalloc()) == (PPATHALLOC) NULL)
            return(FALSE);

        ppa->ppanext    = ppath->ppachain;
        ppath->ppachain = ppa;

    // adjust maxadd

    // Sundown truncation
        ASSERT4GB((ULONGLONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart));

        ULONGSIZE_T numbytes = (ULONG)(((char *)ppa + ppa->siztPathAlloc) -
                            (char *)ppa->pprfreestart);
        cMax = (numbytes - offsetof(PATHRECORD, aptfx))/sizeof(POINTFIX);
    }

// Add pathrecord to end of path

    PPATHREC pprNew = ppa->pprfreestart;

    if (ppath->pprlast == (PPATHREC) NULL)
    {
        ppath->pprfirst = pprNew;
        pprNew->pprprev = (PPATHREC) NULL;
    }
    else
    {
        ppath->pprlast->pprnext = pprNew;
        pprNew->pprprev         = ppath->pprlast;
    }

    ppath->pprlast  = pprNew;
    pprNew->pprnext = (PPATHREC) NULL;
    pprNew->count = 0;

// pptfxPathRecCurrent points to first available spot.  pptfxPathRecEnd
// points to first spot *after* the last available spot.

    pptfxPathRecCurrent = &pprNew->aptfx[0];
    pptfxPathRecEnd     = &pprNew->aptfx[cMax];

    return(TRUE);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vGrowPathAndAddPoint(pptfx)
*
* Adds to the current path by creating a new record and adding the
* specified point.  If this fails, the path is marked as being out-of-
* memory.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPATHOBJ::vGrowPathAndAddPoint(
PPOINTFIX  pptfx,
PEVECTORFX pvec,
BOOL       bInvert)
{
    ASSERT4GB((LONGLONG)(pptfxPathRecCurrent - ppath->pprlast->aptfx));

    COUNT cpt = (COUNT)(pptfxPathRecCurrent - ppath->pprlast->aptfx);

    ppath->pprlast->count         = cpt;
    ppath->ppachain->pprfreestart = NEXTPATHREC(ppath->pprlast);

    if (bValid())
    {
        if (!bGrowPath())
            vSetError();

        else
        {
            ppath->pprlast->flags = 0;
            *pptfxPathRecCurrent = *pptfx;

            if (pvec != (PEVECTORFX) NULL)
            {
                if (bInvert)
                {
                    pptfxPathRecCurrent->x -= pvec->x;
                    pptfxPathRecCurrent->y -= pvec->y;
                }
                else
                {
                    pptfxPathRecCurrent->x += pvec->x;
                    pptfxPathRecCurrent->y += pvec->y;
                }
            }

            pptfxPathRecCurrent++;
        }
    }
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::bBeginFigure()
*
* Creates the start of a new figure (sub-path) in the path.  Must be
* called before vAddPoint().
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDEPATHOBJ::bBeginFigure()
{
    if (bValid())
    {
        #ifdef DEBUG_WIDE
        ASSERTGDI(!bOpenPath, "BeginFigure on already open path!");
        bOpenPath = TRUE;
        #endif

        if (bGrowPath())
        {
            ppath->pprlast->flags = PD_BEGINSUBPATH;
            return(TRUE);
        }

        vSetError();
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vEndFigure()
*
* Ends the open figure.  Must be called after all vAddPoint()'s are done
* for the figure.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPATHOBJ::vEndFigure()
{
#ifdef DEBUG_WIDE
    ASSERTGDI(bOpenPath, "vEndFigure on unopen path!");
    bOpenPath = FALSE;
#endif
    //Sundown truncation
    ASSERT4GB((ULONGLONG)(pptfxPathRecCurrent - ppath->pprlast->aptfx));
    COUNT cpt = (COUNT)(pptfxPathRecCurrent - ppath->pprlast->aptfx);

    ppath->pprlast->flags |= PD_ENDSUBPATH;
    ppath->pprlast->count = cpt;

// Adjust the pathalloc record:

    ppath->ppachain->pprfreestart = NEXTPATHREC(ppath->pprlast);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vPrependBeforeFigure()
*
* Moves the last figure in path and prepends to the first figure.
*
* History:
*  24-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID WIDEPATHOBJ::vPrependBeforeFigure()
{
#ifdef DEBUG_WIDE
    ASSERTGDI(!bOpenPath, "vPrependBeforeFigure on open path!");
#endif

    PPATHREC pprSrcStart;
    PPATHREC pprTargStart;

// Find the start of the last figure:

    pprSrcStart = ppath->pprlast;
    while (!(pprSrcStart->flags & PD_BEGINSUBPATH))
    {
        pprSrcStart = pprSrcStart->pprprev;
        ASSERTGDI(pprSrcStart != (PPATHREC) NULL, "Couldn't find start");
    }

// Find the start of the 2nd last figure:

    pprTargStart = pprFigureStart;
    ASSERTGDI(pprTargStart != (PPATHREC) NULL &&
             (pprTargStart->flags & PD_BEGINSUBPATH), "Funky pprFigureStart");

    PPATHREC pprTargEnd   = pprSrcStart->pprprev;
    PPATHREC pprSrcEnd    = ppath->pprlast;

// 'targ' is currently before 'src', and 'src' is the last figure in the
// path.  We'll move 'src' to be before 'targ':

    ppath->pprlast = pprTargEnd;

// Hmmm, seems to me we're guaranteed to have pprprev NULL here because
// we're looking at the start of the path:

    if (pprTargStart->pprprev == (PPATHREC) NULL)
        ppath->pprfirst = pprSrcStart;
    else
        pprTargStart->pprprev->pprnext = pprSrcStart;

    pprSrcStart->pprprev  = pprTargStart->pprprev;
    pprSrcEnd->pprnext    = pprTargStart;
    pprTargStart->pprprev = pprSrcEnd;
    pprTargEnd->pprnext   = (PPATHREC) NULL;

// We're prepending this to the start of the first figure, so clean up
// the flags:

    pprTargStart->flags &= ~PD_BEGINSUBPATH;
    pprSrcEnd->flags    &= ~(PD_ENDSUBPATH | PD_CLOSEFIGURE);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vPrependBeforeSubpath()
*
* Moves the last figure in path and prepends it to the previous subpath.
*
* History:
*  24-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID WIDEPATHOBJ::vPrependBeforeSubpath()
{
#ifdef DEBUG_WIDE
    ASSERTGDI(!bOpenPath, "vPrependBeforeSubpath on open path!");
#endif

    PPATHREC pprSrcStart;
    PPATHREC pprTargStart;

// Find the start of the last figure:

    pprSrcStart = ppath->pprlast;
    while (!(pprSrcStart->flags & PD_BEGINSUBPATH))
    {
        pprSrcStart = pprSrcStart->pprprev;
        ASSERTGDI(pprSrcStart != (PPATHREC) NULL, "Couldn't find start");
    }

// Find the start of the 2nd last figure:

    ASSERTGDI(pprSrcStart->pprprev != (PPATHREC) NULL, "Was no previous figure");

    pprTargStart = pprSrcStart->pprprev;
    while (!(pprTargStart->flags & PD_BEGINSUBPATH))
    {
        pprTargStart = pprTargStart->pprprev;
        ASSERTGDI(pprTargStart != (PPATHREC) NULL, "Couldn't find previous figure");
    }

    PPATHREC pprTargEnd   = pprSrcStart->pprprev;
    PPATHREC pprSrcEnd    = ppath->pprlast;

// 'targ' is currently before 'src', and 'src' is the last figure in the
// path.  We'll move 'src' to be before 'targ':

    ppath->pprlast = pprTargEnd;

    if (pprTargStart->pprprev == (PPATHREC) NULL)
        ppath->pprfirst = pprSrcStart;
    else
        pprTargStart->pprprev->pprnext = pprSrcStart;

    pprSrcStart->pprprev  = pprTargStart->pprprev;
    pprSrcEnd->pprnext    = pprTargStart;
    pprTargStart->pprprev = pprSrcEnd;
    pprTargEnd->pprnext   = (PPATHREC) NULL;

// We're prepending this to the start of the first figure, so clean up
// the flags:

    pprTargStart->flags &= ~PD_BEGINSUBPATH;
    pprSrcEnd->flags    &= ~(PD_ENDSUBPATH | PD_CLOSEFIGURE);
}

/******************************Public*Routine******************************\
* WIDEPATHOBJ::vReverseConcatenate(wpo)
*
* Reverses 'wpo' and adds all points to the end of this path.
* bBeginFigure() must have been called previously for this path, and
* 'wpo' must be ended by calling vEndFigure().
*
* The path records of 'wpo' are freed as they are copied (in order to
* decrease the total number of path records needed by both paths).  As such,
* 'wpo' must be entirely one figure!
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPATHOBJ::vReverseConcatenate(WIDEPATHOBJ& wpo)
{
#ifdef DEBUG_WIDE
    ASSERTGDI(bOpenPath, "vReverseConcatenate on closed target!");
    ASSERTGDI(!wpo.bOpenPath, "vReverseConcatenate on open source!");
#endif

    ASSERTGDI(bValid(), "Reverse invalid path");

    ASSERTGDI(wpo.ppath->pprfirst != (PPATHREC) NULL, "NULL path 1");
    ASSERTGDI(wpo.ppath->ppachain != (PPATHALLOC) NULL, "NULL path 2");
    ASSERTGDI(ppath->pprfirst != (PPATHREC) NULL, "NULL path 3");
    ASSERTGDI(ppath->ppachain != (PPATHALLOC) NULL, "NULL path 4");

// Reverse the path:

    PPATHREC ppr = wpo.ppath->pprlast;
    while (ppr != (PPATHREC) NULL)
    {
        PPATHREC pprPrev = ppr->pprprev;

        PPOINTFIX pptfxStart;
        PPOINTFIX pptfxEnd;

    // Copy all the points in reverse order:

        pptfxStart = &ppr->aptfx[0];
        pptfxEnd   = &ppr->aptfx[ppr->count];

        while (pptfxEnd > pptfxStart)
            vAddPoint(--pptfxEnd);

        PPATHALLOC ppaEnd = wpo.ppath->ppachain;

        ASSERTGDI(ppaEnd != (PPATHALLOC) NULL, "Null pathalloc");

        wpo.ppath->ppachain = ppaEnd->ppanext;

        ASSERTGDI(((PBYTE) pptfxStart > (PBYTE) ppaEnd) &&
           ((PBYTE) pptfxStart - (PBYTE) ppaEnd) < (LONG) ppaEnd->siztPathAlloc,
           "Last pathrec doesn't correspond to last pathalloc");

        freepathalloc(ppaEnd);

        ppr = pprPrev;
    }

    ASSERTGDI(wpo.ppath->ppachain == (PPATHALLOC) NULL,
              "Didn't delete entire chain");

// Clean up old path:

    wpo.ppath->ppachain = (PPATHALLOC) NULL;
    wpo.ppath->pprlast  = (PPATHREC) NULL;
    wpo.ppath->pprfirst = (PPATHREC) NULL;
}

/******************************Public*Routine******************************\
* vHalve(vec)
*
* Halves the vector, and always rounds 1/32 up.  Symmetric about zero.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID vHalve(EVECTORFX& vec)
{
    if (vec.x >= 0)
        vec.x++;
    if (vec.y >= 0)
        vec.y++;

    vec.x >>= 1;
    vec.y >>= 1;
}


/******************************Public*Routine******************************\
* vVecSymmetricRound(pvec)
*
* Always rounds 1/2 up.  Symmetric about zero.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID vVecSymmetricRound(PEVECTORFX pvec)
{
// Round 1/2 up:

    if (pvec->x >= 0)
        pvec->x = (pvec->x + 4) & ~7L;
    else
        pvec->x = (pvec->x + 3) & ~7L;

    if (pvec->y >= 0)
        pvec->y = (pvec->y + 4) & ~7L;
    else
        pvec->y = (pvec->y + 3) & ~7L;
}


/******************************Public*Routine******************************\
* vVecRound(pvec)
*
* Always rounds 1/2 down for 'x'.  Rounds 1/2 up for 'y'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID vVecRound(PEVECTORFX pvec)
{
// Round 1/2 down:

    if (pvec->x >= 0)
        pvec->x = (pvec->x + 3) & ~7L;
    else
        pvec->x = (pvec->x + 4) & ~7L;

// Round 1/2 up:

    if (pvec->y >= 0)
        pvec->y = (pvec->y + 4) & ~7L;
    else
        pvec->y = (pvec->y + 3) & ~7L;
}

/******************************Public*Routine******************************\
* WIDEPENOBJ::bHobbyize(avecAxis[])
*
* Will copy a pre-computed Hobby pen polygon if the pen is small and
* circular.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDEPENOBJ::bHobbyize(EVECTORFX avecAxis[])
{
    ASSERTGDI(((avecAxis[0].x == avecAxis[1].y) && (avecAxis[0].y == -avecAxis[1].x))
           || ((avecAxis[0].x == -avecAxis[1].y) && (avecAxis[0].y == avecAxis[1].x)),
        "Must be orthogonal and circular");

    ASSERTGDI((MAX(ABS(avecAxis[0].x), ABS(avecAxis[0].y))
           < LPLUSHALFTOFX(HOBBY_TABLE_SIZE)), "Must be Hobby sized");

// We now know that the transform was orthogonal, and that the pen is
// circular in device space.

// We now know that the vector coordinates have less than 15 bits
// signficance, so we can safely compute its Euclidean length in
// 32 bits:

    FIX fxPenWidthSquared = avecAxis[0].x * avecAxis[0].x
                          + avecAxis[0].y * avecAxis[0].y;

    if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(HOBBY_TABLE_SIZE)))
    {
    // Pen is small enough that it will be in our Hobby tables:

        LONG iHobbyPen;

        if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(1)))
            iHobbyPen = 0;                 // Width less than 1.5
        else if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(2)))
            iHobbyPen = 1;                 // Width less than 2.5
        else if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(3)))
            iHobbyPen = 2;                 // Width less than 3.5
        else if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(4)))
            iHobbyPen = 3;                 // Width less than 4.5
        else if (fxPenWidthSquared < SQUARE(LPLUSHALFTOFX(5)))
            iHobbyPen = 4;                 // Width less than 5.5
        else
        {
            #if (HOBBY_TABLE_SIZE != 6L)
            #error "Table size changed, update routine"
            #endif

            iHobbyPen = 5;                 // Width less than 6.5
        }

    // Copy the Hobby pen from the table to our path:

        if (!bBeginFigure())
            return(FALSE);

        PPOINTFIX pptfx    = ahob[iHobbyPen].pptfx;
        PPOINTFIX pptfxEnd = pptfx + ahob[iHobbyPen].cptfx;

        while (pptfx < pptfxEnd)
            vAddPoint(pptfx++);

        vEndFigure();
        bIsHobby(TRUE);

        return(TRUE);
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* WIDEPENOBJ::bThicken(aptfxDiameter)
*
* Check if the pen is so thin in one dimension that it would be invisible
* for some lines.  If so, thicken it.
*
* History:
*  31-Jan-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#define FX_HALF         (LTOFX(1) >> 1)
#define FX_HALF_SQUARED (FX_HALF * FX_HALF)

BOOL WIDEPENOBJ::bThicken(PPOINTFIX aptfxDiameter)
{
// The aptfxDiameter vectors passed to us were constructed from the
// diameter of the pen -- we actually want the vectors as based on
// the radius, so halve them:

    EVECTORFX aevecTmp[2];
    PPOINTFIX aptfx = (PPOINTFIX) aevecTmp;

    aevecTmp[0] = aptfxDiameter[0];
    aevecTmp[1] = aptfxDiameter[1];
    vHalve(aevecTmp[0]);
    vHalve(aevecTmp[1]);

// What I would like to do is compute the length of the minor-axis of
// the pen ellipse in device coordinates -- if its length is less than
// half a pixel, we know we have to thicken the pen.
//
// But it's a lot of computation to do that (see Knuth, "Metafont",
// p. 382).  So, we take the two vectors that described the axis of
// the ellipse in world space, and transform them to device space (call
// them 'avec').  The perpendicular distance from the smaller vector
// to the larger will be close to the minor-axis length.

// Make sure we won't overflow:

    if (((ABS(aptfx[0].x) | ABS(aptfx[0].y) | ABS(aptfx[1].x) | ABS(aptfx[1].y))
      & ~(0xfffL)) != 0)
        return(FALSE);

    FIX fxLengthSquared0 = aptfx[0].x * aptfx[0].x + aptfx[0].y * aptfx[0].y;
    FIX fxLengthSquared1 = aptfx[1].x * aptfx[1].x + aptfx[1].y * aptfx[1].y;

    POINTFIX ptfx;         // Will be the largest vector
    FIX      fxLength;     // Length of largest vector

//
// We use the forumla to compute the distance from a point to a line
// from the origin, where 'd' is the distance, 'B' is the vector,
// 'P' is the point:
//
//                                          2
//      2   4 [ (P.y * B.x) - (P.x * B.y) ]
//     d  = -------------------------------
//               B.x * B.x + B.y * B.y
//
// We want to exit early when the distance is more than 1/2 pixel (8 in
// FIX units), i.e. HALF < d or:
//
//          2     2      2                                   2
//      HALF  (B.x  + B.y ) < 4 [ (P.y * B.x) - (P.x * B.y) ]
//

    if (fxLengthSquared0 > fxLengthSquared1)
    {
    // Vector 0 is bigger than 1:

        FIX fxNum = aptfx[1].y * aptfx[0].x - aptfx[1].x * aptfx[0].y;

        LONGLONG eqLeft  = (LONGLONG) fxLengthSquared0 * (FX_HALF_SQUARED >> 2);
        LONGLONG eqRight = Int32x32To64((LONG) fxNum, (LONG) fxNum);

        if (eqLeft < eqRight)
            return(FALSE);

        ptfx = aptfx[0];
        fxLength = fxLengthSquared0;
    }
    else
    {
    // Vector 1 is bigger than (or equal to) 0:

        FIX fxNum = aptfx[0].y * aptfx[1].x - aptfx[0].x * aptfx[1].y;

        LONGLONG eqLeft = (LONGLONG) fxLengthSquared1 * (FX_HALF_SQUARED >> 2);
        LONGLONG eqRight = Int32x32To64((LONG) fxNum, (LONG) fxNum);

        if (eqLeft < eqRight)
            return(FALSE);

        ptfx = aptfx[1];
        fxLength = fxLengthSquared1;
    }

// Make sure that the largest vector extends outside the unit circle (if
// it's not, we'll make it so that we end up with the entire Hobby pen
// for width 1):

    if (fxLength < FX_HALF_SQUARED)
    {
        ptfx.x = FX_HALF;
        ptfx.y = 0;
    }

// Okay, we know the larger vector, and we have to fix the smaller one.
// Let's simply figure out the vertex on the Hobby pen of width 1 that
// would be used if we drew a line in the same direction as our large
// vector (which is when our given pen is its thinest).
//
// So let's compute the appropriate Hobby vector of size one (making
// sure it's to the 'left' of the big vector, because the vertices have to
// be in counter-clockwise order):

    POINTFIX ptfxHobby;

    if (ABS(ptfx.y) <= ptfx.x)
    {
        ptfxHobby.x = 0;
        ptfxHobby.y = -FX_HALF;
    }
    else if (ABS(ptfx.x) <= -ptfx.y)
    {
        ptfxHobby.x = -FX_HALF;
        ptfxHobby.y = 0;
    }
    else if (ABS(ptfx.y) <= -ptfx.x)
    {
        ptfxHobby.x = 0;
        ptfxHobby.y = FX_HALF;
    }
    else
    {
        ASSERTGDI(ABS(ptfx.x) <= ptfx.y, "Oops");
        ptfxHobby.x = FX_HALF;
        ptfxHobby.y = 0;
    }

// Put stuff into path, remembering that 'pptfx' points to either
// ppath->pprlast->aptfx[0] or [1].  Also, we have to be in counter-
// clockwise order.

    if (!bBeginFigure())
        return(FALSE);

    vAddPoint(&ptfx);
    vAddPoint(&ptfxHobby);

    ptfx.x = -ptfx.x;
    ptfx.y = -ptfx.y;
    ptfxHobby.x = -ptfxHobby.x;
    ptfxHobby.y = -ptfxHobby.y;

    vAddPoint(&ptfx);
    vAddPoint(&ptfxHobby);

    vEndFigure();
    return(TRUE);
}

/******************************Public*Routine******************************\
* WIDEPENOBJ::bPenFlatten(pptfxControl)
*
* Flattens a geometric pen object.  pptfxControl points to the 7 control
* points of a half-ellipse.
*
* History:
*  1-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDEPENOBJ::bPenFlatten(PPOINTFIX pptfxControl)
{
    if (!bGrowPath())
        return(FALSE);

    ASSERTGDI(pptfxPathRecEnd - pptfxPathRecCurrent > 2, "Path rec too small");

    ppath->pprlast->flags = PD_BEGINSUBPATH;

// Leave room to insert a point at the beginning of the path.  Also leave
// room for an additional point at the end of the path record:

    PPOINTFIX pptfxFirst = pptfxPathRecCurrent;
    pptfxPathRecCurrent++;
    pptfxPathRecEnd--;

// Don't forget the very first point:

    *pptfxPathRecCurrent++ = *pptfxControl;

// We'll crack 2 Beziers:

    for (LONG ll = 0; ll <= 1; ll++, pptfxControl += 3)
    {
        BOOL bMore;
        BEZIER bez;
        bez.vInit(pptfxControl);

        do
        {
            bMore = bez.bNext(pptfxPathRecCurrent++);

        // Check if we have to create a new path record:

            if (pptfxPathRecCurrent > pptfxPathRecEnd)
            {
            // Wrap up old path record:

                ASSERTGDI(pptfxPathRecCurrent == pptfxPathRecEnd + 1,
                          "Cur != End + 1");

            // We want to repeat the last edge of this path record as the
            // first edge in the next.  That means repeating two points
            // (remember that we left room for one more point in this record):

                PPOINTFIX pptfxPrev = pptfxPathRecCurrent - 2;

            // Sundown truncation
                ppath->pprlast->count = (ULONG)(pptfxPathRecCurrent
                                      - ppath->pprlast->aptfx);

                ASSERTGDI(ppath->pprlast->count >= 3,
                          "Pen pathrecord doesn't have 3 vertices");

                ppath->ppachain->pprfreestart = NEXTPATHREC(ppath->pprlast);

            // Create a new path record:

                if (!bGrowPath())
                    return(FALSE);

                ppath->pprlast->flags = 0;

            // Repeat those two points in the new path record:

                *pptfxPathRecCurrent++ = *(pptfxPrev);
                *pptfxPathRecCurrent++ = *(pptfxPrev + 1);

            // Don't forget to leave room for an additional point at the
            // end of the record:

                pptfxPathRecEnd--;

            }
        } while (bMore);
    }

// The pen covers 180 degrees of the ellipse.  The first and last edges
// of the pen must be parallel, their vectors in opposite directions.
// The last point in the path is already the opposite of the first.  Now
// make the zeroth point the opposite of the second last and voila,
// parallel edges.

    pptfxFirst->x = - (pptfxPathRecCurrent - 2)->x;
    pptfxFirst->y = - (pptfxPathRecCurrent - 2)->y;

    ppath->pprlast->flags |= PD_ENDSUBPATH;
    // Sundown truncation
    ppath->pprlast->count = (ULONG)(pptfxPathRecCurrent - ppath->pprlast->aptfx);

    ASSERTGDI(ppath->pprlast->count >= 3,
              "Final pen pathrecord doesn't have 3 vertices");

    return(TRUE);
}


/******************************Public*Routine******************************\
* WIDEPENOBJ::bPolygonizePen(exo, ulWidth)
*
* Creates a polyline approximation to the pen.
*
* If the pen is small and circular, we copy a pre-computed Hobby pen;
* otherwise, we approximate the pen using Bezier curves and convert this
* to lines.  Remembering that the pen is defined in world space, we
* construct the Bezier curves that approximate the pen circle in world
* space.  We then transform the coordinates to device space, and flatten.
*
* It makes life a lot easier if we can assume that the vertices of the pen
* are stored in counter-clockwise order.  So, we check the transform to
* see if it is inverting, and adjust the Bezier control points accordingly.
*
* Due to the half-symmetry property of ellipses, we only have to store
* the vertices for half the ellipse.  For the binary search, it is useful
* also to ensure that the last edge vector is the exact opposite of the
* first.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDEPENOBJ::bPolygonizePen(
EXFORMOBJ& exo,          // World to device transform
LONG       lWidth)       // Pen width in world space
{
    EVECTORFX avecAxis[2];

    avecAxis[0].x =   (FIX) lWidth;
    avecAxis[0].y = 0;
    avecAxis[1].x = 0;
    avecAxis[1].y = - (FIX) lWidth;

    exo.bXform((PVECTORL) avecAxis, avecAxis, 2);

    if (((avecAxis[0].x == avecAxis[1].y) && (avecAxis[0].y == -avecAxis[1].x))
     || ((avecAxis[0].x == -avecAxis[1].y) && (avecAxis[0].y == avecAxis[1].x)))
    {

    // We now know that the transform was orthogonal, and that the pen is
    // circular in device space.

        if (MAX(ABS(avecAxis[0].x), ABS(avecAxis[0].y))
            < LPLUSHALFTOFX(HOBBY_TABLE_SIZE))
        {
            if (bHobbyize(avecAxis))
                return(TRUE);

            else if (!bValid())     // See if path still okay
                return(FALSE);
        }
    }

    if (bThicken((PPOINTFIX) avecAxis))
        return(TRUE);

    else if (!bValid())             // See if path still okay
        return(FALSE);

// The points must be ordered in a counter-clockwise direction.
// The half-ellipse we're creating starts at avecAxis[0], goes through
// avecAxis[1], and ends at -avecAxis[0].  As such, avecAxis[1] must
// lie to the left of avecAxis[0]:

    if (!bTurnLeftRandom(&avecAxis[0], &avecAxis[1]))
    {
        avecAxis[1].x = -avecAxis[1].x;
        avecAxis[1].y = -avecAxis[1].y;
    }

    vHalve(avecAxis[0]);
    vHalve(avecAxis[1]);

    VECTORFX vecRight;
    VECTORFX vecUp;

    LONGLONG eqTmp;
    vEllipseControlsOut(&avecAxis[0], &vecRight, &eqTmp);
    vEllipseControlsOut(&avecAxis[1], &vecUp,    &eqTmp);

//
//                  4       3       2
//             +----x-------E-------x----+
//             |                         |
//             |                         |
//             |                         |
//           5 x                         x 1  ^
//             |                         |    |
//             |                         |    |
//             |                         |    | vecUp
//             |            VecRight     |    |
//           6 E            O------->    E 0  |
//
// where 'O' is the origin,
//       'x' is a control point of a Bezier curve
//       'E' is an end point of a Bezier curve
//

    EVECTORFX avec[7];

    avec[6].x = -avecAxis[0].x;
    avec[6].y = -avecAxis[0].y;

    avec[5] = avec[6];
    avec[5] += vecUp;

    avec[4] = avecAxis[1];
    avec[4] -= vecRight;

    avec[3] = avecAxis[1];

    avec[2] = avecAxis[1];
    avec[2] += vecRight;

    avec[1] = avecAxis[0];
    avec[1] += vecUp;

    avec[0] = avecAxis[0];

    return(bPenFlatten((PPOINTFIX) avec));
}

/******************************Public*Routine******************************\
* bLeft(pvec, pptfx, pfxCross)
*
* Returns TRUE if the vector to 'pptfx' turns left from 'pvec'.  Returns
* the cross product in pfxCross.
*
* NOTE: Since only the low DWORD of the cross product is returned, *pfxCross
* is valid only when the vector '*(pptfx + 1) - *pptfx' is close to being
* parallel to 'pvec'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE BOOL bLeft(
PEVECTORFX pvec,     // First vector
PPOINTFIX  pptfx,    // Second vector
PLONGLONG  pfxCross) // Result of pvec X pptfx
{
    LONGLONG ad;
    LONGLONG bc;

    ad = Int32x32To64(pvec->x, (pptfx + 1)->y - pptfx->y);
    bc = Int32x32To64(pvec->y, (pptfx + 1)->x - pptfx->x);

    ad -= bc;

    *pfxCross = ad;

    return(ad < 0);
}


/******************************Public*Routine******************************\
* WIDEPENOBJ::vDetermineDrawVertex(vec, ld)
*
* The core routine of wide-lines.  This routine determines the point
* on the pen that draws the wide-line outline for the given line vector.
*
* Think of the line as a ray, and imagine dragging an elliptical pen
* along it.  The point on the ellipse that is furthest from the
* ray defines the outline of the widened line.  It's a bit of work to
* determine the draw vertex on a true ellipse (involving a bunch of
* floating point calculations).
*
* We take a different approach: we've already computed a convex polygonal
* approximation of the true ellipse.  We search the vertices of the
* polygon to determine which is the farthest from the ray.
*
* We could do this by finding the maximum cross product of the line
* vector and the vectors from the center of the pen to each of its
* vertices, but this approach doesn't lend itself to a binary search.
*
* We accomplish a binary search by looking at the cross product of the
* line vector and the vector difference between successive vertices of the
* pen polygon -- we find the point on the pen polygon whose adjacent
* edge vector on one side turns to the 'left' of the line vector, and
* whose other edge vector turns to the 'right' of the line vector.
* That is, the vertex whose cross products of its adjacent edge vectors
* and the line vector have different signs.
*
* Our pen polygon is only half the ellipse -- under an affine transform,
* ellipses are always symmetrical about some axis.  Since we made sure
* the first edge is exactly opposite the last edge when we built the
* pen polygon, it follows that for any line vector, the cross product
* with the first and last edges have different signs (unless the line
* vector is parallel to that edge, which we sort of let fall through).
* So we start the binary search by considering the first and last edges
* of the half-ellipse.
*
* For the binary search, we maintain the invariant that the cross product
* of the first and last edges with our line vector has different signs, and
* we subdivide the interval between the first and last edge until they are
* adjacent edges on the polygon; the shared vertex is then our draw vertex.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPENOBJ::vDetermineDrawVertex(
EVECTORFX& vec,            // Direction of line
LINEDATA&  ld)             // Result goes here
{
    PPOINTFIX pptfxStart;
    PPOINTFIX pptfxEnd;
    PPOINTFIX pptfxMid;

    LONGLONG fxCrossMid;

    BOOL bLeftStart;
    BOOL bLeftEnd;

    ld.ppr = ppath->pprfirst;

    if (ppath->pprfirst == ppath->pprlast)
    {
        bLeftStart = bLeft(&vec, &ld.ppr->aptfx[0], &ld.fxCrossStart);
        ld.fxCrossEnd = -ld.fxCrossStart;
    }
    else
    {
    // El yucko, the pen is bigger than one PathRecord.  Scan through the
    // linked list until we find a PathRecord whose edges bracket our vector.
    //
    // NOTE: If our vector is parallel to and in the same direction as the
    //       last edge in the last pathrecord, then
    //
    //          bTurnLeft(vec, vecStart) == FALSE
    //      and bTurnLeft(vec, vecEnd) == FALSE

        while (TRUE)
        {
           bLeftStart = bLeft(&vec,
                              &ld.ppr->aptfx[0],
                              &ld.fxCrossStart);

           bLeftEnd   = bLeft(&vec,
                              &ld.ppr->aptfx[ld.ppr->count - 2],
                              &ld.fxCrossEnd);

           if ((bLeftStart ^ bLeftEnd) || ld.ppr->pprnext == (PPATHREC) NULL)
              break;

           ld.ppr = ld.ppr->pprnext;
        }
    }

    if (bLeftStart)
        ld.vSetInvert();
    else
        ld.vClearInvert();

// 'pptfxStart' is a pointer to the first point of the first edge in
// the path record.  'pptfxEnd' is a pointer to the first point of the
// last edge.

    pptfxStart = &ld.ppr->aptfx[0];
    pptfxEnd   = &ld.ppr->aptfx[ld.ppr->count - 2];

    while (TRUE)
    {
        pptfxMid = pptfxStart + ((pptfxEnd - pptfxStart) >> 1);

        if (bLeft(&vec, pptfxMid, &fxCrossMid) ^ bLeftStart)
        {
        // Signs are different, so the point we want must be between
        // 'start' and 'mid':

            ld.fxCrossEnd = fxCrossMid;
            if (pptfxMid == pptfxStart + 1)
            {
                ld.pptfx = pptfxMid;
                break;
            }

            pptfxEnd = pptfxMid;
        }
        else
        {
        // Signs are the same, so the point we want must be between
        // 'mid' and 'end':

            ld.fxCrossStart = fxCrossMid;
            if (pptfxEnd == pptfxMid + 1)
            {
                ld.pptfx = pptfxEnd;
                break;
            }

            pptfxStart = pptfxMid;
        }

        ASSERTGDI(pptfxStart < pptfxEnd, "Couldn't find draw vertex");
    }

// ld.pptfx is our draw vertex.

#ifdef DEBUG_WIDE
    ASSERTGDI((ld.fxCrossEnd >= 0 && ld.fxCrossStart < 0) ||
              (ld.fxCrossEnd <= 0 && ld.fxCrossStart >= 0),
              "Expected different cross products signs");
#endif

    ld.fxCrossStart = ABS(ld.fxCrossStart);
    ld.fxCrossEnd   = ABS(ld.fxCrossEnd);
}

/******************************Public*Routine******************************\
* vAddNice(wpath, pptfx, pvec, bInvert)
*
* This routine is for adding round joins and end-caps to the given path.
*
* It does a trick to make rounds look nicer: when the given point lies on
* the integer grid, it shrinks the pen vector by 1/16th of a pel in both
* coordinates.
*
* This works on the assumption that most often the pens are constructed
* from integer widths in device space -- when that happens, we will often
* get assymetric filling because our fill convention breaks ties when a
* scan-line has a line fall exactly on the integer grid by being lower-right
* exclusive.
*
* Note: Remember that the bounds calculation has to take this possible
*       size increase into account.
*
* History:
*  20-Nov-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vAddNice(
WIDEPATHOBJ&  wpath,           // Path to add to
PPOINTFIX     pptfx,         // Spine point about which the round is added
PEVECTORFX    pvec,          // The vector to add to pptfx
BOOL          bInvert)       // TRUE if pvec is to be subtracted from pptfx
{
    EVECTORFX vec;

    if (((pptfx->x | pptfx->y) & (LTOFX(1) - 1)) == 0)
    {
        if (bInvert)
        {
            vec.x = -pvec->x;
            vec.y = -pvec->y;
            bInvert = FALSE;
        }
        else
        {
            vec = *pvec;
        }

        if (vec.x > 0)
            vec.x -= 1;
        else if (vec.x < 0)
            vec.x += 1;

        if (vec.y > 0)
            vec.y -= 1;
        else if (vec.y < 0)
            vec.y += 1;

        pvec = &vec;
    }

    wpath.vAddPoint(pptfx, pvec, bInvert);
}


/******************************Public*Routine******************************\
* WIDEPENOBJ::cptAddRound(wid, ldIn, ldOut, bLeft, bInPerp, bOutPerp)
*
* Adds round joins to 'wid'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

COUNT WIDEPENOBJ::cptAddRound(
WIDENER&     wid,        // Path to which to add
LINEDATA&    ldIn,       // Vector entering the point
LINEDATA&    ldOut,      // Vector exiting the point
BOOL         bLeft,      // ldOut turns left from ldIn?
BOOL         bInPerp,    //
BOOL         bOutPerp)   //
{
    COUNT cpt = 0;

    ASSERTGDI(ldIn.bVecDrawComputed() && ldOut.bVecDrawComputed(),
              "Draw vertex not computed");

    if (ldIn.pptfx == ldOut.pptfx && ldIn.bInvert() == ldOut.bInvert())
        return(0);

    BOOL      bInvert  = ldIn.bInvert();
    PPATHREC  ppr      = ldIn.ppr;
    PPOINTFIX pptfx    = ldIn.pptfx;

    if (bLeft)
    {
    // Turns left, so add counter-clockwise to right side:

        if (bInPerp && !ldIn.bToLeftSide())
        {
            wid.vAddRightNice((PEVECTORFX) pptfx, bInvert);
        }

        pptfx++;

        while (ppr != ldOut.ppr ||
               pptfx > ldOut.pptfx ||
               bInvert != ldOut.bInvert())
        {
            PPOINTFIX pptfxEnd = &ppr->aptfx[ldIn.ppr->count - 1];

            while (pptfx < pptfxEnd)
            {
                wid.vAddRightNice((PEVECTORFX) pptfx++, bInvert);
                cpt++;
            }

            if (ppr->pprnext != (PPATHREC) NULL)
                ppr = ppr->pprnext;
            else
            {
                ppr = ppath->pprfirst;
                bInvert = !bInvert;
            }

            pptfx = &ppr->aptfx[1];
        }

        ASSERTGDI(ppr == ldOut.ppr, "Unmatched path record pointers");
        ASSERTGDI(ldOut.pptfx - pptfx < (PATHALLOCSIZE >> 3),
                "Clockwise join unsynced");

        while (pptfx < ldOut.pptfx)
        {
            wid.vAddRightNice((PEVECTORFX) pptfx++, bInvert);
            cpt++;
        }

        if (bOutPerp && ldOut.bToLeftSide())
        {
            wid.vAddRightNice((PEVECTORFX) pptfx, bInvert);
        }
    }
    else
    {
    // Turns right, so add clockwise to left side:

        if (bInPerp && ldIn.bToLeftSide())
        {
            wid.vAddLeftNice((PEVECTORFX) pptfx, bInvert);
        }

        pptfx--;

        while (ppr != ldOut.ppr ||
               pptfx < ldOut.pptfx ||
               bInvert != ldOut.bInvert())
        {
            PPOINTFIX pptfxStart = &ppr->aptfx[1];

            while (pptfx > pptfxStart)
            {
                wid.vAddLeftNice((PEVECTORFX) pptfx--, bInvert);
                cpt++;
            }

            if (ppr->pprprev != (PPATHREC) NULL)
                ppr = ppr->pprprev;
            else
            {
                ppr = ppath->pprlast;
                bInvert = !bInvert;
            }

            pptfx = &ppr->aptfx[ppr->count - 1];
        }

        ASSERTGDI(ppr == ldOut.ppr, "Unmatched path record pointers");
        ASSERTGDI(pptfx - ldOut.pptfx < (PATHALLOCSIZE >> 3),
                  "Counterclockwise join unsynced");

        while (pptfx > ldOut.pptfx)
        {
            wid.vAddLeftNice((PEVECTORFX) pptfx--, bInvert);
            cpt++;
        }

        if (bOutPerp && !ldOut.bToLeftSide())
        {
            wid.vAddLeftNice((PEVECTORFX) pptfx, bInvert);
        }
    }

    return(cpt);
}


/******************************Public*Routine******************************\
* WIDEPENOBJ::vAddRoundEndCap(wid, ld, bStartCap, bRound)
*
* Adds round caps to the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDEPENOBJ::vAddRoundEndCap(
WIDENER&     wid,        // Path to which to add
LINEDATA&    ld,         // Vector entering the point
BOOL         bStartCap,  // TRUE if Start-cap
BOOL         bRound)     // TRUE if round joins
{
    ASSERTGDI(ld.bVecDrawComputed(), "Draw vertex not computed");

    BOOL      bInvert  = (bStartCap) ? !ld.bInvert() : ld.bInvert();
    PPATHREC  ppr      = ld.ppr;
    PPOINTFIX pptfx    = ld.pptfx;

// Turns left, so add counter-clockwise to right side:

    if (!bRound && !ld.bToLeftSide())
        wid.vAddRightNice((PEVECTORFX) pptfx, bInvert);

    pptfx++;

    while (ppr != ld.ppr ||
           pptfx > ld.pptfx)
    {
        PPOINTFIX pptfxEnd = &ppr->aptfx[ld.ppr->count - 1];

        while (pptfx < pptfxEnd)
            wid.vAddRightNice((PEVECTORFX) pptfx++, bInvert);

        if (ppr->pprnext != (PPATHREC) NULL)
            ppr = ppr->pprnext;
        else
        {
            ppr = ppath->pprfirst;
            bInvert = !bInvert;
        }

        pptfx = &ppr->aptfx[1];
    }

    ASSERTGDI(ppr == ld.ppr, "Unmatched path record pointers");
    ASSERTGDI(ld.pptfx - pptfx < (PATHALLOCSIZE >> 3),
            "Clockwise join unsynced");

    while (pptfx < ld.pptfx)
        wid.vAddRightNice((PEVECTORFX) pptfx++, bInvert);

    if (!bRound && ld.bToLeftSide())
        wid.vAddRightNice((PEVECTORFX) pptfx, bInvert);
}

/******************************Public*Routine******************************\
* READER::bNextPoint(ptfx)
*
* Reads the next point from the spine of the path.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL READER::bNextPoint(POINTFIX& ptfx)
{
    BOOL bRet;

    if (pptfxRead < pptfxEnd)
    {
        ptfx = *pptfxRead++;
        bRet = TRUE;
    }
    else if (pd.flags & PD_ENDSUBPATH)
        bRet = FALSE;
    else
    {

    // Get next path record:

        vMoreToEnum(pepoSpine->bEnum(&pd));

        ASSERTGDI(pd.count > 0, "Empty path record");
        ASSERTGDI(!(pd.flags & PD_BEGINSUBPATH), "Unexpected begin subpath");

        ptfx = pd.pptfx[0];
        pptfxRead = &pd.pptfx[1];
        pptfxEnd  = &pd.pptfx[pd.count];

        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* READER::bNextFigure()
*
* Goes to the next figure in the path.  Returns FALSE if there are none.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL READER::bNextFigure()
{
    BOOL bRet = bMoreToEnum();

    if (bRet)
    {
        vMoreToEnum(pepoSpine->bEnum(&pd));
        if (pd.count == 0)
        {
            ASSERTGDI(!bMoreToEnum(), "Empty path record in non-empty path");
            bRet = FALSE;
        }

        ASSERTGDI((pd.flags & PD_BEGINSUBPATH) || (pd.count == 0),
                  "bNextFig: Not at start of fig");

        pptfxRead = &pd.pptfx[0];
        pptfxEnd  = &pd.pptfx[pd.count];
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* LINER::vNextPoint()
*
* This function reads the next point in a path.  It will break Bezier
* curves into lines as it goes.
*
* CONSTRUCTING THE PATH BY VERTEX INSTEAD OF BY LINE
*
* The widening system is point based and not line based.  That is, we
* read the original path one vertex at-a-time and construct the wide-lines
* by making the appropriate structures at each of those vertices (i.e.,
* at every vertex we either construct an end-cap or a join); we don't read
* the path a line at-a-time and add both ends of the line then do the
* join if there is one.
*
* This is a subtle but important distinction.
*
* RETURNING THE DATA
*
* To construct a join, we need 3 things from the original path:
*      1) The point of the join;
*      2) The vector of the line entering the join;
*      3) The vector of the line exiting the join.
*
* A start cap requires:
*      1) The point of the start cap;
*      2) The vector of the line exiting the start cap.
*
* An end cap requires:
*      1) The point of the end cap;
*      2) The vector of the line entering the end cap.
*
* This data is returned by setting 'ptfxThis' as the point of interest,
* 'pldIn' points to the entering vector, and 'pldOut' points to the
* exiting vector.
*
* We don't incur the cost of re-computing the same perpendicular or draw
* vector for both sides of a line because that's handled by the lazy
* evaluation of 'pldIn' and 'pldOut'.
*
* VARIABLES
*
* Internal:
*
*   ptfxNext - Next point after 'ptfxThis', used to compute 'ldOut'
*   ptfxStartFigure - Start point for current figure
*   ls - Internal state for reading path
*   ldStartFigure - Line vector data for first line in figure
*   ldStartTangent, ldEndTangent - Line vector data for start and end
*                                  tangents of current Bezier
*
* External:
*
*   ptfxThis - Current point
*   pldIn, pldOut - Entering and exiting vectors from 'ptfxThis'
*
*          pld->vecLine is the difference vector between 'ptfxThis' and 'ptfxNext'
*               (so its length is the length of that line; used by styler)
*          pld->vecTangent is the true tangent vector at the point
*               (this is used for calculating true perpendiculars, and
*               its length does NOT correspond to the line at that point)
*
*   we - Returns point type at 'ptfxThis':
*
*           WE_STARTFIGURE - Figure starts here
*           WE_JOIN - Do a normal join
*           WE_BEZIERJOIN - Do a Bezier join
*           WE_CLOSEFIGURE - Do the final CloseFigure join
*           WE_ENDFIGURE - Do the end-cap
*           WE_FINISHFIGURE - Do the start-cap for the figure we
*                             just finished
*           WE_DONEPATH - All done!
*
* The resulting language is:
*
*       {s{j|b}[c|ef]}d
*
* History:
*  1-Dec-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID LINER::vNextPoint()
{
// Assign 'pldOut' a new spot in the LINEDATA buffer.  Just make sure
// the location isn't already being used by 'pldIn':

    pldOut = &ldBuf[ (pldIn != &ldBuf[0]) ? 0 : 1 ];

    switch (ls)
    {

    case LS_READPATH:
    case LS_STARTFIGURE:
        if (ls == LS_READPATH)
            we = WE_JOIN;               // Normal join
        else
        {
            ASSERTGDI(ls == LS_STARTFIGURE, "Not start figure");

            we = WE_STARTFIGURE;        // The point starts a figure
            ls = LS_READPATH;
        }

        if (bNextPoint(ptfxNext))
        {
        // The next point in the path may be the second control point
        // of a Bezier curve.  If it is, we have to set up to crack the
        // curve into lines:

            if (bIsBezier())
            {
                POINTFIX aptfx[4];

                aptfx[0] = ptfxThis;
                aptfx[1] = ptfxNext;
                bNextPoint(aptfx[2]);
                bNextPoint(aptfx[3]);

                bez.vInit(aptfx);

                if (!bez.bNext(&ptfxNext))
                {
                // Okay, we have a real small Bezier curve (it got converted
                // into one line).  Don't bother trying to use the Bezier's
                // control points to get accurate perps (that is a heuristic
                // that only works when you have lotsa lines in the
                // approximation):

                    pldOut->vInit(ptfxNext, ptfxThis);

                    ls = LS_READPATH;
                    return;
                }

                pldOut->vInit(ptfxNext, ptfxThis);

                ldStartTangent = *pldOut;
                ldStartTangent.vecTangent  = aptfx[1];
                ldStartTangent.vecTangent -= aptfx[0];

            // Initialize end-tangent vector with the true end-tangent
            // (we will change 'ldEndTangent.vecLine' later):

                ldEndTangent.vInit(aptfx[3], aptfx[2]);

                pldOut = &ldStartTangent;

            // Set up to get the next point from the current Bezier:

                ls = LS_READBEZIER;
                return;
            }
        }
        else
        {
        // Since there is no 'ptfxNext', it follows that 'ptfxThis' is the
        // last point in the figure.  See if we have to close the figure.

            ls = LS_FINISHFIGURE;
            ptfxNext = ptfxStartFigure;

            if (bIsClosedFigure())
                we = WE_JOIN;
            else
            {
                we = WE_ENDFIGURE;
                return;
            }
        }
        break;

    case LS_FINISHFIGURE:
        we = bIsClosedFigure() ? WE_CLOSEFIGURE : WE_FINISHFIGURE;

        pldOut = &ldStartFigure;

        if (!bNextFigure())
            ls = LS_DONEPATH;
        else
        {
            bNextPoint(ptfxNext);
            ptfxStartFigure = ptfxNext;

            ls = LS_STARTFIGURE;
        }

        return;

    case LS_READBEZIER:
        we = WE_BEZIERJOIN;
        if (!bez.bNext(&ptfxNext))
        {
        // Since this is the last line in the Bezier, make sure we use
        // the tangent vector computed from the last two control points
        // when calculating perpendicular for the line:

            ls = LS_READPATH;
            pldOut->vInit(ptfxNext, ptfxThis);
            pldOut->vecTangent = ldEndTangent.vecTangent;
            return;
        }

        break;

    case LS_DONEPATH:
        we = WE_DONEPATH;
        return;

    default:
        RIP("Unknown line state");
    }

// Finally, compute the exit vector for those cases that made it here:

    pldOut->vInit(ptfxNext, ptfxThis);
}

/******************************Public*Routine******************************\
* LINER::vZeroFigure()
*
* Sets pldOut and pldIn for a zero-length figure.
*
* History:
*  31-Dec-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID LINER::vZeroFigure()
{
    ldStartFigure.vInit();
    ldStartFigure.vecLine.x    = LTOFX(1);
    ldStartFigure.vecTangent.x = LTOFX(1);
    ldStartFigure.vecLine.y    = 0;
    ldStartFigure.vecTangent.y = 0;

    pldIn  = &ldStartFigure;
    pldOut = &ldStartFigure;
}

/******************************Public*Routine******************************\
* LINER::vNextEvent()
*
* This function reads the next event from the path.
*
* History:
*  31-Dec-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID LINER::vNextEvent()
{
// Update some of our current point data:

    ptfxThis  = ptfxNext;
    pldIn = pldOut;

// Check out the next point:

    vNextPoint();

    WIDENEVENT weOld = we;

// Eat any zero-length lines.  This will stop automatically

    while (pldOut->vecLine.x == 0 && pldOut->vecLine.y == 0)
    {
        if (we != WE_STARTFIGURE && we != WE_JOIN && we != WE_BEZIERJOIN)
            break;

    // Due to rounding on the integer grid, for small Bezier curves
    // the first or last line segments may wind up being zero length.
    // In that case, 'vecLine' will be a zero-vector.  But we do know
    // the true tangents at that point.

        vNextPoint();

    }

// Have to watch for the case when the vecTagent is zero but vecLine is
// not (such as when the first two or last two control points of the
// Bezier are coincident):

    if (pldOut->vecTangent.x == 0 && pldOut->vecTangent.y == 0)
        pldOut->vecTangent = pldOut->vecLine;

    if (weOld == WE_STARTFIGURE)
    {
        if (we == WE_CLOSEFIGURE || we == WE_ENDFIGURE)
        {
            if (we == WE_ENDFIGURE)
            {
                vNextPoint();
                ASSERTGDI(we == WE_FINISHFIGURE, "Expected finish figure");
            }

            vZeroFigure();
            we = WE_ZEROFIGURE;
        }
        else
        {
            ldStartFigure = *pldOut;
            pldOut = &ldStartFigure;
            we = WE_STARTFIGURE;
        }
    }
}

/******************************Public*Routine******************************\
* STYLER::STYLER(epo, dco)
*
* Constructor for the styler.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

STYLER::STYLER(
  EPATHOBJ&   epo,                 // Path of spine
  PLINEATTRS  pla)
: LINER(epo),
  exoDeviceToWorld(&mxDeviceToWorld, DONT_COMPUTE_FLAGS)
{
    vDoingStyles((pla->pstyle != (PFLOAT_LONG) NULL) && (pla->cstyle > 0));

    if (bDoingStyles())
    {
        pstyleStart     = pla->pstyle;
        pstyleCurrent   = pstyleStart;
        pstyleEnd       = pstyleStart + pla->cstyle;

    // Next point comes from the path, not from a style:

        vStyleNext(FALSE);
    }
}

/******************************Public*Routine******************************\
* STYLER::efNextStyleLength()
*
* Reads next style array entry from user-supplied list.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE EFLOAT STYLER::efNextStyleLength()
{
    EFLOATEXT efResult(pstyleCurrent->e);

    pstyleCurrent++;

    if (pstyleCurrent >= pstyleEnd)
        pstyleCurrent = pstyleStart;

    ASSERTGDI(!efResult.bIsNegative(), "Negative style length");

    return(efResult);
}

/******************************Public*Routine******************************\
* STYLER::efWorldLength(vec)
*
* Computes the world space length of the vector.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

EFLOAT STYLER::efWorldLength(EVECTORFX vec)
{
// Transform the vector from device FIX format to world space LONG:

    BOOL bRet = exoDeviceToWorld.bXform(&vec, (PVECTORL) &vec, 1);

    ASSERTGDI(bRet, "XForm failed");

// Now compute the Cartesian length:

    EFLOAT x;
    EFLOAT y;

// The Alpha computes an eensy-weensy length for zero-length vectors
// which causes later math to underflow, so we simply check for zero
// length here.  The next smallest possible vector has a length of 1.0,
// and that has no chance of underflow.

    if ((vec.x == 0) && (vec.y == 0))
    {
        x = FP_0_0;
    }
    else
    {
        x = vec.x;
        y = vec.y;

        x *= x;
        y *= y;

        x += y;
        x.vSqrt();
    }

    return(x);
}

/******************************Public*Routine******************************\
* ptfxFraction(ptfx, pld, efDistance, efLineLength)
*
* Returns ptfx + pld->vecLine * (efDistance / efLineLength).
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

POINTFIX ptfxFraction(
 POINTFIX   ptfx,
 PLINEDATA  pld,
 EFLOAT&    efDistance,
 EFLOAT&    efLineLength)
{
    ASSERTGDI(efDistance <= efLineLength, "More than line length");
    ASSERTGDI(efDistance >= FP_0_0, "Negative distance");

    POINTFIX ptfxResult;

    if (efLineLength.bIsZero())
        return(ptfx);

    if (!pld->bNormalizedComputed())
    {
        pld->ptflNormalized.x = (LONG) pld->vecLine.x;
        pld->ptflNormalized.y = (LONG) pld->vecLine.y;

    // Assume a floating point multiply is twice as fast as a divide:

        EFLOAT efFactor;
        efFactor = FP_1_0;
        efFactor /= efLineLength;

        pld->ptflNormalized.x *= efFactor;
        pld->ptflNormalized.y *= efFactor;

        pld->vSetNormalizedComputed();
    }

    POINTFL ptfl;
    ptfl = pld->ptflNormalized;
    ptfl.x *= efDistance;
    ptfl.y *= efDistance;

    LONG x;
    LONG y;

// bEfToL has to take a LONG argument (can't be a FIX cast to a LONG):

    BOOL bRet1 = ptfl.x.bEfToL(x);
    BOOL bRet2 = ptfl.y.bEfToL(y);

    ASSERTGDI(bRet1 && bRet2, "Unexpected overflow");

    ptfxResult = ptfx;
    ptfxResult.x += (FIX) x;
    ptfxResult.y += (FIX) y;

    return(ptfxResult);
}

/******************************Public*Routine******************************\
* STYLER::vNextStyleEvent()
*
* Gets next style event.  Could be a join, end-cap, start-cap, etc.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID STYLER::vNextStyleEvent()
{
    if (!bDoingStyles())
        vNextEvent();
    else
    {
        if (bStyleNext())
        {
            if (we == WE_STOPDASH)
            {
            // Handle gaps:

            // This following test includes equality in order to eat zero
            // length lines when on a zero length style:

                while (efStyleLength >= efRemainingLength)
                {
                    efStyleLength -= efRemainingLength;

                    vNextEvent();

                    if (we != WE_JOIN && we != WE_BEZIERJOIN)
                    {
                    // We've come to the end of the figure, and it's covered
                    // by a gap.  Since we've effectively already put an end-cap
                    // on the figure (we're in a gap, after all), we can eat
                    // an end-cap message.

                        ASSERTGDI(we == WE_CLOSEFIGURE || we == WE_ENDFIGURE,
                                  "Unexpected event");

                        if (we == WE_ENDFIGURE)
                        {
                        // We need the first point in the figure:

                            vNextEvent();
                            ASSERTGDI(we == WE_FINISHFIGURE, "Expected finish fig");
                        }

                        vStyleNext(FALSE);
                        we = WE_FINISHFIGURE;
                        return;
                    }

                    efDoneLength  = FP_0_0;
                    efLineLength  = efWorldLength(pldOut->vecLine);
                    efRemainingLength = efLineLength;
                    ptfxLineStart = ptfxThis;
                }

                efRemainingLength -= efStyleLength;
                efDoneLength += efStyleLength;

                ptfxThis = ptfxFraction(ptfxLineStart, pldOut, efDoneLength, efLineLength);

                efStyleLength = efNextStyleLength();

                we = WE_STARTDASH;
                return;
            }
            else
            {
            // Handle a dash:

            // If you do a Rectangle(100, 100, 200, 200) with flat caps
            // and a world transform set, with a style array of
            // {100, 30}, I don't want it to wrap around a corner --
            // i.e., both perps for the start and end of the first dash
            // should be calculated from the vector (-100, 0), and NOT
            // have the start calculated from (-100, 0) and the end
            // from (0, 100)..

                if (efStyleLength > efRemainingLength)
                {
                    efStyleLength -= efRemainingLength;
                }
                else
                {
                    efRemainingLength -= efStyleLength;
                    efDoneLength += efStyleLength;

                    ptfxThis = ptfxFraction(ptfxLineStart, pldOut, efDoneLength, efLineLength);
                    pldIn = pldOut;

                    efStyleLength = efNextStyleLength();

                    we = WE_STOPDASH;
                    return;
                }
            }
        }

    // Okay, we're done with the current line (we've completely styled it),
    // so get the next one from the path:

        vNextEvent();

        switch(we)
        {
        case WE_STARTFIGURE:
            vResetStyles();
            efStyleLength = efNextStyleLength();

            efDoneLength  = FP_0_0;
            efLineLength  = efWorldLength(pldOut->vecLine);
            efRemainingLength = efLineLength;
            ptfxLineStart = ptfxThis;
            vStyleNext(TRUE);
            break;

        case WE_JOIN:
        case WE_BEZIERJOIN:
            efDoneLength = FP_0_0;
            efLineLength = efWorldLength(pldOut->vecLine);
            efRemainingLength = efLineLength;
            ptfxLineStart = ptfxThis;

            vStyleNext(TRUE);
            break;

        default:
            vStyleNext(FALSE);
        }
    }
}

/******************************Public*Routine******************************\
* WIDENER::vVecDrawCompute(ld)
*
* Computes the draw vector for 'ld'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vVecDrawCompute(LINEDATA& ld)
{
#ifdef DEBUG_WIDE
    ASSERTGDI(ld.vecTangent.x != 0 || ld.vecTangent.y != 0,
              "Can't compute draw vertex for zero vector");
#endif

    wpen.vDetermineDrawVertex(ld.vecTangent, ld);

    if (!ld.bInvert())
        ld.vecDraw     = *ld.pptfx;
    else
    {
        ld.vecDraw.x   = - ld.pptfx->x;
        ld.vecDraw.y   = - ld.pptfx->y;
    }

    ld.vSetVecDrawComputed();

    vVecSymmetricRound(&ld.vecDraw);
}

/******************************Public*Routine******************************\
* WIDENER::vVecPerpCompute(ld)
*
* Computes the perp vector for 'ld'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vVecPerpCompute(LINEDATA& ld)
{
    ASSERTGDI(ld.vecTangent.x != 0 || ld.vecTangent.y != 0,
              "Can't compute perp for zero vector");

    if (!ld.bVecDrawComputed())
        vVecDrawCompute(ld);

    ASSERTGDI(ld.fxCrossStart >= 0 && ld.fxCrossEnd >= 0, "-ve cross");

    LONGLONG aa = ld.fxCrossStart;
    LONGLONG bb = ld.fxCrossEnd;

    EVECTORFX vec;

    if (aa <= bb)
    {
        vec.x = ld.pptfx->x - (ld.pptfx - 1)->x;
        vec.y = ld.pptfx->y - (ld.pptfx - 1)->y;
    }
    else
    {
        vec.x = (ld.pptfx + 1)->x - ld.pptfx->x;
        vec.y = (ld.pptfx + 1)->y - ld.pptfx->y;
    }

    POINTFIX ptfxMid;

    ptfxMid.x = ld.pptfx->x - (vec.x >> 1);
    ptfxMid.y = ld.pptfx->y - (vec.y >> 1);

    LONGLONG x;
    LONGLONG y;

    LONGLONG fxDivisor = aa + bb;

    x = aa * ABS(vec.x);
    y = aa * ABS(vec.y);

// This is actually only an unsigned divide:

    ULONG ulXRemainder;
    ULONG ulYRemainder;

    if (fxDivisor != 0)
    {
        if (fxDivisor < ULONG_MAX)
        {
            VDIV(x, (ULONG) fxDivisor, &ulXRemainder);
            VDIV(y, (ULONG) fxDivisor, &ulYRemainder);
        }
        else
        {
            // When the numbers are this big, phooie on the rounding:

            ulXRemainder = 0;
            x /= fxDivisor;
            ulYRemainder = 0;
            y /= fxDivisor;
        }
    }
    else
    {
        ulXRemainder = 0;
        ulYRemainder = 0;
    }

// Now adjust the signs:

    FIX xPrime = (LONG) x;
    FIX yPrime = (LONG) y;

// This is a safe conversion because fxDivisor is always positive:

    ULONG ulHalfDivisor = (ULONG) fxDivisor;
    ulHalfDivisor >>= 1;

// Round:

    if (ulXRemainder >= ulHalfDivisor)
        xPrime++;
    if (ulYRemainder >= ulHalfDivisor)
        yPrime++;

// Give it the correct sign:

    if (vec.x < 0)
        xPrime = -xPrime;
    if (vec.y < 0)
        yPrime = -yPrime;

    ld.vecPerp.x = xPrime + ptfxMid.x;
    ld.vecPerp.y = yPrime + ptfxMid.y;

    if (ld.bInvert())
    {
        ld.vecPerp.x = -ld.vecPerp.x;
        ld.vecPerp.y = -ld.vecPerp.y;
    }

    ld.vSetVecPerpComputed();

// Rounds to half integer:

    vVecRound(&ld.vecPerp);
}

/******************************Public*Routine******************************\
* WIDENER::vVecSquareCompute(ld)
*
* Computes the square cap vector for 'ld'.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vVecSquareCompute(LINEDATA& ld)
{
    ASSERTGDI(ld.vecTangent.x != 0 || ld.vecTangent.y != 0,
              "Can't compute square vector for zero vector");

    EFLOAT efAlpha;
    EFLOAT efLength;

    efAlpha  = efHalfWidth;
    efLength = efWorldLength(ld.vecTangent);

    if (!efLength.bIsZero())
        efAlpha /= efLength;
    else
        efAlpha = FP_0_0;

    EFLOATEXT x(ld.vecTangent.x);
    EFLOATEXT y(ld.vecTangent.y);

    x *= efAlpha;
    y *= efAlpha;

// We can assert that these conversions won't fail because we already
// did bounds checking on the entire path.

    BOOL bRet1 = x.bEfToL(ld.vecSquare.x);
    BOOL bRet2 = y.bEfToL(ld.vecSquare.y);

    ASSERTGDI(bRet1 && bRet2, "Square vector out of bounds");

    ld.vSetVecSquareComputed();
}

/******************************Public*Routine******************************\
* bIs31Bits(fx)
*
* Returns TRUE if 'fx' is a 31-bit signed number (i.e., the upper 2 bits
* are the same).
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE BOOL bIs31Bits(FIX fx)
{
    return(fx < ((LONG) LONG_MAX >> 1) && fx > ((LONG) LONG_MIN >> 1));
}

/******************************Public*Routine******************************\
* bComputeIntersect(pvecA, pvecB, pvecC, pvecD, pvecIntersect)
*
* Computes the intersection of the rays defined by the given line segments.
* Returns FALSE if the computation overflows or if the intersection is
* outside the 31 bit space.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bComputeIntersect(
 PEVECTORFX pvecA,               // Start point of first line segment
 PEVECTORFX pvecB,               // Direction of first line segment
 PEVECTORFX pvecC,               // Start point of second line segment
 PEVECTORFX pvecD,               // Direction of second line segment
PEVECTORFX pvecIntersect)       // Resulting point of intersection
{
//
// The intersection is computed by:
//
//            (Cx - Ax)(-Dy) + (Cy - Ay)(Dx)
//  lambda =  ------------------------------
//            (Bx)(-Dy)      + (By)(Dx)
//
//  intersect = A + lambda * B
//

    EFLOAT efTerm1;
    EFLOAT efTerm2;
    EFLOAT efNum;
    EFLOAT efDenom;

// (Cx - Ax)(-Dy)

    efNum = (pvecC->x - pvecA->x);
    efTerm2 = -pvecD->y;
    efNum *= efTerm2;

// (Cy - Ay)(Dx)

    efTerm1 = (pvecC->y - pvecA->y);
    efTerm2 = pvecD->x;
    efTerm1 *= efTerm2;
    efNum += efTerm1;

// (Bx)(-Dy)

    efDenom = pvecB->x;
    efTerm2 = -pvecD->y;
    efDenom *= efTerm2;

// (By)(Dx)

    efTerm1 = pvecB->y;
    efTerm2 = pvecD->x;
    efTerm1 *= efTerm2;
    efDenom += efTerm1;

    if (efDenom.bIsZero())
        return(FALSE);

// lambda

    efNum /= efDenom;

//  lambda * B

    EVECTORFX lambdaB;

    efTerm1 = pvecB->x;
    efTerm2 = pvecB->y;

    efTerm1 *= efNum;
    efTerm2 *= efNum;

    if (!efTerm1.bEfToL(lambdaB.x) || !efTerm2.bEfToL(lambdaB.y) ||
        !bIs31Bits(lambdaB.x) || !bIs31Bits(lambdaB.y))
    {
        return(FALSE);
    }

// A + lambda * B

    pvecIntersect->x = pvecA->x + lambdaB.x;
    pvecIntersect->y = pvecA->y + lambdaB.y;

// Check for overflow:

    if (!bIs31Bits(pvecIntersect->x) || !bIs31Bits(pvecIntersect->y))
    {
        WARNING("Miter would fall outside device space\n");
        return(FALSE);
    }

    return(TRUE);
}


/******************************Public*Routine******************************\
* WIDENER::bMiterInLimit(vec)
*
* Determines if the resulting vector from the middle of the wideline to
* the outer corner would be within the specified miter limit.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDENER::bMiterInLimit(EVECTORFX vec)
{
// Note we change our local copy of 'vec':

    BOOL bRet = exoDeviceToWorld.bXform(&vec, (PVECTORL) &vec, 1);

    ASSERTGDI(bRet, "XForm failed");

// Now compute the square of the Cartesian length:

    EFLOAT x;
    EFLOAT y;

    x = vec.x;
    y = vec.y;

    x *= x;
    y *= y;

    x += y;

    return(x <= efHalfWidthMiterLimitSquared);
}

/******************************Public*Routine******************************\
* WIDENER:vAddRoundJoin(bBezierJoin)
*
* Adds a join.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vAddRoundJoin(BOOL bBezierJoin)
{
    BOOL bTurnLeft = bTurnLeftRandom(&pldIn->vecTangent, &pldOut->vecTangent);

    BOOL bInPerp = FALSE;
    BOOL bOutPerp = FALSE;

    if (!bAllRound())
    {
        if (!bBezierJoin)
        {
            bInPerp = TRUE;
            bOutPerp = TRUE;
        }
//      else
//      {
//          if (pldIn->bSamePenSection(ldStartTangent)
//           || pldIn->bSamePenSection(ldEndTangent))
//              bInPerp = TRUE;
//
//          if (pldOut->bSamePenSection(ldStartTangent)
//           || pldOut->bSamePenSection(ldEndTangent))
//              bOutPerp = TRUE;
//      }
    }

    EVECTORFX vecIn  = bInPerp  ? vecInPerp()  : vecInDraw();
    EVECTORFX vecOut = bOutPerp ? vecOutPerp() : vecOutDraw();

    vAddRight(vecIn);
    vAddLeft(vecIn);

    if (vecIn != vecOut)
    {
        COUNT cpt;

        if (bTurnLeft)
        {
            cpt = wpen.cptAddRound(*this, *pldIn, *pldOut, bTurnLeft, bInPerp, bOutPerp);
            vAddLeft();

            if (!bAllRound())
//            if ((cpt > 0 || bInPerp || bOutPerp) && bBezierJoin) // hmmm and not all round?
            {
                vAddLeft(vecOut);
                if (cpt > 0)
                    wpen.cptAddRound(*this, *pldOut, *pldIn, !bTurnLeft, bOutPerp, bInPerp);
                vAddLeft(vecIn);
                vAddLeft();
            }
        }
        else
        {
            cpt = wpen.cptAddRound(*this, *pldIn, *pldOut, bTurnLeft, bInPerp, bOutPerp);
            vAddRight();

            if (!bAllRound())
//            if ((cpt > 0 || bInPerp || bOutPerp) && bBezierJoin) // hmmm and not all round?
            {
                vAddRight(vecOut);
                if (cpt > 0)
                    wpen.cptAddRound(*this, *pldOut, *pldIn, !bTurnLeft, bOutPerp, bInPerp);
                vAddRight(vecIn);
                vAddRight();
            }
        }

        vAddRight(vecOut);
        vAddLeft(vecOut);
    }
}


/******************************Public*Routine******************************\
* WIDENER:vAddJoin(bBezierJoin)
*
* Adds a join.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vAddJoin(BOOL bBezierJoin)
{
    BOOL bTurnLeft;

    if (iJoin == JOIN_ROUND || bBezierJoin)
        vAddRoundJoin(bBezierJoin);
    else if (iJoin == JOIN_BEVEL)
    {
        bTurnLeft = bTurnLeftRandom(&pldIn->vecTangent, &pldOut->vecTangent);

        EVECTORFX vecIn  = vecInPerp();
        EVECTORFX vecOut = vecOutPerp();

        vAddLeft(vecIn);
        vAddRight(vecIn);

        if (vecIn != vecOut)
        {
            if (bTurnLeft)
                vAddLeft();
            else
                vAddRight();

            vAddRight(vecOut);
            vAddLeft(vecOut);
        }
    }
    else
    {
        ASSERTGDI(iJoin == JOIN_MITER, "Unexpected join type");

        bTurnLeft = bTurnLeftRandom(&pldIn->vecTangent, &pldOut->vecTangent);

    // Use the 'perpendicular' vector rather than the 'draw' vector here for
    // computing the intersection point.  This is done to be consistent:
    // if the same path is redrawn but with a different miter limit, we will
    // still light the same pels except on the joins that change between
    // mitered and beveled.

        EVECTORFX vecIn  = vecInPerp();
        EVECTORFX vecOut = vecOutPerp();

        vAddLeft(vecIn);
        vAddRight(vecIn);

        if (vecIn != vecOut)
        {
            EVECTORFX vecIntersect;

            if (bComputeIntersect(&vecIn, &pldIn->vecLine,
                                  &vecOut, &pldOut->vecLine,
                                  &vecIntersect))

                if (bMiterInLimit(vecIntersect))
                {
                    if (bTurnLeft)
                        vAddRight(vecIntersect);
                    else
                        vAddLeft(vecIntersect);
                }

            if (bTurnLeft)
                vAddLeft();
            else
                vAddRight();

            vAddLeft(vecOut);
            vAddRight(vecOut);
        }
    }
}

/******************************Public*Routine******************************\
* WIDENER::vAddEndCap()
*
* Adds an end-cap.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vAddEndCap()
{
    switch(iEndCap)
    {
    case ENDCAP_SQUARE:
        EVECTORFX vecRight;
        EVECTORFX vecLeft;

        vecRight = vecInSquare();
        vecLeft  = vecRight;

        vecRight += vecInPerp();
        vecLeft  -= vecInPerp();

        vAddRight(vecRight);
        vAddRight(vecLeft);
        break;

    case ENDCAP_BUTT:
	EVECTORFX vecInP;

        vecInP = vecInPerp();
        vAddRight(vecInP, FALSE);
        vAddRight(vecInP, TRUE);
        break;

    case ENDCAP_ROUND:
        EVECTORFX vec;

        if (bAllRound())
            vec = vecInDraw();
        else
            vec = vecInPerp();

        vAddRight(vec, FALSE);
        wpen.vAddRoundEndCap(*this, *pldIn, FALSE, bAllRound());
        vAddRight(vec, TRUE);
        break;

    default:
        RIP("Unknown cap type");
    }
}

/******************************Public*Routine******************************\
* WIDENER::vAddStartCap()
*
* Adds a start cap.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID WIDENER::vAddStartCap()
{
    switch(iEndCap)
    {
    case ENDCAP_SQUARE:
        {
            EVECTORFX vecRight = vecOutSquare();
            EVECTORFX vecLeft;

            vecRight.x = -vecRight.x;
            vecRight.y = -vecRight.y;

            vecLeft = vecRight;

            vecRight += vecOutPerp();
            vecLeft  -= vecOutPerp();

            vAddRight(vecLeft);
            vAddRight(vecRight);
        }
        break;

    case ENDCAP_BUTT:
        EVECTORFX vecOutP;

        vecOutP = vecOutPerp();
        vAddRight(vecOutP, TRUE);
        vAddRight(vecOutP, FALSE);
        break;

    case ENDCAP_ROUND:
        {
            EVECTORFX vec;

            if (bAllRound())
                vec = vecOutDraw();
            else
                vec = vecOutPerp();

            vAddRight(vec, TRUE);
            wpen.vAddRoundEndCap(*this, *pldOut, TRUE, bAllRound());
            vAddRight(vec, FALSE);
        }
        break;

    default:
        RIP("Unknown cap type");
    }
}

/******************************Public*Routine******************************\
* BOOL WIDENER::bWiden()
*
* Widens the path.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL WIDENER::bWiden()
{
    while(TRUE)
    {
        vNextStyleEvent();

        switch (we)
        {
        case WE_ZEROFIGURE:

        // If the entire figure is comprised of one point, output the
        // pen circle at that point if we have round caps (we can't handle
        // square caps because we have no idea of the intended direction):

            if (iEndCap == ENDCAP_ROUND)
            {
                if (!wpathRight.bBeginFigure())
                    return(FALSE);

                vAddStartCap();
                vAddEndCap();

            // Finish up:

                wpathRight.vEndFigure();
                wpathRight.vCloseFigure();
            }

            break;

        case WE_STARTFIGURE:
            if (!wpathLeft.bBeginFigure() || !wpathRight.bBeginFigure())
                return(FALSE);

            vFigureStyled(FALSE);
            wpathRight.vMarkFigureStart();
            break;

        case WE_JOIN:
            vAddJoin(FALSE);
            break;

        case WE_BEZIERJOIN:
            vAddJoin(TRUE);
            break;

        case WE_STARTDASH:
            if (!wpathLeft.bBeginFigure() || !wpathRight.bBeginFigure())
                return(FALSE);

            vAddStartCap();
            break;

        case WE_ENDFIGURE:
        case WE_STOPDASH:
            vAddEndCap();

        // Finish up:

            wpathLeft.vEndFigure();

            if (!bValid())
                return(FALSE);

            wpathRight.vReverseConcatenate(wpathLeft);
            wpathRight.vEndFigure();
            wpathRight.vCloseFigure();

            vFigureStyled(TRUE);   // We hit a style dash
            break;

        case WE_FINISHFIGURE:

        // Prepend the start cap to the beginning of the figure:

            if (!wpathRight.bBeginFigure())
                return(FALSE);

            vAddStartCap();
            wpathRight.vEndFigure();
            wpathRight.vPrependBeforeFigure();
            break;

        case WE_CLOSEFIGURE:

            vAddJoin(FALSE);
            wpathLeft.vEndFigure();

            if (!bFigureStyled())
            {
                wpathRight.vEndFigure();
                wpathRight.vCloseFigure();

                if (!wpathRight.bBeginFigure())
                    return(FALSE);

                wpathRight.vReverseConcatenate(wpathLeft);

                wpathRight.vEndFigure();
                wpathRight.vCloseFigure();
            }
            else
            {
                wpathRight.vEndFigure();
                if (!wpathRight.bBeginFigure())
                    return(FALSE);

                wpathRight.vReverseConcatenate(wpathLeft);
                wpathRight.vEndFigure();

                wpathRight.vPrependBeforeSubpath();
                wpathRight.vPrependBeforeFigure();
                wpathRight.vCloseFigure();
            }

            break;

        case WE_DONEPATH:
            return(bValid());

        default:
            RIP("Unknown widen event");
        }
    }

    RIP("Shouldn't get here");
    return(FALSE);
}

/******************************Public*Routine******************************\
* EPATHOBJ::vBecome(wpath)
*
* Free any data in our path, copy all the data from 'epo', and delete
* 'epo'.
*
* Our path can be a PATHMEMOBJ or PATHSTACKOBJ.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID EPATHOBJ::vBecome(WIDEPATHOBJ& wpath)
{
    ASSERTGDI(!(wpath.ppath->flType & PATHTYPE_STACK), "Can't do stacks");

// First, free all the path blocks in our destination path:

    vFreeBlocks();

// Now copy all the important stuff about the path from 'wpath', including
// the pointers to all its path data:

    cCurves         = wpath.cCurves;
    ppath->ppachain = wpath.ppath->ppachain;
    ppath->pprfirst = wpath.ppath->pprfirst;
    ppath->pprlast  = wpath.ppath->pprlast;

// The flags, ercfxBoundBox and ptfxCurrent fields should be the same for
// the widened result as they were for the spine, so don't copy them.

    ppath->flags    |= (PD_BEGINSUBPATH | PD_ENDSUBPATH);
    fl              &= ~(PO_BEZIERS | PO_ELLIPSE);

// Now delete the wpath path object:

    wpath.ppath->ppachain = (PATHALLOC*) NULL;
    wpath.vDelete();
}

/******************************Public*Routine******************************\
* WIDENER::vMakeItWide(epo)
*
* Replaces the path 'epo' with its widened result.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

INLINE VOID WIDENER::vMakeItWide(EPATHOBJ& epo)
{
    epo.vBecome(wpathRight);

// Recompute the total number of lines in the path:

    epo.cCurves = epo.cTotalCurves();
}

/******************************Public*Routine******************************\
* WIDENER::WIDENER(epo, exoWtoD, pla)
*
* Constructor for the widener.
*
* Coming in to here, we expect bounds checking to be already done via
* bComputeWidenedBounds(), so that we don't have to worry about over-
* flowing outside the 31 bit device space.
*
* History:
*  23-Oct-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

WIDENER::WIDENER(
EPATHOBJ&  epo,
EXFORMOBJ& exoWtoD,
PLINEATTRS pla)
: STYLER(epo, pla)
{
    ASSERTGDI(pla->fl & LA_GEOMETRIC, "Not a geometric line");
    ASSERTGDI(epo.bValid(), "Invalid path");
    ASSERTGDI(exoWtoD.bValid(), "Invalid xform");

// Bail out here if we failed to allocate any objects.  The caller must also
// call WIDENER::bValid() immediately after invoking the WIDENER constructor:

    if (!bValid())
        return;

    iEndCap = pla->iEndCap;
    iJoin   = pla->iJoin;

// Set 'AllRound' flag if we don't have to ever worry about perpendiculars
// looking funny:

    vAllRound((iJoin == JOIN_ROUND) &&
              (iEndCap == ENDCAP_ROUND || iEndCap == ENDCAP_SQUARE));

    EFLOATEXT efWidth(pla->elWidth.e);
    LONG lWidth;
    BOOL bRet;

    bRet = efWidth.bEfToL(lWidth);
    ASSERTGDI(bRet, "Unexpected width overflow");

    efHalfWidth = efWidth;
    efHalfWidth.vDivBy2();

// Set up for miter limit:

    if (iJoin == JOIN_MITER)
    {
    // Compute (PenWidth * MiterLimit / 2) ^ 2:

        efHalfWidthMiterLimitSquared = pla->eMiterLimit;
        efHalfWidthMiterLimitSquared *= efHalfWidth;

    // *= operator probably can't handle dest and src being the same:

        EFLOAT efTemp = efHalfWidthMiterLimitSquared;
        efHalfWidthMiterLimitSquared *= efTemp;
    }

// Current transform has to be invertible for doing styling or mitering
// (miter limit is specified in world space).  Square caps too.

    if (pla->pstyle != (PFLOAT_LONG) NULL ||
        iEndCap == ENDCAP_SQUARE || iJoin == JOIN_MITER)
    {
    // Compute inverse of the current transform:

        if (exoDeviceToWorld.bInverse(exoWtoD))
        {
        // Ensure that every vector between every point in the path
        // could be transformed to world space:

            EVECTORFX avec[2];

            avec[0].x = epo.rcfxBoundBox().xRight - epo.rcfxBoundBox().xLeft;
            avec[0].y = epo.rcfxBoundBox().yBottom - epo.rcfxBoundBox().yTop;
            avec[1].x = -avec[0].x;
            avec[1].y =  avec[0].y;

            if (!exoDeviceToWorld.bXform(avec, (PVECTORL) avec, 2))
                vSetError();

        }
        else
        {
            SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
            vSetError();
        }
    }

    if (!bValid())
        return;

// Do most of the work:

    if (!wpen.bPolygonizePen(exoWtoD, lWidth) ||
        !bWiden())
    {
        vSetError();
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::bWiden(epoSpine, exo, pla)
*
* Widens the specified path, overwriting the results of '*this'.
*
* History:
*  3-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bWiden(EPATHOBJ& epoSpine, XFORMOBJ* pxo, LINEATTRS* pla)
{
    WIDENER wid(epoSpine, *((EXFORMOBJ*) pxo), pla);

    BOOL bValid = wid.bValid();

    if (bValid)
        wid.vMakeItWide(*this);

    return(bValid);
}

/******************************Public*Routine******************************\
* EPATHOBJ::bComputeWidenedBounds(exo, pla)
*
* Adjusts the bounds of the path to allow for joins for geometric
* wide-lines.  We do this by transforming the bound box of the pen
* to device space and taking the corners as the extrema of the joins.
*
* For Miter joins, this is an even rougher guess since we assume we'll
* have the longest possible join allowed by the Miter limit.
*
* The values returned are the upper bounds if the path is to be widened
* (which is fine for pointer exclusion).
*
* FALSE is returned if any part of the widened result might fall outside
* the 31 bit device space.
*
* History:
*  3-Feb-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL EPATHOBJ::bComputeWidenedBounds(
EPATHOBJ& epoSpine,
XFORMOBJ  *pexo,
LINEATTRS *pla)
{
    ASSERTGDI(epoSpine.bValid(), "Not valid path");
    ASSERTGDI(bValid(), "Not valid path");
    ASSERTGDI(pla->fl & LA_GEOMETRIC, "Not geometric line");

    EFLOATEXT efWidth(pla->elWidth.e);
    LONG      lWidth;

    BOOL b = efWidth.bEfToL(lWidth);

    ASSERTGDI(b, "Width too large");
    ASSERTGDI(lWidth >= 0, "Negative pen radius");

    VECTORL avecl[2];

// We use the diameter and not the radius of the pen here because halving
// it in world space as an integer could possibly lose a lot of precision,
// and it's faster to call 'bXform' with an integer vector than an EFLOAT
// one:

    avecl[0].x =  lWidth;
    avecl[0].y =  lWidth;
    avecl[1].x =  lWidth;
    avecl[1].y = -lWidth;

    if (!((EXFORMOBJ*) pexo)->bXform(avecl, (PVECTORFX) avecl, 2))
        return(FALSE);

// Chop in half to get the maximums of the pen (we were using the diameter
// instead of the radius, remember?).  Add a pixel of slop too (remembering
// that there is rounding error, and vAddNice can increase the dimensions
// of the pen slightly):

    LONG xAdjust = (MAX(ABS(avecl[0].x), ABS(avecl[1].x)) >> 1) + LTOFX(1);
    LONG yAdjust = (MAX(ABS(avecl[0].y), ABS(avecl[1].y)) >> 1) + LTOFX(1);

// Account for square caps by multiplying by a coarse approximation to the
// square root of 2:

    if (pla->iEndCap == ENDCAP_SQUARE)
    {
        xAdjust += (xAdjust >> 1);
        yAdjust += (yAdjust >> 1);

    // Watch for overflow:

        if (!bIs31Bits(xAdjust) || !bIs31Bits(yAdjust))
            return(FALSE);
    }

// We know here that xAdjust and yAdjust have at most 31 bits significance.
// (Ok, so maybe we overflowed by adding 1).

    if (pla->iJoin == JOIN_MITER)
    {
        EFLOATEXT efMiterLimit(pla->eMiterLimit);

        ASSERTGDI(FP_1_0 <= efMiterLimit, "Miter limit less than one");

        EFLOATEXT ef(xAdjust);
        ef *= efMiterLimit;
        if (!ef.bEfToL(xAdjust))
            return(FALSE);

        ef = yAdjust;
        ef *= efMiterLimit;
        if (!ef.bEfToL(yAdjust))
            return(FALSE);

        if (!bIs31Bits(xAdjust) || !bIs31Bits(yAdjust))
            return(FALSE);
    }

    PATH *ppNew = ppath;
    PATH *ppOld = epoSpine.ppath;

    LONG xLeft   = ppOld->rcfxBoundBox.xLeft;
    LONG xRight  = ppOld->rcfxBoundBox.xRight;
    LONG yTop    = ppOld->rcfxBoundBox.yTop;
    LONG yBottom = ppOld->rcfxBoundBox.yBottom;

// Our widen code expects the coordinates to fix in a 27.4 space in order
// not to overflow (as guaranteed by the DDI spec, but not guaranteed by
// the code):

    if (!bIs31Bits(xLeft) || !bIs31Bits(xRight) ||
        !bIs31Bits(yTop)  || !bIs31Bits(yBottom))
    {
        return(FALSE);
    }

// Copy the bounds from the 'old' spine to the 'new' widened result,
// accounting for the resulting increase in size:

    xLeft   -= xAdjust;
    xRight  += xAdjust;
    yTop    -= yAdjust;
    yBottom += yAdjust;

// Make sure we the widened result doesn't fall outside the 31 bit space:

    if (!bIs31Bits(xLeft) || !bIs31Bits(xRight) ||
        !bIs31Bits(yTop)  || !bIs31Bits(yBottom))
    {
        return(FALSE);
    }

    ppNew->rcfxBoundBox.xLeft   = xLeft;
    ppNew->rcfxBoundBox.xRight  = xRight;
    ppNew->rcfxBoundBox.yTop    = yTop;
    ppNew->rcfxBoundBox.yBottom = yBottom;

    return(TRUE);
}


/******************************Public*Routine******************************\
* EPATHOBJ::vReComputeBounds()
*
* Updates the bounding rectangle, based on reading all the points in
* the path.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vReComputeBounds()
{
    ASSERTGDI(bValid(), "ReComputeWidenedBounds() in invalid path");

    PPATHREC ppr;

    if (ppath != (PPATH) NULL)
    {
        if (ppath->pprfirst != (PPATHREC) NULL)
        {
            ASSERTGDI(ppath->pprfirst->count > 0, "Shouldn't have empty pathrec");

            ppath->rcfxBoundBox.xLeft   = ppath->pprfirst->aptfx->x;
            ppath->rcfxBoundBox.yTop    = ppath->pprfirst->aptfx->y;
            ppath->rcfxBoundBox.xRight  = ppath->rcfxBoundBox.xLeft;
            ppath->rcfxBoundBox.yBottom = ppath->rcfxBoundBox.yTop;

            for (ppr = ppath->pprfirst; ppr != (PPATHREC) NULL; ppr = ppr->pprnext)
            {
                PPOINTFIX pptfx    = &ppr->aptfx[0];
                PPOINTFIX pptfxEnd = &ppr->aptfx[ppr->count];

                while (pptfx < pptfxEnd)
                    ((ERECTFX*) &ppath->rcfxBoundBox)->vInclude(*pptfx++);
            }
        }
        else
        {
            ppath->rcfxBoundBox.xLeft   = 0;
            ppath->rcfxBoundBox.yTop    = 0;
            ppath->rcfxBoundBox.xRight  = 0;
            ppath->rcfxBoundBox.yBottom = 0;
        }
    }
}

/******************************Public*Routine******************************\
* EPATHOBJ::vWidenSetupForFrameRgn(dco, cxPen, cyPen, pexo, pla)
*
* Initializes a LINEATTRS and EXFORMOBJ to be passed to bWiden to widen
* the path appropriately.  Used only for FrameRgn.
*
* The FrameRgn pen is elliptical in world space, whereas the Widen code
* expects it to be circular.  So we simply change the transform here.
*
* The FrameRgn ellipse may also have zero-length axis (unlike normal
* widened paths), so a flag must be set for that.
*
* History:
*  12-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID EPATHOBJ::vWidenSetupForFrameRgn(
XDCOBJ&     dco,     // Used to get current world transform
LONG       cxPen,   // x dimension of pen in world space
LONG       cyPen,   // y dimension of pen
EXFORMOBJ* pexo,    // Must be initialized via 'vInit(&mx, DONT_COMPUTE_FLAGS)'
LINEATTRS* pla)
{
    ASSERTGDI(pexo->bValid(), "Xform must be initialized");

// FrameRgn can have zero-width or zero-height brush dimensions:

    pla->fl          = LA_GEOMETRIC | LA_ALLOW_ZERO_DIMENSIONS;
    pla->iJoin       = JOIN_MITER;
    pla->iEndCap     = ENDCAP_ROUND;
    pla->eMiterLimit = dco.pdc->l_eMiterLimit();
    pla->pstyle      = (FLOAT_LONG*) NULL;
    pla->cstyle      = 0;

// We need to double the pen dimensions because half of the pen
// will draw outside the region, and will be clipped away:

    ASSERTGDI(cxPen >= 0 && cyPen >= 0, "Illegal pen dimension");
    cxPen *= 2;
    cyPen *= 2;

// Make our calculations a little more numerically stable:

    BOOL bAdjustX = FALSE;
    if (cxPen < cyPen)
    {
        register LONG lTmp;
        SWAPL(cxPen, cyPen, lTmp);
        bAdjustX = !bAdjustX;
    }

// Figure out the y-value normalizing factor that will make a square
// of dimensions [cxPen, cxPen] become a rectangle [cxPen, cyPen]:

    ASSERTGDI(cxPen >= cyPen, "");

    EFLOATEXT efX(cxPen);
    efX.vEfToF(pla->elWidth.e);

    EFLOATEXT efNormalize(cyPen);
    if (!efX.bIsZero())
        efNormalize /= efX;

// Now copy the world transform and modify it:

    pexo->vSet(&dco.pdc->mxWorldToDevice());

    if (bAdjustX)
    {
        pexo->efM11() *= efNormalize;
        pexo->efM12() *= efNormalize;
    }
    else
    {
        pexo->efM21() *= efNormalize;
        pexo->efM22() *= efNormalize;
    }

    pexo->vComputeAccelFlags();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pixelapi.cxx ===
/******************************Module*Header*******************************\
* Module Name: pixelapi.cxx
*
* This contains the functions that get/set individual pixels.
*
* Created: 25-Apr-1991 11:32:15
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* GreSetPixel
*
* API entry point for putting a single pixel on the screen.
*
* Returns: -1 if point not in clip rgn or for blt failure,
*           or the color put on the device surface for success.
*
* History:
*  Tue 17-May-1994 -by- Patrick Haluptzok [patrickh]
* update for size/perf and bug fix.
*
*  Thu  4-Mar-1992 -by- Kent Diamond [kentd]
* Pass in Attribute cache.
*
*  Thu 27-Feb-1992 -by- Patrick Haluptzok [patrickh]
* Fix RGB return.
*
*  Thu 05-Dec-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, optimize for size, add error code logging.
*
*  Fri 16-Aug-1991 -by- Patrick Haluptzok [patrickh]
* Bug fix, make it return -1 for blt failure, cleanup
*
*  20-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

DWORD APIENTRY NtGdiSetPixel(HDC hdcDst, int x, int y, COLORREF crColor)
{
    PAL_ULONG palul;

    palul.ul = 0xFFFFFFFF;

    XDCOBJ dcoDst(hdcDst);

    if (dcoDst.bValid()) 
    { 
        //
        // Transform the coordinates to device space.
        //

        EPOINTL eptlDst(x,y);
        EXFORMOBJ xoDst(dcoDst, WORLD_TO_DEVICE);
        xoDst.bXform(eptlDst);
        ERECTL erclDst(eptlDst.x,eptlDst.y,eptlDst.x+1,eptlDst.y+1);

        //
        // Accumulate bounds.  We can do this before knowing if the operation is
        // successful because bounds can be loose.
        //

        if (dcoDst.fjAccum())
            dcoDst.vAccumulate(erclDst);

        //
        // Check surface is included in DC.
        //

        if (dcoDst.bHasSurface())
        {
            //
            // Lock the device.
            //

            DEVLOCKOBJ dloTrg;

            if (dloTrg.bLock(dcoDst))
            {
                SURFACE *pSurfDst = dcoDst.pSurface();

                //
                // With a fixed DC origin we can change the destination to SCREEN coordinates.
                //

                erclDst += dcoDst.eptlOrigin();

                //
                // Parameter validation to avoid sticky overflow errors.
                // Note the validation is performed after the transform.
                // Any point that starts out in the invalid FIX zone may
                // potentially be transformed into the valid range and 
                // therefore should be plotted.
                // Any point that's had it's bottom right wrap will be also invalidated
                // by this check.
                // Use of BLTOFXOK is probably an overkill, but lower level code
                // could potentially do a FIX conversion.
                //

                if (!BLTOFXOK(erclDst.left)  ||
                    !BLTOFXOK(erclDst.right) ||
                    !BLTOFXOK(erclDst.top)   ||
                    !BLTOFXOK(erclDst.bottom))
                {
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);   

                    //                  
                    // XDCOBJ does not automagically clean up it's locks in 
                    // its destructor so we have do it explicitly here.
                    //

                    dcoDst.vUnlockFast();
                    return (DWORD)(GDI_ERROR);         //fail
                }
                ECLIPOBJ *pco = NULL;

                //
                // This is a pretty knarly expression to save a return in here.
                // Basically pco can be NULL if the rect is completely in the
                // cached rect in the DC or if we set up a clip object that isn't empty.
                //

                if (((erclDst.left   >= dcoDst.prclClip()->left) &&
                     (erclDst.right  <= dcoDst.prclClip()->right) &&
                     (erclDst.top    >= dcoDst.prclClip()->top) &&
                     (erclDst.bottom <= dcoDst.prclClip()->bottom)) ||
                    (pco = dcoDst.pco(),
                     pco->vSetup(dcoDst.prgnEffRao(), erclDst,CLIP_NOFORCETRIV),
                     !pco->erclExclude().bEmpty()))
                {
                    //
                    // Make a fake solid color brush for this guy.
                    //

                    XEPALOBJ  palDst(pSurfDst->ppal());
                    XEPALOBJ  palDstDC(dcoDst.ppal());
                    BBRUSHOBJ bo;
                    BOOL      bCMYKColor = dcoDst.pdc->bIsCMYKColor();

                    //
                    // Initialize BRUSHOBJ on stack.
                    //
                    bo.pvRbrush = (PVOID) NULL;
                    bo.flColorType = 0;

                    //
                    // if the in CMYK color mode, iSolidColor is CMYK color.
                    //
                    if (bCMYKColor)
                    {
                        bo.iSolidColor = crColor;
                        bo.flColorType = (BR_CMYKCOLOR | BR_HOST_ICM);

                        if (gbMultiMonMismatchColor)
                        {
                            bo.crRealized(crColor);
                            bo.crDCPalColor(crColor);
                        }
                    }
                    else
                    {
                        bo.iSolidColor = ulGetNearestIndexFromColorref(palDst, palDstDC, crColor);

                        if (dcoDst.pdc->bIsSoftwareICM())
                        {
                            bo.flColorType = BR_HOST_ICM;
                        }
                        else if (dcoDst.pdc->bIsDeviceICM())
                        {
                            bo.flColorType = BR_DEVICE_ICM;
                        }

                        if (gbMultiMonMismatchColor)
                        {
                            bo.crRealized(crColor);
                            bo.crDCPalColor(rgbFromColorref(palDst, palDstDC, crColor));
                        }
                    }

                    //
                    // Set up the correct return value.
                    //

                    DEVEXCLUDEOBJ dxo(dcoDst,&erclDst,pco);

                    INC_SURF_UNIQ(pSurfDst);

                    ULONG rop4 = gaMix[dcoDst.pdc->jROP2() & 0x0F];
                    rop4 |= (rop4 << 8);

                    if ((*(pSurfDst->pfnBitBlt()))
                              (
                                  pSurfDst->pSurfobj(),
                                  (SURFOBJ *) NULL,
                                  (SURFOBJ *) NULL,
                                  NULL,
                                  NULL,
                                  &erclDst,
                                  (POINTL *)  NULL,
                                  (POINTL *)  NULL,
                                  &bo,
                                  &dcoDst.pdc->ptlFillOrigin(),
                                  rop4
                              ))
                    {
                        if (bCMYKColor)
                        {
                            palul.ul = bo.iSolidColor;
                        }
                        else
                        {
                            palul.ul = ulIndexToRGB(palDst, palDstDC, bo.iSolidColor);
                        }
                    }
                }
            }
        }

        dcoDst.vUnlockFast();
    }
    else
    {
        WARNING1("ERROR GreSetPixel called on invalid DC\n");
    }

    return(palul.ul);
}

#if 0
/******************************Public*Routine******************************\
* EngGetPixel
*
* This facilitates GetPixel on DIBs.
*
* History:
*  27-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

ULONG EngGetPixel(
SURFACE *pSurfSrc,
PPOINTL  pptlSrc)
{
    ULONG ulReturn;
    PBYTE pjBits;
    LONG lDelta;

    ASSERTGDI(pSurfSrc != (PDIBOBJ) NULL, "ERROR GDI EngCopyBits");
    ASSERTGDI(pptlSrc != (PPOINTL) NULL, "ERROR GDI EngCopyBits");
    ASSERTGDI(pSurfSrc->iType() == STYPE_BITMAP, "ERROR GDI EngCopyBits");
    ASSERTGDI(pptlSrc->x < pSurfSrc->sizl().cx, "ERROR GDI EngCopyBits");
    ASSERTGDI(pptlSrc->y < pSurfSrc->sizl().cy, "ERROR GDI EngCopyBits");

    lDelta = pSurfSrc->lDelta();
    pjBits = (PBYTE) pSurfSrc->pvScan0();
    pjBits = pjBits + (lDelta * pptlSrc->y);

// Synchronize with the device driver before touching the device surface.

    {
        PDEVOBJ po(pSurfSrc->hdev());
        po.vSync(pSurfSrc,NULL,0);
    }

    switch(pSurfSrc->iFormat())
    {
    case BMF_1BPP:

    // Get the correct byte.
        ulReturn = (ULONG) *(pjBits + (pptlSrc->x >> 3));
    // Get the correct bit in the lowest bit.
        ulReturn = ulReturn >> (7 - (pptlSrc->x & 7));
    // Mask off the top bits.
        ulReturn = ulReturn & 1;
        break;

    case BMF_4BPP:

    // Get the correct byte.
        ulReturn = (ULONG) *(pjBits + (pptlSrc->x >> 1));

        if (pptlSrc->x & 1)
            ulReturn = ulReturn & 15;
        else
            ulReturn = ulReturn >> 4;

        ASSERTGDI(ulReturn < 16, "ERROR GDI EngCopyBits");
        break;

    case BMF_8BPP:

        ulReturn = (ULONG) *(pjBits + pptlSrc->x);
        break;

    case BMF_16BPP:

        ulReturn = (ULONG) *((PUSHORT) (pjBits + (pptlSrc->x << 1)));
        break;

    case BMF_24BPP:

        pjBits += (pptlSrc->x * 3);
        ulReturn = (ULONG) *(pjBits + 2);
        ulReturn <<= 8;
        ulReturn |= ((ULONG) *(pjBits + 1));
        ulReturn <<= 8;
        ulReturn |= ((ULONG) *pjBits);
        break;

    case BMF_32BPP:

        ulReturn = *((PULONG) (pjBits + (pptlSrc->x << 2)));
        break;

    default:
        RIP("ERROR GDI EngCopyBits1");
    }

    return(ulReturn);
}
#endif

/******************************Public*Routine******************************\
* GreGetPixel
*
* API entry point for getting a single pixel on the screen.
*
* Returns: -1 if point not in clip rgn or for blt failure,
*           the RGB color put on the device surface for success.
*
* History:
*  Tue 17-May-1994 -by- Patrick Haluptzok [patrickh]
* update for size/perf and bug fix.
*
*  Thu 27-Feb-1992 -by- Patrick Haluptzok [patrickh]
* Fix RGB return, remove unnecesary work.
*
*  22-Apr-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

DWORD NtGdiGetPixel(HDC hdc, int x, int y)
{
    //
    // Lock the destination and its transform.
    //

    DWORD iSolidColor = 0xFFFFFFFF;
    XDCOBJ dcoSrc(hdc);

    if (dcoSrc.bValid())
    {
        //
        // Lock the Rao region if we are drawing on a display surface.  The Rao
        // region might otherwise change asynchronously.  The DEVLOCKOBJ also makes
        // sure that the VisRgn is up to date, calling the window manager if
        // necessary to recompute it.  It also protects us from pSurfSrc
        // being changed asynchronously by a dynamic mode change.
        //

        DEVLOCKOBJ dlo;

        if (dlo.bLock(dcoSrc))
        {
            //
            // Check we can really do a GetPixel on this device.
            //

            SURFACE *pSurfSrc = dcoSrc.pSurface();

            if ((pSurfSrc != NULL) &&
                (pSurfSrc->bReadable() || UserScreenAccessCheck()))
            {
                EXFORMOBJ xoSrc(dcoSrc, WORLD_TO_DEVICE);

                //
                // Transform the coordinates to device space.
                //

                EPOINTL eptlSrc(x,y);

                xoSrc.bXform(eptlSrc);

                ERECTL erclSrc(eptlSrc.x,eptlSrc.y,eptlSrc.x+1,eptlSrc.y+1);

                //
                // Shift to Sreen Coordinates
                //

                erclSrc += dcoSrc.eptlOrigin();

                //
                // Parameter validation not necessary here. It seems
                // that if the +1 above wraps, the initialization of the
                // clip obj will catch it in this case.                
                //

                //
                // Compute the clipping complexity and maybe reduce the exclusion rectangle.
                //

                ECLIPOBJ co(dcoSrc.prgnEffRao(), erclSrc);

                //
                // Check the destination which is reduced by clipping.
                //

                if (!co.erclExclude().bEmpty())
                {
                    //
                    // Exclude the pointer.
                    //

                    DEVEXCLUDEOBJ dxo(dcoSrc,&erclSrc);

                    //
                    // Check target device color.
                    //

                    BOOL     bCMYKColor = dcoSrc.pdc->bIsCMYKColor();

                    #if 0
                    if (pSurfSrc->iType() == STYPE_BITMAP)
                    {
                    // We have a special function to quick get it.

                        iSolidColor = EngGetPixel(
                                            pSurfSrc,              // Source surface.
                                            (POINTL *) &erclSrc    // Source origin.
                                           );

                        if (!bCMYKColor)
                        {
                            iSolidColor = ulIndexToRGB(palSurf, palDC, iSolidColor);
                        }
                    }
                    else
                    #endif
                    {
                        iSolidColor = 0;

                        //
                        // Allocate up a temporary DIB.
                        //

                        DEVBITMAPINFO dbmi;
                        dbmi.cxBitmap = 1;
                        dbmi.cyBitmap = 1;
                        dbmi.hpal = (HPALETTE) 0;
                        dbmi.fl = BMF_TOPDOWN;

                        RECTL rclDst;

                        //
                        // To make sure the color falls into the lower
                        // bit/nibble/word, the destination rect is adjusted.
                        //

                        dbmi.iFormat = pSurfSrc->iFormat();

                        switch (dbmi.iFormat)
                        {
                        case BMF_1BPP:
                            rclDst.left   = 7;
                            rclDst.right  = 8;
                            break;
                        case BMF_4BPP:
                            rclDst.left   = 1;
                            rclDst.right  = 2;
                            break;
                        default:
                            rclDst.left   = 0;
                            rclDst.right  = 1;
                        }

                        SURFMEM SurfTempDIB;

                        if (SurfTempDIB.bCreateDIB(&dbmi, &iSolidColor))
                        {
                            rclDst.top    = 0;
                            rclDst.bottom = 1;

                            PDEVOBJ pdo(pSurfSrc->hdev());

                            if ((*PPFNGET(pdo, CopyBits, pSurfSrc->flags()))
                                                   (SurfTempDIB.pSurfobj(),
                                                    pSurfSrc->pSurfobj(),
                                                    (CLIPOBJ *) NULL,
                                                    &xloIdent,
                                                    &rclDst,
                                                    (POINTL *) &erclSrc))
                            {
                                if (!bCMYKColor)
                                {
                                    XEPALOBJ palDC(dcoSrc.ppal());
                                    XEPALOBJ palSurf(pSurfSrc->ppal());

                                    iSolidColor = ulIndexToRGB(palSurf, palDC, iSolidColor);
                                }
                            }
                        }
                    }
                }
            }
        }

        dcoSrc.vUnlockFast();

    }

    return(iSolidColor);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pattern.cxx ===
/******************************Module*Header*******************************\
* Module Name: pattern.cxx
*
* This contains the special case blting code for P, Pn, DPx and Dn rops
* with patterns.
*
* Created: 07-Mar-1992 13:12:58
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

ULONG aulLeftMask[] =
{
    0xFFFFFFFF,
    0xFFFFFF00,
    0xFFFF0000,
    0xFF000000
};

#define DBG_PAT_CPY 0

#if DBG_PAT_CPY
    ULONG   DbgPatCpy = 0;
#endif

/******************************Public*Routine******************************\
* vPatCpyRect8
*
* Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  25-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatCpyRect8(PATBLTFRAME *ppbf)
{
    FETCHFRAME  ff;
    ULONG      *pulTrg;
    ULONG       cLeft;
    ULONG       cRght;
    ULONG       iLeft;
    ULONG       iRght;
    ULONG       ulLeft;
    ULONG       ulRght;
    ULONG       yPat;
    LONG        yTrg;
    LONG        xLeft;
    LONG        yTop;
    BOOL        bSimple = FALSE;

    cLeft = ((RECTL *) ppbf->pvObj)->left * ppbf->cMul;
    cRght = ((RECTL *) ppbf->pvObj)->right * ppbf->cMul;

    iLeft = cLeft & 3;
    iRght = cRght & 3;

    ulLeft =  aulLeftMask[iLeft];
    ulRght = ~aulLeftMask[iRght];


    cLeft &= ~3;                        // Align to DWORD
    cRght &= ~3;                        // Align to DWORD


// Compute the correct starting point in the pattern:

    xLeft = cLeft - ppbf->xPat;
    if (xLeft < 0) 
        xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat); 
    else xLeft %= ppbf->cxPat;

    yTop = ((RECTL *) ppbf->pvObj)->top - ppbf->yPat;
    if (yTop < 0)
        yTop = (ppbf->cyPat-1) - ((-yTop-1) % ppbf->cyPat);
    else yTop %= ppbf->cyPat;



// If these are the same DWORD, then only one strip will be needed.
// Merge the two masks together and just do the left edge.

    if (cLeft == cRght)
    {
        ulLeft &= ulRght;
        bSimple = TRUE;
    }

// Lay down left edge, if needed.

    if (bSimple || (iLeft != 0))
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        yPat = yTop;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg = (*pulTrg & ~ulLeft) | (FETCHMISALIGNED(&ff) & ulLeft);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatCpyRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }

        if (bSimple)
            return;

        cLeft += sizeof(DWORD);         // Move to next DWORD
        xLeft += sizeof(DWORD);         // Move to next DWORD
    }

    ff.culFill = (cRght - cLeft) >> 2;

    // Lay down center stripe, if needed.

    if (ff.culFill != 0)
    {
        yPat = yTop;
        xLeft %= ppbf->cxPat;

        ff.pvTrg = (PVOID) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.cxPat = ppbf->cxPat;
        ff.xPat  = xLeft;

        ff.culWidth = ppbf->cxPat;

        if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
        {
            ff.culWidth >>= 2;

            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchAndCopy(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatCpyRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
            }
        }
        else
        {
            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchShiftAndCopy(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatCpyRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
                ff.xPat = xLeft;                // vFetchShift nukes this
            }
        }
    }

    // Lay down right edge, if needed.

    if (iRght != 0)
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cRght);
        yPat = yTop;

        xLeft += (ff.culFill * sizeof(DWORD));
        xLeft %= ppbf->cxPat;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg = (*pulTrg & ~ulRght) | (FETCHMISALIGNED(&ff) & ulRght);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatCpyRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }
    }
}

/******************************Public*Routine******************************\
* vPatNotRect8
*
* Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  25-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatNotRect8(PATBLTFRAME *ppbf)
{
    FETCHFRAME  ff;
    ULONG      *pulTrg;
    ULONG       cLeft;
    ULONG       cRght;
    ULONG       iLeft;
    ULONG       iRght;
    ULONG       ulLeft;
    ULONG       ulRght;
    ULONG       yPat;
    LONG        yTrg;
    LONG        xLeft;
    LONG        yTop;
    BOOL        bSimple = FALSE;

    cLeft = ((RECTL *) ppbf->pvObj)->left * ppbf->cMul;
    cRght = ((RECTL *) ppbf->pvObj)->right * ppbf->cMul;

    iLeft = cLeft & 3;
    iRght = cRght & 3;

    ulLeft =  aulLeftMask[iLeft];
    ulRght = ~aulLeftMask[iRght];

    cLeft &= ~3;                        // Align to DWORD
    cRght &= ~3;                        // Align to DWORD

// Compute the correct starting point in the pattern:

    xLeft = cLeft - ppbf->xPat;
    if (xLeft < 0)
        xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);
    else xLeft %= ppbf->cxPat;

    yTop = ((RECTL *) ppbf->pvObj)->top - ppbf->yPat;
    if (yTop < 0)
        yTop = (ppbf->cyPat-1) - ((-yTop-1) % ppbf->cyPat);
    else yTop %= ppbf->cyPat;

// If these are the same DWORD, then only one strip will be needed.
// Merge the two masks together and just do the left edge.

    if (cLeft == cRght)
    {
        ulLeft &= ulRght;
        bSimple = TRUE;
    }

    // Lay down left edge, if needed.

    if (bSimple || (iLeft != 0))
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        yPat = yTop;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg = (*pulTrg & ~ulLeft) | (~FETCHMISALIGNED(&ff) & ulLeft);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatNotRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }

        if (bSimple)
            return;

        cLeft += sizeof(DWORD);         // Move to next DWORD
        xLeft += sizeof(DWORD);         // Move to next DWORD
    }

    ff.culFill = (cRght - cLeft) >> 2;

    // Lay down center stripe, if needed.

    if (ff.culFill != 0)
    {
        yPat = yTop;
        xLeft %= ppbf->cxPat;

        ff.pvTrg = (PVOID) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.cxPat = ppbf->cxPat;
        ff.xPat  = xLeft;

        ff.culWidth = ppbf->cxPat;

        if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
        {
            ff.culWidth >>= 2;

            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchNotAndCopy(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatNotRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
            }
        }
        else
        {
            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchShiftNotAndCopy(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatNotRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
                ff.xPat = xLeft;                // vFetchShift nukes this
            }
        }
    }

    // Lay down right edge, if needed.

    if (iRght != 0)
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cRght);
        yPat   = yTop;

        xLeft += (ff.culFill * sizeof(DWORD));
        xLeft %= ppbf->cxPat;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg = (*pulTrg & ~ulRght) | (~FETCHMISALIGNED(&ff) & ulRght);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatNotRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }
    }
}

/******************************Public*Routine******************************\
* vPatXorRect8
*
* Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  25-Jan-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatXorRect8(PATBLTFRAME *ppbf)
{
    FETCHFRAME  ff;
    ULONG      *pulTrg;
    ULONG       cLeft;
    ULONG       cRght;
    ULONG       iLeft;
    ULONG       iRght;
    ULONG       ulLeft;
    ULONG       ulRght;
    ULONG       yPat;
    LONG        yTrg;
    LONG        xLeft;
    LONG        yTop;
    BOOL        bSimple = FALSE;

    cLeft = ((RECTL *) ppbf->pvObj)->left * ppbf->cMul;
    cRght = ((RECTL *) ppbf->pvObj)->right * ppbf->cMul;

    iLeft = cLeft & 3;
    iRght = cRght & 3;

    ulLeft =  aulLeftMask[iLeft];
    ulRght = ~aulLeftMask[iRght];

    cLeft &= ~3;                        // Align to DWORD
    cRght &= ~3;                        // Align to DWORD

// Compute the correct starting point in the pattern:

    xLeft = cLeft - ppbf->xPat;
    if (xLeft < 0)
        xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);
    else xLeft %= ppbf->cxPat;

    yTop = ((RECTL *) ppbf->pvObj)->top - ppbf->yPat;
    if (yTop < 0)
        yTop = (ppbf->cyPat-1) - ((-yTop-1) % ppbf->cyPat);
    else yTop %= ppbf->cyPat;

// If these are the same DWORD, then only one strip will be needed.
// Merge the two masks together and just do the left edge.

    if (cLeft == cRght)
    {
        ulLeft &= ulRght;
        bSimple = TRUE;
    }

    // Lay down left edge, if needed.

    if (bSimple || (iLeft != 0))
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        yPat = yTop;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg ^= (FETCHMISALIGNED(&ff) & ulLeft);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatXorRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }

        if (bSimple)
            return;

        cLeft += sizeof(DWORD);         // Move to next DWORD
        xLeft += sizeof(DWORD);         // Move to next DWORD
    }

    ff.culFill = (cRght - cLeft) >> 2;

    // Lay down center stripe, if needed.

    if (ff.culFill != 0)
    {
        yPat   = yTop;
        xLeft %= ppbf->cxPat;

        ff.pvTrg = (PVOID) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cLeft);
        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.cxPat = ppbf->cxPat;
        ff.xPat  = xLeft;

        ff.culWidth = ppbf->cxPat;

        if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
        {
            ff.culWidth >>= 2;

            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchAndMerge(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatXorRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
            }
        }
        else
        {
            for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
            {
                vFetchShiftAndMerge(&ff);

                yPat++;
                ASSERTGDI(yPat<=ppbf->cyPat, "vPatXorRect8: Reading past the end of the pattern.\n");
                if (yPat == ppbf->cyPat)
                {
                    ff.pvPat = ppbf->pvPat;
                    yPat = 0;
                }
                else
                    ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

                ff.pvTrg = (PVOID) ((BYTE *) ff.pvTrg + ppbf->lDeltaTrg);
                ff.xPat = xLeft;                // vFetchShift nukes this
            }
        }
    }

    // Lay down right edge, if needed.

    if (iRght != 0)
    {
        pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * ((RECTL *) ppbf->pvObj)->top + cRght);
        yPat = yTop;

        xLeft += (ff.culFill * sizeof(DWORD));
        xLeft %= ppbf->cxPat;

        ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yTop);
        ff.xPat  = xLeft;

        for (yTrg = ((RECTL *) ppbf->pvObj)->top; yTrg < ((RECTL *) ppbf->pvObj)->bottom; yTrg++)
        {
            *pulTrg ^= (FETCHMISALIGNED(&ff) & ulRght);

            yPat++;
            ASSERTGDI(yPat<=ppbf->cyPat, "vPatXorRect8: Reading past the end of the pattern.\n");
            if (yPat == ppbf->cyPat)
            {
                ff.pvPat = ppbf->pvPat;
                yPat = 0;
            }
            else
                ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

            pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
        }
    }
}

/******************************Public*Routine******************************\
* vPatCpyRow8
*
* Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  08-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatCpyRow8(
    PATBLTFRAME *ppbf,
    LONG yStart,
    INT crow)
{
    FETCHFRAME ff;
    ULONG     *pulTrg;
    ULONG     *pulTmp;
    ULONG      cLeft;
    ULONG      cRght;
    ULONG      iLeft;
    ULONG      iRght;
    ULONG      ulLeft;
    ULONG      ulRght;
    LONG       yPat;
    LONG       xLeft;
    PROW       prow = (PROW) ppbf->pvObj;

// Initialize the DDA

    pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * yStart);

// Compute the correct y starting point in the pattern:

    yPat = yStart - ppbf->yPat;
    if (yPat < 0)
        yPat = (ppbf->cyPat-1) - ((-yPat-1) % ppbf->cyPat);
    else yPat %= ppbf->cyPat;

    ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yPat);

    for (; crow; crow--, prow++)
    {
        cLeft = prow->left  * ppbf->cMul;
        cRght = prow->right * ppbf->cMul;

        iLeft = cLeft & 3;
        iRght = cRght & 3;

        ulLeft =  aulLeftMask[iLeft];
        ulRght = ~aulLeftMask[iRght];

        cLeft &= ~3;                // Align to DWORD
        cRght &= ~3;                // Align to DWORD

    // Calculate the correct x starting point in the pattern:

        xLeft = cLeft - ppbf->xPat;
        if (xLeft < 0)
            xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);

        else xLeft %= ppbf->cxPat;

        if (cLeft == cRght)
        {
            ulLeft &= ulRght;
            ff.xPat = xLeft;
            pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
           *pulTmp  = (*pulTmp & ~ulLeft) | (FETCHMISALIGNED(&ff) & ulLeft);
        }
        else
        {
        // Lay down left side, if needed.

            if (iLeft != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
                ff.xPat = xLeft;
               *pulTmp  = (*pulTmp & ~ulLeft) | (FETCHMISALIGNED(&ff) & ulLeft);

                cLeft += sizeof(DWORD);         // Move to next DWORD
                xLeft += sizeof(DWORD);         // Move to next DWORD
            }

        // Lay down center, if needed.

            ff.culFill = (cRght - cLeft) >> 2;

            if (ff.culFill != 0)
            {
                xLeft %= ppbf->cxPat;

                ff.pvTrg = (PVOID) ((BYTE *) pulTrg + cLeft);
                ff.cxPat = ppbf->cxPat;
                ff.xPat  = xLeft;

                ff.culWidth = ppbf->cxPat;

                if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
                {
                    ff.culWidth >>= 2;

                    vFetchAndCopy(&ff);
                }
                else
                    vFetchShiftAndCopy(&ff);
            }

        // Lay down right side, if needed.

            if (iRght != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cRght);
                ff.xPat = (xLeft + (ff.culFill * sizeof(DWORD))) % ppbf->cxPat;
               *pulTmp  = (*pulTmp & ~ulRght) | (FETCHMISALIGNED(&ff) & ulRght);
            }
        }

        yPat++;
        ASSERTGDI(yPat<=(LONG)ppbf->cyPat, "vPatCpyRow8: Reading past the end of the pattern.\n");
        if (yPat == (LONG) ppbf->cyPat)
        {
            ff.pvPat = ppbf->pvPat;
            yPat = 0;
        }
        else
            ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

        pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
    }
}

/******************************Public*Routine******************************\
* vPatNotRow8
*
* Tiles the NOT of a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
*   converted from traps to rows
*
*  08-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatNotRow8(
    PATBLTFRAME *ppbf,
    LONG yStart,
    INT crow)
{
    FETCHFRAME ff;
    ULONG     *pulTrg;
    ULONG     *pulTmp;
    ULONG      cLeft;
    ULONG      cRght;
    ULONG      iLeft;
    ULONG      iRght;
    ULONG      ulLeft;
    ULONG      ulRght;
    LONG       yPat;
    LONG       xLeft;
    PROW       prow = (PROW) ppbf->pvObj;

// Initialize the DDA

    pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * yStart);

// Compute the correct y starting point in the pattern:

    yPat = yStart - ppbf->yPat;
    if (yPat < 0)
        yPat = (ppbf->cyPat-1) - ((-yPat-1) % ppbf->cyPat);
    else yPat %= ppbf->cyPat;

    ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yPat);

    for (; crow; crow--, prow++)
    {
        cLeft = prow->left * ppbf->cMul;
        cRght = prow->right * ppbf->cMul;

        iLeft = cLeft & 3;
        iRght = cRght & 3;

        ulLeft =  aulLeftMask[iLeft];
        ulRght = ~aulLeftMask[iRght];

        cLeft &= ~3;                // Align to DWORD
        cRght &= ~3;                // Align to DWORD

    // Calculate the correct x starting point in the pattern:

        xLeft = cLeft - ppbf->xPat;
        if (xLeft < 0)
            xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);
        else xLeft %= ppbf->cxPat;

        if (cLeft == cRght)
        {
            ulLeft &= ulRght;
            ff.xPat = xLeft;
            pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
           *pulTmp  = (*pulTmp & ~ulLeft) | (FETCHMISALIGNED(&ff) & ulLeft);
        }
        else
        {
        // Lay down left side, if needed.

            if (iLeft != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
                ff.xPat = xLeft;
               *pulTmp  = (*pulTmp & ~ulLeft) | (~FETCHMISALIGNED(&ff) & ulLeft);

                cLeft += sizeof(DWORD);         // Move to next DWORD
                xLeft += sizeof(DWORD);         // Move to next DWORD
            }

        // Lay down center, if needed.

            ff.culFill = (cRght - cLeft) >> 2;

            if (ff.culFill != 0)
            {
                xLeft %= ppbf->cxPat;

                ff.pvTrg = (PVOID) ((BYTE *) pulTrg + cLeft);
                ff.cxPat = ppbf->cxPat;
                ff.xPat  = xLeft;

                ff.culWidth = ppbf->cxPat;

                if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
                {
                    ff.culWidth >>= 2;

                    vFetchNotAndCopy(&ff);
                }
                else
                    vFetchShiftNotAndCopy(&ff);
            }

        // Lay down right side, if needed.

            if (iRght != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cRght);
                ff.xPat = (xLeft + (ff.culFill * sizeof(DWORD))) % ppbf->cxPat;
               *pulTmp  = (*pulTmp & ~ulRght) | (~FETCHMISALIGNED(&ff) & ulRght);
            }
        }

        yPat++;
        ASSERTGDI(yPat<=(LONG)ppbf->cyPat, "vPatNotRow8: Reading past the end of the pattern.\n");
        if (yPat == (LONG) ppbf->cyPat)
        {
            ff.pvPat = ppbf->pvPat;
            yPat = 0;
        }
        else
            ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

        pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
    }
}

/******************************Public*Routine******************************\
* vPatXorRow8
*
* XOR Tiles a pattern to 8/16/24 and 32 bpp bitmaps
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
*   Converted from traps to rows
*
*  08-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPatXorRow8(
    PATBLTFRAME *ppbf,
    LONG yStart,
    INT crow)
{
    FETCHFRAME ff;
    ULONG     *pulTrg;
    ULONG     *pulTmp;
    ULONG      cLeft;
    ULONG      cRght;
    ULONG      iLeft;
    ULONG      iRght;
    ULONG      ulLeft;
    ULONG      ulRght;
    LONG       yPat;
    LONG       xLeft;
    PROW       prow = (PROW) ppbf->pvObj;

// Initialize the DDA

    pulTrg = (ULONG *) (((BYTE *) ppbf->pvTrg) + ppbf->lDeltaTrg * yStart);

// Compute the correct y starting point in the pattern:

    yPat = yStart - ppbf->yPat;
    if (yPat < 0)
        yPat = (ppbf->cyPat-1)  - ((-yPat-1)  % ppbf->cyPat);
    else yPat %= ppbf->cyPat;

    ff.pvPat = (PVOID) (((BYTE *) ppbf->pvPat) + ppbf->lDeltaPat * yPat);

    for (; crow; crow--, prow++)
    {
        cLeft = prow->left * ppbf->cMul;
        cRght = prow->right * ppbf->cMul;

        iLeft = cLeft & 3;
        iRght = cRght & 3;

        ulLeft =  aulLeftMask[iLeft];
        ulRght = ~aulLeftMask[iRght];

        cLeft &= ~3;                // Align to DWORD
        cRght &= ~3;                // Align to DWORD

    // Calculate the correct x starting point in the pattern:

        xLeft = cLeft - ppbf->xPat;
        if (xLeft < 0)
            xLeft = (ppbf->cxPat-1) - ((-xLeft-1) % ppbf->cxPat);
        else xLeft %= ppbf->cxPat;

        if (cLeft == cRght)
        {
            ulLeft &= ulRght;
            ff.xPat = xLeft;
            pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
           *pulTmp ^= (FETCHMISALIGNED(&ff) & ulLeft);
        }
        else
        {
        // Lay down left side, if needed.

            if (iLeft != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cLeft);
                ff.xPat = xLeft;
               *pulTmp ^= (FETCHMISALIGNED(&ff) & ulLeft);

                cLeft += sizeof(DWORD);         // Move to next DWORD
                xLeft += sizeof(DWORD);         // Move to next DWORD
            }

        // Lay down center, if needed.

            ff.culFill = (cRght - cLeft) >> 2;

            if (ff.culFill != 0)
            {
                xLeft %= ppbf->cxPat;

                ff.pvTrg = (PVOID) ((BYTE *) pulTrg + cLeft);
                ff.cxPat = ppbf->cxPat;
                ff.xPat  = xLeft;

                ff.culWidth = ppbf->cxPat;

                if (((xLeft & 3) == 0) && ((ff.culWidth & 3) == 0))
                {
                    ff.culWidth >>= 2;

                    vFetchAndMerge(&ff);
                }
                else
                    vFetchShiftAndMerge(&ff);
            }

        // Lay down right side, if needed.

            if (iRght != 0)
            {
                pulTmp  = (ULONG *) ((BYTE *) pulTrg + cRght);
                ff.xPat = (xLeft + (ff.culFill * sizeof(DWORD))) % ppbf->cxPat;
               *pulTmp ^= (FETCHMISALIGNED(&ff) & ulRght);
            }
        }

        yPat++;
        ASSERTGDI(yPat<=(LONG)ppbf->cyPat, "vPatXorRow8: Reading past the end of the pattern.\n");
        if (yPat == (LONG) ppbf->cyPat)
        {
            ff.pvPat = ppbf->pvPat;
            yPat = 0;
        }
        else
            ff.pvPat = (PVOID) ((BYTE *) ff.pvPat + ppbf->lDeltaPat);

        pulTrg = (ULONG *) (((BYTE *) pulTrg) + ppbf->lDeltaTrg);
    }
}



/******************************Public*Routine******************************\
* vPatternCopyLoopRow
*
* This is the inner loop of the 1 bpp and 4 bpp bitmap SrcCpy PatBlt-ing
* routines, this is were we finally write the DWORDs to the bitmap.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
*   Converted from rects to rows
*
*  19-2-93 checker
*       ported stephene's stuff
\**************************************************************************/

VOID vPatternCopyLoopRow(LONG lCurYTop, ULONG *pulTrg, PATBLTFRAME *ppbf,
    int ulFillType, ULONG ulRightPatMask, ULONG ulLeftPatMask,
    ULONG ulRightDestMask, ULONG ulLeftDestMask, LONG lMiddleDwords,
    PULONG pulBasePat)
{
    ULONG   *pulPatPtr;
    LONG    lMiddleBytes;
    ULONG   ulPattern;
    ULONG   ulRightDestMaskedPattern;
    ULONG   ulLeftDestMaskedPattern;

    lMiddleBytes = lMiddleDwords << 2;

    pulPatPtr = pulBasePat + ((lCurYTop - ppbf->yPat) & 0x07);

    // Set up the appropriately rotated version of the current pattern scan

    ulPattern = *pulPatPtr;

    // Draw all Y scans for this pattern byte

    switch(ulFillType)
    {
    case LEFT_MIDDLE_RIGHT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;

        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        RtlFillMemoryUlong (pulTrg+1, lMiddleBytes, ulPattern);
        *(pulTrg+lMiddleDwords+1) =
                (*(pulTrg+lMiddleDwords+1) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case LEFT_MIDDLE:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        RtlFillMemoryUlong (pulTrg+1, lMiddleBytes, ulPattern);
        break;

    case MIDDLE_RIGHT:
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;

        RtlFillMemoryUlong (pulTrg, lMiddleBytes, ulPattern);
        *(pulTrg+lMiddleDwords) =
                (*(pulTrg+lMiddleDwords) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case MIDDLE:
        RtlFillMemoryUlong (pulTrg, lMiddleBytes, ulPattern);
        break;

    case LEFT_MIDDLE_RIGHT_SHORT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;

        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        switch(lMiddleDwords)
        {
            case 9:
                *(pulTrg+9) = ulPattern;
            case 8:
                *(pulTrg+8) = ulPattern;
            case 7:
                *(pulTrg+7) = ulPattern;
            case 6:
                *(pulTrg+6) = ulPattern;
            case 5:
                *(pulTrg+5) = ulPattern;
            case 4:
                *(pulTrg+4) = ulPattern;
            case 3:
                *(pulTrg+3) = ulPattern;
            case 2:
                *(pulTrg+2) = ulPattern;
            case 1:
                *(pulTrg+1) = ulPattern;
                break;
        }
        *(pulTrg+lMiddleDwords+1) =
                (*(pulTrg+lMiddleDwords+1) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case LEFT_MIDDLE_SHORT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        switch(lMiddleDwords)
        {
            case 9:
                *(pulTrg+9) = ulPattern;
            case 8:
                *(pulTrg+8) = ulPattern;
            case 7:
                *(pulTrg+7) = ulPattern;
            case 6:
                *(pulTrg+6) = ulPattern;
            case 5:
                *(pulTrg+5) = ulPattern;
            case 4:
                *(pulTrg+4) = ulPattern;
            case 3:
                *(pulTrg+3) = ulPattern;
            case 2:
                *(pulTrg+2) = ulPattern;
            case 1:
                *(pulTrg+1) = ulPattern;
                break;
        }
        break;

    case MIDDLE_RIGHT_SHORT:
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
        switch(lMiddleDwords)
        {
            case 9:
                *(pulTrg+8) = ulPattern;
            case 8:
                *(pulTrg+7) = ulPattern;
            case 7:
                *(pulTrg+6) = ulPattern;
            case 6:
                *(pulTrg+5) = ulPattern;
            case 5:
                *(pulTrg+4) = ulPattern;
            case 4:
                *(pulTrg+3) = ulPattern;
            case 3:
                *(pulTrg+2) = ulPattern;
            case 2:
                *(pulTrg+1) = ulPattern;
            case 1:
                *(pulTrg) = ulPattern;
                break;
        }
        *(pulTrg+lMiddleDwords) =
                (*(pulTrg+lMiddleDwords) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case MIDDLE_SHORT:
        switch(lMiddleDwords)
        {
            case 9:
                *(pulTrg+8) = ulPattern;
            case 8:
                *(pulTrg+7) = ulPattern;
            case 7:
                *(pulTrg+6) = ulPattern;
            case 6:
                *(pulTrg+5) = ulPattern;
            case 5:
                *(pulTrg+4) = ulPattern;
            case 4:
                *(pulTrg+3) = ulPattern;
            case 3:
                *(pulTrg+2) = ulPattern;
            case 2:
                *(pulTrg+1) = ulPattern;
            case 1:
                *(pulTrg) = ulPattern;
                break;
        }
        break;

    case LEFT_RIGHT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        ulRightDestMaskedPattern = ulPattern & ulRightPatMask;

        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        *(pulTrg+1) = (*(pulTrg+1) & ulRightDestMask) |
                ulRightDestMaskedPattern;
        break;

    case LEFT:
        ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
        *pulTrg = (*pulTrg & ulLeftDestMask) |
                ulLeftDestMaskedPattern;
        break;
    }
}


/******************************Public*Routine******************************\
* vPatCpyRow4_8x8
*
* Tiles an 8x8 pattern to 4 bpp bitmaps, for SRCCOPY rasterop only.
* Fills however many rectangles are specified by crcl
* Assumes pattern bytes are contiguous (lDelta for pattern is 4).
* Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
* Assumes there is at least one rectangle to fill.
*
* History:
*  07-Nov-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

VOID vPatCpyRow4_8x8(PATBLTFRAME *ppbf, LONG yStart, INT crow)
{
    PULONG pulTrgBase;
    LONG lMiddleDwords;
    LONG lMiddleBytes;
    int ulFillType;
    ULONG ulLeftDestMask;
    ULONG ulRightDestMask;
    ULONG ulLeftPatMask;
    ULONG ulRightPatMask;
    UCHAR ucPatRotateRight;
    UCHAR ucPatRotateLeft;
    ULONG ulTemp;
    ULONG *pulPatMax;
    ULONG *pulBasePat;
    ULONG *pulTempSrc;
    ULONG *pulTempDst;
    ULONG ulAlignedPat[8];  // temp storage for rotated pattern
    static ULONG aulMask[8] = { 0, 0x000000F0, 0x000000FF, 0x0000F0FF,
                                0x0000FFFF, 0x00F0FFFF, 0x00FFFFFF, 0xF0FFFFFF};

// Point to list of rectangles to fill

    PROW prow = (PROW) ppbf->pvObj;

// Rotate the pattern if needed, storing in a temp buffer. This way we only
// rotate once, no matter how many fills we perform per call

    if (ppbf->xPat == 0)
    {
        pulBasePat = (ULONG *)ppbf->pvPat;  // no rotation; that's easy

    // Remember where the pattern ends, for wrapping

        pulPatMax = pulBasePat + 8;
    }
    else
    {

    // Set up the shifts to produce the rotation effect to align the pattern
    // as specified (the results of the two shifts are ORed together to emulate
    // the rotate, because C can't do rotations directly)

        ucPatRotateRight = (UCHAR) ppbf->xPat << 2;
        ucPatRotateLeft = (sizeof(ULONG) * 8) - ucPatRotateRight;
        pulTempSrc = (ULONG *)ppbf->pvPat;
        pulTempDst = ulAlignedPat;
        pulBasePat = pulTempDst;

    // Remember where the pattern ends, for wrapping

        pulPatMax = pulBasePat + 8;

        while (pulTempDst < pulPatMax)
        {

        // Go through this mess to convert to big endian, so we can rotate

            *(((UCHAR *)&ulTemp) + 3) = *(((UCHAR *)pulTempSrc) + 0);
            *(((UCHAR *)&ulTemp) + 2) = *(((UCHAR *)pulTempSrc) + 1);
            *(((UCHAR *)&ulTemp) + 1) = *(((UCHAR *)pulTempSrc) + 2);
            *(((UCHAR *)&ulTemp) + 0) = *(((UCHAR *)pulTempSrc) + 3);

        // Rotate the pattern into position

            ulTemp = (ulTemp >> ucPatRotateRight) |
                (ulTemp << ucPatRotateLeft);

        // Convert back to little endian, so we can store the pattern for
        // use in drawing

            *(((UCHAR *)pulTempDst) + 3) = *(((UCHAR *)&ulTemp) + 0);
            *(((UCHAR *)pulTempDst) + 2) = *(((UCHAR *)&ulTemp) + 1);
            *(((UCHAR *)pulTempDst) + 1) = *(((UCHAR *)&ulTemp) + 2);
            *(((UCHAR *)pulTempDst) + 0) = *(((UCHAR *)&ulTemp) + 3);

            pulTempSrc++;
            pulTempDst++;
        }
    }

    // advance to the first scan

    PBYTE pjBase = (BYTE *) ppbf->pvTrg + (ppbf->lDeltaTrg * yStart);

// Loop through all rectangles to fill

    do
    {

    // Set up AND/OR masks for partial-dword edges, for masking both the
    // pattern dword and the destination dword (the pattern and destination
    // masks are complementary). A solid dword is 0 for dest, -1 for pattern

        ulLeftDestMask = aulMask[prow->left & 0x07];
        ulLeftPatMask = ~ulLeftDestMask;

        if ((ulRightPatMask = aulMask[prow->right & 0x07]) == 0)
        {
            ulRightPatMask = 0xFFFFFFFF; // force solid to -1 for pattern
        }
        ulRightDestMask = ~ulRightPatMask;

    // Point to the first dword to fill

        pulTrgBase = (ULONG *) (pjBase + ((prow->left >> 1) & ~3));

    // Number of whole middle dwords/bytes to fill a dword at a time

        lMiddleDwords = (((LONG)(prow->right >> 1) & ~0x03) -
                (((LONG)(prow->left + 7) >> 1) & ~0x03)) >> 2;
        lMiddleBytes = lMiddleDwords << 2;

    // Set up for the appropriate fill, given partial dwords at edges and
    // narrow cases

        switch (lMiddleDwords + 1)
        {
        case 1:                         // left and right, but no middle, or
                                        // possibly just one, partial, dword
            if ((ulLeftDestMask != 0) && (ulRightDestMask != 0)) {
                // Left and right, but no middle
                ulFillType = LEFT_RIGHT;
                break;
            }

        // Note fallthrough in case where one of the masks is 0, meaning we
        // have a single, partial dword

        case 0:                         // just one, partial, dword, which
                                        // we'll treat as a left edge
            ulFillType = LEFT;
            ulLeftPatMask &= ulRightPatMask;
            ulLeftDestMask = ~ulLeftPatMask;
            break;

        case 2:                 // special case narrow cases, to avoid RTL
        case 3:                 // call overhead and REP STOSD startup overhead
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:

            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT_SHORT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT_SHORT;
                }
            }
            break;

        default:
            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT;
                }
            }
            break;
        }

        vPatternCopyLoopRow(yStart,pulTrgBase,ppbf,ulFillType,ulRightPatMask,
            ulLeftPatMask,ulRightDestMask,ulLeftDestMask,lMiddleDwords,
            pulBasePat);

    // Point to the next rectangle to fill, if there is one

        prow++;
        yStart++    ;
        pjBase += ppbf->lDeltaTrg;
    }
    while (--crow);
}

/******************************Public*Routine******************************\
* vPatCpyRect4_8x8
*
* Tiles an 8x8 pattern to 4 bpp bitmaps, for SRCCOPY rasterop only.
* Fills however many rectangles are specified by crcl
* Assumes pattern bytes are contiguous (lDelta for pattern is 4).
* Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
* Assumes there is at least one rectangle to fill.
*
* History:
*  07-Nov-1992 -by- Michael Abrash [mikeab]
* Wrote it.
\**************************************************************************/

VOID vPatCpyRect4_8x8(PATBLTFRAME *ppbf, INT crcl)
{

    PULONG pulTrgBase;
    PRECTL prcl;
    LONG lDelta;
    LONG lDeltaX8;
    LONG lMiddleDwords;
    LONG lMiddleBytes;
	int ulFillType;
    ULONG ulLeftDestMask;
    ULONG ulRightDestMask;
    ULONG ulLeftPatMask;
    ULONG ulRightPatMask;
    UCHAR ucPatRotateRight;
    UCHAR ucPatRotateLeft;
    ULONG ulTemp;
    ULONG *pulPatMax;
    ULONG *pulBasePat;
    ULONG *pulTempSrc;
    ULONG *pulTempDst;
    ULONG ulAlignedPat[8];  // temp storage for rotated pattern
    static ULONG aulMask[8] = { 0, 0x000000F0, 0x000000FF, 0x0000F0FF,
                                0x0000FFFF, 0x00F0FFFF, 0x00FFFFFF, 0xF0FFFFFF};

// Point to list of rectangles to fill

    prcl = (RECTL *) ppbf->pvObj;

// Offset to next scan, offset to every eighth scan

    lDeltaX8 = (lDelta = ppbf->lDeltaTrg) << 3;

// Rotate the pattern if needed, storing in a temp buffer. This way we only
// rotate once, no matter how many fills we perform per call

    if (ppbf->xPat == 0)
    {
        pulBasePat = (ULONG *)ppbf->pvPat;  // no rotation; that's easy

    // Remember where the pattern ends, for wrapping

        pulPatMax = pulBasePat + 8;
    }
    else
    {

    // Set up the shifts to produce the rotation effect to align the pattern
    // as specified (the results of the two shifts are ORed together to emulate
    // the rotate, because C can't do rotations directly)

        ucPatRotateRight = (UCHAR) ppbf->xPat << 2;
        ucPatRotateLeft = (sizeof(ULONG) * 8) - ucPatRotateRight;
        pulTempSrc = (ULONG *)ppbf->pvPat;
        pulTempDst = ulAlignedPat;
        pulBasePat = pulTempDst;

    // Remember where the pattern ends, for wrapping

        pulPatMax = pulBasePat + 8;

        while (pulTempDst < pulPatMax)
        {

        // Go through this mess to convert to big endian, so we can rotate

            *(((UCHAR *)&ulTemp) + 3) = *(((UCHAR *)pulTempSrc) + 0);
            *(((UCHAR *)&ulTemp) + 2) = *(((UCHAR *)pulTempSrc) + 1);
            *(((UCHAR *)&ulTemp) + 1) = *(((UCHAR *)pulTempSrc) + 2);
            *(((UCHAR *)&ulTemp) + 0) = *(((UCHAR *)pulTempSrc) + 3);

        // Rotate the pattern into position

            ulTemp = (ulTemp >> ucPatRotateRight) |
                (ulTemp << ucPatRotateLeft);

        // Convert back to little endian, so we can store the pattern for
        // use in drawing

            *(((UCHAR *)pulTempDst) + 3) = *(((UCHAR *)&ulTemp) + 0);
            *(((UCHAR *)pulTempDst) + 2) = *(((UCHAR *)&ulTemp) + 1);
            *(((UCHAR *)pulTempDst) + 1) = *(((UCHAR *)&ulTemp) + 2);
            *(((UCHAR *)pulTempDst) + 0) = *(((UCHAR *)&ulTemp) + 3);

            pulTempSrc++;
            pulTempDst++;
        }
    }


// Loop through all rectangles to fill

    do
    {

    // Set up AND/OR masks for partial-dword edges, for masking both the
    // pattern dword and the destination dword (the pattern and destination
    // masks are complementary). A solid dword is 0 for dest, -1 for pattern

        ulLeftDestMask = aulMask[prcl->left & 0x07];
        ulLeftPatMask = ~ulLeftDestMask;

        if ((ulRightPatMask = aulMask[prcl->right & 0x07]) == 0)
        {
            ulRightPatMask = 0xFFFFFFFF; // force solid to -1 for pattern
        }
        ulRightDestMask = ~ulRightPatMask;

    // Point to the first dword to fill

        pulTrgBase = (ULONG *) (((BYTE *) ppbf->pvTrg) +
                (ppbf->lDeltaTrg * prcl->top) + ((prcl->left >> 1) & ~3));

    // Number of whole middle dwords/bytes to fill a dword at a time

        lMiddleDwords = (((LONG)(prcl->right >> 1) & ~0x03) -
                (((LONG)(prcl->left + 7) >> 1) & ~0x03)) >> 2;
        lMiddleBytes = lMiddleDwords << 2;

    // Set up for the appropriate fill, given partial dwords at edges and
    // narrow cases

        switch (lMiddleDwords + 1)
        {
        case 1:                         // left and right, but no middle, or
                                        // possibly just one, partial, dword
            if ((ulLeftDestMask != 0) && (ulRightDestMask != 0)) {
                // Left and right, but no middle
                ulFillType = LEFT_RIGHT;
                break;
            }

        // Note fallthrough in case where one of the masks is 0, meaning we
        // have a single, partial dword

        case 0:                         // just one, partial, dword, which
                                        // we'll treat as a left edge
            ulFillType = LEFT;
            ulLeftPatMask &= ulRightPatMask;
            ulLeftDestMask = ~ulLeftPatMask;
            break;

        case 2:                 // special case narrow cases, to avoid RTL
        case 3:                 // call overhead and REP STOSD startup overhead
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:

            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT_SHORT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT_SHORT;
                }
            }
            break;

        default:
            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT;
                }
            }
            break;
        }

        vPatternCopyLoop(prcl,pulTrgBase,ppbf,ulFillType,ulRightPatMask,
            ulLeftPatMask,ulRightDestMask,ulLeftDestMask,lMiddleDwords,
            lDelta,lDeltaX8,pulBasePat,pulPatMax);

    // Point to the next rectangle to fill, if there is one

        prcl++;

    }
    while (--crcl);
}

/******************************Public*Routine******************************\
* vPatternCopyLoop
*
* This is the inner loop of the 1 bpp and 4 bpp bitmap SrcCpy PatBlt-ing
* routines, this is were we finally write the DWORDs to the bitmap.
*
* History:
*  19-2-93 checker
*       ported stephene's stuff
\**************************************************************************/

VOID vPatternCopyLoop( PRECTL prcl, ULONG *pulTrgBase, PATBLTFRAME *ppbf,
    int ulFillType, ULONG ulRightPatMask, ULONG ulLeftPatMask,
    ULONG ulRightDestMask, ULONG ulLeftDestMask, LONG lMiddleDwords,
    LONG lDelta, LONG lDeltaX8, PULONG pulBasePat, PULONG pulPatMax )
{
    ULONG   ulUniqueScans;
    LONG    lCurYTop;
    ULONG   *pulPatPtr;
    LONG    lMiddleBytes;
    ULONG   ulPattern;
    ULONG   ulNumScans;
    ULONG   *pulTrg;
    ULONG   ulRightDestMaskedPattern;
    ULONG   ulLeftDestMaskedPattern;


    lMiddleBytes = lMiddleDwords << 2;

    lCurYTop = prcl->top;
    pulPatPtr = pulBasePat + ((lCurYTop - ppbf->yPat) & 0x07);

    // Loop through up to all 8 pattern bytes, rotating into dword alignment,
    // generating the left and right masked versions, and drawing all lines
    // that use each pattern byte before proceeding to the next pattern byte

    // Do either all 8 pattern scans or the number of scans the fill is high,
    // whichever is less

    ulUniqueScans = 8;
    if ((prcl->bottom - prcl->top) < 8)
    {
        ulUniqueScans = prcl->bottom - prcl->top;
    }

    while (ulUniqueScans--)
    {

        // Point to scan to fill, then advance to next scan for next time

        pulTrg = pulTrgBase;
        pulTrgBase = (ULONG *)(((UCHAR *)pulTrgBase) + lDelta);

        // Set up the number of scans to fill with this pattern scan, given
        // that we'll do every eighth scan

        ulNumScans = (prcl->bottom - lCurYTop + 7) >> 3;
        lCurYTop++;     // we'll start on the next destination scan for the
                        //  next pattern scan

        // Set up the appropriately rotated version of the current pattern scan

        ulPattern = *pulPatPtr;


        // Advance the pattern pointer to the next pattern scan

        if (++pulPatPtr == pulPatMax)
        {
            pulPatPtr = pulBasePat;
        }

        // Draw all Y scans for this pattern byte

        switch(ulFillType)
        {
        case LEFT_MIDDLE_RIGHT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                RtlFillMemoryUlong (pulTrg+1, lMiddleBytes, ulPattern);
                *(pulTrg+lMiddleDwords+1) =
                        (*(pulTrg+lMiddleDwords+1) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT_MIDDLE:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                RtlFillMemoryUlong (pulTrg+1, lMiddleBytes, ulPattern);
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case MIDDLE_RIGHT:
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                RtlFillMemoryUlong (pulTrg, lMiddleBytes, ulPattern);
                *(pulTrg+lMiddleDwords) =
                        (*(pulTrg+lMiddleDwords) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case MIDDLE:
            do
            {
                RtlFillMemoryUlong (pulTrg, lMiddleBytes, ulPattern);
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT_MIDDLE_RIGHT_SHORT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                switch(lMiddleDwords)
                {
                    case 9:
                        *(pulTrg+9) = ulPattern;
                    case 8:
                        *(pulTrg+8) = ulPattern;
                    case 7:
                        *(pulTrg+7) = ulPattern;
                    case 6:
                        *(pulTrg+6) = ulPattern;
                    case 5:
                        *(pulTrg+5) = ulPattern;
                    case 4:
                        *(pulTrg+4) = ulPattern;
                    case 3:
                        *(pulTrg+3) = ulPattern;
                    case 2:
                        *(pulTrg+2) = ulPattern;
                    case 1:
                        *(pulTrg+1) = ulPattern;
                        break;
                }
                *(pulTrg+lMiddleDwords+1) =
                        (*(pulTrg+lMiddleDwords+1) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT_MIDDLE_SHORT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                switch(lMiddleDwords)
                {
                    case 9:
                        *(pulTrg+9) = ulPattern;
                    case 8:
                        *(pulTrg+8) = ulPattern;
                    case 7:
                        *(pulTrg+7) = ulPattern;
                    case 6:
                        *(pulTrg+6) = ulPattern;
                    case 5:
                        *(pulTrg+5) = ulPattern;
                    case 4:
                        *(pulTrg+4) = ulPattern;
                    case 3:
                        *(pulTrg+3) = ulPattern;
                    case 2:
                        *(pulTrg+2) = ulPattern;
                    case 1:
                        *(pulTrg+1) = ulPattern;
                        break;
                }
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case MIDDLE_RIGHT_SHORT:
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                switch(lMiddleDwords)
                {
                    case 9:
                        *(pulTrg+8) = ulPattern;
                    case 8:
                        *(pulTrg+7) = ulPattern;
                    case 7:
                        *(pulTrg+6) = ulPattern;
                    case 6:
                        *(pulTrg+5) = ulPattern;
                    case 5:
                        *(pulTrg+4) = ulPattern;
                    case 4:
                        *(pulTrg+3) = ulPattern;
                    case 3:
                        *(pulTrg+2) = ulPattern;
                    case 2:
                        *(pulTrg+1) = ulPattern;
                    case 1:
                        *(pulTrg) = ulPattern;
                        break;
                }
                *(pulTrg+lMiddleDwords) =
                        (*(pulTrg+lMiddleDwords) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case MIDDLE_SHORT:
            do
            {
                switch(lMiddleDwords)
                {
                    case 9:
                        *(pulTrg+8) = ulPattern;
                    case 8:
                        *(pulTrg+7) = ulPattern;
                    case 7:
                        *(pulTrg+6) = ulPattern;
                    case 6:
                        *(pulTrg+5) = ulPattern;
                    case 5:
                        *(pulTrg+4) = ulPattern;
                    case 4:
                        *(pulTrg+3) = ulPattern;
                    case 3:
                        *(pulTrg+2) = ulPattern;
                    case 2:
                        *(pulTrg+1) = ulPattern;
                    case 1:
                        *(pulTrg) = ulPattern;
                        break;
                }
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT_RIGHT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            ulRightDestMaskedPattern = ulPattern & ulRightPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                *(pulTrg+1) = (*(pulTrg+1) & ulRightDestMask) |
                        ulRightDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        case LEFT:
            ulLeftDestMaskedPattern = ulPattern & ulLeftPatMask;
            do
            {
                *pulTrg = (*pulTrg & ulLeftDestMask) |
                        ulLeftDestMaskedPattern;
                pulTrg = (ULONG *)(((UCHAR *)pulTrg) + lDeltaX8);
            } while (--ulNumScans);
            break;

        }
    }
}


/******************************Public*Routine******************************\
* vPatCpyRect1_8x8
*
* Tiles an 8x8 pattern to 1 bpp bitmaps, for SRCCOPY rasterop only.
* Fills however many rectangles are specified by crcl
* Assumes pattern bytes are contiguous (lDelta for pattern is 4).
* Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
* Assumes there is at least one rectangle to fill.
*
* History:
*  17-Nov-1992 -by- Stephen Estrop [StephenE]
* Wrote it.
\**************************************************************************/
VOID vPatCpyRect1_8x8(PATBLTFRAME *ppbf, INT crcl)
{
    PRECTL          prcl;
    ULONG           *pulTrgBase;
    int              ulFillType;
    ULONG           ulRightPatMask;
    ULONG           ulLeftPatMask;
    ULONG           ulRightDestMask;
    ULONG           ulLeftDestMask;
    LONG            lMiddleDwords;
    LONG            lDelta;
    LONG            lDeltaX8;
    ULONG           aulRotatedPat[8];

    UCHAR                   ucPatRotateRight;
    UCHAR                   ucPatRotateLeft;
    ULONG                   ulPattern;
    ULONG                   *pulPatPtr;
    ULONG                   *pulPatRot;
    ULONG                   *pulPatMax;
    extern ULONG            aulMsk[];    // Defined in solid.cxx

    //
    // Point to list of rectangles to fill
    //
    prcl = (RECTL *)ppbf->pvObj;

    //
    // Offset to next scan, offset to every eighth scan
    //
    lDeltaX8 = (lDelta = ppbf->lDeltaTrg) << 3;

    //
    // Loop through all rectangles to fill
    //
    do {
        //
        // Set up AND/OR masks for partial-dword edges, for masking both the
        // pattern dword and the destination dword (the pattern and destination
        // masks are complementary). A solid dword is 0 for dest, -1 for
        // pattern
        //
        ulLeftPatMask = aulMsk[prcl->left & 31];
        ulLeftDestMask = ~ulLeftPatMask;

        if ((ulRightDestMask = aulMsk[prcl->right & 31]) == 0xFFFFFFFF)
        {
            ulRightDestMask = 0x00; // force solid to -1 for pattern
        }
        ulRightPatMask = ~ulRightDestMask;

        //
        // Point to the first dword to fill
        //
        pulTrgBase = (ULONG *) (((BYTE *) ppbf->pvTrg) +
                     (ppbf->lDeltaTrg * prcl->top)) + (prcl->left >> 5);

        //
        // Number of whole middle dwords/bytes to fill a dword at a time
        //
        lMiddleDwords = (LONG)(prcl->right >> 5) -
                          ((LONG)(prcl->left + 31 ) >> 5);

        //
        // Set up for the appropriate fill, given partial dwords at edges and
        // narrow cases
        //
        switch (lMiddleDwords + 1)
        {
        case 1:                         // left and right, but no middle, or
                                        // possibly just one, partial, dword
            if ((ulLeftDestMask != 0) && (ulRightDestMask != 0)) {
                // Left and right, but no middle
                ulFillType = LEFT_RIGHT;
                break;
            }

        // Note fallthrough in case where one of the masks is 0, meaning we
        // have a single, partial dword

        case 0:                         // just one, partial, dword, which
                                        // we'll treat as a left edge
            ulFillType = LEFT;
            ulLeftPatMask &= ulRightPatMask;
            ulLeftDestMask = ~ulLeftPatMask;
            break;

        case 2:                 // special case narrow cases, to avoid RTL
        case 3:                 // call overhead and REP STOSD startup overhead
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:

            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT_SHORT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE_SHORT;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT_SHORT;
                }
            }
            break;

        default:
            if (ulLeftDestMask == 0)
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = MIDDLE;
                }
                else
                {
                    ulFillType = MIDDLE_RIGHT;
                }
            }
            else
            {
                if (ulRightDestMask == 0)
                {
                    ulFillType = LEFT_MIDDLE;
                }
                else
                {
                    ulFillType = LEFT_MIDDLE_RIGHT;
                }
            }
            break;
        }

        //
        // Set up the shifts to produce the rotation effect to align the
        // pattern as specified (the results of the two shifts are ORed
        // together to emulate the rotate, because C can't do rotations
        // directly)
        //
        ucPatRotateRight = (UCHAR) ppbf->xPat;
        ucPatRotateLeft  = (sizeof(ULONG) * 8) - ucPatRotateRight;

        //
        // Construct a replicated and aligned pattern.
        //
        pulPatPtr = (ULONG *)ppbf->pvPat,
        pulPatMax = (ULONG *)ppbf->pvPat + 8,
        pulPatRot = aulRotatedPat;

        while ( pulPatPtr < pulPatMax ) {

            //
            // Assume only the first 8 bits are good, so replicate these.
            //
            ulPattern  = *pulPatPtr++  >> 24;
            ulPattern |= ulPattern << 8;
            ulPattern |= ulPattern << 16;

            //
            // Rotate the pattern to align it correctly
            //
            if (ucPatRotateRight) {
                ulPattern = (ulPattern >> ucPatRotateRight) |
                            (ulPattern << ucPatRotateLeft);
            }
            *pulPatRot++ = ulPattern;
        }

        //
        // Do the PatBlt to this rectangle
        //

        pulPatMax = aulRotatedPat + 8;

        vPatternCopyLoop(prcl,pulTrgBase,ppbf,ulFillType,ulRightPatMask,
            ulLeftPatMask,ulRightDestMask,ulLeftDestMask,lMiddleDwords,
            lDelta,lDeltaX8,aulRotatedPat,pulPatMax);

        //
        // Point to the next rectangle to fill, if there is one
        //
        prcl++;

    }
    while (--crcl);

}

/******************************Public*Routine******************************\
* vPatCpyRect1_6x6
*
* Tiles an 6x6 pattern to 1 bpp bitmaps, for SRCCOPY rasterop only.
* Fills however many rectangles are specified by crcl
* Assumes pattern bytes are contiguous (lDelta for pattern is 8).
* Assumes pattern X and Y origin (xPat and yPat) are in the range 0-5.
* Assumes there is at least one rectangle to fill.
*
* History:
*  23-Nov-1992 -by- Stephen Estrop [StephenE]
* Wrote it.
*
\**************************************************************************/
VOID vPatCpyRect1_6x6(PATBLTFRAME *ppbf, INT crcl)
{
    UCHAR                   ucPatRotateRight;
    UCHAR                   ucPatRotateLeft;
    PRECTL                  prcl;

    /*
    ** lDelta is offset to the next scan in bytes, lDelta6 is the offset to
    ** the next repeated scan in bytes.
    */
    LONG                    lDelta;
    LONG                    lDelta6;

    /*
    ** pulTrgBase points to the first DWORD of the target rectangle in the
    ** bitmap.
    */
    ULONG                   *pulTrgBase;
    ULONG                   *pulTrg;
    ULONG                   *pulTrgStart; // ptr to first DWORD in scan

    /*
    ** The pattern repeats in the LCM of 32 and 6 bits, which is 96 bits or
    ** 3 Dwords.  We actually repeat the pattern into 4 Dwords, this makes it
    ** easier to handle the LEFT_MIDLLE and LEFT_MIDDLE_RIGHT cases.
    */
    ULONG                   aulPatternRepeat[4];

    ULONG                   ulLeftPatMask;
    ULONG                   ulLeftDestMask;
    ULONG                   ulLeftDestMaskedPattern;
    ULONG                   ulRightPatMask;
    ULONG                   ulRightDestMask;
    ULONG                   ulRightDestMaskedPattern;

    int ulFillType;

    LONG                    lMiddleBytes;
    LONG                    lMiddleDwords;
    LONG                    lMidDwords_div3;
    LONG                    lMidDwords_mod3;
    LONG                    lStartingDword;

    ULONG                   *pulPatSrc;
    ULONG                   *pulPatPtr;
    ULONG                   *pulPatMax;
    ULONG                   ulPattern;
    LONG                    lCurYTop;

    ULONG                   ulUniqueScans;
    ULONG                   ulNumScans;
    ULONG                   ulTemp;
    UCHAR                   *pucTemp = (UCHAR *)&ulTemp;

    LONG                    count;
    extern ULONG            aulMsk[];    // Defined in solid.cxx

    /*
    ** Point to list of rectangles to fill
    */
    prcl = (RECTL *)ppbf->pvObj;


    /*
    ** Offset to next scan, offset to every sixth scan
    */
    lDelta  = ppbf->lDeltaTrg;
    lDelta6 = lDelta * 6;


    /*
    ** Loop through all rectangles to fill
    */
    do {

        /*
        ** Set up AND/OR masks for partial-dword edges, for masking both the
        ** pattern dword and the destination dword (the pattern and destination
        ** masks are complementary). A solid dword is 0 for dest, -1 for
        ** pattern
        */
        ulLeftPatMask = aulMsk[prcl->left & 31];
        ulLeftDestMask = ~ulLeftPatMask;

        if ((ulRightDestMask = aulMsk[prcl->right & 31]) == 0xFFFFFFFF)
        {
            ulRightDestMask = 0x00; // force solid to -1 for pattern
        }
        ulRightPatMask = ~ulRightDestMask;

        /*
        ** Point to the first dword to fill
        */
        pulTrgBase = (ULONG *) (((BYTE *) ppbf->pvTrg) +
                     (ppbf->lDeltaTrg * prcl->top)) + (prcl->left >> 5);

        /*
        ** Number of whole middle dwords/bytes to fill a dword at a time
        */
        lMiddleDwords = (LONG)(prcl->right >> 5) -
                       ((LONG)(prcl->left + 31 ) >> 5);


        switch ( lMiddleDwords + 1 ) {

        case 1:
            if ( (ulLeftDestMask != 0) && (ulRightDestMask != 0) ) {
                /*
                ** left and right but no middle, or possible just one partial
                ** dword.
                */
                ulFillType = LEFT_RIGHT;
                break;
            }


        /*
        ** Note fall thru in case where one off the masks is 0, meaning that we
        ** have a single partial dword which we will treat as a LEFT fill type.
        */

        case 0:
            ulFillType = LEFT;
            ulLeftPatMask &= ulRightPatMask;
            ulLeftDestMask = ~ulLeftPatMask;
            break;


        /*
        ** Won't bother with short cases yet!
        */

        default:
            if ( ulLeftDestMask == 0 ) {
                if ( ulRightDestMask == 0 ) {
                    ulFillType = MIDDLE;
                }
                else {
                    ulFillType = MIDDLE_RIGHT;
                }
            }
            else {
                if ( ulRightDestMask == 0 ) {
                    ulFillType = LEFT_MIDDLE;
                }
                else {
                    /* most likely case ?? */
                    ulFillType = LEFT_MIDDLE_RIGHT;
                }
            }
        }


        /*
        ** Pre-calculate some inner loop constants
        **
        ** Set up the shifts to produce the rotation effect to align the
        ** pattern as specified (the results of the two shifts are ORed
        ** together to emulate the rotate, because C can't do rotations
        ** directly)
        */
        lCurYTop = prcl->top;

        /*
        ** Look for the case when (lCurYTop - ppbf->yPat) is less than zero.
        ** (Note: ppbf->yPat can only be in the range 0-5).  If we don't do
        ** this we could end up with a negative value being added to the
        ** pattern pointer.  What we really want here is a modulus operator
        ** (C only has a remainder operator), we cannot use the & operator
        ** to fake modulus because 6 is not a power of two.
        ** When (lCurYTop - ppbf->yPat) == 0 the pattern is already correctly
        ** aligned in the Y axis.
        */
        if ( count = lCurYTop - ppbf->yPat ) {

            count %= 6;
            count += 6;
            count %= 6;
            pulPatPtr = (ULONG *)ppbf->pvPat + (2 * count);

        } else {

            pulPatPtr = (ULONG *)ppbf->pvPat;
        }

        pulPatMax = (ULONG *)ppbf->pvPat + 12;

        lMidDwords_div3 = lMiddleDwords / 3;
        lMidDwords_mod3 = lMiddleDwords % 3;
        lMiddleBytes    = lMiddleDwords << 2;
        lStartingDword  = (prcl->left >> 5) % 3;

        ucPatRotateRight = (UCHAR)ppbf->xPat;
        ucPatRotateLeft  = 6 - ucPatRotateRight;


        ulUniqueScans = 6;
        if ( (prcl->bottom - prcl->top) < 6 ) {
            ulUniqueScans = prcl->bottom - prcl->top;
        }


        while ( ulUniqueScans-- ) {

            /*
            ** Point to the scan to fill then advance to the next scan for
            ** next time thru the loop.
            */
            pulTrgStart = pulTrg = pulTrgBase;
            pulTrgBase = (ULONG *)((PBYTE)pulTrgBase + lDelta);


            /*
            ** Set up the number of scans to fill with this pattern scan, given
            ** that we'll do every 6th scan.
            */
            ulNumScans = (prcl->bottom - lCurYTop + 5) / 6;
            lCurYTop++;


            /*
            ** Load the first 8 bits of the pattern in to *pucTemp and at the
            ** same time right justify the 6 bit pattern.
            */
            *pucTemp = *(UCHAR *)pulPatPtr >> 2;


            /*
            ** Horizontaly align the 6 bit pattern.
            */
            if ( ucPatRotateRight ) {
                ulPattern = (ULONG)((*pucTemp >> ucPatRotateRight) |
                                    (*pucTemp << ucPatRotateLeft)) & 0x3F;
            }
            else {
                ulPattern = (ULONG)*pucTemp;
            }


            pulPatSrc = aulPatternRepeat;

            /*
            ** Basically, we shift the pattern to correctly fill the 32 bit
            ** DWORD.  We then rearrange the bytes within the DWORD to account
            ** for little endianess.  I special case the LEFT fill type as it
            ** only requires 1 DWORDs worth of pattern it seems a little over
            ** the top to replicate 96 bits of pattern, this saving in
            ** execution time is at the expense of slightly larger code size.
            */
            if ( ulFillType == LEFT ) {

                /*
                ** Select the correct left edge from the 3 pattern DWORDs.
                */
                if( lStartingDword == 0 ) {

                    *pulPatSrc = ((ulPattern << 26) | (ulPattern << 20) |
                                  (ulPattern << 14) | (ulPattern <<  8) |
                                  (ulPattern <<  2) | (ulPattern >>  4));
                }
                else if( lStartingDword == 1 ) {

                    *pulPatSrc = ((ulPattern << 28) | (ulPattern << 22) |
                                  (ulPattern << 16) | (ulPattern << 10) |
                                  (ulPattern <<  4) | (ulPattern >>  2));
                }
                else {          // lStartingDword must be 2

                    *pulPatSrc = ((ulPattern << 30) | (ulPattern << 24) |
                                  (ulPattern << 18) | (ulPattern << 12) |
                                  (ulPattern <<  6) | (ulPattern      ));
                }

                *pucTemp     = *(((UCHAR *)pulPatSrc) + 3);
                *(pucTemp+1) = *(((UCHAR *)pulPatSrc) + 2);
                *(pucTemp+2) = *(((UCHAR *)pulPatSrc) + 1);
                *(pucTemp+3) = *(((UCHAR *)pulPatSrc));

                *pulPatSrc   = *((ULONG *)pucTemp);


                /*
                ** Draw all the Y scans for this pattern
                */
                ulLeftDestMaskedPattern = *aulPatternRepeat & ulLeftPatMask;
                do {
                    *pulTrg = (*pulTrg & ulLeftDestMask) | ulLeftDestMaskedPattern;
                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);
                } while ( --ulNumScans  );

            }

            /*
            ** Otherwise, we replicate the 6 bit pattern into a 96 bit pattern.
            ** We use the same pattern generating principle as that described
            ** above.
            */
            else {

                /*
                ** Pattern bits 0 - 31
                */
                *pulPatSrc   = ((ulPattern << 26) | (ulPattern << 20) |
                                (ulPattern << 14) | (ulPattern <<  8) |
                                (ulPattern <<  2) | (ulPattern >>  4));

                *pucTemp     = *(((UCHAR *)pulPatSrc) + 3);
                *(pucTemp+1) = *(((UCHAR *)pulPatSrc) + 2);
                *(pucTemp+2) = *(((UCHAR *)pulPatSrc) + 1);
                *(pucTemp+3) = *(((UCHAR *)pulPatSrc));

                *pulPatSrc++ = *((ULONG *)pucTemp);



                /*
                ** Pattern bits 32 - 63
                */
                *pulPatSrc   = ((ulPattern << 28) | (ulPattern << 22) |
                                (ulPattern << 16) | (ulPattern << 10) |
                                (ulPattern <<  4) | (ulPattern >>  2));

                *pucTemp     = *(((UCHAR *)pulPatSrc) + 3);
                *(pucTemp+1) = *(((UCHAR *)pulPatSrc) + 2);
                *(pucTemp+2) = *(((UCHAR *)pulPatSrc) + 1);
                *(pucTemp+3) = *(((UCHAR *)pulPatSrc));

                *pulPatSrc++ = *((ULONG *)pucTemp);



                /*
                ** Pattern bits 64 - 95
                */
                *pulPatSrc   = ((ulPattern << 30) | (ulPattern << 24) |
                                (ulPattern << 18) | (ulPattern << 12) |
                                (ulPattern <<  6) | (ulPattern      ));

                *pucTemp     = *(((UCHAR *)pulPatSrc) + 3);
                *(pucTemp+1) = *(((UCHAR *)pulPatSrc) + 2);
                *(pucTemp+2) = *(((UCHAR *)pulPatSrc) + 1);
                *(pucTemp+3) = *(((UCHAR *)pulPatSrc));

                *pulPatSrc++ = *((ULONG  *)pucTemp);


                /*
                ** Select the correct left edge from the 3 pattern DWORDs.
                ** A case of 0 means that we already have the correct edge
                ** of the pattern aligned.
                */
                if ( lStartingDword == 1 ) {

                    ulTemp                  = *aulPatternRepeat;
                    *aulPatternRepeat       = *(aulPatternRepeat + 1);
                    *(aulPatternRepeat + 1) = *(aulPatternRepeat + 2);
                    *(aulPatternRepeat + 2) = ulTemp;

                }
                else if ( lStartingDword == 2 ) {

                    ulTemp                  = *(aulPatternRepeat + 2);
                    *(aulPatternRepeat + 2) = *(aulPatternRepeat + 1);
                    *(aulPatternRepeat + 1) = *aulPatternRepeat;
                    *aulPatternRepeat       = ulTemp;

                }


                /*
                ** Finally the 4th DWORD is just a copy of the first.
                */
                *pulPatSrc = *aulPatternRepeat;
            }




            /*
            ** Draw all the Y scans for this pattern
            */
            switch ( ulFillType ) {

            /*
            ** We include this case to force the i386 compiler to use a
            ** jump table.
            */
            case LEFT:
                ulTemp = 0;
                break;


            case LEFT_RIGHT:
                ulLeftDestMaskedPattern = *aulPatternRepeat & ulLeftPatMask;
                ulRightDestMaskedPattern = *(aulPatternRepeat + 1) &
                                                ulRightPatMask;

                do {
                    *pulTrg = (*pulTrg & ulLeftDestMask) |
                                ulLeftDestMaskedPattern;
                    *(pulTrg + 1) = (*(pulTrg + 1) & ulRightDestMask) |
                                    ulRightDestMaskedPattern;

                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);

                } while ( --ulNumScans  );
                break;


            case LEFT_MIDDLE_RIGHT:
                ulLeftDestMaskedPattern = *aulPatternRepeat & ulLeftPatMask;
                ulRightDestMaskedPattern =
                    *(aulPatternRepeat + 1 + lMidDwords_mod3) & ulRightPatMask;

                /*
                ** Do the first LEFT edge
                */
                *pulTrg = (*pulTrg & ulLeftDestMask) | ulLeftDestMaskedPattern;

                /*
                ** Now do first CENTER stripe
                **
                ** Copy the 96 bit pattern as many times as will fit in the
                ** middle dword section.
                */
                for ( count = 0; count < lMidDwords_div3; count++ ) {

                    RtlCopyMemory( pulTrg + 1, aulPatternRepeat + 1, 12 );
                    pulTrg += 3;
                }


                /*
                ** Do any Dwords that got truncated
                */
                if ( lMidDwords_mod3 ) {
                    RtlCopyMemory( pulTrg + 1, aulPatternRepeat + 1,
                                   (UINT)(lMidDwords_mod3 << 2) );
                    pulTrg += lMidDwords_mod3;
                }


                /*
                ** Now do the first RIGHT edge
                */

                *(pulTrg + 1) = (*(pulTrg + 1) & ulRightDestMask) |
                                ulRightDestMaskedPattern;


                /*
                ** Now copy the previously drawn scan line into all common scans
                */
                pulTrg = (ULONG *)((PBYTE)pulTrgStart + lDelta6);
                while ( --ulNumScans ) {

                    *pulTrg = (*pulTrg & ulLeftDestMask) | ulLeftDestMaskedPattern;

                    RtlCopyMemory( pulTrg + 1, pulTrgStart + 1,
                                   (UINT)lMiddleBytes );

                    *(pulTrg + 1 + lMiddleDwords) =
                        (*(pulTrg + 1 + lMiddleDwords) & ulRightDestMask) |
                        ulRightDestMaskedPattern;

                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);
                }

                break;


            case LEFT_MIDDLE:
                ulLeftDestMaskedPattern = *aulPatternRepeat & ulLeftPatMask;

                /*
                ** Do the first LEFT edge
                */
                *pulTrg = (*pulTrg & ulLeftDestMask) | ulLeftDestMaskedPattern;


                /*
                ** Now do first CENTER stripe
                **
                ** Copy the 96 bit pattern as many times as will fit in the
                ** middle dword section.
                */
                for ( count = 0; count < lMidDwords_div3; count++ ) {

                    RtlCopyMemory( pulTrg + 1, aulPatternRepeat + 1, 12 );
                    pulTrg += 3;
                }


                /*
                ** Do any Dwords that got truncated
                */
                if ( lMidDwords_mod3 ) {
                    RtlCopyMemory( pulTrg + 1, aulPatternRepeat + 1,
                                   (UINT)(lMidDwords_mod3 << 2) );
                }


                /*
                ** Now copy the previously drawn scan line into all common scans
                */
                pulTrg = (ULONG *)((PBYTE)pulTrgStart + lDelta6);
                while ( --ulNumScans ) {

                    *pulTrg = (*pulTrg & ulLeftDestMask) |
                                ulLeftDestMaskedPattern;
                    RtlCopyMemory( pulTrg + 1, pulTrgStart + 1,
                                   (UINT)lMiddleBytes );

                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);
                }
                break;


            case MIDDLE:
                /*
                ** Copy the 96 bit pattern as many times as will fit in the
                ** middle dword section.
                */
                for ( count = 0; count < lMidDwords_div3; count++ ) {

                    RtlCopyMemory( pulTrg, aulPatternRepeat, 12 );
                    pulTrg += 3;
                }


                /*
                ** Do any Dwords that got truncated
                */
                if ( lMidDwords_mod3 ) {
                    RtlCopyMemory( pulTrg, aulPatternRepeat,
                                   (UINT)(lMidDwords_mod3 << 2) );
                }


                /*
                ** Now copy the previously drawn scan line into all common scans
                */
                pulTrg = (ULONG *)((PBYTE)pulTrgStart + lDelta6);
                while ( --ulNumScans ) {

                    RtlCopyMemory( pulTrg, pulTrgStart, (UINT)lMiddleBytes );
                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);
                }
                break;


            case MIDDLE_RIGHT:
                ulRightDestMaskedPattern =
                    *(aulPatternRepeat + lMidDwords_mod3) & ulRightPatMask;


                /*
                ** Copy the 96 bit pattern as many times as will fit in the
                ** middle dword section.
                */
                for ( count = 0; count < lMidDwords_div3; count++ ) {

                    RtlCopyMemory( pulTrg, aulPatternRepeat, 12 );
                    pulTrg += 3;
                }


                /*
                ** Do any Dwords that got truncated
                */
                if ( lMidDwords_mod3 ) {

                    RtlCopyMemory( pulTrg, aulPatternRepeat,
                                   (UINT)(lMidDwords_mod3 << 2) );
                    pulTrg += lMidDwords_mod3;
                }


                /*
                ** Now do the first RIGHT edge
                */
                *pulTrg = (*pulTrg & ulRightDestMask) |
                            ulRightDestMaskedPattern;


                /*
                ** Now copy the previously drawn scan line into all
                ** common scans
                */
                pulTrg = (ULONG *)((PBYTE)pulTrgStart + lDelta6);
                while ( --ulNumScans ) {

                    RtlCopyMemory( pulTrg, pulTrgStart, (UINT)lMiddleBytes );

                    *(pulTrg + lMiddleDwords) =
                        (*(pulTrg + lMiddleDwords) & ulRightDestMask) |
                            ulRightDestMaskedPattern;

                    pulTrg = (ULONG *)((PBYTE)pulTrg + lDelta6);

                }
                break;
            }

            /*
            ** Advance the pattern pointer for the next pattern scan
            */
            pulPatPtr += 2;
            if ( pulPatPtr == pulPatMax ) {
                pulPatPtr = (ULONG *)ppbf->pvPat;
            }
        }


        /*
        ** Point to the next rectangle to fill, if there is one
        */
        prcl++;

    }
    while (--crcl);

}



/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vPatCpyRect8_8x8
*
* Routine Description:
*
*   Tiles an 8x8 pattern to 8 bpp bitmaps, for SRCCOPY rasterop only.
*   Fills however many rectangles are specified by crcl
*   Assumes pattern bytes are contiguous.
*   Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
*   Assumes there is at least one rectangle to fill.
*
* NOTE: We will sometimes be passed empty rectangles!
*
* Arguments
*
*   ppbf    -   pointer to PATBLTFRAME pattern information
*   crcl    -   Rectangle count
*
* Returns
*
*   VOID, this functions may not fail
*
* History:
*  18-Oct-1993 -by- Mark Enstrom [marke]  - simplified for 8bpp
*  17-Nov-1992 -by- Reza Baghai [rezab]
* Adapted from vPatCpyRect4_8x8.
*
\**************************************************************************/
VOID vPatCpyRect8_8x8(PATBLTFRAME *ppbf, INT crcl)
{
    PULONG  pulTrg;
    PULONG  pulTrgTmp;
    LONG    lDeltaTrg8;
    ULONG   PatRotate;
    ULONG   PatRotateRight;
    ULONG   PatRotateLeft;
    PRECTL  prcl;
    LONG    lDeltaPat;
    ULONG   cyPatternTop;
    ULONG   cyVenetianTop;
    ULONG   cyVenetian;
    ULONG   ulPatternEven;
    ULONG   ulPatternOdd;
    ULONG   ulffPattern[2];
    ULONG   ulTmp;
    ULONG  *pulPat;
    ULONG  *pulPatMax;
    ULONG  *pulPatBase;
    ULONG   PatOffsetY;
    FETCHFRAME  ff;

    #if DBG_PAT_CPY

        if (DbgPatCpy >= 1) {
            DbgPrint("vPatCpyRect8_8x8   @ppbf = 0x%p   crcl = %li\n",ppbf,crcl);
            DbgPrint("pvTrg = 0x%p, pvPat = 0x%p\n",ppbf->pvTrg,ppbf->pvPat);
            DbgPrint("xPat = %li, yPat = %li\n",ppbf->xPat,ppbf->yPat);
        }

    #endif

    //
    // Point to list of rectangles to fill
    //

    prcl = (RECTL *) ppbf->pvObj;

    //
    // set up pattern access vars and rotation
    //

    pulPatBase = (ULONG *)ppbf->pvPat;

    PatRotate      = (ppbf->xPat & 7);
    PatRotateLeft  = (ppbf->xPat & 3);
    PatRotateRight = 4 - PatRotateLeft;

    //
    // mupliply by 8 to get byte shift values
    //

    PatRotateRight <<= 3;
    PatRotateLeft  <<= 3;

    //
    // Remember where the pattern ends, for wrapping
    //

    lDeltaPat = 12;
    pulPatMax = (ULONG *)(((BYTE *)pulPatBase) + (lDeltaPat << 3));


    #if DBG_PAT_CPY
        if (DbgPatCpy >= 2) {
            DbgPrint("  Pattern Base   = 0x%p\n",pulPatBase);
            DbgPrint("  Pattern Max    = 0x%p\n",pulPatMax);
            DbgPrint("  Pattern Delta  = 0x%lx\n",lDeltaPat);
            DbgPrint("  Pattern Rotate = 0x%lx\n",PatRotate);
        }
    #endif

    //
    // Loop through all rectangles to fill
    //

    do {

        //
        // are these gaurenteed to be well ordered rectangles?
        //
        //
        // set up begin and end cases as well as middle case for
        // each rect as well as wether to start on even or odd
        //

        #if DBG_PAT_CPY

            if (DbgPatCpy >= 1)
            {
                DbgPrint("  Fill Rect %li,%li to %li,%li\n",
                                prcl->left,
                                prcl->top,
                                prcl->right,
                                prcl->bottom
                                );
            }

        #endif

        LONG    cy = prcl->bottom - prcl->top;
        LONG    cx = prcl->right  - prcl->left;

        //
        // determine start and end cases for the entire rect
        //
        //
        // Simple start cases:          End cases:
        //
        //                          
        //          123   1            0        1
        //                          
        //                            
        //            23   2            01      2
        //                            
        //                              
        //              3   3            012    3
        //                              
        //
        // Start/end  combination
        //
        //          
        //          1       1 + 3
        //          
        //          
        //          12     1 + 4
        //          
        //            
        //            2     2 + 4
        //            
        //
        //

        LONG StartCase = prcl->left  & 0x03;
        LONG EndCase   = prcl->right & 0x03;
        LONG cxDword   = cx - EndCase - ((4-StartCase) & 0x03);

        if (cxDword < 0) {
            cxDword = 0;
        } else {
            cxDword >>= 2;
        }

        if (StartCase == 1)
        {
            if (cx == 1)
            {
                StartCase = 4;
                EndCase   = 0;
            } else if (cx == 2) {
                StartCase = 5;
                EndCase   = 0;
            }

        } else if (StartCase == 2)
        {
            if (cx == 1) {
            StartCase = 6;
            EndCase   = 0;
            }
        }

        //
        // calc the index for loading even and odd pattern DWORDS
        //

        LONG StartOffset    = (prcl->left  & 0x04) >> 2;
        LONG StartOffsetNot = (~StartOffset) & 0x01;

        //
        // calculate the DWORD address of pat scan line and
        // of the destination
        //

        PatOffsetY = (ULONG)((prcl->top - ppbf->yPat) & 0x07);

        pulPat = (PULONG)((PBYTE)pulPatBase + lDeltaPat * PatOffsetY);

        pulTrgTmp = (PULONG)(((PBYTE)ppbf->pvTrg                  +
                                     ppbf->lDeltaTrg * prcl->top  +
                                     (prcl->left & ~0x03)));

        //
        // The first 'cyPatternTop' scans of the pattern will each be tiled
        // 'cyVenetianTop' times into the destination rectangle.  Then, the
        // next '8 - cyPatternTop' scans of the pattern will each be tiled
        // 'cyVenetianTop - 1' times into the destination rectangle.
        //

        cyPatternTop  = (cy & 7);
        cyVenetianTop = (cy >> 3) + 1;

        //
        // lDeltaTrg8 is the offset for 8 Trg scan lines
        //

        lDeltaTrg8 = ppbf->lDeltaTrg << 3;


        #if DBG_PAT_CPY
            if (DbgPatCpy >= 2)
            {
                DbgPrint("  Start Case  = %li, EndCase = %li cxDword = %li\n",StartCase,EndCase,cxDword);
                DbgPrint("  StartOffset = %li\n",StartOffset);
                DbgPrint("  pulPat      = 0x%p\n",pulPat);
                DbgPrint("  Pat Y       = %li\n",PatOffsetY);
                DbgPrint("  pulTrg      = 0x%p\n",pulTrgTmp);
            }
        #endif

        //
        // for each scan line
        //

        ff.pvPat = (PVOID)&ulffPattern;
        ff.xPat  = 0;
        ff.cxPat = 8;
        ff.culWidth = 2;

        //
        // fill every eigth scan line at the same time.
        //

        if (cy > 8) {
            cy = 8;
        }

        while (cy--) {

            PULONG  pulScanTrg;
            ULONG   ulTmpPatEven;
            ULONG   ulTmpPatOdd;

            //
            // load up even and odd pat, rotate into dst alignment
            //

            if (ppbf->xPat == 0) {

                //
                // pattern is aligned
                //

                ulPatternEven = *(pulPat + StartOffset);
                ulPatternOdd  = *(pulPat + StartOffsetNot);

            } else {


                //
                // pattern must be rotated
                //

                ulTmpPatEven = *(pulPat);
                ulTmpPatOdd  = *(pulPat + 1);

                #if DBG_PAT_CPY
                    if (DbgPatCpy >= 2)
                    {
                        DbgPrint("  TmpPatEven    = 0x%lx\n",ulTmpPatEven);
                        DbgPrint("  TmpPatOdd     = 0x%lx\n",ulTmpPatOdd);
                    }
                #endif

                if (PatRotate < 4) {

                    ulPatternEven   = (ulTmpPatEven << PatRotateLeft)  |
                                      (ulTmpPatOdd  >> PatRotateRight);

                    ulPatternOdd    = (ulTmpPatOdd  << PatRotateLeft) |
                                      (ulTmpPatEven >> PatRotateRight);

                } else if (PatRotate == 4) {

                    ulPatternEven   = ulTmpPatOdd;
                    ulPatternOdd    = ulTmpPatEven;

                } else {

                    ulPatternEven   = (ulTmpPatEven >> PatRotateRight) |
                                      (ulTmpPatOdd  << PatRotateLeft);

                    ulPatternOdd    = (ulTmpPatOdd  >> PatRotateRight)  |
                                      (ulTmpPatEven << PatRotateLeft);

                }

                if (StartOffset != 0) {

                    //
                    // swap even and odd
                    //

                    ulTmpPatEven    = ulPatternEven;
                    ulPatternEven   = ulPatternOdd;
                    ulPatternOdd    = ulTmpPatEven;
                }
            }

            #if DBG_PAT_CPY

                if (DbgPatCpy >= 2)
                {
                    DbgPrint("  PatEven    = 0x%lx\n",ulPatternEven);
                    DbgPrint("  PatOdd     = 0x%lx\n",ulPatternOdd);
                }

            #endif

            pulScanTrg = pulTrgTmp;

            //
            // do every eighth scan line
            //

            if (cyPatternTop-- == 0)
                cyVenetianTop--;

            cyVenetian = cyVenetianTop;
            while (cyVenetian-- != 0) {

                ULONG   cxTmp = cxDword;

                //
                // pulTrg = beginning of next scan line
                //

                //
                // assign temp patterns
                //

                ulTmpPatEven = ulPatternEven;
                ulTmpPatOdd  = ulPatternOdd;

                pulTrg = pulScanTrg;

                if (StartCase != 0)
                {
                    switch (StartCase)
                    {
                    case 1:
                        *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                        *((PUSHORT)pulTrg+1) = (SHORT)(ulTmpPatEven >> 16);
                        break;
                    case 2:
                        *((PUSHORT)pulTrg+1) = (SHORT)(ulTmpPatEven >> 16);
                        break;
                    case 3:
                        *((PBYTE)pulTrg+3)   = (BYTE)(ulTmpPatEven  >> 24);
                        break;
                    case 4:
                        *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                        break;
                    case 5:
                        *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                        *((PBYTE)pulTrg+2)   = (BYTE)(ulTmpPatEven  >> 16);
                        break;
                    case 6:
                        *((PBYTE)pulTrg+2)   = (BYTE)(ulTmpPatEven  >> 16);
                        break;
                    }

                    pulTrg++;

                    //
                    // swap patterns
                    //

                    ulTmp = ulTmpPatEven;
                    ulTmpPatEven = ulTmpPatOdd;
                    ulTmpPatOdd  = ulTmp;
                }

                if (cxDword > 7) {

                    ulffPattern[0] = ulTmpPatEven;
                    ulffPattern[1] = ulTmpPatOdd;
                    ff.culFill = cxDword;
                    ff.pvTrg = (PVOID)pulTrg;
                    vFetchAndCopy(&ff);
                    pulTrg += cxDword;

                } else {

                    //
                    // dword pairs
                    //

                    while (cxTmp >= 2) {

                        *pulTrg     = ulTmpPatEven;
                        *(pulTrg+1) = ulTmpPatOdd;

                        pulTrg  += 2;
                        cxTmp -= 2;
                    }

                    //
                    // possible last dword
                    //

                    if (cxTmp) {
                        *pulTrg = ulTmpPatEven;
                        pulTrg++;
                    }

                }

                //
                // end case if needed
                //

                if (EndCase != 0) {

                    //
                    // if cxDword is odd then the patterns must be swapped
                    //

                    if (cxDword & 0x01) {
                        ulTmpPatEven = ulTmpPatOdd;
                    }


                    switch (EndCase) {
                    case 1:
                        *(PBYTE)pulTrg = (BYTE)ulTmpPatEven;
                        break;
                    case 2:
                        *(PUSHORT)pulTrg = (USHORT)ulTmpPatEven;
                        break;
                    case 3:
                        *(PUSHORT)pulTrg   = (USHORT)ulTmpPatEven;
                        *((PBYTE)pulTrg+2) = (BYTE)(ulTmpPatEven >> 16);
                        break;
                    }
                }

                pulScanTrg = (PULONG)((PBYTE)pulScanTrg + lDeltaTrg8);
            }

            //
            // inc dst and pat pointers
            //

            pulPat    = (PULONG)((PBYTE)pulPat + lDeltaPat);

            if (pulPat >= pulPatMax) {
                pulPat = pulPatBase;
            }

            pulTrgTmp = (PULONG)((PBYTE)pulTrgTmp + ppbf->lDeltaTrg);

        }

        prcl++;

    } while (--crcl);
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vPatCpyRow8_8x8
*
* Routine Description:
*
*   Tiles an 8x8 pattern to 8 bpp bitmaps, for SRCCOPY rasterop only.
*   Fills however many rectangles are specified by crcl
*   Assumes pattern bytes are contiguous.
*   Assumes pattern X and Y origin (xPat and yPat) are in the range 0-7.
*   Assumes there is at least one rectangle to fill.
*
* Arguments
*
*   ppbf    -   pointer to PATBLTFRAME pattern information
*   yStart  -   starting row, all following rows are consecutive
*   crow    -   number of rows
*
* Returns
*
*   VOID, this functions may not fail
*
* History:
*  08-Dec-1993 -by- Mark Enstrom [marke]
*
\**************************************************************************/
VOID vPatCpyRow8_8x8(PATBLTFRAME *ppbf, LONG yStart, INT crow)
{
    PULONG  pulTrg;
    PULONG  pulTrgTmp;
    PUCHAR  pjTrgScan;
    LONG    lDeltaTrg8;
    ULONG   PatRotate;
    ULONG   PatRotateRight;
    ULONG   PatRotateLeft;
    PROW    prow;
    LONG    lDeltaPat;
    ULONG   ulPatternEven;
    ULONG   ulPatternOdd;
    ULONG   ulffPattern[2];
    ULONG   ulTmp;
    ULONG  *pulPat;
    ULONG  *pulPatMax;
    ULONG  *pulPatBase;
    ULONG   PatOffsetY;
    FETCHFRAME  ff;

    #if DBG_PAT_CPY

        if (DbgPatCpy >= 1) {
            DbgPrint("vPatCpyRect8_8x8   @ppbf = 0x%p   crow = %li\n",ppbf,crow);
            DbgPrint("pvTrg = 0x%p, pvPat = 0x%p\n",ppbf->pvTrg,ppbf->pvPat);
            DbgPrint("xPat = %li, yPat = %li\n",ppbf->xPat,ppbf->yPat);
        }

    #endif

    //
    // Point to list of rows to fill
    //

    prow = (PROW) ppbf->pvObj;

    //
    // start row dst address
    //

    pjTrgScan = (PUCHAR)ppbf->pvTrg + ppbf->lDeltaTrg * yStart;

    //
    // start pattern offset
    //

    PatOffsetY = (ULONG)((yStart - ppbf->yPat) & 0x07);

    //
    // set up pattern access vars and rotation
    //

    pulPatBase = (ULONG *)ppbf->pvPat;

    PatRotate      = (ppbf->xPat & 7);
    PatRotateLeft  = (ppbf->xPat & 3);
    PatRotateRight = 4 - PatRotateLeft;

    //
    // mupliply by 8 to get byte shift values
    //

    PatRotateRight <<= 3;
    PatRotateLeft  <<= 3;

    //
    // lDelta for 8bpp 8x8 patterns is hard coded to 12
    //

    lDeltaPat = 12;

    //
    // Remember where the pattern starts and where the pattern ends for wrapping
    //

    pulPat     = (PULONG)((PBYTE)pulPatBase + lDeltaPat * PatOffsetY);
    pulPatMax  = (PULONG)(((PBYTE)pulPatBase) + (lDeltaPat << 3));

    #if DBG_PAT_CPY
        if (DbgPatCpy >= 2) {
            DbgPrint("  Pattern Base   = 0x%p\n",pulPatBase);
            DbgPrint("  Pattern Max    = 0x%p\n",pulPatMax);
            DbgPrint("  Pattern Delta  = 0x%lx\n",lDeltaPat);
            DbgPrint("  Pattern Rotate = 0x%lx\n",PatRotate);
        }
    #endif

    //
    // Loop through all rows to fill
    //

    do {

        //
        // set up begin and end cases as well as middle case for
        // each row as well as wether to start on even or odd
        //

        #if DBG_PAT_CPY

            if (DbgPatCpy >= 1)
            {
                DbgPrint("  Fill Row %li to %li\n",
                                prow->left,
                                prow->right
                                );
            }

        #endif

        LONG    cx = prow->right  - prow->left;

        //
        // determine start and end cases for the row
        //
        //
        // Simple start cases:          End cases:
        //
        //                          
        //          123   1            0        1
        //                          
        //                            
        //            23   2            01      2
        //                            
        //                              
        //              3   3            012    3
        //                              
        //
        // Start/end  combination
        //
        //          
        //          1       1 + 3
        //          
        //          
        //          12     1 + 4
        //          
        //            
        //            2     2 + 4
        //            
        //
        //

        LONG StartCase = prow->left  & 0x03;
        LONG EndCase   = prow->right & 0x03;
        LONG cxDword   = cx - EndCase - ((4-StartCase) & 0x03);

        if (cxDword < 0) {
            cxDword = 0;
        } else {
            cxDword >>= 2;
        }

        if (StartCase == 1)
        {
            if (cx == 1)
            {
                StartCase = 4;
                EndCase   = 0;
            } else if (cx == 2) {
                StartCase = 5;
                EndCase   = 0;
            }

        } else if (StartCase == 2)
        {
            if (cx == 1) {
            StartCase = 6;
            EndCase   = 0;
            }
        }

        //
        // calc the index for loading even and odd pattern DWORDS
        //

        LONG StartOffset    = (prow->left  & 0x04) >> 2;
        LONG StartOffsetNot = (~StartOffset) & 0x01;

        //
        // calculate the DWORD address of pat scan line and
        // of the destination
        //

        pulTrgTmp = (PULONG)(pjTrgScan + (prow->left & ~0x03));

        //
        // lDeltaTrg8 is the offset for 8 Trg scan lines
        //

        lDeltaTrg8 = ppbf->lDeltaTrg << 3;


        #if DBG_PAT_CPY
            if (DbgPatCpy >= 2)
            {
                DbgPrint("  Start Case  = %li, EndCase = %li cxDword = %li\n",StartCase,EndCase,cxDword);
                DbgPrint("  StartOffset = %li\n",StartOffset);
                DbgPrint("  pulPat      = 0x%p\n",pulPat);
                DbgPrint("  Pat Y       = %li\n",PatOffsetY);
                DbgPrint("  pulTrg      = 0x%p\n",pulTrgTmp);
            }
        #endif

        //
        // for each scan line
        //

        ff.pvPat = (PVOID)&ulffPattern;
        ff.xPat  = 0;
        ff.cxPat = 8;
        ff.culWidth = 2;

        PULONG  pulScanTrg;
        ULONG   ulTmpPatEven;
        ULONG   ulTmpPatOdd;

        //
        // load up even and odd pat, rotate into dst alignment
        //

        if (ppbf->xPat == 0) {

            //
            // pattern is aligned
            //

            ulPatternEven = *(pulPat + StartOffset);
            ulPatternOdd  = *(pulPat + StartOffsetNot);

        } else {


            //
            // pattern must be rotated
            //

            ulTmpPatEven = *(pulPat);
            ulTmpPatOdd  = *(pulPat + 1);

            #if DBG_PAT_CPY
                if (DbgPatCpy >= 2)
                {
                    DbgPrint("  TmpPatEven    = 0x%lx\n",ulTmpPatEven);
                    DbgPrint("  TmpPatOdd     = 0x%lx\n",ulTmpPatOdd);
                }
            #endif

            if (PatRotate < 4) {

                ulPatternEven   = (ulTmpPatEven << PatRotateLeft)  |
                                  (ulTmpPatOdd  >> PatRotateRight);

                ulPatternOdd    = (ulTmpPatOdd  << PatRotateLeft) |
                                  (ulTmpPatEven >> PatRotateRight);

            } else if (PatRotate == 4) {

                ulPatternEven   = ulTmpPatOdd;
                ulPatternOdd    = ulTmpPatEven;

            } else {

                ulPatternEven   = (ulTmpPatEven >> PatRotateRight) |
                                  (ulTmpPatOdd  << PatRotateLeft);

                ulPatternOdd    = (ulTmpPatOdd  >> PatRotateRight)  |
                                  (ulTmpPatEven << PatRotateLeft);

            }

            if (StartOffset != 0) {

                //
                // swap even and odd
                //

                ulTmpPatEven    = ulPatternEven;
                ulPatternEven   = ulPatternOdd;
                ulPatternOdd    = ulTmpPatEven;
            }
        }

        #if DBG_PAT_CPY

            if (DbgPatCpy >= 2)
            {
                DbgPrint("  PatEven    = 0x%lx\n",ulPatternEven);
                DbgPrint("  PatOdd     = 0x%lx\n",ulPatternOdd);
            }

        #endif

        pulScanTrg = pulTrgTmp;

        ULONG   cxTmp = cxDword;

        //
        // pulTrg = beginning of next scan line
        //

        //
        // assign temp patterns
        //

        ulTmpPatEven = ulPatternEven;
        ulTmpPatOdd  = ulPatternOdd;

        pulTrg = pulScanTrg;

        if (StartCase != 0)
        {
            switch (StartCase)
            {
            case 1:
                *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                *((PUSHORT)pulTrg+1) = (SHORT)(ulTmpPatEven >> 16);
                break;
            case 2:
                *((PUSHORT)pulTrg+1) = (SHORT)(ulTmpPatEven >> 16);
                break;
            case 3:
                *((PBYTE)pulTrg+3)   = (BYTE)(ulTmpPatEven  >> 24);
                break;
            case 4:
                *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                break;
            case 5:
                *((PBYTE)pulTrg+1)   = (BYTE)(ulTmpPatEven  >>  8);
                *((PBYTE)pulTrg+2)   = (BYTE)(ulTmpPatEven  >> 16);
                break;
            case 6:
                *((PBYTE)pulTrg+2)   = (BYTE)(ulTmpPatEven  >> 16);
                break;
            }

            pulTrg++;

            //
            // swap patterns
            //

            ulTmp = ulTmpPatEven;
            ulTmpPatEven = ulTmpPatOdd;
            ulTmpPatOdd  = ulTmp;
        }

        if (cxDword > 7) {

            ulffPattern[0] = ulTmpPatEven;
            ulffPattern[1] = ulTmpPatOdd;
            ff.culFill = cxDword;
            ff.pvTrg = (PVOID)pulTrg;
            vFetchAndCopy(&ff);
            pulTrg += cxDword;

        } else {

            //
            // dword pairs
            //

            while (cxTmp >= 2) {

                *pulTrg     = ulTmpPatEven;
                *(pulTrg+1) = ulTmpPatOdd;

                pulTrg  += 2;
                cxTmp -= 2;
            }

            //
            // possible last dword
            //

            if (cxTmp) {
                *pulTrg = ulTmpPatEven;
                pulTrg++;
            }

        }

        //
        // end case if needed
        //

        if (EndCase != 0) {

            //
            // if cxDword is odd then the patterns must be swapped
            //

            if (cxDword & 0x01) {
                ulTmpPatEven = ulTmpPatOdd;
            }


            switch (EndCase) {
            case 1:
                *(PBYTE)pulTrg = (BYTE)ulTmpPatEven;
                break;
            case 2:
                *(PUSHORT)pulTrg = (USHORT)ulTmpPatEven;
                break;
            case 3:
                *(PUSHORT)pulTrg   = (USHORT)ulTmpPatEven;
                *((PBYTE)pulTrg+2) = (BYTE)(ulTmpPatEven >> 16);
                break;
            }
        }

        //
        // inc dst and pat pointers
        //

        pulPat    = (PULONG)((PBYTE)pulPat + lDeltaPat);

        if (pulPat >= pulPatMax) {
            pulPat = pulPatBase;
        }

        pjTrgScan = pjTrgScan + ppbf->lDeltaTrg;

        prow++;

    } while (--crow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pixelfmt.cxx ===
/******************************Module*Header*******************************\
* Module Name: pixelfmt.cxx
*
* This contains the pixel format functions.
*
* Created: 21-Sep-1993
* Author: Hock San Lee [hockl]
*
* 02-Nov-1995 -by- Drew Bliss [drewb]
* Restored in kernel mode in minimal form
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// Number of generic pixel formats.  There are 5 pixel depths (4,8,16,24,32).
// See GreDescribePixelFormat for details.

#define MIN_GENERIC_PFD  1
#define MAX_GENERIC_PFD  24

/******************************Public*Routine******************************\
* LONG XDCOBJ::ipfdDevMaxGet()
*
* Initialize and return the maximum device supported pixel format index.
*
* The ipfdDevMax is set to -1 initially but is set to 0 or the maximum
* device pixel format index here.  This function should be called at most
* once for the given DC.
*
* History:
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

LONG XDCOBJ::ipfdDevMaxGet()
{
    PDEVOBJ pdo(hdev());
    int ipfd = 0;

    DEVLOCKOBJ dlo(pdo);

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              hdev(), (RECTL) pdc->erclWindow(), NULL);

        if (hdevDevice)
        {
            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if (PPFNVALID(pdo, DescribePixelFormat))
    {
        ipfd = (*PPFNDRV(pdo, DescribePixelFormat))(pdo.dhpdev(), 1, 0, NULL);

        if (ipfd < 0)
        {
            ipfd = 0;
        }
    }

    ipfdDevMax((SHORT)ipfd);

    return ipfd;
}

/******************************Public*Routine******************************\
* GreDescribePixelFormat
*
* Request pixel format information from a driver
* If cjpfd is 0, just return the maximum driver pixel format index.
*
* Returns: 0 if error; maximum driver pixel format index otherwise
*
* History:
*  02-Nov-95                    -by-    Drew Bliss      [drewb]
* Stripped down to driver-only support for kernel-mode
*  Mon Apr 25 15:34:32 1994     -by-    Hock San Lee    [hockl]
* Added 16-bit Z buffer formats and removed double buffered formats for bitmaps.
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int GreDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                           PPIXELFORMATDESCRIPTOR ppfd)
{
// Validate DC.

    DCOBJ dco(hdc);
    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    int ipfdDevMax = dco.ipfdDevMax();

// If cjpfd is 0, just return the maximum pixel format index.

    if (cjpfd == 0)
        return ipfdDevMax;

// Validate the size of the pixel format descriptor.

    if (cjpfd < sizeof(PIXELFORMATDESCRIPTOR))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

// Validate pixel format index.
// If a driver support device pixel formats 1..ipfdDevMax, the generic
// pixel formats will be (ipfdDevMax+1)..(ipfdDevMax+MAX_GENERIC_PFD).
// Otherwise, ipfdDevMax is 0 and the generic pixel formats are
// 1..MAX_GENERIC_PFD.

    if ((ipfd < 1) || (ipfd > ipfdDevMax))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(0);
    }

    PDEVOBJ po(dco.hdev());

    DEVLOCKOBJ dlo(po);

#ifdef OPENGL_MM

    if (po.bMetaDriver())
    {
        //  We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), NULL);

        if (hdevDevice)
        {
            // replace meta pdevobj with device specific hdev.

            po.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    int iRet = 0;

    if (PPFNVALID(po, DescribePixelFormat))
    {
        iRet = (int) (*PPFNDRV(po, DescribePixelFormat))
                               (po.dhpdev(), ipfd, cjpfd, ppfd);
    }

    if (iRet == 0)
        return(0);

    ASSERTGDI(iRet == ipfdDevMax, "Bad ipfdDevMax");
    return ipfdDevMax;
}

/******************************Public*Routine******************************\
* NtGdiSetPixelFormat
*
* Set the pixel format.
*
* This is a special function.  It is one of the three (the other two are
* ExtEscape for WNDOBJ_SETUP escape and ExtEscape for 3D-DDI
* RX_CREATECONTEXT escape) functions that allow WNDOBJ to be created in
* the DDI.  We need to be in the user critical section and grab the devlock
* in the function before calling the DrvSetPixelFormat function to ensure
* that the new WNDOBJ created is current.
*
* Returns: FALSE if error; TRUE otherwise
*
* History:
*  02-Nov-95                    -by-    Drew Bliss      [drewb]
* Changed to driver-only kernel-mode form
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

BOOL NtGdiSetPixelFormat(HDC hdc,int ipfd)
{
// Validate DC and surface.  Info DC is not allowed.

    DCOBJ dco(hdc);
    if (!dco.bValid() || !dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Validate pixel format index.
// If a driver support device pixel formats 1..ipfdDevMax, the generic
// pixel formats will be (ipfdDevMax+1)..(ipfdDevMax+MAX_GENERIC_PFD).
// Otherwise, ipfdDevMax is 0 and the generic pixel formats are
// 1..MAX_GENERIC_PFD.

    int ipfdDevMax = dco.ipfdDevMax();
    if ((ipfd < 1) || (ipfd > ipfdDevMax))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

// Make sure that we don't have devlock before entering user critical section.
// Otherwise, it can cause deadlock.

    if (dco.bDisplay())
    {
        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,"ERROR it has to be direct");
        CHECKDEVLOCKOUT(dco);
    }

// Enter user critical section.

    USERCRIT usercrit;

// We are modifying the pixel format of the window for the first time.
// Grab the devlock.
// We don't need to validate the devlock since we do not care if it is full screen.

    DEVLOCKOBJ dlo(dco);

// If it is a display DC, get the hwnd that the hdc is associated with.
// If it is a printer or memory DC, hwnd is NULL.

    HWND     hwnd;
    if (dco.bDisplay())
    {
        PEWNDOBJ pwo;

        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,
                  "ERROR it has to be direct really");

        if (!UserGetHwnd(hdc, &hwnd, (PVOID *) &pwo, FALSE))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_WINDOW_STYLE);
            return(FALSE);
        }

        // If another thread has changed the pixel format of the window
        // after we queried it earlier in this function, make sure that
        // the pixel format is compatible.
        // If a previous 3D-DDI wndobj with pixel format 0 has been created
        // for this window, fail the call here.

        if (pwo)
        {
            WARNING("GreSetPixelFormat: pixel format set asynchrously!\n");

            if (pwo->ipfd != ipfd)
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PIXEL_FORMAT);
                return(FALSE);
            }
            return(TRUE);
        }
    }
    else
    {
        hwnd = (HWND)NULL;
    }

    // Dispatch driver formats.  Call DrvSetPixelFormat.

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), NULL);

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if (!PPFNVALID(pdo,SwapBuffers) ||
        !((*PPFNDRV(pdo, SetPixelFormat))(pso, ipfd, hwnd)))
            return(FALSE);

// If a new WNDOBJ is created, we need to update the window client regions
// in the driver.

    if (gbWndobjUpdate)
    {
        gbWndobjUpdate = FALSE;
        vForceClientRgnUpdate();
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* NtGdiSwapBuffers
*
* Since SwapBuffers is a GDI function, it has to work even if OpenGL is
* not called.  That is, we will eventually support 2D double buffering in
* GDI.  As a result, we need to define a DDI function DrvSwapBuffers() that
* works with both OpenGL and GDI.  The complication is that we have to
* deal with the generic opengl server, the install opengl driver and GDI.
* I will outline how this function works here:
*
* 1. On the client side, SwapBuffers() call glFinish() to flush all the
*    OpenGL functions in the current thread.  It then calls the server side
*    GreSwapBuffers().  Note that this flushes all GDI functions in the
*    current thread.
* 2. Once on the server side, we know that all GDI/OpenGL calls have been
*    flushed.  We first find the hwnd id that corresponding to the hdc.
*    Note that SwapBuffers really applies to the window but not to the dc.
*    There is only one back buffer for a window but possibly multiple
*    dc's referring to the same back buffer.  We find out the hwnd id
*    for the dc and do one of the following:
*    A. hdc has the device pixel formats.
*       This is simple.  We call the device driver to swap the buffer with
*       the hwnd id.
*    B. hdc has the generic pixel formats.
*       Call the opengl server to swap the buffer.  The OpenGL server uses
*       the hwnd id to bitblt the buffer that is associated with the window.
*
* Note that in this implementation, we do not flush calls in other threads.
* Applications are responsible for coordinating SwapBuffers in multiple
* threads.
*
* History:
*  02-Nov-95                    -by-    Drew Bliss      [drewb]
* Stripped down to driver-only kernel-mode form
*  Thu Jan 06 12:32:11 1994     -by-    Hock San Lee    [hockl]
* Added some code and wrote the above comment.
*  21-Nov-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL NtGdiSwapBuffers(HDC hdc)
{
// Validate DC and surface.  Info DC is not allowed.

    DCOBJ dco(hdc);
    if (!dco.bValid() || !dco.bHasSurface())
    {
        WARNING("GreSwapBuffers(): invalid hdc\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Early out -- nothing to do if memory DC.

    if (dco.dctp() == DCTYPE_MEMORY)
        return(TRUE);

// Lock display.

    DEVLOCKOBJ_WNDOBJ dlo(dco);

    if (!dlo.bValidDevlock())
    {
        if (!dco.bFullScreen())
        {
            WARNING("GreSwapBuffers: could not lock device\n");
            return(FALSE);
        }
        else
            return(TRUE);
    }

    if (!dlo.bValidWndobj())
    {
        WARNING("GreSwapBuffers: invalid wndobj\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (dlo.pwo()->erclExclude().bEmpty())
        return(TRUE);

// Pointer exclusion.
// Increment the surface uniqueness.  This only needs to be done once
// per DEVLOCK.

    DEVEXCLUDEOBJ dxo;

    dxo.vExclude(dco.hdev(), &dlo.pwo()->rclClient, (ECLIPOBJ *) dlo.pwo());
    INC_SURF_UNIQ(dco.pSurface());

// Dispatch driver formats.

    PEWNDOBJ pwo;
    pwo = dlo.pwo();

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), pwo);

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if ( !PPFNVALID(pdo,SwapBuffers) ||
         !((*PPFNDRV(pdo,SwapBuffers))(pso, (WNDOBJ *)pwo)))
        return(FALSE);

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\plgblt.cxx ===
/******************************Module*Header*******************************\
* Module Name: plgblt.cxx
*
* This contains the API and DDI entry points to the graphics engine
* for PlgBlt and EngPlgBlt.
*
* Created: 21-Oct-1990 14:15:53
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "rotate.hxx"

/******************************Public*Routine******************************\
* GrePlgBlt
*
* API for blting to a parallelogram from a rectangle.
*
* History:
*  Tue 02-Jun-1992 -by- Patrick Haluptzok [patrickh]
* fix clipping bugs
*
*  21-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  Wed 15-Jan-1992 -by- Patrick Haluptzok [patrickh]
* Add mask support
*
*  26-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL GrePlgBlt(
    HDC     hdcTrg,
    LPPOINT pptlTrg,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    HBITMAP hbmMask,
    int     xMask,
    int     yMask,
    DWORD   crBackColor
    )
{
    GDITraceHandle3(GrePlgBlt, "(%X, %p, %X, %d, %d, %d, %d, %X, %d, %d, %X)\n", (va_list)&hdcTrg, hdcTrg, hdcSrc, hbmMask);

    BLTRECORD   blt;
    ULONG       ulAvec;

    // Lock the DC's, no optimization is made for same surface

    DCOBJ   dcoTrg(hdcTrg);
    DCOBJ   dcoSrc(hdcSrc);

    if (!dcoTrg.bValid() || !dcoSrc.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    if (dcoTrg.bStockBitmap())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

    // Lock the surface and the Rao region

    DEVLOCKBLTOBJ dlo(dcoTrg, dcoSrc);

    if (!dlo.bValid())
    {
        return(dcoTrg.bFullScreen() || dcoSrc.bFullScreen());
    }

    if (!dcoTrg.bValidSurf() || !dcoSrc.bValidSurf() || !dcoSrc.pSurface()->bReadable())
    {
        ULONG ulDirty = dcoTrg.pdc->ulDirty();

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
           GreDCSelectBrush (dcoTrg.pdc,dcoTrg.pdc->hbrush());
        }

        ulDirty = dcoSrc.pdc->ulDirty();

        if ( ulDirty & DC_BRUSH_DIRTY)
        {
           GreDCSelectBrush (dcoSrc.pdc,dcoSrc.pdc->hbrush());
        }

        // I wanted to cheat, but InfoDCs need the right answer here...

        if ((dcoTrg.dctp() == DCTYPE_INFO) || !dcoSrc.bValidSurf())
        {
            if (dcoTrg.fjAccum())
            {
                blt.pxoTrg()->vInit(dcoTrg,WORLD_TO_DEVICE);

                if (!blt.TrgPlg(pptlTrg))
                {
                    SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                    return(FALSE);
                }

                // Complete the parallelogram and find the extrema.

                blt.vExtrema();

                // Get the bounding rectangle

                ERECTL  erclBnd;

                blt.vBound(&erclBnd);

                dcoTrg.vAccumulate(erclBnd);
            }
        }

        // Do the security test on SCREEN to MEMORY blits.

        if (dcoSrc.bDisplay() && !dcoTrg.bDisplay())
        {
            if (!UserScreenAccessCheck())
            {
                SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
                return(FALSE);
            }
        }

        // If the source isn't a DISPLAY we should exit unless there is no
        // destination surface.

        if( !dcoSrc.bDisplay() )
        {
            return( dcoTrg.pSurface() == NULL );
        }
    }

    if (dcoTrg.bDisplay() && !dcoTrg.bRedirection() && dcoSrc.bValidSurf() && !dcoSrc.bDisplay() && !UserScreenAccessCheck())
    {
        SAVE_ERROR_CODE(ERROR_ACCESS_DENIED);
        return(FALSE);
    }
    // Fill the BLTRECORD

    blt.pxoTrg()->vInit(dcoTrg,WORLD_TO_DEVICE);
    blt.pSurfTrg(dcoTrg.pSurfaceEff());
    blt.ppoTrg()->ppalSet(blt.pSurfTrg()->ppal());
    blt.ppoTrgDC()->ppalSet(dcoTrg.ppal());

    blt.pxoSrc()->vInit(dcoSrc,WORLD_TO_DEVICE);
    blt.pSurfSrc(dcoSrc.pSurfaceEff());
    blt.ppoSrc()->ppalSet(blt.pSurfSrc()->ppal());
    blt.ppoSrcDC()->ppalSet(dcoSrc.ppal());

    // Initialize the color translation object.
    //
    // No ICM with PlgBlt(), so pass NULL color transform to XLATEOBJ.

    if (!blt.pexlo()->bInitXlateObj(NULL,                   // hColorTransform
                                    dcoTrg.pdc->lIcmMode(), // ICM mode
                                   *blt.ppoSrc(),
                                   *blt.ppoTrg(),
                                   *blt.ppoSrcDC(),
                                   *blt.ppoTrgDC(),
                                    dcoTrg.pdc->crTextClr(),
                                    dcoTrg.pdc->crBackClr(),
                                    crBackColor
                                    ))
    {
        WARNING("bInitXlateObj failed in PlgBlt\n");
        return(FALSE);
    }

    blt.flSet(BLTREC_PXLO);
    blt.pbo(NULL);

    // Set the source rectangle.

    if (blt.pxoSrc()->bRotation() || !blt.Src(xSrc, ySrc, cxSrc, cySrc))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // Deal with the mask if provided

    if (hbmMask == (HBITMAP) 0)
    {
        blt.pSurfMsk((SURFACE *) NULL);
        blt.rop(0x0000CCCC);
        ulAvec = AVEC_S;
    }
    else
    {
        SURFREF soMsk((HSURF) hbmMask);

        if (!soMsk.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }

        soMsk.vKeepIt();

        blt.pSurfMsk((SURFACE *) soMsk.ps);

        blt.rop(0x0000AACC);

        ulAvec = AVEC_NEED_MASK | AVEC_S;

        blt.flSet(BLTREC_MASK_NEEDED | BLTREC_MASK_LOCKED);

        if (
            (blt.pSurfMsk()->iType() != STYPE_BITMAP) ||
            (blt.pSurfMsk()->iFormat() != BMF_1BPP)
           )
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(FALSE);
        }

        blt.Msk(xMask, yMask);
    }

    // We must first transform the target.  We might be rotating because of
    // the transform or the specified parallelogram.

    if (!blt.TrgPlg(pptlTrg))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    // If the parallelogram is rotated, skewed or has fractional endpoints
    // send the call to bRotate.

    if (blt.bRotated())
    {
        return(blt.bRotate(dcoTrg, dcoSrc, ulAvec, dcoTrg.pdc->jStretchBltMode()));
    }

    // If we are halftoning or the extents aren't equal, call bStretch.

    if ((dcoTrg.pdc->jStretchBltMode() == HALFTONE) || !blt.bEqualExtents())
    {
        return(blt.bStretch(dcoTrg, dcoSrc, ulAvec, dcoTrg.pdc->jStretchBltMode()));
    }

    return(blt.bBitBlt(dcoTrg, dcoSrc, ulAvec));
}

BOOL
APIENTRY
NtGdiPlgBlt(
    HDC     hdcTrg,
    LPPOINT pptlTrg,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    HBITMAP hbmMask,
    int     xMask,
    int     yMask,
    DWORD   crBackColor
    )
{
    GDITraceHandle3(NtGdiPlgBlt, "(%X, %p, %X, %d, %d, %d, %d, %X, %d, %d, %X)\n", (va_list)&hdcTrg, hdcTrg, hdcSrc, hbmMask);

    BOOL  bRet;
    POINT aptDst[3];

    __try
    {
        ProbeForRead(pptlTrg, sizeof(aptDst), sizeof(DWORD));
        RtlMoveMemory(aptDst, pptlTrg, sizeof(aptDst));

        pptlTrg = aptDst;
        bRet = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // SetLastError(GetExceptionCode());

        bRet = FALSE;
    }

    if (bRet)
    {
        bRet = GrePlgBlt(hdcTrg, pptlTrg, hdcSrc, xSrc, ySrc, cxSrc, cySrc,
                         hbmMask, xMask, yMask, crBackColor);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bRotate(dcoTrg, dcoSrc, ulAvec)
*
* Do a rotate blt from the blt record
*
* History:
*  21-Mar-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
\**************************************************************************/

BOOL
BLTRECORD::bRotate(
    DCOBJ&  dcoTrg,
    DCOBJ&  dcoSrc,
    ULONG   ulAvec,
    BYTE    jMode
    )
{
    //
    // Complete the parallelogram and find the extrema
    //

    vExtrema();

    //
    // We might be here on behalf of MaskBlt and need to rotate the mask
    // before we do a pattern only blt.
    //

    BOOL    bReturn;

    if (!(ulAvec & AVEC_NEED_SOURCE))
    {
        vOrder(perclMask());

        if (MIRRORED_DC(dcoTrg.pdc)) {
            LONG x = aptlMask[0].x;
            aptlMask[0].x = aptlMask[1].x;
            aptlMask[1].x = x;
        }

        //
        // Before we call to the driver, validate that the mask will actually
        // cover the entire target.
        //

        if (pSurfMskOut() != (SURFACE *) NULL)
        {
            if (
                (aptlMask[0].x < 0) ||
                (aptlMask[0].y < 0) ||
                (aptlMask[1].x > pSurfMsk()->sizl().cx) ||
                (aptlMask[1].y > pSurfMsk()->sizl().cy)
               )
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return(FALSE);
            }
        }

        SURFMEM  dimoMask;

        //
        // If there is a mask, rotate it.
        //

        if ((ulAvec & AVEC_NEED_MASK) && !bRotate(dimoMask, (ULONG) jMode))
        {
            return(FALSE);
        }

        //
        // Since this is going to bBitBlt, we need to create a target rectangle.
        //

        vBound(perclTrg());

        //
        // Create a region from the parallelogram and select it into the
        // clipping pipeline.  This is to make sure no bits are altered
        // outside when BitBlt is called.
        //

        if (!bCreateRegion(dcoTrg, aptfxTrg))
        {
            return(FALSE);
        }

        bReturn = bBitBlt(dcoTrg, dcoSrc, ulAvec);

        //
        // Remember to clean up after ourselves!
        //

        dcoTrg.pdc->prgnAPI(NULL);

        return(bReturn);
    }

    //
    // Make the source rectangle well ordered remembering all the flips.
    //

    vOrder(perclSrc());
    perclMask()->vOrder();

    if (MIRRORED_DC(dcoTrg.pdc)) {
        int x = aptlMask[0].x;
        aptlMask[0].x = aptlMask[1].x;
        aptlMask[1].x = x;
    }

    //
    // Before we get too involved, validate that the mask will actually
    // cover the entire source.
    //

    if (pSurfMskOut() != (SURFACE *) NULL)
    {
        if (
            (aptlMask[0].x < 0) ||
            (aptlMask[0].y < 0) ||
            (aptlMask[1].x > pSurfMsk()->sizl().cx) ||
            (aptlMask[1].y > pSurfMsk()->sizl().cy)
           )
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

    //
    // If the devices are on different PDEV's we can only succeed if the Engine
    // manages one or both of the surfaces.  Check for this.
    //

    if (
        (dcoTrg.hdev() != dcoSrc.hdev()) &&
        (dcoTrg.pSurfaceEff()->iType() != STYPE_BITMAP) &&
        (dcoSrc.pSurfaceEff()->iType() != STYPE_BITMAP)
       )
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // We might be here with a ROP, again on behalf of MaskBlt.  If it
    // isn't one of the basic PlgBlt rops, create a rotated shadow and mask
    // and call BitBlt to finish the job for us.
    //

    if ((rop4 != 0x0000CCCC) && (rop4 != 0x0000AACC))
    {
        SURFMEM   dimoMask;
        SURFMEM   dimoShadow;

        // WINBUG #263939 3-5-2000 bhouse Watchdog timeout problems
        // We suspend the watchdog here ... GDI is brain dead and will
        // create a temporary shadow surface the size of the destination
        // mapping.  This is crazy when the destination mapping far excceeds
        // the actual size of the destination.  Maybe one day we will
        // re-write this brain dead code.... I'm not holding my breadth.
        PDEVOBJ pdoTrg(pSurfTrg()->hdev());
        
        if(pdoTrg.bDisplayPDEV())
            GreSuspendWatch(pdoTrg.ppdev, WD_DEVLOCK);

        bReturn = bRotate(dcoSrc, dimoShadow, dimoMask, ulAvec, (ULONG) jMode);

        if(pdoTrg.bDisplayPDEV())
            GreResumeWatch(pdoTrg.ppdev, WD_DEVLOCK);

        if(!bReturn)
            return(FALSE);

        //
        // Since this is going to bBitBlt, we need to create a target rectangle.
        //

        vBound(perclTrg());

        //
        // Create a region from the parallelogram and select it into the
        // clipping pipeline.  This is to make sure no bits are altered
        // outside when BitBlt is called.
        //

        if (!bCreateRegion(dcoTrg, aptfxTrg))
        {
            return(FALSE);
        }

        bReturn = bBitBlt(dcoTrg, dcoSrc, ulAvec);

        //
        // Remember to clean up after ourselves!
        //

        dcoTrg.pdc->prgnAPI(NULL);

        return(bReturn);
    }

    //
    // Get the bounding rectangle
    //

    ERECTL  erclBound;

    vBound(&erclBound);

    //
    // Adjust bounds for inclusive/inclusive
    //

    erclBound.right  += 1;
    erclBound.bottom += 1;

    //
    // Accumulate bounds.  We can do this before knowing if the operation is
    // successful because bounds can be loose.
    //

    if (dcoTrg.fjAccum())
    {
        dcoTrg.vAccumulate(erclBound);
    }

    //
    // With a fixed DC origin we can change parallelogram and rectangle to
    // SCREEN coordinates
    //

    vOffset(dcoTrg.eptlOrigin());
   *perclSrc()  += dcoSrc.eptlOrigin();
    erclBound   += dcoTrg.eptlOrigin();

    //
    // Compute the clipping complexity and maybe reduce the exclusion rectangle.
    //

    ECLIPOBJ eco(dcoTrg.prgnEffRao(), erclBound);

    //
    // Check the destination which is reduced by clipping.
    //

    if (eco.erclExclude().bEmpty())
    {
        return(TRUE);
    }

    //
    // Compute the exclusion rectangle.
    //

    ERECTL erclExclude = eco.erclExclude();

    //
    // If we are going to the same source, prevent bad overlap situations
    //

    if (dcoSrc.pSurface() == dcoTrg.pSurface())
    {
        if (perclSrc()->left   < erclExclude.left)
        {
            erclExclude.left   = perclSrc()->left;
        }

        if (perclSrc()->top    < erclExclude.top)
        {
            erclExclude.top    = perclSrc()->top;
        }

        if (perclSrc()->right  > erclExclude.right)
        {
            erclExclude.right  = perclSrc()->right;
        }

        if (perclSrc()->bottom > erclExclude.bottom)
        {
            erclExclude.bottom = perclSrc()->bottom;
        }
    }

    //
    // We might have to exclude the source or the target, get ready to do either.
    //

    DEVEXCLUDEOBJ dxo;

    PDEVOBJ pdoTrg(pSurfTrg()->hdev());

    //
    // They can't both be display
    //

    if (dcoSrc.bDisplay())
    {
        ERECTL ercl(0,0,pSurfSrc()->sizl().cx,pSurfSrc()->sizl().cy);

        if (dcoSrc.pSurface() == dcoTrg.pSurface())
        {
            ercl *= erclExclude;
        }
        else
        {
            ercl *= *perclSrc();
        }

        dxo.vExclude(dcoSrc.hdev(),&ercl,NULL);
    }
    else if (dcoTrg.bDisplay())
    {
        dxo.vExclude(dcoTrg.hdev(),&erclExclude,&eco);
    }

    //
    // Handle target mirroring
    //

    vMirror(aptfxTrg);

    //
    // Inc the target surface uniqueness
    //

    INC_SURF_UNIQ(pSurfTrg());

    return((*PPFNGET(pdoTrg, PlgBlt, pSurfTrg()->flags()))(
        pSurfTrg()->pSurfobj(),
        pSurfSrc()->pSurfobj(),
        (rop4 == 0x0000CCCC) ? (SURFOBJ *) NULL : pSurfMskOut()->pSurfobj(),
        &eco,
        pexlo()->pxlo(),
        (dcoTrg.pColorAdjustment()->caFlags & CA_DEFAULT) ?
            (PCOLORADJUSTMENT)NULL : dcoTrg.pColorAdjustment(),
        &dcoTrg.pdc->ptlFillOrigin(),
        aptfxTrg,
        perclSrc(),
        aptlMask,
        jMode));
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bRotate(dimo, iMode)
*
* Rotate just the mask.
*
* History:
*  23-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bRotate(
SURFMEM&   dimo,
ULONG      iMode)
{
    ERECTL  erclTrg;

    vBound(&erclTrg);

// Fill in the bitmap info.

    DEVBITMAPINFO   dbmi;

    dbmi.iFormat  = BMF_1BPP;
    dbmi.cxBitmap = erclTrg.right - erclTrg.left;
    dbmi.cyBitmap = erclTrg.bottom - erclTrg.top;
    dbmi.hpal     = (HPALETTE) 0;
    dbmi.fl       = pSurfMskOut()->bUMPD() ? UMPD_SURFACE : 0;

    dimo.bCreateDIB(&dbmi, (VOID *) NULL);

    if (!dimo.bValid())
    {
        return(FALSE);
    }

    // Build a shadow parallelogram.

    POINTFIX    aptfxShadow[4];

    aptfxShadow[0].x = aptfxTrg[0].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[0].y = aptfxTrg[0].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[1].x = aptfxTrg[1].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[1].y = aptfxTrg[1].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[2].x = aptfxTrg[2].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[2].y = aptfxTrg[2].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[3].x = aptfxTrg[3].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[3].y = aptfxTrg[3].y - FIX_FROM_LONG(erclTrg.top);

    // Take care of mirroring.

    vMirror(aptfxShadow);

    // Call EngPlgBlt to rotate the mask.

    EPOINTL ptl(0,0);

    if (!EngPlgBlt(
                   dimo.pSurfobj(),
                   pSurfMskOut()->pSurfobj(),
                   (SURFOBJ *) NULL,
                   (CLIPOBJ *) NULL,
                   NULL,
                   NULL,
                   (POINTL *)&ptl,
                   aptfxShadow,
                   perclMask(),
                   (POINTL *) NULL,
                   iMode)
                  )
    return(FALSE);

    // Release the previous pSurfMask, tell ~BLTRECORD its gone and put the
    // new DIB in its place.  Remember to adjust the mask origin.

    flState &= ~BLTREC_MASK_LOCKED;
    pSurfMsk()->vAltUnlockFast();
    pSurfMsk((SURFACE *) dimo.ps);

    aptlMask[0].x = 0;
    aptlMask[0].y = 0;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bRotate(dcoSrc, dimoShadow, dimoMask, ulAvec, iMode)
*
* Rotate the shadow and mask.
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL
BLTRECORD::bRotate(
    DCOBJ&     dcoSrc,
    SURFMEM&   dimoShadow,
    SURFMEM&   dimoMask,
    ULONG          ulAvec,
    ULONG          iMode
    )
{
    // If there is a mask, rotate it.

    if ((ulAvec & AVEC_NEED_MASK) && !bRotate(dimoMask, iMode))
    {
        return(FALSE);
    }

    ERECTL  erclTrg;

    vBound(&erclTrg);

    // Fill in the bitmap info.

    DEVBITMAPINFO   dbmi;

    dbmi.cxBitmap = erclTrg.right - erclTrg.left;
    dbmi.cyBitmap = erclTrg.bottom - erclTrg.top;
    dbmi.hpal     = (HPALETTE) 0;
    dbmi.iFormat  = pSurfSrc()->iFormat();
    dbmi.fl       = pSurfSrc()->bUMPD() ? UMPD_SURFACE : 0;

    dimoShadow.bCreateDIB(&dbmi, (VOID *) NULL);

    if (!dimoShadow.bValid())
    {
        return(FALSE);
    }

    // Build a shadow parallelogram.

    POINTFIX    aptfxShadow[4];

    aptfxShadow[0].x = aptfxTrg[0].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[0].y = aptfxTrg[0].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[1].x = aptfxTrg[1].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[1].y = aptfxTrg[1].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[2].x = aptfxTrg[2].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[2].y = aptfxTrg[2].y - FIX_FROM_LONG(erclTrg.top);
    aptfxShadow[3].x = aptfxTrg[3].x - FIX_FROM_LONG(erclTrg.left);
    aptfxShadow[3].y = aptfxTrg[3].y - FIX_FROM_LONG(erclTrg.top);

    // Take care of mirroring.

    vMirror(aptfxShadow);

    // Now comes the tricky part.  The source may be a display.  While it may
    // be somewhat faster to assume it isn't, code would be much more complex.

    {
        // Adjust the source rectangle.

        *perclSrc() += dcoSrc.eptlOrigin();

        // Exclude the pointer.

        ERECTL ercl(0,0,pSurfSrc()->sizl().cx,pSurfSrc()->sizl().cy);
        ercl *= *perclSrc();

        DEVEXCLUDEOBJ dxo(dcoSrc, &ercl);

        // Rotate the bits to the DIB.

        EPOINTL ptl(0,0);

        if (!EngPlgBlt(
                       dimoShadow.pSurfobj(),
                       pSurfSrc()->pSurfobj(),
                       (SURFOBJ *) NULL,
                       (CLIPOBJ *) NULL,
                       NULL,
                       NULL,
                       (POINTL *)&ptl,
                       aptfxShadow,
                       perclSrc(),
                       (POINTL *) NULL,
                       iMode)
                      )
        {
            return(FALSE);
        }

        // Update the source surface and set the source rectangle for
        // BitBlt or MaskBlt.

        pSurfSrc((SURFACE *) dimoShadow.ps);

        perclSrc()->left   = -dcoSrc.eptlOrigin().x;
        perclSrc()->top    = -dcoSrc.eptlOrigin().y;
        perclSrc()->right  = dbmi.cxBitmap - dcoSrc.eptlOrigin().x;
        perclSrc()->bottom = dbmi.cyBitmap - dcoSrc.eptlOrigin().y;
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bRotated()
*
* Checks if the target parallelogram is skewed or rotated.
*
* History:
*  25-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bRotated()
{
    // Test for rotation or skew.

    if (
        ((aptfxTrg[1].y - aptfxTrg[0].y) != 0) ||
        ((aptfxTrg[2].x - aptfxTrg[0].x) != 0)
       )
    {
        return(TRUE);
    }

    // We might have fractional endpoints.      If so, we still need to call
    // bRotate since StretchBlt at the DDI takes integer coordinates.

    if (
        (aptfxTrg[0].x & 0x0f) || (aptfxTrg[0].y & 0x0f) ||
        (aptfxTrg[1].x & 0x0f) || (aptfxTrg[1].y & 0x0f) ||
        (aptfxTrg[2].x & 0x0f) || (aptfxTrg[2].y & 0x0f)
       )
    {
        return(TRUE);
    }

    // OK, we don't have to call bRotate.  Set up the target rectangle and
    // return FALSE.

    aptlTrg[0].x = LONG_FLOOR_OF_FIX(aptfxTrg[0].x);
    aptlTrg[0].y = LONG_FLOOR_OF_FIX(aptfxTrg[0].y);
    aptlTrg[1].x = LONG_FLOOR_OF_FIX(aptfxTrg[1].x);
    aptlTrg[1].y = LONG_FLOOR_OF_FIX(aptfxTrg[2].y);

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vExtrema()
*
* Complete the parallelogram and find the extrema.  Uses ChuckWh's trick.
*
* History:
*  28-Jan-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vExtrema()
{
    aptfxTrg[3].x = aptfxTrg[1].x + aptfxTrg[2].x - aptfxTrg[0].x;
    aptfxTrg[3].y = aptfxTrg[1].y + aptfxTrg[2].y - aptfxTrg[0].y;

    iLeft = (aptfxTrg[1].x > aptfxTrg[0].x) == (aptfxTrg[1].x > aptfxTrg[3].x);
    iTop  = (aptfxTrg[1].y > aptfxTrg[0].y) == (aptfxTrg[1].y > aptfxTrg[3].y);
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vBound(percl)
*
* Make a well ordered bounding rectangle from the parallelogram
*
* History:
*  28-Jan-1993 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vBound(ERECTL *percl)
{
    percl->left   = LONG_CEIL_OF_FIX(aptfxTrg[iLeft].x);
    percl->top    = LONG_CEIL_OF_FIX(aptfxTrg[iTop].y);
    percl->right  = LONG_CEIL_OF_FIX(aptfxTrg[iLeft ^ 3].x);
    percl->bottom = LONG_CEIL_OF_FIX(aptfxTrg[iTop ^ 3].y);

    // Make it well ordered!

    percl->vOrder();
}

/******************************Public*Routine******************************\
* VOID BLTRECORD::vMirror(pptfx)
*
* Flip the parallelogram according to the mirroring flags
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID BLTRECORD::vMirror(POINTFIX *pptfx)
{
    FIX fx;

    if (flState & BLTREC_MIRROR_X)
    {
        fx = pptfx[1].x, pptfx[1].x = pptfx[0].x, pptfx[0].x = fx;
        fx = pptfx[1].y, pptfx[1].y = pptfx[0].y, pptfx[0].y = fx;
        fx = pptfx[3].x, pptfx[3].x = pptfx[2].x, pptfx[2].x = fx;
        fx = pptfx[3].y, pptfx[3].y = pptfx[2].y, pptfx[2].y = fx;
    }

    if (flState & BLTREC_MIRROR_Y)
    {
        fx = pptfx[2].x, pptfx[2].x = pptfx[0].x, pptfx[0].x = fx;
        fx = pptfx[2].y, pptfx[2].y = pptfx[0].y, pptfx[0].y = fx;
        fx = pptfx[3].x, pptfx[3].x = pptfx[1].x, pptfx[1].x = fx;
        fx = pptfx[3].y, pptfx[3].y = pptfx[1].y, pptfx[1].y = fx;
    }
}

/******************************Public*Routine******************************\
* BOOL BLTRECORD::bCreateRegion(dco, pptfx)
*
* Create a region from the parallelogram and add it to the clipping
* pipeline.
*
* History:
*  24-Mar-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL BLTRECORD::bCreateRegion(
    DCOBJ&   dco,
    POINTFIX *pptfx
    )
{
    // First, take care of any mirroring that might have occured.

    vMirror(pptfx);

    // Create a path

    PATHMEMOBJ  pmo;

    if (!pmo.bValid())
    {
        return(FALSE);
    }

    // Create a parallelogram in drawing order.

    POINTL  aptl[4];

    aptl[0].x = pptfx[0].x;
    aptl[0].y = pptfx[0].y;
    aptl[1].x = pptfx[1].x;
    aptl[1].y = pptfx[1].y;
    aptl[2].x = pptfx[3].x;
    aptl[2].y = pptfx[3].y;
    aptl[3].x = pptfx[2].x;
    aptl[3].y = pptfx[2].y;

    // Construct a path around the parallelogram

    if (!pmo.bMoveTo((EXFORMOBJ *) NULL, &aptl[0]))
    {
        return(FALSE);
    }

    if (!pmo.bPolyLineTo((EXFORMOBJ *) NULL, &aptl[1], 3))
    {
        return(FALSE);
    }

    // Create a region from it.

    prmo()->vCreate(pmo, ALTERNATE);

    if (!prmo()->bValid())
    {
        return(FALSE);
    }

    // Tell ~BLTRECORD it has something to clean up.

    flState |= BLTREC_PRO;

    // Select the region into the DC's clipping pipeline.  This will dirty
    // the Rao so it gets merged in when bCompute is called.

    dco.pdc->prgnAPI(prmo()->prgnGet());

    return(TRUE);
}

#ifdef  DBG_PLGBLT
LONG gflPlgBlt = PLGBLT_ENABLE;

VOID vShowRect(
CHAR  *psz,
RECTL *prcl)
{
    if (gflPlgBlt & PLGBLT_RECTS)
    {
        DbgPrint("%s [(%ld,%ld) (%ld,%ld)]\n",
                 psz, prcl->left, prcl->top, prcl->right, prcl->bottom);
}
#endif

/******************************Public*Routine******************************\
* EngPlgBlt
*
*  This does parallelogram bltting.  This gets called to PlgBlt between
*  two engine managed surfaces or if the driver has chosen not to handle
*  EngPlgBlt.
*
*  The API passes in prclSrc which is the rectangle on the left, and
*  also passes in 3 points which define A,B,C of the paralellogram on the
*  right.  The points are assumed to be in that order A,B,C.
*  The lower-left of the src rect goes to the third point, the upper-left of
*  the src rect goes to the first point, and the upper-right of the source
*  rect goes to the second point.
*
*  NOTE! The source rectangle MUST BE WELL ORDERED IN DEVICE SPACE.
*
*   A-----B                  B                   A----------------B
*   |     |                 / \                  |                |
*   |     |     --->       /   \                 |                |
*   |     |               /     \        or      |                |
*   C-----D              A       \               |                |
*                         \       D              |                |
*                          \     /               |                |
*                           \   /                |                |
*                            \ /                 |                |
*                             C                  C----------------D
*
*
*  This call returns TRUE for success, FALSE for ERROR.
*
* History:
*  27-Jul-1992 -by- Donald Sidoroff [donalds]
* Wrote.
\**************************************************************************/

BOOL
EngPlgBlt(
    SURFOBJ         *psoTrg,
    SURFOBJ         *psoSrc,
    SURFOBJ         *psoMsk,
    CLIPOBJ         *pco,
    XLATEOBJ        *pxlo,
    COLORADJUSTMENT *pca,
    POINTL          *pptlBrushOrg,
    POINTFIX        *pptfx,
    RECTL           *prcl,
    POINTL          *pptl,
    ULONG            iMode)
{

    PSURFACE pSurfTrg = SURFOBJ_TO_SURFACE(psoTrg);
    PSURFACE pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    PSURFACE pSurfMsk = SURFOBJ_TO_SURFACE(psoMsk);

    BOOL bRet = FALSE;

    //
    // Added HALFTONE support if iMode passed in is HALFTONE.
    // This is to ensure n-up printing on PCL printers
    // will look decent.
    // Note that we are currently not supporting HALFTONE
    // if there is mask.   [lingyunw]
    //
    BOOL bHalftone = ((iMode == HALFTONE) && !pSurfMsk);

    //
    // Prevent bad driver call backs
    //

    if ((iMode == 0) || (iMode > MAXSTRETCHBLTMODE))
    {
        WARNING1("EngPlgBlt: Unsupported iMode\n");
        return(FALSE);
    }

    //
    // Can't PlgBlt to an RLE
    // Can't PlgBlt to/from a JPEG or PNG
    //

    if ((pSurfTrg->iFormat() == BMF_4RLE) ||
        (pSurfTrg->iFormat() == BMF_8RLE) ||
        (pSurfTrg->iFormat() == BMF_JPEG) ||
        (pSurfSrc->iFormat() == BMF_JPEG) ||
        (pSurfTrg->iFormat() == BMF_PNG ) ||
        (pSurfSrc->iFormat() == BMF_PNG ))
    {
        WARNING("EngPlgBlt: Unsupported source/target\n");
        return(FALSE);
    }

    //
    // We may need to do a WHITEONBLACK or BLACKONWHITE from a monochrome source.
    // Find out and set the bogusity flag.
    //

    BOOL bBogus = (
                   (iMode < COLORONCOLOR) &&
                   (pSurfMsk == (SURFACE *) NULL) &&
                   ((pSurfSrc->iFormat() == BMF_1BPP) ||
                    (pSurfTrg->iFormat() == BMF_1BPP))
                  );

    if ((!bBogus) && (iMode < COLORONCOLOR))
    {
        iMode = COLORONCOLOR;
    }

    //
    // Get the LDEV's for the target and source surfaces
    //

    PDEVOBJ    pdoTrg(pSurfTrg->hdev());
    PDEVOBJ    pdoSrc(pSurfSrc->hdev());

    //
    // Set up frame variables for possible switch to temporary output surface
    //

    SURFMEM      dimoOut;
    SURFACE     *pSurfOut;
    POINTFIX     aptfxOut[4];
    POINTFIX    *pptfxOut;
    ECLIPOBJ     ecoOut;
    CLIPOBJ     *pcoOut;
    ERECTL       erclDev;
    EPOINTL      eptlDev;
    XLATEOBJ    *pxloOut;
    RGNMEMOBJTMP rmoOut;

    ERECTL       erclTrim(0, 0, pSurfSrc->sizl().cx, pSurfSrc->sizl().cy);
        
    //
    // Multimon negative offset case
    //

    if ((pdoSrc.bValid()) && (pdoSrc.bPrimary(pSurfSrc) && (pdoSrc.bMetaDriver())))
    {
        erclTrim += *pdoSrc.pptlOrigin();
    }

    //
    // If the target is not a DIB, or the target and source are on the same
    // surface and the extents overlap, create a target DIB of the needed
    // size and format.  We will also create a target DIB if we need to do
    // the evil BLACKONWHITE or WHITEONBLACK modes.
    //

    if ( !bBogus &&
         (pSurfTrg->iType() == STYPE_BITMAP) &&
         (pSurfTrg->hsurf() != pSurfSrc->hsurf()) &&
         !bHalftone )
    {
        pSurfOut   = pSurfTrg;
        pptfxOut = pptfx;
        pcoOut   = pco;
    }
    else
    {
        aptfxOut[0] = pptfx[0];
        aptfxOut[1] = pptfx[1];
        aptfxOut[2] = pptfx[2];
        aptfxOut[3].x = pptfx[1].x + pptfx[2].x - pptfx[0].x;
        aptfxOut[3].y = pptfx[1].y + pptfx[2].y - pptfx[0].y;

        //
        // Compute the extrema
        //

        int iLeft = (aptfxOut[1].x > aptfxOut[0].x) == (aptfxOut[1].x > aptfxOut[3].x);
        int iTop  = (aptfxOut[1].y > aptfxOut[0].y) == (aptfxOut[1].y > aptfxOut[3].y);

        if (aptfxOut[iLeft].x > aptfxOut[iLeft ^ 3].x)
        {
            iLeft ^= 3;
        }

        if (aptfxOut[iTop].y > aptfxOut[iTop ^ 3].y)
        {
            iTop ^= 3;
        }

        //
        // This will be the area we copy dimoOut to in the target surface.
        //

        erclDev.left   = LONG_FLOOR_OF_FIX(aptfxOut[iLeft].x) - 1;
        erclDev.top    = LONG_FLOOR_OF_FIX(aptfxOut[iTop].y) - 1;
        erclDev.right  = LONG_CEIL_OF_FIX(aptfxOut[iLeft ^ 3].x) + 1;
        erclDev.bottom = LONG_CEIL_OF_FIX(aptfxOut[iTop ^ 3].y) + 1;

        //
        // Trim to the target surface.
        //

        ERECTL  erclTrg(0, 0, pSurfTrg->sizl().cx, pSurfTrg->sizl().cy);

        //
        // Multimon negative offset case
        //
    
        if ((pdoTrg.bValid()) && (pdoTrg.bPrimary(pSurfTrg) && (pdoTrg.bMetaDriver())))
        {
            erclTrg += *pdoTrg.pptlOrigin();
        }
        
        erclDev *= erclTrg;

        //
        // If we have nothing left, we're done.
        //

        if (erclDev.bEmpty())
        {
            return(TRUE);
        }

        //
        // If we are only here on possible overlap, test for misses
        //

        if ( !bBogus &&
             (pSurfTrg->iType() == STYPE_BITMAP) &&
             (!bHalftone) &&
             (  (erclDev.left > prcl->right) ||
                (erclDev.right < prcl->left) ||
                (erclDev.top > prcl->bottom) ||
                (erclDev.bottom < prcl->top) ) )
        {
            pSurfOut   = pSurfTrg;
            pptfxOut = pptfx;
            pcoOut   = pco;
        }
        else
        {
            // Compute the adjusted parallelogram in the temporary surface.

            aptfxOut[0].x -= FIX_FROM_LONG(erclDev.left);
            aptfxOut[0].y -= FIX_FROM_LONG(erclDev.top);
            aptfxOut[1].x -= FIX_FROM_LONG(erclDev.left);
            aptfxOut[1].y -= FIX_FROM_LONG(erclDev.top);
            aptfxOut[2].x -= FIX_FROM_LONG(erclDev.left);
            aptfxOut[2].y -= FIX_FROM_LONG(erclDev.top);

            DEVBITMAPINFO   dbmi;

            dbmi.cxBitmap = erclDev.right - erclDev.left + 1;
            dbmi.cyBitmap = erclDev.bottom - erclDev.top + 1;
            dbmi.hpal     = (HPALETTE) 0;
            dbmi.iFormat  = pSurfTrg->iFormat();
            dbmi.fl       = pSurfTrg->bUMPD() ? UMPD_SURFACE : 0;

            //
            // If this is a bogus call, build a monochrome target.
            //

            if (bBogus)
            {
                dbmi.iFormat = BMF_1BPP;
            }
            else if (bHalftone)
            {
               //
               // if HALFTONE, make the target same format as source
               // so latter on we can stretch with HALFTONE
               //
               dbmi.iFormat = pSurfSrc->iFormat();
            }

            dimoOut.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoOut.bValid())
            {
                return(FALSE);
            }

            //
            // What point in the target surface is 0,0 in temporary surface.
            //

            eptlDev = *((EPOINTL *) &erclDev);

            //
            // Build a CLIPOBJ for the new surface.
            //

            if (!rmoOut.bValid())
            {
                return(FALSE);
            }

            erclDev.left    = 0;
            erclDev.top     = 0;
            erclDev.right  -= eptlDev.x;
            erclDev.bottom -= eptlDev.y;

            rmoOut.vSet((RECTL *) &erclDev);

            ecoOut.vSetup(rmoOut.prgnGet(), erclDev, CLIP_FORCE);

            //
            // Synchronize with the device driver before touching the device surface.
            //

            pdoTrg.vSync(psoTrg,NULL,0);

            //
            // If there is a mask, copy the actual target to the temporary.
            //

            if (pSurfMsk != (SURFACE *) NULL)
            {
                (*PPFNGET(pdoTrg,CopyBits,pSurfTrg->flags()))(
                          dimoOut.pSurfobj(),
                          pSurfTrg->pSurfobj(),
                          (CLIPOBJ *) NULL,
                          &xloIdent,
                          &erclDev,
                          &eptlDev);

            }

            //
            // If we are doing BLACKONWHITE or WHITEONBLACK we need to
            // initialize the DIB appropriately.
            //

            if (bBogus)
            {
                if (!EngEraseSurface(dimoOut.pSurfobj(),
                                     &erclDev,
                                     iMode == BLACKONWHITE ? ~0L : 0L))
                    return(FALSE);
            }

            //
            // Point to the new target.
            //

            pSurfOut   = dimoOut.ps;
            pptfxOut   = &aptfxOut[0];
            pcoOut     = &ecoOut;

            if ((bBogus && (pSurfSrc->iFormat() == BMF_1BPP)) || bHalftone)
            {
                pxloOut = pxlo;
                pxlo    = NULL;
            }
            else
            {
                pxloOut = &xloIdent;
            }
        }
    }

    //
    // Synchronize with the device driver before touching the device surface.
    //

    pdoSrc.vSync(psoSrc,NULL,0);

    //
    // Compute what area of the source surface will actually be used.  We do
    // this so we never read off the end of the surface and fault or worse,
    // write bad pixels onto the target. Trim the source rectangle to the
    // source surface.
    //

    erclTrim *= *prcl;

    // WINBUG #263939 3-5-2000 bhouse Watchdog timeout problems
    // We suspend the watchdog here ... This code is just brain
    // dead and for various scenarios can cause us to hang within GDI
    // giving false positive WatchDog timeouts.  Maybe one day we will
    // re-write this brain dead code.... I'm not holding my breadth.

    if(pdoTrg.bValid() && pdoTrg.bDisplayPDEV())
        GreSuspendWatch(pdoTrg.ppdev, WD_DEVLOCK);
    
    if(pdoSrc.bValid() && pdoSrc.bDisplayPDEV())
        GreSuspendWatch(pdoSrc.ppdev, WD_DEVLOCK);

    //
    // If we have nothing left, we're done.
    //

    if (erclTrim.bEmpty())
    {
         bRet = TRUE;
    }
    else
    {
        //
        // Now we must worry about the source surface.  Its possible we are blitting
        // from an RLE to the VGA for instance.  We convert the surface to the same
        // bitmap format as the target for convience.
        //

        SURFMEM     dimoIn;
        SURFACE    *pSurfIn;
        RECTL       rclIn;
        RECTL      *prclIn;
        XLATEOBJ   *pxloIn;

        if (! ((pSurfSrc->iType() != STYPE_BITMAP) ||
               (pSurfSrc->iFormat() == BMF_4RLE)   ||
               (pSurfSrc->iFormat() == BMF_8RLE) )
           )
        {
            pSurfIn  = pSurfSrc;

            pxloIn = pxlo;

            prclIn = prcl;
        }
        else
        {
            DEVBITMAPINFO   dbmi;

            dbmi.cxBitmap = erclTrim.right - erclTrim.left + 1;
            dbmi.cyBitmap = erclTrim.bottom - erclTrim.top + 1;
            dbmi.hpal     = (HPALETTE) 0;
            dbmi.iFormat  = pSurfOut->iFormat();
            dbmi.fl       = pSurfSrc->bUMPD() ? UMPD_SURFACE : 0;

            dimoIn.bCreateDIB(&dbmi, (VOID *) NULL);

            if (!dimoIn.bValid())
            {
                bRet = FALSE;
                goto exit;
            }

            // The cursor should already be excluded at this point, so just copy
            // to the DIB.

            rclIn.left   = 0;
            rclIn.top    = 0;
            rclIn.right  = erclTrim.right - erclTrim.left;
            rclIn.bottom = erclTrim.bottom - erclTrim.top;

            (*PPFNGET(pdoSrc,CopyBits,pSurfSrc->flags()))(
                     dimoIn.pSurfobj(),
                     pSurfSrc->pSurfobj(),
                     (CLIPOBJ *) NULL,
                     pxlo,
                     &rclIn,
                     (POINTL *) &erclTrim);

            // Point at the new source

            rclIn.left   = prcl->left   - erclTrim.left;
            rclIn.top    = prcl->top    - erclTrim.top;
            rclIn.right  = prcl->right  - erclTrim.left;
            rclIn.bottom = prcl->bottom - erclTrim.top;

            pSurfIn  = dimoIn.ps;
            pxloIn = NULL;
            prclIn = &rclIn;

            // Adjust the trimmed source origin and extent

            erclTrim.right  -= erclTrim.left;
            erclTrim.bottom -= erclTrim.top;
            erclTrim.left = 0;
            erclTrim.top  = 0;
        }

        // Synchronize with the device driver before touching the device surface.

        {
            PDEVOBJ po(pSurfOut->hdev());
            po.vSync(pSurfOut->pSurfobj(),NULL,0);
        }

        //
        // Initialize the DDA
        //

        PLGDDA   *pdda = (PLGDDA *)PALLOCMEM(sizeof(PLGDDA),'addG');
        if (pdda)
        {
            if (!bInitPlgDDA(pdda, (RECTL *) &erclTrim, prclIn, pptfxOut))
            {
                bRet = TRUE;
            }
            else
            {
                PFN_PLGREAD     pfnRead  = apfnRead[pSurfIn->iFormat()];
                PFN_PLGWRITE    pfnWrite;
                PLGRUN         *prun;
                LONG            cjSpace = lSizeDDA(pdda) * (erclTrim.right - erclTrim.left + 2);

                if (bBogus)
                {
                    pdda->bOverwrite = TRUE;
                    pfnWrite = apfnBogus[iMode];
                }
                else
                {
                    pdda->bOverwrite = FALSE;
                    pfnWrite = apfnWrite[pSurfOut->iFormat()];
                }

                if (prun = (PLGRUN *) PALLOCMEM(cjSpace,'addG'))
                {
                    BYTE    *pjSrc = (BYTE *) pSurfIn->pvScan0() + pSurfIn->lDelta() * erclTrim.top;
                    BYTE    *pjMask;
                    POINTL   ptlMask;

                    if (pSurfMsk == (SURFACE *) NULL)
                    {
                        pjMask = (BYTE *) NULL;
                    }
                    else
                    {
                        ptlMask.x = erclTrim.left - prclIn->left + pptl->x;
                        ptlMask.y = erclTrim.top  - prclIn->top  + pptl->y;

                        pjMask = (BYTE *) pSurfMsk->pvScan0() + pSurfMsk->lDelta() * ptlMask.y;
                    }

                    // See if we can accelerate anything.

                    if ((pxloIn != NULL) && (pxloIn->flXlate & XO_TRIVIAL))
                    {
                        pxloIn = NULL;
                    }

                    //
                    // force DDA into clipping to destination surface!, this can be
                    // removed once dda doesn't go negatice!
                    //

                    if ((pcoOut == NULL) || (pcoOut->iDComplexity == DC_TRIVIAL))
                    {
                        ERECTL erclDest(0,0,pSurfOut->sizl().cx,pSurfOut->sizl().cy);

                        rmoOut.vSet((RECTL *) &erclDest);
                        ecoOut.vSetup(rmoOut.prgnGet(), erclDest, CLIP_FORCE);
                        pcoOut = &ecoOut;
                    }

                    //
                    // make sure it doesn't have a empty rectangle
                    //
                    if ((pcoOut->rclBounds.left < pcoOut->rclBounds.right) &&
                        (pcoOut->rclBounds.top < pcoOut->rclBounds.bottom))
                    {
                       for (LONG yRow = erclTrim.top; yRow < erclTrim.bottom; yRow++)
                       {
                           pdda->dsX = pdda->ds;

                           (*pfnWrite)(prun,
                                       (*pfnRead)(pdda,
                                                  prun,
                                                  pjSrc,
                                                  pjMask,
                                                  pxloIn,
                                                  erclTrim.left,
                                                  erclTrim.right,
                                                  ptlMask.x),
                                       pSurfOut,
                                       pcoOut);

                           vAdvYDDA(pdda);
                           pjSrc += pSurfIn->lDelta();

                           if (pjMask != (BYTE *) NULL)
                           {
                               pjMask += pSurfMsk->lDelta();
                           }
                       }

                       VFREEMEM(prun);

                       //
                       // See if we have drawn on the actual output surface.
                       //

                       if (pSurfOut == pSurfTrg)
                       {
                           bRet = TRUE;
                       }
                       else
                       {
                           BOOL bTmpRet = FALSE;

                           //
                           // If the source rectangle was reduced, then we have to
                           // create a mask for the target, so only the actual pels
                           // effected by the PlgBlt will be altered on the target.

                           SURFMEM     dimoMask;
                           SURFACE    *pSurfMask;

                           if (((prcl->right - prcl->left) == erclTrim.right) &&
                               ((prcl->bottom - prcl->top) == erclTrim.bottom) )
                           {
                               pSurfMask = (SURFACE *) NULL;
                               bTmpRet = TRUE;
                           }
                           else
                           {
                               DEVBITMAPINFO   dbmi;

                               dbmi.cxBitmap = erclDev.right + 1;
                               dbmi.cyBitmap = erclDev.bottom + 1;
                               dbmi.hpal     = (HPALETTE) 0;
                               dbmi.iFormat  = BMF_1BPP;
                               dbmi.fl       = pSurfTrg->bUMPD() ? UMPD_SURFACE : 0;

                               dimoMask.bCreateDIB(&dbmi, (VOID *) NULL);

                               if (dimoMask.bValid())
                               {
                                   SURFMEM   dimoTrim;

                                   dbmi.cxBitmap = erclTrim.right;
                                   dbmi.cyBitmap = erclTrim.bottom;
                                   dbmi.hpal     = (HPALETTE) 0;
                                   dbmi.iFormat  = BMF_1BPP;
                                   dbmi.fl       = pSurfTrg->bUMPD() ? UMPD_SURFACE : 0;

                                   dimoTrim.bCreateDIB(&dbmi, (VOID *) NULL);

                                   RGNMEMOBJTMP rmoMask;

                                   if (dimoTrim.bValid() &&
                                       rmoMask.bValid() )
                                   {
                                       rmoMask.vSet((RECTL *) &erclDev);

                                       ECLIPOBJ    ecoMask(rmoMask.prgnGet(), erclDev, CLIP_FORCE);

                                       //
                                       // Initialize the two bitmaps and call EngPlgBlt to create a pel
                                       // perfect mask for the reduced call.
                                       //

                                       if (EngEraseSurface(dimoMask.pSurfobj(),
                                                           &erclDev,
                                                           0L)                  &&
                                           EngEraseSurface(dimoTrim.pSurfobj(),
                                                           &erclTrim,
                                                           (ULONG)~0L)          &&
                                           EngPlgBlt(dimoMask.pSurfobj(),
                                                     dimoTrim.pSurfobj(),
                                                     (SURFOBJ *) NULL,
                                                     &ecoMask,
                                                     NULL,
                                                     (COLORADJUSTMENT *) NULL,
                                                     (POINTL *) NULL,
                                                     pptfxOut,
                                                     prclIn,
                                                     (POINTL *) NULL,
                                                     COLORONCOLOR) )
                                       {

                                           pSurfMask = dimoMask.ps;
                                           bTmpRet = TRUE;
                                       }
                                   }
                               }
                           }

                           // If we had to draw the target on a shadow, we need to copy it to the
                           // actual surface.  Since we don't clip to the shadow buffer, we need
                           // to merge the parallelogram into the clipobj and clip against this
                           // and call BitBlt.

                           PATHMEMOBJ  pmo;

                           if (bTmpRet &&
                               pmo.bValid())
                           {
                               //
                               // Create a parallelogram in drawing order.
                               //

                               POINTL  aptl[4];

                               aptl[0].x = pptfx[0].x;
                               aptl[0].y = pptfx[0].y;
                               aptl[1].x = pptfx[1].x;
                               aptl[1].y = pptfx[1].y;
                               aptl[2].x = pptfx[1].x + pptfx[2].x - pptfx[0].x;
                               aptl[2].y = pptfx[1].y + pptfx[2].y - pptfx[0].y;;
                               aptl[3].x = pptfx[2].x;
                               aptl[3].y = pptfx[2].y;

                               //
                               // Construct a path around the parallelogram
                               //

                               if ( (pmo.bMoveTo((EXFORMOBJ *) NULL, &aptl[0])) &&
                                    (pmo.bPolyLineTo((EXFORMOBJ *) NULL, &aptl[1], 3)) )
                               {
                                   //
                                   // Create a regions from it.
                                   //

                                   RGNMEMOBJTMP rmo(pmo, ALTERNATE);
                                   RGNMEMOBJTMP rmoTrg;

                                   if ( (rmo.bValid()) &&
                                        (rmoTrg.bValid()) )
                                   {
                                       //
                                       // Merge the region we just constructed with the clip region.
                                       //

                                       if ( ((pco == (CLIPOBJ *) NULL) &&
                                             (rmoTrg.bCopy(rmo)))             ||
                                            ((pco != (CLIPOBJ *) NULL) &&
                                             (rmoTrg.bMerge(rmo,
                                                            *((ECLIPOBJ *)pco),
                                                            gafjRgnOp[RGN_AND])))  )
                                       {

                                           ERECTL  ercl;

                                           rmoTrg.vGet_rcl(&ercl);

                                           // If we have a clipobj,
                                           // make sure that the bounds are 
                                           // tight to the destination rectangle
                                           // and there is intersection.
                                           if ((pco == NULL) ||
                                               bIntersect(&ercl, &pco->rclBounds, &ercl))
                                           {
                                               ECLIPOBJ eco(rmoTrg.prgnGet(), ercl, CLIP_FORCE);

                                               if (!eco.erclExclude().bEmpty())
                                               {
                                                   //
                                                   // Copy from the temporary to the target surface.
                                                   //

                                                   erclDev.left   += eptlDev.x;
                                                   erclDev.top    += eptlDev.y;
                                                   erclDev.right  += eptlDev.x;
                                                   erclDev.bottom += eptlDev.y;
                                                   eptlDev.x       = 0;
                                                   eptlDev.y       = 0;

                                                   //
                                                   // Inc the target surface uniqueness
                                                   //

                                                   INC_SURF_UNIQ(pSurfTrg);

                                                   if (!bHalftone)
                                                   {
                                                      (*(pSurfTrg->pfnBitBlt()))(
                                                          pSurfTrg->pSurfobj(),
                                                          dimoOut.pSurfobj(),
                                                          pSurfMask->pSurfobj(),
                                                          &eco,
                                                          pxloOut,
                                                          &erclDev,
                                                          &eptlDev,
                                                          &eptlDev,
                                                          (BRUSHOBJ *) NULL,
                                                          (POINTL *) NULL,
                                                          pSurfMask == (SURFACE *) NULL ? 0x0000CCCC : 0x0000AACC);
                                                   }
                                                   else
                                                   {
                                                      POINTL ptlBrushOrg;
                                                      ERECTL erclSrc(0, 0,
                                                                     erclDev.right-erclDev.left,
                                                                     erclDev.bottom-erclDev.top);

                                                      ptlBrushOrg.x=0; ptlBrushOrg.y=0;

                                                      (*PPFNGET(pdoTrg, StretchBlt, pSurfTrg->flags()))(
                                                          pSurfTrg->pSurfobj(),
                                                          dimoOut.pSurfobj(),
                                                          pSurfMask->pSurfobj(),
                                                          &eco,
                                                          pxloOut,
                                                          NULL,
                                                          &ptlBrushOrg,
                                                          &erclDev,
                                                          &erclSrc,
                                                          &eptlDev,
                                                          HALFTONE);
                                                   }
                                               }
                                           }

                                           bRet = TRUE;
                                       }
                                   }
                               }
                           }
                       }
                    }
                    else
                    {
                        VFREEMEM(prun);
                    }
                }
            }

            VFREEMEM(pdda);
        }

    }

exit:

    if(pdoTrg.bValid() && pdoTrg.bDisplayPDEV())
        GreResumeWatch(pdoTrg.ppdev, WD_DEVLOCK);

    if(pdoSrc.bValid() && pdoSrc.bDisplayPDEV())
        GreResumeWatch(pdoSrc.ppdev, WD_DEVLOCK);

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pooltrk.cxx ===
/******************************Module*Header*******************************\
* Module Name: pooltrk.cxx
*
* Pool allocation tracker.
*
* Created: 23-Feb-1998 20:09:03
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1998-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"
#include "pooltrk.hxx"

#if DBG

#ifdef _HYDRA_
#ifndef USER_POOL_TAGGING_ON

extern BOOL G_fConsole;

LIST_ENTRY gleDebugGrePoolTrackerHead;
HSEMAPHORE ghsemDebugGrePoolTracker = NULL;

/******************************Public*Routine******************************\
* DebugGrePoolTrackerInit
*
* Initialize the pool tracker.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
DebugGrePoolTrackerInit()
{
    //
    // Initialize doubly linked list used to track pool allocations.
    //

    InitializeListHead(&gleDebugGrePoolTrackerHead);

    //
    // Initialize the list semaphore.
    //
    // Note: allocate from non-tracked pool.  We will trust the pool
    // tracker to cleanup its own allocation.
    //

    ghsemDebugGrePoolTracker = GreCreateSemaphoreNonTracked();

    return (ghsemDebugGrePoolTracker != NULL);
}

/******************************Public*Routine******************************\
* DebugGrePoolTrackerAdd
*
* Add specified pool allocation to list.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
DebugGrePoolTrackerAdd(POOLTRACKHDR *pTrack, SIZE_T cj, ULONG ulTag)
{
    PLIST_ENTRY pleNew = (PLIST_ENTRY) pTrack;

    //
    // Setup pool track header.
    //
    // Sundown note: pool allocations in GRE should be < 4GB
    //

    pTrack->ulSize = cj;
    pTrack->ulTag  = ulTag;

    //
    // Lock the pool tracking list.
    //
    // During GRE initialization, we may be called while allocating
    // the ghsemDebugGrePoolTracker.  So we actually need to check
    // if it exists.
    //

    if (ghsemDebugGrePoolTracker) GreAcquireSemaphore(ghsemDebugGrePoolTracker);

    //
    // Insert into the pool tracking list.
    //

    InsertTailList(&gleDebugGrePoolTrackerHead, pleNew);

    //
    // Unlock the pool tracking list.
    //

    if (ghsemDebugGrePoolTracker) GreReleaseSemaphore(ghsemDebugGrePoolTracker);
}

/******************************Public*Routine******************************\
* DebugGrePoolTrackerRemove
*
* Remove specified pool allocation from list.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
DebugGrePoolTrackerRemove(POOLTRACKHDR *pTrack)
{
    PLIST_ENTRY pleVictim = (PLIST_ENTRY) pTrack;

    //
    // Lock the pool tracking list.
    //
    // During GRE initialization, we may be called while allocating
    // the ghsemDebugGrePoolTracker.  So we actually need to check
    // if it exists.
    //

    if (ghsemDebugGrePoolTracker) GreAcquireSemaphore(ghsemDebugGrePoolTracker);

    //
    // Remove entry from pool tracking list.
    //

    RemoveEntryList(pleVictim);

    //
    // Unlock the pool tracking list.
    //

    if (ghsemDebugGrePoolTracker) GreReleaseSemaphore(ghsemDebugGrePoolTracker);
}

/******************************Public*Routine******************************\
* DebugGreAllocPool
*
* Allocates paged pool and tracks it in the pool tracking list.
* Free with DebugGreFreePool.
*
*                 Buffer
*   pTrack --> +----------------+
*              | POOLTRACKHDR   |
*    pvRet --> +----------------+
*              | Returned       |
*              | Buffer         |
*              | Allocation     |
*              |                |
*                ...
*              |                |
*              +----------------+
*
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" PVOID
DebugGreAllocPool(SIZE_T ulBytes, ULONG ulTag)
{
    PVOID pv;

    //
    // If Hydra, adjust requested size to include tracking header.
    //
    // Sundown note: sizeof(POOLTRACKHDR) will fit into 32-bits.
    //

    if (!G_fConsole)
    {
        if (ulBytes <= (MAXULONG - sizeof(POOLTRACKHDR)))
            ulBytes += ((ULONG) sizeof(POOLTRACKHDR));
        else
            return NULL;
    }

    //
    // Allocate paged pool.
    //

    pv = ExAllocatePoolWithTag(
            (POOL_TYPE) (SESSION_POOL_MASK | PagedPool),
            ulBytes, ulTag);

    if (pv)
    {
        //
        // Tracking overhead if Hydra.
        //

        if (!G_fConsole)
        {
            //
            // Add allocation to tracking list.
            //

            POOLTRACKHDR *pTrack = (POOLTRACKHDR *) pv;

            DebugGrePoolTrackerAdd(pTrack, ulBytes, ulTag);

        #ifdef POOLTRACK_STACKTRACE_ENABLE
            //
            // Save the stack back trace.
            //

            ULONG ulHash;

            RtlZeroMemory(pTrack->apvStackTrace,
                          POOLTRACK_TRACESIZE * sizeof(PVOID));

            RtlCaptureStackBackTrace(1,
                                     POOLTRACK_TRACESIZE,
                                     pTrack->apvStackTrace,
                                     &ulHash);
        #endif

            //
            // Adjust return pointer to exclude tracking header.
            //

            pv = (PVOID) (pTrack + 1);
        }
    }

    return pv;
}

/******************************Public*Routine******************************\
* DebugGreAllocPoolNonPaged
*
* Allocates nonpaged pool and tracks it in the pool tracking list.
* Free with DebugGreFreePool.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" PVOID
DebugGreAllocPoolNonPaged(SIZE_T ulBytes, ULONG ulTag)
{
    PVOID pv;

    //
    // If Hydra, adjust requested size to include tracking header.
    //
    // Sundown note: sizeof(POOLTRACKHDR) will fit into 32-bits.
    //

    if (!G_fConsole)
    {
        ulBytes += ((ULONG) sizeof(POOLTRACKHDR));
    }

    //
    // Allocate nonpaged pool.
    //

    pv = ExAllocatePoolWithTag(
            (POOL_TYPE)NonPagedPool,
            ulBytes, ulTag);

    if (pv)
    {
        //
        // Tracking overhead if Hydra.
        //

        if (!G_fConsole)
        {
            //
            // Add allocation to tracking list.
            //

            POOLTRACKHDR *pTrack = (POOLTRACKHDR *) pv;

            DebugGrePoolTrackerAdd(pTrack, ulBytes, ulTag);

            //
            // Adjust return pointer to exclude tracking header.
            //

            pv = (PVOID) (pTrack + 1);
        }
    }

    return pv;
}

/******************************Public*Routine******************************\
* DebugGreFreePool
*
* Free pool memory allocated by DebugGreAllocPool and
* DebugGreAllocPoolNonPaged.  Removes the allocation from tracking list.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

extern "C" VOID
DebugGreFreePool(PVOID pv)
{
    if (pv)
    {
        //
        // Tracking overhead if Hydra.
        //

        if (!G_fConsole)
        {
            //
            // Find header and remove from tracking list.
            //

            POOLTRACKHDR *pTrack = ((POOLTRACKHDR *) pv) - 1;

            DebugGrePoolTrackerRemove(pTrack);

            //
            // Adjust pointer to base of allocation.
            //

            pv = (PVOID) pTrack;
        }

        //
        // Free the pool allocation.
        //

        ExFreePool(pv);
    }
}

/******************************Public*Routine******************************\
* DebugGreCleanupPoolTracker
*
* Frees any allocations remaining in the tracking list (but asserts so
* that debugger is informed that a leak exists).  Free resources used
* to maintain the tracking list.
*
* History:
*  23-Feb-1998 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
DebugGreCleanupPoolTracker()
{
    BOOL bTitle = FALSE;
    ULONG cLeaks = 0;
    volatile PLIST_ENTRY pleNext;

    //
    // Assert if list not empty (i.e., there are leaks!).
    //
    // What to do if there is a leak?
    //
    // Well, it might be enough just to look at the tags that leak.
    // If that doesn't provide enough detail to track the leak,
    // recompile with USER_POOL_TAGGING_ON defined in engine.h and
    // define POOL_ALLOC_TRACE in w32\w32inc\usergdi.h to use the
    // USER pool tracking code.  You'll have build a checked version
    // of win32k (clean build both USER and GDI), but this pool tracker
    // will record a stack trace for every allocation.  If we leak,
    // USER will assert during Hydra session shutdown and the userkdx
    // dpa extension will dump the allocations (use !dpa -ts 24 to
    // dump the leaked TAG_GDI allocations with a stack trace).
    //

    if (!IsListEmpty(&gleDebugGrePoolTrackerHead))
    {
        DbgPrint("DebugGreCleanupPoolTracker: "
                 "gleDebugGrePoolTrackerHead 0x%08lx not empty\n",
                 &gleDebugGrePoolTrackerHead);
        RIP("DebugGreCleanupPoolTracker: leak detected\n");
    }

    //
    // Free all allocations in the list.
    //

    pleNext = gleDebugGrePoolTrackerHead.Flink;

    while (pleNext != &gleDebugGrePoolTrackerHead)
    {
        //
        // Pool allocation starts after the POOLTRACKHDR.
        //

        PVOID pvVictim = (PVOID) (((POOLTRACKHDR *) pleNext) + 1);

        //
        // Count the number of leaked allocations.
        //

        cLeaks++;

        //
        // Print out the allocation information.
        //

        if (!bTitle)
        {
            DbgPrint("\nDebugGreCleanupPoolTracker: cleaning up pool allocations\n");
            DbgPrint("----------\t----------\t-----------------\n");
            DbgPrint("Address   \tSize      \tTag\n");
            DbgPrint("----------\t----------\t-----------------\n");
            bTitle = TRUE;
        }

        DbgPrint("0x%08lx\t0x%08lx\t0x%08lx (%c%c%c%c)\n",
                 pleNext,
                 ((POOLTRACKHDR *) pleNext)->ulSize,
                 ((POOLTRACKHDR *) pleNext)->ulTag,
                 ((((POOLTRACKHDR *) pleNext)->ulTag)      ) & 0xff,
                 ((((POOLTRACKHDR *) pleNext)->ulTag) >>  8) & 0xff,
                 ((((POOLTRACKHDR *) pleNext)->ulTag) >> 16) & 0xff,
                 ((((POOLTRACKHDR *) pleNext)->ulTag) >> 24) & 0xff);

        //
        // Delete the allocation.
        //

        DebugGreFreePool(pvVictim);

        //
        // Restart at the begining of the list since our
        // entry got deleted.
        //

        pleNext = gleDebugGrePoolTrackerHead.Flink;
    }

    if (bTitle)
    {
        DbgPrint("----------\t----------\t-----------------\n");
    }

    if (cLeaks)
    {
        DbgPrint("%ld allocations leaked\n\n", cLeaks);
    }

    //
    // Delete the list lock.
    //
    // Note that the list lock was allocated from non-tracked pool.
    // It is also a non-tracked semaphore - that is, it must be deleted
    // explicitly.
    //

    GreDeleteSemaphoreNonTracked(ghsemDebugGrePoolTracker);
    ghsemDebugGrePoolTracker = NULL;
}

#endif  //USER_POOL_TAGGING_ON

#endif  //_HYDRA_

#endif  //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rfntxlat.cxx ===
/******************************Module*Header*******************************\
* Module Name: rfntxlat.cxx
*
* Methods for translating wchars to hglyphs or pgd's
*
* Created: March 5, 1992
* Author: Paul Butzi
*
* Copyright (c) 1992-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

void RFONTOBJ::pfdg(FD_GLYPHSET *pfdg)
{
    prfnt->pfdg = pfdg;
}

/******************************Public*Routine******************************\
* void chglyGetAllGlyphHandles
*
* Get all the glyph handles for an RFONTOBJ
* return the number of handles
*
*
* History:
*  06-Mar-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/
COUNT RFONTOBJ::chglyGetAllHandles
(
    HGLYPH *pgh
)
{
// first check if this is one of the tt fonts which supports
// possibly more glyphs than can be accessed via fd_glyphset directly.
// In this case handles are the same as glyph indicies

    IFIMETRICS * pifi = prfnt->ppfe->pifi;

    ULONG cig = 0;

    if (pifi->cjIfiExtra > offsetof(IFIEXTRA, cig))
    {
        cig = ((IFIEXTRA *)(pifi + 1))->cig;
    }

    if (cig)
    {
        if (pgh)
        {
            for (ULONG hg = 0; hg < cig; hg++, pgh++)
                *pgh = hg;
        }

        return cig;
    }

    FD_GLYPHSET *pfdg = prfnt->pfdg;

    if ( pgh == NULL )
        return pfdg->cGlyphsSupported;

    for ( COUNT i = 0; i < pfdg->cRuns; i += 1 )
    {
        WCRUN *pwcr = &pfdg->awcrun[i];

        if ( pwcr->phg != NULL )
        {
            for ( COUNT j = 0; j < pwcr->cGlyphs; j += 1 )
            {
                *pgh = pwcr->phg[j];
                pgh += 1;
        }
    }
    else
    {
        for ( COUNT j = 0; j < pwcr->cGlyphs; j += 1 )
        {
        *pgh = pwcr->wcLow + j;
        pgh += 1;
        }
    }
    }
    return pfdg->cGlyphsSupported;
}


BYTE  acBits[16]  = {0,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4};

INT aiStart[17] = {0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768};


VOID RFONTOBJ::vXlatGlyphArray(WCHAR *pwc,UINT cwc,HGLYPH *phg, DWORD iMode, BOOL bSubset)
{
    FD_GLYPHSET *pgs = prfnt->pfdg;
    
    BOOL  bHorizGS = FALSE;
    ULONG iFont;
    PFE   *ppfeHoriz;

    iFont = prfnt->ppfe->iFont;

    // if this is used on @face font by font subsetting
    // we return the "base" glyph indices

    if (bSubset && iFont && !(iFont & 1))
    {
        PFEOBJ  pfeObj(ppfeHoriz = ((PFE**)(prfnt->pPFF->aulData))[(iFont - 1) & 0xFFFFFFFE]);
        FD_GLYPHSET  *pgsTmp;

        if (pfeObj.bValid() && (pgsTmp = pfeObj.pfdg()))
        {
            bHorizGS = TRUE;
            pgs = pgsTmp;
        }
    }

    if (pgs->cRuns == 0)
    {
        WARNING("vXlatGlyphArray - empty glyphset\n");

    	for (; cwc != 0; --cwc, ++phg)
        {
    		*phg = prfnt->hgDefault;
    	}
    	return;
    }
    
    WCRUN *pwcRunBase = pgs->awcrun;
    int    iMax  = (int) pgs->cRuns - 1;
    WCRUN *pwcRun;
    int    nwc;
    int    iThis;
    int    iFirst;
    int    cBits;
    HGLYPH hgReplace = (iMode == GGI_MARK_NONEXISTING_GLYPHS) ?
                       0xffffffff : prfnt->hgDefault;

// We should precompute this stuff.

// Count the bits.


    if (iMax > 0xFFFF)
      iMax = 0xFFFF;        // 65000 runs

    if ( iMax & 0xF000 )
      cBits = acBits[(iMax >> 12) & 0x00FF] + 12;
    else if (iMax & 0x0F00 )
      cBits = acBits[(iMax >>  8) & 0x00FF] +  8;
    else if (iMax & 0x00F0)
      cBits = acBits[(iMax >>  4) & 0x00FF] +  4;
    else
      cBits = acBits[iMax];

// Set the starting point.

    iFirst = aiStart[cBits];

    while (cwc)
    {
    // Handle a common case which otherwise causes us to do a lot of
    // useless searching.  It also guarantees that we never have to look
    // below run 0.

        if (*pwc < pwcRunBase->wcLow)
        {

            do { *phg++ = hgReplace; pwc++; cwc--; }
            while (cwc && (*pwc < pwcRunBase->wcLow));
            continue;
        }

    // Binary search to find a run for the first character.

        iThis = iFirst;

        switch (cBits)
        {
        case 16:
          iThis += (*pwc >= pwcRunBase[iThis].wcLow) ? 32768 : 0;
          iThis -= 16384;
        case 15:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 16384 : 0;
          iThis -= 8192;
        case 14:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 8192 : 0;
          iThis -= 4096;
        case 13:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 4096 : 0;
          iThis -= 2048;
        case 12:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 2048 : 0;
          iThis -= 1024;
        case 11:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 1024 : 0;
          iThis -= 512;
        case 10:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 512 : 0;
          iThis -= 256;
        case 9:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 256 : 0;
          iThis -= 128;
        case 8:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 128 : 0;
          iThis -= 64;
        case 7:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 64 : 0;
          iThis -= 32;
        case 6:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 32 : 0;
          iThis -= 16;
        case 5:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 16 : 0;
          iThis -= 8;
        case 4:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 8 : 0;
          iThis -= 4;
        case 3:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 4 : 0;
          iThis -= 2;
        case 2:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 2 : 0;
          iThis -= 1;
        case 1:
          iThis += ((iThis <= iMax) && (*pwc >= pwcRunBase[iThis].wcLow)) ? 1 : 0;
          iThis -= 1;
        case 0:
            break;
        }
        pwcRun = &pwcRunBase[iThis];     // This is our candidate.
        nwc = *pwc - pwcRun->wcLow;

        if (nwc >= pwcRun->cGlyphs)
        {
        // Oops, there is no such character.  Store the default.

#ifdef FE_SB
            if(bIsLinkedGlyph(*pwc) || bIsSystemTTGlyph(*pwc))
            {
                prfnt->flEUDCState |= EUDC_WIDTH_REQUESTED;
            }
#endif
            *phg++ = hgReplace; pwc++; cwc--;

            continue;
        }

    // Here's the better case, we found a run.  Let's try to use it a lot.

        if (pwcRun->phg != NULL)
        {
            do { *phg++ = pwcRun->phg[nwc]; pwc++; cwc--; }
            while
            (
                cwc
                && ((nwc = *pwc - pwcRun->wcLow) >= 0)
                && (nwc < (int) pwcRun->cGlyphs)
            );
        }
        else
        {
            do { *phg++ = *pwc++; cwc--; }
            while
            (
                cwc
                && ((nwc = *pwc - pwcRun->wcLow) >= 0)
                && (nwc < (int) pwcRun->cGlyphs)
            );
        }
    }

    
    if (bHorizGS)
    {
        PFEOBJ  pfeObj(ppfeHoriz);

        pfeObj.vFreepfdg();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rfntobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: rfntobj.cxx                                                 *
*                                                                          *
* Non-inline methods for realized font objects.                            *
*                                                                          *
* Created: 30-Oct-1990 09:32:48                                            *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
* Copyright (c) 1993-1999 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.hxx"
#include "flhack.hxx"
#ifdef _HYDRA_
#include "muclean.hxx"
#endif

#include "winsta.h"

//
// Storage for static globals in rfntobj.hxx
//

extern BOOL G_fConsole;

extern "C" USHORT gProtocolType;
#define IsRemoteConnection() (gProtocolType != PROTOCOL_CONSOLE)

FONTFILE_PRINTKVIEW  *gpPrintKViewList = NULL;
HSEMAPHORE ghsemPrintKView;

NTSTATUS  MapFontFileInKernel(void*, void**);
VOID vUnmapFontFileInKernel(void* pvKView);
void vCleanupPrintKViewList();

GAMMA_TABLES RFONTOBJ::gTables =
{
  {
        0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00
    ,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00,   0x00
    ,   0x00,   0x00,   0x00,   0x01,   0x01,   0x01,   0x01,   0x01
    ,   0x01,   0x01,   0x01,   0x01,   0x01,   0x02,   0x02,   0x02
    ,   0x02,   0x02,   0x02,   0x02,   0x03,   0x03,   0x03,   0x03
    ,   0x03,   0x03,   0x04,   0x04,   0x04,   0x04,   0x05,   0x05
    ,   0x05,   0x05,   0x06,   0x06,   0x06,   0x06,   0x07,   0x07
    ,   0x07,   0x08,   0x08,   0x08,   0x08,   0x09,   0x09,   0x09
    ,   0x0A,   0x0A,   0x0B,   0x0B,   0x0B,   0x0C,   0x0C,   0x0D
    ,   0x0D,   0x0D,   0x0E,   0x0E,   0x0F,   0x0F,   0x10,   0x10
    ,   0x11,   0x11,   0x12,   0x12,   0x13,   0x13,   0x14,   0x14
    ,   0x15,   0x15,   0x16,   0x17,   0x17,   0x18,   0x18,   0x19
    ,   0x1A,   0x1A,   0x1B,   0x1C,   0x1C,   0x1D,   0x1E,   0x1E
    ,   0x1F,   0x20,   0x20,   0x21,   0x22,   0x23,   0x23,   0x24
    ,   0x25,   0x26,   0x26,   0x27,   0x28,   0x29,   0x2A,   0x2A
    ,   0x2B,   0x2C,   0x2D,   0x2E,   0x2F,   0x30,   0x31,   0x31
    ,   0x32,   0x33,   0x34,   0x35,   0x36,   0x37,   0x38,   0x39
    ,   0x3A,   0x3B,   0x3C,   0x3D,   0x3E,   0x3F,   0x40,   0x41
    ,   0x42,   0x44,   0x45,   0x46,   0x47,   0x48,   0x49,   0x4A
    ,   0x4B,   0x4D,   0x4E,   0x4F,   0x50,   0x51,   0x53,   0x54
    ,   0x55,   0x56,   0x58,   0x59,   0x5A,   0x5C,   0x5D,   0x5E
    ,   0x60,   0x61,   0x62,   0x64,   0x65,   0x66,   0x68,   0x69
    ,   0x6B,   0x6C,   0x6D,   0x6F,   0x70,   0x72,   0x73,   0x75
    ,   0x76,   0x78,   0x79,   0x7B,   0x7C,   0x7E,   0x80,   0x81
    ,   0x83,   0x84,   0x86,   0x88,   0x89,   0x8B,   0x8D,   0x8E
    ,   0x90,   0x92,   0x93,   0x95,   0x97,   0x99,   0x9A,   0x9C
    ,   0x9E,   0xA0,   0xA1,   0xA3,   0xA5,   0xA7,   0xA9,   0xAB
    ,   0xAD,   0xAE,   0xB0,   0xB2,   0xB4,   0xB6,   0xB8,   0xBA
    ,   0xBC,   0xBE,   0xC0,   0xC2,   0xC4,   0xC6,   0xC8,   0xCA
    ,   0xCC,   0xCE,   0xD0,   0xD2,   0xD5,   0xD7,   0xD9,   0xDB
    ,   0xDD,   0xDF,   0xE1,   0xE4,   0xE6,   0xE8,   0xEA,   0xED
    ,   0xEF,   0xF1,   0xF3,   0xF6,   0xF8,   0xFA,   0xFD,   0xFF
  }
  ,
  {
        0x00,   0x18,   0x20,   0x27,   0x2C,   0x30,   0x34,   0x37
    ,   0x3B,   0x3E,   0x40,   0x43,   0x46,   0x48,   0x4A,   0x4D
    ,   0x4F,   0x51,   0x53,   0x55,   0x56,   0x58,   0x5A,   0x5C
    ,   0x5D,   0x5F,   0x61,   0x62,   0x64,   0x65,   0x67,   0x68
    ,   0x6A,   0x6B,   0x6C,   0x6E,   0x6F,   0x70,   0x72,   0x73
    ,   0x74,   0x75,   0x76,   0x78,   0x79,   0x7A,   0x7B,   0x7C
    ,   0x7D,   0x7F,   0x80,   0x81,   0x82,   0x83,   0x84,   0x85
    ,   0x86,   0x87,   0x88,   0x89,   0x8A,   0x8B,   0x8C,   0x8C
    ,   0x8E,   0x8F,   0x90,   0x91,   0x91,   0x92,   0x93,   0x94
    ,   0x95,   0x96,   0x97,   0x98,   0x98,   0x99,   0x9A,   0x9A
    ,   0x9C,   0x9D,   0x9D,   0x9E,   0x9F,   0xA0,   0xA1,   0xA1
    ,   0xA2,   0xA3,   0xA4,   0xA5,   0xA5,   0xA6,   0xA7,   0xA7
    ,   0xA8,   0xA9,   0xAA,   0xAB,   0xAB,   0xAC,   0xAD,   0xAD
    ,   0xAE,   0xAF,   0xB0,   0xB0,   0xB1,   0xB2,   0xB2,   0xB2
    ,   0xB4,   0xB4,   0xB5,   0xB6,   0xB6,   0xB7,   0xB8,   0xB8
    ,   0xB9,   0xBA,   0xBA,   0xBB,   0xBC,   0xBC,   0xBD,   0xBD
    ,   0xBE,   0xBF,   0xC0,   0xC0,   0xC1,   0xC1,   0xC2,   0xC3
    ,   0xC3,   0xC4,   0xC4,   0xC5,   0xC6,   0xC6,   0xC7,   0xC7
    ,   0xC8,   0xC9,   0xC9,   0xCA,   0xCA,   0xCB,   0xCC,   0xCC
    ,   0xCD,   0xCD,   0xCE,   0xCE,   0xCF,   0xD0,   0xD0,   0xD0
    ,   0xD1,   0xD2,   0xD2,   0xD3,   0xD3,   0xD4,   0xD4,   0xD5
    ,   0xD6,   0xD6,   0xD7,   0xD7,   0xD8,   0xD8,   0xD9,   0xD9
    ,   0xDA,   0xDA,   0xDB,   0xDB,   0xDC,   0xDC,   0xDD,   0xDD
    ,   0xDE,   0xDE,   0xDF,   0xE0,   0xE0,   0xE1,   0xE1,   0xE1
    ,   0xE2,   0xE3,   0xE3,   0xE4,   0xE4,   0xE5,   0xE5,   0xE5
    ,   0xE6,   0xE6,   0xE7,   0xE7,   0xE8,   0xE8,   0xE9,   0xE9
    ,   0xEA,   0xEA,   0xEB,   0xEB,   0xEC,   0xEC,   0xED,   0xED
    ,   0xEE,   0xEE,   0xEF,   0xEF,   0xEF,   0xF0,   0xF0,   0xF0
    ,   0xF1,   0xF2,   0xF2,   0xF3,   0xF3,   0xF4,   0xF4,   0xF5
    ,   0xF5,   0xF5,   0xF6,   0xF6,   0xF7,   0xF7,   0xF8,   0xF8
    ,   0xF9,   0xF9,   0xF9,   0xFA,   0xFA,   0xFB,   0xFB,   0xFC
    ,   0xFC,   0xFC,   0xFD,   0xFD,   0xFE,   0xFE,   0xFF,   0xFF
 }
};

LONG lNormAngle(LONG lAngle);

BOOL
bGetNtoWScales (
    EPOINTFL *peptflScale, // return address of scaling factors
    XDCOBJ& dco,            // defines device to world transformation
    PFD_XFORM pfdx,        // defines notional to device transformation
    PFEOBJ& pfeo,          // defines baseline direction
    BOOL *pbIdent          // return TRUE if NtoW is identity (with repsect
                           // to EVECTFL transormations, which ignore
                           // translations)
    );

//
// The iUniqueStamp is protected by the ghsemRFONTList semaphore.
//

ULONG iUniqueStamp;

// Maximum number of RFONTs allowed on the PDEV inactive list.

#define     cMaxInactiveRFONT       32

// Device height over which we will cache PATHOBJ's instead of bitmaps.

ULONG gulOutlineThreshold = 800;


/******************************Public*Routine******************************\
* ulSimpleDeviceOrientation                                                *
*                                                                          *
* Attempts to calculate a simple orientation angle in DEVICE coordinates.  *
* This only ever returns multiples of 90 degrees when it succeeds.  If the *
* calculation would be hard, it just returns 3601.                         *
*                                                                          *
* Note that the text layout code, for which the escapement and orientation *
* are recorded in the RFONT, always considers its angles to be measured    *
* from the x-axis towards the positive y-axis.  (So that a unit vector     *
* will have a y component equal to the cosine of the angle.)  This is NOT  *
* what an application specifies in world coordinates!                      *
*                                                                          *
*  Sat 05-Jun-1993 -by- Bodin Dresevic [BodinD]                            *
* Wrote it.  It looks more formidable than it is.  It actually doesn't     *
* execute much code.                                                       *
\**************************************************************************/

ULONG ulSimpleDeviceOrientation(RFONTOBJ &rfo)
{
// Calculate the orientation in device space.

    INT sx = (INT) rfo.prfnt->pteUnitBase.x.lSignum();
    INT sy = (INT) rfo.prfnt->pteUnitBase.y.lSignum();

// Exactly one of these must be zero (for the orientation to be simple).

    if ((sx^sy)&1)
    {
    // Calculate the following angles:
    //
    //   sx = 00000001 :    0
    //   sy = 00000001 : 2700
    //   sx = FFFFFFFF : 1800
    //   sy = FFFFFFFF :  900

        ULONG ulOrientDev = (sx & 1800) | (sy & 900) | ((-sy) & 2700);

        return(ulOrientDev);

    }

// If it's not simple, return an answer out of range.

    return(3601);
}

/******************************Public*Routine******************************\
* VOID RFONTOBJ::RFONTOBJ (PRFONT prfnt)
*
* Deletion Constructor for RFONTOBJ.  Note that this is only used
* in DC deletion, where we create the RFONTOBJ only to let it expire.
*
* We set up the RFONTOBJ only to unlock the handle and blow away the
* rfont.
*
* Ok, so it's sleazy.  I couldn't think of a cleaner way.  Sue me.
*
* History:
*  06-Feb-92 -by- Paul Butzi
* Wrote it.
\**************************************************************************/
RFONTOBJ::RFONTOBJ (PRFONT _prfnt)
{
    prfnt = _prfnt;
    if (prfnt != NULL)
    {
        vMakeInactive();

        prfnt = (PRFONT)NULL;
    }
}

/******************************Public*Routine******************************\
* RFONTOBJ::vInit (dco, bNeedPaths)                                        *
*                                                                          *
* Constructor for a realized font user object.  More complicated than most *
* contructors, this one doesn't even take an handle as an input.  Instead, *
* it accepts a dc reference.  This constructor creates a user object for   *
* the font realization for the font which is currently selected into the   *
* DC.  The name of the game here is to be fast in the common case, which   *
* is that the LFONT selection has not changed since the last time we were  *
* here.                                                                    *
*                                                                          *
* Note that the destructor for this class DOES NOT unlock the object.      *
* That only happens when the object is deselected in the routine or in the *
* sleazy deselection constructor above.                                    *
*                                                                          *
* History:                                                                 *
*                                                                          *
*  15-Nov-1995 -by- Kirk Olynyk [kirko]                                    *
* Renamed from vInit to  to bInit. bInit is called by a stub called vInit  *
* If the return value is true then vInit calls vGetCache(), if the         *
* return value is false then vInit does not call vGetCache. This assures   *
* that the last thing that a valid construtor does is lock the cache       *
* semaphore. Before this change, the PFFREFOBJ destructor could sneak      *
* in and acquire the font semaphore inside a cache critical section.       *
*                                                                          *
*  Tue 10-Mar-1992 18:59:54 -by- Charles Whitmer [chuckwh]                 *
* Made this, the body of the constructor, optional.                        *
*                                                                          *
*  31-Jan-1992 -by- Paul Butzi                                             *
* Serious rewrite.                                                         *
*                                                                          *
*  30-Oct-1990 -by- Gilman Wong [gilmanw]                                  *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bGrayRequestTheSame(XDCOBJ &dco)
{
    BOOL bRet = TRUE;

// if gulFontInformation did change, this would only matter to tt and ps fonts
// and if this is a screen or memory dc

    if (dco.bDisplay() || (dco.dctp() == DCTYPE_MEMORY))
    {
        PRFONT prfnt = dco.pdc->prfnt();

        if (prfnt->fobj.flFontType & (TRUETYPE_FONTTYPE|FO_POSTSCRIPT))
        {
            FLONG  flRequest = 0;

            if (gulFontInformation & FE_AA_ON)
            {
                flRequest |= FO_GRAY16;
                if (gulFontInformation & FE_CT_ON)
                    flRequest |= FO_CLEARTYPE_X;
            }

            if (prfnt->fobj.flFontType & TRUETYPE_FONTTYPE)
            {
                if (flRequest != (prfnt->fobj.flFontType & (FO_GRAY16 | FO_CLEARTYPE_X)))
                    return FALSE;
            }
            else // (prfnt->fobj.flFontType & FO_POSTSCRIPT)
            {
                if ((flRequest & FO_GRAY16) != (prfnt->fobj.flFontType & FO_GRAY16))
                    return FALSE;
            }

            if ((prfnt->fobj.flFontType & (FO_GRAY16 | FO_CLEARTYPE_X)) && IsRemoteConnection())
            {
                // the session got changed from console to remote and we need to force ClearType and gray antialiazing off
                return FALSE;
            }

        }
    }
    return bRet;
}


BOOL RFONTOBJ::bInit(XDCOBJ &dco, BOOL bNeedPaths, FLONG flType)
{
//
// We start out with the currently selected RFONT.
// That way, if we deselect it, we will unlock it!
//
    prfnt = dco.pdc->prfnt();

// Early out--maybe the font has not changed.

    if
    (
        bValid()                                            &&
        (dco.pdc->hlfntNew() == dco.pdc->hlfntCur())
    )
    {
        if
        (
            (iGraphicsMode() == dco.pdc->iGraphicsMode())     &&
            (bNeedPaths == prfnt->bNeededPaths)               &&
            (flType == (prfnt->flType & RFONT_TYPE_MASK))     &&
            bGrayRequestTheSame(dco)                          &&
            !dco.pdc->bUseMetaPtoD()
        )
        {

        // xform must be initialiazed before checking
        // dco.pdc->bXFormChange()

            EXFORMOBJ xo(dco, WORLD_TO_DEVICE);
            ASSERTGDI(xo.bValid(),
                "gdisrv!RFONTOBJ(dco) - invalid xform in dcof\n"
                );


        // bNeedPath clause is added to the above check since last time
        // this font could have been realized with bitmaps or metrics only
        // rather than with paths [bodind]

            if (!dco.pdc->bXFormChange())

            {
            // Since the LFONT  and xform have not changed, we know that we
            // already have the right RFONT selected into the DC
            // so we are just going to use it.  Remember that if it is
            // already selected it is also locked down.

                return(TRUE);
            }
            else
            {
            // Get World to Device transform (but with translations removed),
            // check if it happens to be to essentially the same as the old one


                if (xo.bEqualExceptTranslations(&(prfnt->mxWorldToDevice)))
                {
                    dco.pdc->vXformChange(FALSE);
                    return(TRUE);
                }
            }
        }
    }
    else
    {
    // LogFont has definitely changed, so update the current handle.

        dco.pdc->hlfntCur(dco.pdc->hlfntNew());
    }

// Get PDEV user object (need for bFindRFONT).  We also need to make
// sure that we have loaded device fonts before we go off to the font mapper.
// this must be done before the ghsemPublicPFT is locked down.

    PDEVOBJ pdo(dco.hdev());
    ASSERTGDI(pdo.bValid(), "gdisrv!RFONTOBJ(dco): bad pdev in dc\n");

    if (!pdo.bGotFonts())
        pdo.bGetDeviceFonts();

// If we get to here, either the LFONT has changed since the last
// text operation, or the XFORM has changed.  In either case, we'll look
// on the list of RFONTs on the pdev to see if we can find the right
// realization.  If not, we'll just have to realize it now.

    vMakeInactive();    // deselects the rfont

//
// Now we have no selected RFONT.  We're going to track one down
// that corresponds to the current XFORM and LFONT,
// and 'select' it.

// Lock and Validate the LFONTOBJ user object.

    LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);
    if (!lfo.bValid())
    {
        WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        dco.pdc->prfnt(prfnt);
        return(FALSE);
    }

// This is an opportune time to update the fields in the DC that
// are cached from the LFONTOBJ...

    dco.pdc->flSimulationFlags(lfo.flSimulationFlags());

// Note that our internal angles are always towards the positive y-axis,
// but at the API they are towards the negative y-axis.


    dco.pdc->lEscapement(lNormAngle(-lfo.lEscapement()));

//
// Now we're ready to track down this RFONT we want...
//

    PFE     *ppfe;          // realize this font
    FD_XFORM fdx;           // realize with this notional to device xform
    FLONG    flSim;         // simulation flags for realization
    POINTL   ptlSim;        // for bitmap scaling simulations
    FLONG    flAboutMatch;  // info about how the font mapping was done

// We will hold a reference to whatever PFF we map to while trying to
// realize the font.

    PFFREFOBJ pffref;

// Temporarily grab the global font semaphore to do the mapping.

    {
    // Stabilize the public PFT for mapping.

        SEMOBJ  so(ghsemPublicPFT);

    // LFONTOBJ::ppfeMapFont returns a pointer to the physical font face and
    // a simulation type (ist)

        ppfe = lfo.ppfeMapFont(dco, &flSim, &ptlSim, &flAboutMatch, flType & RFONT_TYPE_HGLYPH);

    // Compute the Notional to Device transform for this realization.

        PFEOBJ  pfeo(ppfe);
        IFIOBJ  ifio(pfeo.pifi());

        ASSERTGDI(pfeo.bValid(), "gdisrv!RFONTOBJ(dco): bad ppfe from mapping\n");

    // Map mode settings have no effect on stock logfont under Windows.
    // App PeachTree accounting relies on this behavior for postscript
    // printing works properly.

        BOOL   bIgnoreMapMode = (!(pdo.bDisplayPDEV()) && (lfo.fl() & LF_FLAG_STOCK) );

        if (
            !pfeo.bSetFontXform(
                dco, lfo.plfw(),
                &fdx,
                bIgnoreMapMode ? ND_IGNORE_MAP_MODE : 0,
                flSim,
                (POINTL* const) &ptlSim,
                ifio,
                FALSE
                )
        )
        {
            WARNING("gdisrv!RFONTOBJ(dco): failed to compute font transform\n");
            prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
            dco.pdc->prfnt(prfnt);
            return(FALSE);
        }

    // this is needed only by ttfd to support win31 hack: VDMX XFORM QUANTIZING
    // NOTE: in the case that the requested height is 0 we will pick a default
    // value which represent the character height and not the cell height for
    // Win 3.1 compatibility.  Thus I have he changed this check to be <= 0
    // from just < 0. [gerritv]


        if (ifio.bTrueType() && (lfo.plfw()->lfHeight <= 0))
            flSim |= FO_EM_HEIGHT;

    // Tell PFF about this new reference, and then release the global sem.
    // Note that vInitRef() must be called while holding the semaphore.

        pffref.vInitRef(pfeo.pPFF());
    }

// go find the font

    EXFORMOBJ xoWtoD(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xoWtoD.bValid(), "gdisrv!RFONTOBJ(dco) - \n");


// When looking for an RFONT it is important that we don't consider those
// who have small metrics in the GLYPHDATA cache if there is any possibility
// that we will hit the G1,G2,or G3 cases in the glyph layout code.  We will
// possibly hit this if the escapment in the LOGFONT is non-zero or the
// WorldToDevice XFORM is more than simple scaling or has negative values is
// M11 or M22.


    BOOL bSmallMetricsOk;

    if( ( dco.pdc->lEscapement() == 0 ) &&
         xoWtoD.bScale()  &&
         !xoWtoD.efM22().bIsNegative() &&
         !xoWtoD.efM11().bIsNegative() )
    {
        bSmallMetricsOk = TRUE;
    }
    else
    {
        bSmallMetricsOk = FALSE;
    }


// Attempt to find an RFONT in the lists cached off the PDEV.  Its transform,
// simulation state, style, etc. all must match.

    if
    (
        bFindRFONT
        (
            &fdx,
            flSim,
            0, // lfo.pelfw()->elfStyleSize,
            pdo,
            &xoWtoD,
            ppfe,
            bNeedPaths,
            dco.pdc->iGraphicsMode(),
            bSmallMetricsOk,
            flType
        )
    )
    {
        dco.pdc->prfnt(prfnt);

        dco.pdc->vXformChange(FALSE);

        return(TRUE);
    }

//
// if we get here, we couldn't find an appropriate font realization.
// Now, we are going to create one just for us to use.
//


    if ( !bRealizeFont(&dco,
                       &pdo,
                       lfo.pelfw(),
                       ppfe,
                       &fdx,
                       (POINTL* const) &ptlSim,
                       flSim,
                       0, // lfo.pelfw()->elfStyleSize,
                       bNeedPaths,
                       bSmallMetricsOk, flType) )
    {
        WARNING1("gdisrv!RFONTOBJ(dco): realization failed, RFONTOBJ invalidated\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid
        dco.pdc->prfnt(prfnt);

        return(FALSE);
    }
    ASSERTGDI(bValid(), "gdisrv!RFONTOBJ(dco): invalid hrfnt from realization\n");


// We created a new RFONT, we better hold the PFF reference!

    pffref.vKeepIt();

// Select this into the DC if successful.

    dco.pdc->prfnt(prfnt);

// Finally, grab the cache semaphore.

    dco.pdc->vXformChange(FALSE);

    return(TRUE);
}

/******************************Private*Routine******************************\
* RFONTOBJ::bMatchRealization()                                            *
*                                                                          *
* Return if prfnt matches a font realization caller wants.                 *
*                                                                          *
* History:                                                                 *
*  Wed 13-Sep-00 -by- Michael Leonov [mleonov]                             *
* Moved diplicating code from bFindRFONT into this function.               *
*                                                                          *
\**************************************************************************/
BOOL RFONTOBJ::bMatchRealization(
    PFD_XFORM   pfdx,
    FLONG       flSim,
    ULONG       ulStyleHt,
    EXFORMOBJ * pxoWtoD,
    PFE       * ppfe,
    BOOL        bNeedPaths,
    INT         iGraphicsMode,
    BOOL        bSmallMetricsOk,
    FLONG       flType
)
{
    if (prfnt->ppfe != ppfe)
        return FALSE;

    if (flType != (prfnt->flType & RFONT_TYPE_MASK))
        return FALSE;

    FLONG flXOR = prfnt->fobj.flFontType ^ flSim; // set the bits that are different
    if ((flXOR & (FO_EM_HEIGHT | FO_SIM_BOLD | FO_SIM_ITALIC)) == 0 )
    {
        flXOR &= (FO_GRAY16 | FO_CLEARTYPE_X | FO_CLEARTYPENATURAL_X); // focus just on ct and aa
        

        if (flXOR)
        {
            // The gray bits disagree but we still have a chance.
            // If the request is for gray but the font cannot
            // provide gray fonts at this particular font size
            // then this realization is OK

            if (flSim & FO_GRAY16)
            {
                if (prfnt->fobj.flFontType & FO_NOGRAY16)
                {
                    flXOR &= (FO_CLEARTYPE_X | FO_CLEARTYPENATURAL_X); // still need to look if we ask for the same AA type
                }
            }

            // If asking font sets CT bit but Rfont in cache doesn't set CT bit 
            // and FO_GRAY16 bit sets, then we assume this font cannot provide
            // CT at this size. So this realization is OK

            if ( (flSim & FO_CLEARTYPE_X) && !(prfnt->fobj.flFontType & FO_CLEARTYPE_X) )
            {
                if (prfnt->fobj.flFontType & FO_NOCLEARTYPE)
                {
                    flXOR = 0;
                }
            }
        }
        if (flXOR == 0)
          if (prfnt->fobj.ulStyleSize == ulStyleHt)
            if (bMatchFDXForm(pfdx))
              if ( bNeedPaths == prfnt->bNeededPaths )
                if ( !pxoWtoD || pxoWtoD->bEqualExceptTranslations(&(prfnt->mxWorldToDevice)))
                  if (prfnt->iGraphicsMode == iGraphicsMode)
                    if ( (!bSmallMetricsOk ) ? !(prfnt->cache.bSmallMetrics) : TRUE )
                    {
                        return TRUE;
                    }
    }
    return FALSE;
}


/******************************Public*Routine******************************\
* RFONTOBJ::bFindRFONT()                                                   *
*                                                                          *
* Find the rfont on the chain on the pdev, if it exists.                   *
*                                                                          *
* History:                                                                 *
*  Mon 08-Feb-1993 11:26:31 -by- Charles Whitmer [chuckwh]                 *
* Added dependency on graphics mode.                                       *
*                                                                          *
*  10-Feb-92 -by- Paul Butzi                                               *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RFONTOBJ::bFindRFONT(
    PFD_XFORM  pfdx,
    FLONG      flSim,
    ULONG      ulStyleHt,
    PDEVOBJ&   pdo,
    EXFORMOBJ *pxoWtoD,
    PFE       *ppfe,
    BOOL       bNeedPaths,
    INT        iGraphicsMode,
    BOOL       bSmallMetricsOk,
    FLONG      flType
)
{
    ASSERTGDI(prfnt == NULL,
        "gdisrv!RFONTOBJ:bFindRFONT - prfnt != NULL");

    SEMOBJ so(ghsemRFONTList);

//
// Search active list.  If we find it, just increment selection
// count and leave.
//

    for (  prfnt = pdo.prfntActive();
                prfnt != (PRFONT)NULL;
                prfnt = prfnt->rflPDEV.prfntNext)
    {
        ASSERTGDI(prfnt->cSelected >= 1,
                "gdisrv!RFONTOBJ::bFindRFONT - cSelected < 1 on active list\n");
        if (bMatchRealization(
            pfdx,
            flSim,
            ulStyleHt,
            pxoWtoD,
            ppfe,
            bNeedPaths,
            iGraphicsMode,
            bSmallMetricsOk,
            flType
            ))
        {
            prfnt->cSelected += 1;
            return TRUE;
        }
    }

//
// Search inactive list.  If we find it, we must take it off the
// inactive list and put it on the active list.
//
    PRFONT prfntLast = (RFONT*) NULL;
    for (  prfnt = pdo.prfntInactive();
                prfnt != NULL;
                prfntLast = prfnt, prfnt = prfnt->rflPDEV.prfntNext)
    {
        ASSERTGDI(prfnt->cSelected == 0,
                "gdisrv!RFONTOBJ::bFindRFONT - cSelected != 0 on inactive list\n");

        if (bMatchRealization(
            pfdx,
            flSim,
            ulStyleHt,
            pxoWtoD,
            ppfe,
            bNeedPaths,
            iGraphicsMode,
            bSmallMetricsOk,
            flType
            ))
        {
            // first, take it off inactive list

            PRFONT prfntHead = pdo.prfntInactive();
            vRemove(&prfntHead, PDEV_LIST);
            pdo.prfntInactive(prfntHead);   // vRemove MAY change head of list

            pdo.cInactive(pdo.cInactive()-1);

            // finally, put it on the active list and increment Selected count

            prfntHead = pdo.prfntActive();
            vInsert(&prfntHead, PDEV_LIST);
            pdo.prfntActive(prfntHead);     // vInsert changes head of list

            prfnt->cSelected = 1;

            return TRUE;
        }
    }

    prfnt = (RFONT*) NULL;
    return FALSE;
}

/******************************Public*Routine******************************\
* RFONTOBJ::VerifyCacheSemaphore
*
* Useful debugging code to verify the semaphore release
*
* History:
*
* 5-4-2000 Yung-Jen Tony Tsai 
* Write it.
\**************************************************************************/

#ifdef FE_SB

/******************************Public*Routine******************************\
* RFONTOBJ::bMakeInactiveHelper()
*
* Take the rfont off the active list, put on the inactive list, Return a
* list of linked fonts to deactivate.
*
* History:
*
*  13-Jan-95 -by- Hideyuki Nagase [hideyukn]
* Rewrite it.
*
*  29-Sep-93 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bMakeInactiveHelper(PRFONT *pprfnt)
{
    BOOL bLockEUDC = FALSE;

// Quick out if NULL or already inactive.

    if ((prfnt == NULL) || (prfnt->cSelected == 0))
        return(bLockEUDC);

// If prfVictim is changed to a valid pointer, then a victim was selected
// off the inactive list for deletion.

    PRFONT prfVictim = PRFNTNULL;

    {
        // in order to avoid a deadlock (ghsemRFONTList, ghsemEUDC1)
        // we increament the gcEUDCCount first

        if (pprfnt != NULL)
        {
            INCREMENTEUDCCOUNT;
        }
        
        SEMOBJ so(ghsemRFONTList);

    // Since RFONT is being deselected from a DC, remove a reference count.

        prfnt->cSelected -= 1;
        
    // If no more references, take the RFONT off the active list.

        if ( prfnt->cSelected == 0 )
        {

         // if pprfnt is not null, enumrate EUDC RFONT, and store pprfnt array.
                                                 
            if(pprfnt != NULL)
            {
                if(prfnt->prfntSystemTT)
                {
                    *pprfnt++ = prfnt->prfntSystemTT;
                    prfnt->prfntSystemTT = NULL;
                }
    
             // We need to accumulate a list of Linked/EUDC RFONTS and deactive
             // if pprfnt is not null, enumrate EUDC RFONT, and store pprfnt array.
                
                bLockEUDC = TRUE;

                if( prfnt->prfntSysEUDC != NULL )
                {
                    *pprfnt++ = prfnt->prfntSysEUDC;
                    prfnt->prfntSysEUDC = (RFONT *)NULL;
                }
    
                if( prfnt->prfntDefEUDC != NULL )
                {
                    *pprfnt++ = prfnt->prfntDefEUDC;
                    prfnt->prfntDefEUDC = (RFONT *)NULL;
                }
                
                for( UINT ii = 0; ii < prfnt->uiNumLinks ; ii++ )
                {
                    if (prfnt->paprfntFaceName[ii] != NULL)
                    {
                        *pprfnt++ = prfnt->paprfntFaceName[ii];
                        prfnt->paprfntFaceName[ii] = (RFONT *)NULL;
                    }
                }
                prfnt->uiNumLinks = 0;
                prfnt->bFilledEudcArray = FALSE;
            }
            else
            {
                ASSERTGDI( (prfnt->prfntSysEUDC == NULL),
                    "vMakeInactiveHelper:deactivated an RFONT with a System EUDC.\n" );
                ASSERTGDI( (prfnt->prfntDefEUDC == NULL),
                           "vMakeInactiveHelper:deactivated an RFONT with a Default \
                            EUDC.\n" );
                ASSERTGDI( (prfnt->uiNumLinks == 0),
                     "vMakeInactiveHelper:deactivated an RFONT with uiNumLinks\n");
            }

            PDEVOBJ pdo(prfnt->hdevConsumer);

        // Take it off the active list.

            PRFONT prf = pdo.prfntActive();
            vRemove(&prf, PDEV_LIST);
            pdo.prfntActive(prf);       // vRemove might change head of list

        // If font file no longer loaded, then make this RFONT the victim
        // for deletion.

            PFFOBJ pffo(prfnt->pPFF);
            ASSERTGDI(pffo.bValid(), "gdisrv!vMakeInactiveRFONTOBJ(): invalid PFF\n");

            // Possible race condition.  We're checking the count
            //     without the ghsemPublicPFT semaphore.  It could be that
            //     this is ABOUT to become zero, but we miss it.  I claim
            //     that this rarely happens and if it does, so what?  We'll
            //     eventually get rid of this font when it gets flushed out
            //     of the inactive list.  This code is just an attempt to
            //     get it out faster.   [GilmanW]

            if ( (pffo.cLoaded() == 0) && (pffo.cNotEnum() == 0) && (pffo.pPvtDataHeadGet() == NULL) )
            {
                prfVictim = prfnt;
            }

        // Otherwise, put it on the inactive list.

            else
            {
                if ( pdo.cInactive() >= cMaxInactiveRFONT )
                {
                // Too many inactive rfonts, blow one away!  Pick the last one on
                // the list.

                    for ( prf = pdo.prfntInactive();
                          prf != NULL;
                          prfVictim = prf, prf = prf->rflPDEV.prfntNext)
                    {
                    }

                // Remove victim from inactive list.

                    RFONTTMPOBJ rfo(prfVictim);

                    prf = pdo.prfntInactive();
                    rfo.vRemove(&prf, PDEV_LIST);
                    pdo.prfntInactive(prf); // vRemove might change head of list

                // We don't need to modify the count because, even though we
                // just removed one, we're going to add one back right away.

                }
                else
                {
                // We definitely made the list get longer.

                    pdo.cInactive(pdo.cInactive()+1);
                }

                prf = pdo.prfntInactive();
                vInsert(&prf, PDEV_LIST);
                pdo.prfntInactive(prf);     // vInsert changes head of list
            }
        }
    }

    // decreament the gcEUDCCount if there is no EUDC RFONTs

    if (pprfnt != NULL && !bLockEUDC)
    {
        DECREMENTEUDCCOUNT;
    }

// If we removed a victim from the inactive list, we can now delete it.

    if ( prfVictim != PRFNTNULL )
    {
        RFONTTMPOBJ rfloVictim(prfVictim);

    // Need this so we can remove this from the PFF's RFONT list.

        PFFOBJ pffo(prfVictim->pPFF);
        ASSERTGDI(pffo.bValid(), "gdisrv!vMakeInactiveRFONTOBJ(): bad HPFF");

    // We pass in NULL for ppdo because we've already removed it from the
    // PDEV list.

    // bDelete keeps the list head ptrs updated

        rfloVictim.bDeleteRFONT((PDEVOBJ *) NULL, &pffo);
    }

// No longer valid RFONTOBJ.  RFONT is now on the inactive list or deleted.

    prfnt = (PRFONT) NULL;
    return(bLockEUDC);
}


/******************************Public*Routine******************************\
* RFONTOBJ::vMakeInactive()
*
* Take the rfont off the active list, put on the inactive list
*
* History:
*  13-Jan-95 -by- Hideyuki Nagase [hideyukn]
* Rewrite it.
*
*  29-Sep-93 -by- Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vMakeInactive()
{
// We will treat this as a NULL terminated array of pointers to RFONTS so
// we need an extra ptr at the end for the NULL termination and
// SystemWide and Default EUDC Rfonts.


    PRFONT aprfnt[QUICK_FACE_NAME_LINKS + 4];
    PRFONT *pprfnt;
    BOOL   bLockEUDC, bScratch, bAllocated;

    if ((prfnt == NULL) || (prfnt->cSelected == 0))
        return;

// if the quick buffer is not enough, just allocate it here.

    if( prfnt->uiNumLinks > QUICK_FACE_NAME_LINKS )
    {
    // we need an extra ptr at the end for the NULL termination and
    // SystemWide and Default EUDC Rfonts.

        pprfnt = (PRFONT *) PALLOCMEM((prfnt->uiNumLinks+4)*sizeof(PRFONT),'flnk');
        if (pprfnt)
        {
            bAllocated = TRUE;
        }
        else
        {
        // this a small allocation which is really unlikely to fail.
        // If it does, we are probably in such a deep trouble that
        // it does not matter that we will leek even further by not
        // freeing mem allocated by this rfont. Also, in the real world,
        // we should never have uiNumLinks > QUICK_FACE_NAME_LINKS

#if DBG
            WARNING("We are in trouble to release the cache\n");
            DbgBreakPoint();
#endif

            return;
        }
    }
    else
    {
        RtlZeroMemory((VOID *)aprfnt, sizeof(aprfnt));
        pprfnt = aprfnt;
        bAllocated = FALSE;
    }

// First deactivate the RFONT itself. vMakeInactiveHelper returns a list of
// linked/EUDC RFONTS which we will then deactivate.  If bLockEUDC is TRUE
// on return from this function it means we've blocked EUDC API's from functioning
// because we are deactivating an EUDC RFONT.  On return from this function
// we should unblock EUDC API's.

    bLockEUDC = bMakeInactiveHelper(pprfnt);

    while( *pprfnt != NULL )
    {

        FLINKMESSAGE(DEBUG_FONTLINK_RFONT,
                     "vMakeInactive() deactivating linked font %x\n");

        RFONTTMPOBJ rfo( *pprfnt );

        rfo.bMakeInactiveHelper((PRFONT *)NULL);

    // next one..

        pprfnt++;
    }

// free temorary buffer, if it was allocated.

    if( bAllocated ) VFREEMEM( pprfnt );

// possibly unblock EUDC API's

    if( bLockEUDC )
    {
        ASSERTGDI(gcEUDCCount > 0, "gcEUDCCount <= 0");
        DECREMENTEUDCCOUNT;
    }
}

#endif


/**************************Public*Routine************************\
* vRemoveAllInactiveRFONTs()
*
* Take all of the rfont off the inactive list.
* This is only called by bAllocateCache() after it fails to
* allocate the memory the fisrt time.
*
* History:
*
*  Mar-06-98 -by- Xudong Wu [TessieW]
* Wrote it.
\****************************************************************/

VOID vRemoveAllInactiveRFONTs(PPDEV ppdev)
{
    PRFONT  aprfnt[cMaxInactiveRFONT], prf, prfHead, prfVictim;
    ULONG   i = 0, cNumVictim;

    {
        SEMOBJ so(ghsemRFONTList);

        PDEVOBJ pdo((HDEV)ppdev);

        // remove every RFONT from the inactive list

        for (prf = pdo.prfntInactive(); prf != NULL; )
        {
            aprfnt[i++] = prfVictim = prf;
            prf = prf->rflPDEV.prfntNext;

            RFONTTMPOBJ rfo(prfVictim);
            prfHead = pdo.prfntInactive();
            rfo.vRemove(&prfHead, PDEV_LIST);
            pdo.prfntInactive(prfHead);
        }
        pdo.cInactive(0);
    }

    cNumVictim = i;
    ASSERTGDI(cNumVictim <= cMaxInactiveRFONT, "bRemoveAllInactiveRFONT: cNumVictim > cMaxInactiveRFONT");

    for (i = 0; i < cNumVictim; i++)
    {
        RFONTTMPOBJ rfo(aprfnt[i]);

        PFFOBJ pffo(aprfnt[i]->pPFF);
        ASSERTGDI(pffo.bValid(), "bReamoveAllInactiveRFONT: Invalid pff");

        // pass in ppdo as NULL because it has been
        // removed from the PDEV list

        rfo.bDeleteRFONT((PDEVOBJ *) NULL, &pffo);
    }
}


/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bRealizeFont
*
* Realizes the IFI or device font represented by the PFE handle for the
* DC associated with the passed DC user object.  Initializes the other
* fields of the RFONT.
*
* Warning:
*   Whoever calls this should be holding the semaphore of the PFT in which
*   the PFE lives.
*
* Returns:
*   TRUE if realization successful, FALSE if error occurs.
*
* History:
*  Wed 09-Mar-1994 13:52:26 by Kirk Olynyk [kirko]
* Made the FONTOBJ::flFontType consistent with the contents of the font
* in the case where the type of the original font is overridden.
*  Sat 09-Jan-1993 22:11:23 by Kirk Olynyk [kirko]
* Added pptlSim to the input parameter list. This is for bitmap scaling
* simulations.
*  12-Dec-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bRealizeFont(
    XDCOBJ     *pdco,            // realize font for this DC (optional)
    PPDEVOBJ    ppdo,            // realize font for this PDEV
    ENUMLOGFONTEXDVW *pelfw,     // font wish list (in logical coords)
    PFE        *ppfe,            // realize this font face
    PFD_XFORM   pfdx,            // font xform (Notional to Device)
    POINTL* const pptlSim,       // for bitmap scaling
    FLONG       _fl,             // xform flags
    ULONG       ulStyleHtPt,     // style ht
    BOOL        bNeedPaths,      // Font realization must cache paths
    BOOL        bSmallMetricsOk,
    FLONG       flType
)
{
    BOOL bRet = FALSE;
    PFEOBJ pfeo(ppfe);
    PFD_GLYPHSET pfdgTmp;

    ASSERTGDI(pfeo.bValid(),
        "gdisrv!bRealizeFontRFONTOBJ(): PFEOBJ constructor failed\n");

// If we can not allocate pfdg, then we would failed to do RFNT initialized.

    pfdgTmp = pfeo.pfdg();

    if (!pfdgTmp)
    {
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }

    ASSERTGDI(prfnt == NULL,
        "gdisrv!bRealizeFontRFONTOBJ(): prfnt != NULL\n");

// Create a default sized RFONT.

    prfnt = (RFONT *) PALLOCMEM(sizeof(RFONT), 'tnfG');

    if (prfnt == PRFNTNULL)
    {
        WARNING("gdisrv!bRealizeFontRFONTOBJ(): failed alloc\n");
        pfeo.vFreepfdg();
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }


    PFFOBJ pffo(pfeo.pPFF());
    ASSERTGDI(pffo.bValid(),
        "gdisrv!bRealizeFontRFONTOBJ(): PFFOBJ constructor failed\n");

    ASSERTGDI(pfdx != NULL,
        "gdisrv!bRealizeFontRFONTOBJ(): pfdx == NULL\n");

// Set up the RFONT's copy of the FONTOBJ.
//
// This needs to be done before the IFI/device driver dependent stuff
// because it is needed by FdOpenFontContext.

    // Note: iUniq should be set here, but we won't set it until we grab
    //       the ghsemRFONTList because the iUniqueStap needs semaphore
    //       protection for increment and access.  (InterlockedIncrement
    //       doesn't cut it).

    pfo()->sizLogResPpi.cx = ppdo->ulLogPixelsX();
    pfo()->sizLogResPpi.cy = ppdo->ulLogPixelsY();
    pfo()->ulStyleSize = ulStyleHtPt;
    pfo()->flFontType = _fl | pfeo.flFontType();  // combine the simulation and type flage
    pfo()->pvConsumer = (PVOID) NULL;
    pfo()->pvProducer = (PVOID) NULL;
    pfo()->iFace = pfeo.iFont();
    pfo()->iFile = pffo.hff();

    // nonzero only for tt fonts

    //
    // Old comment from gilmanw:
    //  - what about device TT fonts?!? Should iTTUniq be zero?
    //

    // iTTUniq should be different between Normal face font and @face Verical font.
    // And also, this value should be uniq for TrueType collection format fonts.
    //
    pfo()->iTTUniq = (pfo()->flFontType & TRUETYPE_FONTTYPE) ? (ULONG_PTR) ppfe : 0;

    // Assert consistency of TrueType.  The driver is the TrueType font driver
    // if and only if the font is TrueType.

    #ifdef FINISHED_FONT_DRIVER_WORK
    ASSERTGDI(((pfo()->flFontType & TRUETYPE_FONTTYPE) != 0) ==
              (pffo.hdev() == (HDEV) gppdevTrueType),
              "gdisrv!bRealizeFontRFONTOBJ():  inconsistentflFontType\n");
    #endif

// Copy the font transform passed in.

    prfnt->fdx = *pfdx;
    prfnt->fdxQuantized = *pfdx;
    prfnt->ptlSim = *pptlSim;

// Initialize the DDI callback EXFORMOBJ.

    prfnt->xoForDDI.vInit(&prfnt->mxForDDI);
    vSetNotionalToDevice(prfnt->xoForDDI);

// Save identifiers to the source of the font (physical font).

    prfnt->ppfe = ppfe;
    prfnt->pPFF = pfeo.pPFF();

#ifdef FE_SB
// Set Null to indicate this RFONT not yet linked to EUDC

    prfnt->prfntSystemTT    = (PRFONT )NULL;
    prfnt->prfntSysEUDC     = (PRFONT  )NULL;
    prfnt->prfntDefEUDC     = (PRFONT  )NULL;
    prfnt->paprfntFaceName  = (PRFONT *)NULL;
    prfnt->bFilledEudcArray = FALSE;

// Initialize EUDC status.

    prfnt->flEUDCState = 0;
    prfnt->uiNumLinks  = 0;
    prfnt->ulTimeStamp = 0;
    prfnt->bVertical   = pfeo.bVerticalFace();
#endif


// Save identifiers to the consumer of this font realization.

    if (ppdo != NULL)
    {
    // The dhpdev is really for font producers, which won't support dynamic
    // mode changing:

        prfnt->hdevConsumer  = ppdo->hdev();
        prfnt->dhpdev        = ppdo->dhpdevNotDynamic();
    }
    else
    {
        prfnt->hdevConsumer  = NULL;
        prfnt->dhpdev        = 0;
    }

// Bits per pel?

    // 
    // Old comment:
    //   - setting cBitsPerPel = 1 is wrong - kriko

    prfnt->cBitsPerPel = 1;

// Outline (transformable)?

    IFIOBJ ifio(pfeo.pifi());
    prfnt->flInfo = pfeo.pifi()->flInfo;

    pfdg(pfdgTmp);

// Cache the default character.  The bInitCache method below needs it.

    prfnt->hgDefault = hgXlat(ifio.wcDefaultChar());

// Should this become an error exit, or can this be taken out?

    ASSERTGDI (
        pfdg()->cGlyphsSupported != 0,
        "gdisrv!bRealizeFontRFONTOBJ(): no glyphs in this font\n"
        );

// Get the device metrics info

    FD_DEVICEMETRICS devm;          // buffer to which the driver returns info

// Initialize font driver (the font producer) information.

    prfnt->hdevProducer = pffo.hdev();

// Up to this point nothing has been done that could cause the font driver
// (the font provider) to realize the font.  However, this may now happen
// when querying for information dependent on the realization.  So we are
// going to HAVE TO KILL font driver realization on every  error return
// from this function

     // FONTASSASIN faKillDriverRealization(&ldo, pfo());

// get and convert device metrics.

    if ( !bGetDEVICEMETRICS(&devm) )
    {
        WARNING("gdisrv!bRealizeFontRFONTOBJ(): error with DEVICEMETRICS\n");

        vDestroyFont(); // kill the driver realization
        VFREEMEM(prfnt);
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }

// Pre-compute some useful values for text placement and extents.
// (But only if it's not some journalling guys calling.)

    if (pdco != (XDCOBJ *) NULL)
    {
    // pelfw is null only when pdco is null

        ASSERTGDI(pelfw,"gdisrv! pelfw == NULL\n");

    // Get the unit baseline and ascent vectors from the DEVICEMETRICS.

        prfnt->pteUnitBase.x   = devm.pteBase.x; // Converts from FLOAT.
        prfnt->pteUnitBase.y   = devm.pteBase.y; // Converts from FLOAT.
        prfnt->pteUnitAscent.x = devm.pteSide.x; // Converts from FLOAT.
        prfnt->pteUnitAscent.y = devm.pteSide.y; // Converts from FLOAT.

    // Save a copy of the DC's World to Device matrix.  We'll need this later
    // to identify compatible XFORM's (i.e., DC marked as having a changed
    // transform when, in fact, the transform has not changed in a way that
    // would effect the font realization.  Example: translation only changes.

        prfnt->mxWorldToDevice = pdco->pdc->mxWorldToDevice();

    // Compute the scaling factors for fast transforms from world to
    // device space and back.

    // Compute some matrix stuff related to the font realization's transform.
    // Compute Notional to World scaling factors in the baseline and ascender
    // directions.

    // These two routines should be made into a single routine [bodind]
        if
        (
            !bCalcLayoutUnits(pdco)     // Uses pteUnitBase, pteUnitAscent.
            ||
            !bGetNtoWScales(
                &prfnt->eptflNtoWScale,
                *pdco,
                &prfnt->fdxQuantized,  // the one really used by the rasterizer
                pfeo,
                &prfnt->bNtoWIdent
                )
        )
        {
            WARNING("gdisrv!bRealizeFont(): error computing scaling factors\n");
            vDestroyFont(); // kill the driver realization
            VFREEMEM(prfnt);
            prfnt = PRFNTNULL;
            return bRet;        // return FALSE
        }

    // Precompute the offsets for max ascent and descent.

        prfnt->ptfxMaxAscent.x  = lCvt(prfnt->pteUnitAscent.x,prfnt->fxMaxAscent);
        prfnt->ptfxMaxAscent.y  = lCvt(prfnt->pteUnitAscent.y,prfnt->fxMaxAscent);
        prfnt->ptfxMaxDescent.x = lCvt(prfnt->pteUnitAscent.x,prfnt->fxMaxDescent);
        prfnt->ptfxMaxDescent.y = lCvt(prfnt->pteUnitAscent.y,prfnt->fxMaxDescent);

    // Mark escapement info as invalid.

        prfnt->lEscapement = -1;

        if (pdco->pdc->iGraphicsMode() == GM_COMPATIBLE)
        {
            if (ifio.bStroke())
            {
            // esc and orientation treated as WORLD space concepts

                prfnt->ulOrientation =
                    (ULONG) lNormAngle(3600-pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation);
            }
            else
            {
            // force orientation to be equal to escapement, which means
            // that h3 or g2 text out code will be executed
            // in this case ulOrientation and lEsc are device space concepts
            // but it does not really matter, so long as we wind up in h2 or
            // g3 layout routines which are not even going to look at this number.

                if (ifio.bArbXforms())
                {
                // you will always get the orientation you ask for

                    prfnt->ulOrientation =
                        (ULONG) lNormAngle(3600-pelfw->elfEnumLogfontEx.elfLogFont.lfEscapement);
                }
                else // get one of the discrete choices of the font driver
                {
                    prfnt->ulOrientation
                        = ulSimpleDeviceOrientation(*this);

                    ASSERTGDI(
                        prfnt->ulOrientation != 3601,
                        "GDISRVL! ulSimpleDeviceOrientation err\n"
                        );
                }
            }

        }
        else // advanced mode
        {
        // Try to calculate an orientation angle in world coordinates.  Note that
        // we want an exact answer, because it's important to know if the
        // escapement and orientation are exactly equal.  In the Win 3.1
        // compatible case, we will force them equal (in ESTROBJ::vInit), but
        // we still need to know if the orientation is 0 for fast horizontal
        // layout.  (So we don't really care what the orientation is if it's
        // non-obvious in this case.)

            prfnt->ulOrientation = ulSimpleOrientation(pdco); // Uses pteUnitBase.

        // If we are in advanced mode and the font is scalable, we will assume
        // that the desired orientation is obtained.

            if
            (
                (prfnt->ulOrientation >= 3600)
                && bArbXforms()
            )
            {
            // For text layout, orientation angles are measured from the x-axis
            // towards the positive y-axis.  The app measures them towards the
            // negative y-axis.  We adjust for this.

                prfnt->ulOrientation =
                    (ULONG) lNormAngle(3600-pelfw->elfEnumLogfontEx.elfLogFont.lfOrientation);
            }

        }

    } // end of if (pdco != NULL) clause

// Make sure essential information is in place for further realization.

    ASSERTGDI(prfnt->hgDefault != HGLYPH_INVALID,"Default glyph invalid!\n");

    prfnt->bNeededPaths = bNeedPaths;

    // Is this font driver, or just a device driver?

    ULONG ulFontCaps = 0;

    PDEVOBJ pdo(prfnt->hdevProducer);

    if (PPFNVALID(pdo, QueryFontCaps))
    {
        ULONG ulBuf[2];

        if ( pdo.QueryFontCaps(2, ulBuf) != FD_ERROR )
        {
            ulFontCaps = ulBuf[1];
        }
    }

    if ( !pdo.bFontDriver() )
    {
    // If not a font driver, then the driver does not provide either bitmaps
    // or outlines.  Therefore, it must be that we are using a device-specific
    // font (i.e., metrics only).

        prfnt->bDeviceFont = TRUE;

    // Handle cache typing.

        prfnt->ulContent = FO_HGLYPHS;

        prfnt->cache.cjGlyphMax = 0;

    }
    else
    {
    // If its a font driver, then this font is not device specific.  We
    // can get more than just glyph metrics from this realization.

    // we will make sure that glyphs that are up to ~2 inches tall
    // are stored as glyphbits, above that as paths. That should speed up
    // printing on high resolution printers.

        ULONG ulPathThreshold;

		if ( prfnt->fobj.flFontType & (FO_CLEARTYPE_X | FO_GRAY16)) 
			ulPathThreshold = gulOutlineThreshold / 2;
		else
			ulPathThreshold = gulOutlineThreshold;


        prfnt->bDeviceFont = FALSE;

    // Figure out the type of font data we want to cache
    // First, figure out what the driver would like

        prfnt->ulContent = FO_GLYPHBITS;        // assume bitmaps

        if ( bNeedPaths )
        {
            prfnt->ulContent = FO_PATHOBJ;
        }
        else if (prfnt->hdevConsumer != NULL)
        {
        // get device driver user object

            PDEVOBJ pdoConsumer(prfnt->hdevConsumer);

            if (PPFNVALID(pdoConsumer, GetGlyphMode))
            {
                prfnt->ulContent =
                    (*PPFNDRV(pdoConsumer, GetGlyphMode)) (prfnt->dhpdev, pfo());
            }

        // multiply resolution by 3 inches to get pixel height limit

            if (pdoConsumer.flGraphicsCapsNotDynamic() & GCAPS_FONT_RASTERIZER)
            {
                ULONG ulTmp = pdoConsumer.ulLogPixelsY() * 3;

                if (ulTmp > gulOutlineThreshold)
                    ulPathThreshold = ulTmp;

            // also, if in the future we get 2400 dpi or 4800 dpi devices
            // we do not want this number to get too big, this
            // would cost us too much in terms of font cache memory
            // and rasterization times.

                if (ulPathThreshold > 2400)
                    ulPathThreshold = 2400;
            }
        }

        ASSERTGDI(prfnt->ulContent <= FO_PATHOBJ,
                  "RFONTOBJ::bRealize - bad ulContent\n");

        // A driver preference requires agreement between the font driver and
        // device driver.

        switch(prfnt->ulContent)
        {
        case FO_GLYPHBITS:
            {
            // If the driver is incapable of supplying bitmaps OR if the height
            // is very large (greater global outline threshold) and the font is
            // capable of doing outlines, then force path mode.

            // we use different threshold for cxMax
            // which is usually about 2 * cyMax

                if
                (
                  (!(ulFontCaps & QC_1BIT)) ||
                  (bReturnsOutlines() &&
                  ((prfnt->cxMax > (2*ulPathThreshold)) ||
                   (prfnt->cyMax > ulPathThreshold)))
                )
                    prfnt->ulContent = FO_PATHOBJ;
            }
            break;

        case FO_PATHOBJ:
            if ( !(ulFontCaps & QC_OUTLINES))
                prfnt->ulContent = FO_GLYPHBITS;
            break;

        default:
            break;
        }
    }
    // If you force the path mode then turn off antialiasing
    if (prfnt->ulContent == FO_PATHOBJ)
    {
        #if DBG
        if (gflFontDebug & DEBUG_AA)
            KdPrint(("Forcing path mode ==> turning off antialiasing\n"));
        #endif
        prfnt->fobj.flFontType &= ~FO_GRAY16;
    }
    if ( bNeedPaths && (prfnt->ulContent != FO_PATHOBJ))
    {
        WARNING1("Can't get paths for font!\n");
        vDestroyFont(); // kill the driver realization
        VFREEMEM(prfnt);
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }

// we only use small metrics if the bit

    prfnt->cache.bSmallMetrics =
        ( bSmallMetricsOk && ( prfnt->ulOrientation == 0 ) ) ? TRUE : FALSE;

    if (!bInitCache(flType))
    {
        WARNING("gdisrv!bRealizeFontRFONTOBJ(): cache initialization failed\n");

        vDestroyFont(); // kill the driver realization
        VFREEMEM(prfnt);
        prfnt = PRFNTNULL;
        return bRet;        // return FALSE
    }

// set TEXTMETRICS cache to NULL

    prfnt->ptmw = NULL;

// Made it this far, so everything is OK

    bRet = TRUE;

    //
    // Old comments:
    //  - really ought to check list to make sure that no one else
    //    realized the font while we were working
    //

    PRFONT prfntHead;

    {
        SEMOBJ so(ghsemRFONTList);

    // Assign the uniqueness ID under semaphore.

        // WARNING:
        // This exact same code is in iGetNextUniqueness() in JNLFONT.CXX.
        // Why not just call it?  Because iGetNextUniqueness() would grab
        // the semaphore a second time.  I'd rather live with duplicate
        // code!

        iUniqueStamp += 1;
        if (iUniqueStamp == 0)  // an iUniq of 0 means "don't cache" in driver
            iUniqueStamp = 1;

        pfo()->iUniq = iUniqueStamp;

    // If a PDEVOBJ * was passed in, we need to update its list.

        if (ppdo != NULL)
        {
            prfnt->cSelected = 1;

        // Add to PDEV list.

            prfntHead = ppdo->prfntActive();
            vInsert(&prfntHead, PDEV_LIST);
            ppdo->prfntActive(prfntHead);
        }

    // Add to PFF list.

        prfntHead = pffo.prfntList();
        vInsert(&prfntHead, PFF_LIST);
        pffo.prfntList(prfntHead);
    }

    if (prfnt->ulContent == FO_GLYPHBITS)
        prfnt->fobj.flFontType |= FO_TYPE_RASTER;
    else
        prfnt->fobj.flFontType &= ~FO_TYPE_RASTER;

// remember the graphics mode used in computing this realization's
// notional to world xform:

    if (pdco != (XDCOBJ *) NULL)
        iGraphicsMode(pdco->pdc->iGraphicsMode());
    else
        iGraphicsMode(0);

#ifdef FE_SB
    prfnt->bIsSystemFont = gbSystemDBCSFontEnabled && pfeo.bSBCSSystemFont();
#endif

    return bRet;
}



/******************************Public*Routine******************************\
* bCalcLayoutUnits (pdco)                                                  *
*                                                                          *
* Initializes the following fields in the RFONT.  The unit baseline and    *
* unit ascent vectors pteUnitBase and pteUnitAscent must already be        *
* initialized.  The vectors are given to us by the font realization code,  *
* so we can really make no assumptions about them other than that they are *
* unit vectors in device space and orthogonal in world space.              *
*                                                                          *
*   efWtoDBase                                                             *
*   efDtoWBase                                                             *
*   efWtoDAscent                                                           *
*   efDtoWAscent                                                           *
*                                                                          *
*  Fri 05-Feb-1993 16:03:14 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RFONTOBJ::bCalcLayoutUnits(XDCOBJ *pdco)
{
    EFLOAT efOne;
    efOne.vSetToOne();

// Get the world to device transform from the DC.

    EXFORMOBJ xo(*pdco, WORLD_TO_DEVICE);

// Pick up the diagonal components.

    EFLOAT efM11 = xo.efM11();
    EFLOAT efM22 = xo.efM22();
    efM11.vAbs(); efM22.vAbs();

// Handle the simple (but common) case.

    if (xo.bScale() && (efM11 == efM22))
    {
        EFLOAT efM11Inv;
        efM11Inv.eqDiv(efOne,efM11);

        prfnt->efWtoDBase   = efM11;
        prfnt->efWtoDAscent = efM11;
        prfnt->efDtoWBase   = efM11Inv;
        prfnt->efDtoWAscent = efM11Inv;

    // in isotropic case even win 31 dudes get it right;

        prfnt->efDtoWBase_31   = prfnt->efDtoWBase  ;
        prfnt->efDtoWAscent_31 = prfnt->efDtoWAscent;
    }

// Handle the slow general case.

    else
    {
        POINTFL ptfl;

    // Get the inverse transform from the DC.

        EXFORMOBJ xoDtoW(*pdco, DEVICE_TO_WORLD);
        if (!xoDtoW.bValid())
            return(FALSE);

    // Back transform the baseline, measure its length.


        xoDtoW.bXform((VECTORFL *) &prfnt->pteUnitBase,(VECTORFL *) &ptfl,1);
        prfnt->efDtoWBase.eqLength(ptfl);
        prfnt->efDtoWBase.vDivBy16();   // Adjust for subpel transform.
        prfnt->efWtoDBase.eqDiv(efOne,prfnt->efDtoWBase);

    // Back transform the ascent, measure its length.

        xoDtoW.bXform((VECTORFL *) &prfnt->pteUnitAscent,(VECTORFL *) &ptfl,1);
        prfnt->efDtoWAscent.eqLength(ptfl);
        prfnt->efDtoWAscent.vDivBy16(); // Adjust for subpel transform.
        prfnt->efWtoDAscent.eqDiv(efOne,prfnt->efDtoWAscent);

        if
        (
            (pdco->pdc->iGraphicsMode() == GM_COMPATIBLE) &&
            !pdco->pdc->bUseMetaPtoD()                   &&
            !(prfnt->flInfo & FM_INFO_TECH_STROKE)
        )
        {
        // win 31 way of doing it: they scale extent measured
        // along baseline by the (DtoW) xx component even if baseline is
        // along some other direction. Likewise they scale ascender extent by
        // DtoW yy component even if ascender is not collinear with y axis.
        // so fix up backward scaling factors, but leave forward scaling factors
        // correct for the text layout code [bodind]
        // Note that win31 is here at least consistent with respect tt and
        // vector fonts: it returns text extent values that are screwed
        // in the same bogus way for tt and for vector fonts

            prfnt->efDtoWBase_31   = xoDtoW.efM11();
            prfnt->efDtoWAscent_31 = xoDtoW.efM22();

            prfnt->efDtoWBase_31.vAbs();
            prfnt->efDtoWAscent_31.vAbs();
        }
        else
        {
            prfnt->efDtoWBase_31   = prfnt->efDtoWBase  ;
            prfnt->efDtoWAscent_31 = prfnt->efDtoWAscent;
        }

    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* ulSimpleOrientation (pdco)                                               *
*                                                                          *
* Attempts to calculate a simple orientation angle in world coordinates.   *
* This only ever returns multiples of 90 degrees when it succeeds.  If the *
* calculation would be hard, it just returns 3601.                         *
*                                                                          *
* Note that the text layout code, for which the escapement and orientation *
* are recorded in the RFONT, always considers its angles to be measured    *
* from the x-axis towards the positive y-axis.  (So that a unit vector     *
* will have a y component equal to the cosine of the angle.)  This is NOT  *
* what an application specifies in world coordinates!                      *
*                                                                          *
*  Fri 05-Feb-1993 18:57:33 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  It looks more formidable than it is.  It actually doesn't     *
* execute much code.                                                       *
\**************************************************************************/

ULONG RFONTOBJ::ulSimpleOrientation(XDCOBJ *pdco)
{
// Calculate the orientation in device space.

    INT sx = (INT) prfnt->pteUnitBase.x.lSignum();
    INT sy = (INT) prfnt->pteUnitBase.y.lSignum();

// Exactly one of these must be zero (for the orientation to be simple).

    if ((sx^sy)&1)
    {
    // Calculate the following angles:
    //
    //   sx = 00000001 :    0
    //   sy = 00000001 :  900
    //   sx = FFFFFFFF : 1800
    //   sy = FFFFFFFF : 2700

        ULONG ulOrientDev = (sx & 1800) | ((-sy) & 900) | (sy & 2700);

    // Handle the trivial case.

        if (pdco->pdc->bWorldToDeviceIdentity())
            return(ulOrientDev);

    // Locate our transform and examine the matrix.

        EXFORMOBJ xo(*pdco, WORLD_TO_DEVICE);

        INT s11 = (INT) xo.efM11().lSignum();
        INT s12 = (INT) xo.efM12().lSignum();
        INT s21 = (INT) xo.efM21().lSignum();
        INT s22 = (INT) xo.efM22().lSignum();

    // Handle non-inverting transforms.

    // Examine the transform to see if it's a simple multiple of 90
    // degrees rotation and perhaps some scaling.

    // If any of the terms we OR together are non-zero, it's a bad transform.

        if (
             (
               (s11 - s22)         // Signs on diagonal must match.
               | (s12 + s21)       // Signs off diagonal must be opposite.
               | ((s11^s12^1)&1)   // Exactly one diagonal must be zero.
             ) == 0
           )
        {
        // Since we've normalized to a space where (0 1) represents
        // a vector with a 90 degree orientation note that the matrix
        // that rotates us by positive 90 degrees, going from world to
        // device, is:
        //
        //           [ 0  1 ]
        //     (1 0) [      ] = (0 1)
        //           [-1  0 ]
        //
        // I.e. the one with M  < 0.  From device to world, that's -90 degrees.
        //                    21

            ULONG ulOrientWorld = ulOrientDev
                                  + (s12 &  900)
                                  + (s11 & 1800)
                                  + (s21 & 2700);

        // Note that only the single 0xFFFFFFFF term contributes above.

            if (ulOrientWorld >= 3600)
                ulOrientWorld -= 3600;

            return(ulOrientWorld);
        }

    // Now we do the parity inverting transforms.

        else if (
                  (
                    (s11 + s22)         // Signs on diagonal must be opposite.
                    | (s12 - s21)       // Signs off diagonal must match.
                    | ((s11^s12^1)&1)   // Exactly one diagonal must be zero.
                  ) == 0
                )
        {
        // These are just the simple reflections which take multiples of
        // 90 degrees to multiples of 90 degrees.  They are idempotent so
        // device-to-world or world-to-device is irrelevant.
        //
        //  [ 1  0 ]                [-1  0 ]
        //  [      ] => 3600-x      [      ] => 5400-x
        //  [ 0 -1 ]                [ 0  1 ]
        //
        //  [ 0 -1 ]                [ 0  1 ]
        //  [      ] => 6300-x      [      ] => 4500-x
        //  [-1  0 ]                [ 1  0 ]

            ULONG ulOrientWorld = (s22 & 3600) + (s12 & 6300)
                                + (s11 & 5400) + ((-s12) & 4500)
                                - ulOrientDev;

        // Note that only the single 0xFFFFFFFF term contributes.

            if (ulOrientWorld >= 3600)
                ulOrientWorld -= 3600;

            return(ulOrientWorld);
        }
    }

// If it's not simple, return an answer out of range.

    return(3601);
}

/******************************Public*Routine******************************\
* RFONTOBJ::bDeleteFONT
*
* Delete an RFONT.  The ppdo and ppffo point to objects that have RFONT
* lists that require updating because of the deletion.  If NULL, that
* means the corresponding object does not need deletion (most likely
* because the list management has already been performed for that object).
*
* Warning:
*   Only PFFOBJ::bDelete should pass in a NULL for ppffo.  The PFF
*   list needs to be treated specially because PFFs are the only object
*   which might get deleted in response to a RFONT deletion.
*
* History:
*  30-Oct-1990 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bDeleteRFONT (
    PDEVOBJ *ppdo,
    PFFOBJ *ppffo
    )
{
    PRFONT prfntHead;
    PFEOBJ pfeo(ppfe());

// free pfdg
    pfeo.vFreepfdg();

// Tell font producer that font is going away.

    PDEVOBJ pdoPro(prfnt->hdevProducer);

    if ( PPFNVALID(pdoPro, DestroyFont) )
    {
        pdoPro.DestroyFont(pfo());
    }

// Tell font consumer that font is going away.
// Note: the PLDEV for the consumer may be NULL (jounalling).

    if (prfnt->hdevConsumer != NULL )
    {
        PDEVOBJ pdoCon(prfnt->hdevConsumer);

    // If this is a display device and we are not in the middle of tearing
    // the pdev down we need to lock the display in order to synchronize
    // this call with other calls to the driver.

        BOOL bLock = ( pdoCon.bDisplayPDEV() && pdoCon.cPdevRefs() != 0 );

        if( bLock )
        {
            GreAcquireSemaphoreEx(pdoCon.hsemDevLock(), SEMORDER_DEVLOCK, NULL);
            GreEnterMonitoredSection(pdoCon.ppdev, WD_DEVLOCK);
        }

        if ( PPFNVALID(pdoCon, DestroyFont) )
        {
            pdoCon.DestroyFont(pfo());
        }

        if( bLock )
        {
            GreExitMonitoredSection(pdoCon.ppdev, WD_DEVLOCK);
            GreReleaseSemaphoreEx(pdoCon.hsemDevLock());
        }
    }

// Update the RFONT lists.  Do this under the ghsemRFONTList semaphore (which
// may or may not already be held).

    {
    // Stablize the RFONT lists.

        SEMOBJ so(ghsemRFONTList);

    // If a ppdo is passed in, then we need to remove this RFONT from the
    // PDEV list.

        if ( ppdo != (PDEVOBJ *) NULL )
        {
            ASSERTGDI(!bActive(), "gdisrv!bDeleteRFONTOBJ(): RFONT still active\n");

        // Remove from PDEV list.

            prfntHead = ppdo->prfntInactive();
            vRemove(&prfntHead, PDEV_LIST);
            ppdo->prfntInactive(prfntHead);

        // Update the inactive RFONT ref. count.

            ppdo->cInactive(ppdo->cInactive()-1);
        }

    // If a ppffo is passed in, then remove from PFF list.  If ppffo is NULL, then
    // bDelete must have been called from PFFOBJ::bDelete(), so we are
    // in the process of deleting RFONTs already and do not need to maintain the
    // list.

    // Note: it is possible to write PFFOBJ::bDelete() so that a bDelete
    //       will recursively destroy the entire RFONT list, but I want to
    //       avoid the recursion.

        if ( ppffo != (PFFOBJ *) NULL )
        {
        // Remove from PFF list.

            prfntHead = ppffo->prfntList();
            vRemove(&prfntHead, PFF_LIST);
            ppffo->prfntList(prfntHead);

        }
    }

// Need to tell PFF that this RFONT is going away.  Can't do this under the
// semaphore because bDeleteRFONTRef may cause the driver to be called.

    if ( ppffo != (PFFOBJ *) NULL )
    {
    // Inform PFF that RFONT is going away

        if ( !ppffo->bDeleteRFONTRef() )
        {
            WARNING("gdisrv!bDeleteRFONTOBJ(): PFF deletion failed\n");
            return (FALSE);
        }
    }

// Destroy the cache

    vDeleteCache();

// Delete TEXTMETRICS cache

    if( prfnt->ptmw != NULL )
    {
        VFREEMEM( prfnt->ptmw );
    }

    if (prfnt->hsemEUDC)
        GreDeleteSemaphore(prfnt->hsemEUDC);
    
// Delete the cache semaphore
    GreDeleteSemaphore(prfnt->hsemCache);
// Free object memory and invalidate pointer

    VFREEMEM(prfnt);
    prfnt = PRFNTNULL;
    return (TRUE);
}

/******************************Member*Function*****************************\
* BOOL  RFONTOBJ::bGetDEVICEMETRICS
*
* calls the device or font driver to provide the engine with the
* FD_DEVICEMETRICS structure
*
* History:
*  08-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL RFONTOBJ::bGetDEVICEMETRICS(PFD_DEVICEMETRICS pdevm)
{
    ULONG ulRet;

// Supply fields to be overwritten by the font provider.
// The fdxQuantized field is overwritten if the provider wants a different
// transform.  The lExtLeading field is changed from MINLONG if the provider
// wants to scale this value non-linearly.

    pdevm->fdxQuantized  = prfnt->fdx;

    pdevm->lNonLinearExtLeading   = MINLONG; // if stays MINLONG, means linear
    pdevm->lNonLinearIntLeading   = MINLONG; // if stays MINLONG, means linear
    pdevm->lNonLinearMaxCharWidth = MINLONG; // if stays MINLONG, means linear
    pdevm->lNonLinearAvgCharWidth = MINLONG; // if stays MINLONG, means linear

    PDEVOBJ pdo(prfnt->hdevProducer);

    if ( ((ulRet = pdo.QueryFontData(
                    prfnt->dhpdev,
                    pfo(),
                    QFD_MAXEXTENTS,
                    HGLYPH_INVALID,
                    (GLYPHDATA *) NULL,
                    (PVOID) pdevm,
                    (ULONG) sizeof(FD_DEVICEMETRICS))) == FD_ERROR) )
    {
    // The QFD_MAXEXTENTS mode is required of all drivers.
    // However must allow for the possibility of this call to fail.
    // This could happen if the
    // font file is on the net and the net connection dies, and the font
    // driver needs the font file to produce device metrics [bodind]

        return FALSE;
    }

    #if DBG
    {
        EFLOAT efX;
        EFLOAT efY;

        efX = pdevm->pteBase.x;
        efY = pdevm->pteBase.y;
        efX *= efX;
        efY *= efY;
        efY += efX;
        ASSERTGDI(efY < FP_2_0, "pteBase is too large\n");

        efX  = pdevm->pteSide.x;
        efY  = pdevm->pteSide.y;
        efX *= efX;
        efY *= efY;
        efY += efX;
        ASSERTGDI(efY < FP_2_0, "pteSide is too large\n");
    }
    #endif

    prfnt->flRealizedType = SO_FLAG_DEFAULT_PLACEMENT;
    if (pdevm->flRealizedType & FDM_TYPE_MAXEXT_EQUAL_BM_SIDE)
        prfnt->flRealizedType |= SO_MAXEXT_EQUAL_BM_SIDE;
    if (pdevm->flRealizedType & FDM_TYPE_CHAR_INC_EQUAL_BM_BASE)
        prfnt->flRealizedType |= SO_CHAR_INC_EQUAL_BM_BASE;
    if (pdevm->flRealizedType & FDM_TYPE_ZERO_BEARINGS)
        prfnt->flRealizedType |= SO_ZERO_BEARINGS;

    prfnt->cxMax          = pdevm->cxMax;

    prfnt->ptlUnderline1  = pdevm->ptlUnderline1;
    prfnt->ptlStrikeOut   = pdevm->ptlStrikeOut;

    prfnt->ptlULThickness = pdevm->ptlULThickness;
    prfnt->ptlSOThickness = pdevm->ptlSOThickness;

    if (pdevm->fxMaxAscender < 0)
        prfnt->fxMaxExtent = pdevm->fxMaxDescender;
    else if (pdevm->fxMaxDescender < 0)
        prfnt->fxMaxExtent = pdevm->fxMaxAscender;
    else
        prfnt->fxMaxExtent = pdevm->fxMaxAscender + pdevm->fxMaxDescender;

    prfnt->fxMaxAscent  = pdevm->fxMaxAscender;
    prfnt->fxMaxDescent = -pdevm->fxMaxDescender;

    prfnt->lMaxAscent   = FXTOL(8 + prfnt->fxMaxAscent);
    prfnt->lMaxHeight   = FXTOL(8 + prfnt->fxMaxAscent - prfnt->fxMaxDescent);

    prfnt->lCharInc     = pdevm->lD;

// new fields

    prfnt->cyMax      = pdevm->cyMax;
    prfnt->cjGlyphMax = pdevm->cjGlyphMax; // used to get via QFD_MAXGLYPHBITMAP

// need to compute the filtering correction for CLEAR_TYPE:
// x filtering adds a pixel on each side of the glyph

    if (prfnt->fobj.flFontType & FO_CLEARTYPE_X)
    {
        prfnt->cjGlyphMax = CJ_CTGD((prfnt->cxMax + 2), prfnt->cyMax);
    }

// formerly in reExtra

    prfnt->fdxQuantized           = pdevm->fdxQuantized;
    prfnt->lNonLinearExtLeading   = pdevm->lNonLinearExtLeading;
    prfnt->lNonLinearIntLeading   = pdevm->lNonLinearIntLeading;
    prfnt->lNonLinearMaxCharWidth = pdevm->lNonLinearMaxCharWidth;
    prfnt->lNonLinearAvgCharWidth = pdevm->lNonLinearAvgCharWidth;

// Get the lMaxNegA lMaxNegC and lMinWidthD for USER

    prfnt->lMaxNegA   = pdevm->lMinA;
    prfnt->lMaxNegC   = pdevm->lMinC;
    prfnt->lMinWidthD = pdevm->lMinD;

// cxMax is now computed, copy it to FONTOBJ portion of the RFONTOBJ.

    pfo()->cxMax = prfnt->cxMax;

// Everythings OK.

    return TRUE;
}


/******************************Public*Routine******************************\
* VOID RFONTOBJ::vGetInfo (
*     PFONTINFO pfi
*     )
*
* Fills the FONTINFO buffer pointed to by pfi.
*
* Returns:
*   Nothing.
*
* History:
*  03-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vGetInfo(PFONTINFO pfi)
{
    RtlZeroMemory(pfi, sizeof(FONTINFO));

    pfi->cjThis = sizeof(FONTINFO);
    pfi->cGlyphsSupported = prfnt->pfdg->cGlyphsSupported;

    switch(prfnt->cBitsPerPel)
    {
    case 1:
        pfi->cjMaxGlyph1 = prfnt->cache.cjGlyphMax;
        break;

    case 4:
        pfi->cjMaxGlyph4 = prfnt->cache.cjGlyphMax;
        break;

    case 8:
        pfi->cjMaxGlyph8 = prfnt->cache.cjGlyphMax;
        break;

    case 32:
        pfi->cjMaxGlyph32 = prfnt->cache.cjGlyphMax;
        break;
    }

    if (bDeviceFont())
        pfi->flCaps |= FO_DEVICE_FONT;

    if (bReturnsOutlines())
        pfi->flCaps |= FO_OUTLINE_CAPABLE;
}


/******************************Public*Routine******************************\
* VOID RFONTOBJ::vSetNotionalToDevice (
*     EXFORMOBJ   &xfo
*     )
*
* Set the XFORMOBJ passed in to be the Notional to Device transform.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  03-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vSetNotionalToDevice(EXFORMOBJ &xo)  // set this transform
{
// Make sure to remove translations.

    xo.vRemoveTranslation();

// Set the rest of the transform matrix.

    xo.vSetElementsLToFx (
        prfnt->fdxQuantized.eXX,
        prfnt->fdxQuantized.eXY,
        prfnt->fdxQuantized.eYX,
        prfnt->fdxQuantized.eYY
        );

    xo.vComputeAccelFlags(XFORM_FORMAT_LTOFX);
}


/******************************Public*Routine******************************\
* BOOL RFONTOBJ::bSetNotionalToWorld (
*     EXFORMOBJ   &xoDToW,
*     EXFORMOBJ   &xo
*     )
*
* Set the incoming XFORMOBJ to be the Notional to World transform for this
* font.
*
* Returns:
*   TRUE if successful, FALSE if an error occurs.
*
* History:
*  27-Jan-1992 -by- Wendy Wu [wendywu]
* Changed calling interfaces.  Left translations alone as we can transform
* vectors now.
*  10-Oct-1991 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL RFONTOBJ::bSetNotionalToWorld (
    EXFORMOBJ   &xoDeviceToWorld,   // Device to World transform
    EXFORMOBJ   &xo                 // set this transform
    )
{
// Get empty xform to receive Notional to Device transform.

    MATRIX  mxNotionalToDevice;

// This constructor never fails.

    EXFORMOBJ    xoNotionalToDevice(&mxNotionalToDevice,DONT_COMPUTE_FLAGS);

// Set the transform matrix from Notional to Device space.

    xoNotionalToDevice.vSetElementsLToFx (
        prfnt->fdx.eXX,
        prfnt->fdx.eXY,
        prfnt->fdx.eYX,
        prfnt->fdx.eYY
        );

// Make sure to remove translations.

    xoNotionalToDevice.vRemoveTranslation();

// Calculate a Notional to World transform.
// Don't mind about translations.  We'll use this to transform vectors only.

    return(xo.bMultiply(xoNotionalToDevice, xoDeviceToWorld,
                COMPUTE_FLAGS | XFORM_FORMAT_LTOL));
}

/******************************Public*Routine******************************\
* RFONTOBJ::bCalcEscapementP (xo,lEsc)                                     *
*                                                                          *
* This is the internal routine that calculates the projection of the       *
* escapement onto the base and ascent vectors, as well as other useful     *
* escapement quantities.                                                   *
*                                                                          *
* This is expensive, call only when needed!                                *
*                                                                          *
*  Sat 21-Mar-1992 13:35:49 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RFONTOBJ::bCalcEscapementP(EXFORMOBJ& xo,LONG lEsc)
{
    ASSERTGDI((lEsc >= 0) && (lEsc < 3600),"Unnormalized angle!\n");

// Check for simple alignment with the orientation.

    if
    (
      (prfnt->ulOrientation < 3600) &&
      (
        ((ULONG) lEsc == prfnt->ulOrientation)
        || ((ULONG) lEsc == prfnt->ulOrientation + 1800)
        || ((ULONG) lEsc == prfnt->ulOrientation - 1800)
      )
    )
    {
        prfnt->lEscapement   = lEsc;
        prfnt->pteUnitEsc    = prfnt->pteUnitBase;
        prfnt->efWtoDEsc     = prfnt->efWtoDBase;
        prfnt->efDtoWEsc     = prfnt->efDtoWBase;
        prfnt->efEscToBase.vSetToOne();
        prfnt->efEscToAscent.vSetToZero();

        if ((ULONG) lEsc != prfnt->ulOrientation)
        {
            prfnt->pteUnitEsc.x.vNegate();
            prfnt->pteUnitEsc.y.vNegate();
            prfnt->efEscToBase.vNegate();
        }
        return(TRUE);
    }

// Do the general calculation.

    prfnt->lEscapement = -1;            // Assume failure.
    if (!xo.bComputeUnits
         (
          lEsc,
          &prfnt->pteUnitEsc,
          &prfnt->efWtoDEsc,
          &prfnt->efDtoWEsc
         )
       )
        return(FALSE);

/**************************************************************************\
* Compute the projections along the Base and Ascent axes.                  *
*                                                                          *
* We compute two quantities r  and r  as follows:                          *
*                            a      b                                      *
*                                                                          *
*    E = unit escapement vector                                            *
*    A = unit ascent vector                                                *
*    B = unit baseline vector                                              *
*                                                                          *
*         E x B           A x E                                            *
*    r  = -----      r  = -----                                            *
*     a   A x B       b   A x B                                            *
*                                                                          *
*                                                                          *
* These have the property that:                                            *
*                                                                          *
*    E = r A + r B                                                         *
*         a     b                                                          *
*                                                                          *
* This allows us to decompose the escapement vector.                       *
\**************************************************************************/

    EFLOAT ef;          // Ascent x Esc  or Esc x Base
    EFLOAT efNorm;      // Ascent x Base

    efNorm.eqCross(prfnt->pteUnitAscent,prfnt->pteUnitBase);
    if (efNorm.bIsZero())   // Too singular.
        return(FALSE);

    ef.eqCross(prfnt->pteUnitAscent,prfnt->pteUnitEsc);
    prfnt->efEscToBase.eqDiv(ef,efNorm);

    ef.eqCross(prfnt->pteUnitEsc,prfnt->pteUnitBase);
    prfnt->efEscToAscent.eqDiv(ef,efNorm);
    prfnt->lEscapement = lEsc;
    return(TRUE);
}


/******************************Public*Routine******************************\
* bGetNtoWScales
*
* Calculates the Notional to World scaling factor for vectors that are
* parallel to the baseline direction.
*
* History:
*  14-Apr-1992 14:23:49 Gilman Wong [gilmanw]
* Modified to support ascender scaling factor as well.
*  Sat 21-Mar-1992 08:03:14 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL bGetNtoWScales (
    EPOINTFL *peptflScale, // return address of scaling factors
    XDCOBJ& dco,            // defines device to world transformation
    PFD_XFORM pfdx,        // defines notional to device transformation
    PFEOBJ& pfeo,          // defines baseline direction
    BOOL *pbIdent          // return TRUE if NtoW is identity (with repsect
                           // to EVECTFL transormations, which ignore
                           // translations)
    )
{
    MATRIX    mxNtoD;
    EXFORMOBJ xoNtoD(&mxNtoD, DONT_COMPUTE_FLAGS);

    xoNtoD.vSetElementsLToFx(
        pfdx->eXX,
        pfdx->eXY,
        pfdx->eYX,
        pfdx->eYY
        );
    xoNtoD.vRemoveTranslation();
    xoNtoD.vComputeAccelFlags();  // XFORM_FORMAT_LTOFX is default

    IFIOBJ  ifio(pfeo.pifi());
    POINTL  ptlBase = *ifio.pptlBaseline();;

    EVECTORFL evflScaleBase(ptlBase.x, ptlBase.y);
    EVECTORFL evflScaleAsc;

    if ( ifio.bRightHandAscender() )
    {
        evflScaleAsc.x = -ptlBase.y;    // ascender is 90 deg CCW from baseline
        evflScaleAsc.y =  ptlBase.x;
    }
    else
    {
        evflScaleAsc.x =  ptlBase.y;    // ascender is 90 deg CW from baseline
        evflScaleAsc.y = -ptlBase.x;
    }

// assert ptlBase is normalized, this code would not work otherwise
// If base is normalized, ascender will also be normalized

    ASSERTGDI(
        (ptlBase.x * ptlBase.x + ptlBase.y * ptlBase.y) == 1,
        "gdisrv, unnormalized base vector\n"
        );

    if (!xoNtoD.bXform(evflScaleBase) || !xoNtoD.bXform(evflScaleAsc))
    {
        WARNING("gdisrv!bGetNtoWScale(): bXform(evflScaleBase or Asc) failed\n");
        return(FALSE);
    }

    if (!dco.pdc->bWorldToDeviceIdentity())
    {
    // The notional to world transformation is the product of the notional
    // to device transformation and the device to world transformation

        EXFORMOBJ xoDtoW(dco, DEVICE_TO_WORLD);
        if (!xoDtoW.bValid())
        {
            WARNING("gdisrv!bGetNtoWScale(): xoDtoW is not valid\n");
            return(FALSE);
        }

    #ifdef WASTE_TIME_MULTIPLYING_MATRICES

    // it is bit strange to do this multiply just to get this
    // accelerator [bodind]

        MATRIX    mxNtoW;
        EXFORMOBJ xoNtoW(&mxNtoW, DONT_COMPUTE_FLAGS);

        if (!xoNtoW.bMultiply(xoNtoD,xoDtoW))
        {
            WARNING("gdisrv!bGetNtoWScale(): xoNtoW.bMultiply failed\n");
            return(FALSE);
        }
        xoNtoW.vComputeAccelFlags(XFORM_FORMAT_LTOL);

        *pbIdent = xoNtoW.bTranslationsOnly();

    #endif //  WASTE_TIME_MULTIPLYING_MATRICES

    // forget about the acceleration in this infrequent case [bodind]

        *pbIdent = FALSE;

        if
        (
            (dco.pdc->iGraphicsMode() == GM_COMPATIBLE) &&
            !dco.pdc->bUseMetaPtoD()                   &&
            !ifio.bStroke()
        )
        {
        // win 31 way of doing it: they scale extent measured
        // along baseline by the (DtoW) xx component even if baseline in device
        // is along some other direction. Likewise they scale ascender extent by
        // DtoW yy component even if ascender is not collinear with y axis.
        // Note that win31 is here at least consistent with respect tt and
        // vector fonts: it returns text extent values that are screwed
        // in the same bogus way for tt and for vector fonts [bodind]

            evflScaleBase *= xoDtoW.efM11();
            evflScaleAsc  *= xoDtoW.efM22();

        // we have to do this becase in else part of the clause
        // this multiplication occurs within bXform

            evflScaleBase.x.vTimes16();
            evflScaleBase.y.vTimes16();

            evflScaleAsc.x.vTimes16();
            evflScaleAsc.y.vTimes16();
        }
        else // do the right thing
        {
            if (!xoDtoW.bXform(evflScaleBase) || !xoDtoW.bXform(evflScaleAsc))
            {
                WARNING("gdisrv! bXform(evflScaleBase or Asc) failed\n");
                return(FALSE);
            }
        }
    }
    else
    {
    // accelerate when user is asking for font at em ht

        *pbIdent = xoNtoD.bTranslationsOnly();
    }

// The baseline and ascender scaling factors are equal to the length of the
// transformed Notional baseline unit and ascender unit vectors, respectively.

    peptflScale->x.eqLength(*(POINTFL *) &evflScaleBase);
    peptflScale->y.eqLength(*(POINTFL *) &evflScaleAsc);

    return(TRUE);
}



/******************************Public*Routine******************************\
* RFONTOBJ::vInsert
*
* This function is used to help maintain a doubly linked list of RFONTs.
* Its purpose is to insert this RFONT into a list.  New RFONTs are always
* inserted at the head of the list.
*
* WARNING!
*
* Caller should always grab the ghsemRFONTList semaphore before calling any
* of the RFONT list funcitons.
*
* History:
*  23-Jun-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vInsert (
    PPRFONT pprfntHead,
    RFL_TYPE rflt
    )
{
    RFONTLINK *prflNew = NULL;
    RFONTLINK *prflOld = NULL;

// assert pprfntHead is different from prfnt, if they are same it will cause infinite loop

    ASSERTGDI(
        *pprfntHead != prfnt,
        "*pprfntHead is same as prfnt at RFONTOBJ::vInsert\n"
        );
        
// Which set of RFONT links should we use?

    switch (rflt)
    {
    case PFF_LIST:
        prflNew = &(prfnt->rflPFF);
        prflOld = (*pprfntHead != (PRFONT) NULL) ? &((*pprfntHead)->rflPFF) : (PRFONTLINK) NULL;
        break;

    case PDEV_LIST:
        prflNew = &(prfnt->rflPDEV);
        prflOld = (*pprfntHead != (PRFONT) NULL) ? &((*pprfntHead)->rflPDEV) : (PRFONTLINK) NULL;
        break;

    default:
        RIP("gdisrv!vInsertRFONTOBJ(): unknown list type\n");
        break;
    }

    if (prflNew != (RFONTLINK *) NULL)
    {
// Connect this RFONT to current head.

        prflNew->prfntPrev = (PRFONT) NULL;    // head of list has NULL prev
        prflNew->prfntNext = *pprfntHead;

// Connect current head to this RFONT.

        if (prflOld != (PRFONTLINK) NULL)
            prflOld->prfntPrev = prfnt;

// Make this RFONT the new head.

        *pprfntHead = prfnt;
    }
}


/******************************Public*Routine******************************\
* RFONTOBJ::vRemove
*
* This function is used to help maintain a doubly linked list of RFONTs.
* Its purpose is to remove this RFONT from the list.
*
* WARNING!
*
* Caller should always grab the ghsemRFONTList semaphore before calling any
* of the RFONT list funcitons.
*
* History:
*  23-Jun-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID RFONTOBJ::vRemove (
    PPRFONT pprfntHead,         // a pointer to the head of list
    RFL_TYPE rflt               // identifies which list to delete from list
    )
{
    RFONTLINK *prflVictim = NULL;
    RFONTLINK *prflPrev;
    RFONTLINK *prflNext;

// Which set of RFONT links should we use?

    switch (rflt)
    {
    case PFF_LIST:
        prflVictim = &(prfnt->rflPFF);
        prflPrev = (prflVictim->prfntPrev != (PRFONT) NULL) ? &(prflVictim->prfntPrev->rflPFF) : (PRFONTLINK) NULL;
        prflNext = (prflVictim->prfntNext != (PRFONT) NULL) ? &(prflVictim->prfntNext->rflPFF) : (PRFONTLINK) NULL;
        break;

    case PDEV_LIST:
        prflVictim = &(prfnt->rflPDEV);
        prflPrev = (prflVictim->prfntPrev != (PRFONT) NULL) ? &(prflVictim->prfntPrev->rflPDEV) : (PRFONTLINK) NULL;
        prflNext = (prflVictim->prfntNext != (PRFONT) NULL) ? &(prflVictim->prfntNext->rflPDEV) : (PRFONTLINK) NULL;
        break;

    default:
        RIP("gdisrv!vInsertRFONTOBJ(): unknown list type\n");
        break;
    }

// Case 1: this RFONT is at the head of the list.

    if ( prflVictim != (RFONTLINK *) NULL )
    {
        if ( prflVictim->prfntPrev == (PRFONT) NULL )
        {
        // Make the next RFONT the head of the list.

            (*pprfntHead) = prflVictim->prfntNext;
            if (prflNext != (RFONTLINK *) NULL)
                prflNext->prfntPrev = (PRFONT) NULL;    // head of list has NULL prev
        }

    // Case 2: this RFONT is not at the head of the list.

        else
        {
        // Connect previous RFONT to next RFONT.
        // Note: since we are guaranteed that this is NOT the head of the
        //       list, prflPrev is guaranteed !NULL.

            prflPrev->prfntNext = prflVictim->prfntNext;

        // Connect next RFONT to previous RFONT.

            if (prflNext != (RFONTLINK *) NULL)
                prflNext->prfntPrev = prflVictim->prfntPrev;
        }
    }
}

/******************************Public*Routine******************************\
* RFONTOBJ::lOverhang                                                      *
*                                                                          *
* The definitive routine to calculate the Win 3.1 compatible overhang for  *
* simulated bitmap fonts.                                                  *
*                                                                          *
*  Mon 01-Feb-1993 11:05:10 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

LONG RFONTOBJ::lOverhang()
{
    LONG  ll = 0;
    FLONG fl = prfnt->fobj.flFontType;

    if
    (
        (prfnt->ppfe->pifi->flInfo & (FM_INFO_TECH_BITMAP|FM_INFO_TECH_STROKE)) &&
        !bDeviceFont()
    )
    {
        if (fl & FO_SIM_ITALIC)
            ll = (prfnt->lMaxHeight - 1) / 2;

        if (fl & FO_SIM_BOLD)
        {
            IFIOBJ  ifio(prfnt->ppfe->pifi);

            if (!ifio.bStroke())   // if not vector font
            {
                ll += 1;
            }
            else // vector font
            {
            // overhang has to be computed by scaling (1,0) in notional
            // space to device space and taking the length of this vector.
            // However if length is < 1 we round it up to 1. This is windows
            // 3.1 compatible vector font "hinting" [bodind]

            // Set up transform.

                MATRIX      mx;
                EXFORMOBJ   xo(&mx, DONT_COMPUTE_FLAGS | XFORM_FORMAT_LTOFX);
                if (!xo.bValid())
                {
                    WARNING("gdisrv!lOverhang: XFORMOBJ\n");
                    return (FALSE);
                }

                vSetNotionalToDevice(xo);

                POINTL  ptlBase = *ifio.pptlBaseline();
                EVECTORFL evtflBase(ptlBase.x,ptlBase.y);

                if (!xo.bXform(evtflBase))
                {
                    WARNING("gdisrv!lOverhang(): transform failed\n");
                    return 1;
                }
                EFLOAT  ef;
                ef.eqLength(*(POINTFL *) &evtflBase);

                LONG lEmbolden = lCvt(ef,1);
                if (lEmbolden == 0)
                    lEmbolden = 1;
                ll += lEmbolden;
            }
        }
    }
    return(ll);
}

/******************************Public*Routine******************************\
* RFONTOBJ::bSetNewFDX (dco, bNeedPaths)                                        *
*
* This function props up the functionality of the RESETFCOBJ.  It either
* finds a new RFONT or creates one that matches the same ppfe as the current
* RFONT, but with a different Notional to World transform.
*
* Unlike the initialization routines, this function does not modify the DC
* in anyway.  In particular, it does not change the font realization selected
* into the DC.  So this is a peculiar sort of RFONTOBJ in that it can be
* used to get glyphs and metrics and such (and it is "compatible" with the
* DC passed in) but it is not selected into any DC.  It is, however, classified
* as an active RFONT.  It is the caller's responsibility to make the RFONT
* inactive (by calling vMakeInactive()).
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
\**************************************************************************/

BOOL RFONTOBJ::bSetNewFDX(XDCOBJ &dco, FD_XFORM &fdx, FLONG flType)
{
// Get PDEV user object (need for bFindRFONT)

    PDEVOBJ pdo(dco.hdev());
    ASSERTGDI(pdo.bValid(), "gdisrv!bSetNewFDXRFONTOBJ(): bad pdev in dc\n");

// go find the font

    EXFORMOBJ xoWtoD(dco, WORLD_TO_DEVICE);
    ASSERTGDI(xoWtoD.bValid(), "gdisrv!bSetNewFDXRFONTOBJ - bad WD xform in DC\n");

// Grab these out of the current RFONT so we can pass them into the find
// and realization routines.

    FLONG  flSim       = pfo()->flFontType & FO_SIM_MASK;
    ULONG  ulStyleSize = pfo()->ulStyleSize;
    POINTL ptlSim      = prfnt->ptlSim;
    PFE   *ppfe        = prfnt->ppfe;

// Release the cache semaphore.

    if (prfnt != PRFNTNULL )
    {
        vReleaseCache();
    }

// We will hold a reference to whatever PFF we are using while trying to
// realize the font.

    PFFREFOBJ pffref;
    pffref.vInitRef(prfnt->pPFF);

// Don't want to make the font inactive, but we must make the RFONTOBJ
// invalid.  So just set it to NULL.

    prfnt = PRFNTNULL;

// Attempt to find an RFONT in the lists cached off the PDEV.  Its transform,
// simulation state, style, etc. all must match.

    if
    (
        bFindRFONT
        (
            &fdx,
            flSim,
            ulStyleSize,
            pdo,
            &xoWtoD,
            ppfe,
            FALSE,
            dco.pdc->iGraphicsMode(),
            FALSE,
            flType
        )
    )
    {
        vGetCache();
        
        return TRUE;
    }

    LFONTOBJ lfo(dco.pdc->hlfntNew(), &pdo);
    if (!lfo.bValid())
    {
        WARNING("gdisrv!RFONTOBJ(dco): bad LFONT handle\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid

        return FALSE;
    }

//
// if we get here, we couldn't find an appropriate font realization.
// Now, we are going to create one just for us to use.
//

    if ( !bRealizeFont(&dco,
                       &pdo,
                       lfo.pelfw(),
                       ppfe,
                       &fdx,
                       (POINTL* const) &ptlSim,
                       flSim,
                       ulStyleSize,
                       FALSE,
                       FALSE, flType) )
    {
        WARNING("gdisrv!bSetNewFDXRFONTOBJ(): realization failed, RFONTOBJ invalidated\n");
        prfnt = PRFNTNULL;  // mark RFONTOBJ invalid

        return FALSE;
    }
    ASSERTGDI(bValid(), "gdisrv!bSetNewFDXRFONTOBJ(): invalid hrfnt from realization\n");

// We created a new RFONT, we better hold the PFF reference!

    pffref.vKeepIt();

// Finally, grab the cache semaphore.

    vGetCache();

    return TRUE;
}


/******************************Public*Routine******************************\
* bGetWidthTable (iMode,pwc,cwc,plWidth)
*
* Gets the advance widths for a bunch of glyphs at the same time.  Tries
* to do it the fast way with DrvQueryAdvanceWidths.  A value of NO_WIDTH
* is returned for widths that take too long to compute.
*
* Returns:
*   TRUE        If all widths are valid.
*   FALSE       If any widths are invalid.
*   GDI_ERROR   If an error occurred.
*
* History:
*  Wed 13-Jan-1993 03:21:59 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

#define HCOUNT  70

BOOL RFONTOBJ::bGetWidthTable(
    XDCOBJ&     dco,
    ULONG      cSpecial,    // Count of special chars.
    WCHAR     *pwcChars,    // Pointer to UNICODE text codepoints.
    ULONG      cwc,         // Count of chars.
    USHORT    *psWidth      // Width table (returned).
)
{
    ULONG    cBatch,ii,cc;
    WCHAR   *pwc;
    USHORT  *ps;
    BOOL     bRet = TRUE;
    GLYPHPOS gp;

// Locate the font driver.

    PDEVOBJ pdo(prfnt->hdevProducer);

// If it supports the easy function, just call it.

    if ( PPFNDRV( pdo, QueryAdvanceWidths ))
    {
        HGLYPH ahg[HCOUNT];

    // We need space to hold up the translated glyph handles, so we
    // batch the calls.

        cc  = cwc;
        ps  = psWidth;
        pwc = pwcChars;

        while (cc)
        {
            BOOL b;     // Tri-state BOOL.

            cBatch = (cc > HCOUNT) ? HCOUNT : cc;

        // Translate UNICODE to glyph handles.

        // It is important to note that vXlateGlyph array will set the
        // EUDC_WIDTH_REQUESTED flag if a linked character is encountered.
        // It will just return the glyph handle for the default glyph and
        // expects us to patch up this width later.

            vXlatGlyphArray(pwc,(UINT) cBatch,ahg);

        // Get easy widths from the driver.

            b = pdo.QueryAdvanceWidths
                (
                    prfnt->dhpdev,
                    pfo(),
                    QAW_GETEASYWIDTHS,
                    ahg,
                    (LONG *) ps,
                    cBatch
                );

#ifdef FE_SB
            if (b == GDI_ERROR)
            {
                prfnt->flEUDCState &= ~EUDC_WIDTH_REQUESTED;
                return(GDI_ERROR);
            }

            if( prfnt->flEUDCState & EUDC_WIDTH_REQUESTED )
            {
                prfnt->flEUDCState &= ~EUDC_WIDTH_REQUESTED;

            // If some of the widths requested were in a linked font, then patch
            // them up here.

                WCHAR wcDefault = prfnt->ppfe->pifi->wcDefaultChar;

                for( ii=0; ii < cBatch; ii++ )
                {
                    if( ( ahg[ii] == prfnt->hgDefault ) &&
                        ( pwc[ii] != wcDefault ) &&
                        ( bIsLinkedGlyph(pwc[ii]) || bIsSystemTTGlyph(pwc[ii])) )
                    {
                    	if (cwc - cc + ii < cSpecial )  /* perf: we want to hit the linked font only for required characters */
						{
                        	if (!bGetGlyphMetrics(1,&gp,&pwc[ii],&dco))
                            	return(GDI_ERROR);

                        	ps[ii] = (USHORT)(((GLYPHDATA*) gp.pgdf)->fxD);
                        }
                        else
                        {
                        	ps[ii] = NO_WIDTH;
                        	bRet = FALSE;
                        }
                    }
                }
            }
#endif
            bRet &= b;

        // Do the next batch.

            ps  += cBatch;
            pwc += cBatch;
            cc  -= cBatch;
        }
    }

// Otherwise just mark all widths invalid.

    else
    {
        for (ii=0; ii<cwc; ii++)
            psWidth[ii] = NO_WIDTH;
        bRet = FALSE;
    }

// Now make sure that all important widths are set, even if it's hard.

    if (!bRet)
    {
        for (ii=0; ii<cSpecial; ii++)
        {
            if (psWidth[ii] == NO_WIDTH)
            {
                if (!bGetGlyphMetrics(1,&gp,&pwcChars[ii],&dco))
                    return(GDI_ERROR);
                psWidth[ii] = (USHORT) ((GLYPHDATA*)gp.pgdf)->fxD;
            }
        }
    }

#ifdef FE_SB
    if (cwc == cSpecial)
      return((bRet == GDI_ERROR) ? (BOOL)GDI_ERROR : TRUE);

    else
#endif

    return(bRet);
}

/******************************Public*Routine******************************\
* bGetWidthData (pwd)                                                      *
*                                                                          *
* Gets font data which is useful on the client side.                       *
*                                                                          *
*  Thu 14-Jan-1993 00:52:43 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/


WCHAR RequestedDBCSChars[] = { 0x3000,   // Ideograhic Space
                               0x4e00,   // Kanji (digit one)
                               0xff21,   // FullWidth A
                               0x0000 };

WCHAR OptionalDBCSChars[]  = { 0x30a2,   // Katakana A
                               0x3041,   // Hiragana A
                               0x3131,   // Hangul Kiyeok
                               0x3400,   // Hangul Kiyeok A
                               0x4e08,   // Kanji (Take)
                               0x0000 };

BOOL RFONTOBJ::bGetWidthData(WIDTHDATA *pwd, XDCOBJ& dco)
{
    LONG fxHeight  = prfnt->lMaxHeight << 4;
    LONG fxCharInc = prfnt->lCharInc << 4;
    LONG fxBreak   = prfnt->fxBreak;

    LONG fxDBCSInc = 0;
    LONG fxDefaultInc;

    IFIOBJ  ifio(prfnt->ppfe->pifi);

// If this font has a SHIFTJIS charset and FM_DBCS_FIXED_PITCH is set (and it
// will be 99% of the time ) then the width of all DBCS characters will be
// equal to MaxCharInc.  Using the is information we can still compute client
// side extents and char widths for DBCS fonts.

    if( IS_ANY_DBCS_CHARSET(ifio.lfCharSet()) )
    {
        if( ifio.bDBCSFixedPitch() )
        {
            GLYPHPOS gp;
            WCHAR    wc;
            LONG     fxInc;
            ULONG    ulIndex = 0;

        // This logic is for .....
        //  In Japanese market, there is some font that has not all glyph
        // of SHIFT-JIS charset. This means some SHIFTJIS glyphs will be replace
        // default character, even it is a valid SHIFTJIS code.
        //  we cache widths in client side, its logic is that just retrun DBCS width
        // if the codepoint is valid SHIFTJIS codepoint. but above case real glyph is
        // default char, the width is incorrect. then we just define "Requested chars"
        // for DBCS font, if this font does not have all of these glyph, we don't
        // cache in client side.

            while( (wc = RequestedDBCSChars[ulIndex]) != 0x0000 )
            {
                if( !bGetGlyphMetrics(1,&gp,&wc, &dco) )
                {
                    return(FALSE);
                }

            // Does the glyph fall into the category of default glyph ?

                if( gp.hg == prfnt->hgDefault )
                {
                    return(FALSE); // we don't cache in client side...
                }

                ulIndex++;
            }

        // treat last char in the array of width as DBCS width.

            fxDBCSInc = (USHORT)(((GLYPHDATA*) gp.pgdf)->fxD);

            ulIndex = 0;

        // check Optional DBCS width.

            while( (wc = OptionalDBCSChars[ulIndex]) != 0x0000 )
            {
                if( !bGetGlyphMetrics(1,&gp,&wc) )
                {
                    return(FALSE);
                }

                fxInc = (USHORT)(((GLYPHDATA*) gp.pgdf)->fxD);

                fxDBCSInc = max(fxInc,fxDBCSInc);

                ulIndex++;
            }
        }
         else
        {
            // WARNING("bGetWidthDataRFONTOBJ: DBCS chars not fixed pitch\n");
            return(FALSE); // we don't cache in client side.
        }

        fxDefaultInc = (USHORT)(pgdDefault()->fxD);
    }

    if( ((fxHeight | fxCharInc | fxBreak | fxDBCSInc) & 0xFFFF0000L) == 0 )
    {
        pwd->sHeight  = (USHORT) fxHeight;
        pwd->sCharInc = (USHORT) fxCharInc;
        pwd->sBreak   = (USHORT) fxBreak;

    // for DBCS client side widhts

        pwd->sDBCSInc = (USHORT) fxDBCSInc;
        pwd->sDefaultInc = (USHORT) fxDefaultInc;


    // Set a Windows 3.1 compatible overhang.

        pwd->sOverhang = (USHORT) (lOverhang() << 4);

    // Get some important ANSI codepoints.

        IFIMETRICS *pifi = prfnt->ppfe->pifi;

        pwd->iFirst   = pifi->chFirstChar;
        pwd->iLast    = pifi->chLastChar;
        pwd->iDefault = pifi->chDefaultChar;
        pwd->iBreak   = pifi->chBreakChar;
        return(TRUE);
    }
    return(FALSE);
}


/************************Public*Routine*****************\
*  RFONTOBJ::vChnageiTTUniq
*
* This is only called by PreTextOut()
\*******************************************************/
void RFONTOBJ::vChangeiTTUniq(FONTFILE_PRINTKVIEW *pPrintKview)
{
    ULONG       i;
    ULONG_PTR   uPFE, uPFEend;
    ULONG_PTR   iTTUniq;

    uPFE = (ULONG_PTR)ppfe();
    uPFEend = uPFE + sizeof(PFE);
    iTTUniq = pPrintKview->iTTUniq;

    if (pfo()->flFontType & TRUETYPE_FONTTYPE)
    {            
        if ((iTTUniq >= uPFE) && (iTTUniq < uPFEend))
        {
            if (iTTUniq < (--uPFEend))
            {
                pPrintKview->iTTUniq++;
            }
            else
            {
                pPrintKview->iTTUniq = uPFE;
            }
            pfo()->iTTUniq = pPrintKview->iTTUniq;
        }
    }
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ:PreTextOut
*
* Routine Description:
*
*   Called before calling to any DrvTextOut to prepare for callbacks
*   to FONTOBJ_pjOpenTypeTable and FONTOBJ_pvTrueTypeFontFile.
*
* Arguments:
*
*   none
*
* Called by:
*
*   bProxyTextOut, GreExtTextOutWLocked
*
* Return Value:
*
*   none
*
\**************************************************************************/

void RFONTOBJ::PreTextOut(XDCOBJ& dco)
{
    FONTFILE_PRINTKVIEW  *pPrintKView;
    
    if (dco.bPrinter() && !dco.bUMPD() && !bDeviceFont())
    {
        SEMOBJ so(ghsemPrintKView);

        pPrintKView = gpPrintKViewList;

        while (pPrintKView)
        {
            if (pPrintKView->hff == pPFF()->hff)
            {
                pPrintKView->cPrint++;

                if (pPrintKView->pKView == NULL)
                {
                    vChangeiTTUniq(pPrintKView);
                }
            }

            pPrintKView = pPrintKView->pNext;
        }
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ::pvFile
*
* Routine Description:
*
*   Generates a kernel mode pointer to the associated font file.
*
* Arguments:
*
*   pcjFile - address of 32-bit variable to receive the size
*             of the TrueType file in bytes.
*
* Called by:
*
*   FONTOBJ_pvTrueTypeFontFile
*
* Return Value:
*
*   A kernel mode pointer to the associated font file.
*
\**************************************************************************/

PVOID RFONTOBJ::pvFile(ULONG *pcjFile)
{
    char *pchFile;
    ULONG cjFile;

    pchFile = 0;
    cjFile = 0;

    PDEVOBJ pdo( prfnt->hdevProducer );
    if ( pdo.bValid() )
    {
        PFF *pPFF;
        if ( pPFF = prfnt->pPFF )
        {
            HFF hff;
            if ( hff = pPFF->hff )
            {
                if ( pchFile = (char*) pdo.GetTrueTypeFile( hff, &cjFile ))
                {
                    pchFile = pchTranslate( pchFile );
                }
            }
        }
    }

    if ( pchFile == 0 )
    {
        cjFile = 0;
    }
    if ( pcjFile )
    {
        *pcjFile = cjFile;
    }

    return( pchFile );
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ::pjTable
*
* Routine Description:
*
*   Generates a kernel mode view of a particular table in the associated
*   OpenType font file.
*
* Arguments:
*
*   ulTag     a 4-byte tag of the table according to the OpenType
*             conventions
*
*   pcjTable  the address of a 32-bit variable that will receive the size
*             of the table in bytes.
*
* Called by:
*
*   FONTOBJ_pjOpenTypeTable
*
* Return Value:
*
*   a kernel mode pointer to the desired OpenType table
*
\**************************************************************************/

BYTE *RFONTOBJ::pjTable( ULONG ulTag, ULONG *pcjTable )
{
    BYTE *pjTable = 0;
    ULONG cjTable = 0;

    PDEVOBJ pdo( prfnt->hdevProducer );
    if ( pdo.bValid() )
    {
        PFF *pPFF;
        LONG lRet;

        if ( pPFF = prfnt->pPFF )
        {
            HFF hff;
            if ( hff = pPFF->hff )
            {
                lRet = pdo.QueryTrueTypeTable( hff,
                                               1,
                                               ulTag,
                                               0,
                                               0,
                                               0,
                                               &pjTable,
                                               &cjTable
                                               );
                if ( lRet == FD_ERROR )
                {
                    pjTable = 0;
                }
                else
                {
                    pjTable = (BYTE*) pchTranslate( (char*) pjTable );
                }
            }
        }
    }

    if ( pjTable == 0 )
    {
        cjTable = 0;
    }
    if ( pcjTable )
    {
        *pcjTable = cjTable;
    }
    return( pjTable );
}

/*******************************Public*Routine********************************\
* Routine Name:
*
*   bFindPrintKView()
*
* Routine Description:
*
*   This routine goes through the gpPrintKViewList and try to find whether
* there is an existing node matches hff and iFile.
*
* Return:
*  TRUE if it finds a matching node (hff and iFile), and pNode contains
* the address of the matching node.
* Note that the pKView in the node might be NULL, which requires the caller
* to re-map the view.
*
*  FALSE if it doesn't find a match node.
*
* History:
*   02-Jun-1999     Xudong Wu [tessiew]
* Wrote it.
\*****************************************************************************/
BOOL bFindPrintKView(
    HFF     hff,
    ULONG   iFile,
    FONTFILE_PRINTKVIEW **ppNode
)
{
    ASSERTGDI(hff, "bFindPrintKView, hff == 0\n");
    FONTFILE_PRINTKVIEW *pPrintKView;
  
    *ppNode = NULL;
    
    SEMOBJ so(ghsemPrintKView);
    
    pPrintKView = gpPrintKViewList;

    while (pPrintKView)
    {
        if
        (
            (pPrintKView->hff == hff) && (pPrintKView->iFile == iFile)     // matching node
        )
        {
            *ppNode = pPrintKView;
            return TRUE;
        }

        pPrintKView = pPrintKView->pNext;
    }

    return FALSE;
}

/**********************Public*Routine************************\
* Routine Name:
*
*   bAddPrintKView()
*
* Routine Description:
*
* This routine either adds a new node or update the pKView
* in an existing node to the global gpPrintKViewList
* 
* If pNode is not NULL, it points to the existing node with
* the matching hff and iFile.
*
* History:
*   02-Jun-1999     Xudong Wu [tessiew]
* Wrote it.
\************************************************************/
BOOL bAddPrintKView(
    HFF hff,
    PVOID pvKView,
    ULONG iFile,
    ULONG_PTR iTTUniq,
    FONTFILE_PRINTKVIEW *pNode
)
{
    FONTFILE_PRINTKVIEW  *pNew = NULL;

    SEMOBJ so(ghsemPrintKView);
    
    // pNode != NULL, existing node with matching hff and iFile
    
    if (pNode) // just updating the pointer, cPrint is ++'ed at PreTextOut time
    {
        pNode->pKView = pvKView;
    }
    else    // new node
    {
        pNew = (FONTFILE_PRINTKVIEW *)PALLOCMEM(sizeof(FONTFILE_PRINTKVIEW), 'pmtG');

        if (pNew)
        {
            pNew->hff = hff;
            pNew->pKView = pvKView;
            pNew->iFile = iFile;
            pNew->cPrint = 1;
            pNew->iTTUniq = iTTUniq;

        // put it at the head of the linked list

            pNew->pNext = gpPrintKViewList;
            gpPrintKViewList = pNew;
        }
        else
            return FALSE;
    }
    return TRUE;
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ::pchTranslate
*
* Routine Description:
*
*   This routine returns a pointer into a kernel mode view of a font file.
*   If the argument is a kernel mode address then this routine simply
*   returns the same address. If the argument is a user mode address
*   then this routine will map a kernel mode view of the font, if
*   necessary, and translate the user mode pointer into an equivalent
*   kernel mode pointer. If it is necessary to map a kernel mode view
*   this routine records that fact in the global list. This view will be
*   unmapped when the fontcontext goes away or at the "clean up" time.
*
* Arguments:
*
*   pch  a pointer into the font file. This may be either a user mode
*        view or a kernel mode view.
*
* Called by:
*
*   RFONTOBJ::pjTable
*   RFONTOBJ::pvFile
*
* Return Value:
*
*   a kernel mode pointer to the desired offset into the font file
*
\**************************************************************************/

char* RFONTOBJ::pchTranslate(char *pch)
{
    NTSTATUS NtStatus;
    ULONG iKernelBase;
    char *pchBase;
    PFF *pPFF_;
    FONTFILEVIEW **ppFFV, *pFFV;
    PVOID pvKView;
    FONTFILE_PRINTKVIEW *pNode = NULL;
    HFF hff;

    //??? is it possible that pch is a kernel address? if so, what should we return?
    if (pch &&
        IS_USER_ADDRESS(pch) &&
        (pPFF_ = prfnt->pPFF) &&
        (hff = pPFF_->hff) &&
        (ppFFV = pPFF_->ppfv))
    {
        for (iKernelBase = 0; iKernelBase < pPFF_->cFiles; ppFFV++, iKernelBase++)
        {
            if (pFFV = *ppFFV)
            {
                pchBase = (char*) ((pFFV->SpoolerBase) ? pFFV->SpoolerBase : pFFV->fv.pvViewFD);

                if (pchBase && (pchBase <= pch) && (pch < pchBase + pFFV->fv.cjView))
                {
                    if (!bFindPrintKView(hff, iKernelBase, &pNode) || (pNode->pKView == NULL))
                    {
                        if (pFFV->fv.pSection)
                        {
                            if (NT_SUCCESS(MapFontFileInKernel(pFFV->fv.pSection, &pvKView)))
                            {
                                if (bAddPrintKView(hff, pvKView, iKernelBase, (ULONG_PTR)ppfe(), pNode))
                                {
                                    return (pch - pchBase + (char*)pvKView);
                                }
                                else
                                {
                                    vUnmapFontFileInKernel(pvKView);
                                    return NULL;
                                }
                            }
                        }
                        else
                        {
                            RIP("pSection = 0\n");
                        }
                    }
                    else
                    {
                        pvKView = pNode->pKView;
                        return (pch - pchBase + (char*)pvKView);
                    }
                }
            }
        }
    }

    return NULL;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   RFONTOBJ:PostTextOut
*
* Routine Description:
*
*   Called after calling to any DrvTextOut to keep track of cPrint count
*
* Arguments:
*
*   none
*
* Called by:
*
*   bProxyTextOut, GreExtTextOutWLocked
*
* Return Value:
*
*   none
*
\**************************************************************************/

void RFONTOBJ::PostTextOut(XDCOBJ& dco)
{
    FONTFILE_PRINTKVIEW  *pPrintKView;

    if (dco.bPrinter() && !dco.bUMPD() && !bDeviceFont())
    {
        SEMOBJ so(ghsemPrintKView);

        pPrintKView = gpPrintKViewList;

        while (pPrintKView)
        {
            if (pPrintKView->hff == pPFF()->hff)
            {
                if (pPrintKView->cPrint)
                {
                    pPrintKView->cPrint--;
                }
            }
            pPrintKView = pPrintKView->pNext;
        }
    }
}


/*******************Public*Routine***********************\
* Routine Name:
*
*   vClosePrintKView()
*
* Routine Description:
*
*   This routine goes through the global gpPrintKViewList
* and unmap all the kernel views, except for those "few" at
* that are at the moment used by DrvTextOut calls.
*   This is only called when the first attemp of mapping
* a kernel view on a font file failed.
\********************************************************/

void vClosePrintKView()
{
    FONTFILE_PRINTKVIEW *pPrintKView;

    SEMOBJ so(ghsemPrintKView);

    pPrintKView = gpPrintKViewList;

    while(pPrintKView)
    {
        if
        (
            (pPrintKView->cPrint == 0) && // no DrvTextOut calls in progress with this font
            pPrintKView->pKView           // and file is mapped
        )
        {
            vUnmapFontFileInKernel(pPrintKView->pKView);
            pPrintKView->pKView = NULL;
        }
        pPrintKView = pPrintKView->pNext;
    }
}

/***********************Public*Routine***************************\
* Routine Name:
*
*   MapFontFileInKernel(void* void**)
*
* Routine Description:
*
*   This routine maps a font file in kernel.
\****************************************************************/
NTSTATUS  MapFontFileInKernel(void *pSection, void** ppvKView)
{
    NTSTATUS NtStatus;
    SIZE_T Dummy;

    *ppvKView = NULL;
    Dummy = 0; // map entire section into kernel

#if defined(_GDIPLUS_)
    NtStatus = MapViewInProcessSpace(
                    pSection,
                    ppvKView,
                    &Dummy);
#elif defined(_HYDRA_)
    // MmMapViewInSessionSpace is internally promoted to
    // MmMapViewInSystemSpace on non-Hydra systems.

    NtStatus = Win32MapViewInSessionSpace(pSection,
                                          ppvKView,
                                          &Dummy);
#else
    NtStatus = MmMapViewInSystemSpace(pSection,
                                      ppvKView,
                                      &Dummy);
#endif
    
    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("MapFontViewInKernel -- failure at the first attemp\n");

        vClosePrintKView();

        // try again

        #if defined(_GDIPLUS_)
            NtStatus = MapViewInProcessSpace(
                            pSection,
                            ppvKView,
                            &Dummy);
        #elif defined(_HYDRA_)
            // MmMapViewInSessionSpace is internally promoted to
            // MmMapViewInSystemSpace on non-Hydra systems.

            NtStatus = Win32MapViewInSessionSpace(pSection,
                                                  ppvKView,
                                                  &Dummy);
        #else
            NtStatus = MmMapViewInSystemSpace(pSection,
                                              ppvKView,
                                              &Dummy);
        #endif
    }

#ifdef _HYDRA_
#if DBG
    if (!G_fConsole)
    {
        DebugGreTrackAddMapView(*ppvKView);
    }
#endif
#endif

    return (NtStatus);
}


/**********************Public*Routine****************************\
* Routine Name:
*
*   vUnmapFontFileInKernel(void*)
*
* Routine Description:
*
*   This routine unmap the kernel font file view
\****************************************************************/

VOID vUnmapFontFileInKernel(void *pvKView)
{
#if defined(_GDIPLUS_)
    UnmapViewInProcessSpace(pvKView);
#elif defined(_HYDRA_)
    // MmUnmapViewInSessionSpace is internally promoted to
    // MmUnmapViewInSystemSpace on non-Hydra systems.
    
    Win32UnmapViewInSessionSpace(pvKView);
#else
    MmUnmapViewInSystemSpace(pvKView);
#endif
    
#ifdef _HYDRA_
#if DBG
    if (!G_fConsole)
    {
        DebugGreTrackRemoveMapView (pvKView);
    }
#endif
#endif
}


/*******************Public*Routine********************\
* vCleanupPrintKViewList
*
* For MultiUserNtGreCleanup (Hydra) cleanup.
*
* Worker functions for MultiUserGreCleanupAllFonts.
*
*
* History:
*  01-Jun-1999 -by- Xudong Wu [tessiew]
* Wrote it.
\*****************************************************/
void vCleanupPrintKViewList()
{
    FONTFILE_PRINTKVIEW *pPrintKView, *pNext;

    pNext = gpPrintKViewList;

    while(pNext)
    {
        ASSERTGDI(!pNext->pKView, "vCleanupPrintKViewList: unmapped pKView\n");

        pPrintKView = pNext;
        pNext = pPrintKView->pNext;

        VFREEMEM(pPrintKView);
    }
}


/*********************Public*Routine*******************\
* Routine Name:
*
*   UnmapPrintKView(char*)
*
* Routine Description:
*
* This routine is ONLY called at DestroyFont time
* when the cRFONT refer count in RFONT is ONE.
* 
*
* History:
*   02-Jun-1999     Xudong Wu [tessiew]
* Wrote it.
\******************************************************/
void UnmapPrintKView(HFF hff)
{
    FONTFILE_PRINTKVIEW *pPrintKView;

    SEMOBJ so(ghsemPrintKView);

    pPrintKView = gpPrintKViewList;

    while(pPrintKView)
    {        
        if (pPrintKView->hff == hff && pPrintKView->pKView)
        {
            ASSERTGDI(!pPrintKView->cPrint, "UnmapPrintKView: cPrint != 0\n");

            vUnmapFontFileInKernel(pPrintKView->pKView);

            pPrintKView->pKView = NULL;
        }
        pPrintKView = pPrintKView->pNext;        
    }
}



//
// Implementation of pvFile and pchTranslate for UMPD.
// Here we need to map the font file into the current process' user mode address
// instead of kernel's address space.
//

PVOID
RFONTOBJ::pvFileUMPD(
    ULONG *pcjFile,
    PVOID *ppBase
    )

{
    CHAR    *pchFile = NULL;
    ULONG   cjFile = 0;
    PFF     *pPFF;
    HFF     hff;

    PDEVOBJ pdo( prfnt->hdevProducer );

    //
    // pdo.GetTrueTypeFile returns a user mode address in
    // CSR process' address space.
    //

    if (pdo.bValid() &&
        (pPFF = prfnt->pPFF) != NULL &&
        (hff = pPFF->hff) != NULL &&
        (pchFile = (CHAR *) pdo.GetTrueTypeFile(hff, &cjFile)) != NULL)
    {
        //
        // We now need to translate that address into
        // the current process' address space.
        //

        pchFile = pchTranslateUMPD(pchFile, ppBase);
    }

    if (pchFile == NULL)
        cjFile = 0;

    if (pcjFile)
        *pcjFile = cjFile;

    return pchFile;
}


CHAR*
RFONTOBJ::pchTranslateUMPD(
    CHAR    *pch,
    PVOID   *ppBase
    )

{
    NTSTATUS        NtStatus;
    ULONG           iKernelBase;
    CHAR            *pchBase;
    PFF             *pPFF_;
    FONTFILEVIEW    **ppFFV, *pFFV;
    VOID            *pSaveFirstSpoolerBase, *pFinalSpoolerBase;
    VOID            *pSaveFirstSection, *pFinalSection;

    if ((pch != NULL) &&
        IS_USER_ADDRESS(pch) &&
        (pPFF_ = prfnt->pPFF) != NULL &&
        (ppFFV = pPFF_->ppfv) != NULL)
    {
        for (iKernelBase = 0; iKernelBase < pPFF_->cFiles; ppFFV++, iKernelBase++)
        {
            if ((pFFV = *ppFFV) == NULL)
                continue;

            //type 1 fonts have 2 files, we save the pSection and SpoolerBase and use for 2nd, 3rd file
			
            if (iKernelBase == 0){

                // pSection for 1st File is NULL bail out

               if ( pFFV->fv.pSection == NULL){ 
               
	          RIP("pSection == NULL\n");  
                  return NULL;
	       }

               //save the valid pSection and pSpoolerBase of the 1st font 

               pSaveFirstSection = pFFV->fv.pSection;     
               pSaveFirstSpoolerBase = pFFV->SpoolerBase; 

            }

            if (pFFV->fv.pSection != NULL){ 

              // valid pSection, so we use it

              pFinalSection = pFFV->fv.pSection;
	      pFinalSpoolerBase = pFFV->SpoolerBase; 
    	
            }else{
		
                // not a valid pSection, use the values from the first file
                // we will never get here for the first file
				
	        pFinalSection = pSaveFirstSection ;
                pFinalSpoolerBase = pSaveFirstSpoolerBase; 

	    }


            pchBase = (CHAR*) ((pFinalSpoolerBase) ? pFinalSpoolerBase : pFFV->fv.pvViewFD);

            if (pchBase && (pchBase <= pch) && (pch < pchBase + pFFV->fv.cjView))
            {
				

                LARGE_INTEGER   SectionOffset;
                SIZE_T          ViewSize;

                *ppBase = NULL;
                ViewSize = 0;
                RtlZeroMemory(&SectionOffset, sizeof(SectionOffset));

                NtStatus = MmMapViewOfSection(
                                pFinalSection,
                                PsGetCurrentProcess(),
                                ppBase,
                                0,
                                pFFV->fv.cjView,
                                &SectionOffset,
                                &ViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READONLY);

                if (!NT_SUCCESS(NtStatus))
                {
                    WARNING("RFONTOBJ::pchTranslateUMPD: MmMapViewOfSection failed\n");
                    *ppBase = NULL;

                    return NULL;
                }

                return (CHAR *) *ppBase + (pch - pchBase);
            }
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rgn2path.cxx ===
/******************************Module*Header*******************************\
* Module Name: rgn2path.cxx                                                *
*                                                                          *
* Created: 14-Sep-1993 11:00:07                                            *
* Author: Kirk Olynyk [kirko]                                              *
*                                                                          *
* Copyright (c) 1993-1999 Microsoft Corporation                                 *
*                                                                          *
* Discussion                                                               *
*                                                                          *
* Input                                                                    *
*                                                                          *
*     The input to the diagonalization routing is a rectangular            *
*     path whose vertices have integer endpoints.  Moreover it             *
*     is required that the path always has the region on its               *
*     left and that successive lines are mutually orthogonal.              *
*                                                                          *
*     All paths are in device 28.4 coordinates.  (Since all of             *
*     the input coordinates are integers, the fractional part of all       *
*     coordinates is zero.)                                                *
*                                                                          *
* Output                                                                   *
*                                                                          *
*     A path that contains the same pixels as the originl path.            *
*                                                                          *
* Filling Convention                                                       *
*                                                                          *
*     Any region bounded by two non-horizontal lines is closed             *
*     on the left and open on the right. If the region is bounded          *
*     by two horizontal lines, it is closed on the top and open on         *
*     bottom.                                                              *
*                                                                          *
* Definition                                                               *
*                                                                          *
*     A CORNER is subsequence of two lines from the orignal axial path.    *
*     It is convenient to partition the set of corners into two classes;   *
*     HORIZONTAL-VERTIAL and VERTICAL-HORIZONTAL.                          *
*                                                                          *
*     A corner is "diagonalizable" the original two lines can be replaced  *
*     by a single diagonal line such that same pixels would be rendered    *
*     (using the filling convention defined above).                        *
*                                                                          *
*                                                                          *
* Nomenclature                                                             *
*                                                                          *
*       S ::= "SOUTH" ::= one pixel move in +y-direction                   *
*       N ::= "NORTH" ::= one pixel move in -y-direction                   *
*       E ::= "EAST"  ::= one pixel move in +x direction                   *
*       W ::= "WEST"  ::= one pixel move in -x direction                   *
*                                                                          *
*     The set of diagonalizable corners are described by                   *
*     the following regular expressions:                                   *
*                                                                          *
*      DIAGONALIZABLE CORNERS                                              *
*                                                                          *
*         S(E+|W+)  a one pixel move in the +y-direction                   *
*                   followed by at least one pixel in any horizontal       *
*                   direction                                              *
*                                                                          *
*         S+W       an arbitary number of pixels in the +y-direction       *
*                   followed by a single pixel move in the                 *
*                   negative x-direction.                                  *
*                                                                          *
*         EN+       a one pixel move in the positive x-direction           *
*                   followed by at least one pixel move in the negative    *
*                   x-direction                                            *
*                                                                          *
*         (E+|W+)N  at least one-pixel move in the horizontal followed     *
*                   by a single pixel move in the negative                 *
*                   y-direction.                                           *
*                                                                          *
* Algorithm                                                                *
*                                                                          *
* BEGIN                                                                    *
*    <For each corner in the orginal path>                                 *
*    BEGIN                                                                 *
*        <if the corner is diagonalizable> THEN                            *
*                                                                          *
*            <just draw a single diagonal line>                            *
*        ELSE                                                              *
*            <draw both legs of the original corner>                       *
*    END                                                                   *
*                                                                          *
*    <Go around the path once again, merging successive                    *
*     identical moves into single lines>                                   *
* END                                                                      *
*                                                                          *
*     In the code, both of these steps are done in parallel                *
*                                                                          *
* Further Improvements                                                     *
*                                                                          *
*  The output path the I generate with this algorithm will contain only    *
*  points that were vertices of the original axial path. A larger of       *
*  regular expressions could be searched for if I were willing to          *
*  consider using new vertices for the output path. For example            *
*  the regular exprssios N+WN and S+ES describe two "chicane turns" that   *
*  can be diagonalized. The price to be paid is the a more complex         *
*  code path.                                                              *
*                                                                          *
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bDiagonalize                                             *
*                                                                          *
*   Produces a diagonalized path that is pixel equivalent.                 *
*                                                                          *
* Assumptions                                                              *
*                                                                          *
*   0. *this is the original path which will not be changed.               *
*   1. All points on the path lie on integers                              *
*   2. All subpaths have the inside on the left                            *
*   3. All subpaths are closed                                             *
*                                                                          *
* History:                                                                 *
*  Mon 13-Sep-1993 15:53:50 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RTP_PATHMEMOBJ::bDiagonalizePath(EPATHOBJ* pepoOut_)
{
    pepoOut     = pepoOut_;
    bMoreToEnum = TRUE;
    vEnumStart();
    while (bFetchSubPath())
    {
        if (!bDiagonalizeSubPath())
        {
            return(FALSE);
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bFetchSubPath                                            *
*                                                                          *
* History:                                                                 *
*  Wed 15-Sep-1993 14:19:14 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RTP_PATHMEMOBJ::bFetchSubPath()
{
    BOOL bRet = FALSE;

    if (bMoreToEnum) {

        // first we whiz on by any empty subpaths

        do {
            bMoreToEnum = bEnum(&pd);
        } while ((pd.count == 0) && (bMoreToEnum));

        if (pd.count && (pd.flags & PD_BEGINSUBPATH) && pd.pptfx) {
            // record the first point in the sub-path, we will need it later
            // when dealing with the last corner in the path

            ptfxFirst = *(pd.pptfx);
            bRet = TRUE;
        }
        else
            WARNING("RTP_PATHMEMOBJ::bFetchSubPath -- bad SubPath\n");
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bWritePoint                                              *
*                                                                          *
* This routine takes as input a candidate point for writing. However       *
* this routine is smart in that it analyzes the stream of candidate        *
* points looking for consecutive sub-sets of points that all lie on the    *
* same line. When such a case is recognized, then only the endpoints of    *
* the interpolating line are actually added to the output path.            *
*                                                                          *
* I do not go to a great deal of trouble to determine if a candidate       *
* point is on a line. All that I do is to see if the vector increment      *
* to the new point  is the same as the increment between prior points      *
* in the input path.                                                       *
*                                                                          *
* History:                                                                 *
*  Mon 13-Sep-1993 15:53:35 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RTP_PATHMEMOBJ::bWritePoint()
{
    POINTFIX ptfxNewAB;
    BOOL bRet = TRUE;
    int  jA   = j;

    if (cPoints == 2)
    {
        ptfxNewAB.x = aptfx[jA].x - aptfxWrite[1].x;
        ptfxNewAB.y = aptfx[jA].y - aptfxWrite[1].y;
        if (ptfxNewAB.x != ptfxAB.x || ptfxNewAB.y != ptfxAB.y)
        {
            if (!(bRet = pepoOut->bPolyLineTo(aptfxWrite,1)))
            {
                WARNING((
                    "pepoOut->bPolyLineTo(aptfxWrite,1) failed when"
                    " called from RTP_PATHMEMOBJ::bWritePoint()\n"
                    ));
            }
            else
            {
                aptfxWrite[0] = aptfxWrite[1];
                ptfxAB   = ptfxNewAB;
            }
        }
        aptfxWrite[1] = aptfx[jA];
    }
    else if (cPoints == 0)
    {
        aptfxWrite[0] = aptfx[jA];
        cPoints += 1;
    }
    else if (cPoints == 1)
    {
        aptfxWrite[1] = aptfx[jA];
        ptfxAB.x = aptfxWrite[1].x - aptfxWrite[0].x;
        ptfxAB.y = aptfxWrite[1].y - aptfxWrite[0].y;
        cPoints += 1;
    }
    else
    {
        RIP("RTP_PATHMEMOBJ::bWritePoint -- bad cPoints\n");
        bRet = FALSE;
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* bFetchNextPoint  ... in sub-path                                         *
*                                                                          *
* History:                                                                 *
*  Tue 14-Sep-1993 14:13:01 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RTP_PATHMEMOBJ::bFetchNextPoint()
{
#define TRUE_BIT 1
#define DONE_BIT 2

    int jold;
    int flag = TRUE_BIT;

    // advance the corner buffer along the path
    // jold points to the stale member of the corner buffer. This is
    // where we will store the new point in the path

    jold = j;
    j++;
    if (j > 2)
    {
        j -= 3;
    }
    if (pd.count == 0)
    {
        // there are no points left in the current batch.

        if (pd.flags & PD_ENDSUBPATH)
        {
            // If the PD_ENDSUBPATH flag was set, then we must add
            // into this path the first point in the subpath. This
            // is done so that later on, we can examine the last
            // corner which, of course, contains the first point.

            afl[jold]   = 0;
            aptfx[jold] = ptfxFirst;   // close the path
            pd.count -= 1;
            flag = DONE_BIT | TRUE_BIT;
        }
        else
        {
            ASSERTGDI(
                bMoreToEnum,
                "RTP_PATHMEMOBJ::bFetchNextPoint() -- bMoreToEnum == FALSE\n"
                );

            // If you get to here, you have exhauseted the current batch of
            // points, but there are more points left to be fetched for the
            // current subpath. This means that we will have to make another
            // call to bEnum()

            bMoreToEnum = bEnum(&pd);

            // At this point I check to make sure that the returned batch makes
            // sense

            if (!(pd.count > 0 && ((pd.flags & PD_BEGINSUBPATH) == 0) && pd.pptfx))
            {
                WARNING("RTP_PATHMEMOBJ::bFetchNextPoint -- bad pd\n");
                flag = DONE_BIT;
            }
        }
    }

    if (!(flag & DONE_BIT))
    {
        if ((LONG) pd.count > 0)
        {
            aptfx[jold] = *(pd.pptfx);
            if (pd.count == 1 && (pd.flags & PD_ENDSUBPATH))
            {
                afl[jold] = RTP_LAST_POINT;
            }
            else
            {
                afl[jold] = 0;
            }
            pd.pptfx += 1;
            pd.count -= 1;
        }
        else
        {
            ASSERTGDI(
                (LONG) pd.count > -3,
                "RTP_PATHMEMOBJ::bFetchNextPoint -- pd.count < -2\n"
                );
        }
    }
    return((BOOL) flag & TRUE_BIT);
}

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bDiagonalizeSubPath                                      *
*                                                                          *
* History:                                                                 *
*  Tue 14-Sep-1993 12:47:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

#define ROTATE_BACKWARD(x,y,z) {int ttt = x; x = z; z = y; y = ttt;}
#define ROTATE_FORWARD(x,y,z)  {int ttt = x; x = y; y = z; z = ttt;}

BOOL RTP_PATHMEMOBJ::bDiagonalizeSubPath()
{
    FIX fxAB;    // length of the first leg
    FIX fxBC;    // length of the second leg
    int bH;      // set to 1 if second leg is horizontal
    int jA,jB,jC;
    register BOOL bRet = TRUE; // if FALSE then return immediately
                               // otherwise keep processing.

    cPoints = 0; // no points so far in the write buffer
    j       = 0; // set the start of the circular buffer

    // Fill the circular buffer with the first three points of the
    // path. The three member buffer, defines two successive lines, or
    // one corner (the path is guaranteed to be composed of alternating
    // lines along the x-axis and y-axis). I shall label the three vertices
    // of the corner A,B, and C. The point A always resides at ax[j],
    // point B resides at ax[iMod3[j+1]], and point C resides at
    // ax[iMod3[j+2]] where j can have one of the values 0, 1, 2.

    if (bRet = bFetchNextPoint() && bFetchNextPoint() && bFetchNextPoint())
    {
        ASSERTGDI(j == 0,"RTP_PATHMEMOBJ::bDiagonalizeSubPath() -- j != 0\n");

        // bH ::= <is the second leg of the corner horizontal?>
        //
        // if the second leg of the corner is horizontal set bH=1 otherwise
        // set bH=0. Calculate the length of the first leg of the corner
        // and save it in fxAB. Note that I do not need to use the iMod3
        // modulus operation since j==0.

        if (aptfx[2].y == aptfx[1].y)
        {
            bH = 1;
            fxAB = aptfx[1].y - aptfx[0].y;
        }
        else
        {
            bH = 0;
            fxAB = aptfx[1].x - aptfx[0].x;
        }

        // Start a new subpath at the first point of the subpath.

        bRet = pepoOut->bMoveTo(aptfx);

        jA = 0;
        jB = 1;
        jC = 2;
    }

    while (bRet)
    {
#if DBG
        if (!(afl[jA] & RTP_LAST_POINT))
        {
            // Assert that the the legs of the corner are along
            // the axes, and that the two legs are mutually
            // orthogonal

            ASSERTGDI(
                aptfx[jC].x == aptfx[jB].x ||
                aptfx[jC].y == aptfx[jB].y,
                "Bad Path :: C-B is not axial\n"
                );
            ASSERTGDI(
                aptfx[jA].x == aptfx[jB].x ||
                aptfx[jA].y == aptfx[jB].y,
                "Bad Path :: B-A is not axial\n"
                );
            ASSERTGDI(
                (aptfx[jC].x - aptfx[jB].x) *
                (aptfx[jB].x - aptfx[jA].x)
                +
                (aptfx[jC].y - aptfx[jB].y) *
                (aptfx[jB].y - aptfx[jA].y)
                == 0,
                "Bad Path :: B-A is not orthogonal to C-B"
                );
        }
#endif
        // If the first vertex of the corner is the last point in the
        // original subpath then we terminate the processing.  This point
        // has either been recorded with PATHMEMOBJ::bMoveTo or
        // PATHMEMOBJ::bPolyLineTo.  All that remains is to close the
        // subpath which is done outside the while loop

        if (afl[jA] & RTP_LAST_POINT)
            break;

        // There are two paths through the following if-else clause
        // They are for VERTICAL-HORIZONTAL and HORIZONTAL-VERTICAL
        // corners respectively. These two clauses are identical
        // except for the interchange of ".x" with ".y". It might be
        // a good idea to have macros or subrouines for these sections
        // in order that they be guranteed to be identical.

        // Is the second leg of the corner horizontal?

        if (bH)
        {
            // Yes, the second leg of the corner is horizontal

            fxBC = aptfx[jC].x - aptfx[jB].x;

            // Is the corner diagonalizable?

            if ((fxAB > 0) && ((fxAB == FIX_ONE) || (fxBC == -FIX_ONE)))
            {
                // Yes, the corner is diagonalizable
                //
                // If the middle of the corner was the last point in the
                // original path then the last point in the output path
                // is the first point in the corner. This is because the
                // last line in the output path is this diagonalized
                // corner which will be produced automatically by the
                // CloseFigure() call after this while-loop. Thus, in
                // this case we would just break out of the loop.

                if (afl[jB] & RTP_LAST_POINT)
                    break;

                // The corner is diagonalizable. This means that we are no
                // longer interested in the first two points of this corner.
                // We therefore fetch the next two points of the path
                // an place them in our circular corner-buffer.

                if (!(bRet = bFetchNextPoint() && bFetchNextPoint()))
                    break;

                // under modulo 3 arithmetic, incrementing by 2 is
                // equivalent to decrementing by 1

                ROTATE_BACKWARD(jA,jB,jC);

                // fxAB is set to the length of the first leg of the new
                // corner.

                fxAB = aptfx[jB].y - aptfx[jA].y;
            }
            else
            {
                // No, the corner is not diagonalizable
                //
                // The corner cannot be diagonalized. Advance the corner
                // to the next point in the original path. The orientation
                // of the second leg of the corner will change. The length
                // of the first leg of the new corner is set equal to the
                // length of the second leg of the previous corner.

                if (!(bRet = bFetchNextPoint()))
                    break;
                ROTATE_FORWARD(jA,jB,jC);
                bH  ^= 1;
                fxAB = fxBC;
            }
        }
        else
        {
            // Diagonalize the HORIZONTAL->VERTICAL corner

            fxBC = aptfx[jC].y - aptfx[jB].y;
            if ((fxBC < 0) && ((fxAB == FIX_ONE) || (fxBC == -FIX_ONE)))
            {
                if (afl[jB] & RTP_LAST_POINT)
                    break;
                if (!(bRet = bFetchNextPoint() && bFetchNextPoint()))
                    break;
                ROTATE_BACKWARD(jA,jB,jC);
                fxAB = aptfx[jB].x - aptfx[jA].x;
            }
            else
            {
                if (!(bRet = bFetchNextPoint()))
                    break;
                ROTATE_FORWARD(jA,jB,jC);
                bH  ^= 1;
                fxAB  = fxBC;
            }
        }
        if (!(bRet = bWritePoint()))
            break;
    }

    if (bRet)
    {
        ASSERTGDI(cPoints == 2,"GDI Region To Path -- cPoints is not 2\n");

        bRet = pepoOut->bPolyLineTo(aptfxWrite, 2) && pepoOut->bCloseFigure();
    }
    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\pw32kevt.h ===
/******************************Module*Header*******************************\
* Module Name: pw32kevt.h
*
* Copyright (c) 1996-1999 Microsoft Corporation
* 
\**************************************************************************/

//
//  NOTE: The following structure has to be in nonpaged memory. It also
//  has to be the same as in videoprt.h.
//

typedef struct  _ENG_EVENT  {
    PKEVENT pKEvent;
    ULONG   fFlags;
    } ENG_EVENT, *PENG_EVENT;

//
//  Manifest constants for fFlags field of ENG_EVENT
//

#define ENG_EVENT_FLAG_IS_MAPPED_USER  0x1

typedef enum {
    type_delete,
    type_unmap
    } MANAGE_TYPE;

#define ENG_KEVENTALLOC(size) (PENG_EVENT)GdiAllocPoolNonPagedNS((size), 'msfD')
#define ENG_KEVENTFREE(ptr)   GdiFreePool((ptr))
#define ENG_ALLOC(size)       (PENG_EVENT)GdiAllocPool( (size), 'msfD')
#define ENG_FREE(ptr)         GdiFreePool((ptr))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\print.cxx ===
/******************************Module*Header*******************************\
* Module Name: print.cxx
*
* Printer support routines.
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern "C"
{
#include <gl\gl.h>
#include <gldrv.h>
#include <dciddi.h>
};

extern "C"
{
    extern HFASTMUTEX ghfmMemory;
}

#define TYPE1_KEY L"\\Registry\\Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Type 1 Installer\\Type 1 Fonts"

PTYPEONEINFO gpTypeOneInfo = NULL;
PTYPEONEINFO GetTypeOneFontList();
BOOL GetFontPathName( WCHAR *pFullPath, WCHAR *pFileName );

extern "C" ULONG ComputeFileviewCheckSum(PVOID, ULONG);
extern "C" void vUnmapRemoteFonts(FONTFILEVIEW *pFontFileView);

extern PW32PROCESS gpidSpool;

/******************************Public*Routine******************************\
* DoFontManagement                                                         *
*                                                                          *
* Gives us access to the driver entry point DrvFontManagement.  This is    *
* very much an Escape function, except that it needs a font realization.   *
*                                                                          *
*  Fri 07-May-1993 14:56:12 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

ULONG DoFontManagement(
    DCOBJ &dco,
    ULONG iMode,
    ULONG cjIn,
    PVOID pvIn,
    ULONG cjOut,
    PVOID pvOut
)
{
    ULONG ulRet   = 0;
    PVOID pvExtra = NULL;

    PDEVOBJ pdo(dco.hdev());

    PFN_DrvFontManagement pfnF = PPFNDRV(pdo,FontManagement);

    if (pfnF == (PFN_DrvFontManagement) NULL)
        return(ulRet);


    if (iMode == QUERYESCSUPPORT)
    {
    // Pass it to the device.

        return ((*pfnF)
            (
                pdo.bUMPD() ? (SURFOBJ *)pdo.dhpdev() : NULL, //overload pso with dhpdev for UMPD
                NULL,
                iMode,
                cjIn,
                pvIn,
                0,
                NULL
            ));

    }

    RFONTOBJ rfo(dco,FALSE);

    if (!rfo.bValid())
    {
        WARNING("gdisrv!DoFontManagement(): could not lock HRFONT\n");
        return(ulRet);
    }

    // See if we need some extra RAM and translation work.

    if (iMode == DOWNLOADFACE)
    {
        // How many 16 bit values are there now?

        int cWords = (int)cjIn / sizeof(WCHAR);

        // Try to get a buffer of 32 bit entries, since HGLYPHs are bigger.

        pvExtra = PALLOCMEM(cWords * sizeof(HGLYPH),'mfdG');

        if (pvExtra == NULL)
            return(ulRet);

        // Translate the UNICODE to HGYLPHs.

        if (cWords > 1)
        {
            rfo.vXlatGlyphArray
            (
                ((WCHAR *) pvIn) + 1,
                (UINT) (cWords-1),
                ((HGLYPH *) pvExtra) + 1
            );
        }

        // Copy the control word from the app over.

        *(HGLYPH *) pvExtra = *(WORD *) pvIn;

        // Adjust the pvIn and cjIn.

        pvIn = pvExtra;
        cjIn = cWords * sizeof(HGLYPH);
    }


    // It is unfortunate that apps call some printing escapes before
    // doing a StartDoc, so there is no real surface in the DC.
    // We fake up a rather poor one here if we need it.  The device
    // driver may only dereference the dhpdev from this!

    SURFOBJ soFake;
    SURFOBJ *pso = dco.pSurface()->pSurfobj();

    if (pso == (SURFOBJ *) NULL)
    {
        RtlFillMemory((BYTE *) &soFake,sizeof(SURFOBJ),0);
        soFake.dhpdev = dco.dhpdev();
        soFake.hdev   = dco.hdev();
        soFake.iType  = (USHORT)STYPE_DEVICE;
        pso = &soFake;
    }

    // Pass it to the device.

    ulRet = (*pfnF)
            (
                pso,
                rfo.pfo(),
                iMode,
                cjIn,
                pvIn,
                cjOut,
                pvOut
            );

    // Free any extra RAM.

    if (pvExtra != NULL)
    {
        VFREEMEM(pvExtra);
    }
    return(ulRet);
}

/******************************Public*Routine******************************\
*
* LockMcdHdrSurfaces
*
* Locks kernel-mode handles for DirectDraw surfaces described in the
* given header.
*
* History:
*  Fri Sep 20 14:18:31 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL LockMcdHdrSurfaces(MCDESC_HEADER *pmeh,
                        PDD_SURFACE_LOCAL *ppslColor,
                        PDD_SURFACE_LOCAL *ppslDepth)
{
    PDD_SURFACE_LOCAL psl;
    PDD_SURFACE_GLOBAL psg;

    *ppslColor = *ppslDepth = NULL;

    if (pmeh->msrfColor.hSurf != NULL)
    {
        *ppslColor = psl = EngLockDirectDrawSurface(pmeh->msrfColor.hSurf);
        if (psl == NULL)
        {
            return FALSE;
        }
        psg = psl->lpGbl;

        // Update information with trusted values
        pmeh->msrfColor.hSurf = (HANDLE)psl;
        pmeh->msrfColor.lOffset = (ULONG)psg->fpVidMem;
        pmeh->msrfColor.lStride = psg->lPitch;
        pmeh->msrfColor.rclPos.left = psg->xHint;
        pmeh->msrfColor.rclPos.top = psg->yHint;
        pmeh->msrfColor.rclPos.right = psg->xHint+psg->wWidth;
        pmeh->msrfColor.rclPos.bottom = psg->yHint+psg->wHeight;
    }

    if (pmeh->msrfDepth.hSurf != NULL)
    {
        *ppslDepth = psl = EngLockDirectDrawSurface(pmeh->msrfDepth.hSurf);
        if (psl == NULL)
        {
            if (*ppslColor)
            {
                EngUnlockDirectDrawSurface(*ppslColor);
                *ppslColor = NULL;
            }
            return FALSE;
        }
        psg = psl->lpGbl;

        // Update information with trusted values
        pmeh->msrfDepth.hSurf = (HANDLE)psl;
        pmeh->msrfDepth.lOffset = (ULONG)psg->fpVidMem;
        pmeh->msrfDepth.lStride = psg->lPitch;
        pmeh->msrfDepth.rclPos.left = psg->xHint;
        pmeh->msrfDepth.rclPos.top = psg->yHint;
        pmeh->msrfDepth.rclPos.right = psg->xHint+psg->wWidth;
        pmeh->msrfDepth.rclPos.bottom = psg->yHint+psg->wHeight;
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* iMcdSetupExtEscape
*
* MCD CreateContext ExtEscape.  This special escape allows WNDOBJ to be
* created in DrvEscape.  This is one of the three places where WNDOBJ can
* be created (the other two are iWndObjSetupExtEscape and DrvSetPixelFormat).
*
* See also iWndObjSetupExtEscape().
*
* History:
*  Tue Jun 21 17:24:12 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int iMcdSetupExtEscape(
    DCOBJ &dco,             //  DC user object
      int  nEscape,         //  Specifies the escape function to be performed.
      int  cjIn,            //  Number of bytes of data pointed to by pvIn
    PVOID  pvIn,            //  Points to the input structure required
      int  cjOut,           //  Number of bytes of data pointed to by pvOut
    PVOID  pvOut            //  Points to the output structure
)
{
    KFLOATING_SAVE fsFpState;
    MCDESC_HEADER *pmeh = (MCDESC_HEADER *)pvIn;
    MCDESC_HEADER_NTPRIVATE *pmehPriv =
        (MCDESC_HEADER_NTPRIVATE *)((PBYTE)pvIn + sizeof(MCDESC_HEADER));

    // This command may not be in shared memory.  Also, make sure
    // we have entire command structure.

    if ((!pmehPriv->pBuffer) ||
        (pmehPriv->bufferSize < sizeof(MCDESC_CREATE_CONTEXT)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return 0;
    }

    MCDESC_CREATE_CONTEXT *pmccCreate =
        (MCDESC_CREATE_CONTEXT *)(pmehPriv->pBuffer);

    ASSERTGDI(nEscape == MCDFUNCS,
              "iMcdSetupExtEscape(): not a CreateContext escape\n");

    // Validate DC surface.  Info DC is not allowed.

    if (!dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    // Make sure that we don't have devlock before entering user critical section.
    // Otherwise, it can cause deadlock.

    if (dco.bDisplay())
    {
        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,"ERROR it has to be direct");
        CHECKDEVLOCKOUT(dco);
    }

    // Enter user critical section.

    USERCRIT usercrit;

    // Grab the devlock.
    // We don't need to validate the devlock since we do not care if it is full screen.

    DEVLOCKOBJ dlo(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }

    // Assume no WNDOBJ on this call

    pmehPriv->pwo = (WNDOBJ *)NULL;

    HWND hwnd = NULL;

    PEWNDOBJ pwo = NULL;

    if (pmccCreate->flags & MCDESC_SURFACE_HWND)
    {
        // If it is a display DC, get the hwnd that the hdc is associated with.
        // If it is a printer or memory DC, hwnd is NULL.

        if (dco.bDisplay() && dco.dctp() == DCTYPE_DIRECT)
        {
            ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,"ERROR it has to be direct really");

            if (!UserGetHwnd(dco.hdc(), &hwnd, (PVOID *) &pwo, FALSE))
            {
                SAVE_ERROR_CODE(ERROR_INVALID_WINDOW_STYLE);
                return(FALSE);
            }

            if (pwo)
            {
                // If the WNDOBJ is owned by a different surface (as can happen with
                // dynamic mode changes, where the old driver instance lives as long
                // as the WNDOBJ is alive), simply fail the call.

                if (pwo->pto->pSurface != dco.pSurface())
                {
#ifdef OPENGL_MM
                    // Under multi-mon the DCOBJ may have the meta-surface while
                    // the pto was created with the actual hardware surface.
                    // So if the parent hdev of hdev in WNDOBJ is same as hdev in
                    // DCOBJ, we will allow to continue since we have replaced
                    // meta-PDEV with hardware PDEV. so it's fine.

                    PDEVOBJ pdoOfPwo(pwo->pto->pSurface->hdev());

                    if (pdoOfPwo.hdevParent() != dco.hdev())
                    {
                        WARNING("iMcdSetupExtEscape: pwo->pto->pSurface != dco.pSurface, so bailing out\n");
                        return(FALSE);
                    }
#else
                    return(FALSE);
#endif // OPENGL_MM
                }

                if (!(pwo->fl & WO_GENERIC_WNDOBJ))
                    pmehPriv->pwo = (WNDOBJ *)pwo;
            }
        }

    // Make sure that DC hwnd matches MCDESC_CREATE_CONTEXT hwnd.

        if (hwnd != pmccCreate->hwnd)
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            return(0);
        }
    }

// Dispatch the call.

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), pwo);

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if ( !PPFNDRV( pdo, Escape ))
        return(0);

    // Handle any surfaces

    // This escape doesn't expect any extra locks
    ASSERTGDI((pmeh->flags & MCDESC_FL_LOCK_SURFACES) == 0,
              "iMcdSetupExtEscape: MCDESC_FL_LOCK_SURFACES set\n");

    PDD_SURFACE_LOCAL psl[2] = { NULL, NULL };

    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        if (!LockMcdHdrSurfaces(pmeh, &psl[0], &psl[1]))
        {
            return 0;
        }
    }

// Save floating point state
// This allows client drivers to do floating point operations
// If the state were not preserved then we would be corrupting the
// thread's user-mode FP state

    int iRet;

    if (!NT_SUCCESS(KeSaveFloatingPointState(&fsFpState)))
    {
        WARNING("iMcdSetupExtEscape: Unable to save FP state\n");
        iRet = 0;
        goto iMcdSetupExtEscape_Unlock_And_Exit;
    }

    iRet = (int) pdo.Escape(pso,
                            (ULONG)nEscape,
                            (ULONG)cjIn,
                             pvIn,
                            (ULONG)cjOut,
                            pvOut);

    // Restore floating point state

    KeRestoreFloatingPointState(&fsFpState);

    // If a new WNDOBJ is created, we need to update the window client regions
    // in the driver.

    if (gbWndobjUpdate)
    {
        gbWndobjUpdate = FALSE;
        vForceClientRgnUpdate();
    }

iMcdSetupExtEscape_Unlock_And_Exit:

    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        if (psl[0])
        {
            EngUnlockDirectDrawSurface(psl[0]);
        }

        if (psl[1])
        {
            EngUnlockDirectDrawSurface(psl[1]);
        }
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* iWndObjSetupExtEscape
*
* Live video ExtEscape.  This special escape allows WNDOBJ to be created
* in DrvEscape.  This is one of the three places where WNDOBJ can be created
* (the other two are iMcdSetupExtEscape and DrvSetPixelFormat).
*
* See also iMcdSetupExtEscape().
*
* History:
*  Fri Feb 18 13:25:13 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int iWndObjSetupExtEscape
(
    DCOBJ &dco,             //  DC user object
       int nEscape,         //  Specifies the escape function to be performed.
       int cjIn,            //  Number of bytes of data pointed to by pvIn
     PVOID pvIn,            //  Points to the input structure required
       int cjOut,           //  Number of bytes of data pointed to by pvOut
     PVOID pvOut            //  Points to the output structure
)
{
    ASSERTGDI(nEscape == WNDOBJ_SETUP,
        "iWndObjSetupExtEscape(): not a WndObjSetup escape\n");

    // Validate DC surface.  Info DC is not allowed.

    if (!dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    // Make sure that we don't have devlock before entering user critical section.
    // Otherwise, it can cause deadlock.

    if (dco.bDisplay())
    {
        ASSERTGDI(dco.dctp() == DCTYPE_DIRECT,"ERROR it has to be direct");
        CHECKDEVLOCKOUT(dco);
    }

    // Enter user critical section.

    USERCRIT usercrit;

    // Grab the devlock.
    // We don't need to validate the devlock since we do not care if it is full screen.

    DEVLOCKOBJ dlo(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }


    // Dispatch the call.

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(), (RECTL)dco.erclWindow(), NULL);

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    if ( !PPFNDRV( pdo, Escape ))
        return(0);

    int iRet = (int) pdo.Escape(pso,
                                (ULONG)nEscape,
                                (ULONG)cjIn,
                                pvIn,
                                (ULONG)cjOut,
                                pvOut);

    // If a new WNDOBJ is created, we need to update the window client regions
    // in the driver.

    if (gbWndobjUpdate)
    {
        gbWndobjUpdate = FALSE;
        vForceClientRgnUpdate();
    }

    return(iRet);
}

/******************************Public*Routine******************************\
*
* LookUpWndobjs
*
* Looks up WNDOBJs for a list of HDCs.  Only performs lookups for
* HDCs which are for the same device as that given.  Returns negative
* if error, otherwise it returns a bitmask of the HDCs
* that had a lookup.
*
* Fills in DCOBJ table with locked DCs for tested HDCs.
* Overwrites HDC table with WNDOBJ pointers.
*
* History:
*  Mon Oct 14 16:48:13 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int LookUpWndobjs(DCOBJ *pdcoMatch, DCOBJ *pdcoFill, HDC *phdc, int n)
{
    int iMask;
    HDEV hdevMatch;
    int i;

    CHECKUSERCRITIN;

    hdevMatch = pdcoMatch->hdev();
    iMask = 0;
    for (i = 0; i < n; i++)
    {
        pdcoFill->vLock(*phdc);
        if (!pdcoFill->bValid())
        {
            return -1;
        }

        if (pdcoFill->hdev() != hdevMatch)
        {
            pdcoFill->vUnlock();
            *phdc = NULL;
        }
        else
        {
            HWND hwnd;

            if (!UserGetHwnd(*phdc, &hwnd, (PVOID *)phdc, FALSE))
            {
                return -1;
            }
            else
            {
                iMask |= 1 << i;
            }
        }

        phdc++;
        pdcoFill++;
    }

    return iMask;
}

/******************************Public*Routine******************************\
* iMcdExtEscape
*
* Take the MCD special case ExtEscape out of line to minimize the
* impact on other ExtEscapes.  We need to stick special data into the
* input buffer.  No CLIPOBJ is given to the driver here.
*
* History:
*  Tue Jun 21 17:24:12 1994     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int iMcdExtEscape(
    DCOBJ &dco,             //  DC user object
      int  nEscape,         //  Specifies the escape function to be performed.
      int  cjIn,            //  Number of bytes of data pointed to by pvIn
    PVOID  pvIn,            //  Points to the input structure required
      int  cjOut,           //  Number of bytes of data pointed to by pvOut
    PVOID  pvOut            //  Points to the output structure
)
{
    BOOL bSaveSwapEnable;
    KFLOATING_SAVE fsFpState;
    ULONG i;
    int iRet = 0;
    int iMultiMask;
    DCOBJ dcoMulti[MCDESC_MAX_EXTRA_WNDOBJ];

    ASSERTGDI(nEscape == MCDFUNCS, "iMcdExtEscape(): not an MCD escape\n");

    // Validate DC surface.  Info DC is not allowed.

    if (!dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return iRet;
    }

    // Special processing for 3D-DDI escape.
    //
    // The escape requires that the server fill in the pwo engine object pointer
    // before it is passed to the display driver.  The client side simply
    // doesn't have a clue what this might be.
    // CAUTION: These object are defined here so that they will live long enough
    // to be valid when control is passed to the driver!

    // Grab the devlock and lock down wndobj.

    DEVLOCKOBJ_WNDOBJ dlo(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }
    
    if (!dlo.bValidDevlock())
    {
        if (!dco.bFullScreen())
        {
            WARNING("iMcdExtEscape(): devlock failed\n");
            return iRet;
        }
    }

    PDEVOBJ pdo(dco.hdev());

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(),
                              (RECTL)dco.erclWindow(),
                              (dlo.bValidWndobj() ? dlo.pwo() : NULL));

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (pdo.bPrimary(dco.pSurface()))
            {
                PDEVOBJ pdoDevice(hdevDevice);

                pso = pdoDevice.pSurface()->pSurfobj();
            }

            // replace meta pdevobj with device specific hdev.

            pdo.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    // Locate the driver entry point.

    if ( !PPFNDRV( pdo, Escape ))
        return( iRet );

    if (pdo.bUMPD())
        return (iRet);

    // If surfaces are passed through the MCDESC_HEADER then lock them
    MCDESC_HEADER *pmeh = (MCDESC_HEADER *)pvIn;
    MCDESC_HEADER_NTPRIVATE *pmehPriv = (MCDESC_HEADER_NTPRIVATE *)(pmeh+1);

    PDD_SURFACE_LOCAL psl[2+MCDESC_MAX_LOCK_SURFACES];
    RtlZeroMemory(psl, (2+MCDESC_MAX_LOCK_SURFACES) * sizeof(PDD_SURFACE_LOCAL));

    // First lock standard surfaces
    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        if (!LockMcdHdrSurfaces(pmeh, &psl[0], &psl[1]))
        {
            return iRet;
        }
    }

    // Now check for extra surfaces
    if (pmeh->flags & MCDESC_FL_LOCK_SURFACES)
    {
        HANDLE *phSurf;

        phSurf = pmehPriv->pLockSurfaces;
        for (i = 0; i < pmeh->cLockSurfaces; i++)
        {
            if ((psl[i+2] = EngLockDirectDrawSurface(*phSurf++)) == NULL)
            {
                goto iMcdExtEscape_Unlock_And_Exit;
            }
        }
    }

    // Look up any extra WNDOBJs that need to be looked up
    if (pmeh->flags & MCDESC_FL_EXTRA_WNDOBJ)
    {
        iMultiMask = LookUpWndobjs(&dco, dcoMulti, pmehPriv->pExtraWndobj,
                                   pmeh->cExtraWndobj);
        if (iMultiMask < 0)
        {
            goto iMcdExtEscape_Unlock_And_Exit;
        }
    }

// Grow the kernel stack so that OpenGL drivers can use more
// stack than is provided by default.  The call attempts to
// grow the stack to the maximum possible size
// The stack will shrink back automatically so there's no cleanup
// necessary

    if (!NT_SUCCESS(MmGrowKernelStack((BYTE *)PsGetCurrentThreadStackBase()-
                                      KERNEL_LARGE_STACK_SIZE+
                                      KERNEL_LARGE_STACK_COMMIT)))
    {
        WARNING("iMcdExtEscape: Unable to grow stack\n");

        goto iMcdExtEscape_Unlock_And_Exit;
    }

    // Ensure that the stack does not shrink back until we release it.

    bSaveSwapEnable = KeSetKernelStackSwapEnable(FALSE);

// We need to get the WNDOBJ for the driver.  Note that we pass calls
// through to the driver even if we don't yet have a WNDOBJ to allow
// query functions to succeed (before context-creation).  Cursor exclusion
// is not performed in this case, since no drawing is done.

    {
        DEVEXCLUDEWNDOBJ dxoWnd;

        if (dlo.bValidWndobj())
        {
        // Put the DDI pwo pointer in the input buffer.

            PEWNDOBJ pwo;

            pwo = dlo.pwo();

        // If the WNDOBJ is owned by a different surface (as can happen with
        // dynamic mode changes, where the old driver instance lives as long
        // as the WNDOBJ is alive), simply fail the call.

            if (pwo->pto->pSurface != dco.pSurface())
            {
#ifdef OPENGL_MM
            // Under multi-mon the DCOBJ may have the meta-surface while
            // the pto was created with the actual hardware surface.
            // So if the parent hdev of hdev in WNDOBJ is same as hdev in
            // DCOBJ, we will allow to continue since we have replaced
            // meta-PDEV with hardware PDEV. so it's fine.

                PDEVOBJ pdoOfPwo(pwo->pto->pSurface->hdev());

                if (pdoOfPwo.hdevParent() != dco.hdev())
                {
                    WARNING("iMcdExtEscape: pwo->pto->pSurface != dco.pSurface, so bailing out\n");
                    goto iMcdExtEscape_RestoreSwap;
                }
#else
                goto iMcdExtEscape_RestoreSwap;
#endif // OPENGL_MM
            }

            if (pwo->fl & WO_GENERIC_WNDOBJ)
                pwo = (PEWNDOBJ) NULL;

            pmehPriv->pwo = (WNDOBJ *) pwo;

        // Cursor exclusion.
        // Note that we do not early out for empty clip rectangle.

            if (pwo)
            {
                dxoWnd.vExclude(pwo);
                INC_SURF_UNIQ(dco.pSurface());
            }
        }
        else
            pmehPriv->pwo = (WNDOBJ *) NULL;
    }

    // Save floating point state
    // This allows client drivers to do floating point operations
    // If the state were not preserved then we would be corrupting the
    // thread's user-mode FP state

    if (!NT_SUCCESS(KeSaveFloatingPointState(&fsFpState)))
    {
        WARNING("iMcdExtEscape: Unable to save FP state\n");
        goto iMcdExtEscape_RestoreSwap;
    }

    // Call the driver escape.

    iRet = (int) pdo.Escape(pso,
                            (ULONG)nEscape,
                            (ULONG)cjIn,
                            pvIn,
                            (ULONG)cjOut,
                            pvOut);

    if (pmeh->flags & MCDESC_FL_EXTRA_WNDOBJ)
    {
        iRet = (iRet & (0xffffffff >> MCDESC_MAX_EXTRA_WNDOBJ)) |
            (iMultiMask << (32-MCDESC_MAX_EXTRA_WNDOBJ));
    }

    // Restore floating point state and stack swap enable state

    KeRestoreFloatingPointState(&fsFpState);

iMcdExtEscape_RestoreSwap:

    KeSetKernelStackSwapEnable((BOOLEAN)bSaveSwapEnable);

iMcdExtEscape_Unlock_And_Exit:

    if (pmeh->flags & MCDESC_FL_SURFACES)
    {
        if (psl[0])
        {
            EngUnlockDirectDrawSurface(psl[0]);
        }

        if (psl[1])
        {
            EngUnlockDirectDrawSurface(psl[1]);
        }
    }

    if (pmeh->flags & MCDESC_FL_LOCK_SURFACES)
    {
        for (i = 0; i < pmeh->cLockSurfaces; i++)
        {
            if (psl[i+2])
            {
                EngUnlockDirectDrawSurface(psl[i+2]);
            }
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* iOpenGLExtEscape
*
* Take the OpenGL special case ExtEscape out of line to minimize the
* impact on non-OpenGL ExtEscapes.  We need to stick special data into the
* input buffer.  No CLIPOBJ is given to the driver here.
*
* History:
*  20-Jan-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int iOpenGLExtEscape(
    DCOBJ &dco,             //  DC user object
      int nEscape,          //  Specifies the escape function to be performed.
      int cjIn,             //  Number of bytes of data pointed to by pvIn
    PVOID pvIn,             //  Points to the input structure required
      int cjOut,            //  Number of bytes of data pointed to by pvOut
    PVOID pvOut             //  Points to the output structure
)
{
    BOOL bSaveSwapEnable;
    KFLOATING_SAVE fsFpState;
    int iRet = 0;
    int iMultiMask;
    DCOBJ dcoMulti[OPENGLCMD_MAXMULTI];

    ASSERTGDI(
        (nEscape == OPENGL_CMD) || (nEscape == OPENGL_GETINFO),
        "iOpenGLExtEscape(): not an OpenGL escape\n");

    // Validate DC surface.  Info DC is not allowed.

    if (!dco.bHasSurface())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    // Special processing for OPENGL_CMD escape.
    //
    // The OPENGL_CMD escape may require that the server fill in the pxo and
    // pwo engine object pointers before it is passed to the display driver.
    // The client side simply doesn't have a clue what these might be.
    // CAUTION: These object are defined here so that they will live long enough
    // to be valid when control is passed to the driver!

    EXLATEOBJ xlo;
    XLATEOBJ *pxlo = (XLATEOBJ *) NULL;

    PDEVOBJ po(dco.hdev());
    ASSERTGDI(po.bValid(), "iOpenGLExtEscape(): bad hdev in DC\n");

    // Grab the devlock and user crit section

    DEVLOCKOBJ_WNDOBJ dlo(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }
    
    if (!dlo.bValidDevlock())
    {
        if (!dco.bFullScreen())
        {
            WARNING("iOpenGLExtEscape(): devlock failed\n");
            return 0;
        }
    }

    // Find a target surface, if DDML.

    PSURFACE pSurface = dco.pSurfaceEff();

#ifdef OPENGL_MM

    if (po.bMetaDriver())
    {
        // We need to change the meta-PDEV into a hardware specific PDEV

        HDEV hdevDevice = hdevFindDeviceHdev(
                              dco.hdev(),
                              (RECTL)dco.erclWindow(),
                              (dlo.bValidWndobj() ? dlo.pwo() : NULL));

        if (hdevDevice)
        {
            // If the surface is pdev's primary surface, we will replace it with
            // new device pdev's surface.

            if (po.bPrimary(dco.pSurface()))
            {
                PDEVOBJ poDevice(hdevDevice);

                pSurface = poDevice.pSurface();
            }

            // replace meta pdevobj with device specific hdev.

            po.vInit(hdevDevice);
        }
    }

#endif // OPENGL_MM

    SURFOBJ *pso = pSurface->pSurfobj();

    // Locate the driver entry point.

    if (!PPFNDRV(po, Escape))
        return(0);

    if (po.bUMPD())
        return (0);

    // Create a sprite exclusion object.  Actual exclusion is performed elsewhere
    // as needed.

    DEVEXCLUDEWNDOBJ dxoWnd;
    DEVEXCLUDERECT dxoRect;

    // Grow the kernel stack so that OpenGL drivers can use more
    // stack than is provided by default.  The call attempts to
    // grow the stack to the maximum possible size
    // The stack will shrink back automatically so there's no cleanup
    // necessary

    if (!NT_SUCCESS(MmGrowKernelStack((BYTE *)PsGetCurrentThreadStackBase()-
                                      KERNEL_LARGE_STACK_SIZE+
                                      KERNEL_LARGE_STACK_COMMIT)))
    {
        WARNING("iOpenGLExtEscape: Unable to grow stack\n");
        return 0;
    }

    // Ensure that the stack does not shrink back until we release it.

    bSaveSwapEnable = KeSetKernelStackSwapEnable(FALSE);

    // Save floating point state
    // This allows client drivers to do floating point operations
    // If the state were not preserved then we would be corrupting the
    // thread's user-mode FP state

    if (!NT_SUCCESS(KeSaveFloatingPointState(&fsFpState)))
    {
        WARNING("iOpenGLExtEscape: Unable to save FP state\n");
        goto iOpenGLExtEscape_RestoreSwap;
    }

    // Handle OPENGL_CMD processing.

    if ( nEscape == OPENGL_CMD )
    {
        ASSERTGDI(sizeof(OPENGLCMD) == sizeof(OPENGLCMDMULTI),
                  "OPENGLCMD doesn't match OPENGLCMDMULTI\n");

    // Better check input size.  We don't want to access violate.

        if (cjIn < sizeof(OPENGLCMD))
        {
            WARNING("iOpenGLExtEscape(): buffer too small\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            goto iOpenGLExtEscape_RestoreState;
        }

        DWORD inBuffer[(sizeof(OPENGLCMD) + 128) / sizeof(DWORD)];
        POPENGLCMD poglcmd;
        POPENGLCMDMULTI pomcmd;

        // Copy pvIn to a private buffer to prevent client process from trashing
        // pwo and pxlo.

        if (cjIn <= sizeof(inBuffer))
        {
            poglcmd = (POPENGLCMD) inBuffer;
        }
        else
        {
            // may affect performance
            WARNING("iOpenGLExtEscape(): big input buffer\n");
            poglcmd = (POPENGLCMD) PALLOCNOZ(cjIn,'lgoG');
            if (!poglcmd)
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                goto iOpenGLExtEscape_RestoreState;
            }
        }

        RtlCopyMemory((PBYTE) poglcmd, (PBYTE) pvIn, cjIn);

        if (poglcmd->fl & OGLCMD_MULTIWNDOBJ)
        {
            pomcmd = (POPENGLCMDMULTI)poglcmd;

            if (pomcmd->cMulti > OPENGLCMD_MAXMULTI ||
                (DWORD)cjIn < sizeof(OPENGLCMDMULTI)+pomcmd->cMulti*
                sizeof(HDC))
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                goto oglcmd_cleanup;
            }

            iMultiMask = LookUpWndobjs(&dco, dcoMulti, (HDC *)(poglcmd+1),
                                       pomcmd->cMulti);
            if (iMultiMask < 0)
            {
                goto oglcmd_cleanup;
            }
        }

        if ( poglcmd->fl & OGLCMD_NEEDXLATEOBJ )
        {
            switch (po.iDitherFormat())
            {
            case BMF_4BPP:
            case BMF_8BPP:
                {
                    XEPALOBJ pal(dco.ppal());

                    if ( pal.bValid() )
                    {
                        COUNT cColors = (po.iDitherFormat() == BMF_4BPP) ? 16 : 256;
                        USHORT aus[256];

                        for (COUNT ii = 0; ii < cColors; ii++)
                            aus[ii] = (USHORT) ii;

#ifdef OPENGL_MM
                        if ( xlo.bMakeXlate(aus, pal, pSurface, cColors, cColors) )
#else
                        if ( xlo.bMakeXlate(aus, pal, dco.pSurfaceEff(), cColors, cColors) )
#endif // OPENGL_MM

                            pxlo = (XLATEOBJ *) xlo.pxlo();
                    }

                    if (!pxlo)
                        pxlo = &xloIdent;
                }
                break;

            default:
                pxlo = &xloIdent;
                break;
            }
        }

        // Write the XLATOBJ into the correct places in the input structure.

        poglcmd->pxo = pxlo;

        // May need to get the WNDOBJ for the driver.

        if ((poglcmd->fl & OGLCMD_MULTIWNDOBJ) == 0)
        {
            if (poglcmd->fl & OGLCMD_NEEDWNDOBJ)
            {
                if (!dlo.bValidWndobj() || dlo.pwo()->fl & WO_GENERIC_WNDOBJ)
                {
                    WARNING("iOpenGLExtEscape(): invalid WNDOBJ\n");
                    SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                    goto oglcmd_cleanup;
                }

            // If the WNDOBJ is owned by a different surface (as can happen with
            // dynamic mode changes, where the old driver instance lives as long
            // as the WNDOBJ is alive), simply fail the call.

                if (dlo.pwo()->pto->pSurface != dco.pSurface())
                {
#ifdef OPENGL_MM
                // Under multi-mon the DCOBJ may have the meta-surface while
                // the pto was created with the actual hardware surface.
                // So if the parent hdev of hdev in WNDOBJ is same as hdev in
                // DCOBJ, we will allow to continue since we have replaced
                // meta-PDEV with hardware PDEV. so it's fine.

                    PDEVOBJ pdoOfPwo(dlo.pwo()->pto->pSurface->hdev());

                    if (pdoOfPwo.hdevParent() != dco.hdev())
                    {
                        WARNING("iOpenGLExtEscape: pwo->pto->pSurface != dco.pSurface, so bailing out\n");
                        goto oglcmd_cleanup;
                    }
#else
                    goto oglcmd_cleanup;
#endif // OPENGL_MM
                }

                poglcmd->pwo = (WNDOBJ *)dlo.pwo();
            }
            else
            {
                poglcmd->pwo = (WNDOBJ *)NULL;
            }
        }

        // Cursor exclusion.

        if (dlo.bValidWndobj())
        {
            // If the driver's WNDOBJ knows about sprites, we assume the driver
            // will take of exclusion.

            if (!(dlo.pwo()->fl & WO_SPRITE_NOTIFY))
            {
                dxoWnd.vExclude(dlo.pwo());
            }
            INC_SURF_UNIQ(dco.pSurface());
        }
        else
        {
            ERECTL ercl(dco.prgnEffRao()->rcl);
            ECLIPOBJ co(dco.prgnEffRao(), ercl, FALSE);

            dxoRect.vExclude(dco.hdev(), &co.erclExclude());
            INC_SURF_UNIQ(dco.pSurface());
        }

        iRet = (int) po.Escape(pso,
                                    (ULONG)nEscape,
                                    (ULONG)cjIn,
                                    (PVOID)poglcmd,
                                    (ULONG)cjOut,
                                    pvOut);
        if (poglcmd->fl & OGLCMD_MULTIWNDOBJ)
        {
            iRet = (iRet & (0xffffffff >> OPENGLCMD_MAXMULTI)) |
                (iMultiMask << (32-OPENGLCMD_MAXMULTI));
        }

    oglcmd_cleanup:
        if (cjIn > sizeof(inBuffer))
            VFREEMEM(poglcmd);
    } // if ( nEscape == OPENGL_CMD )
    else
    {
        // Handle OPENGL_GETINFO processing.

        iRet = ((int) po.Escape(pso,
                                (ULONG)nEscape,
                                (ULONG)cjIn,
                                pvIn,
                                (ULONG)cjOut,
                                pvOut));
    }

// Restore floating point state

iOpenGLExtEscape_RestoreState:
    KeRestoreFloatingPointState(&fsFpState);

iOpenGLExtEscape_RestoreSwap:
    KeSetKernelStackSwapEnable((BOOLEAN)bSaveSwapEnable);

    return iRet;
}

/******************************Public*Routine******************************\
* iCheckPassthroughImage
*
* Implements the CHECKJPEGFORMAT and CHECKPNGFORMAT escapes on behalf of
* the driver.  Converts the escape into a call to DrvQueryDriverSupport
* which can pass objects such as XLATEOBJ to the driver that DrvEscape
* does not have.
*
* These escapes are used to validate images with the device so that
* they can later be sent directly (passthrough) to the device.
*
* Returns:
*   QUERYESCSUPPORT returns 1 if escape supported, 0 otherwise.
*   CHECKJPEGFORMAT/CHECKPNGFORMAT returns 1 if image supported, 0 if not
*   supported, and -1 if error.
*
* History:
*  14-Oct-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int iCheckPassthroughImage(
    DCOBJ &dco,             //  DC user object
  PDEVOBJ &pdo,             //  PDEV user object
      int  nEscape,         //  Specifies the escape function to be performed.
      int  cjIn,            //  Number of bytes of data pointed to by pvIn
    PVOID  pvIn,            //  Points to the input structure required
      int  cjOut,           //  Number of bytes of data pointed to by pvOut
    PVOID  pvOut            //  Points to the output structure
)
{
    int iRet = 0;           // not supported

    if (nEscape == QUERYESCSUPPORT)
    {
        ASSERTGDI((*(ULONG*)pvIn == CHECKJPEGFORMAT) ||
                  (*(ULONG*)pvIn == CHECKPNGFORMAT),
                  "iCheckPassthroughImage: unknown escape\n");

        if (*(ULONG*)pvIn == CHECKJPEGFORMAT)
        {
            // Escape is supported if driver has JPEG support.

            if (dco.bSupportsJPEG() &&
                (PPFNVALID(pdo, QueryDeviceSupport)))
            {
                iRet = 1;
            }
        }
        else
        {
            // Escape is supported if driver has PNG support.

            if (dco.bSupportsPNG() &&
                (PPFNVALID(pdo, QueryDeviceSupport)))
            {
                iRet = 1;
            }
        }
    }
    else if (PPFNVALID(pdo, QueryDeviceSupport))
    {
        ASSERTGDI((nEscape == CHECKJPEGFORMAT) || (nEscape == CHECKPNGFORMAT),
                  "iCheckPassthroughImage: unknown escape\n");

        if ((cjOut >= sizeof(ULONG)) && pvOut)
        {
            // There is no surface in metafile DCs.  In addition, some
            // apps call printing escape before the StartDoc, also
            // resulting in no real surface in DC.
            //
            // The XLATEOBJ generated in this way may not be valid except
            // for the ICM information (which is all this escape cares
            // about in the XLATEOBJ anyway).

            XEPALOBJ  palDest(dco.pSurface() ? dco.pSurface()->ppal() : NULL);
            XEPALOBJ  palDestDC(dco.ppal());
            PALMEMOBJ palTemp;
            XLATEOBJ *pxlo = NULL;
            EXLATEOBJ xlo;

            // Create the XLATEOBJ so driver can determine the ICM state.

            if (((nEscape == CHECKJPEGFORMAT) && dco.bSupportsJPEG()) ||
                ((nEscape == CHECKPNGFORMAT ) && dco.bSupportsPNG()))
            {
                if (palTemp.bCreatePalette(PAL_BGR, 0, (PULONG) NULL,
                                            0, 0, 0, PAL_FIXED))
                {
                    if (xlo.pInitXlateNoCache(dco.pdc->hcmXform(),
                                              dco.pdc->lIcmMode(),
                                              palTemp,
                                              palDest,
                                              palDestDC,
                                              0,
                                              0,
                                              0x00FFFFFF))
                    {
                        pxlo = xlo.pxlo();
                    }
                    else
                    {
                        WARNING("ExtEscape(CHECKJPEGFORMAT/CHECKPNGFORMAT): "
                                "failed pxlo creation\n");

                        iRet = -1;  // error
                    }
                }
            }

            // If XLATEOBJ created, call DrvQueryDriverSupport to validate
            // the image.

            if (pxlo)
            {
                // There is no surface in metafile DCs.  In addition, some
                // apps call printing escape before the StartDoc, also
                // resulting in no real surface in DC.
                //
                // We fake up a rather poor one here if we need it.  The
                // device driver may only dereference the dhpdev from this!

                SURFOBJ soFake;
                SURFOBJ *pso = dco.pSurface()->pSurfobj();

                if (pso == (SURFOBJ *) NULL)
                {
                    RtlFillMemory((BYTE *) &soFake,sizeof(SURFOBJ),0);
                    soFake.dhpdev = dco.dhpdev();
                    soFake.hdev   = dco.hdev();
                    soFake.iType  = (USHORT)STYPE_DEVICE;
                    pso = &soFake;
                }

                // Call the Driver.

                *(ULONG *)pvOut = PPFNDRV(pdo,QueryDeviceSupport)
                                            (pso,
                                             pxlo,
                                             (XFORMOBJ *) NULL,
                                             (nEscape == CHECKJPEGFORMAT)
                                                ? QDS_CHECKJPEGFORMAT
                                                : QDS_CHECKPNGFORMAT,
                                             (ULONG) cjIn,
                                             pvIn,
                                             (ULONG) cjOut,
                                             pvOut) ? 1 : 0;

                iRet = 1;
            }
        }
        else
        {
            WARNING("ExtEscape(CHECKJPEGFORMAT/CHECKPNGFORMAT): "
                    "invalid output buffer\n");

            iRet = -1;  // error
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* GreExtEscape                                                             *
*                                                                          *
* GreExtEscape() allows applications to access facilities of a particular  *
* device that are not directly available through GDI.  GreExtEscape calls  *
* made by an application are translated and sent to the device driver.     *
*                                                                          *
* Returns                                                                  *
*                                                                          *
*     The return value specifies the outcome of the function.  It is       *
*     positive if the function is successful except for the                *
*     QUERYESCSUPPORT escape, which only checks for implementation.        *
*     The return value is zero if the escape is not implemented.           *
*     A negative value indicates an error.                                 *
*     The following list shows common error values:                        *
*                                                                          *
*                                                                          *
*   Value           Meaning                                                *
*                                                                          *
*   SP_ERROR        General error.                                         *
*                                                                          *
*   SP_OUTOFDISK    Not enough disk space is currently                     *
*                   available for spooling, and no more                    *
*                   space will become available.                           *
*                                                                          *
*                                                                          *
*   SP_OUTOFMEMORY  Not enough memory is available for                     *
*                   spooling.                                              *
*                                                                          *
*                                                                          *
*   SP_USERABORT    User terminated the job through the                    *
*                   Print Manager.                                         *
*                                                                          *
*                                                                          *
*  COMMENTS                                                                *
*                                                                          *
*  [1] I assume that if we pass to the driver an Escape number that        *
*      it does not support, the driver will handle it gracefully.          *
*      No checks are done in the Engine.                                   *
*                                                         [koo 02/13/91].  *
*  [2] The cast on pso may seem redundant.  However if you                 *
*      try it without the (PSURFOBJ) cast, you will find                   *
*      that cFront objects.  The reason for this is beyond                 *
*      my understanding of C++.                                            *
*                                                                          *
* History:                                                                 *
*  Fri 07-May-1993 14:58:39 -by- Charles Whitmer [chuckwh]                 *
* Added the font management escapes.  Made it copy the ATTRCACHE.          *
*                                                                          *
*  Fri 03-Apr-1992  Wendy Wu [wendywu]                                     *
* Old escapes are now mapped to GDI functions on the client side.          *
*                                                                          *
*  Fri 14-Feb-1992  Dave Snipp                                             *
* Added output buffer size. This is calculated on the client and passed to *
* us in the message                                                        *
*                                                                          *
*  Wed 13-Feb-1991 09:17:51 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GreExtEscape(
      HDC hDC,        //  Identifies the device context.
      int iEscape,    //  Specifies the escape function to be performed.
      int cjIn,       //  Number of bytes of data pointed to by pvIn.
    LPSTR pvIn,       //  Points to the input data.
      int cjOut,      //  Number of bytes of data pointed to by pvOut.
    LPSTR pvOut       //  Points to the structure to receive output.
)
{
    // Locate the surface.

    DCOBJ dco(hDC);

    if (!dco.bValid())
        return(0);

    // PDEVs that have been marked by USER for deletion cannot have escapes
    // going down to them.

    PDEVOBJ pdo(dco.hdev());
    if (pdo.bDeleted())
        return(0);

#if TEXTURE_DEMO
    if (iEscape == 0x031898)
    {
        return(TexTexture(pvIn, cjIn));
    }

    if ((cjIn >= 4) && (pvIn != NULL) && (iEscape == 0x031899))
    {
        return((int) hdcTexture(*(ULONG*) pvIn));
    }
#endif

    // We are responsible for not faulting on any call that we handle.
    // (As are all drivers below us!)  Since we handle QUERYESCSUPPORT, we'd
    // better verify the length.  [chuckwh]

    ////////////////////////////////////////////////////////////////////////
    // NOTE: If you add more private escape routines, you MUST acquire the
    //       DEVLOCK before calling the driver's DrvEscape routine, to allow
    //       for dynamic mode changing.

    // First, get the driver capable override info
    DWORD   dwOverride = pdo.dwDriverCapableOverride();

    if ((iEscape == QUERYESCSUPPORT) && (((ULONG)cjIn) < 4))
    {
        return(0);
    }
    else if ( (iEscape == QUERYESCSUPPORT)
            &&(  (*(ULONG*)pvIn == OPENGL_GETINFO)
               ||(*(ULONG*)pvIn == OPENGL_CMD)
               ||(*(ULONG*)pvIn == MCDFUNCS) )
            &&(dwOverride & DRIVER_NOT_CAPABLE_OPENGL) )
    {
        return (0);
    }
    else if ( (iEscape == OPENGL_CMD) || (iEscape == OPENGL_GETINFO) )
    {
        // If the driver is not capable of doing OpenGL, just return
        if ( (dwOverride & DRIVER_NOT_CAPABLE_OPENGL)
          || (dco.dctp() != DCTYPE_DIRECT) )
            return 0;

        return iOpenGLExtEscape(dco, iEscape, cjIn, pvIn, cjOut, pvOut);
    }
    else if (iEscape == MCDFUNCS)
    {
        // Don't allow the MCD to be started up on device bitmaps.
        // If the driver is not capable of doing OpenGL, just return
        if ( (dwOverride & DRIVER_NOT_CAPABLE_OPENGL)
          || (dco.dctp() != DCTYPE_DIRECT) )
            return 0;

        DWORD inBuffer[((sizeof(MCDESC_HEADER) +
                         sizeof(MCDESC_HEADER_NTPRIVATE)) /
                        sizeof(DWORD))];
        HANDLE hLockSurfaces[MCDESC_MAX_LOCK_SURFACES];
        HDC hdcExtraWndobj[MCDESC_MAX_EXTRA_WNDOBJ];
        MCDESC_HEADER *pmeh = (MCDESC_HEADER *)inBuffer;
        MCDESC_HEADER_NTPRIVATE *pmehPriv;
        BYTE *pbCmd;

        // MCD escape protocol involves an
        // MCDESC_HEADER + MCDESC_HEADER_NTPRIVATE structure sent via
        // the escape.
        //
        // If there is shared memory, then the entire command is described
        // in the MCDESC_HEADER.  Otherwise, the pBuffer field of the
        // MCDESC_HEADER_NTPRIVATE
        // structure is set to point to the command structure.

        if (cjIn >= sizeof(MCDESC_HEADER))
        {
            *pmeh = *(MCDESC_HEADER *)pvIn;
            pbCmd = (BYTE *)pvIn+sizeof(MCDESC_HEADER);
            cjIn -= sizeof(MCDESC_HEADER);
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            return 0;
        }

        pmehPriv = (MCDESC_HEADER_NTPRIVATE *)(pmeh+1);

        // If MCDESC_FL_LOCK_SURFACES is set, the cLockSurfaces field indicates
        // the number of trailing surface handles for locking
        if (pmeh->flags & MCDESC_FL_LOCK_SURFACES)
        {
            int cb;

            if ((pmeh->cLockSurfaces <= MCDESC_MAX_LOCK_SURFACES) &&
                ((cb = sizeof(HANDLE)*pmeh->cLockSurfaces) <= cjIn))
            {
                RtlCopyMemory(hLockSurfaces, pbCmd, cb);
                pmehPriv->pLockSurfaces = hLockSurfaces;
                pbCmd += cb;
                cjIn -= cb;
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return 0;
            }
        }
        else
        {
            pmehPriv->pLockSurfaces = NULL;
        }

        // If MCDESC_FL_EXTRA_WNDOBJ is set, the cExtraWndobj field indicates
        // the number of trailing HDCs to find WNDOBJs for.
        if (pmeh->flags & MCDESC_FL_EXTRA_WNDOBJ)
        {
            int cb;

            if ((pmeh->cExtraWndobj <= MCDESC_MAX_EXTRA_WNDOBJ) &&
                ((cb = sizeof(HDC)*pmeh->cExtraWndobj) <= cjIn))
            {
                RtlCopyMemory(hdcExtraWndobj, pbCmd, cb);
                pmehPriv->pExtraWndobj = hdcExtraWndobj;
                pbCmd += cb;
                cjIn -= cb;
            }
            else
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                return 0;
            }
        }
        else
        {
            pmehPriv->pExtraWndobj = NULL;
        }

        if (!pmeh->hSharedMem)
        {
            pmehPriv->pBuffer = (VOID *)pbCmd;
            pmehPriv->bufferSize = cjIn;
        }
        else
        {
            pmehPriv->pBuffer = (VOID *)NULL;
            pmehPriv->bufferSize = 0;
        }

        if (pmeh->flags & MCDESC_FL_CREATE_CONTEXT)
        {
            return iMcdSetupExtEscape(dco, iEscape, sizeof(inBuffer), inBuffer,
                                      cjOut, pvOut);
        }
        else
        {
            return iMcdExtEscape(dco, iEscape, sizeof(inBuffer), inBuffer,
                                 cjOut, pvOut);
        }
    }
    else if (iEscape == WNDOBJ_SETUP)
    {
        if (dco.dctp() != DCTYPE_DIRECT)
            return 0;

        return iWndObjSetupExtEscape(dco, iEscape, cjIn, pvIn, cjOut, pvOut);
    }
    else if (iEscape == DCICOMMAND)
    {
        return (0);
    }

    // Acquire the DEVLOCK to protect against dynamic mode changes.  We still
    // let escapes down if we're in full-screen mode, though.

    DEVLOCKOBJ dlo;

    dlo.vLockNoDrawing(dco);

    // Redirection DCs should not support escapes.  This is actually a tricky
    // case because the dc is DCTYPE_DIRECT but the redirection surface may
    // not be owned by the driver (and in fact the driver may crash if we
    // pass it a redirection surface).  So it's best to quit here.

    if (dco.pdc->bRedirection())
    {
        return(0);
    }

    // Make sure that a driver can't be called with an escape on a DIB bitmap
    // that it obviously won't own.

    if (dco.dctp() != DCTYPE_DIRECT)
    {
        if (!dco.bPrinter())
        {
            if ((dco.pSurface() == NULL) ||
                (dco.pSurface()->iType() != STYPE_DEVBITMAP))
            {
                return(0);
            }
        }
        else
        {
            // Have to be careful with the printer case since there is no
            // surface if metafile or escape called before StartDoc.  Only
            // reject if surface exists and does not match device.

            if ((dco.pSurface() != NULL) &&
                (dco.pSurface()->dhpdev() != pdo.dhpdev())
               )
            {
                return(0);
            }
        }
    }

    DRAWPATRECTP PatternRect;
    EXFORMOBJ   exo;

    // Adjust DRAWPATTERNRECT for banding

    if (iEscape == DRAWPATTERNRECT)
    {
        if (pdo.flGraphicsCaps() & GCAPS_NUP)
        {
            exo.vQuickInit(dco, WORLD_TO_DEVICE);

            //
            // If app passes us the wrong size return failure.
            // Note: wow always fix up 16bit DRAWPATRECT to 32bit
            // version.
            //
            if (cjIn != sizeof(DRAWPATRECT))
            {
                WARNING(" we are passed in a bad cjIn for DRAWPATTERNRECT\n");
                return (0);
            }
            else
            {
               PatternRect.DrawPatRect = *(DRAWPATRECT *) pvIn;
               PatternRect.pXformObj = (XFORMOBJ *) (PVOID) &exo;

               pvIn = (LPSTR)&PatternRect;

               cjIn = sizeof(DRAWPATRECTP);
            }
        }

        if (dco.pSurface() && (dco.pSurface())->bBanding())
        {
            if ((cjIn == sizeof(DRAWPATRECT)) || (pdo.flGraphicsCaps() & GCAPS_NUP))
            {
                DRAWPATRECT *pPatternRect = (DRAWPATRECT *) pvIn;

                // convert position to band coords from page coords.

                pPatternRect->ptPosition.x -= (dco.ptlPrintBandPos().x);
                pPatternRect->ptPosition.y -= (dco.ptlPrintBandPos().y);
            }
            else
            {
                WARNING("GreExtEscape():DRAWPATRECT - cjIn != sizeof(DRAWPATRECT)\n");

                // we don't fail, let driver effort for this.
            }
        }

    }

    // Pass the calls that require a FONTOBJ off to DoFontManagement.

    if ( ((iEscape >= 0x100) && (iEscape < 0x3FF)) ||
            ((iEscape == QUERYESCSUPPORT) &&
             ((*(ULONG*)pvIn >= 0x100) && (*(ULONG*)pvIn < 0x3FF))) )
    {
        return ( (int) DoFontManagement(dco,
                                        iEscape,
                                        (ULONG) cjIn,
                                        (PVOID) pvIn,
                                        (ULONG) cjOut,
                                        (PVOID) pvOut));
    }

    // Handle device compressed image passthrough support (JPEG or PNG images)

    if ( (iEscape == CHECKJPEGFORMAT) || (iEscape == CHECKPNGFORMAT) ||
         ((iEscape == QUERYESCSUPPORT) &&
          ((*(ULONG*)pvIn == CHECKJPEGFORMAT) ||
           (*(ULONG*)pvIn == CHECKPNGFORMAT ))
         )
       )
    {
        return ( iCheckPassthroughImage(dco,
                            pdo,
                            iEscape,
                            (ULONG) cjIn,
                            (PVOID) pvIn,
                            (ULONG) cjOut,
                            (PVOID) pvOut));
    }

    // Inc the target surface for output calls with a valid surface.

    if (dco.bValidSurf() && (pvOut == (LPSTR) NULL))
    {
        INC_SURF_UNIQ(dco.pSurface());
    }

    SURFOBJ *pso = dco.pSurface()->pSurfobj();

    // Handle OpenGL - QUERYSUPPORT escape with multimon system

#ifdef OPENGL_MM

    if (pdo.bMetaDriver())
    {
        if ( (iEscape == QUERYESCSUPPORT) &&
             ((*(ULONG *) pvIn == OPENGL_GETINFO) ||
              (*(ULONG *) pvIn == OPENGL_CMD)     ||
              (*(ULONG *) pvIn == MCDFUNCS)
             )
           )
        {

        // We need to change the meta-PDEV into a hardware specific PDEV

            HDEV hdevDevice = hdevFindDeviceHdev(
                                  dco.hdev(),
                                  (RECTL)dco.erclWindow(),
                                  NULL);

            if (hdevDevice)
            {
                // If the surface is pdev's primary surface, we will replace it with
                // new device pdev's surface.

                if (pdo.bPrimary(dco.pSurface()))
                {
                    PDEVOBJ pdoDevice(hdevDevice);

                    pso = pdoDevice.pSurface()->pSurfobj();
                }

                // replace meta pdevobj with device specific hdev.

                pdo.vInit(hdevDevice);
            }
        }
    }

#endif // OPENGL_MM

    // Locate the driver entry point.

    if (!PPFNDRV(pdo, Escape))
        return(0);

    // There is no surface in metafile DCs.  In addition,
    // it is unfortunate that apps call some printing escapes before
    // doing a StartDoc, so there is no real surface in the DC.
    // We fake up a rather poor one here if we need it.  The device
    // driver may only dereference the dhpdev from this!

    SURFOBJ soFake;

    if (pso == (SURFOBJ *) NULL)
    {
        RtlFillMemory((BYTE *) &soFake,sizeof(SURFOBJ),0);
        soFake.dhpdev = dco.dhpdev();
        soFake.hdev   = dco.hdev();
        soFake.iType  = (USHORT)STYPE_DEVICE;
        pso = &soFake;

        // Special case SETCOPYCOUNT if we havn't done a startdoc yet

        if ((iEscape == SETCOPYCOUNT) && (cjIn >= sizeof(USHORT)))
        {
            // let's remember the call in the dc and wait for start doc
            // since if there is no hardware support, we can simulate it
            // when EMF spooling case.

            dco.ulCopyCount((ULONG)(*(PUSHORT)pvIn));

            // check if the driver supports it and let him fill in the actual
            // size in the return buffer.

            pdo.Escape(pso,iEscape,cjIn,pvIn,cjOut,pvOut);

            // always behaves as success, since EMF spooling can simulate it.

            return(1);
        }

        // Special case post scripts EPS_PRINTING if we havn't done a startdoc yet

        if ((iEscape == EPSPRINTING) && (cjIn >= sizeof(USHORT)))
        {
            // yes, lets remember the call in the dc and wait for start doc

            if ((BOOL)*(PUSHORT)pvIn)
                dco.vSetEpsPrintingEscape();
            else
                dco.vClearEpsPrintingEscape();

            return(1);
        }
    }

    // Call the Driver.

    int iRes;

    iRes = (int) pdo.Escape(pso,
                        (ULONG) iEscape,
                        (ULONG) cjIn,
                        pvIn,
                        (ULONG) cjOut,
                        pvOut);

    return(iRes);
}

/******************************Public*Routine******************************\
* GreDrawEscape
*
* History:
*  07-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

int APIENTRY GreDrawEscape(
     HDC hdc,          //  Identifies the device context.
     int nEscape,      //  Specifies the escape function to be performed.
     int cjIn,         //  Number of bytes of data pointed to by lpIn
    PSTR pstrIn        //  Points to the input structure required
)
{
    LONG  lRet = 0;
    DCOBJ dco(hdc);

    //
    // The DC must be valid and also the surface must be valid in order
    // for the driver to be called
    //

    if ((dco.bValid()) && (dco.bHasSurface()))
    {
        //
        // We are responsible for not faulting on any call that we handle.
        // (As are all drivers below us!)  Since we handle QUERYESCSUPPORT, we'd
        // better verify the length.
        //

        if ((nEscape == QUERYESCSUPPORT) && (((ULONG) cjIn) < 4))
        {
            return(0);
        }

        //
        // see if the device supports it
        //

        PDEVOBJ pdo(dco.hdev());
        PFN_DrvDrawEscape pfnDrvDrawEscape = PPFNDRV(pdo, DrawEscape);

        if (pfnDrvDrawEscape != NULL)
        {
            //
            // Lock the surface and the Rao region, ensure VisRgn up to date.
            //

            DEVLOCKOBJ dlo(dco);

            //
            // if it is query escape support, get out early
            //

            if (nEscape == QUERYESCSUPPORT)
            {
                lRet = (int)(*pfnDrvDrawEscape)(dco.pSurface()->pSurfobj(),
                                       (ULONG)nEscape,
                                       (CLIPOBJ *)NULL,
                                       (RECTL *)NULL,
                                       (ULONG)cjIn,
                                       (PVOID)pstrIn);
            }
            else
            {
                if (!dlo.bValid())
                {
                    lRet = (int)dco.bFullScreen();
                }
                else
                {
                    ERECTL ercl = dco.erclWindow();

                    ECLIPOBJ co(dco.prgnEffRao(), ercl);

                    if (co.erclExclude().bEmpty())
                    {
                        lRet = (int)TRUE;
                    }
                    else
                    {
                        //
                        // Exclude any sprites.
                        //

                        DEVEXCLUDERECT dxoRect(dco.hdev(), &ercl);

                        //
                        // Inc the target surface uniqueness
                        //

                        INC_SURF_UNIQ(dco.pSurface());

                        lRet = (int)(*pfnDrvDrawEscape)(dco.pSurface()->pSurfobj(),
                                               (ULONG)nEscape,
                                               (CLIPOBJ *)&co,
                                               (RECTL *)&ercl,
                                               (ULONG)cjIn,
                                               (PVOID)pstrIn);
                    }
                }
            }
        }
    }

    return(lRet);
}

/******************************Public*Routine******************************\
* int APIENTRY GreStartDoc(HDC hdc, DOCINFOW *pDocInfo,BOOL *pbBanding)
*
* Arguments:
*
*   hdc        - handle to device context
*   pdi        - DOCINFO of output names
*   pbBanding  - return banding flag
*
* Return Value:
*
*   if successful return job identifier, else SP_ERROR
*
* History:
*  Wed 08-Apr-1992 -by- Patrick Haluptzok [patrickh]
* lazy surface enable, journal support, remove unnecesary validation.
*
*  Mon 01-Apr-1991 13:50:23 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

int APIENTRY GreStartDocInternal(
         HDC  hdc,
    DOCINFOW *pDocInfo,
        BOOL *pbBanding,
        INT  iDocJob
)
{
    int iRet = 0;
    int iJob;

    DCOBJ dco(hdc);

    if (dco.bValid())
    {
        PDEVOBJ po(dco.hdev());

        //
        // Check that this is a printer surface.
        //

        if ((!po.bDisplayPDEV())          &&
            (po.hSpooler())               &&
            (dco.dctp() == DCTYPE_DIRECT) &&
            (!dco.bHasSurface()))
        {
            // We now try and open the printer up in journal mode.  If we fail
            // then we try and open it up in raw mode.  If that fails we fail call.

            if (!po.bUMPD())
            {

               #define MAX_DOCINFO_DATA_TYPE 80
               DOC_INFO_1W DocInfo;
               WCHAR awchDatatype[MAX_DOCINFO_DATA_TYPE];

               DocInfo.pDocName = (LPWSTR)pDocInfo->lpszDocName;
               DocInfo.pOutputFile = (LPWSTR)pDocInfo->lpszOutput;
               DocInfo.pDatatype = NULL;

               // see if the driver wants to define its own data type.  If it does,
               // first fill the buffer in with the type requested by the app

               if (PPFNVALID(po, QuerySpoolType))
               {
                   awchDatatype[0] = 0;

                   // did the app specify a data type and will it fit in our buffer

                   if (pDocInfo->lpszDatatype)
                   {
                       int cjStr = (wcslen(pDocInfo->lpszDatatype) + 1) * sizeof(WCHAR);

                       if (cjStr < (MAX_DOCINFO_DATA_TYPE * sizeof(WCHAR)))
                       {
                           RtlCopyMemory((PVOID)awchDatatype,(PVOID)pDocInfo->lpszDatatype,cjStr);
                       }
                   }

                   if ((*PPFNDRV(po, QuerySpoolType))(po.dhpdev(), awchDatatype))
                   {
                       DocInfo.pDatatype = awchDatatype;
                   }
               }

               // open up the document


               iJob = (BOOL)StartDocPrinterW(po.hSpooler(), 1, (LPBYTE)&DocInfo);

               if (iJob <= 0)
               {
                   WARNING("ERROR GreStartDoc failed StartDocPrinter Raw Mode\n");
                   return(iJob);
               }
            }
            else
            {
                // if it is UMPD, StartDocPrinter has been called in user mode already
                iJob = iDocJob;
            }

            // Lazy surface creation happens now.

            if (po.bMakeSurface())
            {
                *pbBanding = (po.pSurface())->bBanding();

                // Put the surface into the DC.

                dco.pdc->pSurface(po.pSurface());

                if ( *pbBanding )
                {
                // if banding set Clip rectangle to size of band

                    dco.pdc->sizl((po.pSurface())->sizl());
                    dco.pdc->bSetDefaultRegion();
                }

                BOOL bSucceed = FALSE;

                PFN_DrvStartDoc pfnDrvStartDoc = PPFNDRV(po, StartDoc);

                bSucceed = (*pfnDrvStartDoc)(po.pSurface()->pSurfobj(),
                                             (PWSTR)pDocInfo->lpszDocName,
                                             iJob);

                // now, if a SETCOPYCOUNT escape has come through, send it down

                if (dco.ulCopyCount() != (ULONG)-1)
                {
                    ULONG ulCopyCount = dco.ulCopyCount();

                    GreExtEscape(hdc,SETCOPYCOUNT,sizeof(DWORD),
                                 (LPSTR)&ulCopyCount,0,NULL);

                    dco.ulCopyCount((ULONG)-1);
                }

                // now, if a EPSPRINTING escape has come through, send it down

                if (dco.bEpsPrintingEscape())
                {
                    SHORT b = 1;

                    GreExtEscape(hdc,EPSPRINTING,sizeof(b),(LPSTR)&b,0,NULL);

                    dco.vClearEpsPrintingEscape();
                }

                if (bSucceed)
                {
                    iRet = iJob;
                    dco.vSetSaveDepthStartDoc();
                }
            }
        }
        if (!iRet)
        {
            AbortPrinter(po.hSpooler());
        }
    }

    return iRet;
}

/****************************************************************************
*  NtGdiSetLinkedUFIs
*
*  History:
*   12/16/1996 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

#define QUICK_LINKS   4

extern "C" BOOL NtGdiSetLinkedUFIs(
                   HDC hdc,
    PUNIVERSAL_FONT_ID pufiLinks,
                 ULONG uNumUFIs
)
{
    BOOL bRet = TRUE;
    UNIVERSAL_FONT_ID pufiQuickLinks[QUICK_LINKS];
    PUNIVERSAL_FONT_ID pufi = NULL;

    if (!pufiLinks && uNumUFIs)
        return FALSE;
        
    if (uNumUFIs > QUICK_LINKS)
    {
        if (!BALLOC_OVERFLOW1(uNumUFIs,UNIVERSAL_FONT_ID))
        {
            pufi = (PUNIVERSAL_FONT_ID)
              PALLOCNOZ(uNumUFIs * sizeof(UNIVERSAL_FONT_ID),'difG');
        }

        if (pufi == NULL)
        {
            WARNING("NtGdiSetLinkedUFIs: out of memory\n");
            return(FALSE);
        }
    }
    else
    {
        pufi = pufiQuickLinks;
    }

    __try
    {
        if (pufiLinks)
        {
            ProbeForRead(pufiLinks,
                          sizeof(UNIVERSAL_FONT_ID)*uNumUFIs,
                          sizeof(DWORD) );
            RtlCopyMemory(pufi,pufiLinks,
                          sizeof(UNIVERSAL_FONT_ID)*uNumUFIs);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNINGX(106);
        bRet = FALSE;
    }

    if (bRet)
    {
        XDCOBJ dco(hdc);

        if (dco.bValid())
        {
            bRet = dco.bSetLinkedUFIs(pufi, uNumUFIs);
            dco.vUnlockFast();
        }
    }

    if (pufi != pufiQuickLinks)
    {
        VFREEMEM(pufi);
    }
    return(bRet);
}

int APIENTRY NtGdiStartDoc(
         HDC  hdc,
    DOCINFOW *pdi,
        BOOL *pbBanding,
        INT  iJob
)
{
    int iRet = 0;
    BOOL bkmBanding;
    DOCINFOW  kmDocInfo;
    ULONG cjStr;
    BOOL bStatus = TRUE;

    kmDocInfo.cbSize = 0;
    kmDocInfo.lpszDocName  = NULL;
    kmDocInfo.lpszOutput   = NULL;
    kmDocInfo.lpszDatatype = NULL;

    //DbgPrint ("NtGdiStartDoc\n");

    if (pdi != (DOCINFOW *)NULL)
    {
        __try
        {
            LPCWSTR lpszDocName;
            LPCWSTR lpszOutput;
            LPCWSTR lpszDatatype;

            ProbeForRead(pdi,sizeof(DOCINFOW),sizeof(ULONG));

            kmDocInfo.cbSize = pdi->cbSize;
            lpszDocName      = pdi->lpszDocName;
            lpszOutput       = pdi->lpszOutput;
            lpszDatatype     = pdi->lpszDatatype;

            if (lpszDocName != NULL)
            {
                cjStr = (wcslensafe(lpszDocName) + 1) * sizeof(WCHAR);
                kmDocInfo.lpszDocName = (LPWSTR)PALLOCNOZ(cjStr,'pmtG');
                if (kmDocInfo.lpszDocName == NULL)
                {
                    bStatus = FALSE;
                }
                else
                {
                    ProbeForRead(lpszDocName,cjStr,sizeof(WCHAR));
                    RtlCopyMemory((PVOID)kmDocInfo.lpszDocName,(PVOID)lpszDocName,cjStr);

                    // Guarantee NULL termination of string.
                    ((WCHAR *)kmDocInfo.lpszDocName)[(cjStr/sizeof(WCHAR)) - 1] = L'\0';
                }
            }

            if (lpszOutput != NULL)
            {
                cjStr = (wcslensafe(lpszOutput) + 1) * sizeof(WCHAR);
                kmDocInfo.lpszOutput = (LPWSTR)PALLOCNOZ(cjStr,'pmtG');
                if (kmDocInfo.lpszOutput == NULL)
                {
                    bStatus = FALSE;
                }
                else
                {
                    ProbeForRead(lpszOutput,cjStr,sizeof(WCHAR));
                    RtlCopyMemory((PVOID)kmDocInfo.lpszOutput,(PVOID)lpszOutput,cjStr);

                    // Guarantee NULL termination of string.
                    ((WCHAR *)kmDocInfo.lpszOutput)[(cjStr/sizeof(WCHAR)) - 1] = L'\0';
                }
            }

            // does it contain the new Win95 fields

            if ((kmDocInfo.cbSize >= sizeof(DOCINFOW)) && (lpszDatatype != NULL))
            {
                __try
                {
                    cjStr = (wcslensafe(lpszDatatype) + 1) * sizeof(WCHAR);

                    ProbeForRead(lpszDatatype,cjStr,sizeof(WCHAR));
                    kmDocInfo.lpszDatatype = (LPWSTR)PALLOCNOZ(cjStr,'pmtG');

                    if (kmDocInfo.lpszDatatype == NULL)
                    {
                        bStatus = FALSE;
                    }
                    else
                    {
                        RtlCopyMemory((PVOID)kmDocInfo.lpszDatatype,(PVOID)lpszDatatype,cjStr);

                        // Guarantee NULL termination of string.
                        ((WCHAR *)kmDocInfo.lpszDatatype)[(cjStr/sizeof(WCHAR)) - 1] = L'\0';
                    }
                }
                __except(EXCEPTION_EXECUTE_HANDLER)
                {
                    // apps may have forgotten to initialize this.  Don't want to fail

                    if (kmDocInfo.lpszDatatype != NULL)
                    {
                        VFREEMEM(kmDocInfo.lpszDatatype);
                        kmDocInfo.lpszDatatype = NULL;
                    }
                }
            }
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());

            bStatus = FALSE;
        }
    }

    if (bStatus)
    {
        iRet = GreStartDocInternal(hdc,&kmDocInfo,&bkmBanding, iJob);

        if (iRet != 0)
        {
            __try
            {
                ProbeForWrite(pbBanding,sizeof(BOOL),sizeof(BOOL));
                *pbBanding = bkmBanding;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                // SetLastError(GetExceptionCode());

                iRet = 0;
            }
        }
    }

    if (kmDocInfo.lpszDocName != NULL)
    {
        VFREEMEM(kmDocInfo.lpszDocName);
    }

    if (kmDocInfo.lpszOutput != NULL)
    {
        VFREEMEM(kmDocInfo.lpszOutput);
    }

    if (kmDocInfo.lpszDatatype != NULL)
    {
        VFREEMEM(kmDocInfo.lpszDatatype);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* bEndDocInternal
*
* History:
*  Tue 22-Sep-1992 -by- Wendy Wu [wendywu]
* Made it a common routine for EndDoc and AbortDoc.
*
*  Sun 21-Jun-1992 -by- Patrick Haluptzok [patrickh]
* surface disable, check for display dc.
*
*  Mon 01-Apr-1991 13:50:23 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL bEndDocInternal(HDC hdc, FLONG fl)
{
    BOOL bSucceed;
    BOOL bEndPage;

    ASSERTGDI(((fl & ~ED_ABORTDOC) == 0), "GreEndDoc: invalid fl\n");

    DCOBJ dco(hdc);

    if (!dco.bValidSurf())
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        WARNING("GreEndDoc failed - invalid DC\n");
        return(FALSE);
    }

    // before going any futher, restore the DC to it's original level

    if (dco.lSaveDepth() > dco.lSaveDepthStartDoc())
        GreRestoreDC(hdc,dco.lSaveDepthStartDoc());

    PDEVOBJ po(dco.hdev());

    if (po.bDisplayPDEV() || po.hSpooler() == (HANDLE)0)
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        WARNING("GreEndDoc: Display PDEV or not spooling yet\n");
        return(FALSE);
    }

    SURFACE   *pSurf = dco.pSurface();

    bEndPage = (*PPFNDRV(po,EndDoc))(pSurf->pSurfobj(), fl);

    if (!po.bUMPD())
    {
       if (fl & ED_ABORTDOC)
           bSucceed = AbortPrinter(po.hSpooler());
       else
           bSucceed = EndDocPrinter(po.hSpooler());
    }
    else
        bSucceed = TRUE;

    // Reset pixel format accelerators.

    dco.ipfdDevMax(-1);

    // Remove the surface from the DC.

    dco.pdc->pSurface((SURFACE *) NULL);

    po.vDisableSurface();

    return(bSucceed && bEndPage);
}

/******************************Public*Routine******************************\
* NtGdiEndDoc()
*
\**************************************************************************/

BOOL APIENTRY NtGdiEndDoc( HDC hdc )
{
    return(bEndDocInternal(hdc, 0));
}

/******************************Public*Routine******************************\
* NtGdiAbortDoc()
*
\**************************************************************************/

BOOL APIENTRY NtGdiAbortDoc( HDC hdc )
{
    return(bEndDocInternal(hdc, ED_ABORTDOC));
}

/******************************Public*Routine******************************\
* NtGdiStartPage()
*
*  Mon 01-Apr-1991 13:50:23 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiStartPage( HDC hdc )
{
    DCOBJ dco(hdc);
    BOOL  bReturn = FALSE;

    if (dco.bValidSurf())
    {
        if (dco.bHasSurface())
        {
            PDEVOBJ po(dco.hdev());

            //
            // Must be spooling already
            //

            if (po.hSpooler())
            {
                SURFACE *pSurf = dco.pSurface();
                BOOL    bStarted;

                //
                // if it is not a User Mode Printer,
                // Call the spooler before calling the printer.
                //

                if (!po.bUMPD())
                {
                    bStarted = StartPagePrinter(po.hSpooler());
                }
                else
                {
                    bStarted = TRUE;
                }

                if (bStarted)
                {
                    if ((*PPFNDRV(po, StartPage))(pSurf->pSurfobj()))
                    {
                        //
                        // Can't ResetDC in an active page
                        //

                        dco.fsSet(DC_RESET);

                        //
                        // Reset band position in page (if we are banding)
                        //
                        dco.vResetPrintBandPos();

                        bReturn = TRUE;
                    }
                    else
                    {
                        bEndDocInternal(hdc, ED_ABORTDOC);
                    }
                }
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return (bReturn);
}

/******************************Public*Routine******************************\
* NtGdiEndPage()
*
*  Mon 01-Apr-1991 13:50:23 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY NtGdiEndPage( HDC hdc )
{
    BOOL bRet = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValidSurf())
    {
        if (dco.bHasSurface())
        {
            PDEVOBJ po(dco.hdev());

        // Must be spooling already.

            if (!po.bDisplayPDEV() && po.hSpooler())
            {
                SURFACE *pSurf = dco.pSurface();

                if ((*PPFNDRV(po, SendPage))(pSurf->pSurfobj()))
                {
                    BOOL bEndPage;

                    if (po.bUMPD())
                    {
                        //
                        // all the spooler calls have been made at the user mode
                        // for User Mode Printer Drivers
                        //
                        bEndPage = TRUE;
                    }
                    else
                    {
                        bEndPage = EndPagePrinter(po.hSpooler());
                    }

                    if (bEndPage)
                    {
                        //
                        // Allow ResetDC to function again.
                        //

                        dco.fsClr(DC_RESET);

                        //
                        // Delete the wndobj and reset the pixel format.
                        // Since we don't allow pixel format to change once it
                        // is set, we need to reset it internally here to allow a
                        // different pixel format in the next page.  This means
                        // that applications must make the OpenGL rendering
                        // context not current before ending a page or a document.
                        // They also need to set the pixel format explicitly in
                        // the next page if they need it.
                        //

                        EWNDOBJ *pwoDelete = pSurf->pwo();
                        if (pwoDelete)
                        {
                            GreDeleteWnd((PVOID) pwoDelete);
                            pSurf->pwo((EWNDOBJ *) NULL);
                        }

                        //
                        // Reset pixel format accelerators.
                        //

                        dco.ipfdDevMax(-1);

                        bRet = TRUE;
                    }
                }
            }
        }
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL APIENTRY GreDoBanding(HDC hdc,BOOL bStart,RECTL *prcl)
*
*
*  Tue 20-Dec-1994 14:50:45 by Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL GreDoBanding( HDC hdc, BOOL bStart, POINTL *pptl, PSIZE pSize )
{
    BOOL bRet = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValidSurf() && (dco.bHasSurface()))
    {
        PDEVOBJ po(dco.hdev());

        // Must be spooling already.

        if (po.hSpooler())
        {
            SURFACE *pSurf = dco.pSurface();

            if (pSurf->SurfFlags & BANDING_SURFACE)
            {
                BOOL bSucceed;

                if ( bStart )
                {
                    // DrvStartBanding

                    PFN_DrvStartBanding pfnDrvStartBanding = PPFNDRV(po, StartBanding);

                    bSucceed = (*pfnDrvStartBanding)(pSurf->pSurfobj(),pptl);
                    #if DEBUG_BANDING
                        DbgPrint("just called DrvStartBanding which returned %s %d %d\n",
                             (bSucceed) ? "TRUE" : "FALSE", pptl->x, pptl->y );
                    #endif
                    pSize->cx = pSurf->so.sizlBitmap.cx;
                    pSize->cy = pSurf->so.sizlBitmap.cy;

                    //
                    // Set band position in page (if we are banding)
                    //
                    dco.vSetPrintBandPos(pptl);
                }
                else
                {
                    // DrvNextBand

                    PFN_DrvNextBand pfnDrvNextBand = PPFNDRV(po, NextBand);

                    bSucceed = (*pfnDrvNextBand)(pSurf->pSurfobj(), pptl );

                    #if DEBUG_BANDING
                        DbgPrint("just called DrvNextBand which returned %s %d %d\n",
                             (bSucceed) ? "TRUE" : "FALSE", pptl->x, pptl->y );
                    #endif

                    if ( (bSucceed) && ( pptl->x == -1 ) )
                    {
                        // No more bands.

                       if (!po.bUMPD())
                       {
                           //
                           // all the spooler calls have been made at the user mode
                           // for User Mode Printer Drivers
                           //
                           bSucceed = EndPagePrinter(po.hSpooler());
                       }

                        // Allow ResetDC to function again.

                        if (bSucceed)
                        {
                            dco.fsClr(DC_RESET);
                        }

                        // Delete the wndobj and reset the pixel format.
                        // Since we don't allow pixel format to change once it is set, we need
                        // to reset it internally here to allow a different pixel format in the
                        // next page. This means that applications must make the OpenGL
                        // rendering context not current before ending a page or a document.
                        // They also need to set the pixel format explicitly in the next page
                        // if they need it.

                        if (bSucceed)
                        {
                            EWNDOBJ *pwoDelete = pSurf->pwo();
                            if (pwoDelete)
                            {
                                GreDeleteWnd((PVOID) pwoDelete);
                                pSurf->pwo((EWNDOBJ *) NULL);
                            }

                            // Reset pixel format accelerators.

                            dco.ipfdDevMax(0);
                        }
                    }
                    else
                    {
                        if ( !bSucceed )
                        {
                            WARNING("GreDoBanding failed DrvNextBand\n");
                        }
                        else
                        {
                           //
                           // Set band position in page (if we are banding)
                           //
                           dco.vSetPrintBandPos(pptl);
                        }
                    }
                }

                return(bSucceed);
            }
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* NtGdiDoBanding()
*
* History:
*  11-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
*  01-Mar-1995 -by-  Lingyun Wang [lingyunw]
* Expanded it.
\**************************************************************************/

BOOL APIENTRY NtGdiDoBanding(
       HDC  hdc,
      BOOL  bStart,
    POINTL *pptl,
     PSIZE  pSize
)
{
    POINTL  ptTmp;
    SIZE szTmp;
    BOOL    bRet = TRUE;

    bRet = GreDoBanding(hdc,bStart,&ptTmp,&szTmp);

    if (bRet)
    {
        __try
        {
            ProbeForWrite(pptl,sizeof(POINTL), sizeof(DWORD));
            *pptl = ptTmp;
            ProbeForWrite(pSize,sizeof(SIZE), sizeof(DWORD));
            *pSize = szTmp;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            // SetLastError(GetExceptionCode());

            bRet = FALSE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL APIENTRY GreGetPerBandInfo()
*
* History:
*  05-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
***************************************************************************/

ULONG APIENTRY GreGetPerBandInfo(
    HDC          hdc,
    PERBANDINFO *ppbi
)
{
    ULONG ulRet = GDI_ERROR;

    //
    // Set default. Assume no repeat, just play one time per one band.
    //
    ppbi->bRepeatThisBand = FALSE;

    DCOBJ dco(hdc);

    if (dco.bValidSurf() && (dco.bHasSurface()))
    {
        PDEVOBJ po(dco.hdev());

        if (po.hSpooler())
        {
            SURFACE *pSurf = dco.pSurface();

            //
            // The surface should be banded.
            //
            if (pSurf->SurfFlags & BANDING_SURFACE)
            {
                PFN_DrvQueryPerBandInfo pfnDrvQueryPerBandInfo = PPFNDRV(po, QueryPerBandInfo);

                //
                // DrvQueryPerBandInfo is optional fucntion, check it is provided.
                //
                if (pfnDrvQueryPerBandInfo)
                {
                    //
                    // Call driver.
                    //
                    ulRet = (*pfnDrvQueryPerBandInfo)(pSurf->pSurfobj(), ppbi);

                    if (ulRet == DDI_ERROR)
                    {
                        ulRet = GDI_ERROR;
                    }
                }
                 else
                {
                    //
                    // The function is not provided, that means the driver don't
                    // want to repeat more than one time for each band. Just return
                    // true, and use default that setted above.
                    //
                    ulRet = 0;
                }
            }
        }
    }

    return (ulRet);
}

/******************************Public*Routine******************************\
* BOOL APIENTRY NtGdiGetPerBandInfo()
*
* History:
*  05-Jan-1997 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
***************************************************************************/

ULONG APIENTRY NtGdiGetPerBandInfo(
    HDC          hdc,
    PERBANDINFO *ppbi
)
{
    PERBANDINFO PerBandInfo;
    ULONG       ulRet = GDI_ERROR;

    if (ppbi)
    {
        __try
        {
            ProbeForRead(ppbi,sizeof(PERBANDINFO),sizeof(ULONG));
            RtlCopyMemory(&PerBandInfo,ppbi,sizeof(PERBANDINFO));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            return (ulRet);
        }
    }

    ulRet = GreGetPerBandInfo(hdc,&PerBandInfo);

    if (ulRet && (ulRet != GDI_ERROR))
    {
        __try
        {
            ProbeForWrite(ppbi,sizeof(PERBANDINFO), sizeof(ULONG));
            RtlCopyMemory(ppbi,&PerBandInfo,sizeof(PERBANDINFO));
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ulRet = GDI_ERROR;
        }
    }

    return (ulRet);
}

/******************************Public*Routine******************************\
* BOOL APIENTRY EngCheckAbort
*
* History:
*  01-Apr-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY EngCheckAbort(SURFOBJ *pso)
{
    // Return FALSE if it's a faked surfobj.

    PSURFACE pSurf = SURFOBJ_TO_SURFACE(pso);

    if (pSurf == NULL || pSurf->hsurf() == 0)
    {
        return(FALSE);
    }

    return(pSurf->bAbort());
}

/******************************Public*Routine******************************\
* BOOL APIENTRY NtGdiAnyLinkedFonts()
*
* Returns TRUE if there are any linked fonts in the system.
*
*
* History:
*  12-Dec-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

extern "C" BOOL NtGdiAnyLinkedFonts()
{
    return(gbAnyLinkedFonts || IS_SYSTEM_EUDC_PRESENT());
}

/******************************Public*Routine******************************\
* BOOL APIENTRY NtGdiGetLinkedUFIs
*
* This API returns UFI's (in order of priority) of all the fonts linked to
* the font currently in the DC.
*
*
* History:
*  12-Dec-1996 by Gerrit van Wingerden [gerritv]
* Wrote it.
\**************************************************************************/

extern "C" INT NtGdiGetLinkedUFIs(
                   HDC hdc,
    PUNIVERSAL_FONT_ID pufiLinkedUFIs,
                   INT BufferSize
    )
{
    INT iRet = 0;
    PUNIVERSAL_FONT_ID pufi = NULL;

    if (( BufferSize > 0 ) && ( pufiLinkedUFIs != NULL ))
    {
        if (!BALLOC_OVERFLOW1(BufferSize,UNIVERSAL_FONT_ID))
        {
            pufi = (PUNIVERSAL_FONT_ID)
              PALLOCNOZ(BufferSize * sizeof(UNIVERSAL_FONT_ID),'difG');
        }

        if ( pufi == NULL )
        {
            iRet = -1 ;
        }
    }
    else if (BufferSize && pufiLinkedUFIs == NULL)
    {
        iRet = -1;
    }

    if ( iRet != -1 )
    {
       {
           XDCOBJ dco(hdc);
           if (dco.bValid())
           {
               RFONTOBJ rfo(dco,FALSE);

               if (rfo.bValid())
               {
                   iRet = rfo.GetLinkedFontUFIs(dco, pufi,BufferSize);
               }
               else
               {
                   iRet = -1;
                   WARNING("NtGdiGetLinkedUFIS: Invalid RFNTOBJ");
               }

               dco.vUnlockFast();
           }
           else
           {
               WARNING("NtGdiGetLinkedUFIS: Invalid DC");
               iRet = -1;
           }

       }

        if ( iRet > 0 )
        {
            __try
            {
                if (pufiLinkedUFIs)
                {
                    ProbeForWrite(pufiLinkedUFIs,
                                  sizeof(UNIVERSAL_FONT_ID)*BufferSize,
                                  sizeof(DWORD));

                    RtlCopyMemory(pufiLinkedUFIs,
                                  pufi,sizeof(UNIVERSAL_FONT_ID)*BufferSize);
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNINGX(62);
                iRet = -1;
            }

        }
    }

    if ( pufi != NULL )
    {
        VFREEMEM( pufi );
    }

    if ( iRet == -1 )
    {
    // We need to set the last error here to something because the spooler
    // code that calls this relies on there being a non-zero error code
    // in the case of failure.  Since we really have no idea I will just
    // set this to ERROR_NOT_ENOUGH_MEMORY which would be the most likely
    // reason for a failure

        EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);
    }

    return(iRet);
}

ULONG GreGetEmbedFonts()
{
    PUBLIC_PFTOBJ pfto(gpPFTPrivate);

    if (!pfto.bValid() || pfto.cFiles() == 0)         // no embedded fonts
        return 0;

    return (pfto.GetEmbedFonts());
}


BOOL GreChangeGhostFont(VOID *fontID, BOOL bLoad)
{
    PUBLIC_PFTOBJ pfto(gpPFTPrivate);

    if (!pfto.bValid() || !pfto.cFiles())            // somehow the private font table is invalid
        return FALSE;

    return (pfto.ChangeGhostFont(fontID, bLoad));
}


extern "C" BOOL NtGdiAddEmbFontToDC(HDC hdc, VOID **pFontID)
{
    VOID *fontID;
    BOOL bRet = TRUE;

    __try
    {
        ProbeForRead(pFontID, sizeof(VOID *), sizeof(BYTE));
        RtlCopyMemory(&fontID, pFontID, sizeof(VOID *));
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        bRet = FALSE;
    }

    if (bRet)
    {
        bRet = FALSE;

        XDCOBJ dco(hdc);

        if (dco.bValid())
        {
            PUBLIC_PFTOBJ pfto(gpPFTPrivate);
        
        // FonID could be a fake value from hacker to crash the system        
            if(pfto.bValid() && pfto.VerifyFontID(fontID))
                bRet = dco.bAddRemoteFont((PFF *)fontID);            
        }
    }

    return bRet;
}


/******************************Public*Routine******************************\
* BOOL GreGetUFI
*
* History:
*  18-Jan-1995 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL GreGetUFI( HDC hdc, PUNIVERSAL_FONT_ID pufi,
                DESIGNVECTOR *pdv, ULONG *pcjDV, ULONG *pulBaseCheckSum,
                FLONG *pfl,
                VOID **pfontID)
{
    *pfl = 0;
    if (pfontID)
        *pfontID = NULL;

    BOOL bRet = FALSE;
    XDCOBJ dco(hdc);

    if(dco.bValid())
    {
        RFONTOBJ rfo(dco,FALSE);

        if (rfo.bValid())
        {
            rfo.vUFI( pufi );

        // now on to determine if this is private or public font

            PFEOBJ pfeo(rfo.ppfe());
            if (pfeo.bValid())
            {
                PFFOBJ pffo(pfeo.pPFF());
                if (pffo.bValid())
                {
                    if (pffo.bInPrivatePFT())
                    {
                        *pfl |= FL_UFI_PRIVATEFONT;
                        if (pfontID)
                            *pfontID = (VOID*) pfeo.pPFF();                        
                    }

                    if (pffo.bMemFont())
                    {
                        *pfl |= FL_UFI_MEMORYFONT;
                    }

                    if (pffo.pdv())
                    {
                        *pfl |= FL_UFI_DESIGNVECTOR_PFF;
                        if (pdv)
                            RtlCopyMemory(pdv, pffo.pdv(), pffo.cjDV());
                        if (pcjDV)
                            *pcjDV = pffo.cjDV();
                        if (pulBaseCheckSum)
                        {
                        // factor out DV check sum. If we endup using algorithm
                        // that couples these two numbers, then BaseCheckSum will
                        // have to be remembered at the time of computation.

                            *pulBaseCheckSum = pffo.ulCheckSum();

                            *pulBaseCheckSum -= ComputeFileviewCheckSum(pffo.pdv(), pffo.cjDV());
                        }
                    }

                    bRet = TRUE;
                }
            }
        }
        else
        {
            WARNING("GreGetUFI: Invalid rfo");
        }

        dco.vUnlockFast();
    }
    else
    {
        WARNING("GreGetUFI: Invalid DC");
    }

    return bRet;
}



/******************************Public*Routine******************************\
*
* ppfeGetPFEFromUFI
*
* This is used all over the place
*
* History:
*  11-Aug-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



PFE *ppfeGetPFEFromUFIInternal (
    PUNIVERSAL_FONT_ID pufi,
    BOOL               bPrivate,
    BOOL               bCheckProccess
)
{
    PFE *ppfeRet = NULL;
    BOOL    bThreadMatch = FALSE;

    PFELINK *ppfel;

    PUBLIC_PFTOBJ pfto(bPrivate ? gpPFTPrivate : gpPFTPublic);
    if (!pfto.bValid())
        return ppfeRet;

    FHOBJ fho(&pfto.pPFT->pfhUFI);
    HASHBUCKET  *pbkt;

    pbkt = fho.pbktSearch( NULL, (UINT*)NULL, pufi );

    if (!pbkt)
    {
        WARNING1("ppfeGetPFEFromUFI: pbkt is NULL\n");
        return ppfeRet;
    }

    for(ppfel = pbkt->ppfelEnumHead; ppfel; ppfel = ppfel->ppfelNext)
    {
        PFEOBJ pfeo(ppfel->ppfe);

        if (UFI_SAME_FACE(pfeo.pUFI(),pufi) && (!bCheckProccess || pfeo.SameProccess()))
        {
            if(pfeo.bDead())
            {
                WARNING("ppfeGetPFEFromUFI: get the pathname to a dead PFE\n");
            }
            else
            {
                if (ppfeRet == NULL)
                {
                    bThreadMatch = pfeo.SameThread();
                    ppfeRet = ppfel->ppfe;
                }
                else
                {
                    // if we get here, it means we have multiple face name and process match.
                    // Do more extensive matching using thread ID.
                    if (!bThreadMatch && pfeo.SameThread())
                    {
                       // This is a better candidate.
                       // Although spooler can be running multiple threads, the same thread for a given
                       // port is used by spooler.  However, if multiple printers were sharing the same
                       // port, we cannot distinguish.  

                       ppfeRet = ppfel->ppfe;
                       bThreadMatch = TRUE;
                       break;
                    }
                }
            }
        }
    }

    #if DBG
    if (ppfel == NULL)
    {
        WARNING("ppfeGetPFEFromUFI can't find the PFE\n");
    }
    #endif

    return ppfeRet;
}




PFE *ppfeGetPFEFromUFI (
    PUNIVERSAL_FONT_ID pufi,
    BOOL               bPrivate,
    BOOL               bCheckProccess
)
{
    PFE * pfeRet = NULL;

    if (bPrivate)
    pfeRet = ppfeGetPFEFromUFIInternal(pufi, TRUE, bCheckProccess);
    if (!pfeRet)
    pfeRet = ppfeGetPFEFromUFIInternal(pufi, FALSE, bCheckProccess);
    return pfeRet;
}

#define SZDLHEADER ALIGN8(offsetof(DOWNLOADFONTHEADER, FileOffsets[1]))


/*********************************Public*Routine*********************************\
* BOOL GreGetUFIPathname
*
* Get the path name and file counts to a given UFI.
*
* History:
*  Feb-04-1997  Xudong Wu   [tessiew]
* Wrote it.
\********************************************************************************/

BOOL GreGetUFIPathname(
    PUNIVERSAL_FONT_ID pufi,
    ULONG             *pcwc,
    LPWSTR             pwszPathname,
    ULONG             *pcNumFiles,
    FLONG              fl,
    BOOL              *pbMemFont,
    ULONG             *pcjView,
    PVOID              pvView,
    BOOL              *pbTTC,
    ULONG             *piTTC
)
{
    BOOL bRet = TRUE;
    PFE *ppfe = ppfeGetPFEFromUFI(pufi, (BOOL)(fl & (FL_UFI_PRIVATEFONT | FL_UFI_MEMORYFONT)), TRUE);

    if (ppfe == NULL)
    {
        WARNING("GreGetUFIPathname can't find the PFE\n");
        return FALSE;
    }

    PFFOBJ pffo(ppfe->pPFF);

    if (pcNumFiles)
    {
        *pcNumFiles = pffo.cNumFiles();
    }
    if (pcwc)
    {
        *pcwc = pffo.cSizeofPaths();
    }
    if (pwszPathname)
    {
        RtlCopyMemory(pwszPathname, pffo.pwszPathname(), pffo.cSizeofPaths() * sizeof(WCHAR));
    }

    if (pbMemFont)
    {
        *pbMemFont = (BOOL)(ppfe->flPFE & PFE_MEMORYFONT);
    }

    if (ppfe->flPFE & PFE_MEMORYFONT)
    {
        NTSTATUS NtStatus;
        SIZE_T    ViewSize = 0;
        ULONG    cjView;

        ASSERTGDI((pffo.ppfvGet()[0])->SpoolerPid == (W32PID)W32GetCurrentPID() ||          // either the current process
                  gpidSpool == (PW32PROCESS)W32GetCurrentProcess(),                                  // or the spooler
                  "GreGetUFIPathname: wrong process to access memory font\n");

        #if 0

        PVOID  pvView1;
        LARGE_INTEGER SectionOffset; SectionOffset.QuadPart = 0;

        NtStatus = MmMapViewOfSection(
                       pffo.ppfvGet()[0]->fv.pSection , // SectionToMap,
                       PsGetCurrentProcess(), //
                       &pvView1          , // CapturedBase,
                       0                 , // ZeroBits,
                       ViewSize          , // CommitSize,
                       &SectionOffset    , // SectionOffset,
                       &ViewSize         , // CapturedViewSize,
                       ViewUnmap         , // InheritDisposition,
                       SEC_NO_CHANGE     , // AllocationType,
                       PAGE_READONLY       // Protect
                       );

        if (!NT_SUCCESS(NtStatus))
        {
            //WARNING("could not map mem font to the spooler process\n");
            KdPrint(("could not map mem font to the spooler process\n"));
            *pcjView = 0;
            *ppvView = NULL;
            return FALSE;
        }

    // if this is a memory font, preceeding the font image
    // there is going to be the header stuff in the section,
    // so will need to adjust the pointer. cjView will already contain
    // the correct data corresponding to the size without the header

        *pcjView = pffo.ppfvGet()[0]->fv.cjView;
        *ppvView = (PVOID)((BYTE *)pvView1 + SZDLHEADER);

        #endif

        cjView = pffo.ppfvGet()[0]->fv.cjView;

        if (pcjView)
        {
            *pcjView = cjView;
        }

        if (pvView)
        {
            PVOID pvKView;

#ifdef _HYDRA_
        // MmMapViewInSessionSpace is internally promoted to
        // MmMapViewInSystemSpace on non-Hydra systems.

            NtStatus = Win32MapViewInSessionSpace(
                          pffo.ppfvGet()[0]->fv.pSection,
                          &pvKView,
                          &ViewSize);
#else
            NtStatus = MmMapViewInSystemSpace(
                           pffo.ppfvGet()[0]->fv.pSection,
                           &pvKView,
                           &ViewSize);
#endif

            if (!NT_SUCCESS(NtStatus))
            {
                //WARNING("could not map mem font to the system space\n");
                KdPrint(("could not map mem font to the system space\n"));
                return FALSE;
            }

            __try
            {
            // if this is a memory font, preceeding the font image
            // there is going to be the header stuff in the section,
            // so will need to adjust the pointer before copying.
            // cjView already corresponds to the correct data
            // without the header

                ProbeForWrite(pvView, cjView, sizeof(BYTE));
                RtlCopyMemory(pvView, ((BYTE *)pvKView + SZDLHEADER), cjView);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                bRet = FALSE;
            }

#ifdef _HYDRA_
        // MmUnmapViewInSessionSpace is internally promoted to
        // MmUnmapViewInSystemSpace on non-Hydra systems.

            Win32UnmapViewInSessionSpace(pvKView);
#else
            MmUnmapViewInSystemSpace(pvKView);
#endif
        }
    }

    if (bRet && pbTTC && piTTC)
    {
        *pbTTC = FALSE;
        *piTTC = 0;

        PFF *pPFF = ppfe->pPFF;

        if (pPFF->hdev == (HDEV) gppdevTrueType)
        {
            COUNT cFonts = pPFF->cFonts;

        // if this is a ttc file we need at least 4 faces, eg.
        // foo1, @foo1, foo2, @foo2 ...

            if ((cFonts >= 4) && !(cFonts & 1))
            {
                ASSERTGDI(ppfe->ufi.Index, "ufi.Index must not be zero\n");
                *piTTC = (ppfe->ufi.Index - 1) / 2;
                *pbTTC = TRUE;
            }
        }
    }

    return bRet;
}



/******************************Public*Routine******************************\
* BOOL GreForceUFIMapping( HDC hdc, PUNIVERSAL_FONT_ID pufi )
*
* History:
*  3-Mar-1995 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL GreForceUFIMapping( HDC hdc, PUNIVERSAL_FONT_ID pufi)
{
    XDCOBJ dco(hdc);

    if (!dco.bValid())
    {
        WARNING("GreForceUFIMapping: Invalid DC");
        return(FALSE);
    }

    dco.pdc->vForceMapping( pufi );

    dco.vUnlockFast();

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL GreGetUFIBits
*
* History:
*  18-Jan-1995 -by- Gerrit van Wingerden
* Wrote it.
\**************************************************************************/

BOOL GreGetUFIBits(
    PUNIVERSAL_FONT_ID pufi,
    COUNT cjMaxBytes,
    PVOID pjBits,
    PULONG pulFileSize,
    FLONG  fl
)
{
    PDOWNLOADFONTHEADER pdfh;
    BOOL bRet = FALSE;

// not needed in nt 5.0

#if 0

    if (UFI_TYPE1_FONT(pufi))
    {
        PTYPEONEINFO pTypeOneInfo;

        // First get a pointer to the Type1 list so we can search for a PFM/PFB
        // pair with an ID that matches the UFI's checksum value.

        pTypeOneInfo = GetTypeOneFontList();

        if (pTypeOneInfo)
        {
            DWORD HashValue = UFI_HASH_VALUE(pufi);
            COUNT j,cPFM,cPFB,cPFMReal;
            PULONG pPFM,pPFB;

        // search through all the type one fonts in the system to find a match

            for (j = 0; j < pTypeOneInfo->cNumFonts*2; j+=2)
            {
                if (pTypeOneInfo->aTypeOneMap[j].Checksum == HashValue )
                {
                    break;
                }
            }

            // if we found a match map both the PFM and the PFB

            if (j < pTypeOneInfo->cNumFonts*2)
            {
                if (EngMapFontFileInternal((ULONG_PTR)&(pTypeOneInfo->aTypeOneMap[j].fv),
                                  &pPFM,
                                  &cPFMReal, FALSE))
                {
                    if (EngMapFontFileInternal((ULONG_PTR)&(pTypeOneInfo->aTypeOneMap[j+1].fv),
                                      &pPFB,&cPFB, FALSE))
                    {
                        cPFM = ALIGN4( cPFMReal );
                        *pulFileSize = cPFB + cPFM + ALIGN8(sizeof(DOWNLOADFONTHEADER));

                        if ( pjBits )
                        {
                            pdfh = (DOWNLOADFONTHEADER*) pjBits;

                            if ( cjMaxBytes >= *pulFileSize )
                            {
                                BYTE *pjDest = (BYTE*) pjBits + ALIGN8(sizeof(DOWNLOADFONTHEADER));

                                pdfh->FileOffsets[0] = cPFM;
                                pdfh->Type1ID = HashValue;
                                pdfh->NumFiles = 0;  // signifies Type1

                                RtlCopyMemory(pjDest,(PVOID)pPFM,cPFMReal);
                                pjDest += cPFM;
                                RtlCopyMemory(pjDest,(PVOID)pPFB,cPFB);
                                bRet = TRUE;
                            }
                        }
                        else
                        {
                            bRet = TRUE;
                        }

                        EngUnmapFontFile((ULONG_PTR)&(pTypeOneInfo->aTypeOneMap[j+1].fv));
                    }
                    EngUnmapFontFile((ULONG_PTR)&(pTypeOneInfo->aTypeOneMap[j].fv));
                }

                // Calling GetTypeOneFontList increments the reference count so we
                // need to decrement and possibly release it when we are done.

                GreAcquireFastMutex(ghfmMemory);
                pTypeOneInfo->cRef -= 1;

                if ( !pTypeOneInfo->cRef )
                {
                    VFREEMEM(pTypeOneInfo);
                }
                GreReleaseFastMutex(ghfmMemory);
            }
        }
    }
    else
#endif

    {
        // Stabilize the public PFT for mapping.

        WCHAR *pwcPath = NULL;
        COUNT cNumFiles;

        {
            SEMOBJ  so(ghsemPublicPFT);

            PFE  *ppfe = ppfeGetPFEFromUFI(pufi,
                                       (BOOL)(fl & (FL_UFI_PRIVATEFONT | FL_UFI_MEMORYFONT)),
                                       FALSE); // do not check the proccess id
            if (!ppfe)
                return FALSE;

            PFFOBJ pffo (ppfe->pPFF);

            ASSERTGDI( pffo.pwszPathname() != NULL, "GreGetUFIBits pathname was NULL\n");

            // We need to copy this to a buffer since the PFFOBJ could go away after
            // we release the semaphore.

            if (pwcPath = (PWCHAR) PALLOCMEM(pffo.cSizeofPaths()*sizeof(WCHAR),'ufiG'))
            {
                RtlCopyMemory((void*)pwcPath,pffo.pwszPathname(),
                              pffo.cSizeofPaths()*sizeof(WCHAR));
                cNumFiles = pffo.cNumFiles();
            }
        }

        if ( pwcPath )
        {
            FILEVIEW fv;
            RtlZeroMemory( &fv, sizeof(fv) );

            COUNT cjHeaderSize = offsetof(DOWNLOADFONTHEADER,FileOffsets)+
              cNumFiles*sizeof(ULONG);

            // just to be safe align everything on quadword boundaries

            cjHeaderSize = ALIGN8(cjHeaderSize);

            if ( (pjBits == NULL) || (cjHeaderSize < cjMaxBytes))
            {
                UINT File,Offset;
                WCHAR *pFilePath;

                *pulFileSize = cjHeaderSize;

                if ( pjBits )
                {
                    pdfh = (DOWNLOADFONTHEADER*)pjBits;
                    pdfh->Type1ID = 0;
                    pdfh->NumFiles = cNumFiles;
                    pjBits = (PVOID) ((PBYTE) pjBits + cjHeaderSize);
                    cjMaxBytes -= cjHeaderSize;
                }

                bRet = TRUE;

                for (File = 0, Offset = 0, pFilePath = pwcPath;
                    File < cNumFiles;
                    File += 1, pFilePath = pFilePath + wcslen(pFilePath) + 1)
                {
                    // dont do this under the semaphore because the file could be on the net

                    // WINBUG 364416 Look into whether we need a try except in GreGetUFIBits
                    //
                    // Old comment:
                    //  - we need a try except here.
                    //


                    if (!bMapFile(pFilePath, &fv, 0, NULL))
                    {
                        WARNING("GreGetUFIBits: error mapping file");
                        bRet = FALSE;
                        break;
                    }

                    ULONG AllignedSize = ALIGN8(fv.cjView);

                    *pulFileSize += AllignedSize;

                    if ( pjBits != NULL )
                    {
                        if ( cjMaxBytes >= fv.cjView )
                        {
                        // Files are mapped into the kernel mode address space

                            if (fv.pvKView && fv.cjView)
                                RtlCopyMemory(pjBits,fv.pvKView,fv.cjView);

                            pdfh->FileOffsets[File] = Offset + fv.cjView;
                            Offset += AllignedSize;

                            pjBits = (PVOID) ((PBYTE) pjBits+ AllignedSize);
                            cjMaxBytes -= AllignedSize;
                        }
                        else
                        {
                            WARNING("GreGetUFIBits: buffer too small\n");
                            bRet = FALSE;
                            vUnmapFile(&fv);
                            break;
                        }
                    }
                    vUnmapFile(&fv);
                }
            }
            VFREEMEM(pwcPath);
        }
    }
    return(bRet);
}


/**********************Public*Routine******************************\
* NtGdiRemoveMergeFont(HDC hdc, UNIVERSAL_FONT_ID *pufi)
*
* History:
*  Jan-27-1997 -by- Xudong Wu [tessiew]
* Wrote it.
\******************************************************************/
BOOL
APIENTRY
NtGdiRemoveMergeFont(HDC hdc, UNIVERSAL_FONT_ID *pufi)
{
    BOOL  bRet = TRUE;
    UNIVERSAL_FONT_ID ufiTmp;
    XDCOBJ dco(hdc);

    if(!dco.bValid())
    {
        WARNING("NtGdiRemoveMergefont bogus HDC\n" );
        return FALSE;
    }
    else if (dco.bDisplay())
    {
        WARNING("NtGdiRemoveMergefont: display DC\n" );
        bRet = FALSE;
    }
    else
    {
        ASSERTGDI(pufi != NULL, "Try to remove a font wiht pufi == NULL\n");

        __try
        {
            ProbeForRead(pufi, sizeof(UNIVERSAL_FONT_ID), sizeof(DWORD));
            ufiTmp = *pufi;
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            bRet = FALSE;
        }

        if (bRet)
        {
            if (!(bRet = dco.bRemoveMergeFont(ufiTmp)))
            {
                WARNING("NtGdiRemoveMergeFont failed on dco.bRemoveMergeFont\n");
            }
        }
    }

    dco.vUnlockFast();

    return bRet;
}

/****************************************************************************
*  INT GreQueryFonts( PUNIVERSAL_FONT_ID, ULONG, PLARGE_INTEGER )
*
*  History:
*   5/24/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

INT GreQueryFonts(
    PUNIVERSAL_FONT_ID pufi,
                 ULONG nBufferSize,
        PLARGE_INTEGER pTimeStamp
)
{

    PUBLIC_PFTOBJ  pfto;
    return(pfto.QueryFonts(pufi,nBufferSize,pTimeStamp));
}

/*****************************************************************************
 * PTYPEONEINFO GetTypeOneFontList()
 *
 * This function returns a pointer to a TYPEONEINFO structure that contains
 * a list of file mapping handles and checksums for the Type1 fontst that are
 * installed in the system.  This structure also has a reference count and a
 * time stamp coresponding to the last time fonts were added or removed from
 * the system.  The reference count is 1 biased meaning that even if no PDEV's
 * a referencing it, it is still 1.
 *
 * History
 *  8-10-95 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 ****************************************************************************/

PTYPEONEINFO GetTypeOneFontList()
{
                    UNICODE_STRING UnicodeRoot;
                      PTYPEONEINFO InfoReturn = NULL;
                 OBJECT_ATTRIBUTES ObjectAttributes;
                              BOOL bCloseRegistry = FALSE;
                          NTSTATUS NtStatus;
             PKEY_FULL_INFORMATION InfoBuffer = NULL;
    PKEY_VALUE_PARTIAL_INFORMATION PartialInfo = NULL;
                             ULONG KeyInfoLength;
                            HANDLE KeyRegistry;

    RtlInitUnicodeString(&UnicodeRoot,TYPE1_KEY);

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeRoot,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

        NtStatus = ZwOpenKey(&KeyRegistry,
                         GENERIC_READ,
                         &ObjectAttributes);

    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("Unable to open TYPE1 key\n");
        goto done;
    }

    bCloseRegistry = TRUE;

    NtStatus = ZwQueryKey(KeyRegistry,
                          KeyFullInformation,
                          (PVOID) NULL,
                          0,
                          &KeyInfoLength );

    if ((NtStatus != STATUS_BUFFER_OVERFLOW) &&
       (NtStatus != STATUS_BUFFER_TOO_SMALL))
    {
        WARNING("Unable to query TYPE1 key\n");
        goto done;
    }

    InfoBuffer = (PKEY_FULL_INFORMATION) PALLOCNOZ(KeyInfoLength,'f1tG');

    if ( !InfoBuffer )
    {
        WARNING("Unable to alloc mem for TYPE1 info\n");
        goto done;
    }

    NtStatus = ZwQueryKey(KeyRegistry,
                          KeyFullInformation,
                          InfoBuffer,
                          KeyInfoLength,
                          &KeyInfoLength );

    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("Unable to query TYPE1 key\n");
        goto done;
    }

    // if there aren't any soft TYPE1 fonts installed then just return now.

    if ( !InfoBuffer->Values )
    {
        goto done;
    }

    GreAcquireFastMutex(ghfmMemory);

    if (gpTypeOneInfo != NULL )
    {
        if ((gpTypeOneInfo->LastWriteTime.LowPart == InfoBuffer->LastWriteTime.LowPart)&&
           (gpTypeOneInfo->LastWriteTime.HighPart == InfoBuffer->LastWriteTime.HighPart))
        {
            // If the times match then increment the ref count and return

            InfoReturn = gpTypeOneInfo;
            gpTypeOneInfo->cRef += 1;
            GreReleaseFastMutex(ghfmMemory);
            goto done;
        }

        gpTypeOneInfo->cRef -= 1;

        // At this point if gTypeOneInfo->cRef > 0 then there is a PDEV using this
        // info still.  If gTypeOneInfo->cRef = 0 then it is okay to delete it.
        // Note that this behavior means we must initialize gTypeOneInfo->cRef to 1.

        if ( !gpTypeOneInfo->cRef  )
        {
            VFREEMEM(gpTypeOneInfo);
        }

        // Whether someone is using it or not, remove pointer to current type one
        // info so that noone else tries to use it.

        gpTypeOneInfo = NULL;
    }

    GreReleaseFastMutex(ghfmMemory);


    ULONG MaxValueName, MaxValueData, TotalData, Values;

    MaxValueData = ALIGN4(InfoBuffer->MaxValueDataLen);
    Values = InfoBuffer->Values;

    TotalData = MaxValueData + sizeof(KEY_VALUE_PARTIAL_INFORMATION) +
                (Values * sizeof(ULONG)) + // Room for checksums
                (Values * 2 * sizeof(WCHAR) * MAX_PATH) +  // Room for PFM and PFB paths
                Values * sizeof(FONTFILEVIEW);    // Room for mapping structs

    PartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) PALLOCNOZ(TotalData,'f1tG');

    if ( !PartialInfo )
    {
        WARNING("Unable to allocate memory for TYPE1 info\n");
        goto done;
    }

    BYTE *ValueData;
    PFONTFILEVIEW FontFileViews;
    WCHAR *FullPFM, *FullPFB;
    ULONG *Checksums;
    ULONG SoftFont,Result;

    ValueData =  &(PartialInfo->Data[0]);
    FullPFM = (WCHAR*) &ValueData[MaxValueData];
    FullPFB = &FullPFM[(MAX_PATH+1)*Values];
    Checksums = (ULONG*) &FullPFB[Values*(MAX_PATH+1)];

    FontFileViews = (PFONTFILEVIEW) &Checksums[Values];

    for ( SoftFont = 0; SoftFont < Values; SoftFont ++ )
    {
        WCHAR *TmpValueData;
        COUNT  SizeOfString;

        NtStatus = ZwEnumerateValueKey(KeyRegistry,
                                       SoftFont,
                                       KeyValuePartialInformation,
                                       PartialInfo,
                                       MaxValueData +
                                       sizeof(KEY_VALUE_PARTIAL_INFORMATION),
                                       &Result );

        if (!NT_SUCCESS(NtStatus))
        {
            WARNING("Unable to enumerate TYPE1 keys\n");
            goto done;
        }

        TmpValueData = (WCHAR*) ValueData;
        TmpValueData = TmpValueData + wcslen(TmpValueData)+1;

        SizeOfString = wcslen(TmpValueData);

        if ( SizeOfString > MAX_PATH )
        {
            WARNING("PFM path too long\n");
            goto done;
        }

        wcscpy(&FullPFM[SoftFont*(MAX_PATH+1)],TmpValueData);

        TmpValueData += SizeOfString+1;

        SizeOfString = wcslen(TmpValueData);

        if ( SizeOfString > MAX_PATH )
        {
            WARNING("PFB path too long\n");
            goto done;
        }

        wcscpy(&FullPFB[SoftFont*(MAX_PATH+1)],TmpValueData);
    }

    // Release key at this point.  We are about to call off to the spooler
    // which could take a while and shouldn't be holding the key while we do so.

    ZwCloseKey(KeyRegistry);
    bCloseRegistry = FALSE;

    ULONG i, ValidatedTotal,TotalSize;


    for ( i = 0, ValidatedTotal = TotalSize = 0; i < SoftFont; i++ )
    {
        BOOL bAbleToLoadFont;

        bAbleToLoadFont = FALSE;

    // go through all the PFM's and PFB's and expand them to full paths by
    // calling back to the spooler

        if (GetFontPathName(&FullPFM[i*(MAX_PATH+1)],&FullPFM[i*(MAX_PATH+1)]) &&
           GetFontPathName(&FullPFB[i*(MAX_PATH+1)],&FullPFB[i*(MAX_PATH+1)]))
        {
        // Compute the checksum that we are goine to give to the PSCRIPT
        // driver to stuff into the IFI metrics.  We will use the sum
        // of the checksum of both files.

            FILEVIEW fv;
            RtlZeroMemory( &fv, sizeof(fv) );

            // Temporarily map a kernel mode view

            if (bMapFile(&FullPFM[i*(MAX_PATH+1)], &fv, 0, NULL))
            {
                ULONG sum;

                sum = ComputeFileviewCheckSum(fv.pvKView, fv.cjView);
                vUnmapFile( &fv);

                // Temporarily map a kernel mode view

                if (bMapFile(&FullPFB[i*(MAX_PATH+1)], &fv, 0, NULL))
                {
                    sum += ComputeFileviewCheckSum(fv.pvKView, fv.cjView);

                    vUnmapFile( &fv);

                    ValidatedTotal += 2;
                    TotalSize += (wcslen(&FullPFM[i*(MAX_PATH+1)]) + 1) * sizeof(WCHAR);
                    TotalSize += (wcslen(&FullPFB[i*(MAX_PATH+1)]) + 1) * sizeof(WCHAR);
                    Checksums[i] = sum;
                    bAbleToLoadFont = TRUE;
                }
            }
        }

        if (!bAbleToLoadFont)
        {
            FullPFM[i*(MAX_PATH+1)] = (WCHAR) 0;
            FullPFB[i*(MAX_PATH+1)] = (WCHAR) 0;
        }
    }

    TotalSize += ValidatedTotal * sizeof(TYPEONEMAP) + sizeof(TYPEONEINFO);

    PTYPEONEINFO TypeOneInfo;
    WCHAR *StringBuffer;

    if (!ValidatedTotal)
    {
        goto done;
    }

    TypeOneInfo = (PTYPEONEINFO) PALLOCMEM(TotalSize,'f1tG');
    StringBuffer = (WCHAR*) &TypeOneInfo->aTypeOneMap[ValidatedTotal];

    if ( !TypeOneInfo )
    {
        goto done;
    }

    TypeOneInfo->cRef = 1; // must be one so PDEV stuff doesn't deallocate it unless
                           // we explicitly set it to 0

    TypeOneInfo->cNumFonts = ValidatedTotal/2;
    TypeOneInfo->LastWriteTime = InfoBuffer->LastWriteTime;

    // loop through everything again packing everything tightly together in memory
    // and setting up the FONTFILEVIEW pointers.

    UINT CurrentFont;

    for ( i = 0, CurrentFont = 0; i < SoftFont; i ++ )
    {
        if (FullPFM[i*(MAX_PATH+1)] != (WCHAR) 0)
        {
            wcscpy(StringBuffer,&FullPFM[i*(MAX_PATH+1)]);
            TypeOneInfo->aTypeOneMap[CurrentFont].fv.pwszPath = StringBuffer;
            StringBuffer += wcslen(&FullPFM[i*(MAX_PATH+1)]) + 1;

            wcscpy(StringBuffer,&FullPFB[i*(MAX_PATH+1)]);
            TypeOneInfo->aTypeOneMap[CurrentFont+1].fv.pwszPath = StringBuffer;
            StringBuffer += wcslen(&FullPFB[i*(MAX_PATH+1)]) + 1;

            // Both the PFM and PFB share the same checksum since they represent
            // the same font file.

            TypeOneInfo->aTypeOneMap[CurrentFont].Checksum = Checksums[i];
            TypeOneInfo->aTypeOneMap[CurrentFont+1].Checksum = Checksums[i];

            CurrentFont += 2;
        }
    }

    ASSERTGDI(CurrentFont == ValidatedTotal,
              "GetTypeOneFontList:CurrentFont != ValidatedTotal\n");

    // everything should be set up now just our list into

    GreAcquireFastMutex(ghfmMemory);

    if ( gpTypeOneInfo )
    {
        // looks like someone snuck in before us.  that's okay well use their font
        // list and destroy our own
        VFREEMEM(TypeOneInfo);
    }
    else
    {
        gpTypeOneInfo = TypeOneInfo;
    }

    gpTypeOneInfo->cRef += 1;
    InfoReturn = gpTypeOneInfo;

    GreReleaseFastMutex(ghfmMemory);

done:

    if ( bCloseRegistry )
    {
        ZwCloseKey(KeyRegistry);
    }

    if ( InfoBuffer )
    {
        VFREEMEM(InfoBuffer);
    }

    if ( PartialInfo )
    {
        VFREEMEM(PartialInfo);
    }

    return(InfoReturn);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   EngGetType1FontList
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

BOOL APIENTRY EngGetType1FontList(
             HDEV  hdev,
       TYPE1_FONT *pType1Buffer,
            ULONG  cjType1Buffer,
           PULONG  pulLocalFonts,
           PULONG  pulRemoteFonts,
    LARGE_INTEGER *pLastModified
)
{
    BOOL bRet = FALSE;

    PPDEV ppdev = (PPDEV) hdev;

    if (!ppdev->TypeOneInfo)
    {
        ppdev->TypeOneInfo = GetTypeOneFontList();
    }

    PREMOTETYPEONENODE RemoteTypeOne = ppdev->RemoteTypeOne;

    if (ppdev->TypeOneInfo || RemoteTypeOne )
    {
        *pulRemoteFonts = 0;

        while (RemoteTypeOne)
        {
            *pulRemoteFonts += 1;
            RemoteTypeOne = RemoteTypeOne->pNext;
        }

        if ( ppdev->TypeOneInfo )
        {
            *pulLocalFonts = ppdev->TypeOneInfo->cNumFonts;
            *pLastModified = *(&ppdev->TypeOneInfo->LastWriteTime);
        }
        else
        {
            *pulLocalFonts = 0;
            pLastModified->LowPart = 0;
            pLastModified->HighPart = 0;
        }

        // If buffer is NULL then caller is only querying for time stamp
        // and size of buffer.

        if (pType1Buffer)
        {
            COUNT Font;

            if (cjType1Buffer >= (*pulLocalFonts+*pulRemoteFonts) * sizeof(TYPE1_FONT))
            {
                TYPEONEMAP *pTypeOneMap = ppdev->TypeOneInfo->aTypeOneMap;

                for (Font = 0;
                    ppdev->TypeOneInfo && (Font < ppdev->TypeOneInfo->cNumFonts);
                    Font++ )
                {
                    pType1Buffer[Font].hPFM = (HANDLE)&pTypeOneMap[Font*2].fv;
                    pType1Buffer[Font].hPFB = (HANDLE)&pTypeOneMap[Font*2+1].fv;
                    pType1Buffer[Font].ulIdentifier = pTypeOneMap[Font*2+1].Checksum;
                }

                RemoteTypeOne = ppdev->RemoteTypeOne;

                while ( RemoteTypeOne )
                {
                    pType1Buffer[Font].hPFM = (HANDLE) &(RemoteTypeOne->fvPFM);
                    pType1Buffer[Font].hPFB = (HANDLE) &(RemoteTypeOne->fvPFB);
                    pType1Buffer[Font].ulIdentifier =
                                        RemoteTypeOne->pDownloadHeader->Type1ID;

                    Font += 1;
                    RemoteTypeOne = RemoteTypeOne->pNext;
                }

                bRet = TRUE;
            }
            else
            {
                WARNING("GDI:EngGetType1FontList:pType1Buffer is too small.\n");
            }
        }
        else
        {
            bRet = TRUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* EngQueryLocalTime()
*
*   Fill in the ENG_TIME_FIELDS structure with the current local time.
*   Originaly added for postscript
*
* History:
*  07-Feb-1996 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID EngQueryLocalTime( PENG_TIME_FIELDS ptf )
{
    TIME_FIELDS   tf;
    LARGE_INTEGER li;

    GreQuerySystemTime(&li);
    GreSystemTimeToLocalTime(&li,&li);
    RtlTimeToTimeFields(&li,&tf);

    ptf->usYear         = tf.Year;
    ptf->usMonth        = tf.Month;
    ptf->usDay          = tf.Day;
    ptf->usHour         = tf.Hour;
    ptf->usMinute       = tf.Minute;
    ptf->usSecond       = tf.Second;
    ptf->usMilliseconds = tf.Milliseconds;
    ptf->usWeekday      = tf.Weekday;
}


/******************************Public*Routine******************************\
* BOOL GreGetBaseUFIBits(UNIVERSAL_FONT_ID *pufi, FONTFILEVIEW **ppfv)
*
* History:
*  17-Jan-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL GreGetBaseUFIBits(UNIVERSAL_FONT_ID *pufi, FONTFILEVIEW *pfv)
{
    BOOL bRet = FALSE;

// base font is not an old fashioned type1 font

    ASSERTGDI(!UFI_TYPE1_FONT(pufi), "Base MM Font is old fashioned device font\n");

// Stabilize the public PFT for mapping.

    PUBLIC_PFTOBJ  pfto(gpPFTPublic);

// base mm font will always be added to gpPFTPublic (not to gpPFTPrivate)
// on the print server machine (look at NtGdiAddRemoteFontsToDC).
// Therefore, we shall only look in the public table for it

    PFE  *ppfe = ppfeGetPFEFromUFI(pufi,
                                   FALSE,  // public
                                   FALSE); // do not check the proccess id

    if (!ppfe)
        return bRet;

    PFFOBJ pffo(ppfe->pPFF);

    #if DBG
    COUNT cNumFiles = pffo.cNumFiles();
    ASSERTGDI(cNumFiles == 1, "GreGetBaseUFIBits cNumFiles != 1\n");
    ASSERTGDI(!wcsncmp(pffo.pwszPathname(), L"REMOTE-", 7), "GreGetBaseUFIBits pathname != REMOTE\n");
    #endif

// We need to copy this to a buffer since the PFFOBJ could go away after
// we release the semaphore. TRUE? Not really. The point is that ppfv is
// only going to be used during a print job while base font is added to DC.
// That is, only when DC goes away the base font will be removed so that this
// ppfv will be around for as long as is necessary to service its mm instances
// that are used in the same job.

    *pfv = *(pffo.ppfvGet()[0]);

    ASSERTGDI(pfv->SpoolerPid == W32GetCurrentPID() || gpidSpool == (PW32PROCESS)W32GetCurrentProcess(),
              "GreGetBaseUFIBits, Pid doesn't match\n");

    return TRUE;
}


/******************************Public*Routine******************************\
*
* NtGdiAddRemoteMMInstanceToDC(
*
* History:
*  17-Jan-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL NtGdiAddRemoteMMInstanceToDC(
    HDC                   hdc,
    DOWNLOADDESIGNVECTOR *pddv,
    ULONG                 cjDDV
    )
{

    DOWNLOADDESIGNVECTOR ddv;
    BOOL bRet = FALSE;
    FONTFILEVIEW fv;

    XDCOBJ dco(hdc);

    if (!dco.bValid())
        return bRet;

    if (!dco.bDisplay() && (cjDDV <= sizeof(DOWNLOADDESIGNVECTOR)) )
    {
        __try
        {
            ProbeForRead(pddv,cjDDV, sizeof(BYTE));
            RtlCopyMemory(&ddv, pddv, cjDDV);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("GreAddRemoteMMInstanceToDC, bogus ddv\n");
        }

    // Now get the pointer to the bits of the base mm font.
    // This will only work because the base font has already been installed
    // on the print server. We always first write the bits for the base font
    // to the spool file and then design vectors for all its instances.
    // Consenquently, as we spool, the base font has already been added
    // and its bits live in virtual memory window allocated by
    // NtGdiAddRemoteFontToDC. We now just get the file view for the bits

        if (GreGetBaseUFIBits(&ddv.ufiBase, &fv))
        {
            PUBLIC_PFTOBJ  pfto;

            UINT offset = ALIGN8(sizeof(FONTFILEVIEW*));
            FONTFILEVIEW** ppfv = (FONTFILEVIEW**)
              PALLOCMEM( sizeof(FONTFILEVIEW) + offset, 'vffG');

            if (ppfv == NULL)
            {
                WARNING1("NtGdiAddRemoteMMInstanceToDC out of memory\n");
                bRet = FALSE;
            }
            else
            {
            // CAUTION
            //
            // The PFF cleanup code has intimate knowledge of this
            // code so be sure you synchronize changes in here and there.
            //
            // We are about to create a FONTFILEVIEW that corresponds to
            // a pool image of a font downloaded for metafile printing.
            // This case is signified by setting FONTFILEVIEW::pszPath
            // to zero. This corresponds to a image loaded once.

                ppfv[0] = (FONTFILEVIEW*)((BYTE *)ppfv + offset);

            // the following line of code is crucial:
            // since we set ulRegionSize to zero, the code
            // which does unsecure mem will not be executed for instances
            // but only for the base font. However, ppfv will be freed properly.

                fv.ulRegionSize = 0;

            // cRefCountFD should be set to or 1, what should it be?
            // It turns out it does not matter because ulRegionSize
            // is set to zero, so that unmap remote fonts is not called on
            // pdv record, only on the base font.

                fv.cRefCountFD = 0;

                *(ppfv[0]) = fv;

                bRet = pfto.bLoadRemoteFonts(dco, ppfv, 1, &ddv.dv, NULL);
            }
        }
    }
    else
    {
        WARNING("GreAddRemoteMMInstanceToDC bogus HDC,display DC, or cjDDV\n");
    }

    dco.vUnlockFast();

    return (bRet);
}


/*************Public**Routine**************\
* BOOL GreUnmapMemFont
*
* History:
*  Jul-03-97  Xudong Wu [TessieW]
* Wrote it
\*******************************************/
#if 0

BOOL GreUnmapMemFont(PVOID pvView)
{
    NTSTATUS NtStatus;

    NtStatus = MmUnmapViewOfSection(PsGetCurrentProcess(), (PVOID)((PBYTE)pvView - SZDLHEADER));

    if (!NT_SUCCESS(NtStatus))
    {
        WARNING("Unmapping memory font's view in application's process space failed");
        return FALSE;
    }

    return TRUE;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rgnobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: rgnobj.cxx
*
* Non inline RGNOBJ methods
*
* Created: 02-Jul-1990 12:36:30
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// Region is expanded by this size when the size is too small.
// Used by bAddScans().

#define FILL_REGION_SIZE    10 * QUANTUM_REGION_SIZE

extern RECTL rclEmpty;

#if DBG
RGNOBJ *gprgn = NULL;
#define VALIDATE(ro)    {gprgn = &ro; (ro).bValidateFramedRegion(); }
#else
#define VALIDATE(ro)
#endif

//
// The following declarations are required by the native c8 compiler.
//

ULONG   REGION::ulUniqueREGION;
HRGN    hrgnDefault;
REGION  *prgnDefault;

/**************************************************************************\
 *
\**************************************************************************/

#if DBG

#define MAXRGNLOG  1000

extern "C"
{
    int gMaxRgnLog = MAXRGNLOG;
    RGNLOGENTRY argnlog[MAXRGNLOG];
    LONG iLog  = 0;
    LONG iPass = 0;
};

BOOL bDispRgn = 0;
BOOL bLogRgn  = 1;

VOID vPrintRgn(RGNLOGENTRY& rl)
{
    DbgPrint("%p,%p,(%8lx),%8lx,%8lx,%4lx, %s, %p, %p\n",
            rl.hrgn,rl.prgn,rl.lRes,rl.lParm1,rl.lParm2,rl.lParm3,
            rl.pszOperation,rl.pvCaller,rl.pvCallersCaller);
}

RGNLOG::RGNLOG(HRGN hrgn,PREGION prgn,PSZ psz,ULONG_PTR l1, ULONG_PTR l2, ULONG_PTR l3)
{
    if (!bLogRgn)
        return;

    plog = &argnlog[iLog++];
    if (iLog >= MAXRGNLOG)
    {
        iLog = 0;
        ++iPass;
    }

    if (plog >= argnlog+MAXRGNLOG)
        plog = &argnlog[0];

    plog->hrgn = (HOBJ) hrgn;
    plog->prgn = prgn;
    plog->pszOperation = psz;
    plog->lRes = 0xff;
    plog->lParm1 = l1;
    plog->lParm2 = l2;
    plog->lParm3 = l3;
    plog->teb    = (PVOID)W32GetCurrentThread();

    RtlGetCallersAddress(&plog->pvCaller,&plog->pvCallersCaller);

    if (bDispRgn)
        vPrintRgn(*plog);
}

RGNLOG::RGNLOG(PREGION prgn,PSZ psz,ULONG_PTR l1, ULONG_PTR l2, ULONG_PTR l3)
{
    if (!bLogRgn)
        return;

    plog = &argnlog[iLog++];
    if (iLog >= MAXRGNLOG)
    {
        iLog = 0;
        ++iPass;
    }

    if (plog >= argnlog+MAXRGNLOG)
        plog = &argnlog[0];

    plog->hrgn = (HOBJ) 1;
    plog->prgn = prgn;
    plog->pszOperation = psz;
    plog->lRes = 0xff;
    plog->lParm1 = l1;
    plog->lParm2 = l2;
    plog->lParm3 = l3;
    plog->teb    = (PVOID)W32GetCurrentThread();

    RtlGetCallersAddress(&plog->pvCaller,&plog->pvCallersCaller);

    if (bDispRgn)
        vPrintRgn(*plog);
}
#endif

/******************************Public*Routine******************************\
* RGNOBJ::vGetSubRect
*
* Return largest rectange completely within the region.
*
* History:
*  09-Sep-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vGetSubRect(PRECTL prcl)
{
// We should try and do better here but this will solve 80% of our
// performance goal.  We should try and return the biggest rectangle
// completely contained within the region that we can quickly compute.

    if (prgn->sizeRgn <= SINGLE_REGION_SIZE)
    {
    // Bounding rect == rect region

        *prcl = prgn->rcl;
        return;
    }

    *prcl = rclEmpty;
}

/******************************Public*Routine******************************\
*
*
* History:
*  05-Jul-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

RGNOBJAPI::RGNOBJAPI(HRGN hrgn,BOOL bSelect)
{
    prgn  = (REGION *)HmgLock((HOBJ)hrgn, RGN_TYPE);
    RGNLOG rl(hrgn,prgn,"RGNOBJAPI::RGNOBJAPI");
    hrgn_    = hrgn;
    bSelect_ = bSelect;

    if (prgn != (PREGION)NULL)
    {
        BOOL bStatus = TRUE;
        //
        // Does this region have valid user-mode data? If there is
        // any problem with the user-mode state, then the contructor
        // must unlock the region set prgn to NULL.
        //

        PRGNATTR prRegion = (PRGNATTR)(PENTRY_FROM_POBJ(prgn)->pUser);

        if (prRegion != (PRGNATTR)NULL)
        {
            //
            // update a valid rgn, we can get an invalid
            // region here because gdi32!DeleteRegion must
            // clear the VALID flag before calling the
            // kernel.
            //

            if (
                 (prRegion->AttrFlags & ATTR_RGN_VALID) &&
                 !(prRegion->AttrFlags & ATTR_CACHED)
               )
            {
                if (prRegion->AttrFlags & ATTR_RGN_DIRTY)
                {
                    if (prRegion->Flags == NULLREGION)
                    {
                        vSet();
                        prRegion->AttrFlags &= ~ATTR_RGN_DIRTY;
                    }
                    else if (prRegion->Flags == SIMPLEREGION)
                    {
                        vSet(&prRegion->Rect);
                        prRegion->AttrFlags &= ~ATTR_RGN_DIRTY;
                    }
                }
            }
            else
            {
                bStatus = FALSE;
            }
        }

        if (!bStatus)
        {
            DEC_EXCLUSIVE_REF_CNT(prgn);
            prgn  = NULL;
            hrgn_ = NULL;
        }
    }
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bDeleteHandle()
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bDeleteHandle");

    ASSERTGDI(hrgn_ != (HRGN) NULL, "Delete NULL\n");

    if (hrgn_ == hrgnDefault)
    {
        rl.vRet(0);
        return(FALSE);
    }

    PREGION prgn1 = (PREGION)HmgRemoveObject((HOBJ) hrgn_, 1, 0, FALSE, RGN_TYPE);

    if (prgn1 != prgn)
    {
        rl.vRet(-1);

    #if DBG
        DbgPrint("couldn't delete api rgn - %p, prgn1 = %p\n",hrgn_,prgn1);
        DbgBreakPoint();
    #endif
        return(FALSE);
    }
    hrgn_ = NULL;

    rl.vRet(1);
    return(TRUE);
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bDeleteRGNOBJAPI()
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bDelete");
    BOOL bRes = FALSE;
    POBJECTATTR pRgnattr = NULL;

    //
    // if this region has user-mode memory, try to place in cache
    //

    if (prgn)
    {
        PENTRY pEntry = PENTRY_FROM_POBJ(prgn);
        pRgnattr = (POBJECTATTR)pEntry->pUser;

        if (pRgnattr)
        {
            bRes = bPEBCacheHandle(prgn->hGet(),RegionHandle,pRgnattr,pEntry);
        }
    }

    if (!bRes)
    {
        bRes = bDeleteHandle() && bDeleteRGNOBJ();

        if (bRes && (pRgnattr != NULL))
        {
            HmgFreeObjectAttr((POBJECTATTR)pRgnattr);
        }
    }
    rl.vRet(bRes);
    return(bRes);
}

VOID RGNOBJ::vDeleteRGNOBJ()
{
    //
    // Deletes the region and sets it to NULL.
    //

    RGNLOG rl(prgn,"RGNOBJ::vDeleteRGNOBJ");
    prgn->vDeleteREGION();
    prgn = NULL;
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

//
// This struct and the following union can be thrown away
// when someone fixes the BASEOBJECT cExclusiveLock and BaseFlags sharing
// the same DWORD.
//
struct SplitLockAndFlags {
  USHORT c_cExclusiveLock;
  USHORT c_BaseFlags;
};

union SplitOrCombinedLockAndFlags {
  SplitLockAndFlags S;
  ULONG W;
};

BOOL RGNOBJ::bSwap(RGNOBJ *pro)
{
    RGNLOG rl(prgn,"RGNOBJ::bSwap",(ULONG_PTR)pro,(ULONG_PTR)pro->prgn);

    //
    // Swap the BASEOBJECT info at the start of the region.
    // Ensuring that when cExclusiveLock is swapped, the BaseFlags
    // is not swapped with it.
    // BaseFlags contains information about how the
    // object was allocated (and therefore, how it must be deallocated).  Thus,
    // it represents state associated with the actual memory, not the object,
    // and should not be swapped.
    //
    // See comments regarding BASEOBJECT in inc\hmgshare.h for more details.
    // Also, there is swapping code in HmgSwapLockedHandleContents (hmgrapi.cxx).
    //
    BASEOBJECT  *proB = (BASEOBJECT *)pro->prgnGet();
    BASEOBJECT obj = *proB;
    SplitOrCombinedLockAndFlags lfTmp;

    proB->hHmgr = prgn->hHmgr;
    
    lfTmp.S.c_cExclusiveLock = prgn->cExclusiveLock;
    lfTmp.S.c_BaseFlags = proB->BaseFlags;
    InterlockedExchange((LONG *) &(proB->cExclusiveLock), lfTmp.W);
    proB->Tid = prgn->Tid;

    prgn->hHmgr = obj.hHmgr;

    lfTmp.S.c_cExclusiveLock = obj.cExclusiveLock;
    lfTmp.S.c_BaseFlags = prgn->BaseFlags;
    InterlockedExchange((LONG *) &(prgn->cExclusiveLock), lfTmp.W);
    prgn->Tid = obj.Tid;

    // Swap the selection data.

    COUNT cRefsTemp = prgn->cRefs;
    prgn->cRefs = pro->prgn->cRefs;
    pro->prgn->cRefs = cRefsTemp;

    // swap the pointers in the objects

    PREGION prgnTmp = prgn;
    prgn = pro->prgnGet();
    pro->vSetRgn(prgnTmp);

    return(TRUE);
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bSwap(RGNOBJ *pro)
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bSwap",(ULONG_PTR)pro,(ULONG_PTR)pro->prgn);

    ASSERTGDI(hrgn_ != NULL,"RGNOBJAPI::bSwap - hrgn is null\n");

    //
    // dunno if this is safe without grabbing the handle lock first
    //

    //
    // This increments the lock count so that between the HmgReplace and
    // the bSwap we're guaranteed a cExclusiveLock > 0 for both objects.
    //

    INC_EXCLUSIVE_REF_CNT(pro->prgnGet());
    INC_EXCLUSIVE_REF_CNT(prgn);

    // swap the pointer in the handle
    
    PREGION prgnRet = (PREGION)HmgReplace((HOBJ) hrgn_,(POBJ) pro->prgnGet(),0,1,RGN_TYPE);

    if (prgnRet != prgn)
    {
        rl.vRet((ULONG_PTR)prgnRet);
        RIP("RGNOBJ::bSwap - swapping invalid rgn\n");

        return(FALSE);
    }

    // swap the objects

    rl.vRet(1);


    BOOL retVal = RGNOBJ::bSwap(pro);


    //
    // Decrementing the cExclusiveLock for both objects in this way ensures
    // that after the swap the Lock status is restored for _both_ objects.
    //

    DEC_EXCLUSIVE_REF_CNT(pro->prgnGet());
    DEC_EXCLUSIVE_REF_CNT(prgn);

    return retVal;
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vCopy()
*
* Copy region.  There are some fields like the object size that don't need
* copying.  This deals with them appropriately
*
* History:
*  22-Jul-1993 -by-  Eric Kutter [erick]
*       reorged region structure so don't have to deal with individual
*       fields that may not need copying.
*
*  04-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vCopy(RGNOBJ& roSrc)
{
    RGNLOG rl(prgn,"RGNOBJ::vCopy",(ULONG_PTR)roSrc.prgn);

    ASSERTGDI(prgn->sizeObj >= roSrc.prgn->sizeRgn, "sizeObj Src > sizeRgn Trg\n");

    RtlCopyMemory ((PBYTE) prgn + RGN_COPYOFFSET,
                   (PBYTE) roSrc.prgn + RGN_COPYOFFSET,
                   roSrc.prgn->sizeRgn - RGN_COPYOFFSET);

// Get the difference and add it to the pscnTail pointer.  This is faster
// than running through the list to find it.

    prgn->pscnTail = (SCAN *) ((BYTE *) prgn->pscnHead() +
                              (LONG) ((BYTE *) roSrc.prgn->pscnTail -
                                      (BYTE *) roSrc.prgn->pscnHead()));
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bCopy(roSrc)
*
* Copy region.
*
* NOTE: This is significantly different than vCopy.  This routine will
*       create a new region if the source and target are of different
*       complexities.
*
* WARNING: the prgn may change.  If this rgn is associated with a handle,
*       the handle's version will not have changed.
*
* History:
*  04-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bCopy(RGNOBJ& roSrc)
{
    RGNLOG rl(prgn,"RGNOBJ::bCopy",(ULONG_PTR)roSrc.prgn);

    if (prgn->sizeObj <= QUANTUM_REGION_SIZE)
    {
        if (roSrc.prgn->sizeObj <= QUANTUM_REGION_SIZE)
        {
            rl.vRet(1);
            vCopy(roSrc);
            return(TRUE);
        }
        else
        {
            rl.vRet(2);
            RGNMEMOBJTMP rmo(roSrc.prgn->sizeRgn);

            if (!rmo.bValid())
                return(FALSE);

            rmo.vCopy(roSrc);
            return(bSwap(&rmo));
        }
    }

    if (roSrc.prgn->sizeObj <= QUANTUM_REGION_SIZE)
    {
        rl.vRet(3);
        RGNMEMOBJTMP rmo2;

        if (!rmo2.bValid())
            return(FALSE);

        rmo2.vCopy(roSrc);
        return(bSwap(&rmo2));
    }

    if (prgn->sizeObj >= roSrc.prgn->sizeRgn)
    {
        rl.vRet(4);
        vCopy(roSrc);
        return(TRUE);
    }

    RGNMEMOBJTMP rmo3(roSrc.prgn->sizeRgn);

    rl.vRet(5);

    if (!rmo3.bValid())
        return(FALSE);

    rmo3.vCopy(roSrc);
    return(bSwap(&rmo3));
}

/******************************Member*Function*****************************\
*  bCopy
*
*  This should be used if you want any prgn change reflected in the handle.
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bCopy(RGNOBJ& roSrc)
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bCopy",(ULONG_PTR)roSrc.prgn);

    ASSERTGDI(hrgn_ != NULL,"RGNOBJAPI::bCopy\n");

    PREGION prgnOrg = prgn;

// lock the handle so no one can reference it while the pobj may be invalid

    OBJLOCK ol((HOBJ) hrgn_);

    BOOL bRes = RGNOBJ::bCopy(roSrc);

    rl.vRet(0);

    if (bRes)
    {
        rl.vRet(1);
        if (prgn != prgnOrg)
        {
            rl.vRet((ULONG_PTR)prgn);

            PVOID pv = HmgReplace((HOBJ) hrgn_,(POBJ) prgn,0,1,OBJLOCK_TYPE);
            ASSERTGDI(pv != NULL,"RGNOBJAPI::bCopy - HmgReplace failed\n");
        }
    }

    return(bRes);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bExpand(size)
*
* Expand the object to the given size
*
* History:
*  10-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bExpand(ULONGSIZE_T size)
{
    RGNLOG rl(prgn,"RGNOBJ::bExpand",size);

    ASSERTGDI(size > prgn->sizeObj, "Expanded size <= original size\n");

    RGNMEMOBJTMP rmo(size);

    rl.vRet((ULONG_PTR)rmo.prgnGet());

    if (!rmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    rmo.vCopy(*this);

    return(bSwap(&rmo));
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bInside(pptl)
*
* Is the point inside the region?
*
* Returns:
*   ERROR            0L
*   REGION_POINT_OUTSIDE    1L
*   REGION_POINT_INSIDE     2L
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bInside(PPOINTL pptl)
{
// First check if the point is in the bounding box

    if (!bBounded(pptl))
        return(REGION_POINT_OUTSIDE);

    BOOL    b = REGION_POINT_OUTSIDE;   // Assume point is outside
    PSCAN   pscn;
    COUNT   cScan;
    COUNT   cWall;
    COUNT   iWall;

    pscn = prgn->pscnHead();            // Get first scan
    cScan = prgn->cScans;               // Get scan count

    while (cScan--)
    {
        if (pscn->yTop > pptl->y)       // Have we passed the point?
            return(b);                  // Yes, exit.

        if (pscn->yBottom > pptl->y)    // Does this scan overlap the point?
        {                               // Yes, test walls/lines.

            ASSERTGDI(!(pscn->cWalls & 1), "Invalid cWalls\n");

            iWall = 0;
            cWall = pscn->cWalls;

            while (iWall != cWall)
                if (xGet(pscn, (PTRDIFF)iWall++) > pptl->x)
                    return(b);
                else
                    b ^= (REGION_POINT_INSIDE | REGION_POINT_OUTSIDE);
        }

        pscn = pscnGet(pscn);

        ASSERTGDI( pscn <=  prgn->pscnTail, "bInside:Went past end of region\n");
    }

    WARNING("********** RGNOBJ::bInside *****************\n");

    return(b);
}

/******************************Public*Routine******************************\
* RGNOBJ::bInside (prcl)                                                   *
*                                                                          *
* Does the rectangle intersect the region?                                 *
*                                                                          *
* Returns:                                                                 *
*   ERROR          0L                                               *
*   REGION_RECT_OUTSIDE   1L                                               *
*   REGION_RECT_INTERSECT 2L                                               *
*                                                                          *
* History:                                                                 *
*  Tue 12-May-1992 22:23:10 -by- Charles Whitmer [chuckwh]                 *
* Rewrote the scan search.  I want this zippy fast since I'm going to use  *
* it for pointer exclusion.                                                *
*                                                                          *
*  11-May-1991 -by- Kent Diamond [kentd]                                   *
* Rewrote.  No more support for partial intersection.                      *
*                                                                          *
*  02-Jul-1990 -by- Donald Sidoroff [donalds]                              *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RGNOBJ::bInside(PRECTL prcl)
{
// First check if the rectangle is outside the bounding box

    if ((prcl->left   >= prgn->rcl.right) ||
        (prcl->right  <= prgn->rcl.left)  ||
        (prcl->top    >= prgn->rcl.bottom) ||
        (prcl->bottom <= prgn->rcl.top))
        return(REGION_RECT_OUTSIDE);

// Skip scans above the rectangle.

    PSCAN pscn  = prgn->pscnHead();
    COUNT cScan = prgn->cScans;

    while (cScan && (prcl->top >= pscn->yBottom))
    {
        pscn = pscnGet(pscn);
        cScan--;
    }

// Examine all interesting scans.

    INDEX_LONG *pix,*pixEnd;

    while (cScan && (prcl->bottom > pscn->yTop))
    {
        pix    = pscn->ai_x;
        pixEnd = pix + 2 * pscn->cWalls;

    // Skip segments to the left.

        while ((pix < pixEnd) && (prcl->left >= pix[1].x))
            pix += 2;

    // It's this segment or nothing!

        if ((pix < pixEnd) && (prcl->right > pix[0].x))
            return(REGION_RECT_INTERSECT);

    // Move to the next scan.

        pscn = pscnGet(pscn);
        cScan--;
    }
    return(REGION_RECT_OUTSIDE);        // Did not find an intersection
}

/******************************Public*Routine******************************\
* RGNOBJ::bEqual(roSrc)
*
* Are the two regions equal?
*
* NOTE: The handle and sizeObj maybe different even though the regions
* are the same, so these are skipped.
*
* Returns:
*   TRUE if they are equal.
*   FALSE if they are not.
*
* History:
*  13-May-1991 -by- Donald Sidoroff [donalds]
* Rewrote it.
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bEqual(RGNOBJ& roSrc)
{
// In the region header, only cScans need to be similar for
// a region to equal another region
// Now run thru the scans and determine if they are the same

    ASSERT4GB((LONGLONG)((BYTE *)prgn->pscnTail - (BYTE *)prgn->pscnHead()));

    return(
        (prgn->cScans == roSrc.prgn->cScans) &&
        (!memcmp(prgn->pscnHead(), roSrc.prgn->pscnHead(),
                   (ULONG)((BYTE *)prgn->pscnTail - (BYTE *)prgn->pscnHead()))));
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bOffset(pptl)
*
* Offset the region by the point.
*
* Note:
*   Since the point is in DEVICE coords it will have to be converted to
*   FIX notation before it can be added to endpoints of trapezoid lines.
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bOffset(PPOINTL pptl)
{
    COUNT       cscn;
    COUNT       cwll;
    PSCAN       pscn;
    int         x = (int)pptl->x;
    int         y = (int)pptl->y;

// Can't fail to offset a NULL region

    if (prgn->cScans == 1)
        return(TRUE);

// First try to update the bounding box.  If we are successful here then
// all the other offsets will be successful.  This eliminates the need
// for checking for overflow/underflow on every offset operation.

    ERECTL ercl(prgn->rcl);          // Get the current bounding box
    if (ercl.bWrapped())
        return(TRUE);

    ercl.left   += x;
    ercl.bottom += y;
    ercl.right  += x;
    ercl.top    += y;

    if (!VALID_SCRRC(ercl))
    {
    // Foo, we over/under flowed.

        SAVE_ERROR_CODE(ERROR_ARITHMETIC_OVERFLOW);
        return(FALSE);
    }
    prgn->rcl = *((RECTL *)&ercl);  // Set the current bounding box

    cscn = prgn->cScans;            // Number of scans;
    pscn = prgn->pscnHead();        // First scan

    while (cscn--)
    {
        pscn->yTop += y;
        pscn->yBottom += y;

        cwll = pscn->cWalls;
        while (cwll)
            pscn->ai_x[--cwll].x += x;

        pscn = pscnGet(pscn);       // Get next scan

        ASSERTGDI(pscn <= prgn->pscnTail, "bOffset:Went past end of region\n");
    }

    pscn = pscnGot(pscn);           // Fix top ...
    pscn->yBottom = POS_INFINITY;
    pscn = prgn->pscnHead();        // ... and bottom.
    pscn->yTop = NEG_INFINITY;

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vSet()
*
* Set region to null region
*
* History:
*  05-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vSet()
{
    RGNLOG rl(prgn,"RGNOBJ::vSet");

    PREGION prgn1 = prgn;

    prgn1->sizeRgn    = NULL_REGION_SIZE;
    prgn1->cScans     = 1;
    prgn1->rcl.left   = 0;
    prgn1->rcl.top    = 0;
    prgn1->rcl.right  = 0;
    prgn1->rcl.bottom = 0;

    PSCAN pscn = prgn1->pscnHead();
    pscn->cWalls     = 0;
    pscn->yTop       = NEG_INFINITY;
    pscn->yBottom    = POS_INFINITY;
    pscn->ai_x[0].x  = 0;                    // This sets cWalls2

    prgn1->pscnTail   = pscnGet(pscn);
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vSet()
*
* Set region from list of rectangles
*
* History:
*   7-18-2000 bhouse Wrote it
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bSet(ULONG cRect, RECTL * prcl)
{
    RGNMEMOBJTMP rmoTmp1, rmoTmp2;

    if (!rmoTmp1.bValid() || !rmoTmp2.bValid())
    {
        return(FALSE);
    }

    // NOTE: the iCombine call below is O(n*n) so
    // we want to only call it with small n.  We use
    // merge sort which is O(n*log n) to handle larger n.
    //
    // The limit of 20 was picked as a reasonable number which
    // balances the cost of the RGNMEMOBJ creation
    // with the cost of the n squared algorithm.
    //

    if(cRect < 20)
    {
        BOOL bDoneFirst=FALSE;
        
        for (ULONG i=0; i < cRect; i++, prcl++)
        {      
            // ignore bad rectangles
            if (!((prcl->left>=prcl->right)     || 
                  (prcl->top>=prcl->bottom)     ||
                  (prcl->left<MIN_REGION_COORD) ||
                  (prcl->right>MAX_REGION_COORD)||
                  (prcl->top<MIN_REGION_COORD)  ||
                  (prcl->bottom>MAX_REGION_COORD)))
            {
                if(!bDoneFirst) 
                {
                    // Do the first rectangle
                    vSet(prcl);
                    bDoneFirst=TRUE;
                }
                else 
                {
                    // Now get the rest of the rectangles, one by one
                    rmoTmp1.vSet(prcl);
                    rmoTmp2.iCombine(*this, rmoTmp1, RGN_OR); // put result of merge into rmoTmp2
                    bSwap(&rmoTmp2); // now move into rmo
                }
            }
        }
    }
    else
    {
        RGNMEMOBJTMP rmoTmp3;
        
        ULONG   cTmp1 = cRect >> 1;
        ULONG   cTmp2 = cRect - cTmp1;

        if(!rmoTmp1.bSet(cTmp1, prcl) || !rmoTmp2.bSet(cTmp2, prcl+cTmp1))
        {
            return FALSE;
        }

        rmoTmp3.iCombine(rmoTmp2, rmoTmp1, RGN_OR);
        bSwap(&rmoTmp3);

    }
    return TRUE;
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vSet(prcl)
*
* Set region to single rect
*
* History:
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vSet(PRECTL prcl)
{
    RGNLOG rl(prgn,"RGNOBJ::vSet prcl");

    PSCAN   pscn;

    if ((prcl->left == prcl->right) || (prcl->top == prcl->bottom))
    {
        vSet();
        return;
    }

// If the region is already a RECT region, this can be much faster

    PREGION prgn1 = prgn;

    prgn1->rcl = *prcl;

    if (prgn1->sizeRgn == SINGLE_REGION_SIZE)
    {
        rl.vRet(0);

        ASSERTGDI(prgn1->cScans == 3,"RGNOBJ::vSet - cScans != 3\n");

    // scan 0

        pscn = prgn1->pscnHead();
        ASSERTGDI(pscn->yTop == NEG_INFINITY,"RGNOBJ::vSet - yTop0\n");

        pscn->yBottom = prcl->top;

    // scan 1

        pscn = pscnGet(pscn);
        ASSERTGDI(pscn->cWalls == 2,"RGNOBJ::vSet - cWalls1 != 2\n");

        pscn->yTop = prcl->top;
        pscn->yBottom = prcl->bottom;
        pscn->ai_x[0].x = prcl->left;
        pscn->ai_x[1].x = prcl->right;

    // scan 2

        pscn = pscnGet(pscn);
        ASSERTGDI(pscn->cWalls == 0,"RGNOBJ::vSet - cWalls2 != 0\n");
        ASSERTGDI(pscn->yBottom == POS_INFINITY,"RGNOBJ::vSet - yBottom2\n");

        pscn->yTop = prcl->bottom;

    // tail

        prgn1->pscnTail = pscnGet(pscn);
    }
    else
    {
        rl.vRet(0);

        prgn1->sizeRgn = SINGLE_REGION_SIZE;
        prgn1->cScans = 3;

        pscn = prgn1->pscnHead();
        pscn->cWalls = 0;
        pscn->yTop = NEG_INFINITY;
        pscn->yBottom = prcl->top;
        pscn->ai_x[0].x = 0;                    // This sets cWalls2

        pscn = pscnGet(pscn);
        pscn->cWalls = 2;
        pscn->yTop = prcl->top;
        pscn->yBottom = prcl->bottom;
        pscn->ai_x[0].x = prcl->left;
        pscn->ai_x[1].x = prcl->right;
        pscn->ai_x[2].x = 2;                    // This sets cWalls2

        pscn = pscnGet(pscn);
        pscn->cWalls = 0;
        pscn->yTop = prcl->bottom;
        pscn->yBottom = POS_INFINITY;
        pscn->ai_x[0].x = 0;                    // This sets cWalls2

        prgn1->pscnTail = pscnGet(pscn);
    }
    VALIDATE(*(RGNOBJ *)this);
}

/******************************Public*Routine******************************\
* VOID SCAN::vMerge(pscnSrcA, pscnSrcB, fj)
*
* Merge the scans.
*
* The algorithm takes advantage of the pre-sorted nature of the source
* scans.  We define the 'events' to be the merged sorted list of X values
* from both A and B.  The 'op' is referenced to determine if the event
* is worth recording in the destination.
*
* There are a few tricks used in this routine.  The first is the way that
* the state is recorded.  There are four states possible, since
* we can either be IN or OUT of A or B.  These states are:
*
*  0001b    OUT A, OUT B
*  0010b    OUT A, IN  B
*  0100b    IN  A, OUT B
*  1000b    IN  A, IN  B
*
* From this we can see A is equal to 1100 (IN_A_OUT_B | IN_A_IN_B) and
* that B is equal to 1010 (OUT_A_IN_B | IN_A_IN_B).
*
* We use a state table to find the next state.  The index into the table
* is the current state and the value we get out the new state.
*
* We always begin with an initial state OUT A, OUT B.  We then take the
* lowest X value from either A or B.  We then map through the table of
* which ever scan we pulled an X value from and so the state always
* indicates whether we are in (entering) or out (leaving) of either scan.
*
* The second trick is in the similar way that the logical operation
* to be used for the merge is encoded in the 'op'.  This is done as a
* simple logical truth table that can be tested against the state to
* see if we are IN or OUT of the result.  The frequently used ops are:
*
*  1110     OR
*  1000     AND
*  0110     XOR
*  0100     DIFF
*
* These ops are seen to be the OR of the appropriate state definitions
* needed for the boolean operation.  For example the op for 'A OR B' is
* derived from (1100 | 1010).
*
* In fact, any op whose lower bit is 0 is allowed.  This gives eight
* possible operations.
*
* The final trick we use to determine when an event worthy of recording
* has occured.  When we are not in a destination rectangle, we just
* test the new state against the op to see if we've just changed to IN.
* If so, we invert the op.  Now we only need to test the state against
* this inverted op to determine when we pop OUT again!  So whenever we
* record a point we invert the op.
*
* History:
*  11-Nov-1992 -by- Donald Sidoroff [donalds]
* Merged into RGNOBJ::bMerge for speed.
*
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

#define MERGE_OUT_OUT       0x01
#define MERGE_OUT_IN        0x02
#define MERGE_IN_OUT        0x04
#define MERGE_IN_IN         0x08
#define MERGE_INITIAL_STATE MERGE_OUT_OUT

static  FCHAR   afjA[16] =
{
    0x00,               //
    MERGE_IN_OUT,       //  OUT OUT ->  IN  OUT
    MERGE_IN_IN,        //  OUT IN  ->  IN  IN
    0x00,               //
    MERGE_OUT_OUT,      //  IN  OUT ->  OUT OUT
    0x00,               //
    0x00,               //
    0x00,               //
    MERGE_OUT_IN        //  IN  IN  ->  OUT IN
};

static  FCHAR   afjB[16] =
{
    0x00,               //
    MERGE_OUT_IN,       //  OUT OUT ->  OUT IN
    MERGE_OUT_OUT,      //  OUT IN  ->  OUT OUT
    0x00,               //
    MERGE_IN_IN,        //  IN  OUT ->  IN  IN
    0x00,               //
    0x00,               //
    0x00,               //
    MERGE_IN_OUT        //  IN  IN  ->  IN  OUT
};

static  FCHAR   afjAB[16] =
{
    0x00,               //
    MERGE_IN_IN,        //  OUT OUT ->  IN  IN
    MERGE_IN_OUT,       //  OUT IN  ->  IN  OUT
    0x00,               //
    MERGE_OUT_IN,       //  IN  OUT ->  OUT IN
    0x00,               //
    0x00,               //
    0x00,               //
    MERGE_OUT_OUT       //  IN  IN  ->  OUT OUT
};

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bMerge(proSrc1, proSrc2, fjOp)
*
* Merge two regions together.
*
* WARNING: If this function returns FALSE, the region may be inconsistent.
*          The caller must discard or reset the region. (See bug #343770)
*
* History:
*  11-Nov-1992 -by- Donald Sidoroff [donalds]
* Merged SCAN::vMerge into code for speed up.  More aggressive memory
* usage scheme and other optimizations.
*
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bMerge(RGNOBJ& roSrc1,
                     RGNOBJ& roSrc2,
                     FCHAR   fjOp)
{
    RGNLOG rl(prgn,"RGNOBJ::bMerge",(ULONG_PTR)roSrc1.prgn,(ULONG_PTR)roSrc2.prgn,(ULONG_PTR)fjOp);

    SCAN   *pscnSrc1 = roSrc1.prgn->pscnHead();
    SCAN   *pscnSrc2 = roSrc2.prgn->pscnHead();
    SCAN   *pscnOld = (SCAN *) NULL;
    SCAN   *pscnTrg;
    LONG    yTop;
    LONG    yBottom;
    ULONG   size;

// Set target region to be TOTALLY empty, yet valid.

    prgn->pscnTail = prgn->pscnHead();
    prgn->sizeRgn  = NULL_REGION_SIZE - NULL_SCAN_SIZE;
    prgn->cScans   = 0;

// Ensure the bounding box gets updated later on.

    prgn->rcl.left   = POS_INFINITY;
    prgn->rcl.top    = POS_INFINITY;
    prgn->rcl.right  = NEG_INFINITY;
    prgn->rcl.bottom = NEG_INFINITY;

// Merge the source scans into the target

    for(;;)
    {
        pscnTrg = prgn->pscnTail;

    // Check for nearly full region

        size = (pscnSrc1->cWalls + pscnSrc2->cWalls) * sizeof(INDEX_LONG) +
               NULL_SCAN_SIZE;

        if (size > prgn->sizeObj - prgn->sizeRgn)
        {
        // OK, we need to realloc this region.  Lets be fairly aggressive
        // on the allocate to cut down on realloc's

            if (!bExpand(prgn->sizeRgn * 2 + (ULONGSIZE_T)size))
                return(FALSE);

            pscnTrg = prgn->pscnTail;       // Get the updated object's tail.

            if (pscnOld)                    // If we had an old scan
                pscnOld = pscnGot(pscnTrg); // Get the updated old scan.
        }

        yTop = MAX(pscnSrc1->yTop, pscnSrc2->yTop);
        yBottom = MIN(pscnSrc1->yBottom, pscnSrc2->yBottom);

        ASSERTGDI(yBottom > yTop, "Bottom <= Top\n");

    // Merge the current scans

        pscnTrg->yBottom = yBottom;
        pscnTrg->yTop    = yTop;

        {
        register INDEX_LONG *plTrg   = &pscnTrg->ai_x[0];
        register INDEX_LONG *plSrc1  = &pscnSrc1->ai_x[0];
        register INDEX_LONG *plSrc2  = &pscnSrc2->ai_x[0];
                 COUNT cSrc1   = pscnSrc1->cWalls;
                 COUNT cSrc2   = pscnSrc2->cWalls;
                 LONG  xEvent;
                 FCHAR fjState = MERGE_INITIAL_STATE;
                 FCHAR fjOpTmp = fjOp;

            pscnTrg->cWalls = 0;                // Init the wall count to zero


            // Continue to loop as long as either cSrc1 or cSrc2 (or both) are non-zero.
            // We terminate the loop via a break statement because this causes the compiler
            // to generate more efficient code (fewer branches).  I believe this is a key loop
            // that is worth optimizing at a minor cost to readability.

            while (1)
            {
                if (cSrc1)
                {
                    if (cSrc2)
                    {
                        // Both cSrc1 and cSrc2 are non-zero, so the next xEvent
                        // will come from whichever is smaller: *plSrc1 or *plSrc2

                        if (plSrc1->x < plSrc2->x)
                        {
                            xEvent = plSrc1->x, plSrc1++, cSrc1--, fjState = afjA[fjState];
                        }
                        else if (plSrc1->x > plSrc2->x)
                        {
                            xEvent = plSrc2->x, plSrc2++, cSrc2--, fjState = afjB[fjState];
                        }
                        else
                        {
                            // *plSrc1 and *plSrc2 are equal so advance both pointers

                            xEvent = plSrc1->x, plSrc1++, cSrc1--, plSrc2++, cSrc2--, fjState = afjAB[fjState];
                        }
                    }
                    else
                    {
                        // cSrc1 is non-zero, but cSrc2 is zero:  the next xEvent is
                        // at *plSrc1

                        xEvent=plSrc1->x, plSrc1++, cSrc1--, fjState = afjA[fjState];
                    }
                }
                else
                {
                    if (cSrc2)
                    {

                        // cSrc1 is zero and cSrc2 is non-zero:  the next xEvent is
                        // at *plSrc2

                        xEvent = plSrc2->x, plSrc2++, cSrc2--, fjState = afjB[fjState];

                    }
                    else
                    {
                        // both cSrc1 and cSrc2 are zero.  We are done with the loop.

                        break;
                    }

                }
                // We now have the next event and a new state

                if (fjOpTmp & fjState)
                    pscnTrg->cWalls++, plTrg->x = xEvent, plTrg++, fjOpTmp ^= 0x0f;
            }

            pscnTrg->ai_x[pscnTrg->cWalls].x = pscnTrg->cWalls;
        }

        ASSERTGDI(!(pscnTrg->cWalls & 1), "Odd cWalls\n");

    // Try to coalesce the current scan with the previous scan

        if (pscnOld != (SCAN *) NULL)
        {
        // If the wall counts are the same, compare the walls

            if (pscnOld->cWalls == pscnTrg->cWalls)
                if (!memcmp(&pscnOld->ai_x[0], &pscnTrg->ai_x[0], (UINT)pscnOld->cWalls * sizeof(INDEX_LONG)))
                {
                    pscnOld->yBottom = pscnTrg->yBottom;
                    pscnTrg = pscnOld;
                }
        }

    // If the scans didn't coalesce, update size and count information

        if (pscnOld != pscnTrg)
        {
            prgn->pscnTail = pscnGet(pscnTrg);
            prgn->sizeRgn += pscnTrg->sizeGet();
            prgn->cScans++;
        }

    // We might be done

        if (pscnTrg->yBottom == POS_INFINITY)
        {
            ASSERTGDI((prgn->sizeRgn <= prgn->sizeObj),"bMerge: sizeRgn > sizeObj\n");
            ASSERTGDI(prgn->sizeRgn == (SIZE_T)((BYTE *)prgn->pscnTail - (BYTE *)prgn),
                      "bMerge:sizeRgn != size of region\n");

            return(TRUE);
        }

    // Maybe update the bounding rectangle

        if (pscnTrg->cWalls)
        {
            if (pscnTrg->ai_x[0].x < prgn->rcl.left)
                prgn->rcl.left = pscnTrg->ai_x[0].x;

            if (pscnTrg->yTop < prgn->rcl.top)
                prgn->rcl.top = pscnTrg->yTop;

            if (pscnTrg->ai_x[pscnTrg->cWalls - 1].x > prgn->rcl.right)
                prgn->rcl.right = pscnTrg->ai_x[pscnTrg->cWalls - 1].x;

            if (pscnTrg->yBottom > prgn->rcl.bottom)
                prgn->rcl.bottom = pscnTrg->yBottom;
        }

    // Decide which source pointers need to be advanced

        if (yBottom == pscnSrc1->yBottom)
            pscnSrc1 = pscnGet(pscnSrc1);

        if (yBottom == pscnSrc2->yBottom)
            pscnSrc2 = pscnGet(pscnSrc2);

    // Set the pscnOld to the current scan

        pscnOld = pscnTrg;
    }
}

/******************************Public*Routine******************************\
* LONG RGNOBJ::iCombine(proSrc1, proSrc2, iMode)
*
* Combine the two regions by the mode and update the objects region.
* Return the complexity of the resulting region.
*
* History:
*  09-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

FCHAR gafjRgnOp[] =
{
    0x00,                   //
    0x08,                   // RGN_AND
    0x0e,                   // RGN_OR
    0x06,                   // RGN_XOR
    0x04,                   // RGN_DIFF
};

LONG RGNOBJ::iCombine(RGNOBJ& roSrc1,
                      RGNOBJ& roSrc2,
                      LONG    iMode)
{
    RGNLOG rl(prgn,"RGNOBJ::iCombine",(ULONG_PTR)roSrc1.prgn,(ULONG_PTR)roSrc2.prgn,iMode);

// The target region MUST NOT be either of the source regions

    ASSERTGDI(prgn != roSrc1.prgn, "Trg == Src1\n");
    ASSERTGDI(prgn != roSrc2.prgn, "Trg == Src2\n");

// if this is the global empty one, we don't want to mess with it.

    if (prgn == prgnDefault)
        return(iComplexity());

// Check for the special case of merging one big single region with others.

    if ((iMode == RGN_AND)||(iMode == RGN_OR))
    {

        if (roSrc1.bRectl())
        {
            // if roSrc2.prgn's bounding box is smaller or equal

            if (roSrc1.bContain(roSrc2))
            {
                // The result will be identical to one region
                if (!bCopy((iMode == RGN_AND) ? roSrc2 : roSrc1))
                {
                    WARNING("Unable to copy region!!");
                    vSet();
                    return(ERROR);
                }
                rl.vRet((ULONG_PTR)prgn);
                return(iComplexity());
            }
        }

        if (roSrc2.bRectl())
        {

            // if roSrc1.prgn's bounding box is smaller or equal

            if (roSrc2.bContain(roSrc1))
            {
                // The result will be identical to one region
                if (!bCopy((iMode == RGN_AND) ? roSrc1 : roSrc2))
                {
                    WARNING("Unable to copy region!!");
                    vSet();
                    rl.vRet((ULONG_PTR)prgn);
                    return(ERROR);
                }
                    rl.vRet((ULONG_PTR)prgn);
                return(iComplexity());
            }
        }
    }

// Check for the special case of ANDing two single regions together.

    if ((iMode == RGN_AND)                     &&
        (roSrc1.prgn->sizeRgn == SINGLE_REGION_SIZE)  &&
        (roSrc2.prgn->sizeRgn == SINGLE_REGION_SIZE))
    {
    // Cool, all we have to do is AND the bounding boxes and we're done.

        RECTL   rclSrc1;
        RECTL   rclSrc2;
        RECTL   rclTrg;

        rclSrc1 = roSrc1.prgn->rcl;
        rclSrc2 = roSrc2.prgn->rcl;

        rclTrg.left    = MAX(rclSrc1.left,   rclSrc2.left);
        rclTrg.right   = MIN(rclSrc1.right,  rclSrc2.right);
        rclTrg.top     = MAX(rclSrc1.top,    rclSrc2.top);
        rclTrg.bottom  = MIN(rclSrc1.bottom, rclSrc2.bottom);

    // Was the resulting region NULL?

        if ((rclTrg.left >= rclTrg.right) ||
            (rclTrg.top  >= rclTrg.bottom))
            vSet();                     // Make target NULL;
        else
            vSet(&rclTrg);              // Make target a rect

        rl.vRet((ULONG_PTR)prgn);
        return(SIMPLEREGION);          // Since we know what we get
    }

// Do the general cases.

    if (!bMerge(roSrc1, roSrc2, gafjRgnOp[iMode]))
    {
        vSet();
        rl.vRet((ULONG_PTR)prgn);
        return(ERROR);
    }
    rl.vRet((ULONG_PTR)prgn);
    return(iComplexity());
}

/******************************Member*Function*****************************\
*
* History:
*  22-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

LONG RGNOBJAPI::iCombine(
    RGNOBJ& roSrc1,
    RGNOBJ& roSrc2,
    LONG    iMode)
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::iCombine",(ULONG_PTR)roSrc1.prgn,(ULONG_PTR)roSrc2.prgn,iMode);

    PREGION prgnOrg = prgn;

// lock the handle so no one can reference it while the pobj may be invalid

    OBJLOCK ol((HOBJ) hrgn_);

    LONG iRet = RGNOBJ::iCombine(roSrc1,roSrc2,iMode);

    if (prgn != prgnOrg)
    {
        rl.vRet((ULONG_PTR)prgn);

        PVOID pv = HmgReplace((HOBJ) hrgn_,(POBJ) prgn,0,1,OBJLOCK_TYPE);
        ASSERTGDI(pv != NULL,"RGNOBJAPI::iCombine - HmgReplace failed\n");
    }
    return(iRet);
}

/******************************Member*Function*****************************\
* RGNOBJ::iReduce()
*
*   copy the roSrc into this reducing the size of the region if possible.
*
* History:
*  13-Aug-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

LONG RGNMEMOBJ::iReduce(RGNOBJ& roSrc)
{
    RGNLOG rl(prgn,"RGNMEMOBJ::iReduce",(ULONG_PTR)roSrc.prgn);

    RGNMEMOBJTMP rmoBigRect;
    RECTL rcl;

    rcl.left   = MIN_REGION_COORD;
    rcl.right  = MAX_REGION_COORD;
    rcl.top    = MIN_REGION_COORD;
    rcl.bottom = MAX_REGION_COORD;

    rmoBigRect.vSet(&rcl);

// Set the bounding box to be maximally crossed (left > right, top > bottom)

    prgn->rcl.left   = POS_INFINITY;
    prgn->rcl.top    = POS_INFINITY;
    prgn->rcl.right  = NEG_INFINITY;
    prgn->rcl.bottom = NEG_INFINITY;

    if (!bMerge(rmoBigRect, roSrc, gafjRgnOp[RGN_AND]))
    {
        vSet();
        rl.vRet((ULONG_PTR)prgn);
        return(ERROR);
    }

    rl.vRet((ULONG_PTR)prgn);
    return(iComplexity());
}

/******************************Public*Routine******************************\
* SIZE_T RGNOBJ::sizeSave()
*
* Compute the size of the save data for this region
*
* History:
*  26-Oct-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

ULONGSIZE_T RGNOBJ::sizeSave()
{
    COUNT   cscn = prgn->cScans;
    PSCAN   pscn = prgn->pscnHead();
    COUNT   crcl = 0;

// The number of rectangles per scan is:
//
// For RECT regions --  (# of walls / 2)
// For TRAP regions --  (# of walls / 2) * (height of scan)

    while (cscn--)
    {
        crcl += (pscn->cWalls / 2);
        pscn = pscnGet(pscn);

        ASSERTGDI(pscn <= prgn->pscnTail, "sizeSave:Went past end of region\n");
    }

    return(crcl * sizeof(RECTL));
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vDownload(pv)
*
* Download the region to the buffer
*
* History:
*  26-Oct-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vDownload(PVOID pv)
{
    PRECTL  prcl = (PRECTL) pv;
    PSCAN   pscn = prgn->pscnHead();
    COUNT   cscn = prgn->cScans;
    RECTL   rclTmp;
    LONG    lPrevBottom = NEG_INFINITY;
    LONG    lPrevRight;

    while (cscn--)
    {
#if DBG
        if (pscn->yTop < lPrevBottom)
            DbgPrint("top < prev bottom, scan %ld, pscn @ 0x%lx\n",
                     prgn->cScans - cscn, (BYTE *)pscn - (BYTE *)prgn->pscnHead());

        if (pscn->yTop > pscn->yBottom)
            DbgPrint("top > bottom, scan %ld, pscn @ 0x%lx\n",
                     prgn->cScans - cscn, (BYTE *)pscn - (BYTE *)prgn->pscnHead());
#endif

        lPrevBottom = pscn->yBottom;


        rclTmp.top    = pscn->yTop;
        rclTmp.bottom = pscn->yBottom;

        COUNT iWall = 0;

        lPrevRight = NEG_INFINITY;

        while (iWall < pscn->cWalls)
        {
            rclTmp.left  = xGet(pscn, (PTRDIFF) iWall);
            rclTmp.right = xGet(pscn, (PTRDIFF) iWall + 1);

#if DBG
            if ((rclTmp.left <= lPrevRight) || (rclTmp.right <= rclTmp.left))
                DbgPrint("left[i] < left[i+1], pscn @ 0x%lx, iWall = 0x%lx\n",
                         (BYTE *)pscn - (BYTE *)prgn->pscnHead(),iWall);
#endif

            lPrevRight = rclTmp.right;

            *prcl++ = rclTmp;
            iWall += 2;
        }

#if DBG
        if (pscn->cWalls != (COUNT)xGet(pscn,(PTRDIFF)iWall))
            DbgPrint("cWalls != cWalls2 @ 0x%lx\n",
                         (BYTE *)pscn - (BYTE *)prgn->pscnHead());
#endif

        pscn = pscnGet(pscn);

#if DBG
        if (pscn > prgn->pscnTail)
        {
            DbgPrint("vDownload1:Went past end of region\n");
            return;
        }
#endif
    }

    return;
}

/******************************Public*Routine******************************\
* VOID RGNOBJ::vComputeUncoveredSpriteRegion(po)
*
* Upload the region describing the parts of the screen not covered by
* sprites.  Derived from 'bupload'.
*
* History:
*  28-Nov-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vComputeUncoveredSpriteRegion(PDEVOBJ& po)
{
    SPRITESTATE*    pState = po.pSpriteState();
    PSCAN           pscn   = prgn->pscnHead();
    LONG            yTop;
    LONG            yBottom;
    ULONG           cScans;
    ULONG           cWalls;
    RECTL           rcl;

    // First, reset to an empty region:

    vSet();

    // Find the first non-covered range:

    ENUMUNCOVERED Enum(pState);
    if (!Enum.bEnum(&rcl))
        return;                 // Empty region

    cScans = prgn->cScans;

    // Setup variables for first scan:

    yTop = NEG_INFINITY;
    yBottom = rcl.top;
    cWalls = 0;

    do {
        if (rcl.top != yTop)
        {
            cScans++;

            // Close off current scan:

            pscn->yTop = yTop;
            pscn->yBottom = yBottom;
            pscn->cWalls = cWalls;
            pscn->ai_x[cWalls].x = cWalls;

            // Add a null scan if the top of the new rectangle and
            //  the bottom of the old don't overlap:

            if (rcl.top != yBottom)
            {
                cScans++;
                pscn = pscnGet(pscn);
                pscn->yTop = yBottom;
                pscn->yBottom = rcl.top;
                pscn->cWalls = 0;
                pscn->ai_x[0].x = 0;
            }

            // Advance to the next scan:

            pscn = pscnGet(pscn);

            // Open up current scan:

            yTop = rcl.top;
            yBottom = rcl.bottom;
            cWalls = 0;
        }

        pscn->ai_x[cWalls].x = rcl.left;
        pscn->ai_x[cWalls + 1].x = rcl.right;
        cWalls += 2;

    } while (Enum.bEnum(&rcl));

    // Close off current scan:

    pscn->yTop = yTop;
    pscn->yBottom = yBottom;
    pscn->cWalls = cWalls;
    pscn->ai_x[cWalls].x = cWalls;

    // Build final scan:

    cScans++;
    pscn = pscnGet(pscn);
    pscn->cWalls = 0;
    pscn->yTop = yBottom;
    pscn->yBottom = POS_INFINITY;
    pscn->ai_x[0].x = 0;

    prgn->pscnTail = pscnGet(pscn);
    prgn->cScans = cScans;
    prgn->sizeRgn = NULL_REGION_SIZE - NULL_SCAN_SIZE;
    prgn->sizeRgn += (ULONGSIZE_T) (((BYTE *) prgn->pscnTail - (BYTE *) prgn->pscnHead()));
}

/******************************Public*Routine******************************\
*
* History:
*  24-Sep-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

RGNMEMOBJ::RGNMEMOBJ()
{
    vInitialize(QUANTUM_REGION_SIZE);
}

/******************************Public*Routine******************************\
* RGNMEMOBJ::RGNMEMOBJ(size)
*
*  Create a new region object
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

RGNMEMOBJ::RGNMEMOBJ(ULONGSIZE_T size)
{
    vInitialize(size);
}

/******************************Public*Routine******************************\
* RGNMEMOBJ::vInitialize(size)
*
*  Create a new region object
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID
RGNMEMOBJ::vInitialize(ULONGSIZE_T size)
{
    RGNLOG rl((PREGION)0,"RGNMEMOBJ::vInitialize(sz)",(ULONG_PTR)size);

// don't bother with anything smaller than a QUANTUM_REGION_SIZE

    if (size <  QUANTUM_REGION_SIZE)
        size = QUANTUM_REGION_SIZE;

// Got to allocate a new one.

    prgn = (PREGION)ALLOCOBJ(size,RGN_TYPE,FALSE);

    rl.vRet((ULONG_PTR)prgn);

    if (prgn)
    {
        vInit(size);
    }
}

/******************************Public*Routine******************************\
* RGNMEMOBJ::RGNMEMOBJ(bInit)
*
*  Create a new region object
*
* History:
*  02-Jul-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

RGNMEMOBJ::RGNMEMOBJ(BOOL bInit)
{
    RGNLOG rl((PREGION)0,"RGNMEMOBJ::RGNMEMOBJ(b)",(ULONG_PTR)bInit);

    ASSERTGDI(bInit == FALSE,"RGNMEMOBJ::RGNMEMOBJ - bInit == TRUE\n");

    prgn = (PREGION)ALLOCOBJ(QUANTUM_REGION_SIZE,RGN_TYPE,FALSE);

    rl.vRet((ULONG_PTR)prgn);

    if (prgn)
    {
        prgn->sizeObj = QUANTUM_REGION_SIZE;
        prgn->sizeRgn = 0;
        prgn->cRefs   = 0;
    prgn->iUnique = 0;
    }
}

/******************************Public*Function*****************************\
* AddEdgeToGET
*
*  Adds the edge described by the two passed-in points to the Global Edge
*  Table, if the edge spans at least one pixel vertically.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/


PEDGE AddEdgeToGET(EDGE *pGETHead, EDGE *pFreeEdge,
        POINTFIX *ppfxEdgeStart, POINTFIX *ppfxEdgeEnd, RECTL *pBound)
{
    LONG lyStart, lyEnd, lxStart, lxEnd, lyHeight, lxWidth,lyStartSave;
    BOOL bTopClip;

// Set the winding-rule direction of the edge, and put the endpoints in
// top-to-bottom order

    lyHeight = ppfxEdgeEnd->y - ppfxEdgeStart->y;
    if (lyHeight >= 0)
    {
        lxStart = ppfxEdgeStart->x;
        lyStart = ppfxEdgeStart->y;
        lxEnd = ppfxEdgeEnd->x;
        lyEnd = ppfxEdgeEnd->y;
        pFreeEdge->lWindingDirection = 1;
    }
    else
    {
        lyHeight = -lyHeight;
        lxEnd = ppfxEdgeStart->x;
        lyEnd = ppfxEdgeStart->y;
        lxStart = ppfxEdgeEnd->x;
        lyStart = ppfxEdgeEnd->y;
        pFreeEdge->lWindingDirection = -1;
    }

    bTopClip = FALSE;

    if( pBound != NULL )
    {
        if( ( lyEnd < pBound->top ) || ( lyStart > pBound->bottom ) )
        {
        // completely above or below the bound rectangle so skip this segment

            return(pFreeEdge);
        }

        if( lyStart < pBound->top )
        {
        // starts above the rect so clip to the top of the rect

            bTopClip = TRUE;
            lyStartSave = lyStart;
            lyStart = pBound->top;
        }

        if( lyEnd > pBound->bottom )
        {
        // ends below the rect so clip to the bottom of the rect

            lyEnd = pBound->bottom;
        }

    }

// First pixel scan line (non-fractional GIQ Y coordinate) edge intersects.
// Dividing by 16 with a shift is okay because Y is always positive

    pFreeEdge->Y = (lyStart + 15) >> 4;

// Calculate the number of pixels spanned by this edge

    pFreeEdge->lScansLeft = ((lyEnd + 15) >> 4) - pFreeEdge->Y;

    if (pFreeEdge->lScansLeft <= 0)
        return(pFreeEdge);  // no pixels at all are spanned, so we can ignore
                            //  this edge

// Set the error term and adjustment factors, all in GIQ coordinates for new.

    lxWidth = lxEnd - lxStart;
    if (lxWidth >= 0)
    {
    // Left to right, so we change X as soon as we move at all.

        pFreeEdge->lXDirection = 1;
        pFreeEdge->lErrorTerm = -1;
    }
    else
    {
    // Right to left, so we don't change X until we've moved a full GIQ
    // coordinate.

        lxWidth = -lxWidth;
        pFreeEdge->lXDirection = -1;
        pFreeEdge->lErrorTerm = -lyHeight;
    }

    if (lxWidth >= lyHeight)
    {
    // Calculate base run length (minimum distance advanced in X for a 1-
    // scan advance in Y)

        pFreeEdge->lXWhole = lxWidth / lyHeight;

    // Add sign back into base run length if going right to left

        if (pFreeEdge->lXDirection == -1)
            pFreeEdge->lXWhole = -pFreeEdge->lXWhole;

        pFreeEdge->lErrorAdjustUp = lxWidth % lyHeight;
    }
    else
    {
    // Base run length is 0, because line is closer to vertical than
    // horizontal.

        pFreeEdge->lXWhole = 0;
        pFreeEdge->lErrorAdjustUp = lxWidth;
    }
    pFreeEdge->lErrorAdjustDown = lyHeight;

// If the edge doesn't start on a pixel scan (that is, it starts at a
// fractional GIQ coordinate), advance it to the first pixel scan it
// intersects or to the top of the clip rectangle if we are top clipped

    LONG lyAdjust;

    if( bTopClip )
    {
        lyAdjust = pBound->top;
        lyStart = lyStartSave;
    }
    else
    {
        lyAdjust = ( lyStart + 15 ) & ~15;
    }

    while( lyStart != lyAdjust )
    {
    // Starts at a fractional GIQ coordinate, not exactly on a pixel scan
    // Advance the edge's GIQ X coordinate for a 1-GIQ-pixel Y advance
    // Advance by the minimum amount

        lxStart += pFreeEdge->lXWhole;

    // Advance the error term and see if we got one extra pixel this time.

        pFreeEdge->lErrorTerm += pFreeEdge->lErrorAdjustUp;
        if (pFreeEdge->lErrorTerm >= 0)
        {
        // The error term turned over, so adjust the error term and
        // advance the extra pixel.

            pFreeEdge->lErrorTerm -= pFreeEdge->lErrorAdjustDown;
            lxStart += pFreeEdge->lXDirection;
        }
        lyStart++;  // advance to the next GIQ Y coordinate
    }

// Turn the calculations into pixel rather than GIQ calculations

// Move the X coordinate to the nearest pixel, and adjust the error term
// accordingly
// Dividing by 16 with a shift is okay because X is always positive

    pFreeEdge->X = (lxStart + 15) >> 4; // convert from GIQ to pixel coordinates

    if (pFreeEdge->lXDirection == 1)
    {
    // Left to right

        pFreeEdge->lErrorTerm -= pFreeEdge->lErrorAdjustDown *
                (((lxStart + 15) & ~0x0F) - lxStart);
    }
    else
    {
    // Right to left

        pFreeEdge->lErrorTerm -= pFreeEdge->lErrorAdjustDown *
                ((lxStart - 1) & 0x0F);
    }

// Scale the error adjusts up by 16 times, to move 16 GIQ pixels at a time.
// Shifts work to do the multiplying because these values are always
// non-negative

    pFreeEdge->lErrorAdjustUp <<= 4;
    pFreeEdge->lErrorAdjustDown <<= 4;

// Insert the edge into the GET in YX-sorted order. The search always ends
// because the GET has a sentinel with a greater-than-possible Y value

    while ((pFreeEdge->Y > ((EDGE *)pGETHead->pNext)->Y) ||
            ((pFreeEdge->Y == ((EDGE *)pGETHead->pNext)->Y) &&
            (pFreeEdge->X > ((EDGE *)pGETHead->pNext)->X)))
    {
        pGETHead = pGETHead->pNext;
    }

    pFreeEdge->pNext = pGETHead->pNext; // link the edge into the GET
    pGETHead->pNext = pFreeEdge;

    return(++pFreeEdge);    // point to the next edge storage location for next
                            //  time
}

/******************************Public*Function*****************************\
* vConstructGET
*
*  Build the Global Edge Table from the path.  The GET is constructed in
*  Y-X order, and has a head/tail/sentinel node at pGETHead.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/

VOID vConstructGET(EPATHOBJ& po, EDGE *pGETHead, EDGE *pFreeEdges,RECTL *pBound)
{
// Create an empty GET with the head node also a tail sentinel

    pGETHead->pNext = pGETHead; // mark that the GET is empty
    pGETHead->Y = 0x7FFFFFFF;   // this is greater than any valid Y value, so
                                //  searches will always terminate

    PPATH ppath = po.ppath;

    PPOINTFIX pptfxStart, pptfxEnd, pptfx;
    PPOINTFIX pptfxPrev = NULL;

    for (PATHRECORD *ppr = ppath->pprfirst;
         ppr != (PPATHREC) NULL;
         ppr = ppr->pprnext)
    {
    // If first point starts a subpath, remember it as such
    // and go on to the next point, so we can get an edge.

        pptfx = ppr->aptfx;

        if (ppr->flags & PD_BEGINSUBPATH)
        {
            pptfxStart = ppr->aptfx;        // the subpath starts here
            pptfxPrev = ppr->aptfx;         // this points starts next edge
            pptfx++;                        // advance to the next point
        }

   // Add edges in PATH to GET, in Y-X sorted order.

        pptfxEnd = ppr->aptfx + ppr->count;

        while (pptfx < pptfxEnd)
        {
            ASSERTGDI(pptfxPrev != NULL, "No path record with PD_BEGINSUBPATH");

            pFreeEdges =
                AddEdgeToGET(pGETHead, pFreeEdges,pptfxPrev,pptfx,pBound);
            pptfxPrev = pptfx;
            pptfx++;                        // advance to the next point
        }

     // If last point ends the subpath, insert the edge that
     // connects to first point.

        if (ppr->flags & PD_ENDSUBPATH)
        {
            pFreeEdges =
                AddEdgeToGET(pGETHead, pFreeEdges,pptfxPrev, pptfxStart,pBound);

            pptfxPrev = NULL;
        }
    }
}

/******************************Public*Function*****************************\
* vAdvanceAETEdges
*
*  Advance the edges in the AET to the next scan, dropping any for which we've
*  done all scans. Assumes there is at least one edge in the AET.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/

VOID vAdvanceAETEdges(EDGE *pAETHead)
{
    EDGE *pLastEdge, *pCurrentEdge;
    COUNT c = pAETHead->Y;                  // Y is used as edge count in AET

    pLastEdge = pAETHead;
    pCurrentEdge = pLastEdge->pNext;
    do
    {
    // Count down this edge's remaining scans

        if (--pCurrentEdge->lScansLeft == 0)
        {
        // We've done all scans for this edge; drop this edge from the AET

            pLastEdge->pNext = pCurrentEdge->pNext;
            c--;
        }
        else
        {
        // Advance the edge's X coordinate for a 1-scan Y advance
        // Advance by the minimum amount

            pCurrentEdge->X += pCurrentEdge->lXWhole;

        // Advance the error term and see if we got one extra pixel this time.

            pCurrentEdge->lErrorTerm += pCurrentEdge->lErrorAdjustUp;
            if (pCurrentEdge->lErrorTerm >= 0)
            {
            // The error term turned over, so adjust the error term and
            // advance the extra pixel.

                pCurrentEdge->lErrorTerm -= pCurrentEdge->lErrorAdjustDown;
                pCurrentEdge->X += pCurrentEdge->lXDirection;
            }

            pLastEdge = pCurrentEdge;
        }
    } while ((pCurrentEdge = pLastEdge->pNext) != pAETHead);
    pAETHead->Y = c;                        // Y is used as edge count in AET
}

/******************************Public*Function*****************************\
* vXSortAETEdges
*
*  X-sort the AET, because the edges may have moved around relative to
*  one another when we advanced them. We'll use a multipass bubble
*  sort, which is actually okay for this application because edges
*  rarely move relative to one another, so we usually do just one pass.
*  Also, this makes it easy to keep just a singly-linked list. Assumes there
*  are at least two edges in the AET.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/

VOID vXSortAETEdges(EDGE *pAETHead)
{
    BOOL bEdgesSwapped;
    EDGE *pLastEdge, *pCurrentEdge, *pNextEdge;

    do
    {
        bEdgesSwapped = FALSE;
        pLastEdge = pAETHead;
        pCurrentEdge = pLastEdge->pNext;
        pNextEdge = pCurrentEdge->pNext;

        do {
            if (pNextEdge->X < pCurrentEdge->X)
            {
            // Next edge is to the left of the current edge; swap them.

                pLastEdge->pNext = pNextEdge;
                pCurrentEdge->pNext = pNextEdge->pNext;
                pNextEdge->pNext = pCurrentEdge;
                bEdgesSwapped = TRUE;
                pCurrentEdge = pNextEdge;   // continue sorting before the edge
                                            //  we just swapped; it might move
                                            //  farther yet
            }
            pLastEdge = pCurrentEdge;
            pCurrentEdge = pLastEdge->pNext;
        } while ((pNextEdge = pCurrentEdge->pNext) != pAETHead);
    } while (bEdgesSwapped);
}

/******************************Public*Function*****************************\
* vMoveNewEdges
*
*  Moves all edges that start on the current scan from the GET to the AET in
*  X-sorted order. Parameters are pointer to head of GET and pointer to dummy
*  edge at head of AET, plus current scan line. Assumes there's at least one
*  edge to be moved.
*
* History:
*  09-Sep-1993 -by- Wendy Wu [wendywu]
* Stolen from DrvFillPath.
\**************************************************************************/

VOID vMoveNewEdges(EDGE *pGETHead, EDGE *pAETHead, LONG lyCurrent)
{
    EDGE *pCurrentEdge = pAETHead;
    EDGE *pGETNext = pGETHead->pNext;
    COUNT c = pAETHead->Y;          // Y is used as edge count in AET

    do
    {
    // Scan through the AET until the X-sorted insertion point for this
    // edge is found. We can continue from where the last search left
    // off because the edges in the GET are in X sorted order, as is
    // the AET. The search always terminates because the AET sentinel
    // is greater than any valid X

        while (pGETNext->X > ((EDGE *)pCurrentEdge->pNext)->X)
            pCurrentEdge = pCurrentEdge->pNext;

    // We've found the insertion point; add the GET edge to the AET, and
    // remove it from the GET.

        pGETHead->pNext = pGETNext->pNext;
        pGETNext->pNext = pCurrentEdge->pNext;
        pCurrentEdge->pNext = pGETNext;
        pCurrentEdge = pGETNext;    // continue insertion search for the next
                                    //  GET edge after the edge we just added
        pGETNext = pGETHead->pNext;
        c++;

    } while (pGETNext->Y == lyCurrent);
    pAETHead->Y = c;                // Y is used as edge count in AET
}

/******************************Member*Function*****************************\
* BOOL RGNOBJ::bAddScans
*
*  Add a new scan into the region.
*
* History:
*  16-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL RGNMEMOBJ::bAddScans(LONG yTop, PEDGE pAETHead, FLONG flOptions)
{
    ULONGSIZE_T cWalls = (ULONGSIZE_T)pAETHead->Y;    // Y is used as edge count in AET
    ULONGSIZE_T size = cWalls * sizeof(INDEX_LONG) + NULL_SCAN_SIZE;

// Check for nearly full region

    if (size > prgn->sizeObj - prgn->sizeRgn)
    {
    // There isn't enough space for this scan, lets try to realloc this region.
    // We want to expand to a big enough size to avoid reallocation in the near
    // future.

        if (!bExpand(prgn->sizeObj + size + FILL_REGION_SIZE))
            return(FALSE);
    }

    PSCAN pscn = (SCAN *) prgn->pscnTail;      // points pass last scan

    ASSERTGDI(yTop == pscnGot(pscn)->yBottom, "bAddNullScan: bad yTop\n");

    PEDGE pCurrentEdge = pAETHead->pNext;   // point to the first edge

// yBottom is the dword before ai_x[0] in the SCAN structure.
// Stuff NEG_INFINITY there so the first wall is bigger than
// the "previous" wall.  yBottom will be initialized later on.

    PLONG pWallStart = (LONG *)&pscn->yBottom;
    PLONG pWall = pWallStart;
    *pWall = NEG_INFINITY;

    if (flOptions & WINDING)
    {
    // Do winding fill; scan across until we've found equal numbers
    // of up and down edges.

        while (pCurrentEdge != pAETHead)
        {
            if (*pWall < pCurrentEdge->X)
            {
                pWall++;
                *pWall = pCurrentEdge->X;
            }
            else
                pWall--;

            LONG lWindingCount = pCurrentEdge->lWindingDirection;
            do
            {
                pCurrentEdge = pCurrentEdge->pNext;
                lWindingCount += pCurrentEdge->lWindingDirection;
            } while (lWindingCount != 0);

            if (*pWall < pCurrentEdge->X)
            {
                pWall++;
                *pWall = pCurrentEdge->X;
            }
            else
                pWall--;

            pCurrentEdge = pCurrentEdge->pNext;
        }
    }
    else
    {
        while (pCurrentEdge != pAETHead)
        {
            if (*pWall < pCurrentEdge->X)
            {
                pWall++;
                *pWall = pCurrentEdge->X;
            }
            else
                pWall--;

            pCurrentEdge = pCurrentEdge->pNext;
        }
    }

    ASSERT4GB ((LONGLONG)(((BYTE *)pWall - (BYTE *)pWallStart) / sizeof(LONG)));
    cWalls = (ULONGSIZE_T)(((BYTE *)pWall - (BYTE *)pWallStart) / sizeof(LONG));

    PSCAN pscnPrev = pscnGot(pscn);

    if ((pscnPrev->cWalls == cWalls) &&
        !memcmp(pscnPrev->ai_x, pscn->ai_x,cWalls * sizeof(LONG)))
    {
        pscnPrev->yBottom = yTop+1;
    }
    else
    {
        prgn->cScans += 1;
        prgn->sizeRgn += (ULONGSIZE_T)(NULL_SCAN_SIZE + sizeof(INDEX_LONG) * cWalls);
        ASSERTGDI(prgn->sizeRgn <= prgn->sizeObj, "bAddScans: sizeRgn > sizeObj\n");
        ASSERTGDI((cWalls & 1) == 0,"bAddScan error: cWalls odd number\n");

        pscn->yTop = yTop;
        pscn->yBottom = yTop+1;

        pscn->cWalls = cWalls;
        pscn->ai_x[cWalls].x = cWalls;              // This sets cWalls2
        prgn->pscnTail = pscnGet(pscn);
    }

    return(TRUE);
}

/******************************Member*Function*****************************\
* BOOL RGNOBJ::bAddNullScan
*
*  Add a null scan into the region.
*
* History:
*  16-Sep-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL RGNMEMOBJ::bAddNullScan(LONG yTop, LONG yBottom)
{
// Check for nearly full region

    if (NULL_SCAN_SIZE > prgn->sizeObj - prgn->sizeRgn)
    {
    // There isn't enough space for this scan, lets try to realloc this region.
    // We want to expand to a big enough size to avoid reallocation in the near
    // future.

        if (!bExpand(prgn->sizeObj + NULL_SCAN_SIZE + FILL_REGION_SIZE))
            return(FALSE);
    }

    PSCAN pscn = (SCAN *) prgn->pscnTail;      // points pass last scan
    ASSERTGDI(prgn->cScans == 0 || yTop == pscnGot(pscn)->yBottom,
              "bAddNullScan: bad yTop\n");

    prgn->cScans += 1;

    pscn->yTop = yTop;
    pscn->yBottom = yBottom;

    prgn->sizeRgn += (ULONGSIZE_T)NULL_SCAN_SIZE;
    ASSERTGDI(prgn->sizeRgn <= prgn->sizeObj, "bAddNullScan: sizeRgn > sizeObj\n");

    pscn->cWalls = pscn->ai_x[0].x = 0;
    prgn->pscnTail = pscnGet(pscn);

    return(TRUE);
}

/******************************Member*Function*****************************\
* VOID RGNMEMOBJ::vCreate(po, fl)
*
* Routine for constructing a region from a path.
*
* History:
*  16-Sep-1993 -by- Wendy Wu [wendywu]
* Removed trapazoidal regions.
*  04-Apr-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID RGNMEMOBJ::vCreate(
EPATHOBJ&   po,
FLONG       flOptions, // ALTERNATE or WINDING
RECTL       *pBound
)
{
    GDIFunctionID(RGNMEMOBJ::vCreate);

    RGNLOG rl((PREGION)NULL,"RGNMEMOBJ::vCreate");
    rl.vRet(0);

    if (!po.bValid())
    {
        RIP("Invalid EPATHOBJ");
    }
    else
    {

        ULONG count;
        EDGE AETHead;       // dummy head/tail node & sentinel for Active Edge Table
        EDGE *pAETHead;     // pointer to AETHead
        EDGE GETHead;       // dummy head/tail node & sentinel for Global Edge Table
        EDGE *pGETHead;     // pointer to GETHead
        EDGE aEdge[MAX_POINTS];

        prgn = (REGION *) NULL;         // Assume failure.

        if (po.bBeziers() && !po.bFlatten())
            return;

    // The given path should be closed when create region from path
    // then make sure it here.

        po.vCloseAllFigures();

        if ((count = po.cCurves) < 2)
            return;

        // Is path contained in a bounding rectangle?
        //
        // If there is no bound (pBound = NULL) or 
        // the bound won't shrink the current BoundBox
        // then try bFastFillWrapper.
        //
        // Many calling sites only initialize the top and bottom of the
        // pBound rectange because the underlying clipping code only
        // uses the top and bottom.
        // Also, they always initialize them in FIX coordinate.

        if ( (pBound==NULL) ||
             ( ( pBound->top    < po.rcfxBoundBox().yTop   ) &&
               ( pBound->bottom > po.rcfxBoundBox().yBottom)
           ) )
        {
             if (bFastFillWrapper(po))
             {
                 vTighten();
                 rl.vRet((ULONG_PTR)prgn);
                 return;
             }
        }

    // Allocate memory for edge storage.

        BOOL bAlloc;
        EDGE *pFreeEdges;   // pointer to memory free for use to store edges

        if (count < MAX_POINTS)
        {
            pFreeEdges = &aEdge[0];
            bAlloc     = FALSE;
        }
        else
        {
            pFreeEdges = (PEDGE)PALLOCNOZ(sizeof(EDGE) * (count + 1), 'ngrG');
            if (pFreeEdges == (PEDGE)NULL)
                return;
            bAlloc     = TRUE;
        }

    // This is a size of random guess...
    // Given a path of n points, assume there are n scans with 4 walls on each
    // scan.  The region will be expanded later if this size is too small.

        ULONG size;
        LONGLONG llSize;
        FIX top    = po.rcfxBoundBox().yTop;
        FIX bottom = po.rcfxBoundBox().yBottom;

        if (bottom < top)
        {
            // WINBUG #178736 claudebe 9-7-2000 we should check for math overflow where the path is created/offset/scaled see stress #178262
            // when this is done, we can chage this test back into an assert
            WARNING("PATHOBJ BoundBox is invalid.\n");

            if (bAlloc)
                VFREEMEM(pFreeEdges);

            return;
        }

        // Make sure we account for the clipping in our estimate.
        // Without this code, we could overestimate by many orders
        // of magnitude.

        if (pBound)
        {
            top    = MAX(top,    pBound->top);
            bottom = MIN(bottom, pBound->bottom);
        }

        // The smallest region we should have from bounding is zero.
        // Note this also takes care of the conversion issue of using
        //  FXTOL and assigning the result to an unsigned long.
        // using LONGLONG because bottom-top may overflow a ULONG

        llSize = MAX((LONGLONG)bottom-(LONGLONG)top, 0);

        // we know that after >> 4, the result will fit in a ULONG
        size = (ULONG)(FXTOL(llSize)) + 10;

        if (size < 0x00ffffff)
        {
            size = QUANTUM_REGION_SIZE + (sizeof(INDEX_LONG) * 4 + NULL_SCAN_SIZE) * size;

            prgn = (PREGION)ALLOCOBJ(size,RGN_TYPE,FALSE);
        }

        if (!prgn)
        {
            if (bAlloc)
                VFREEMEM(pFreeEdges);

            return;
        }

        prgn->sizeObj = size;
        prgn->sizeRgn = offsetof(REGION,scan);
        prgn->cRefs = 0;
        prgn->iUnique = 0;
        prgn->cScans = 0;           // start from scratch, assume no scans
        prgn->pscnTail = prgn->pscnHead();

    // Construct the global edge list.

        pGETHead = &GETHead;
        vConstructGET(po, pGETHead, pFreeEdges,pBound);    // bad line coordinates or

        BOOL bSucceed = TRUE;
        LONG yTop = NEG_INFINITY;   // scan line for which we're currently scanning

    // Create an empty AET with the head node also a tail sentinel

        pAETHead = &AETHead;
        AETHead.pNext = pAETHead;   // mark that the AET is empty
        AETHead.Y = 0;              // used as a count for number of edges in AET
        AETHead.X = 0x7FFFFFFF;     // this is greater than any valid X value, so
                                    //  searches will always terminate

    // Loop through all the scans in the polygon, adding edges from the GET to
    // the Active Edge Table (AET) as we come to their starts, and scanning out
    // the AET at each scan into a rectangle list. Each time it fills up, the
    // rectangle list is passed to the filling routine, and then once again at
    // the end if any rectangles remain undrawn. We continue so long as there
    // are edges to be scanned out.

        while (bSucceed)
        {
        // Advance the edges in the AET one scan, discarding any that have
        // reached the end (if there are any edges in the AET)

            if (AETHead.pNext != pAETHead)
                vAdvanceAETEdges(pAETHead);

        // If the AET is empty, done if the GET is empty, else jump ahead to
        // the next edge in the GET; if the AET isn't empty, re-sort the AET

            if (AETHead.pNext == pAETHead)
            {
            // Done if there are no edges in either the AET or the GET

                if (GETHead.pNext == pGETHead)
                    break;

            // There are no edges in the AET, so jump ahead to the next edge in
            // the GET.

                LONG    yTopOld = yTop;
                yTop = ((EDGE *)GETHead.pNext)->Y;
                if (yTop != yTopOld)
                {
                // Fill in NULL scan between rectangles.

                    if (!(bSucceed = bAddNullScan(yTopOld, yTop)))
                        break;
                }
            }
            else
            {
            // Re-sort the edges in the AET by X coordinate, if there are at
            // least two edges in the AET (there could be one edge if the
            // balancing edge hasn't yet been added from the GET)

                if (((EDGE *)AETHead.pNext)->pNext != pAETHead)
                    vXSortAETEdges(pAETHead);
            }

        // Move any new edges that start on this scan from the GET to the AET;
        // bother calling only if there's at least one edge to add

            if (((EDGE *)GETHead.pNext)->Y == yTop)
                vMoveNewEdges(pGETHead, pAETHead, yTop);

        // Scan the AET into region scans (there's always at least one
        // edge pair in the AET)

            bSucceed = bAddScans(yTop, pAETHead, flOptions);
            yTop++;    // next scan
        }

        if (!bSucceed ||
            !bAddNullScan(yTop, POS_INFINITY))
        {
            bDeleteRGNOBJ();
            bSucceed = FALSE;
        }
        else
        {
            vTighten();
        }

        if (bAlloc)
            VFREEMEM(pFreeEdges);

        rl.vRet((ULONG_PTR)prgn);

    }
}

/******************************Member*Function*****************************\
* RGNMEMOBJ::bFastFillWrapper
*
*   create a rgn from a convex polygon.
*
* History:
*  27-Sep-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#define QUICKPOINTS 40

BOOL RGNMEMOBJ::bFastFillWrapper(
    EPATHOBJ& epo)
{
    PATHDATA pd;
    BOOL     bRes = FALSE;

    ASSERTGDI(!(epo.fl & PO_BEZIERS),"RGNMEMOBJ::bFastFill - bez\n");
    ASSERTGDI(epo.cCurves == epo.cTotalPts(),"RGNMEMOBJ::cCurves != cTotalPts\n");

    epo.vEnumStart();

    if (epo.bEnum(&pd))
    {
        // if this ends the sub path, that means there is more than one sub path.
        // also don't handle if we can't copy points onto stack

        if (!(pd.flags & PD_ENDSUBPATH) && (epo.cCurves <= QUICKPOINTS))
        {
            POINTFIX aptfx[QUICKPOINTS];
            LONG cPoints;
            BOOL bMore;

            RtlCopyMemory(aptfx,pd.pptfx,(SIZE_T)pd.count*sizeof(POINTFIX));
            cPoints = pd.count;

            do {
                bMore = epo.bEnum(&pd);

                if (pd.flags & PD_BEGINSUBPATH)
                    goto DoStart;

                RtlCopyMemory(aptfx+cPoints,pd.pptfx,(SIZE_T)pd.count*sizeof(POINTFIX));
                cPoints += pd.count;

            } while(bMore);

            // Should never hit this assert. if hit, the stack is already broken...

            ASSERTGDI(cPoints <= QUICKPOINTS,"RGNMEMOBJ::bFastFillWrapper - too many points\n");

            bRes = bFastFill(epo,cPoints,aptfx);
        }
    }
    else if (pd.count > 1)
    {
        bRes = bFastFill(epo,pd.count,pd.pptfx);
    }
    else
    {
        bRes = TRUE;
    }

DoStart:
    epo.vEnumStart();

    return(bRes);
}

/******************************Member*Function*****************************\
* RGNMEMOBJ::bFastFill
*
*   create a rgn from a convex polygon.
*   this routine is very similar to bFastFill in fastfill.cxx
*
* History:
*  14-Oct-1993 -by-  Eric Kutter [erick]
* initial code stolen from s3 driver.
\**************************************************************************/

BOOL RGNMEMOBJ::bFastFill(
    EPATHOBJ& po,
    LONG      cEdges,       // Includes close figure edge
    POINTFIX* pptfxFirst)
{
    LONG      cyTrapezoid;  // Number of scans in current trapezoid
    LONG      yStart;       // y-position of start point in current edge
    LONG      dM;           // Edge delta in FIX units in x direction
    LONG      dN;           // Edge delta in FIX units in y direction
    LONG      i;
    POINTFIX* pptfxLast;    // Points to the last point in the polygon array
    POINTFIX* pptfxTop;     // Points to the top-most point in the polygon
    POINTFIX* pptfxOld;     // Start point in current edge
    POINTFIX* pptfxScan;    // Current edge pointer for finding pptfxTop
    LONG      cScanEdges;   // Number of edges scanned to find pptfxTop
                            //  (doesn't include the closefigure edge)
    LONG      iEdge;
    LONG      lQuotient;
    LONG      lRemainder;

    EDGEDATA  aed[2];       // DDA terms and stuff
    EDGEDATA* ped;

    pptfxScan = pptfxFirst;
    pptfxTop  = pptfxFirst;                 // Assume for now that the first
                                            //  point in path is the topmost
    pptfxLast = pptfxFirst + cEdges - 1;

    LONG yCurrent;

    // 'pptfxScan' will always point to the first point in the current
    // edge, and 'cScanEdges' will the number of edges remaining, including
    // the current one:

    cScanEdges = cEdges - 1;     // The number of edges, not counting close figure

    if ((pptfxScan + 1)->y > pptfxScan->y)
    {
        // Collect all downs:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if (--cScanEdges == 0)
                goto SetUpForFillingCheck;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        // Collect all downs:

        pptfxTop = pptfxScan;

        do {
            if ((pptfxScan + 1)->y > pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        return(FALSE);
    }
    else
    {
        // Collect all ups:

        do {
            pptfxTop++;                 // We increment this now because we
                                        //  want it to point to the very last
                                        //  point if we early out in the next
                                        //  statement...
            if (--cScanEdges == 0)
                goto SetUpForFilling;
        } while ((pptfxTop + 1)->y <= pptfxTop->y);

        // Collect all downs:

        pptfxScan = pptfxTop;
        do {
            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y >= pptfxScan->y);

        // Collect all ups:

        do {
            if ((pptfxScan + 1)->y < pptfxFirst->y)
                break;

            if (--cScanEdges == 0)
                goto SetUpForFilling;
            pptfxScan++;
        } while ((pptfxScan + 1)->y <= pptfxScan->y);

        return(FALSE);
    }

SetUpForFillingCheck:

    // We check to see if the end of the current edge is higher
    // than the top edge we've found so far:

    if ((pptfxScan + 1)->y < pptfxTop->y)
        pptfxTop = pptfxScan + 1;

SetUpForFilling:

    yCurrent = (pptfxTop->y + 15) >> 4;

    // Make sure we initialize the DDAs appropriately:

#define RIGHT 0
#define LEFT  1

    aed[LEFT].cy  = 0;
    aed[RIGHT].cy = 0;

    // For now, guess as to which is the left and which is the right edge:

    aed[LEFT].dptfx  = -(LONG) sizeof(POINTFIX);
    aed[RIGHT].dptfx = sizeof(POINTFIX);
    aed[LEFT].pptfx  = pptfxTop;
    aed[RIGHT].pptfx = pptfxTop;

    // setup the region

    ULONGSIZE_T size = (ULONGSIZE_T)(NULL_REGION_SIZE + NULL_SCAN_SIZE +
                   (sizeof(INDEX_LONG) * 2 + NULL_SCAN_SIZE) *
                   FXTOL(po.rcfxBoundBox().yBottom - po.rcfxBoundBox().yTop + 15));

    prgn = (PREGION)ALLOCOBJ(size,RGN_TYPE,FALSE);

    if (!prgn)
        return(FALSE);

    prgn->sizeObj  = size;
    prgn->sizeRgn  = offsetof(REGION,scan);
    prgn->cRefs    = 0;
    prgn->cScans   = 0;           // start from scratch, assume no scans
    prgn->pscnTail = (PSCAN)((PBYTE)prgn + size);

    // setup the scans

    PSCAN pscnPrev= prgn->pscnHead();
    ULONG cScans  = 1;

    pscnPrev->yTop    = NEG_INFINITY;
    pscnPrev->yBottom = yCurrent;
    pscnPrev->cWalls  = 0;
    pscnPrev->ai_x[0].x = 0;

    PSCAN pscn = pscnGet(pscnPrev);

NextEdge:

    ASSERTGDI(pscn < prgn->pscnTail,"bFastFill - pscn past end\n");

    // We loop through this routine on a per-trapezoid basis.

    for (iEdge = 1; iEdge >= 0; iEdge--)
    {
        ped = &aed[iEdge];
        if (ped->cy == 0)
        {
            // Need a new DDA:

            do {
                cEdges--;
                if (cEdges < 0)
                {
                // the only way out

                    if (pscnPrev->cWalls == 0)
                    {
                        pscnPrev->yBottom = POS_INFINITY;
                    }
                    else
                    {
                        pscn->cWalls  = 0;
                        pscn->ai_x[0].x = 0;
                        pscn->yTop    = yCurrent;
                        pscn->yBottom = POS_INFINITY;
                        ++cScans;
                        pscn = pscnGet(pscn);
                    }

                    ASSERTGDI(pscn <= prgn->pscnTail,"bFastFill - pscn past end2\n");

                    prgn->cScans = cScans;
                    prgn->pscnTail = pscn;

                    ASSERT4GB((ULONGLONG)((PBYTE)pscn - (PBYTE)prgn));
                    prgn->sizeRgn  = (ULONG)((PBYTE)pscn - (PBYTE)prgn);

                    return(TRUE);
                }
                // Find the next left edge, accounting for wrapping:

                pptfxOld = ped->pptfx;
                ped->pptfx = (POINTFIX*) ((BYTE*) ped->pptfx + ped->dptfx);

                if (ped->pptfx < pptfxFirst)
                    ped->pptfx = pptfxLast;
                else if (ped->pptfx > pptfxLast)
                    ped->pptfx = pptfxFirst;

                // Have to find the edge that spans yCurrent:

                ped->cy = ((ped->pptfx->y + 15) >> 4) - yCurrent;

                // With fractional coordinate end points, we may get edges
                // that don't cross any scans, in which case we try the
                // next one:

            } while (ped->cy <= 0);

            // 'pptfx' now points to the end point of the edge spanning
            // the scan 'yCurrent'.

            dN = ped->pptfx->y - pptfxOld->y;
            dM = ped->pptfx->x - pptfxOld->x;

            ASSERTGDI(dN > 0, "Should be going down only");

            // Compute the DDA increment terms:

            if (dM < 0)
            {
                dM = -dM;
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = -1;
                    ped->lErrorUp = dN - dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = -lQuotient;     // - dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                    if (ped->lErrorUp > 0)
                    {
                        ped->dx--;
                        ped->lErrorUp = dN - ped->lErrorUp;
                    }
                }
            }
            else
            {
                if (dM < dN)                // Can't be '<='
                {
                    ped->dx       = 0;
                    ped->lErrorUp = dM;
                }
                else
                {
                    QUOTIENT_REMAINDER(dM, dN, lQuotient, lRemainder);

                    ped->dx       = lQuotient;      // dM / dN
                    ped->lErrorUp = lRemainder;     // dM % dN
                }
            }

            ped->lErrorDown = dN; // DDA limit
            ped->lError     = -1; // Error is initially zero (add dN - 1 for
                                  //  the ceiling, but subtract off dN so that
                                  //  we can check the sign instead of comparing
                                  //  to dN)

            ped->x = pptfxOld->x;
            yStart = pptfxOld->y;

            if ((yStart & 15) != 0)
            {
                // Advance to the next integer y coordinate

                for (i = 16 - (yStart & 15); i > 0; i--)
                {
                    ped->x      += ped->dx;
                    ped->lError += ped->lErrorUp;
                    if (ped->lError >= 0)
                    {
                        ped->lError -= ped->lErrorDown;
                        ped->x++;
                    }
                }
            }

            if ((ped->x & 15) != 0)
            {
                ped->lError -= ped->lErrorDown * (16 - (ped->x & 15));
                ped->x += 15;       // We'll want the ceiling in just a bit...
            }

            // Chop off those fractional bits:

            ped->x      >>= 4;
            ped->lError >>= 4;
        }
    }

    cyTrapezoid = min(aed[LEFT].cy, aed[RIGHT].cy); // # of scans in this trap
    aed[LEFT].cy  -= cyTrapezoid;
    aed[RIGHT].cy -= cyTrapezoid;

    // If the left and right edges are vertical, simply output as
    // a rectangle:

    if (((aed[LEFT].lErrorUp | aed[RIGHT].lErrorUp) == 0) &&
        ((aed[LEFT].dx       | aed[RIGHT].dx) == 0))
    {
        LONG xL = aed[LEFT].x;
        LONG xR = aed[RIGHT].x;

        if (xL != xR)
        {
            if (xL > xR)
            {
                LONG l = xL;
                xL = xR;
                xR = l;
            }

        // non NULL case

            if ((pscnPrev->cWalls  == 2) &&
                (pscnPrev->ai_x[0].x == xL) &&
                (pscnPrev->ai_x[1].x == xR))
            {
                pscnPrev->yBottom = yCurrent+cyTrapezoid;
            }
            else
            {
                pscn->cWalls  = 2;
                pscn->ai_x[0].x = xL;
                pscn->ai_x[1].x = xR;
                pscn->ai_x[2].x = 2;
                pscn->yTop    = yCurrent;
                pscn->yBottom = yCurrent+cyTrapezoid;
                pscnPrev      = pscn;
                pscn          = pscnGet(pscn);
                ++cScans;
            }
        }
        else
        {
        // NULL scan case

            if (pscnPrev->cWalls == 0)
            {
                pscnPrev->yBottom = yCurrent+cyTrapezoid;
            }
            else
            {
                pscn->cWalls  = 0;
                pscn->ai_x[0].x = 0;
                pscn->yTop    = yCurrent;
                pscn->yBottom = yCurrent+cyTrapezoid;
                pscnPrev      = pscn;
                pscn          = pscnGet(pscn);
                ++cScans;
            }
        }

        yCurrent += cyTrapezoid;

        goto NextEdge;
    }

    while (TRUE)
    {
        LONG lWidth = aed[RIGHT].x - aed[LEFT].x;

        if (lWidth > 0)
        {
            if ((pscnPrev->cWalls  == 2) &&
                (pscnPrev->ai_x[0].x == aed[LEFT].x) &&
                (pscnPrev->ai_x[1].x == aed[RIGHT].x))
            {
            // the scans coalesce, just need to change the bottom

    ContinueAfterZeroDup:

                pscnPrev->yBottom = ++yCurrent;
            }
            else
            {
            // need to setup the entire scan

                pscn->cWalls  = 2;
                pscn->ai_x[0].x = aed[LEFT].x;
                pscn->ai_x[1].x = aed[RIGHT].x;
                pscn->ai_x[2].x = 2;

    ContinueAfterZero:

                pscn->yTop    = yCurrent;
                pscn->yBottom = ++yCurrent;
                pscnPrev      = pscn;
                pscn          = pscnGet(pscn);    // (PBYTE)pscn + NULL_SCAN_SIZE + 2 * sizeof(LONG);
                ++cScans;
            }

            // Advance the right wall:

            aed[RIGHT].x      += aed[RIGHT].dx;
            aed[RIGHT].lError += aed[RIGHT].lErrorUp;

            if (aed[RIGHT].lError >= 0)
            {
                aed[RIGHT].lError -= aed[RIGHT].lErrorDown;
                aed[RIGHT].x++;
            }

            // Advance the left wall:

            aed[LEFT].x      += aed[LEFT].dx;
            aed[LEFT].lError += aed[LEFT].lErrorUp;

            if (aed[LEFT].lError >= 0)
            {
                aed[LEFT].lError -= aed[LEFT].lErrorDown;
                aed[LEFT].x++;
            }

            cyTrapezoid--;

            if (cyTrapezoid == 0)
                goto NextEdge;
        }
        else if (lWidth == 0)
        {
            // NULL scan, do null scan specific stuff

            if (pscnPrev->cWalls == 0)
            {
                goto ContinueAfterZeroDup;
            }
            else
            {
                pscn->cWalls  = 0;
                pscn->ai_x[0].x = 0;

                goto ContinueAfterZero;
            }
        }
        else
        {
            #define SWAP(a, b, tmp) { tmp = a; a = b; b = tmp; }

            // We certainly don't want to optimize for this case because we
            // should rarely get self-intersecting polygons (if we're slow,
            // the app gets what it deserves):

            EDGEDATA edTmp;
            SWAP(aed[LEFT],aed[RIGHT],edTmp);

            continue;
        }
    }
}

#if DBG
/******************************Member*Function*****************************\
* VOID RGNOBJ::vPrintScans()
*
*  DbgPrint the walls of every scan of the given region.  This is
*  for debugging only.
*
* History:
*  08-Mar-1991 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vPrintScans()
{
    COUNT cScans = prgn->cScans;
    PSCAN pscn = prgn->pscnHead();

    for (COUNT i = 0;
         i < cScans;
         i++)
    {
        COUNT cWalls = pscn->cWalls;
        DbgPrint("Scan %ld: yTop = %ld, yBottom = %ld, cWalls = %ld\n",
                  i, pscn->yTop, pscn->yBottom, cWalls);

        for (COUNT j = 0;
             j < cWalls;
             j+=2)
        {
            DbgPrint("  Left edge: index = %ld\n", pscn->ai_x[j].x);
            DbgPrint("  Right edge: index = %ld\n", pscn->ai_x[j+1].x);
        }
        pscn = pscnGet(pscn);
    }
}
#endif

/******************************Public*Routine******************************\
* VOID vTighten()
*
* Tighten the bounding rectangle
*
* History:
*  21-May-1991 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID RGNOBJ::vTighten()
{
// If this is a NULL region, zero the bounding box and get out of here.

    if (prgn->cScans == 1)
    {
        prgn->rcl.left = 0;
        prgn->rcl.bottom = 0;
        prgn->rcl.right = 0;
        prgn->rcl.top = 0;
        return;
    }

// Start with a maximally crossed rectangle

    ERECTL  ercl(POS_INFINITY, POS_INFINITY, NEG_INFINITY, NEG_INFINITY);
    COUNT   cScans = prgn->cScans;
    PSCAN   pscn = pscnGot(prgn->pscnTail);

    ercl.bottom = pscn->yTop;          // The top of the empty bottom scan
    pscn = prgn->pscnHead();
    ercl.top = pscn->yBottom;          // The bottom of the empty top scan

    COUNT   cWall;

    while (cScans--)
    {
    // Are there any walls?

        if ((cWall = pscn->cWalls) != 0)
        {
            if (ercl.left > pscn->ai_x[0].x)
                ercl.left = pscn->ai_x[0].x;
            if (ercl.right < pscn->ai_x[cWall - 1].x)
                ercl.right = pscn->ai_x[cWall - 1].x;
        }

        pscn = pscnGet(pscn);

        ASSERTGDI(pscn <= prgn->pscnTail, "vTighten2:Went past end of region\n");
    }

    if (ercl.left >= ercl.right)
    {
        ercl.left  = 0;
        ercl.right = 0;
    }

    prgn->rcl = *((RECTL *) &ercl);
}

/******************************Public*Routine******************************\
* BOOL vFramed(pscn, iWall)
*
* Marks the given wall as having been added to the frame path.
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#define REGION_FRAMED_OFFSET 0x10000000L
#define DIR_UP               0x00000001L
#define DIR_DOWN             0x00000000L

inline VOID vFramed(SCAN* pscn, LONG iWall, RGNOBJ* pro)
{
#if DBG
    if (!VALID_SCR(pscn->ai_x[iWall].x))
    {
        pro->bValidateFramedRegion();
        RIP("Wall revisited");
    }
#endif

    DONTUSE(pro);
    pscn->ai_x[iWall].x += REGION_FRAMED_OFFSET;
}

/******************************Public*Routine******************************\
* BOOL bFramed(pscn, iWall)
*
* Returns TRUE if the wall has already been added to the frame's path.
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline BOOL bFramed(SCAN* pscn, LONG iWall)
{
    return(pscn->ai_x[iWall].x > MAX_REGION_COORD);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::xMyGet(pscn, iWall, iDir)
*
* Retrieves the x-value of the wall of the given scan, iDir indicating
* if it should be the top or bottom.
*
* History:
*  31-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline LONG RGNOBJ::xMyGet(SCAN* pscn, LONG iWall, LONG iDir)
{
    DONTUSE(iDir);

    INDEX_LONG il = pscn->ai_x[iWall];

    if (il.x > MAX_REGION_COORD)
        il.x -= REGION_FRAMED_OFFSET;

#if DBG
    if (!VALID_SCR(il.x))
    {
        bValidateFramedRegion();
        RIP("Wall Revisited");
    }
#endif

    return(il.x);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bOutline(epo, pexo)
*
* Create a path from the outline of a region.
*
* WARNING: This call destroys the data in the region!
*
* Note that this code makes the implicit assumption that the x-value of
* adjacent walls is not the same (i.e., no empty rectangles).
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bOutline(
EPATHOBJ& epo,
EXFORMOBJ *pexo)
{
    RGNLOG rl(prgn,"RGNOBJ::bOutline");

    POINTL  aptl[2];
    COUNT   cScans;
    SCAN*   pscnCurrent;
    COUNT   iWallCurrent;
    COUNT   cWallsCurrent;

// Now compute the outline:

    pscnCurrent = prgn->pscnHead();
    cScans      = prgn->cScans;

    while (cScans--)
    {
        cWallsCurrent = pscnCurrent->cWalls;
        for (iWallCurrent = 0; iWallCurrent != cWallsCurrent; iWallCurrent++)
        {
        // Only start at unvisited walls:

            if (!bFramed(pscnCurrent, iWallCurrent))
            {
                SCAN* pscn    = pscnCurrent;
                COUNT iWall   = iWallCurrent;
                LONG  iTurn;

                aptl[0].x = xMyGet(pscn, iWallCurrent, DIR_UP);
                aptl[0].y = pscn->yTop;

                if (!epo.bMoveTo(pexo, aptl))
                    return(FALSE);

                SCAN* pscnSearch = pscnGet(pscn);
                BOOL  bInside = (BOOL) (iWallCurrent & 1);

            // Mark that we've visited this wall:

                vFramed(pscn, iWall, this);

            // Loop until the path closes on itself:

            GoDown:
                iTurn = +1;
                while (pscnSearch->cWalls != 0)
                {
                    LONG xWall = xMyGet(pscn, iWall, DIR_DOWN);
                    LONG iNewWall;
                    LONG xNewWall;

                    COUNT iLeft  = bInside;
                    COUNT iRight = pscnSearch->cWalls - 1 - bInside;

                // It would be nice if the first wall in the region structure
                // was minus infinity, but it isn't, so we do this check:

                    if (xMyGet(pscnSearch, iLeft, DIR_UP) > xWall)
                        iNewWall = iLeft;
                    else
                    {
                    // Check if it's possible to find a wall with the
                    // minimum x-value > xWall:

                        if (xMyGet(pscnSearch, iRight, DIR_UP) <= xWall)
                            break;                  // =====>

                    // Do a binary search to find it:

                        while (TRUE)
                        {
                            COUNT iSearch = (iLeft + iRight) >> 1;
                            if (iSearch == iLeft)
                                break;              // =====>

                            LONG xSearch = xMyGet(pscnSearch, iSearch, DIR_UP);

                            if (xSearch > xWall)
                                iRight = iSearch;
                            else
                                iLeft = iSearch;
                        }
                        iNewWall = iRight;
                    }

                    if ((iNewWall & 1) != bInside)
                    {
                    // There is a region directly below xWall.  We can't
                    // move down if its left side is < the left
                    // side of our space:

                        if (iWall > 0 &&
                            xMyGet(pscnSearch, iNewWall - 1, DIR_UP) <
                            xMyGet(pscn, iWall - 1, DIR_DOWN))
                        {
                            iTurn = -1;
                            break;                      // =====>
                        }

                        iNewWall--;
                    }
                    else
                    {
                    // There is a space directly below xWall.  We can't
                    // move down if its right side is more than the
                    // right side of our region:

                        if (xMyGet(pscnSearch, iNewWall, DIR_UP) >=
                            xMyGet(pscn, iWall + 1, DIR_DOWN))
                            break;                      // =====>
                    }

                    xNewWall  = xMyGet(pscnSearch, iNewWall, DIR_UP);

                // Don't bother outputing multiple in-line straight lines:

                    if (xWall != xNewWall                               ||
                        xMyGet(pscn, iWall, DIR_UP) != xNewWall         ||
                        xMyGet(pscnSearch, iNewWall, DIR_DOWN) != xNewWall)
                    {
                        aptl[0].x = xWall;
                        aptl[0].y = pscn->yBottom;
                        aptl[1].y = pscn->yBottom;
                        aptl[1].x = xNewWall;

                        if (!epo.bPolyLineTo(pexo, aptl, 2))
                            return(FALSE);
                    }

                    pscn       = pscnSearch;
                    iWall      = iNewWall;
                    pscnSearch = pscnGet(pscn);

                    vFramed(pscn, iWall, this);
                }

            // Setup to go up other side:

                aptl[0].x = xMyGet(pscn, iWall, DIR_DOWN);
                aptl[0].y = pscn->yBottom;
                aptl[1].y = pscn->yBottom;
                aptl[1].x = xMyGet(pscn, iWall + iTurn, DIR_DOWN);

                if (!epo.bPolyLineTo(pexo, aptl, 2))
                    return(FALSE);

                pscnSearch = pscnGot(pscn);
                iWall += iTurn;
                vFramed(pscn, iWall, this);

            // Go up:

                iTurn = -1;
                while (pscnSearch->cWalls != 0)
                {
                    LONG  xWall = xMyGet(pscn, iWall, DIR_UP);
                    LONG  iNewWall;
                    LONG  xNewWall;

                    COUNT iLeft  = bInside;
                    COUNT iRight = pscnSearch->cWalls - 1 - bInside;

                // It would be nice if the last wall in the region structure
                // was plus infinity, but it isn't, so we do this check:

                    if (xMyGet(pscnSearch, iRight, DIR_DOWN) < xWall)
                        iNewWall = iRight;
                    else
                    {
                    // Check if it's possible to find a wall with the
                    // maximum x-value < xWall:

                        if (xMyGet(pscnSearch, iLeft, DIR_DOWN) >= xWall)
                            break;                  // =====>

                    // Binary search to find it:

                        while (TRUE)
                        {
                            COUNT iSearch = (iLeft + iRight) >> 1;
                            if (iSearch == iLeft)
                                break;              // =====>

                            LONG xSearch = xMyGet(pscnSearch, iSearch, DIR_DOWN);

                            if (xSearch >= xWall)
                                iRight = iSearch;
                            else
                                iLeft = iSearch;
                        }
                        iNewWall = iLeft;
                    }

                    if ((iNewWall & 1) == bInside)
                    {
                    // There is a region directly above xWall.  We can't
                    // move up if its right side is more than the right
                    // side of our space:

                        if (iWall < pscn->cWalls - 1 &&
                            xMyGet(pscnSearch, iNewWall + 1, DIR_DOWN) >
                            xMyGet(pscn, iWall + 1, DIR_UP))
                        {
                            iTurn = +1;
                            break;                          // =====>
                        }

                        iNewWall++;
                    }
                    else
                    {
                    // There is a space directly above xWall.  We can't
                    // move up if its left side is <= the left side
                    // of our region:

                        if (xMyGet(pscnSearch, iNewWall, DIR_DOWN) <=
                            xMyGet(pscn, iWall - 1, DIR_UP))
                            break;                          // =====>
                    }

                    xNewWall = xMyGet(pscnSearch, iNewWall, DIR_DOWN);

                // Don't bother outputing multiple in-line straight lines:

                    if (xWall != xNewWall                               ||
                        xMyGet(pscn, iWall, DIR_DOWN) != xNewWall       ||
                        xMyGet(pscnSearch, iNewWall, DIR_UP) != xNewWall)
                    {
                        aptl[0].x = xWall;
                        aptl[0].y = pscn->yTop;
                        aptl[1].y = pscn->yTop;
                        aptl[1].x = xNewWall;

                        if (!epo.bPolyLineTo(pexo, aptl, 2))
                            return(FALSE);
                    }

                    pscn       = pscnSearch;
                    iWall      = iNewWall;
                    pscnSearch = pscnGot(pscn);

                    vFramed(pscn, iWall, this);
                }

            // Check if we've returned to where we started from:

                if (pscnCurrent != pscn || iWallCurrent != iWall - 1)
                {
                // Setup to go down other side:

                    aptl[0].x = xMyGet(pscn, iWall, DIR_UP);
                    aptl[0].y = pscn->yTop;
                    aptl[1].y = pscn->yTop;
                    aptl[1].x = xMyGet(pscn, iWall + iTurn, DIR_UP);

                    if (!epo.bPolyLineTo(pexo, aptl, 2))
                        return(FALSE);

                    pscnSearch = pscnGet(pscn);
                    iWall += iTurn;
                    vFramed(pscn, iWall, this);

                    goto GoDown;                    // =====>
                }

            // We're all done with this outline!

                aptl[0].x = xMyGet(pscn, iWall, DIR_UP);
                aptl[0].y = pscn->yTop;

                if (!epo.bPolyLineTo(pexo, aptl, 1) ||
                    !epo.bCloseFigure())
                    return(FALSE);
            }
        }
        pscnCurrent  = pscnGet(pscnCurrent);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bCreate(epo, pexo)
*
* Create a path from the frame of a region without destroying the region.
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJ::bCreate(
EPATHOBJ& epo,
EXFORMOBJ *pexo)
{

// When converting the region to a path, bCreate() destroys the region's
// data, which would be sort of rude, so make a copy of the region first:

    BOOL bRes;
    RGNMEMOBJTMP rmoCopy(sizeRgn());
    if (!rmoCopy.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        bRes = FALSE;
    }
    else
    {
        rmoCopy.vCopy(*this);

        VALIDATE(rmoCopy);

        bRes = rmoCopy.bOutline(epo, pexo);

        VALIDATE(*(RGNOBJ *)this);
    }

    return(bRes);
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bSubtract(prcl, arcl, crcl)
*
* Subtract a list of rectangles from a rectangle to produce a region.
* This is just a special case of bMerge and is written to speed up
* USER's computation of VisRgns for obscured windows.
*
* WARNING: If this function returns FALSE, the region may be inconsistent.
*          The caller must discard or reset the region. (See bug #343770)
*
* History:
*  10-Aug-1993 -by-  Eric Kutter [erick]
*       rewrote the complex case.  (accounts for 50% of operations)
*
*  18-Nov-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bSubtract(RECTL *prcl, RECTL *arcl, int crcl)
{
    RGNLOG rl(hrgn_,prgn,"RGNOBJAPI::bSubtract");
    rl.vRet(0);

    PREGION prgn1 = prgn;

    ASSERTGDI(crcl > 0, "Zero rectangles in RGNOBJ::bSubtract\n");

// Since we are really pressed for speed, we special case ONE rectangle being
// subtracted.  There are only a few cases to deal with and the result always
// fits into a quantum region.

#if DBG
    for (int i = 0; i < crcl; ++i)
    {
        if ((arcl[i].left >= arcl[i].right) || (arcl[i].top >= arcl[i].bottom))
        {
            RIP("RGNOBJAPI::bSubtract - invalid rectangle from USER\n");
            arcl[i].left   = -10001;
            arcl[i].right  = -10000;
            arcl[i].top    = -10001;
            arcl[i].bottom = -10000;
        }
    }
#endif


    // Handle empty rectangles here.  Otherwise if we pass them to 
    // bSubtractComplex they can cause an AV with the sentinel case
    // (see bug 299398 for details).

    if (((ERECTL *) prcl)->bEmpty()) 
    {
        vSet();
        return TRUE;    
    }    
    
    if (crcl == 1)
    {
    // First discard total misses

        if ((arcl[0].top    >= prcl->bottom) ||
            (arcl[0].left   >= prcl->right)  ||
            (arcl[0].bottom <= prcl->top)    ||
            (arcl[0].right  <= prcl->left))
        {
            vSet(prcl);
            return(TRUE);
        }

    /*
        OK, this gets a little tricky.  There are 16 distinct ways that
        two rectangles can overlap.  In the diagram below, 1 and 2 are
        rectangle boundaries and asterisks represent areas of overlap.

        22          22222        2            22
        2*11        2***2       1*1         11*2
         1 1         1 1        1 1         1 1     TOP_NOTCH
         111         111        111         111

        22          22222        2            22
        2*11        2***2       1*1         11*2
        2* 1        2***2       1*1         1 *2    VERT_CLIP
        2*11        2***2       1*1         11*2
        22          22222        2            22

         111         111        111         111
        2* 1        2***2       1*1         1 *2    VERT_NOTCH
         111         111        111         111


         111         111        111         111
         1 1         1 1        1 1         1 1     BOTTOM_NOTCH
        2*11        2***2       1*1         11*2

     LEFT_NOTCH  HORIZ_CLIP HORIZ_NOTCH  RIGHT_NOTCH

        I have given each of the rows and columns names.  By simply finding
        out which state I'm in, I can produce the correct output region.
    */

        RECTL   rcl;
        SCAN   *pscn;
        int     iState;

        if (arcl[0].left <= prcl->left)
            iState = arcl[0].right < prcl->right ? SR_LEFT_NOTCH  : SR_HORIZ_CLIP ;
        else
            iState = arcl[0].right < prcl->right ? SR_HORIZ_NOTCH : SR_RIGHT_NOTCH;

        if (arcl[0].top <= prcl->top)
            iState += arcl[0].bottom < prcl->bottom ? SR_TOP_NOTCH  : SR_VERT_CLIP ;
        else
            iState += arcl[0].bottom < prcl->bottom ? SR_VERT_NOTCH : SR_BOTTOM_NOTCH;

        switch(iState)
        {
        // NULL case

        case SR_VERT_CLIP | SR_HORIZ_CLIP:
            vSet();
            break;

        // SINGLE cases

        case SR_TOP_NOTCH | SR_HORIZ_CLIP:
            rcl = *prcl;
            rcl.top = arcl[0].bottom;
            vSet(&rcl);
            break;

        case SR_VERT_CLIP | SR_LEFT_NOTCH:
            rcl = *prcl;
            rcl.left = arcl[0].right;
            vSet(&rcl);
            break;

        case SR_VERT_CLIP | SR_RIGHT_NOTCH:
            rcl = *prcl;
            rcl.right = arcl[0].left;
            vSet(&rcl);
            break;

        case SR_BOTTOM_NOTCH | SR_HORIZ_CLIP:
            rcl = *prcl;
            rcl.bottom = arcl[0].top;
            vSet(&rcl);
            break;

        // 2 scans (Corner notch)

        case SR_TOP_NOTCH | SR_LEFT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = arcl[0].right;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_TOP_NOTCH | SR_RIGHT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_BOTTOM_NOTCH | SR_LEFT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = arcl[0].right;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_BOTTOM_NOTCH | SR_RIGHT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        // 3 scans

        case SR_VERT_CLIP | SR_HORIZ_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 2 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 3;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 4;
            pscn->yTop = prcl->top;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = arcl[0].right;
            pscn->ai_x[3].x = prcl->right;
            pscn->ai_x[4].x = 4;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        // 4 scans (Edge notch)

        case SR_TOP_NOTCH | SR_HORIZ_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 6 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 4;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = arcl[0].right;
            pscn->ai_x[3].x = prcl->right;
            pscn->ai_x[4].x = 4;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_BOTTOM_NOTCH | SR_HORIZ_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 3 * NULL_SCAN_SIZE + 6 * sizeof(INDEX_LONG);
            prgn1->cScans = 4;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 4;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = arcl[0].right;
            pscn->ai_x[3].x = prcl->right;
            pscn->ai_x[4].x = 4;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        // 5 scans

        case SR_VERT_NOTCH | SR_HORIZ_CLIP:
            prgn1->sizeRgn = NULL_REGION_SIZE + 4 * NULL_SCAN_SIZE + 4 * sizeof(INDEX_LONG);
            prgn1->cScans = 5;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_VERT_NOTCH | SR_LEFT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 4 * NULL_SCAN_SIZE + 6 * sizeof(INDEX_LONG);
            prgn1->cScans = 5;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = arcl[0].right;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        case SR_VERT_NOTCH | SR_RIGHT_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 4 * NULL_SCAN_SIZE + 6 * sizeof(INDEX_LONG);
            prgn1->cScans = 5;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;

        // The classic toroidal region

        case SR_VERT_NOTCH | SR_HORIZ_NOTCH:
            prgn1->sizeRgn = NULL_REGION_SIZE + 4 * NULL_SCAN_SIZE + 8 * sizeof(INDEX_LONG);
            prgn1->cScans = 5;
            prgn1->rcl = *prcl;

            pscn = prgn1->pscnHead();
            pscn->cWalls = 0;
            pscn->yTop = NEG_INFINITY;
            pscn->yBottom = prcl->top;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = prcl->top;
            pscn->yBottom = arcl[0].top;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 4;
            pscn->yTop = arcl[0].top;
            pscn->yBottom = arcl[0].bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = arcl[0].left;
            pscn->ai_x[2].x = arcl[0].right;
            pscn->ai_x[3].x = prcl->right;
            pscn->ai_x[4].x = 4;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 2;
            pscn->yTop = arcl[0].bottom;
            pscn->yBottom = prcl->bottom;
            pscn->ai_x[0].x = prcl->left;
            pscn->ai_x[1].x = prcl->right;
            pscn->ai_x[2].x = 2;                    // This sets cWalls2

            pscn = pscnGet(pscn);
            pscn->cWalls = 0;
            pscn->yTop = prcl->bottom;
            pscn->yBottom = POS_INFINITY;
            pscn->ai_x[0].x = 0;                    // This sets cWalls2

            prgn1->pscnTail = pscnGet(pscn);
            break;
        }

        return(TRUE);
    }

// its complex, do it the hard way

    PREGION prgnOrg = prgn;

// lock the handle so no one can reference it while the pobj may be invalid

    OBJLOCK ol((HOBJ) hrgn_);

    BOOL b = bSubtractComplex(prcl,arcl,crcl);

    if (prgn != prgnOrg)
    {
        PVOID pv = HmgReplace((HOBJ) hrgn_,(POBJ) prgn,0,1,OBJLOCK_TYPE);
        ASSERTGDI(pv != NULL,"RGNOBJAPI::bSubtract - HmgReplace failed\n");
    }

    rl.vRet((ULONG_PTR)prgn);

    return(b);
}

/******************************Member*Function*****************************\
* RGNOBJ::bSubtractComplex()
*
*   Handle the complex cases of subtracting a list of rectangles from another
*   rectangle to generate a region.
*
*   The alogrithm used here requires that the list of rectangles is always
*   sorted by both ytop and ybottom within the range of rectangles overlaping
*   the current scan.  To have both of these true, ytop refers to the max of
*   ytop and the top of the current scan.  There is no ordering in the
*   horizontal direction.  Rectangles that fall below the current scan are still
*   sorted by top but not by bottom.  While computing a new scan, all rectangles
*   that are just being added are inserted to keep the bottoms sorted.
*
*                 ..................
*   scan 1 top -->.+-----+  +-----+.
*                 .|     |  |     |.
*                 .|     |  |     |.
*                 .|     |  |     |.  +-----+
*                 .................   |     |
*                  |     |  |     |   |     |
*                  |     |  |     |   |     |
*                  |     |  |     |   |     |
*                  |     |  |     |   |     |
*                  +-----+  |     |   |     |
*                           |     |   |     |
*                           |     |   +-----+
*                           |     |
*                           +-----+
*
*
*
*                   +-----+           +-----+
*                   |     |           |     |.
*                  ...........................
*   scan 2 top --> .|     |  +-----+  |     |.
*                  .|     |  |     |  |     |.
*                  .|     |  |     |  |     |.
*                  .|     |  |     |  |     |.
*                  .|     |  |     |  |     |.
*                  .|     |  |     |  |     |.
*                  .+-----+  |     |  |     |.
*                  ...........................
*                            +-----+  |     |
*                                     |     |
*                                     +-----+
*
*
*   To keep this ordering, a list of pointers to rectangles is used.  This reduces
*   the overhead of reordering the rectangles for each scan and reduces the amount
*   of temporary memory required.  For each scan, iFirst and iLast bracket the
*   set of rectangles intersecting the current scan.
*
*   To calculate the walls of a scan, we start assuming the entire with of the
*   dst rectangle and subtract from there.  The left to right of each rectangle
*   from iFirst to iLast is subtracted from the scan.
*
*   iFirst is update to remove any rectangles that are finished after the current
*   scan.
*
*   iLast is updated to include any new rectangles that lie in the new scan.
*
*   WARNING: If this function returns FALSE, the region may be inconsistent.
*            The caller must discard or reset the region. (See bug #343770)
*
* History:
*  26-Jul-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL RGNOBJAPI::bSubtractComplex(
    RECTL *prcl,
    RECTL *arclRemove,
    int    crcl)
{
    ASSERTGDI(crcl > 0, "Zero rectangles in RGNOBJ::bSubtract\n");
    ASSERTGDI(prcl->bottom >= prcl->top," RGNOBJ::bSubtractComplex - bottom > top\n");

// allocate array for temporary storage

    PRECTL aprclStack[100];
    PRECTL *aprcl;

    if (crcl < 100)
    {
        aprcl = aprclStack;
    }
    else
    {
        aprcl = (PRECTL *)PALLOCNOZ((sizeof(PRECTL) + 1) * crcl, 'ngrG');

        if (aprcl == NULL)
            return(FALSE);
    }

// sort the array of subtraction rectangles by yTop

    int iInsert;
    int i;

    for (i = 0; i < crcl; ++i)
    {
    // insert rect[i], search from the end so we don't do much in the
    // case of a pre-sorted list and we do the pointer copies while we
    // search backwards if it isn't sorted.

        iInsert = i;

        while (iInsert && (arclRemove[i].top < aprcl[iInsert-1]->top))
        {
            aprcl[iInsert] = aprcl[iInsert-1];
            --iInsert;
        }

        aprcl[iInsert] = &arclRemove[i];
    }

// add an extra rectangle at the end to make the end case simple

    RECTL rclLast;
    rclLast.left   = 0;
    rclLast.right  = 0;
    rclLast.top    = prcl->bottom;
    rclLast.bottom = POS_INFINITY;

    aprcl[crcl] = &rclLast;

// partialy setup the first scan, allowing for coalescing of inital empty scans

    PSCAN pscnOld = prgn->pscnHead();

    pscnOld->cWalls  = 0;
    pscnOld->yTop    = NEG_INFINITY;
    pscnOld->yBottom = POS_INFINITY;
    pscnOld->ai_x[0].x = 0;

    PSCAN pscn       = pscnGet(pscnOld);

    prgn->sizeRgn    = NULL_REGION_SIZE;
    prgn->cScans     = 1;
    prgn->rcl.left   = POS_INFINITY;
    prgn->rcl.right  = NEG_INFINITY;

// now do the real work, all rectangles in the range of iFirst to iLast
// are sorted by bottom.  To get in this range, the rectangle must intersect
// yTop.
//
// yTop    - top y value for current scan
// yBottom - bottom y value for current scan
// iFirst  - index first rectangle in current scan
// iLast   - one past index of last rectangle in current scan

    LONG yTop    = prcl->top;
    LONG yBottom = prcl->bottom;
    int  cWalls  = 0;

// throw out any easy ones

    int  iFirst  = 0;

    while (aprcl[iFirst]->bottom <= yTop)
        ++iFirst;

    int iLast = iFirst;

// while we still have scans

    do
    {
    // make sure this scan is going to have enough room, also insure enough space
    // for last scan.  The scan will never have more walls than 2 * (num rectangles + 1)

        LONG size = prgn->sizeRgn + 2 * NULL_SCAN_SIZE + 2 * sizeof(INDEX_LONG) * (crcl - iFirst + 1);

        if (size > (LONG)prgn->sizeObj)
        {
        // not big enough, grow it and be aggresive with size because growing is
        // very expensive.  Also set any fields need to grow and reset the scans
        // afterwards.

            prgn->pscnTail = pscn;

            if (!bExpand((UINT)(size + (crcl - iFirst) * (NULL_SCAN_SIZE + (crcl - iFirst) * sizeof(INDEX_LONG)))))
            {
                if (aprcl != aprclStack)
                {
                    VFREEMEM(aprcl);
                }
                return(FALSE);
            }

            pscn    = prgn->pscnTail;
            pscnOld = pscnGot(pscn);
        }

    // setup the new scan, assume the entire width of prcl

        cWalls          = 2;
        pscn->ai_x[0].x = prcl->left;
        pscn->ai_x[1].x = prcl->right;

    // check if we need to reduce the scan, do we have any overlapping rects?

        if (aprcl[iFirst]->top > yTop)
        {
        // the bottom of this scan is the top of the next rectangle

            yBottom = aprcl[iFirst]->top;
        }
        else
        {
        // assume the bottom is the bottom of the first rectangle

            yBottom = aprcl[iFirst]->bottom;

        // first find any new rectangles that fit in the new scan, and reduce
        // ybottom appropriately

            while (TRUE)
            {
            // does the next rectangle start below the current top

                if (aprcl[iLast]->top > yTop)
                {
                // stop this scan where the next rectangle starts

                    if (aprcl[iLast]->top < yBottom)
                       yBottom = aprcl[iLast]->top;

                    break;
                }

                if (aprcl[iLast]->bottom < yBottom)
                   yBottom = aprcl[iLast]->bottom;

            // perculate it backwards to keep the current rectangles sorted by yBottom

                iInsert = iLast;
                PRECTL prclTmp = aprcl[iLast];

                while ((iInsert > iFirst) && (prclTmp->bottom < aprcl[iInsert-1]->bottom))
                {
                    aprcl[iInsert] = aprcl[iInsert-1];
                    --iInsert;
                }

            // if we did some shuffling, put the rectangle in the right place.
            // It is possible to have a rectangle that completely lies above
            // the top of this scan if we are on the first scan and the top of
            // this rectangle is greater than one before it but the bottom is
            // less than the top of prcl.

                if (aprcl[iInsert]->bottom <= yTop)
                {
                // the rectangle is completely clipped away

                    ASSERTGDI(iInsert == iFirst,"bSubtractComplex - iInsert != iFirst\n");
                    ++iFirst;
                }
                else
                {
                    aprcl[iInsert] = prclTmp;
                }

                ++iLast;
            }

        // build up the scan, for each new rectangle...

            for (int irc = iFirst; irc < iLast; ++irc)
            {
                LONG xLeft  = aprcl[irc]->left;
                LONG xRight = aprcl[irc]->right;

            // merge it into the walls

                for (int iWall = 0; iWall < cWalls; iWall += 2)
                {
                // the walls are before the rectangle, nothing to do yet

                    if (xLeft >= pscn->ai_x[iWall+1].x)
                        continue;

                // the walls are passed the rectangle, done with this rectangle

                    if (xRight <= pscn->ai_x[iWall].x)
                        break;

                // compute the overlap, update the walls

                    int iHit = 0;

                    if (xLeft <= pscn->ai_x[iWall].x)
                        iHit = 1;

                    if (xRight >= pscn->ai_x[iWall+1].x)
                        iHit += 2;

                    switch (iHit)
                    {
                    case 0:
                        // completely inside the walls, insert new rectangle

                        RtlMoveMemory(&pscn->ai_x[iWall+3],&pscn->ai_x[iWall+1],
                                      (cWalls - iWall - 1) * sizeof(INDEX_LONG));
                        pscn->ai_x[iWall+1].x = xLeft;
                        pscn->ai_x[iWall+2].x = xRight;
                        cWalls += 2;
                        break;

                    case 1:
                        // overlapped the left wall, just update the left edge

                        pscn->ai_x[iWall].x = xRight;
                        break;

                    case 2:
                        // overlapped the right wall, just update the right edge

                        pscn->ai_x[iWall+1].x = xLeft;
                        break;

                    case 3:
                        // completely bounds the walls, remove rectangle

                        RtlMoveMemory(&pscn->ai_x[iWall],&pscn->ai_x[iWall+2],
                                      (cWalls - iWall - 2) * sizeof(INDEX_LONG));
                        cWalls -= 2;
                        iWall  -= 2;
                        break;
                    }
                }
            }
        }

    // make sure yBottom isn't below the original rectangle

        if (yBottom > prcl->bottom)
            yBottom = prcl->bottom;

    // Try to coalesce the current scan with the previous scan

        if (((int)pscnOld->cWalls == cWalls) &&
            !memcmp(pscnOld->ai_x, pscn->ai_x,(UINT)cWalls * sizeof(INDEX_LONG)))
        {
        // the walls are identical to the previous scan, merge them

            pscnOld->yBottom = yBottom;
        }
        else
        {
        // update the x bounds

            if (cWalls)
            {
                if (pscn->ai_x[0].x < prgn->rcl.left)
                    prgn->rcl.left = pscn->ai_x[0].x;

                if (pscn->ai_x[cWalls-1].x > prgn->rcl.right)
                     prgn->rcl.right = pscn->ai_x[cWalls-1].x;
            }

        // update the rest of the fields

            prgn->cScans++;
            pscn->cWalls = cWalls;
            prgn->sizeRgn += pscn->sizeGet();

            pscn->yTop           = yTop;
            pscn->yBottom        = yBottom;
            pscn->ai_x[cWalls].x = cWalls;

            pscnOld = pscn;
            pscn = pscnGet(pscn);
        }

    // trim off the finished rectangles

        yTop = yBottom;

        while ((iFirst < iLast) && (aprcl[iFirst]->bottom <= yTop))
            ++iFirst;

    } while (yBottom < prcl->bottom);

// set the top and bottom bounds and the last scan

    if (prgn->cScans == 1)
    {
        prgn->rcl.top    = 0;
        prgn->rcl.bottom = 0;
        prgn->rcl.left   = 0;
        prgn->rcl.right  = 0;
        pscnOld->yBottom = POS_INFINITY;
        prgn->pscnTail   = pscn;
    }
    else
    {
    // was the last scan empty?

        if (pscnOld->cWalls == 0)
        {
        // combine the final scan with the last computed scan

            pscn = pscnOld;
        }
        else
        {
        // set up any fields that wouldn't already be set by an empty scan

            pscn->yTop = pscnOld->yBottom;
            prgn->cScans++;
            pscn->cWalls    = 0;
            pscn->ai_x[0].x = 0;
            prgn->sizeRgn += pscn->sizeGet();
        }

    // set vertical bounds

        prgn->pscnHead()->yBottom = pscnGet(prgn->pscnHead())->yTop;
        prgn->rcl.top    = prgn->pscnHead()->yBottom;
        prgn->rcl.bottom = pscn->yTop;

    // setup the other region fields

        pscn->yBottom   = POS_INFINITY;
        prgn->pscnTail  = pscnGet(pscn);
    }

// if we allocated a buffer, free it

    if (aprcl != aprclStack)
        VFREEMEM(aprcl);

    return(TRUE);
}



/******************************Public*Routine******************************\
*
*   SyncRgn converts a client NULL or SIMPLE rectangle into a normal region
*   for kernel operations
*
* Arguments:
*
*   none
*
* Return Value:
*
*   BOOL
*
* History:
*
*    22-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
RGNOBJ::SyncUserRgn()
{
    BOOL bRet = FALSE;

    RGNLOG rl(prgn,"RGNOBJ::SyncUserRgn");

    if (prgn != (PREGION)NULL)
    {
        //
        // does this fine region have valid user-mode data?
        //

        PRGNATTR prRegion = (PRGNATTR)(PENTRY_FROM_POBJ(prgn)->pUser);

        if (prRegion != (PRGNATTR)NULL)
        {
            __try
            {

              if (prRegion->AttrFlags & ATTR_RGN_VALID)
              {

                  if (prRegion->AttrFlags & ATTR_RGN_DIRTY)
                  {
                      if (prRegion->Flags == NULLREGION)
                      {
                          vSet();
                          prRegion->AttrFlags &= ~ATTR_RGN_DIRTY;
                      }
                      else if (prRegion->Flags == SIMPLEREGION)
                      {
                          vSet(&prRegion->Rect);
                          prRegion->AttrFlags &= ~ATTR_RGN_DIRTY;
                      }
                  }
              }
              else
              {
                  WARNING("RGNOBJ::SyncUserRgn invalid rectregion\n");
              }

              bRet = TRUE;
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("except in RGNOBJ::SyncRgn\n");
            }
        }
    }
    return(bRet);
}

VOID
RGNOBJ::UpdateUserRgn()
{
    RGNLOG rl(prgn,"RGNOBJ::UpdateUserRgn");
    if (prgn != (PREGION)NULL)
    {
        //
        // does this fine region have valid user-mode data?
        //

        PRGNATTR prRegion = (PRGNATTR)(PENTRY_FROM_POBJ(prgn)->pUser);

        if (prRegion != (PRGNATTR)NULL)
        {
            //
            // check for DCATTR
            //

            __try
            {
                //
                // set user region complexity and bounding box
                //

                if (prRegion->AttrFlags & ATTR_RGN_VALID)
                {
                    prRegion->Flags = iComplexity();
                    prRegion->Rect = prgn->rcl;
                }
                else
                {
                    WARNING("UpdateUserRgn: Invalid region");
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("except in RGNOBJ::UpdateUserRgn\n");
            }
        }
    }
}

/******************************Public*Routine******************************\
* BOOL RGNOBJ::bValidateFramedRegion()
*
* Verify the region's integrity.  For debugging purposes only.
*
* History:
*  30-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#if DBG

#define REASONABLE      0x10000L
#define FX_REASONABLE   (0x10000L << 4)

BOOL RGNOBJ::bValidateFramedRegion()
{
#ifdef DEBUGREGIONS

    if (prgn == NULL)
        return(TRUE);       // ???

//    ASSERTGDI(prgn->rcl.left <= prgn->rcl.right &&
//              prgn->rcl.top  <= prgn->rcl.bottom, "Funky rcl");
    ASSERTGDI(prgn->pscnHead() <= prgn->pscnTail, "Funky head/tail");
    ASSERTGDI(prgn->sizeRgn <= prgn->sizeObj, "sizeRgn > sizeObj");
    ASSERTGDI((BYTE*) prgn->pscnTail <= (BYTE*) prgn + prgn->sizeObj,
              "Tail > prgn + sizeObj");
    ASSERTGDI((BYTE*) prgn->pscnTail <= (BYTE*) prgn + prgn->sizeRgn,
              "Tail > prgn + sizeRgn");
//    ASSERTGDI(prgn->cScans < REASONABLE, "cScans not reasonable");
    ASSERTGDI(prgn->cScans >= 1, "cScans < 1");

    if (prgn->cScans < 2)
        return(TRUE);

    COUNT   cScans = prgn->cScans;
    SCAN   *pscn   = prgn->pscnHead();
    LONG    yOldBottom = pscn->yBottom;

    ASSERTGDI(pscn->yTop == NEG_INFINITY, "Very yTop not NEG_INFINITY");
    ASSERTGDI(pscn->cWalls == 0, "Very top cWalls not 0");
    ASSERTGDI(pscn->ai_x[0].x == 0, "Very top cWalls2 not 0");
//    ASSERTGDI(pscn->yBottom == prgn->rcl.top, "Very top yBottom not rcl.top");

    pscn = pscnGet(pscn);
    cScans -= 2;

    while (cScans--)
    {
        LONG    iWall;
        LONG    cWalls  = pscn->cWalls;
        LONG    yTop    = pscn->yTop;
        LONG    yBottom = pscn->yBottom;
        LONG    xOld    = NEG_INFINITY;

        ASSERTGDI(pscn->ai_x[cWalls].x == cWalls, "cWalls1 != cWalls2");
        ASSERTGDI(yTop < yBottom, "Region corrupted: yTop >= yBottom");
        ASSERTGDI(yOldBottom == yTop, "Region corrupted: yOldBottom != yTop");
//        ASSERTGDI(cWalls < REASONABLE, "cWalls not reasonable");
        ASSERTGDI((cWalls & 1) == 0, "cWalls not even");
//        ASSERTGDI(yTop > -REASONABLE && yTop < REASONABLE,
//                  "yTop not reasonable");
//        ASSERTGDI(yBottom > -REASONABLE && yBottom < REASONABLE,
//                  "yBottom not reasonable");

        for (iWall = 0; iWall != cWalls; iWall++)
        {
            LONG x = xGet(pscn, (PTRDIFF) iWall);

        // Framed regions make things look weird:

            if (x > MAX_REGION_COORD)
                x -= REGION_FRAMED_OFFSET;

            ASSERTGDI(VALID_SCR(x), "Region corrupted: Invalid x");

            if (x <= xOld)
                DbgPrint("x <= xOld - pscn = %p, iWall = %lx\n",pscn,iWall);

//            ASSERTGDI(x > xOld, "Region corrupted: x <= xOld");
//            ASSERTGDI(x > -REASONABLE && x < REASONABLE, "x not reasonable");
            xOld = x;
        }

//        if (cWalls > 0)
//        {
//            ASSERTGDI(xGet(pscn, (PTRDIFF) 0) >= (prgn->rcl.left - 1),
//                      "x < rcl.left");
//            ASSERTGDI(xGet(pscn, (PTRDIFF) (cWalls - 1)) <= (prgn->rcl.right + 1),
//                      "x > rcl.right");
//        }

        yOldBottom = yBottom;
        pscn = pscnGet(pscn);

        ASSERTGDI(pscn > prgn->pscnHead() && pscn <= prgn->pscnTail,
                  "pscn out of bounds");
//        ASSERTGDI(prgn->rcl.top <= (yBottom + 1) && prgn->rcl.bottom >= (yBottom - 1),
//                 "yBottom not in rcl");
    }

    ASSERTGDI(pscn->yBottom == POS_INFINITY, "Very yBottom not POS_INFINITY");
    ASSERTGDI(pscn->cWalls == 0, "Very bottom cWalls not 0");
    ASSERTGDI(pscn->ai_x[0].x == 0, "Very bottom cWalls2 not 0");
    //ASSERTGDI(pscn->yTop == prgn->rcl.bottom, "Very bottom yTop not rcl.bottom");

#endif

    return(TRUE);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rleblt.h ===
/* rleblt.h
 *
 * Modified: 21 Oct 1992 by Gerrit van Wingerden [gerritv]
 *
 * Purpose:  Added an enumerated type and function prototypes for RLE
 *           compression routines.
 *
 * Created:  5 Mar 1992 by Andrew Milton (w-andym)
 *
 * Purpose:  Contains support macros for the RLE blt functions in
 *           <rle4blt.cxx> and <rle8blt.cxx>
 *
 * See the notes section of the above files for more info about these macros
 *
 * Contents: (The interesting macros only)
 *
 *  RLE_InitVars - Declares & initializes the variables for output position
 *                 management and source access in all RLE blt functions.
 *
 *  RLE_AssertValid - ASSERTs to verify the BLTINFO structure has good data
 *
 *  RLE_FetchVisibleRect - Declares the visible region variables & initializes
 *                         them from the BLTINFO structure
 *
 *  RLE_SetStartPos - Initializes the output position on the DIB for the RLE
 *
 *  RLE_SourceExhausted - Verifies that the source contains n more bytes.
 *
 *  RLE_GetNextCode - Fetches an RLE code.
 *
 *  RLE_NextLine - Advances to the next line of output on the destination DIB
 *
 *  RLE_PosDelta - Changes the output postion on the DIB.  The delta is
 *                 ALWAYS up the DIB, but may move left or right.
 *
 *  RLE_InVisibleRect - Checks if any portion of a run will fall inside the
 *                      visible region.
 *
 *  RLE_ForceBounds - Returns the left/(right) boundary if an output column is
 *                    before/(after) the left/(right) edge.  If the column is
 *                    inside the interval it does nothing.
 *
 *  RLE_SavePositon - Saves the current output position, source pointer,
 *                    destination pointer, and RLE bytes consumed into the
 *                    BLTINFO structure.  This information is used by
 *                    <EngCopyBits> for complex clipping optimization.
 *
 * Copyright (c) 1992-1999 Microsoft Corporation
 *
 \***************************************************************************/

/* Miscellaneous Macros *****************************************************/

#define GetLowNybble(b)  ((b) & 0x0F)

/* Byte Manipulators */

#define GetHighNybble(b) ( ( (b) & 0xF0) >> 4)
#define SetLowNybble(b, rn)  b = ( ((b) & 0xF0) | ((rn) & 0x0F) )
#define SetHighNybble(b, ln) b = ( ((b) & 0x0F) | (((ln) & 0x0F) << 4) )
#define BuildByte(ln, rn) (BYTE) ((((ln) & 0x0F) << 4) | ((rn) & 0x0F))

/* Word Manipulators */

#define GetLowByte(w)  ((w) & 0x00FF)
#define GetHighByte(w) ( ( (w) & 0xFF00) >> 8)

#define SetLowByte(w, b)  w = ( ((w) & 0xFF00) | ((b) & 0x00FF) )
#define SetHighByte(w, b) w = ( ((w) & 0x00FF) | (((b) & 0x00FF) << 4) )


#define RollLeft(x)  ( ((x) & 0x80) ? ((x) << 1) | 0x01 : (x) << 1 )

#define RollRight(x) ( ((x) & 0x01) ? ((x) >> 1) | 0x80 : (x) >> 1 )

#define SwapValues(x, y) (x) ^= (y); \
                         (y) ^= (x); \
                         (x) ^= (y);

/****************************************************************************
 *
 *  RLE4_MakeColourBlock - Unpacks & translates a packed byte of 2 colours
 *                         into an array
 *
 *  RLE4_MakePackedWord  - Unpacks & translates a packed byte of 2 colours
 *                         into 8 Bits/Pel and packs them into a word
 *
 *  RLE4_MakePackedDWord - Unpacks & translates a packed byte of 2 colours
 *                         into 16 Bits/Pel and packs them into a double word
 *
 *  RLE4_AlignToWord  - Verifies all bytes of an Absolute run exist in the
 *                      source & sets a flag if the run does not end on a
 *                      word boundary.
 *
 *  RLE4_FixAlignment - Forces the source pointer to a word boundary if the
 *                      flag was set by <RLE4_AlignToWord>
 *
 ****************************************************************************/

/* Source Byte Unpacking ****************************************************/

#define RLE4_MakeColourBlock(PackedColours, ColourBlock,  Type, Trans)       \
    ColourBlock[0] = (Type) Trans[GetHighNybble(PackedColours)];             \
    ColourBlock[1] = (Type) Trans[GetLowNybble(PackedColours)];              \

#define RLE4_MakePackedWord(PackedColours, PackedWord, Trans)                \
    PackedWord  = (( (WORD) Trans[GetHighNybble(PackedColours)] ) << 8);     \
    PackedWord |=  ( (WORD) Trans[GetLowNybble(PackedColours)]  );           \

#define RLE4_MakePackedDWord(PackedColours, PackedDWord, Trans)              \
    PackedDWord  = (( Trans[GetHighNybble(PackedColours)] ) << 16);          \
    PackedDWord |=  ( Trans[GetLowNybble(PackedColours)]  );                 \

/* Source Alignment Macros **************************************************/

#define RLE4_ByteLength(RunLength) ((RunLength + 1) >> 1)

#define RLE4_AlignToWord(SrcPtr, RunLength)                                  \
     ulNotAligned = ((1 + RunLength) >> 1) & 1;

#define RLE4_FixAlignment(SrcPtr)                                            \
    ulSrcIndex += ulNotAligned;                                              \
    SrcPtr += ulNotAligned;                                                  

/****************************************************************************
 *
 *  RLE8_AbsClipLeft - Forces an Absolute run to start at the left edge of
 *                     the visible region when the current output column is
 *                     before the left edge.
 *
 *  RLE8_EncClipLeft - Forces an Encoded run to start at the left edge of
 *                     the visible region when the current output column is
 *                     before the left edge.
 *
 *  RLE8_AbsClipLeft - Forces any run to end at the right edge of the visible
 *                     region when it extends beyond the right edge
 *
 *  RLE8_AlignToWord - Verifies all bytes of an Absolute run exist in the
 *                     source & sets a flag if the run does not end on a
 *                     word boundary.
 *
 *  RLE8_FixAlignment - Forces the source pointer to a word boundary if
 *                      the flag was set by <RLE8_AlignToWord>
 *
 ****************************************************************************/

/* Clipping Macros  *********************************************************/

#define RLE8_AbsClipLeft(SrcPtr, IndentAmount, RunLength, OutColumn)         \
    if (OutColumn < (LONG)ulDstLeft)                                         \
    {                                                                        \
        IndentAmount = ulDstLeft - OutColumn;                                \
        OutColumn    = ulDstLeft;                                            \
        SrcPtr      += IndentAmount;                                         \
        RunLength   -= IndentAmount;                                         \
    }

#define RLE8_EncClipLeft(IndentAmount, RunLength, OutColumn)                 \
    if (OutColumn < (LONG)ulDstLeft)                                         \
    {                                                                        \
        IndentAmount = ulDstLeft - OutColumn;                                \
        RunLength    -= IndentAmount;                                        \
        OutColumn    += IndentAmount;                                        \
    }                                                                        \

#define RLE8_ClipRight(OverRun, RunLength, OutColumn)                        \
    if ((OutColumn + (LONG) RunLength) > (LONG)ulDstRight)                          \
    {                                                                        \
        OverRun = (OutColumn + RunLength) - ulDstRight;                      \
        RunLength -= OverRun;                                                \
    } else                                                                   \
        OverRun = 0;                                                         \

/* Source Alignment Macros **************************************************/

#define RLE8_AlignToWord(SrcPtr, RunLength)                                  \
     ulNotAligned = RunLength & 1;                                           \

#define RLE8_FixAlignment(SrcPtr)                                            \
    ulSrcIndex += ulNotAligned;                                              \
    SrcPtr += ulNotAligned;                                                  





#define LOOP_FOREVER   while(1)
#define bIsOdd(x) ((x) & 1)
#define BoundsCheck(a, b, x) ( ((x) >= (a)) ? ( ((x) <= (b)) ? (x) : (b) )   \
                                            : (a) )
/* Startup and Initialization Macros ****************************************/

#define RLE_InitVars(BI, Source, Dest, DstType, Count, Colour, \
                    OutColumn, Xlate)                          \
    LONG   OutColumn;  /* Offest from <pjDst> to get to the output column */ \
    LONG   lOutRow;    /* Output scanline                                 */ \
                                                                             \
    ULONG  Count;      /* First byte of an RLE code                       */ \
    ULONG  Colour;     /* Second byte of an RLE code                      */ \
                                                                             \
    PBYTE Source = (BI)->pjSrc; /* Current location into the source RLE   */ \
    DstType Dest = (DstType)(BI)->pjDst; /* Beginning of crnt. out line   */ \
    LONG lDeltaDst = (BI)->lDeltaDst / (LONG)sizeof(Dest[0]);                \
                                                                             \
    ULONG  ulSrcIndex  = (BI)->ulConsumed;                                   \
    ULONG  ulSrcLength = (BI)->pdioSrc->cjBits();                            \
                                                                             \
    PULONG Xlate = (BI)->pxlo->pulXlate;                                     \
                                                                             \
    ULONG ulNotAligned;                                                      \

#define RLE_AssertValid(BI)                                                  \
    ASSERTGDI((BI)->xDir == 1,  "RLE4 - direction not left to right");       \
    ASSERTGDI((BI)->yDir == -1, "RLE4 - direction not up to down");          \
    ASSERTGDI((BI)->lDeltaSrc == 0, "RLE - lDeltaSrc not 0");                \
    ASSERTGDI(pulXlate != (PULONG) NULL, "ERROR pulXlate NULL in RLE");      \

#define RLE_FetchVisibleRect(BI)                                             \
    /* Fetch the visible region boundaries of the passed structure */        \
    ULONG ulDstLeft   = (BI)->rclDst.left;                                   \
    ULONG ulDstRight  = (BI)->rclDst.right;                                  \
    ULONG ulDstTop    = (BI)->rclDst.top;                                    \
    ULONG ulDstBottom = (BI)->rclDst.bottom;                                 \

#define RLE_SetStartPos(BI, InitialColumn)                                   \
    /* Initialize the starting positions */                                  \
    LONG lDstStart = (BI)->xDstStart;                                        \
    InitialColumn  = (BI)->ulOutCol;                                         \
    lOutRow        = (LONG) (BI)->yDstStart;                                 \

/* Source Access ************************************************************/

#define RLE_SourceExhausted(Count)                                           \
    ((ulSrcIndex += (Count)) > ulSrcLength)

#define RLE_GetNextCode(SrcPtr, Count, Colour)                               \
    Count = (ULONG) *(SrcPtr++);                                             \
    Colour = (ULONG) *(SrcPtr++);                                            \

/* Output Position Change Macros ********************************************/

#define RLE_NextLine(DstType, DstPtr, OutColumn)                             \
    /*  Goto the next row */                                                 \
    DstPtr += lDeltaDst;                                                     \
    OutColumn  = lDstStart;                                                  \
    lOutRow -= 1;                                                            \

#define RLE_PosDelta(DstPtr, OutColumn, ColDelta, RowDelta)                  \
    OutColumn += ColDelta;                                                   \
    DstPtr += (LONG) (RowDelta) * lDeltaDst;                                 \
    lOutRow -= RowDelta;                                                     \

/* Visability Check Macros **************************************************/

#define RLE_InVisibleRect(RunLength, OutColumn)                              \
    ((lOutRow < (LONG) ulDstBottom) &&                                       \
     ((OutColumn) < (LONG)ulDstRight)  &&                                    \
     (((OutColumn) + (LONG) (RunLength)) > (LONG) ulDstLeft))                        \

#define RLE_RowVisible ( (lOutRow < (LONG) ulDstBottom)                      \
                      && (lOutRow >= (LONG) ulDstTop) )

#define RLE_ColVisible(Col) ( ( (Col) >= (LONG) ulDstLeft  )                 \
                           && ( (Col) <  (LONG) ulDstRight ) )

#define RLE_ForceBounds(Col) BoundsCheck(ulDstLeft, ulDstRight, Col)

#define RLE_PastRightEdge(Col) ((Col) >= (LONG) ulDstRight)

#define RLE_PastTopEdge  (lOutRow < (LONG) ulDstTop)

/* Ending Macro *************************************************************/

#define RLE_SavePosition(BI, SrcPtr, DstPtr, OutColumn)                      \
    (BI)->ulEndConsumed = ulSrcIndex;                                        \
    (BI)->pjSrcEnd = (SrcPtr);                                               \
    (BI)->pjDstEnd = (PBYTE) (DstPtr);                                       \
    (BI)->ulEndCol = (OutColumn);                                            \
    (BI)->ulEndRow = (ULONG) lOutRow;



enum RLE_TYPE { RLE_START, RLE_ABSOLUTE, RLE_ENCODED };
int EncodeRLE8( BYTE*, BYTE *, UINT, UINT, UINT );
int EncodeRLE4( BYTE*, BYTE*, UINT, UINT, UINT );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rotate.cxx ===
/******************************Module*Header*******************************\
* Module Name: rotate.cxx
*
* Internal DDAs for EngPlgBlt
*
* Created: 06-Aug-1992 15:35:02
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1992-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "rotate.hxx"

#ifdef DBG_PLGBLT
extern BOOL gflPlgBlt;
#endif

int aiPlgConst[][6] = {
    {  1,  0,  0,  0,  1,  0 },
    {  0,  1,  0,  1,  0,  0 },
    { -1,  0,  1,  0,  1,  0 },
    {  0,  1,  0, -1,  0,  1 },
    {  0, -1,  1,  1,  0,  0 },
    {  1,  0,  0,  0, -1,  1 },
    {  0, -1,  1, -1,  0,  1 },
    { -1,  0,  1,  0, -1,  1 }
};

int aiPlgSort[][4] = {
    {  0,  1,  2,  3 },
    {  0,  2,  1,  3 },
    {  1,  0,  3,  2 },
    {  1,  3,  0,  2 },
    {  2,  0,  3,  1 },
    {  2,  3,  0,  1 },
    {  3,  1,  2,  0 },
    {  3,  2,  1,  0 }
};

static VOID ROT_DIV(
DIV_T *pdt,
LONG   lNum,
LONG   lDen)
{
    pdt->lQuo = lNum / lDen;
    pdt->lRem = lNum % lDen;

    if (pdt->lRem < 0)
    {
	pdt->lQuo -= 1;
	pdt->lRem += lDen;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("%ld / %ld = %ld R %ld\n", lNum, lDen, pdt->lQuo, pdt->lRem);
#endif
}

static VOID QDIV(
DIV_T *pdt,
LONGLONG *peqNum,
LONG   lDen)
{
    ULONGLONG       liQuo;
    ULONG	    ul;
    BOOL	    bSigned;

    bSigned = *peqNum < 0;

    if (bSigned)
    {
        liQuo =  (ULONGLONG) (- (LONGLONG) *peqNum);
    }
    else
	liQuo = *peqNum;

    pdt->lQuo = DIVREM(liQuo, lDen, &ul);

    if (bSigned)
    {
	pdt->lQuo = - pdt->lQuo;
	if (ul == 0)
	    pdt->lRem = 0;
	else
	{
	    pdt->lQuo -= 1;
	    pdt->lRem  = lDen - ((LONG) ul);
	}
    }
    else
    {
	pdt->lRem = (LONG) ul;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("%ld,%ld / %ld = %ld R %ld\n", peqNum->HighPart, peqNum->LowPart, lDen, pdt->lQuo, pdt->lRem);
#endif
}

/******************************Public*Routine******************************\
* VOID vInitPlgDDA(pdda, pptl)
*
* Initialize the DDA
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL bInitPlgDDA(
PLGDDA	 *pdda,
RECTL	 *prclScan,
RECTL	 *prcl,
POINTFIX *pptfx)
{
    POINTFIX	aptfx[4];
    RECTL	rclScan;
    RECTL	rcl;

    aptfx[0]   = pptfx[0];
    aptfx[1]   = pptfx[1];
    aptfx[2]   = pptfx[2];
    aptfx[3].x = aptfx[1].x + aptfx[2].x - aptfx[0].x;
    aptfx[3].y = aptfx[1].y + aptfx[2].y - aptfx[0].y;

// If the source surface does not have a 0,0 origin, deal with it here.

    if ((prcl->left != 0) || (prcl->top != 0))
    {
	rclScan.left   = prclScan->left	  - prcl->left;
	rclScan.top    = prclScan->top	  - prcl->top;
	rclScan.right  = prclScan->right  - prcl->left;
	rclScan.bottom = prclScan->bottom - prcl->top;
	prclScan = &rclScan;

	rcl.left   = 0;
	rcl.top    = 0;
	rcl.right  = prcl->right - prcl->left;
	rcl.bottom = prcl->bottom - prcl->top;
	prcl = &rcl;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
    {
	DbgPrint("prclScan = [(%ld,%ld) (%ld,%ld)]\n",
		  prclScan->left, prclScan->top, prclScan->right, prclScan->bottom);

	DbgPrint("prcl = [(%ld,%ld) (%ld,%ld)]\n",
		  prcl->left, prcl->top, prcl->right, prcl->bottom);

	DbgPrint("aptfx[0] = (%ld,%ld)\n", aptfx[0].x, aptfx[0].y);
	DbgPrint("aptfx[1] = (%ld,%ld)\n", aptfx[1].x, aptfx[1].y);
	DbgPrint("aptfx[2] = (%ld,%ld)\n", aptfx[2].x, aptfx[2].y);
	DbgPrint("aptfx[3] = (%ld,%ld)\n", aptfx[3].x, aptfx[3].y);
    }
#endif

    int iTop  = (aptfx[1].y > aptfx[0].y) == (aptfx[1].y > aptfx[3].y);
    int iCase;

    if (aptfx[iTop].y > aptfx[iTop ^ 3].y)
	iTop ^= 3;

    switch (iTop) {
    case 0:
	if (aptfx[1].y < aptfx[2].y)
	    iCase = 0;
	else
	    if (aptfx[1].y > aptfx[2].y)
		iCase = 1;
	    else
		if (aptfx[1].x < aptfx[2].x)
		    iCase = 0;
		else
		    iCase = 1;
	break;

    case 1:
	if (aptfx[0].y < aptfx[3].y)
	    iCase = 2;
	else
	    if (aptfx[0].y > aptfx[3].y)
		iCase = 3;
	    else
		if (aptfx[0].x < aptfx[3].x)
		    iCase = 2;
		else
		    iCase = 3;
	break;

    case 2:
	if (aptfx[0].y < aptfx[3].y)
	    iCase = 4;
	else
	    if (aptfx[0].y > aptfx[3].y)
		iCase = 5;
	    else
		if (aptfx[0].x < aptfx[3].x)
		    iCase = 4;
		else
		    iCase = 5;
	break;

    case 3:
	if (aptfx[1].y < aptfx[2].y)
	    iCase = 6;
	else
	    if (aptfx[1].y > aptfx[2].y)
		iCase = 7;
	    else
		if (aptfx[1].x < aptfx[2].x)
		    iCase = 6;
		else
		    iCase = 7;
	break;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("iTop = %ld, iCase = %ld\n", iTop, iCase);
#endif

    LONG    DELTA_1;
    LONG    DELTA_2;

    switch (iCase) {
    case 0:
    case 2:
    case 5:
    case 7:
	DELTA_1 = prcl->right - prcl->left;
	DELTA_2 = prcl->bottom - prcl->top;
	break;

    case 1:
    case 3:
    case 4:
    case 6:
	DELTA_1 = prcl->bottom - prcl->top;
	DELTA_2 = prcl->right - prcl->left;
	break;
    }

    LONG    ci1 = aiPlgConst[iCase][0];
    LONG    cj1 = aiPlgConst[iCase][1];
    LONG    c1	= aiPlgConst[iCase][2];
    LONG    ci2 = aiPlgConst[iCase][3];
    LONG    cj2 = aiPlgConst[iCase][4];
    LONG    c2	= aiPlgConst[iCase][5];

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("Global constants: %ld %ld %ld %ld %ld %ld %ld %ld\n",
		 DELTA_1, DELTA_2, ci1, cj1, c1, ci2, cj2, c2);
#endif

    LONG    V1 = ci1 * prclScan->left + cj1 * prclScan->top + c1 * (DELTA_1 - 1);
    LONG    V2 = ci2 * prclScan->left + cj2 * prclScan->top + c2 * (DELTA_2 - 1);

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("V1 = %ld, V2 = %ld\n", V1, V2);
#endif

    LONG I0 = aptfx[aiPlgSort[iCase][0]].x;
    LONG J0 = aptfx[aiPlgSort[iCase][0]].y;
    LONG I1 = aptfx[aiPlgSort[iCase][1]].x;
    LONG J1 = aptfx[aiPlgSort[iCase][1]].y;
    LONG I2 = aptfx[aiPlgSort[iCase][2]].x;
    LONG J2 = aptfx[aiPlgSort[iCase][2]].y;
    LONG I3 = aptfx[aiPlgSort[iCase][3]].x;
    LONG J3 = aptfx[aiPlgSort[iCase][3]].y;

    I1 -= I0;
    I2 -= I0;
    I3 -= I0;

    J1 -= J0;
    J2 -= J0;
    J3 -= J0;

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
    {
	DbgPrint("I0, I1, I2, I3 = %8ld %8ld %8ld %8ld\n", I0, I1, I2, I3);
	DbgPrint("J0, J1, J2, J3 = %8ld %8ld %8ld %8ld\n", J0, J1, J2, J3);
    }
#endif

    LONG    X1 = DELTA_2 * I1;
    LONG    Y1 = DELTA_2 * J1;

    LONG    X2 = DELTA_1 * I2;
    LONG    Y2 = DELTA_1 * J2;

// avoid divide by 0's.  In some way shape or form, all divides are based on
// these two values.  Note that by checking Y2, DELTA_1 is also validated.  We
// can't just validate Y1 as well because it is special cased below to be 0.
// Also beware of overflows given large numbers where multipications can
// potentially shift off all set bits leaving you with a zero value. In the case
// where we just lose bits but don't end up with all zeros we will have
// undefined but non-exception (divide by zero) behavior

    if ((Y2 == 0) || (DELTA_2 == 0))
        return(FALSE);
    
    LONG    T = DELTA_1 * DELTA_2;

    LONGLONG N = Int32x32To64(T, (J0 + 16));
    LONGLONG eqTmp = Int32x32To64(V1, Y1);

    N += eqTmp;
    eqTmp = Int32x32To64(V2, Y2);
    N += eqTmp;
    N -= 1;

//  LONG    N = T * (J0 + 16) + V1 * Y1 + V2 * Y2 - 1;

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
    {
	DbgPrint("X1 = %ld, Y1 = %ld, X2 = %ld, Y2 = %ld\n", X1, Y1, X2, Y2);
	DbgPrint("T = %ld, N = %ld,%ld\n", T, N.HighPart, N.LowPart);
    }
#endif

    T *= 16;
// overflow check: avoid divide by 0's
    if ( T == 0 )
        return(FALSE);

    DDA_STEP	dp1;
    DDA_STEP	dp2;

    ROT_DIV(&dp1.dt, Y1, T);
    dp1.lDen = T;

    ROT_DIV(&dp2.dt, Y2, T);
    dp2.lDen = T;

    QDIV(&pdda->ds.dt0, &N, T);

    pdda->ds.dt1 = pdda->ds.dt0;
    DDA(&pdda->ds.dt1, &dp1)

    pdda->ds.dt2 = pdda->ds.dt0;
    DDA(&pdda->ds.dt2, &dp2)

    pdda->ds.dt3 = pdda->ds.dt2;
    DDA(&pdda->ds.dt3, &dp1)

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
    {
	DbgPrint("N0, N1, N2, N3 = %8ld %8ld %8ld %8ld\n",
		  pdda->ds.dt0.lQuo, pdda->ds.dt1.lQuo, pdda->ds.dt2.lQuo, pdda->ds.dt3.lQuo);

	DbgPrint("R0, R1, R2, R3 = %8ld %8ld %8ld %8ld\n",
		  pdda->ds.dt0.lRem, pdda->ds.dt1.lRem, pdda->ds.dt2.lRem, pdda->ds.dt3.lRem);
    }
#endif

    ROT_DIV(&pdda->dp0_i.dt, ci1 * Y1 + ci2 * Y2, T);
    pdda->dp0_i.lDen = T;
    pdda->dp1_i = pdda->dp0_i;
    pdda->dp2_i = pdda->dp0_i;
    pdda->dp3_i = pdda->dp0_i;

    ROT_DIV(&pdda->dp0_j.dt, cj1 * Y1 + cj2 * Y2, T);
    pdda->dp0_j.lDen = T;
    pdda->dp1_j = pdda->dp0_j;
    pdda->dp2_j = pdda->dp0_j;
    pdda->dp3_j = pdda->dp0_j;

    LONGLONG Q = Int32x32To64(I1, J2);
    eqTmp = Int32x32To64(J1, I2);
    Q -= eqTmp;

//  LONG    Q = I1 * J2 - J1 * I2;

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_INIT)
	DbgPrint("Q = %ld,%ld\n", Q.HighPart, Q.LowPart);
#endif

    DIV_T   dt1;
    DIV_T   dt2;

//overflow check: avoid divide by 0's
    if ((16 * DELTA_1) == 0 || (16 * DELTA_2) == 0)
        return(FALSE);
    
    ROT_DIV(&dt1, ci1 * J1, 16 * DELTA_1);
    ROT_DIV(&dt2, ci2 * J2, 16 * DELTA_2);

    LONG    dn_i = dt1.lQuo + dt2.lQuo;

    ROT_DIV(&dt1, cj1 * J1, 16 * DELTA_1);
    ROT_DIV(&dt2, cj2 * J2, 16 * DELTA_2);

    LONG    dn_j = dt1.lQuo + dt2.lQuo;

    if (Y1 == 0)
    {
	pdda->dp01.dt.lQuo = 0;
	pdda->dp01.dt.lRem = 0;
	pdda->dp01.lDen    = 0;

	pdda->dp01_i.dt.lQuo = 0;
	pdda->dp01_i.dt.lRem = 0;
	pdda->dp01_i.lDen    = 0;

	pdda->dp01_j.dt.lQuo = 0;
	pdda->dp01_j.dt.lRem = 0;
	pdda->dp01_j.lDen    = 0;

	pdda->ds.dt01.lQuo = 0;
	pdda->ds.dt01.lRem = 0;
	pdda->ds.dt23.lQuo = 0;
	pdda->ds.dt23.lRem = 0;

	pdda->dpP01.dt.lQuo = 0;
	pdda->dpP01.dt.lRem = 0;
	pdda->dpP01.lDen    = 0;
    }
    else
    {
	N= Int32x32To64(X1, 16 * pdda->ds.dt0.lQuo - J0);
	eqTmp= Int32x32To64(Y1, (I0 + 16));
	N += eqTmp;
	eqTmp= Int32x32To64(V2, I1 * J2);
	N -= eqTmp;
	eqTmp= Int32x32To64(V2, I2 * J1);
	N += eqTmp;
	N -= 1;

//	N = X1 * (16 * pdda->ds.dt0.lQuo - J0) + Y1 * (I0 + 16) - V2 * Q - 1;

	pdda->dp01.lDen   = 16 * Y1;
	pdda->dp01_i.lDen = pdda->dp01.lDen;
	pdda->dp01_j.lDen = pdda->dp01.lDen;

// overflow check: avoid divide by 0's.
        if (pdda->dp01.lDen == 0)
            return(FALSE);

	QDIV(&pdda->ds.dt01, &N, pdda->dp01.lDen);

	eqTmp= Int32x32To64(16 * X1, pdda->ds.dt2.lQuo - pdda->ds.dt0.lQuo);
	eqTmp -= Q;
	N += eqTmp;

//	N += 16 * X1 * (pdda->ds.dt2.lQuo - pdda->ds.dt0.lQuo) - Q;

	QDIV(&pdda->ds.dt23, &N, pdda->dp01.lDen);

	ROT_DIV(&pdda->dp01.dt, 16 * X1, pdda->dp01.lDen);

	N= Int32x32To64(ci2 * I1,J2);
	eqTmp= Int32x32To64(ci2 * I2, J1);
	N -= eqTmp;	// Q * ci2
	eqTmp= Int32x32To64(16 * dn_i, X1);
	eqTmp -= N;
	QDIV(&pdda->dp01_i.dt, &eqTmp, pdda->dp01_i.lDen);

	N= Int32x32To64(cj2 * I1,J2);
	eqTmp= Int32x32To64(cj2 * I2, J1);
	N -= eqTmp;	// Q * cj2
	eqTmp= Int32x32To64(16 * dn_j, X1);
	eqTmp -= N;
	QDIV(&pdda->dp01_j.dt, &eqTmp, pdda->dp01_j.lDen);

//	ROT_DIV(&pdda->dp01_i.dt, 16 * X1 * dn_i - ci2 * Q, pdda->dp01_i.lDen);
//	ROT_DIV(&pdda->dp01_j.dt, 16 * X1 * dn_j - cj2 * Q, pdda->dp01_j.lDen);

// overflow check: avoid divide by 0's
// 16*Y1 was already checked above computing pdda->dp01.lDen       
	ROT_DIV(&pdda->dpP01.dt, 16 * X1, 16 * Y1);
	pdda->dpP01.lDen = 16 * Y1;
    }

    N= Int32x32To64(X2, 16 * pdda->ds.dt0.lQuo - J0);
    eqTmp= Int32x32To64(Y2, I0 + 16);
    N += eqTmp;
    eqTmp= Int32x32To64(V1, I1 * J2);
    N += eqTmp;
    eqTmp= Int32x32To64(V1, I2 * J1);
    N -= eqTmp;
    N -= 1;

//  N = Y1 * (16 * pdda->ds.dt0.lQuo - J0) + Y2 * (I0 + 16) + V1 * Q - 1;

    pdda->dp02.lDen   = 16 * Y2;
    pdda->dp02_i.lDen = pdda->dp02.lDen;
    pdda->dp02_j.lDen = pdda->dp02.lDen;

// overflow check: avoid divide by 0's.
    if (pdda->dp02.lDen == 0)
        return(FALSE);
        
    QDIV(&pdda->ds.dt02, &N, pdda->dp02.lDen);

    eqTmp= Int32x32To64(16 * X2, pdda->ds.dt1.lQuo - pdda->ds.dt0.lQuo);
    eqTmp += Q;
    N += eqTmp;

//  N += 16 * Y1 * (pdda->ds.dt1.lQuo - pdda->ds.dt0.lQuo) + Q;

    QDIV(&pdda->ds.dt13, &N, pdda->dp02.lDen);

    ROT_DIV(&pdda->dp02.dt, 16 * X2, pdda->dp02.lDen);

    N= Int32x32To64(ci1 * I1,J2);
    eqTmp= Int32x32To64(ci1 * I2, J1);
    N -= eqTmp; 	// Q * ci1
    eqTmp= Int32x32To64(16 * dn_i, X2);
    eqTmp += N;
    QDIV(&pdda->dp02_i.dt, &eqTmp, pdda->dp02_i.lDen);

    N= Int32x32To64(cj1 * I1,J2);
    eqTmp= Int32x32To64(cj1 * I2, J1);
    N -= eqTmp; 	// Q * cj1
    eqTmp= Int32x32To64(16 * dn_j, X2);
    eqTmp += N;
    QDIV(&pdda->dp02_j.dt, &eqTmp, pdda->dp02_j.lDen);

//  DIV(&pdda->dp02_i.dt, 16 * X2 * dn_i + ci1 * Q, pdda->dp02_i.lDen);
//  DIV(&pdda->dp02_j.dt, 16 * X2 * dn_j + cj1 * Q, pdda->dp02_j.lDen);

    pdda->dp13	 = pdda->dp02;
    pdda->dp13_i = pdda->dp02_i;
    pdda->dp13_j = pdda->dp02_j;

    pdda->dp23	 = pdda->dp01;
    pdda->dp23_i = pdda->dp01_i;
    pdda->dp23_j = pdda->dp01_j;

// overflow check: avoid divide by 0's
// 16*Y2 was already checked above computing pdda->dp02.lDen
    ROT_DIV(&pdda->dpP02.dt, 16 * X2, 16 * Y2);
    pdda->dpP02.lDen = 16 * Y2;

    return(TRUE);
}

/******************************Public*Routine******************************\
* LONG lSizeDDA(pdda)
*
* Return the space needed to run the DDA for a scan
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

LONG lSizeDDA(PLGDDA *pdda)
{
    LONG dt[4];
    LONG max, min, i;
    
    // Bug #336058:
    // Prior to this fix, this function assumed that dt0 contains the
    // top-most vertex and dt3 contains the bottom-most vertex in the
    // parallelogram.  However, under some calls to EngPlgBlt this appears
    // to not be true (the bug includes a test program that can
    // demonstrate this).  That caused the allocated buffer to not be large
    // enough which resulted in an AV (i.e. when doing the run from dt1
    // to dt2).  The fix is to find the smallest and largest vertices (with
    // respect to y-values) and allocate enough space for a run from the
    // smallest to the largest.

    dt[0] = pdda->ds.dt0.lQuo;
    dt[1] = pdda->ds.dt1.lQuo;
    dt[2] = pdda->ds.dt2.lQuo;
    dt[3] = pdda->ds.dt3.lQuo;
        
    max = min = dt[0];
    for (i=1; i<4; i++) 
    {
        if (min > dt[i]) 
        {
            min = dt[i];
        }

        if (max < dt[i]) 
        {
            max = dt[i];
        }
    }
    
    //LONG    lTmp = pdda->ds.dt3.lQuo - pdda->ds.dt0.lQuo;
    LONG lTmp = max-min;

    if (lTmp == 0)
	lTmp = 1;

    return((lTmp + 4) * sizeof(CNTPOS) + sizeof(ULONG));
}

/******************************Public*Routine******************************\
* VOID vAdvXDDA(pdda)
*
* Advance the DDA in X.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vAdvXDDA(PLGDDA *pdda)
{
    pdda->dsX.dt0.lQuo += pdda->dp0_i.dt.lQuo;
    pdda->dsX.dt0.lRem += pdda->dp0_i.dt.lRem;
    if (pdda->dsX.dt0.lRem >= pdda->dp0_i.lDen)
    {
	pdda->dsX.dt0.lRem -= pdda->dp0_i.lDen;
	pdda->dsX.dt0.lQuo++;
	DDA(&pdda->dsX.dt01, &pdda->dpP01);
	DDA(&pdda->dsX.dt02, &pdda->dpP02);
    }

    pdda->dsX.dt1.lQuo += pdda->dp1_i.dt.lQuo;
    pdda->dsX.dt1.lRem += pdda->dp1_i.dt.lRem;
    if (pdda->dsX.dt1.lRem >= pdda->dp1_i.lDen)
    {
	pdda->dsX.dt1.lRem -= pdda->dp1_i.lDen;
	pdda->dsX.dt1.lQuo++;
	DDA(&pdda->dsX.dt13, &pdda->dpP02);
    }

    pdda->dsX.dt2.lQuo += pdda->dp2_i.dt.lQuo;
    pdda->dsX.dt2.lRem += pdda->dp2_i.dt.lRem;
    if (pdda->dsX.dt2.lRem >= pdda->dp2_i.lDen)
    {
	pdda->dsX.dt2.lRem -= pdda->dp2_i.lDen;
	pdda->dsX.dt2.lQuo++;
	DDA(&pdda->dsX.dt23, &pdda->dpP01);
    }

    DDA(&pdda->dsX.dt3, &pdda->dp3_i);

    DDA(&pdda->dsX.dt01, &pdda->dp01_i);
    DDA(&pdda->dsX.dt02, &pdda->dp02_i);
    DDA(&pdda->dsX.dt13, &pdda->dp13_i);
    DDA(&pdda->dsX.dt23, &pdda->dp23_i);
}

/******************************Public*Routine******************************\
* VOID vAdvYDDA(pdda)
*
* Advance the DDA in Y.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vAdvYDDA(PLGDDA *pdda)
{
    pdda->ds.dt0.lQuo += pdda->dp0_j.dt.lQuo;
    pdda->ds.dt0.lRem += pdda->dp0_j.dt.lRem;
    if (pdda->ds.dt0.lRem >= pdda->dp0_j.lDen)
    {
	pdda->ds.dt0.lRem -= pdda->dp0_j.lDen;
	pdda->ds.dt0.lQuo++;
	DDA(&pdda->ds.dt01, &pdda->dpP01);
	DDA(&pdda->ds.dt02, &pdda->dpP02);
    }

    pdda->ds.dt1.lQuo += pdda->dp1_j.dt.lQuo;
    pdda->ds.dt1.lRem += pdda->dp1_j.dt.lRem;
    if (pdda->ds.dt1.lRem >= pdda->dp1_j.lDen)
    {
	pdda->ds.dt1.lRem -= pdda->dp1_j.lDen;
	pdda->ds.dt1.lQuo++;
	DDA(&pdda->ds.dt13, &pdda->dpP02);
    }

    pdda->ds.dt2.lQuo += pdda->dp2_j.dt.lQuo;
    pdda->ds.dt2.lRem += pdda->dp2_j.dt.lRem;
    if (pdda->ds.dt2.lRem >= pdda->dp2_j.lDen)
    {
	pdda->ds.dt2.lRem -= pdda->dp2_j.lDen;
	pdda->ds.dt2.lQuo++;
	DDA(&pdda->ds.dt23, &pdda->dpP01);
    }

    DDA(&pdda->ds.dt3, &pdda->dp3_j);
    DDA(&pdda->ds.dt01, &pdda->dp01_j);
    DDA(&pdda->ds.dt02, &pdda->dp02_j);
    DDA(&pdda->ds.dt13, &pdda->dp13_j);
    DDA(&pdda->ds.dt23, &pdda->dp23_j);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPumpDDA(pdda, prun)
*
* 'Pump' out the target point run for the source point.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPumpDDA(
PLGDDA *pdda,
PLGRUN *prun)
{
    DIV_T     dt01 = pdda->dsX.dt01;
    DIV_T     dt02 = pdda->dsX.dt02;
    DIV_T     dt13 = pdda->dsX.dt13;
    DIV_T     dt23 = pdda->dsX.dt23;
    CNTPOS   *pcp;
    LONG      n    = pdda->dsX.dt0.lQuo;

    prun->cpY.iPos = n;
    pcp = &prun->cpX[0];

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_PUMP)
    {
	DbgPrint("Pumping pel\n");
	DbgPrint("N0 = %ld\n", n);
	DbgPrint("N1 = %ld\n", pdda->dsX.dt1.lQuo);
	DbgPrint("N2 = %ld\n", pdda->dsX.dt2.lQuo);
	DbgPrint("N3 = %ld\n", pdda->dsX.dt3.lQuo);

	DbgPrint("DDA 01 = %ld, %ld\n", dt01.lQuo, dt01.lRem);
	DbgPrint("DDA 02 = %ld, %ld\n", dt02.lQuo, dt02.lRem);
	DbgPrint("DDA 13 = %ld, %ld\n", dt13.lQuo, dt13.lRem);
	DbgPrint("DDA 23 = %ld, %ld\n", dt23.lQuo, dt23.lRem);

	DbgPrint("Step 01 = %ld, %ld, %ld\n",
		 pdda->dp01.dt.lQuo, pdda->dp01.dt.lRem, pdda->dp01.lDen);
	DbgPrint("Step 02 = %ld, %ld, %ld\n",
		 pdda->dp02.dt.lQuo, pdda->dp02.dt.lRem, pdda->dp02.lDen);
	DbgPrint("Step 13 = %ld, %ld, %ld\n",
		 pdda->dp13.dt.lQuo, pdda->dp13.dt.lRem, pdda->dp13.lDen);
	DbgPrint("Step 23 = %ld, %ld, %ld\n",
		 pdda->dp23.dt.lQuo, pdda->dp23.dt.lRem, pdda->dp23.lDen);
    }
#endif

    while(n < pdda->dsX.dt1.lQuo)
    {
#ifdef DBG_PLGBLT
	if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	    DbgPrint("@ Y = %ld, X0 = %ld, X1 = %ld\n", n, dt01.lQuo, dt02.lQuo);
#endif
	if (dt01.lQuo < dt02.lQuo)
	{
	    pcp->iPos = dt01.lQuo;
	    pcp->cCnt = dt02.lQuo - dt01.lQuo;
	}
	else
	{
	    pcp->iPos = dt02.lQuo;
	    pcp->cCnt = dt01.lQuo - dt02.lQuo;
	}
	prun->cpY.cCnt++;
	DDA(&dt01, &pdda->dp01);
	DDA(&dt02, &pdda->dp02);
	pcp++;
	n++;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	DbgPrint("Switching LHS to 13\n");
#endif

    while(n < pdda->dsX.dt2.lQuo)
    {
#ifdef DBG_PLGBLT
	if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	    DbgPrint("@ Y = %ld, X0 = %ld, X1 = %ld\n", n, dt13.lQuo, dt02.lQuo);
#endif
	if (dt13.lQuo < dt02.lQuo)
	{
	    pcp->iPos = dt13.lQuo;
	    pcp->cCnt = dt02.lQuo - dt13.lQuo;
	}
	else
	{
	    pcp->iPos = dt02.lQuo;
	    pcp->cCnt = dt13.lQuo - dt02.lQuo;
	}
	prun->cpY.cCnt++;
	DDA(&dt13, &pdda->dp13);
	DDA(&dt02, &pdda->dp02);
	pcp++;
	n++;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	DbgPrint("Switching RHS to 23\n");
#endif

    while(n < pdda->dsX.dt3.lQuo)
    {
#ifdef DBG_PLGBLT
	if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	    DbgPrint("@ Y = %ld, X0 = %ld, X1 = %ld\n", n, dt13.lQuo, dt23.lQuo);
#endif
	if (dt13.lQuo < dt23.lQuo)
	{
	    pcp->iPos = dt13.lQuo;
	    pcp->cCnt = dt23.lQuo - dt13.lQuo;
	}
	else
	{
	    pcp->iPos = dt23.lQuo;
	    pcp->cCnt = dt13.lQuo - dt23.lQuo;
	}
	prun->cpY.cCnt++;
	DDA(&dt13, &pdda->dp13);
	DDA(&dt23, &pdda->dp23);
	pcp++;
	n++;
    }

#ifdef DBG_PLGBLT
    if (gflPlgBlt & PLGBLT_SHOW_PUMP)
	DbgPrint("Done.\n");
#endif

    prun->cpY.cCnt = n - prun->cpY.iPos;

// Always put at least one X pair in the list.	This handles the BLACKONWHITE
// and WHITEONBLACK compression.  Notice that the size of the X run is zero.

    if ((pdda->bOverwrite) && (prun->cpY.cCnt == 0))
    {
	if (dt13.lQuo < dt02.lQuo)
	{
	    pcp->iPos = dt13.lQuo;
	    pcp->cCnt = dt02.lQuo - dt13.lQuo;
	}
	else
	{
	    pcp->iPos = dt02.lQuo;
	    pcp->cCnt = dt13.lQuo - dt02.lQuo;
	}

	prun->cpY.cCnt = 1;
	pcp++;
    }

    return((PLGRUN *) pcp);
}

static ULONG gaulMaskMono[] =
{
    0x00000080, 0x00000040, 0x00000020, 0x00000010,
    0x00000008, 0x00000004, 0x00000002, 0x00000001,
    0x00008000, 0x00004000, 0x00002000, 0x00001000,
    0x00000800, 0x00000400, 0x00000200, 0x00000100,
    0x00800000, 0x00400000, 0x00200000, 0x00100000,
    0x00080000, 0x00040000, 0x00020000, 0x00010000,
    0x80000000, 0x40000000, 0x20000000, 0x10000000,
    0x08000000, 0x04000000, 0x02000000, 0x01000000
};

static ULONG gaulMaskQuad[] =
{
    0x000000F0, 0x0000000F, 0x0000F000, 0x00000F00,
    0x00F00000, 0x000F0000, 0xF0000000, 0x0F000000
};

static ULONG gaulShftQuad[] =
{
    0x00000004, 0x00000000, 0x0000000C, 0x00000008,
    0x00000014, 0x00000010, 0x0000001C, 0x00000018
};

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead1(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 1BPP surface.
*
* History:
*  12-Feb-1993 -by- Donald Sidoroff [donalds]
* Fixed a LOT of bugs in monochrome sources
*
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead1(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    ULONG   *pulMsk;
    ULONG   *pulSrc;
    ULONG    ulMsk;
    ULONG    ulSrc;
    ULONG    iBlack;
    ULONG    iWhite;
    LONG     cLeft;
    LONG     iLeft;
    LONG     iMask;

    cLeft  =  xLeft >> 5;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 31;                   // Bits used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

// To prevent derefences of the XLATE, do it upfront.  We can easily do
// this on monochrome bitmaps.

    if (pxlo == NULL)
    {
	iBlack = 0;
	iWhite = 1;
    }
    else
    {
	iBlack = pxlo->pulXlate[0];
	iWhite = pxlo->pulXlate[1];
    }

    if (pjMask == (BYTE *) NULL)
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                if (ulSrc & gaulMaskMono[iLeft])
                    prun->iColor = iWhite;
                else
                    prun->iColor = iBlack;

                prun = prunPumpDDA(pdda, prun);
                vAdvXDDA(pdda);

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 32)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
	}

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (ulMsk & gaulMaskMono[iMask])
            {
                if (ulSrc & gaulMaskMono[iLeft])
                    prun->iColor = iWhite;
                else
                    prun->iColor = iBlack;

                prun = prunPumpDDA(pdda, prun);
            }

            vAdvXDDA(pdda);
            xLeft++;
            iLeft++;
            iMask++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 32)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead4(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 4BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead4(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    ULONG   *pulMsk;
    ULONG   *pulSrc;
    ULONG    ulMsk;
    ULONG    ulSrc;
    ULONG    iColor;
    LONG     cLeft;
    LONG     iLeft;
    LONG     iMask;

    cLeft  =  xLeft >> 3;                   // Index of leftmost DWORD
    iLeft  =  xLeft & 7;                    // Bits used in leftmost DWORD
    pulSrc =  ((DWORD *) pjSrc) + cLeft;    // Adjust base address
    ulSrc  = *pulSrc;

    if (pjMask == (BYTE *) NULL)
    {
        if (xLeft < xRght)
        {
            while (TRUE)
            {
                iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];

                if (pxlo == NULL)
                    prun->iColor = iColor;
                else
                    prun->iColor = pxlo->pulXlate[iColor];

                prun = prunPumpDDA(pdda, prun);
                vAdvXDDA(pdda);

                xLeft++;
                iLeft++;

                if (xLeft >= xRght)
                    break;

                if (iLeft & 8)
                {
                    pulSrc++;
                    ulSrc = *pulSrc;
                    iLeft = 0;
                }
            }
	}

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    if (xLeft < xRght)
    {
        while (TRUE)
        {
            if (ulMsk & gaulMaskMono[iMask])
            {

                iColor = (ulSrc & gaulMaskQuad[iLeft]) >> gaulShftQuad[iLeft];

                if (pxlo == NULL)
                    prun->iColor = iColor;
                else
                    prun->iColor = pxlo->pulXlate[iColor];

                prun = prunPumpDDA(pdda, prun);
            }

            vAdvXDDA(pdda);
            xLeft++;
            iLeft++;
            iMask++;

            if (xLeft >= xRght)
                break;

            if (iLeft & 8)
            {
                pulSrc++;
                ulSrc = *pulSrc;
                iLeft = 0;
            }

            if (iMask & 32)
            {
                pulMsk++;
                ulMsk = *pulMsk;
                iMask = 0;
            }
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead8(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 8BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead8(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     iMask;

    pjSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                prun->iColor = *pjSrc;
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pjSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                prun->iColor = pxlo->pulXlate[*pjSrc];
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pjSrc++;
                xLeft++;
            }

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    while (xLeft != xRght)
    {
        if (ulMsk & gaulMaskMono[iMask])
        {
            iColor = *pjSrc;
            if (pxlo == NULL)
                prun->iColor = iColor;
            else
                prun->iColor = pxlo->pulXlate[iColor];

            prun = prunPumpDDA(pdda, prun);
        }

        vAdvXDDA(pdda);
        pjSrc++;
        xLeft++;
        iMask++;

        if (iMask & 32)
        {
            pulMsk++;
            ulMsk = *pulMsk;
            iMask = 0;
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead16(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 16BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead16(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    WORD    *pwSrc = (WORD *) pjSrc;
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     iMask;

    pwSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                prun->iColor = *pwSrc;
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pwSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                prun->iColor = ((XLATE *) pxlo)->ulTranslate((ULONG) *pwSrc);
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pwSrc++;
                xLeft++;
            }

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    while (xLeft != xRght)
    {
        if (ulMsk & gaulMaskMono[iMask])
        {
            iColor = *pwSrc;
            if (pxlo == NULL)
                prun->iColor = iColor;
            else
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(iColor);

            prun = prunPumpDDA(pdda, prun);
        }

        vAdvXDDA(pdda);
        pwSrc++;
        xLeft++;
        iMask++;

        if (iMask & 32)
        {
            pulMsk++;
            ulMsk = *pulMsk;
            iMask = 0;
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead24(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 24BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead24(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    RGBTRIPLE *prgbSrc = (RGBTRIPLE *) pjSrc;
    ULONG     *pulMsk;
    ULONG      ulMsk;
    ULONG      iColor = 0;
    LONG       iMask;

    prgbSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                *((RGBTRIPLE *) &iColor) = *prgbSrc;
                prun->iColor = iColor;
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                prgbSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                *((RGBTRIPLE *) &iColor) = *prgbSrc;
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(iColor);
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                prgbSrc++;
                xLeft++;
            }

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    while (xLeft != xRght)
    {
        if (ulMsk & gaulMaskMono[iMask])
        {
            *((RGBTRIPLE *) &iColor) = *prgbSrc;
            if (pxlo == NULL)
                prun->iColor = iColor;
            else
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(iColor);

            prun = prunPumpDDA(pdda, prun);
        }

        vAdvXDDA(pdda);
        prgbSrc++;
        xLeft++;
        iMask++;

        if (iMask & 32)
        {
            pulMsk++;
            ulMsk = *pulMsk;
            iMask = 0;
        }
    }

    return(prun);
}

/******************************Public*Routine******************************\
* PLGRUN *prunPlgRead32(prun, pjSrc, pjMask, pxlo, xLeft, xRght, xMask)
*
* Read the source, mask it, xlate colors and produce a run list
* for a row of a 32BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

PLGRUN *prunPlgRead32(
PLGDDA	 *pdda,
PLGRUN	 *prun,
BYTE	 *pjSrc,
BYTE	 *pjMask,
XLATEOBJ *pxlo,
LONG	  xLeft,
LONG	  xRght,
LONG	  xMask)
{
    DWORD   *pdwSrc = (DWORD *) pjSrc;
    ULONG   *pulMsk;
    ULONG    ulMsk;
    ULONG    iColor;
    LONG     iMask;

    pdwSrc += xLeft;

    if (pjMask == (BYTE *) NULL)
    {
        if (pxlo == NULL)
            while (xLeft != xRght)
            {
                prun->iColor = *pdwSrc;
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pdwSrc++;
                xLeft++;
            }
        else
            while (xLeft != xRght)
            {
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(*pdwSrc);
                prun = prunPumpDDA(pdda, prun);

                vAdvXDDA(pdda);
                pdwSrc++;
                xLeft++;
            }

        return(prun);
    }

// Compute initial state of mask

    pulMsk =  ((DWORD *) pjMask) + (xMask >> 5);
    iMask  =  xMask & 31;
    ulMsk  = *pulMsk;

    while (xLeft != xRght)
    {
        if (ulMsk & gaulMaskMono[iMask])
        {
            iColor = *pdwSrc;
            if (pxlo == NULL)
                prun->iColor = iColor;
            else
                prun->iColor = ((XLATE *) pxlo)->ulTranslate(iColor);

            prun = prunPumpDDA(pdda, prun);
        }

        vAdvXDDA(pdda);
        pdwSrc++;
        xLeft++;
        iMask++;

        if (iMask & 32)
        {
            pulMsk++;
            ulMsk = *pulMsk;
            iMask = 0;
        }
    }

    return(prun);
}

static BYTE gajMask[] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

/******************************Public*Routine******************************\
* VOID vPlgWrite1(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 1BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite1(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;
    BYTE    jMask;
    BYTE    jTemp;
    BOOL    bValid;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor ? (ULONG) -1L : 0L;

	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];
		jTemp	= *pjOff;

		while (xDist != 0)
		{
		    jTemp = (BYTE) ((jTemp & ~jMask) | (iColor & jMask));
		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
		       *pjOff = jTemp;
			pjOff++;
			jTemp = *pjOff;
			jMask = gajMask[xCurr & 7];
		    }
		}

	       *pjOff = jTemp;
		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	iColor = prun->iColor ? (ULONG) -1L : 0L;

	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff = pjBase + (xCurr >> 3);
		jMask = gajMask[xCurr & 7];

		bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
		jTemp  = bValid ? *pjOff : (BYTE) 0;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			jTemp = (BYTE) ((jTemp & ~jMask) | (iColor & jMask));

		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
			if (bValid)
			   *pjOff = jTemp;

			jMask = gajMask[xCurr & 7];
			pjOff++;

			bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
			jTemp  = bValid ? *pjOff : (BYTE) 0;
		    }
		}

	       if (bValid)
		   *pjOff = jTemp;
	    }

	    pjBase += pSurf->lDelta();
            yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWrite4(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 4BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite4(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;
    BYTE    jMask;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor | (prun->iColor << 4);

	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff = pjBase + (xCurr >> 1);
		jMask = (xCurr & 1) ? 0x0F : 0xF0;

		while (xDist != 0)
		{
		   *pjOff = (BYTE) ((*pjOff & ~jMask) | (iColor & jMask));
		    jMask ^= 0xFF;
		    if (jMask == 0xF0)
			pjOff++;
		    xDist--;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There maybe a single rectangle to clip against.

    RECTL    rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
	rclClip = pco->rclBounds;

	while (prun != prunEnd)
	{
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    iColor = prun->iColor | (prun->iColor << 4);
	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp    = &prun->cpX[0];

	    while (yDist != 0)
	    {
		if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
		{
		    xCurr = pcp->iPos;
		    xDist = pcp->cCnt;

		    pjOff = pjBase + (xCurr >> 1);
		    jMask = (xCurr & 1) ? 0x0F : 0xF0;

		    while (xDist != 0)
		    {
			if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			   *pjOff = (BYTE) ((*pjOff & ~jMask) | (iColor & jMask));

			xDist--;
			xCurr++;
			jMask ^= 0xFF;
			if (jMask == 0xF0)
			    pjOff++;
		    }
		}

		pjBase += pSurf->lDelta();
		yCurr++;
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor | (prun->iColor << 4);
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff = pjBase + (xCurr >> 1);
		jMask = (xCurr & 1) ? 0x0F : 0xF0;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *pjOff = (BYTE) ((*pjOff & ~jMask) | (iColor & jMask));

		    xDist--;
		    xCurr++;
		    jMask ^= 0xFF;
		    if (jMask == 0xF0)
			pjOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }

}

/******************************Public*Routine******************************\
* VOID vPlgWrite8(prun, prunEnd, pso, pco)
*
* Write the clipped run list of pels to the target 8BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite8(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor;
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		pjOff = pjBase + pcp->iPos;
		xDist = pcp->cCnt;

		while (xDist != 0)
		{
		   *pjOff = (BYTE) iColor;
		    pjOff++;
		    xDist--;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There maybe a single rectangle to clip against.

    RECTL    rclClip;

    if (pco->iDComplexity == DC_RECT)
    {
	rclClip = pco->rclBounds;

	while (prun != prunEnd)
	{
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    iColor = prun->iColor;
	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp    = &prun->cpX[0];

	    while (yDist != 0)
	    {
		if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
		{
		    xCurr = pcp->iPos;
		    xDist = pcp->cCnt;

		    pjOff = pjBase + xCurr;

		    while (xDist != 0)
		    {
			if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			   *pjOff = (BYTE) iColor;

			xDist--;
			xCurr++;
			pjOff++;
		    }
		}

		pjBase += pSurf->lDelta();
		yCurr++;
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is complex clipping.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor;
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff = pjBase + xCurr;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *pjOff = (BYTE) iColor;

		    xDist--;
		    xCurr++;
		    pjOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWrite16(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 16BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite16(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    WORD   *pwOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor;
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		pwOff = ((WORD *) pjBase) + pcp->iPos;
		xDist = pcp->cCnt;

		while (xDist != 0)
		{
		   *pwOff = (WORD) iColor;
		    xDist--;
		    pwOff++;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor;
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pwOff = ((WORD *) pjBase) + xCurr;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *pwOff = (WORD) iColor;

		    xDist--;
		    xCurr++;
		    pwOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWrite24(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 24BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite24(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE      *pjBase;
    RGBTRIPLE *prgbOff;
    CNTPOS    *pcp;
    ULONG      iColor;
    LONG       yCurr;
    LONG       yDist;
    LONG       xCurr;
    LONG       xDist;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor;
	    yCurr  = prun->cpY.iPos;
	    yDist  = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		prgbOff = ((RGBTRIPLE *) pjBase) + pcp->iPos;
		xDist = pcp->cCnt;

		while (xDist != 0)
		{
		   *prgbOff = *((RGBTRIPLE *) &iColor);
		    prgbOff++;
		    xDist--;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor;
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		prgbOff = ((RGBTRIPLE *) pjBase) + xCurr;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *prgbOff = *((RGBTRIPLE *) &iColor);

		    xDist--;
		    xCurr++;
		    prgbOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWrite32(prun, prunEnd, pSurf, pco)
*
* Write the clipped run list of pels to the target 32BPP surface.
*
* History:
*  08-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWrite32(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    DWORD  *pdwOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor;
	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		pdwOff = ((DWORD *) pjBase) + pcp->iPos;
		xDist = pcp->cCnt;

		while (xDist != 0)
		{
		   *pdwOff = iColor;
		    xDist--;
		    pdwOff++;
		}

		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	iColor = prun->iColor;
	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp    = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pdwOff = ((DWORD *) pjBase) + xCurr;

		while (xDist != 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
		       *pdwOff = iColor;

		    xDist--;
		    xCurr++;
		    pdwOff++;
		}
	    }

	    pjBase += pSurf->lDelta();
	    yCurr++;
	    yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWriteAND(prun, prunEnd, pSurf, pco)
*
* AND the clipped run list of pels to the target 1BPP surface.	This can
* be made much faster by noting that ANDing with 1's is a NOP.
*
* History:
*  25-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWriteAND(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;
    BYTE    jMask;
    BYTE    jTemp;
    BOOL    bValid;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor == 0 ? ~0L : 0L;

	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];
		jTemp	= *pjOff;

		while (xDist >= 0)
		{
		    jTemp &= ~((BYTE) (iColor & jMask));
		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
		       *pjOff = jTemp;
			pjOff++;
			jTemp = *pjOff;
			jMask = gajMask[xCurr & 7];
		    }
		}

	       *pjOff = jTemp;
		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	iColor = prun->iColor == 0 ? ~0L : 0L;

	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];

		bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
		jTemp  = bValid ? *pjOff : (BYTE) 0;

		while (xDist >= 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			jTemp &= ~((BYTE) (iColor & jMask));

		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
			if (bValid)
			   *pjOff = jTemp;

			pjOff++;
			jMask = gajMask[xCurr & 7];

			bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
			jTemp  = bValid ? *pjOff : (BYTE) 0;
		    }
		}

	       if (bValid)
		   *pjOff = jTemp;
	    }

	    pjBase += pSurf->lDelta();
            yCurr++;
            yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}

/******************************Public*Routine******************************\
* VOID vPlgWriteOR(prun, prunEnd, pso, pco)
*
* OR the clipped run list of pels to the target 1BPP surface.  This can
* be much faster by noting that ORing with 0's is a NOP.
*
* History:
*  25-Aug-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID vPlgWriteOR(
PLGRUN	*prun,
PLGRUN	*prunEnd,
SURFACE *pSurf,
CLIPOBJ *pco)
{
    BYTE   *pjBase;
    BYTE   *pjOff;
    CNTPOS *pcp;
    ULONG   iColor;
    LONG    yCurr;
    LONG    yDist;
    LONG    xCurr;
    LONG    xDist;
    BYTE    jMask;
    BYTE    jTemp;
    BOOL    bValid;

// See if this can be handled without clipping.

    if (pco == (CLIPOBJ *) NULL)
    {
	while (prun != prunEnd)
	{
	    iColor = prun->iColor == 0 ? 0L : ~0L;

	    yCurr = prun->cpY.iPos;
	    yDist = prun->cpY.cCnt;

	    pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	    pcp = &prun->cpX[0];

	    while (yDist != 0)
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];
		jTemp	= *pjOff;

		while (xDist >= 0)
		{
		    jTemp |= ((BYTE) (iColor & jMask));
		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
		       *pjOff = jTemp;
			pjOff++;
			jTemp = *pjOff;
			jMask = gajMask[xCurr & 7];
		    }
		}

	       *pjOff = jTemp;
		pjBase += pSurf->lDelta();
		yDist--;
		pcp++;
	    }

	    prun = (PLGRUN *) pcp;
	}

	return;
    }

// There is a clip region.  Set up the clipping code.

    ((ECLIPOBJ *) pco)->cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

    RECTL    rclClip;

    rclClip.left   = POS_INFINITY;
    rclClip.top    = POS_INFINITY;
    rclClip.right  = NEG_INFINITY;
    rclClip.bottom = NEG_INFINITY;

    while (prun != prunEnd)
    {
	iColor = prun->iColor == 0 ? 0L : ~0L;

	yCurr = prun->cpY.iPos;
	yDist = prun->cpY.cCnt;

	pjBase = (BYTE *) pSurf->pvScan0() + pSurf->lDelta() * yCurr;
	pcp = &prun->cpX[0];

	while (yDist != 0)
	{
	    if ((yCurr < rclClip.top) || (yCurr >= rclClip.bottom))
		((ECLIPOBJ *) pco)->vFindScan(&rclClip, yCurr);

	    if ((yCurr >= rclClip.top) && (yCurr < rclClip.bottom))
	    {
		xCurr = pcp->iPos;
		xDist = pcp->cCnt;

		pjOff	= pjBase + (xCurr >> 3);
		jMask	= gajMask[xCurr & 7];

		bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
		jTemp  = bValid ? *pjOff : (BYTE) 0;

		while (xDist >= 0)
		{
		    if ((xCurr < rclClip.left) || (xCurr >= rclClip.right))
			((ECLIPOBJ *) pco)->vFindSegment(&rclClip, xCurr, yCurr);

		    if ((xCurr >= rclClip.left) && (xCurr < rclClip.right))
			jTemp |= ((BYTE) (iColor & jMask));

		    xDist--;
		    xCurr++;
		    jMask >>= 1;

		    if (jMask == (BYTE) 0)
		    {
			if (bValid)
			   *pjOff = jTemp;

			pjOff++;
			jMask = gajMask[xCurr & 7];

			bValid = ((xCurr >= 0) && (xCurr < pSurf->sizl().cx));
			jTemp  = bValid ? *pjOff : (BYTE) 0;
		    }
		}

		if (bValid)
		   *pjOff = jTemp;
	    }

	    pjBase += pSurf->lDelta();
            yCurr++;
            yDist--;
	    pcp++;
	}

	prun = (PLGRUN *) pcp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rgngdi.cxx ===
/******************************Module*Header*******************************\
* Module Name: rgngdi.cxx
*
* GDI Region calls
*
* Created: 30-Aug-1990 10:21:11
* Author: Donald Sidoroff [donalds]
*
* Copyright (c) 1990-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

extern PBRUSH gpbrNull;

#if DBG
extern ULONG dbgrgn;
#endif


// Tracing defines for traces that should ignore class
#define GDITE_GreCreatePolyPolygonRgnInternal_return                        \
       (GDITE_GreCreatePolyPolygonRgnInternal|GDITF_IGNORE_CLASS)
#define GDITE_GreCreateRectRgn_return                                       \
       (GDITE_GreCreateRectRgn|GDITF_IGNORE_CLASS)
#define GDITE_GreCreateRectRgnIndirect_return                               \
       (GDITE_GreCreateRectRgnIndirect|GDITF_IGNORE_CLASS)
#define GDITE_GreExtCreateRegion_return                                     \
       (GDITE_GreExtCreateRegion|GDITF_IGNORE_CLASS)
#define GDITE_NtGdiCreateEllipticRgn_return                                 \
       (GDITE_NtGdiCreateEllipticRgn|GDITF_IGNORE_CLASS)
#define GDITE_NtGdiCreateRectRgn_return                                     \
       (GDITE_NtGdiCreateRectRgn|GDITF_IGNORE_CLASS)
#define GDITE_NtGdiCreateRoundRectRgn_return                                \
       (GDITE_NtGdiCreateRoundRectRgn|GDITF_IGNORE_CLASS)


/******************************Public*Routine******************************\
* BOOL bDeleteRegion(HRGN)
*
* Delete the specified region
*
* History:
*  17-Sep-1990 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

BOOL bDeleteRegion(HRGN hrgn)
{

    RGNLOG rl(hrgn,NULL,"bDeleteRegion",0,0,0);

    RGNOBJAPI   ro(hrgn,FALSE);

    return(ro.bValid() &&
           (ro.cGet_cRefs() == 0) &&
           ro.bDeleteRGNOBJAPI());
}

/***************************Exported*Routine****************************\
* BOOL GreSetRegionOwner(hrgn,lPid)
*
* Assigns a new owner to the given region.  This function should be as
* fast as possible so that the USER component can call it often without
* concern for performance!
*
\***********************************************************************/

BOOL
GreSetRegionOwner(
    HRGN hrgn,
    W32PID lPid)
{

    RGNLOG rl(hrgn,NULL,"GreSetRegionOwner",W32GetCurrentPID(),0,0);

    //
    // Setting a region to public, the region must not have
    // a user mode component
    //

    #if DBG

    RGNOBJAPI ro(hrgn,TRUE);
    if (ro.bValid())
    {
        if (PENTRY_FROM_POBJ(ro.prgn)->pUser != NULL)
        {
            RIP("Error: setting region public that has user component");
        }
    }

    #endif

    //
    // Get the current PID.
    //

    if (lPid == OBJECT_OWNER_CURRENT)
    {
        lPid = W32GetCurrentPID();
    }

    return HmgSetOwner((HOBJ)hrgn, lPid, RGN_TYPE);
}






/******************************Public*Routine******************************\
* CLIPOBJ *EngCreateClip()
*
* Create a long live clipping object for a driver
*
* History:
*  22-Sep-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

CLIPOBJ *EngCreateClip()
{

    //
    // Note that we intentionally zero this memory on allocation. Even though
    // we're going to set some of these fields to non-zero values right away,
    // this is not a performance-critical function (a driver typically calls
    // this only once), and we save a lot of instruction bytes by not having to
    // zero a number of fields explicitly.
    //

    VOID *pv = EngAllocMem(FL_ZERO_MEMORY,
                           sizeof(ECLIPOBJ) + SINGLE_REGION_SIZE,
                           'vrdG');

    if (pv != NULL)
    {
        //
        // Make this a CLIPOBJ that doesn't clip anything.
        //

        ((ECLIPOBJ *) pv)->iDComplexity     = DC_TRIVIAL;
        ((ECLIPOBJ *) pv)->iFComplexity     = FC_RECT;
        ((ECLIPOBJ *) pv)->iMode            = TC_RECTANGLES;

        REGION *prgn = (REGION*)((PBYTE)pv + sizeof(ECLIPOBJ));
        ((ECLIPOBJ *) pv)->prgn             = prgn;

        RGNOBJ ro(prgn);
        RECTL  r;

        r.left  = r.top    = MIN_REGION_COORD;
        r.right = r.bottom = MAX_REGION_COORD;

        ro.vSet(&r);
    }

    return((CLIPOBJ *)pv);
}

/******************************Public*Routine******************************\
* VOID EngDeleteClip()
*
* Delete a long live clipping object for a driver
*
* History:
*  22-Sep-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

VOID EngDeleteClip(CLIPOBJ *pco)
{
    if (pco == NULL)
    {
        WARNING("Driver calling to free NULL clipobj");
    }
    else
    {
        ASSERTGDI(pco->iUniq == 0, "Non-zero iUniq\n");
    }

    //
    // We call EngFreeMem since some drivers like to free non-existant
    // Clip Objects.
    //

    EngFreeMem((PVOID)pco);

}



/******************************Public*Routine******************************\
* ASSERTDEVLOCK()
*
*   This validates that the thread using the DC has the devlock as well.
*
* History:
*  24-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#if DBG
VOID ASSERTDEVLOCK(PDC pdc)
{
    return;

    if (pdc->fs() & DC_SYNCHRONIZEACCESS)
    {
        ASSERTGDI(GreIsSemaphoreOwnedByCurrentThread(pdc->hsemDcDevLock_),
                  "ASSERTDEVLOCK: wrong id\n");
    }
}
#endif

/******************************Public*Routine******************************\
* LONG GreCombineRgn(hrgnTrg,hrgnSrc1,hrgnSrc2,iMode)
*
* Combine the two source regions by the given mode.  The result is placed
* in the target.  Note that either (or both sources) may be the same as
* the target.
*
\**************************************************************************/

int APIENTRY GreCombineRgn(
    HRGN  hrgnTrg,
    HRGN  hrgnSrc1,
    HRGN  hrgnSrc2,
    int   iMode)
{
    GDITraceHandle3(GreCombineRgn, "(%X, %X, %X, %d)\n", (va_list)&hrgnTrg,
                    hrgnTrg, hrgnSrc1, hrgnSrc2);

    RGNLOG rl(hrgnTrg,NULL,"GreCombineRgn",(ULONG_PTR)hrgnSrc1,(ULONG_PTR)hrgnSrc2,iMode);

    LONG Status;

    if ((iMode < RGN_MIN) || (iMode > RGN_MAX))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return ERROR;
    }

    //
    // Check if a simple copy is to be performed.
    //

    if (iMode == RGN_COPY)
    {

        RGNOBJAPI roTrg(hrgnTrg,FALSE);
        RGNOBJAPI roSrc1(hrgnSrc1,TRUE);

        //
        // if either of these regions have a client rectangle, then set the
        // km region
        //

        if (!roTrg.bValid() || !roSrc1.bValid() || !roTrg.bCopy(roSrc1))
        {
            if (!roSrc1.bValid() || !roTrg.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            }

            Status = ERROR;
        }
        else
        {
            Status = roTrg.iComplexity();
        }

    }
    else if (SAMEHANDLE(hrgnTrg, hrgnSrc1) || SAMEHANDLE(hrgnTrg, hrgnSrc2))
    {

    // Two of the handles are the same. Check to determine if all three
    // handles are the same.

        if (SAMEHANDLE(hrgnSrc1, hrgnSrc2))
        {
            RGNOBJAPI roTrg(hrgnTrg,FALSE);

            if (!roTrg.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                Status = ERROR;
            }
            else
            {
                if ((iMode == RGN_DIFF) || (iMode == RGN_XOR))
                {
                    roTrg.vSet();
                }

                Status = roTrg.iComplexity();
            }

        }
        else
        {

            //
            // All three handles are not the same.
            //
            // Also, Src1 or Src2 could be the actual
            // destination so don't use TRUE on the
            // RGNOBJAPI contructor
            //

            RGNMEMOBJTMP rmo((BOOL)FALSE);
            RGNOBJAPI roSrc1(hrgnSrc1,FALSE);
            RGNOBJAPI roSrc2(hrgnSrc2,FALSE);

            if (!rmo.bValid()    ||
                !roSrc1.bValid() ||
                !roSrc2.bValid() ||
                (rmo.iCombine(roSrc1, roSrc2, iMode) == ERROR))
            {
                if (!roSrc1.bValid() || !roSrc2.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
                }

                Status = ERROR;

            }
            else if (SAMEHANDLE(hrgnTrg, hrgnSrc1))
            {
                if (!roSrc1.bSwap(&rmo))
                {
                    Status = ERROR;

                }
                else
                {
                    Status = roSrc1.iComplexity();
                }

            }
            else
            {
                if (!roSrc2.bSwap(&rmo))
                {
                    Status = ERROR;

                }
                else
                {
                    Status = roSrc2.iComplexity();
                }
            }
        }

    }
    else
    {

    // Handle the general case.

        RGNOBJAPI roSrc1(hrgnSrc1,TRUE);
        RGNOBJAPI roSrc2(hrgnSrc2,TRUE);
        RGNOBJAPI roTrg(hrgnTrg,FALSE);

        if (!roSrc1.bValid() ||
            !roSrc2.bValid() ||
            !roTrg.bValid()  ||
            (roTrg.iCombine(roSrc1, roSrc2, iMode) == ERROR))
        {
            if (!roSrc1.bValid() || !roSrc2.bValid() || !roTrg.bValid())
            {
                SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
            }

            Status = ERROR;

        }
        else
        {
            Status = roTrg.iComplexity();
        }
    }

    return (int)Status;
}

/******************************Public*Routine******************************\
* HRGN NtGdiCreateEllipticRgn(xLeft,yTop,xRight,yBottom)
*
* Create an elliptical region.
*
\**************************************************************************/

HRGN
APIENTRY NtGdiCreateEllipticRgn(
 int xLeft,
 int yTop,
 int xRight,
 int yBottom)
{
    GDITrace(NtGdiCreateEllipticRgn, "(%d, %d, %d, %d)\n", (va_list)&xLeft);

    HRGN hrgn;

    PATHMEMOBJ pmo;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    ERECTL ercl(xLeft, yTop, xRight, yBottom);

    if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

// Handle the PS_INSIDEFRAME pen attribute and lower-right exclusion
// by adjusting the box now.  And set the flag that this will be an
// ellipse, to fill it nice:

    EBOX ebox(ercl, TRUE);

    if (ebox.bEmpty())
    {
        RGNMEMOBJ rmoEmpty;

        if (rmoEmpty.bValid())
        {
            hrgn = rmoEmpty.hrgnAssociate();

            if (hrgn == (HRGN)0)
            {
                rmoEmpty.bDeleteRGNOBJ();
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            hrgn = (HRGN) 0;
        }
    }
    else if (!bEllipse(pmo, ebox) || !pmo.bFlatten())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        hrgn = (HRGN)0;
    }
    else
    {
        RGNMEMOBJ rmo(pmo);         // convert path to region (ALTERNATE)

        if (rmo.bValid())
        {
            rmo.vTighten();

            hrgn = rmo.hrgnAssociate();

            if (hrgn == (HRGN)0)
            {
                rmo.bDeleteRGNOBJ();
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            hrgn = (HRGN) 0;
        }
    }

    GDITrace(NtGdiCreateEllipticRgn_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}

/******************************Public*Routine******************************\
* HRGN GreCreatePolyPolygonRgn(aptl,acptl,cPoly,iFill)
*
* Create a polygonal region with multiple, disjoint polygons.
*
\**************************************************************************/

HRGN
APIENTRY
GreCreatePolyPolygonRgnInternal(
    CONST POINT *aptl,
    CONST INT *acptl,
    int     cPoly,
    int     iFill,
    UINT    cMaxPoints)
{
    GDITrace(GreCreatePolyPolygonRgnInternal, "(%p, %p, %d, %d, %u)\n",
             (va_list)&aptl);

    HRGN hrgn = NULL;

    if ((iFill == ALTERNATE) || (iFill == WINDING))
    {
        PATHMEMOBJ pmo;

        if (pmo.bValid())
        {
            EXFORMOBJ   exfo(IDENTITY);

            ASSERTGDI(exfo.bValid(), "Can\'t make IDENTITY matrix!\n");

            if (bPolyPolygon(pmo,
                             exfo,
                             (PPOINTL) aptl,
                             (PLONG) acptl,
                             cPoly,
                             cMaxPoints))
            {
                RGNMEMOBJ rmo(pmo, iFill);  // convert path to region

                if (rmo.bValid())
                {
                    hrgn = rmo.hrgnAssociate();

                    if (hrgn == (HRGN)0)
                    {
                        rmo.bDeleteRGNOBJ();
                    }
                }
            }
        }
    }

    GDITrace(GreCreatePolyPolygonRgnInternal_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}

/******************************Public*Routine******************************\
* HRGN GreCreateRectRgn(xLeft,yTop,xRight,yBottom)
*
* Create a rectangular region.
*
* Called only from user
*
\**************************************************************************/

HRGN APIENTRY GreCreateRectRgn(
 int xLeft,
 int yTop,
 int xRight,
 int yBottom)
{
    GDITrace(GreCreateRectRgn, "(%d, %d, %d, %d)\n", (va_list)&xLeft);

    RGNLOG rl((PREGION)NULL,"GreCreateRectRgn");



    ERECTL   ercl(xLeft, yTop, xRight, yBottom);

    if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

    RGNMEMOBJ rmo((BOOL)FALSE);
    HRGN hrgn;

    if (!rmo.bValid())
    {
        hrgn = (HRGN) 0;
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
    }
    else
    {

        #if NOREORDER_RGN

            //
            // reduce region if coordinates are not well ordered
            //

            if ((xLeft > xRigth) || (yTop > yBottom))
            {
                WARNING("GreCreateRectRgn: region not well ordered");

                xLeft   = 0;
                yTop    = 0;
                xRight  = 0;
                yBottom = 0;
            }

        #else

            //
            // Make the rectangle well ordered.
            //

            ercl.vOrder();

        #endif

        rmo.vSet((RECTL *) &ercl);

        hrgn = (HRGN)HmgInsertObject(rmo.prgnGet(),HMGR_MAKE_PUBLIC,RGN_TYPE);

        if (hrgn == (HRGN)0)
        {
            rmo.bDeleteRGNOBJ();
        }
    }

    rl.vRet((ULONG_PTR)hrgn);
    
    GDITrace(GreCreateRectRgn_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}


/******************************Public*Routine******************************\
*
*   NtGdiCreateRectRgn is the same as GreCreateRectRgn except an additional
*   argument is passed in, a shared RECTREGION pointer. This pointer must be
*   put into the shared pointer filed of the handle table for the RGN
*   created. This allows fast user-mode access to RECT regions.
*
* Arguments:
*
*    xLeft       - left edge of region
*    yTop        - top edge of region
*    xRight      - right edge of region
*    yBottom     - bottom edge of region
*    pRectRegion - pointer to user-mode data
*
* Return Value:
*
*   new HRGN or NULL
*
* History:
*
*    20-Jun-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

HRGN APIENTRY
NtGdiCreateRectRgn(
    int xLeft,
    int yTop,
    int xRight,
    int yBottom
    )
{
    GDITrace(NtGdiCreateRectRgn, "(%d, %d, %d, %d)\n", (va_list)&xLeft);

    RGNLOG rl((PREGION)NULL,"GreCreateRectRgn");

    ERECTL   ercl(xLeft, yTop, xRight, yBottom);

    if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }


    PVOID pRgnattr = (PRGNATTR)HmgAllocateObjectAttr();
    HRGN  hrgn;

    if (pRgnattr == NULL)
    {
        //
        // memory alloc error
        //

        hrgn = (HRGN) 0;
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
    }
    else
    {
        RGNMEMOBJ rmo((BOOL)FALSE);

        if (!rmo.bValid())
        {
            hrgn = (HRGN) 0;
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        }
        else
        {
            //
            // Make the rectangle well ordered.
            //

            ercl.vOrder();

            rmo.vSet((RECTL *) &ercl);

            //
            // allocate an object for this region, set
            // the shared pointer if needed
            //

        #if DBG

            RGNLOG rl(rmo.prgn,"RGNOBJ::hrgnAssociate");
            hrgn = (HRGN)HmgInsertObject(rmo.prgn,HMGR_ALLOC_LOCK,RGN_TYPE);
            rl.vRet((ULONG_PTR)hrgn);

        #else

            hrgn = (HRGN)HmgInsertObject(rmo.prgn,HMGR_ALLOC_LOCK,RGN_TYPE);

        #endif

            if (hrgn == (HRGN)0)
            {
                rmo.bDeleteRGNOBJ();
                HmgFreeObjectAttr((POBJECTATTR)pRgnattr);
            }
            else
            {
                //
                // set shared rect region pointer and unlock
                //

                PENTRY_FROM_POBJ(rmo.prgn)->pUser = (PDC_ATTR)pRgnattr;
                DEC_EXCLUSIVE_REF_CNT(rmo.prgn);
            }
        }
    }

    rl.vRet((ULONG_PTR)hrgn);

    GDITrace(NtGdiCreateRectRgn_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}

/******************************Public*Routine******************************\
* HRGN GreCreateRectRgnIndirect(prcl)
*
* Create a rectangular region.
*
\**************************************************************************/

HRGN APIENTRY GreCreateRectRgnIndirect(LPRECT prcl)
{
    GDITrace(GreCreateRectRgnIndirect, "(%p)\n", (va_list)&prcl);

    RGNLOG rl((PREGION)NULL,"GreCreateRectRgnIndirect",prcl->left,prcl->top,prcl->right);



    if ((prcl == (LPRECT) NULL) || !VALID_SCRPRC(prcl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

    RGNMEMOBJ rmo((BOOL)FALSE);
    HRGN hrgn;

    if (!rmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        hrgn = (HRGN) 0;
    }
    else
    {
        ((ERECTL *) prcl)->vOrder();    // Make the rectangle well ordered.

        rmo.vSet((RECTL *) prcl);

        hrgn = rmo.hrgnAssociate();

        if (hrgn == (HRGN)0)
        {
            rmo.bDeleteRGNOBJ();
        }
    }
    rl.vRet((ULONG_PTR)hrgn);

    GDITrace(GreCreateRectRgnIndirect_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}



HRGN
APIENTRY
NtGdiCreateRoundRectRgn(
    int xLeft,
    int yTop,
    int xRight,
    int yBottom,
    int xWidth,
    int yHeight
    )
{
    GDITrace(NtGdiCreateRoundRectRgn, "(%d, %d, %d, %d, %d, %d)\n",
             (va_list)&xLeft);

    PATHMEMOBJ pmo;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    ERECTL ercl(xLeft, yTop, xRight, yBottom);

    if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return((HRGN) 0);
    }

// Handle the PS_INSIDEFRAME pen attribute and lower-right exclusion
// by adjusting the box now.  And set the flag that this will be an
// ellipse, to fill it nice:

    EBOX ebox(ercl, TRUE);
    HRGN hrgn;

    if (ebox.bEmpty())
    {
        RGNMEMOBJ   rmoEmpty;

        if (rmoEmpty.bValid())
        {
            hrgn = rmoEmpty.hrgnAssociate();

            if (hrgn == (HRGN)0)
            {
                rmoEmpty.bDeleteRGNOBJ();
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            hrgn = (HRGN)0;
        }
    }
    else if (!bRoundRect(pmo, ebox, xWidth, yHeight) || !pmo.bFlatten())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        hrgn = (HRGN)0;
    }
    else
    {
        RGNMEMOBJ rmo(pmo);         // convert path to region (ALTERNATE)

        if (rmo.bValid())
        {
            rmo.vTighten();
            hrgn = rmo.hrgnAssociate();

            if (hrgn == (HRGN)0)
            {
                rmo.bDeleteRGNOBJ();
            }
        }
        else
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            hrgn = (HRGN)0;
        }
    }

    GDITrace(NtGdiCreateRoundRectRgn_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}
/******************************Public*Routine******************************\
* NtGdiEqualRgn()
*
* Check if the two regions are equal.
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiEqualRgn(
    HRGN hrgn1,
    HRGN hrgn2
    )
{
    GDITraceHandle2(NtGdiEqualRgn, "(%X, %X)\n", (va_list)&hrgn1, hrgn1, hrgn2);

    BOOL bRet = ERROR;

    RGNOBJAPI   roSrc1(hrgn1,TRUE);
    RGNOBJAPI   roSrc2(hrgn2,TRUE);

    if (roSrc1.bValid() && roSrc2.bValid())
    {
        bRet = roSrc1.bEqual(roSrc2);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* BOOL GreFillRgn (hdc,hrgn,hbrush,pac)
*
* Paint the region with the specified brush.
*
\**************************************************************************/

BOOL NtGdiFillRgn(
 HDC    hdc,
 HRGN   hrgn,
 HBRUSH hbrush
 )
{
    GDITraceHandle3(NtGdiFillRgn, "(%X, %X, %X)\n", (va_list)&hdc,
                    hdc, hrgn, hbrush);

    BOOL bRet = FALSE;

    DCOBJ   dco(hdc);
    BOOL    bXform;
    PREGION prgnOrg;

    if (dco.bValid())
    {
        EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);

        // We may have to scale/rotate the incoming region.

        bXform = !dco.pdc->bWorldToDeviceIdentity();

        RGNOBJAPI ro(hrgn,FALSE);

        if (ro.bValid())
        {
            if (bXform)
            {
                PATHMEMOBJ  pmo;

                if (!pmo.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }

                if (!exo.bValid() || !ro.bCreate(pmo, &exo))
                    return(FALSE);

                ASSERTGDI(pmo.bValid(),"GreFillRgn - pmo not valid\n");

                RGNMEMOBJ rmo(pmo);

                if (!rmo.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }

            // this replaces the prgn in ro with the new prgn.  The ro destructor will
            // unlock the handle for hrgn.  We must first delete the prgn though.

                prgnOrg = ro.prgnGet();
                ro.vSetRgn(rmo.prgnGet());
            }

            // If region is null, return TRUE

            if (ro.iComplexity() != NULLREGION)
            {
                // Accumulate bounds.  We can do this before knowing if the operation is
                // successful because bounds can be loose.

                ERECTL   ercl(0, 0, 0, 0);

                ro.vGet_rcl((RECTL *) &ercl);

                if (dco.fjAccum())
                    dco.vAccumulate(ercl);

                if (dco.bHasSurface())
                {
                    dco.pdc->prgnAPI(ro.prgnGet());          // Dirties rgnRao

                    DEVLOCKOBJ dlo(dco);

                    SURFACE  *pSurf = dco.pSurface();

                    if (!dlo.bValid())
                    {
                        bRet = dco.bFullScreen();
                    }
                    else
                    {
                        ercl += dco.eptlOrigin();               // So we know where to draw

                    // Compute the clipping complexity and maybe reduce the exclusion rectangle.

                        ECLIPOBJ eco(dco.prgnEffRao(), ercl);

                        if (eco.erclExclude().bEmpty())
                        {
                            bRet = TRUE;
                        }
                        else
                        {
                            XEPALOBJ  epal(pSurf->ppal());
                            XEPALOBJ  epalDC(dco.ppal());
                            PDEVOBJ   pdo(pSurf->hdev());
                            EBRUSHOBJ ebo;


                            PBRUSH pbrush = (BRUSH *)HmgShareCheckLock((HOBJ)hbrush,
                                                                     BRUSH_TYPE);

                            bRet = FALSE;   // assume we won't succeed

                            //
                            // Substitute the NULL brush if this brush handle
                            // couldn't be locked.
                            //
                            if (pbrush != NULL)
                            {
                                //
                                // in case the brush is cached and the color has changed
                                //
                                bSyncBrushObj(pbrush);

                                ebo.vInitBrush(dco.pdc,
                                               pbrush,
                                               epalDC,
                                               epal,
                                               pSurf);

                                ebo.pColorAdjustment(dco.pColorAdjustment());

                                if (!pbrush->bIsNull())
                                {
                                // Exclude the pointer.

                                    DEVEXCLUDEOBJ dxo(dco,&eco.erclExclude(),&eco);

                                // Get and compute the correct mix mode.

                                    MIX mix = ebo.mixBest(dco.pdc->jROP2(),
                                                          dco.pdc->jBkMode());

                                // Inc the target surface uniqueness

                                    INC_SURF_UNIQ(pSurf);

                                // Issue a call to Paint.

                                    EngPaint(
                                          pSurf->pSurfobj(),
                                          &eco,
                                          &ebo,
                                          &dco.pdc->ptlFillOrigin(),
                                          mix);

                                    bRet = TRUE;
                                }

                                DEC_SHARE_REF_CNT_LAZY0(pbrush);
                            }
                        }
                    }

                    dco.pdc->prgnAPI((PREGION) NULL);     // Dirties rgnRao
                }
                else
                {
                    bRet = TRUE;
                }
            }
            else
            {
                bRet = TRUE;
            }

            if (bXform)
            {
            // need to delete the temporary one and put the old one back in so
            // the handle gets unlocked

                ro.prgnGet()->vDeleteREGION();
                ro.vSetRgn(prgnOrg);
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL GreFrameRgn (hdc,hrgn,hbrush,xWidth,yHeight,pac)
*
* Frame the region and fill with the specified brush.
*
\**************************************************************************/

BOOL APIENTRY NtGdiFrameRgn(
HDC        hdc,
HRGN       hrgn,
HBRUSH     hbrush,
int        xWidth,
int        yHeight
)
{
    GDITraceHandle3(NtGdiFrameRgn, "(%X, %X, %X, %d, %d)\n", (va_list)&hdc,
                    hdc, hrgn, hbrush);

    DCOBJ       dco(hdc);
    RGNOBJAPI   ro(hrgn,TRUE);
    BOOL        bRet = FALSE;


    //
    // Take the absolute value just like Win3 does:
    //

    xWidth  = ABS(xWidth);
    yHeight = ABS(yHeight);

    //
    // do some validation
    //

    if (dco.bValid()    &&
         ro.bValid()    &&
         (xWidth > 0)   &&
         (yHeight > 0))
    {

        if (ro.iComplexity() == NULLREGION)
        {
            bRet = TRUE;
        }
        else
        {
            //
            // Convert the region to a path, scaling/rotating it as we do so.
            //

            PATHMEMOBJ  pmoSpine;
            PATHMEMOBJ  pmoWide;
            EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);

            ASSERTGDI(exo.bValid(), "Non valid xform");

            if (pmoSpine.bValid() && pmoWide.bValid())
            {
                if (ro.bCreate(pmoSpine, &exo))
                {
                    EXFORMOBJ exoWiden;
                    LINEATTRS la;
                    MATRIX mx;

                    exoWiden.vInit(&mx, DONT_COMPUTE_FLAGS);

                    //
                    // Initialize line attributes and xform from DC's xform:
                    //

                    pmoSpine.vWidenSetupForFrameRgn(dco, xWidth, yHeight, &exoWiden, &la);

                    //
                    // Make sure we won't expand out of device space before we
                    // widen:
                    //

                    if (pmoWide.bComputeWidenedBounds(pmoSpine, (XFORMOBJ*) &exoWiden, &la) &&
                        pmoWide.bWiden(pmoSpine, (XFORMOBJ*) &exoWiden, &la))
                    {
                        //
                        // Now convert the widened result back into a region:
                        //

                        RGNMEMOBJTMP rmoFill(pmoWide, WINDING);
                        RGNMEMOBJTMP rmoFrame;

                        if (rmoFill.bValid() &&
                            rmoFrame.bValid())
                        {
                            if (dco.pdc->bWorldToDeviceIdentity())
                            {
                                //
                                // We AND the original region and the widened region to get the
                                // frame region:
                                //

                                bRet = rmoFrame.bMerge(rmoFill, ro, gafjRgnOp[RGN_AND]);
                            }
                            else
                            {
                                //
                                // Ugh, we have to transform the original region according to the
                                // world transform before we merge it:
                                //

                                RGNMEMOBJTMP rmo(pmoSpine);

                                bRet = rmo.bValid() &&
                                    rmoFrame.bMerge(rmoFill, rmo, gafjRgnOp[RGN_AND]);
                            }

                            if (bRet)
                            {
                                //
                                // Accumulate bounds.  We can do this before knowing if the operation is
                                // successful because bounds can be loose.
                                //

                                // NOTE - the default return value is now TRUE

                                ERECTL   ercl(0, 0, 0, 0);

                                rmoFrame.vGet_rcl((RECTL *) &ercl);

                                if (dco.fjAccum())
                                {
                                    dco.vAccumulate(ercl);
                                }

                                // in FULLSCREEN mode, exit with success.

                                if (!dco.bFullScreen() && dco.bHasSurface())
                                {
                                    dco.pdc->prgnAPI(rmoFrame.prgnGet());   // Dirties rgnRao

                                    DEVLOCKOBJ dlo(dco);

                                    SURFACE *pSurf = dco.pSurface();

                                    if (!dlo.bValid())
                                    {
                                        dco.pdc->prgnAPI(NULL);     // Dirties rgnRao
                                        bRet = dco.bFullScreen();
                                    }
                                    else
                                    {
                                        ercl += dco.eptlOrigin();

                                        //
                                        // Compute the clipping complexity and maybe reduce the exclusion rectangle.
                                        //

                                        ECLIPOBJ eco(dco.prgnEffRao(), ercl);

                                        if (eco.erclExclude().bEmpty())
                                        {
                                            dco.pdc->prgnAPI(NULL);     // Dirties rgnRao
                                        }
                                        else
                                        {

                                            XEPALOBJ    epal(pSurf->ppal());
                                            XEPALOBJ    epalDC(dco.ppal());
                                            PDEVOBJ     pdo(pSurf->hdev());
                                            EBRUSHOBJ   ebo;

                                            //
                                            // NOTE - the default return value
                                            // is now FALSE;

                                            PBRUSH pbrush = (BRUSH *)HmgShareCheckLock((HOBJ)hbrush, BRUSH_TYPE);

                                            bRet = FALSE;

                                            if (pbrush == NULL)
                                            {
                                                dco.pdc->prgnAPI(NULL);     // Dirties rgnRao
                                            }
                                            else
                                            {
                                                //
                                                // in case the brush is cached and the color has changed
                                                //
                                                bSyncBrushObj (pbrush);

                                                ebo.vInitBrush(dco.pdc,
                                                               pbrush,
                                                               epalDC,
                                                               epal,
                                                               pSurf);

                                                ebo.pColorAdjustment(dco.pColorAdjustment());

                                                if (pbrush->bIsNull())
                                                {
                                                    dco.pdc->prgnAPI(NULL);     // Dirties rgnRao
                                                }
                                                else
                                                {
                                                    //
                                                    // Exclude the pointer.
                                                    //

                                                    DEVEXCLUDEOBJ dxo(dco,&eco.erclExclude(),&eco);

                                                    //
                                                    // Get and compute the correct mix mode.
                                                    //

                                                    MIX mix = ebo.mixBest(dco.pdc->jROP2(), dco.pdc->jBkMode());

                                                    //
                                                    // Inc the target surface uniqueness
                                                    //

                                                    INC_SURF_UNIQ(pSurf);

                                                    //
                                                    // Issue a call to Paint.
                                                    //

                                                    EngPaint(
                                                          pSurf->pSurfobj(),                // Destination surface.
                                                          &eco,                             // Clip object.
                                                          &ebo,                             // Realized brush.
                                                          &dco.pdc->ptlFillOrigin(),        // Brush origin.
                                                          mix);                             // Mix mode.

                                                    dco.pdc->prgnAPI(NULL);                 // Dirties rgnRao

                                                    bRet = TRUE;
                                                }

                                                DEC_SHARE_REF_CNT_LAZY0(pbrush);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* LONG GreGetRgnBox(hrgn,prcl)
*
* Get the bounding box of the region.
*
\**************************************************************************/

int
APIENTRY
GreGetRgnBox(
    HRGN   hrgn,
    LPRECT prcl)
{
    GDITraceHandle(GreGetRgnBox, "(%X, %p)\n", (va_list)&hrgn, hrgn);

    int iret = ERROR;

    RGNOBJAPI ro(hrgn,TRUE);

    if ((prcl != NULL) &&
        (ro.bValid()))
    {
        ro.vGet_rcl((RECTL *) prcl);

        iret = (int)ro.iComplexity();

        if (iret == NULLREGION)
        {
            //
            // Be compatible with Win 3.1 [donalds] 02-Jun-1993
            //

            prcl->left   = 0;
            prcl->top    = 0;
            prcl->right  = 0;
            prcl->bottom = 0;
        }
    }

    return(iret);
}

/******************************Public*Routine******************************\
* BOOL GreInvertRgn(hdc,hrgn)
*
* Invert the colors in the given region.
*
\**************************************************************************/

BOOL NtGdiInvertRgn(
 HDC  hdc,
 HRGN hrgn)
{
    GDITraceHandle2(NtGdiInvertRgn, "(%X, %X)\n", (va_list)&hdc, hdc, hrgn);

    DCOBJ   dco(hdc);
    BOOL    bXform;
    PREGION prgnOrg;
    BOOL    bRet = FALSE;


    if (dco.bValid())
    {
        EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);

        //
        // We may have to scale/rotate the incoming region.
        //

        bXform = !dco.pdc->bWorldToDeviceIdentity();

        RGNOBJAPI   ro(hrgn,TRUE);

        if (ro.bValid())
        {
            if (bXform)
            {
                PATHMEMOBJ  pmo;

                if (!pmo.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }
                if (!exo.bValid() || !ro.bCreate(pmo, &exo))
                    return(FALSE);

                RGNMEMOBJ   rmo(pmo);

                if (!rmo.bValid())
                {
                    SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
                    return(FALSE);
                }

                prgnOrg = ro.prgnGet();
                ro.vSetRgn(rmo.prgnGet());
            }

            //
            // If region is null, return TRUE
            //

            if (ro.iComplexity() != NULLREGION)
            {
                // Accumulate bounds.  We can do this before knowing if the operation is
                // successful because bounds can be loose.

                ERECTL   ercl;

                ro.vGet_rcl((RECTL *) &ercl);

                if (dco.fjAccum())
                    dco.vAccumulate(ercl);

                if (dco.bHasSurface())
                {
                    dco.pdc->prgnAPI(ro.prgnGet());             // Dirties rgnRao

                    DEVLOCKOBJ dlo(dco);

                    SURFACE  *pSurf = dco.pSurface();

                    if (!dlo.bValid())
                    {
                        bRet = dco.bFullScreen();
                    }
                    else
                    {
                        ercl += dco.eptlOrigin();

                    // Compute the clipping complexity and maybe reduce the exclusion rectangle.

                        ECLIPOBJ eco(dco.prgnEffRao(), ercl);

                        if (!eco.erclExclude().bEmpty())
                        {
                            PDEVOBJ pdo(pSurf->hdev());

                        // Exclude the pointer.

                            DEVEXCLUDEOBJ dxo(dco,&eco.erclExclude(),&eco);

                        // Inc the target surface uniqueness

                            INC_SURF_UNIQ(pSurf);

                        // Issue a call to Paint.

                            EngPaint(
                                  pSurf->pSurfobj(),                // Destination surface.
                                  &eco,                             // Clip object.
                                  (BRUSHOBJ *) NULL,                // Realized brush.
                                  (POINTL *) NULL,                  // Brush origin.
                                  0x00000606);                      // R2_NOT
                        }

                        bRet = TRUE;
                    }

                    dco.pdc->prgnAPI((PREGION)NULL);     // Dirties rgnRao
                }
                else
                {
                    bRet = TRUE;
                }
            }
            else
            {
                bRet = TRUE;
            }


            if (bXform)
            {
            // need to delete the temporary one and put the old one back in so
            // the handle gets unlocked

                ro.prgnGet()->vDeleteREGION();
                ro.vSetRgn(prgnOrg);
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* LONG GreOffsetRgn(hrgn,x,y)
*
* Offset the given region.
*
\**************************************************************************/

int
APIENTRY
GreOffsetRgn(
    HRGN hrgn,
    int  x,
    int  y)
{
    GDITraceHandle(GreOffsetRgn, "(%X, %d, %d)\n", (va_list)&hrgn, hrgn);

    RGNOBJAPI ro(hrgn,FALSE);
    POINTL    ptl;
    int       iRet = ERROR;

    ptl.x = x;
    ptl.y = y;

    if (ro.bValid())
    {
        if (ro.bOffset(&ptl))
        {
            iRet = ro.iComplexity();
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* BOOL GrePtInRegion(hrgn,x,y)
*
* Is the point in the region?
*
\**************************************************************************/

BOOL APIENTRY GrePtInRegion(
 HRGN hrgn,
 int x,
 int y)
{
    GDITraceHandle(GrePtInRegion, "(%X, %d, %d)\n", (va_list)&hrgn, hrgn);

    RGNOBJAPI ro(hrgn,TRUE);

    if (!ro.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return((BOOL) ERROR);
    }

    POINTL  ptl;

    ptl.x = x;
    ptl.y = y;

    return(ro.bInside(&ptl) == REGION_POINT_INSIDE);
}

/******************************Public*Routine******************************\
* BOOL GreRectInRegion(hrgn,prcl)
*
* Is any part of the rectangle in the region?
*
\**************************************************************************/

BOOL
APIENTRY
GreRectInRegion(
    HRGN   hrgn,
    LPRECT prcl)
{
    GDITraceHandle(GreRectInRegion, "(%X, %p)\n", (va_list)&hrgn, hrgn);

    BOOL bRet = ERROR;
    RGNOBJAPI   ro(hrgn,TRUE);

    if (prcl &&
        (ro.bValid()))
    {
        bRet = (ro.bInside((RECTL *) prcl) == REGION_RECT_INTERSECT);
    }

    return (bRet);
}

/******************************Public*Routine******************************\
* VOID GreSetRectRgn(hrgn,xLeft,yTop,xRight,yBottom)
*
* Set the region to be the specified rectangle
*
\**************************************************************************/

BOOL
APIENTRY
GreSetRectRgn(
    HRGN hrgn,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom)
{
    GDITraceHandle(GreSetRectRgn, "(%X, %d, %d, %d, %d)\n", (va_list)&hrgn, hrgn);

    RGNOBJAPI   ro(hrgn,FALSE);
    BOOL bRet = ERROR;

    if (ro.bValid())
    {
        ERECTL   ercl(xLeft, yTop, xRight, yBottom);

        if (VALID_SCRPRC((RECTL *) &ercl))
        {
            ercl.vOrder();       // Make the rectangle well ordered.

            ro.vSet((RECTL *) &ercl);

            bRet = TRUE;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* LONG GreExcludeClipRect(hdc,xLeft,yTop,xRight,yBottom)
*
* Subtract the rectangle from the current clip region
*
\**************************************************************************/

int APIENTRY GreExcludeClipRect(
    HDC hdc,
    int xLeft,
    int yTop,
    int xRight,
    int yBottom)
{
    GDITraceHandle(GreExcludeClipRect, "(%X, %d, %d, %d, %d)\n", (va_list)&hdc,
                   hdc);

    int     iRet;
    DCOBJ   dco(hdc);

    if (dco.bValid())
    {
        // For speed, test for rotation upfront.

        EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);
        ERECTL      ercl(xLeft, yTop, xRight, yBottom);

        if (!exo.bRotation())
        {
            exo.vOrder(*(RECTL *)&ercl);
            exo.bXform(ercl);

            iRet = (int)dco.pdc->iCombine((RECTL *) &ercl,RGN_DIFF);
        }
        else if (!VALID_SCRPRC((RECTL *) &ercl))
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            iRet = ERROR;
        }
        else
        {
            iRet = (int) dco.pdc->iCombine(&exo, (RECTL *) &ercl,RGN_DIFF);
        }

        if (iRet > NULLREGION)
        {
            iRet = COMPLEXREGION;
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        iRet = ERROR;
    }

    return (iRet);
}

/******************************Public*Routine******************************\
* LONG GreGetAppClipBox(hdc,prcl)
*
* Get the bounding box of the clip region
*
\**************************************************************************/

int APIENTRY GreGetAppClipBox(
     HDC    hdc,
     LPRECT prcl)
{
    GDITraceHandle(GreGetAppClipBox, "(%X, %p)\n", (va_list)&hdc, hdc);

    DCOBJ   dor(hdc);
    int     iRet;
    int iSaveLeft;

    if (dor.bValid())
    {
        DEVLOCKOBJ  dlo(dor);

        if (!dlo.bValid())
        {
            if (dor.bFullScreen())
            {
                prcl->left = 0;             // Make it a 'simple' empty rectangle
                prcl->right = 0;
                prcl->top = 0;
                prcl->bottom = 0;
                return(COMPLEXREGION);
            }
            else
            {
                return(ERROR);
            }
        }

        RGNOBJ  ro(dor.prgnEffRao());

        ro.vGet_rcl((RECTL *) prcl);

        //
        // return to logical coordinates
        //

        if ((prcl->left >= prcl->right) || (prcl->top >= prcl->bottom))
        {
            prcl->left = 0;             // Make it a 'simple' empty rectangle
            prcl->right = 0;
            prcl->top = 0;
            prcl->bottom = 0;

            iRet = NULLREGION;
        }
        else
        {
            EXFORMOBJ xfoDtoW(dor, DEVICE_TO_WORLD);

            if (xfoDtoW.bValid())
            {
                *(ERECTL *)prcl -= dor.eptlOrigin();

                if (!xfoDtoW.bRotation())
                {
                    if (xfoDtoW.bXform(*(ERECTL *)prcl))
                    {
                        iRet = ro.iComplexity();

                        //
                        // Transforms with negative scale can give 
                        // a prcl that is not in vOrder.
                        //

                        //
                        // This is the correct fix, but some apps require the
                        // previous bad behaviour.
                        //
                        //((ERECTL *)prcl)->vOrder();
                    }
                    else
                    {
                        iRet = ERROR;
                    }
                }
                else
                {
                    POINTL aptl[4];

                    aptl[0].x = prcl->left;
                    aptl[0].y = prcl->top;
                    aptl[1].x = prcl->right;
                    aptl[1].y = prcl->top;
                    aptl[2].x = prcl->left;
                    aptl[2].y = prcl->bottom;
                    aptl[3].x = prcl->right;
                    aptl[3].y = prcl->bottom;

                    xfoDtoW.bXform(aptl, 4);

                    prcl->left   = MIN4(aptl[0].x, aptl[1].x, aptl[2].x, aptl[3].x);
                    prcl->top    = MIN4(aptl[0].y, aptl[1].y, aptl[2].y, aptl[3].y);
                    prcl->right  = MAX4(aptl[0].x, aptl[1].x, aptl[2].x, aptl[3].x);
                    prcl->bottom = MAX4(aptl[0].y, aptl[1].y, aptl[2].y, aptl[3].y);

                    iRet = COMPLEXREGION;
                }
            }
            else
            {
                iRet = ERROR;
            }
        }
        if ((iRet != ERROR) && MIRRORED_DC(dor.pdc) && (prcl->left > prcl->right)) {
            iSaveLeft   = prcl->left;
            prcl->left  = prcl->right;
            prcl->right = iSaveLeft;
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        iRet = ERROR;
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* int GreGetRandomRgn(hdc,hrgn,iNum)
*
* Copy the specified region into the handle provided
*
\**************************************************************************/

int GreGetRandomRgn(
HDC  hdc,
HRGN hrgn,
int  iNum)
{
    GDITraceHandle2(GreGetRandomRgn, "(%X, %X, %d)\n", (va_list)&hdc, hdc, hrgn);

    DCOBJ   dor(hdc);
    PREGION prgnSrc1, prgnSrc2;
    int     iMode = RGN_COPY;

    int iRet = -1;

    if (!dor.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }
    else
    {
        DEVLOCKOBJ  dlo(dor);

        switch(iNum)
        {
        case 1:
            prgnSrc1 = dor.pdc->prgnClip();
            break;

        case 2:
            prgnSrc1 = dor.pdc->prgnMeta();
            break;

        case 3:
            prgnSrc1 = dor.pdc->prgnClip();
            prgnSrc2 = dor.pdc->prgnMeta();

            if (prgnSrc1 == NULL)           // prgnSrc1 == 0, prgnSrc2 != 0
            {
                prgnSrc1 = prgnSrc2;
            }
            else if (prgnSrc2 != NULL)      // prgnSrc1 != 0, prgnSrc2 != 0
            {
                iMode = RGN_AND;
            }
            break;

        case 4:
            ASSERTDEVLOCK(dor.pdc);
            prgnSrc1 = dor.pdc->prgnVis();
            break;

        default:
            prgnSrc1 = NULL;
        }

        if (prgnSrc1 == NULL)
        {
            iRet = 0;
        }
        else
        {
            RGNOBJAPI ro(hrgn,FALSE);

            if (ro.bValid())
            {
                RGNOBJ ro1(prgnSrc1);

                if (iMode == RGN_COPY)
                {
                    if (ro.bCopy(ro1))
                    {
                         // For a redirection DC, the surface originates at the
                         // redirected window origin. For compatibility reasons,
                         // we must return the visrgn in screen coordinates.

                        if (iNum == 4 && dor.pdc->bRedirection())
                        {
                            POINTL ptl;

                            if (UserGetRedirectedWindowOrigin(hdc,
                                    (LPPOINT)&ptl) && ro.bOffset(&ptl))
                            {
                                iRet = 1;
                            }
                        }
                        else
                        {
                            iRet = 1;
                        }
                    }
                }
                else
                {
                    RGNOBJ ro2(prgnSrc2);

                    if (ro.iCombine(ro1,ro2,iMode) != RGN_ERROR)
                        iRet = 1;
                }
            }
        }
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* LONG GreIntersectClipRect(hdc,xLeft,yTop,xRight,yBottom)
*
* AND the rectangle with the current clip region
*
\**************************************************************************/

int APIENTRY GreIntersectClipRect(
HDC hdc,
int xLeft,
int yTop,
int xRight,
int yBottom)
{
    GDITraceHandle(GreIntersectClipRect, "(%X, %d, %d, %d, %d)\n", (va_list)&hdc,
                   hdc);

    DCOBJ   dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(ERROR);
    }

    EXFORMOBJ   exo(dco, WORLD_TO_DEVICE);
    ERECTL      ercl(xLeft, yTop, xRight, yBottom);

// For speed, test for rotation up front.

    int iRet;

    if (!exo.bRotation())
    {
        exo.vOrder(*(RECTL *)&ercl);
        exo.bXform(ercl);

        iRet = (int)dco.pdc->iCombine((RECTL *) &ercl,RGN_AND);
    }
    else if (!VALID_SCRPRC((RECTL *) &ercl))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        iRet = ERROR;
    }
    else
    {
        iRet = (int)dco.pdc->iCombine(&exo, (RECTL *) &ercl,RGN_AND);
    }

    if (iRet > NULLREGION)
        iRet = COMPLEXREGION;

    return(iRet);
}

 /******************************Public*Routine******************************\
* INT NtGdiOffsetClipRgn(hdc,x,y)
*
* Offset the current clip region
*
\**************************************************************************/

int APIENTRY
NtGdiOffsetClipRgn(
 HDC  hdc,
 int x,
 int y)
{
    GDITraceHandle(NtGdiOffsetClipRgn, "(%X, %d, %d)\n", (va_list)&hdc, hdc);

    DCOBJ   dor(hdc);

    if (!dor.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(ERROR);
    }

    PREGION prgn = dor.pdc->prgnClip();

    if (prgn == NULL)
        return(SIMPLEREGION);

// if this region has multiple references (saved levels) we need to duplicate
// it and modify the copy.

    if (prgn->cRefs > 1)
    {
        RGNOBJ ro(prgn);

        RGNMEMOBJ rmo(ro.sizeRgn());

        if (!rmo.bValid())
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            return(ERROR);
        }

        rmo.vCopy(ro);
        prgn = rmo.prgnGet();

        rmo.vSelect(hdc);
        ro.vUnselect();

        dor.pdc->prgnClip(prgn);

    }

    RGNOBJ ro(prgn);

    EPOINTL  eptl(x, y);

// Transform the point from Logical to Device

    EXFORMOBJ xfo(dor, WORLD_TO_DEVICE);

    if (!xfo.bXform(*((EVECTORL *) &eptl)) || !ro.bOffset((PPOINTL)&eptl))
    {
        SAVE_ERROR_CODE(ERROR_CAN_NOT_COMPLETE);
        return(ERROR);
    }

    dor.pdc->vReleaseRao();

    dor.pdc->vUpdate_VisRect(dor.pdc->prgnVis());

    return(ro.iComplexity());
}


/******************************Public*Routine******************************\
* BOOL GrePtVisible(hdc,x,y)
*
* Is the point in the current clip region?
*
\**************************************************************************/

BOOL
APIENTRY
NtGdiPtVisible(
    HDC  hdc,
    int x,
    int y)
{
    DCOBJ dor(hdc);

    if (!dor.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(ERROR_BOOL);
    }

    DEVLOCKOBJ dlo(dor);

    if (!dlo.bValid())
        return(REGION_POINT_OUTSIDE);

    RGNOBJ  ro(dor.prgnEffRao());

    EPOINTL  eptl(x, y);

// Transform the point from Logical to Screen

    EXFORMOBJ xfo(dor, WORLD_TO_DEVICE);
    xfo.bXform(eptl);

    eptl += dor.eptlOrigin();

    return(ro.bInside((PPOINTL)&eptl) == REGION_POINT_INSIDE);
}

/******************************Public*Routine******************************\
* BOOL GreRectVisible(hdc,prcl)
*
* Is the rectangle in the current clip region?
*
\**************************************************************************/

BOOL APIENTRY GreRectVisible(
HDC    hdc,
LPRECT prcl)
{
    DCOBJ   dor(hdc);

    if (!dor.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(ERROR_BOOL);
    }

    DEVLOCKOBJ dlo(dor);

    if (!dlo.bValid())
        return(REGION_RECT_OUTSIDE);

    RGNOBJ  ro(dor.prgnEffRao());

    ERECTL  ercl = *((ERECTL *) prcl);

// Transform the rectangle from Logical to Screen

    EXFORMOBJ xfo(dor, WORLD_TO_DEVICE);

// If there is no rotation in the transform, just call bInside().

    if (!xfo.bRotation())
    {
        xfo.vOrder(*(RECTL *)&ercl);
        xfo.bXform(ercl);

        ercl += dor.eptlOrigin();

        BOOL   bIn = ro.bInside((RECTL *) &ercl);

        return(bIn == REGION_RECT_INTERSECT);
    }

// Convert the rectangle to a parallelogram and merge it with the Rao.
// If there is anything left, the call succeeded.

    POINTL  aptl[4];

    aptl[0].x = prcl->left;
    aptl[0].y = prcl->top;
    aptl[1].x = prcl->right;
    aptl[1].y = prcl->top;
    aptl[2].x = prcl->right;
    aptl[2].y = prcl->bottom;
    aptl[3].x = prcl->left;
    aptl[3].y = prcl->bottom;

// Create a path, and draw the parallelogram.

    PATHMEMOBJ  pmo;
    BOOL bRes;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        bRes = ERROR_BOOL;
    }
    else if (!pmo.bMoveTo(&xfo, &aptl[0]) ||
             !pmo.bPolyLineTo(&xfo, &aptl[1], 3) ||
             !pmo.bCloseFigure())
    {
        bRes = ERROR_BOOL;
    }
    else
    {
    // Now, convert it back into a region.

        RGNMEMOBJTMP rmoPlg(pmo, ALTERNATE);
        RGNMEMOBJTMP rmo;

        if (!rmoPlg.bValid() || !rmo.bValid())
        {
            SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            bRes = ERROR_BOOL;
        }
        else
        {
            if (!rmo.bMerge(ro, rmoPlg, gafjRgnOp[RGN_AND]) ||
                (rmo.iComplexity() == NULLREGION))
            {
                bRes = (BOOL)REGION_RECT_OUTSIDE;
            }
            else
            {
                bRes = (BOOL)REGION_RECT_INTERSECT;
            }
        }
    }

    return(bRes);
}

/******************************Public*Routine******************************\
* int GreExtSelectClipRgn(hdc,hrgn,iMode)
*
* Merge the region into current clip region
*
\**************************************************************************/

int
GreExtSelectClipRgn(
    HDC  hdc,
    HRGN hrgn,
    int  iMode)
{
    GDITraceHandle2(GreExtSelectClipRgn, "(%X, %X, %d)\n", (va_list)&hdc,
                    hdc, hrgn);

    int iRet = RGN_ERROR;
    BOOL bSame = FALSE;

    if (((iMode < RGN_MIN) || (iMode > RGN_MAX)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        DCOBJ   dco(hdc);
        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
        else
        {
            if (hrgn != (HRGN)0)
            {
                RGNOBJAPI ro(hrgn,TRUE);

                if (ro.bValid())
                {
                    iRet = dco.pdc->iSelect(ro.prgnGet(),iMode);

                    if (iRet != RGN_ERROR)
                    {
                        DEVLOCKOBJ dlo(dco);
                        RGNOBJ ro(dco.prgnEffRao());
                        iRet = ro.iComplexity();
                    }
                }

            }
            else
            {
                if (iMode == RGN_COPY)
                {
                    iRet = dco.pdc->iSelect((PREGION)NULL,iMode);

                    if (iRet != RGN_ERROR)
                    {
                        DEVLOCKOBJ dlo(dco);
                        RGNOBJ roVis(dco.pdc->prgnVis());
                        iRet = roVis.iComplexity();
                    }
                }
            }
        }
    }


    return(iRet);
}


/******************************Public*Routine******************************\
*   SelectClip from bathcing
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    26-Oct-1995 -by- Mark Enstrom [marke]
*
\**************************************************************************/

GreExtSelectClipRgnLocked(
    XDCOBJ    &dco,
    PRECTL    prcl,
    int       iMode)
{
    int  iRet = RGN_ERROR;
    BOOL bNullHrgn = iMode & REGION_NULL_HRGN;

    iMode &= ~REGION_NULL_HRGN;

    if (((iMode < RGN_MIN) || (iMode > RGN_MAX)))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
    }
    else
    {
        if (!dco.bValid())
        {
            SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        }
        else
        {
            //
            // iFlag specifies a null hrgn
            //

            if (!bNullHrgn)
            {
                //
                // check if current region is the same as new
                // hrgn
                //

                BOOL bSame = FALSE;

                RGNOBJ roClipOld(dco.pdc->prgnClip());

                if (roClipOld.bValid())
                {
                    if (roClipOld.bRectl())
                    {
                        RECTL rclOld;
                        roClipOld.vGet_rcl(&rclOld);

                        if (
                             (prcl->left   == rclOld.left)  &&
                             (prcl->top    == rclOld.top)   &&
                             (prcl->right  == rclOld.right) &&
                             (prcl->bottom == rclOld.bottom)
                           )
                        {
                            RGNOBJ ro(dco.prgnEffRao());
                            iRet = ro.iComplexity();
                            bSame = TRUE;
                        }
                    }
                }

                //
                // regions don't match, must select new region into DC
                //

                if (!bSame)
                {
                    RGNMEMOBJTMP ro(FALSE);

                    if (ro.bValid())
                    {
                        ro.vSet(prcl);

                        iRet = dco.pdc->iSelect(ro.prgnGet(),iMode);

                        //
                        // need to update RAO
                        //

                        if (dco.pdc->bDirtyRao())
                        {
                            if (!dco.pdc->bCompute())
                            {
                                WARNING("bCompute fails in GreExtSelectClipRgnLocked");
                            }
                        }

                        if (iRet != RGN_ERROR)
                        {
                            RGNOBJ ro(dco.prgnEffRao());
                            iRet = ro.iComplexity();
                        }
                    }
                }
            }
            else
            {
                if (iMode == RGN_COPY)
                {
                    iRet = dco.pdc->iSelect((PREGION)NULL,iMode);

                    //
                    // need to update RAO
                    //

                    if (dco.pdc->bDirtyRao())
                    {
                        if (!dco.pdc->bCompute())
                        {
                            WARNING("bCompute fails in GreExtSelectClipRgnLocked");
                        }
                    }

                    if (iRet != RGN_ERROR)
                    {
                        RGNOBJ roVis(dco.pdc->prgnVis());
                        iRet = roVis.iComplexity();
                    }
                }
            }
        }
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* int GreStMetaRgn(hdc,hrgn,iMode)
*
* Merge the region into current meta region
*
\**************************************************************************/

int GreSetMetaRgn(
    HDC hdc)
{
    DCOBJ dco(hdc);

    if (!dco.bValid())
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        return(ERROR);
    }

    return(dco.pdc->iSetMetaRgn());
}

/******************************Public*Routine******************************\
* GreGetRegionData
*
* Retreives the region data
*
* History:
*  5-Dec-1997 -by- Samer Arafeh   [samera]
* Wrote it.
\**************************************************************************/
DWORD
GreGetRegionData(
    HRGN      hrgn,
    DWORD     nCount,
    LPRGNDATA lpRgnData)
{
    GDITraceHandle(GreGetRegionData, "(%X, %u, %p)\n", (va_list)&hrgn, hrgn);

    DWORD       nSize;
    DWORD       nRectangles;
    DWORD       nRgnSize;  // size of buffer of rectangles
    RGNOBJAPI   ro(hrgn,TRUE);

    if (ro.bValid())
    {
        //
        // just return size if buffer is NULL
        //

        nRgnSize = ro.sizeSave();
        nSize = nRgnSize + sizeof(RGNDATAHEADER);

        if (lpRgnData != (LPRGNDATA) NULL)
        {
            if (nSize > nCount)
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                nSize = ERROR;
            }
            else
            {
                nRectangles = (nSize - sizeof(RGNDATAHEADER)) / sizeof(RECTL);

                lpRgnData->rdh.dwSize = sizeof(RGNDATAHEADER);
                lpRgnData->rdh.iType  = RDH_RECTANGLES;
                lpRgnData->rdh.nCount = nRectangles;
                lpRgnData->rdh.nRgnSize = nRgnSize;
                if (nRectangles != 0)
                {
                    ro.vGet_rcl((RECTL *) &lpRgnData->rdh.rcBound);
                }
                else
                {
                    lpRgnData->rdh.rcBound.left = 0;
                    lpRgnData->rdh.rcBound.top = 0;
                    lpRgnData->rdh.rcBound.right = 0;
                    lpRgnData->rdh.rcBound.bottom = 0;
                }
                ro.vDownload((PVOID) &lpRgnData->Buffer);
            }
        }
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        nSize = ERROR;
    }

    return(nSize);
}


/******************************Public*Routine******************************\
* DWORD NtGdiGetRegionData(hrgn, nCount, lpRgnData)
*
* Compute size of buffer/copy region data to buffer
*
\**************************************************************************/
DWORD
NtGdiGetRegionData(
    HRGN      hrgn,
    DWORD     nCount,
    LPRGNDATA lpRgnData)
{
    GDITraceHandle(NtGdiGetRegionData, "(%X, %u, %p)\n", (va_list)&hrgn, hrgn);

    DWORD     nSize=!ERROR;
    ULONG     ulTemp[QUANTUM_REGION_SIZE/2];
    LPRGNDATA prgnTemp=NULL;

    //
    // If it is valid user pointer, let's copy into
    // into kernel memory (we don't know what the user might do with this memory)
    //

    if (lpRgnData)
    {
        if (nCount <= sizeof(ulTemp))
            prgnTemp = (PRGNDATA) ulTemp;
        else
            prgnTemp = (PRGNDATA)AllocFreeTmpBuffer(nCount);

        if (!prgnTemp)
        {
            SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
            nSize = ERROR;
        }
    }

    //
    // Check if allocation (if happened) is ok ?
    //

    if (nSize != ERROR)
    {
        nSize = GreGetRegionData( hrgn , nCount , prgnTemp );


        //
        // Copy retreived data to user-buffer
        //

        if (lpRgnData && (nSize != ERROR))
        {
            __try
            {
                ProbeForWrite(lpRgnData,nSize, sizeof(DWORD));
                RtlCopyMemory( lpRgnData , prgnTemp , nSize );
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
                nSize = ERROR;
            }
        }
    }


    //
    // And free the kernel memory, if allocated
    //

    if (prgnTemp && (prgnTemp != (PRGNDATA)&ulTemp[0]))
    {
        FreeTmpBuffer(prgnTemp);
    }


    return(nSize);
}

/******************************Public*Routine******************************\
* HRGN GreExtCreateRegion(lpXform, nCount, lpRgnData)
*
* Create a region from a region data buffer
*
\**************************************************************************/


HRGN
GreExtCreateRegion(
    XFORML   *lpXform,
    DWORD     nCount,
    LPRGNDATA lpRgnData)
{
    GDITrace(GreExtCreateRegion, "(%p, %u, %p)\n", (va_list)&lpXform);

    ASSERTGDI(nCount >= sizeof(RGNDATAHEADER), "GreExtCreateRegion: passed invalid count");

    DWORD   nSize = lpRgnData->rdh.dwSize;
    ULONG   cRect = lpRgnData->rdh.nCount;

    if (nSize != sizeof(RGNDATAHEADER))
    {
        WARNING("GreExtCreateRegion: bad nSize");
        return((HRGN) 0);
    }

    if (cRect > ((MAXULONG - sizeof(RGNDATAHEADER)) / sizeof (RECTL)))
    {
        // cRect is too large, which will cause the computation for nSize below to overflow.
        return ((HRGN) 0);
    }

    nSize += (cRect * sizeof(RECTL));

    if (nSize > nCount)
        return((HRGN) 0);

    // At this point we have what looks like a valid header, and a buffer that
    // is at least big enough to contain all the data for a region.  Create a
    // region to contain it and then attempt to upload the data into the region.

    
    RGNMEMOBJ rmo;
    
    if(!rmo.bValid())
    {
        rmo.bDeleteRGNOBJ();
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    RECTL *prcl = (RECTL *)lpRgnData->Buffer;
    
    if(!rmo.bSet(cRect, prcl))
    {
        rmo.bDeleteRGNOBJ();
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    HRGN hrgn;

    if ((lpXform == NULL) || (rmo.iComplexity() == NULLREGION))
    {
        //
        // Create the proper bounding box and make it long lived
        //

        rmo.vTighten();

        hrgn = rmo.hrgnAssociate();

        if (hrgn == NULL)
        {
            rmo.bDeleteRGNOBJ();
        }

        GDITrace(GreExtCreateRegion_return, "(%X)\n", (va_list)&hrgn);

        return(hrgn);
    }

    //
    // Convert the XFORM to a MATRIX
    //

    MATRIX  mx;

    vConvertXformToMatrix(lpXform, &mx);

    //
    // Scale it to FIXED notation.
    //

    mx.efM11.vTimes16();
    mx.efM12.vTimes16();
    mx.efM21.vTimes16();
    mx.efM22.vTimes16();
    mx.efDx.vTimes16();
    mx.efDy.vTimes16();
    mx.fxDx *= 16;
    mx.fxDy *= 16;

    EXFORMOBJ   exo(&mx, XFORM_FORMAT_LTOFX | COMPUTE_FLAGS);

    if (!exo.bValid())
    {
        rmo.bDeleteRGNOBJ();
        return((HRGN) 0);
    }

    //
    // If the xform is the identity, we don't have to do anything.
    //

    if (exo.bIdentity())
    {
        //
        // Create the proper bounding box and make it long lived
        //

        rmo.vTighten();
        hrgn = rmo.hrgnAssociate();

        if (hrgn == NULL)
        {
            rmo.bDeleteRGNOBJ();
        }

        GDITrace(GreExtCreateRegion_return, "(%X)\n", (va_list)&hrgn);

        return(hrgn);
    }

    //
    // Create a path from the region
    //

    PATHMEMOBJ  pmo;

    if (!pmo.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        rmo.bDeleteRGNOBJ();
        return((HRGN) 0);
    }

    BOOL bSuccess = rmo.bCreate(pmo, &exo);

    //
    // done with the region, delete it now.
    //

    rmo.bDeleteRGNOBJ();

    if (!bSuccess)
    {
        return((HRGN) 0);
    }

    //
    // Create a region from the path
    //

    RGNMEMOBJTMP rmoPath(pmo);

    if (!rmoPath.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    RGNMEMOBJ rmoFinal;

    if (!rmoFinal.bValid())
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return((HRGN) 0);
    }

    //
    // coelece the region
    //

    rmoFinal.iReduce(rmoPath);

    //
    // Create the proper bounding box and make it long lived
    //

    rmoFinal.vTighten();

    hrgn = rmoFinal.hrgnAssociate();

    if (hrgn == NULL)
    {
        rmoFinal.bDeleteRGNOBJ();
    }

    GDITrace(GreExtCreateRegion_return, "(%X)\n", (va_list)&hrgn);

    return(hrgn);
}

/******************************Public*Routine******************************\
* BOOL GreIntersectVisRect(hdc, xLeft, yTop, xRight, yBottom)
*
* Intersect (AND) the rectangle with the vis region
*
* Warnings:
*   This is a PRIVATE USER API.
*
\**************************************************************************/

BOOL GreIntersectVisRect(
 HDC hdc,
 int xLeft,
 int yTop,
 int xRight,
 int yBottom)
{
    BOOL bRes = FALSE;

    //
    // fail bad ordered rectangles
    //
    if ((xLeft>=xRight) || (yTop>=yBottom))
    {
        return(FALSE);
    }

    //
    // fail bad coordinates
    //
    if ((xLeft<MIN_REGION_COORD)  ||
        (xRight>MAX_REGION_COORD) ||
        (yTop<MIN_REGION_COORD)   ||
        (yBottom>MAX_REGION_COORD))
    {
        return(FALSE);
    }

    DCOBJA  dov(hdc);               // Use ALTLOCK

    if (dov.bValid())    // don't trust them the DC to be valid
    {
        // We invoke the 'dlo(po)' devlock form instead of 'dlo(dco)'
        // to avoid the bCompute that the latter does:

        PDEVOBJ po(dov.hdev());
        DEVLOCKOBJ dlo(po);

        ASSERTDEVLOCK(dov.pdc);

        if (dlo.bValid())
        {
            RGNOBJ  ro(dov.pdc->prgnVis());

            ERECTL  ercl(xLeft, yTop, xRight, yBottom);

            RGNMEMOBJTMP rmo;
            RGNMEMOBJTMP rmo2(ro.sizeRgn());

            if (!rmo.bValid() || !rmo2.bValid())
            {
                SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
            }
            else
            {
                rmo.vSet((RECTL *) &ercl);
                rmo2.vCopy(ro);

                if (ro.iCombine(rmo, rmo2, RGN_AND) != ERROR)
                {
                    dov.pdc->prgnVis(ro.prgnGet());
                    ro.prgnGet()->vStamp();
                    dov.pdc->vReleaseRao();

                    bRes = TRUE;
                }
            }
        }

        RGNLOG rl((HRGN) dov.pdc->prgnVis(),0,"GreIntersectVisRect",(ULONG_PTR)hdc);
        rl.vRet((ULONG_PTR)bRes);
    }
    #if DBG
    else
    {
        //
        // USER may send a NULL hdc in low memory situations.
        // Just print a warning for those situations, but rip
        // for other bad handles (i.e., USER should figure out
        // why they passed us a bad handle).
        //

        if (hdc)
        {
            RIP("GDISRV!GreSelectVisRgn: Bad hdc\n");
        }
        else
        {
            WARNING("GDISRV!GreSelectVisRgn: hdc NULL\n");
        }
    }
    #endif

    return(bRes);
}

#if DBG

/******************************Public*Routine******************************\
* GreValidateVisrgn()
*
* History:
*  10-Dec-1998 -by-  Vadim Gorokhovsky [vadimg]
* Wrote it.
\**************************************************************************/

VOID
GreValidateVisrgn(
    HDC hdc,
    BOOL bValidateVisrgn
    )
{
    DCOBJA dco(hdc);

    if (dco.bValid())
    {
        dco.pdc->vValidateVisrgn(bValidateVisrgn);

        if (bValidateVisrgn)
        {
            PDEVOBJ pdo(dco.hdev());
            SURFACE *pSurf = dco.pSurface();
            REGION *prgn = dco.pdc->prgnVis();

            if (pdo.bValid() && !pdo.bMetaDriver() && pSurf && prgn)
            {
                BOOL bIsOK = ((pSurf->sizl().cx >= prgn->rcl.right) &&
                              (pSurf->sizl().cy >= prgn->rcl.bottom)&&
                              (prgn->rcl.left >= 0) &&
                              (prgn->rcl.top >= 0));

                ASSERTGDI(bIsOK, "Rgn size is bigger than surface size");
            }
        }
    }
}

#endif

/******************************Public*Routine******************************\
* HRGN GreSelectVisRgn(hdc,hrgn,fl)
*
* Select the region as the new vis region
*
* flags - only one of these may be passed in
*
*   SVR_COPYNEW   - make a copy of region passed in, deletes the old one
*   SVR_DELETEOLD - use the select rgn, delete the old one
*   SVR_SWAP      - swaps the contents of the hrgn and the visrgn
*
* Warnings:
*   This is a PRIVATE USER API.
*
\**************************************************************************/

BOOL
GreSelectVisRgn(
    HDC               hdc,
    HRGN              hrgn,
    VIS_REGION_SELECT fl)
{
    RGNLOG rl(hrgn,NULL,"GreSelectVisRgn",(ULONG_PTR)hdc,(ULONG_PTR)fl);

    ASSERTGDI((fl == SVR_COPYNEW  ) ||
              (fl == SVR_DELETEOLD) ||
              (fl == SVR_SWAP     ), "GreSelectVisRgn - invalid fl\n");

    BOOL bRet;

    //
    // Share Lock DC
    //

    DCOBJA   dco(hdc);
    PREGION  prgnOld;
    PREGION  prgn;

    ASSERTDEVLOCK(dco.pdc);

    //
    // Always validate input hdc
    //

    if (!dco.bValid())
    {
    #if DBG
        //
        // USER may send a NULL hdc in low memory situations.
        // Just print a warning for those situations, but rip
        // for other bad handles (i.e., USER should figure out
        // why they passed us a bad handle).
        //

        if (hdc)
        {
            RIP("GDISRV!GreSelectVisRgn: Bad hdc\n");
        }
        else
        {
            WARNING("GDISRV!GreSelectVisRgn: hdc NULL\n");
        }
    #endif
        bRet = FALSE;
    }
    else
    {
        bRet = TRUE;

        //
        // Always nuke the Rao
        //

        dco.pdc->vReleaseRao();

        BOOL bDeleteOld = TRUE;

        if (hrgn != (HRGN) NULL)
        {
            //
            // The incoming region may be some random thing, make it lockable
            //

            GreSetRegionOwner(hrgn, OBJECT_OWNER_PUBLIC);

            RGNOBJAPI ro(hrgn,FALSE);

            if (ro.bValid())
            {
                 #if DBG
                     //
                     // Make Sure USER is not going to give us a RGN bigger than the surface
                     // Note: USER may select a bogus rgn in during ReleaseDC time, we don't want
                     // to assert there.
                     //
                     // To make things easy, we only check for single monitors
                     //
                     PDEVOBJ pdo(dco.hdev());

                     if (pdo.bValid() && !pdo.bMetaDriver())
                     {
                        UINT uiIndex = (UINT) HmgIfromH((HOBJ)hdc);

                        PENTRY pentTmp = &gpentHmgr[uiIndex];

                        SURFACE *pSurf = dco.pSurface();

                        if (pSurf &&
                           dco.pdc->bValidateVisrgn() &&
                           (OBJECTOWNER_PID(pentTmp->ObjectOwner) != OBJECT_OWNER_NONE))
                        {
                            BOOL bIsOK = ((pSurf->sizl().cx >= ro.prgn->rcl.right) &&
                                         (pSurf->sizl().cy >= ro.prgn->rcl.bottom)&&
                                         (ro.prgn->rcl.left >= 0) &&
                                         (ro.prgn->rcl.top >= 0));

                            ASSERTGDI(bIsOK, "Rgn size is bigger than surface size");
                        }
                     }

                 #endif

                switch (fl)
                {
                case SVR_COPYNEW:
                    {
                        //
                        // We need to make a copy of the new one and delete the old one
                        //

                        RGNMEMOBJ rmo(ro.sizeRgn());

                        if (!rmo.bValid())
                        {
                            prgn = prgnDefault;
                        }
                        else
                        {
                            rmo.vCopy(ro);
                            prgn = rmo.prgnGet();
                        }
                    }
                    break;

                case SVR_SWAP:
                    {
                        //
                        // we need to just swap handles.  No deletion.
                        //

                        prgn = dco.pdc->prgnVis();

                        if (prgn == NULL)
                        {
                            prgn = prgnDefault;
                        }

                        //
                        // don't swap out prgnDefault
                        //

                        if (prgn != prgnDefault)
                        {
                            RGNOBJ roVis(prgn);
                            ro.bSwap(&roVis);

                            //
                            // roVis now contains the new vis rgn and the old visrgn
                            // is associated with hrgn.
                            //

                            prgn = roVis.prgnGet();

                            bDeleteOld = FALSE;
                        }
                        else
                        {
                            bRet = FALSE;
                        }
                    }
                    break;

                case SVR_DELETEOLD:

                    //
                    // delete the old handle but keep the region
                    //

                    prgn = ro.prgnGet();

                    if (ro.bDeleteHandle())
                       ro.vSetRgn(NULL);

                    break;
                }
            }
            else
            {
                RIP("Bad hrgn");
                prgn = prgnDefault;
            }

            // see if we need to delete the old one

            if (bDeleteOld)
            {
                dco.pdc->vReleaseVis();
            }

            // set the new one in.

            dco.pdc->prgnVis(prgn);
            prgn->vStamp();

        }
        else
        {

            //
            // User called GreSelectVisRgn after CreateRectRgn without
            // checking return value, so may have NULL hrgn here.
            //

            #if DBG

            if (fl != SVR_DELETEOLD)
            {
                WARNING("GreSelectVisRgn - fl != SVR_DELETEOLD");
            }

            #endif

            dco.pdc->vReleaseVis();
            dco.pdc->bSetDefaultRegion();
        }
    }

    rl.vRet((ULONG_PTR)bRet);
    return(bRet);
}

/******************************Public*Routine******************************\
* GreCopyVisVisRgn()
*
* History:
*  11-Jan-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int GreCopyVisRgn(
    HDC    hdc,
    HRGN   hrgn)
{
    RGNLOG rl(hrgn,NULL,"GreCopyVisRgn",(ULONG_PTR)hdc,0);

    int iRet = ERROR;

    DCOBJA    dco(hdc);                  // Use ALT_LOCK on DC
    RGNOBJAPI ro(hrgn,FALSE);

    ASSERTDEVLOCK(dco.pdc);

    if (dco.bValid() && ro.bValid())
    {
        RGNOBJ roVis(dco.pdc->prgnVis());
        if (roVis.bValid() && ro.bCopy(roVis))
            iRet = ro.iComplexity();
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* LONG GreGetClipBox(hdc,prcl,fXForm)
*
* Get the bounding box of the clip region
*
\**************************************************************************/

int
APIENTRY
GreGetClipBox(
   HDC    hdc,
   LPRECT prcl,
   BOOL fXForm)
{
    GDITraceHandle(GreGetClipBox, "(%X, %p, %X)\n", (va_list)&hdc, hdc);

    int iRet = ERROR;
    int iSaveLeft;

    DCOBJ   dor(hdc);

    if (dor.bValid())
    {
        DEVLOCKOBJ  dlo(dor);

        if (!dlo.bValid())
        {
            prcl->left   = 0;           // Make it a 'simple' empty rectangle
            prcl->right  = 0;
            prcl->top    = 0;
            prcl->bottom = 0;

            if (dor.bFullScreen())
                iRet = NULLREGION;
        }
        else
        {
            RGNOBJ  ro(dor.prgnEffRao());

            ro.vGet_rcl((RECTL *) prcl);

            // First convert from screen to device coordinates

            if ((prcl->left >= prcl->right) || (prcl->top >= prcl->bottom))
            {
                prcl->left = 0;             // Make it a 'simple' empty rectangle
                prcl->right = 0;
                prcl->top = 0;
                prcl->bottom = 0;
            }
            else
            {
                *(ERECTL *)prcl -= dor.eptlOrigin();

                // If requested, convert from device to logical coordinates.

                if (fXForm)
                {
                    EXFORMOBJ xfoDtoW(dor, DEVICE_TO_WORLD);

                    if (xfoDtoW.bValid())
                    {
                        xfoDtoW.bXform(*(ERECTL *)prcl);
                    }
                }
                if (MIRRORED_DC(dor.pdc) && (prcl->left > prcl->right)) {
                    iSaveLeft   = prcl->left;
                    prcl->left  = prcl->right;
                    prcl->right = iSaveLeft;
                }
            }

            iRet = ro.iComplexity();
        }

        GDITrace(GreGetClipBox, " returns (%d, %d) - (%d %d)\n", (va_list)prcl);
    }
    return(iRet);
}

/******************************Public*Routine******************************\
* int GreSubtractRgnRectList(hrgn, prcl, arcl, crcl)
*
* Quickly subtract the list of rectangles from the first rectangle to
* produce a region.
*
\**************************************************************************/

int
GreSubtractRgnRectList(
    HRGN   hrgn,
    LPRECT prcl,
    LPRECT arcl,
    int    crcl)
{
    GDITraceHandle(GreSubtractRgnRectList, "(%X, %p, %p, %d)\n", (va_list)&hrgn, hrgn);

    RGNLOG rl(hrgn,NULL,"GreSubtractRgnRectList",crcl);

    RGNOBJAPI   ro(hrgn,FALSE);
    int iRet;

    if (!ro.bValid() || !ro.bSubtract((RECTL *) prcl, (RECTL *) arcl, crcl))
    {
    // If bSubtract fails, clean up the target region for USER.

        if (ro.bValid())
            ro.vSet();

        iRet = ERROR;
    }
    else
    {
        iRet = ro.iComplexity();
    }

    rl.vRet(iRet);
    return(iRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rle4blt.cxx ===
/******************************Module*Header*******************************\
* Module Name: rleblt4.cxx
*
* This contains the bitmap simulation functions that blt from a 4 bit
* Run-Length Encoded (RLE) source to a DIB surface.  The DIB surface can be
* 1, 4, 8, 16, 24, or 32 bits/pel.
*
* The code is based on functions found in 'rleblt8.cxx', version 2.
*
* Added RLE Encoding functions: 10 Oct 92 @ 10:18
*  Gerrit van Wingerden [gerritv]
*
* Created: 03 Feb 92 @ 21:00
*
*  Author: Andrew Milton (w-andym)
*
* Notes:
*
*   1)  These functions return a BOOL value.  This value is TRUE if the
*       function ends before running out of data in the source RLE or before
*   hitting an End-of-Bitmap code.  Otherwise, we return FALSE.  This return
*   value is used by <EngCopyajBits> in the complex clipping case to decide
*   if the blt is complete.
*
*   2)  Before exiting a function with a TRUE value, position information is
*       saved by the macro <RLE_SavePosition>.  This is used by <EngCopyajBits>
*   to speed up the complex clipping case.
*
*   3)  The below functions use about twenty different macros.  This is
*       because they are all using the same basic algorithm to play an RLE
*   compression. The macros allow us to focus in on the nifty stuff of writing
*   the bytes out to the DIB.  Routine administrivia is handled by the macros.
*
*   The macros themselves are used to manage
*
*          - Source Access and data alignment
*          - Visability Checking
*          - Output position changes with Newline & Delta codes
*
*   The macro <RLE_InitVars> is used to define the varibles that relate to
*   the above information, and to define variables common to all RLE 4
*   blt functions.  Note that actual names of the common variables are passed
*   in as parameters to the macro.  Why?  Two reasons.  Firstly, they are
*   initialized by values taken of the BLTINFO structure passed into the blt
*   function.  Secondly, showing the variable names in the macro 'call' means
*   they don't just appear from nowhere into the function.  RLE_InitVars
*   is the one macro that you should think three times about before modifying.
*
*   One further note.  The variables 'ulDstLeft' and 'ulDstRight' appear to
*   come from nowhere.  This is not true.  They are in fact declared by the
*   macro <RLE_GetVisibleRect>.  However, showing these names in the macro
*   'call' tended to obscure the code.  Pretend you can see the declaration.
*
* Where can I find a macro definition?
*
*   Good question, glad you asked.  Look at the prefix:
*
*       RLE_<stuff> - lives in RLEBLT.H
*       RLE4_<blah> - lives in RLE4BLT.H
*
*   Anything else in here that looks like function call is not.  It's a macro.
*   Probably for bitwise manipulations.  Look for it in BITMANIP.H or in
*   the Miscellaneous section of RLEBLT.H
*
* 4)  The 8 and 16 ajBits/Pel cases can be optimized by packing the source
*     colours into a word / dword.  However, to actually see some net gain in
* run time, it will take some tricky-dicky-doo pointer alignment checking.
* This sort of thing may break on MIPS.
*
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*******************************Public*Routine*****************************\
* bSrcCopySRLE4D8
*
* Secure RLE blting that does clipping and won't die or write somewhere
* it shouldn't if given bad data.
*
* History:
*   3 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

BOOL
bSrcCopySRLE4D8(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.
// Extra Variables

    BYTE jSource;       // Packed RLE 4 colour code
    BYTE ajColours[2];  // Destination for unpacking an RLE 4 code
    BOOL bExtraByte;    // TRUE when an absolute run ends with a partial byte
    ULONG ulClipMargin; // Number of bytes clipped in an Encoded run


// Main process loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode.

            switch (ulNext)
            {
            case 0:

            // New Line

                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            case 1:

            // End of the bitmap

                return(FALSE);

            case 2:

            /* Positional Delta.
             * The delta values live in the next two source bytes
             */

            // Outta here if we can't get two more bytes

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            /* Absolute Mode.
             * The run length is stored in <ulNext>, <ulCount> is used to
             * hold left and right clip amounts.
             */

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left Side Clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount  = ulDstLeft - lOutCol;
                        ulNext  -= ulCount;
                        lOutCol += ulCount;

                        pjSrc += (ulCount >> 1);

                    // Force the Source Run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource =  *pjSrc++;
                            pjDst[lOutCol] =
                                     (BYTE) pulXlate[GetLowNybble(jSource)];
                            lOutCol++;
                            ulNext--;
                        }

                    }

                // Right Side Clipping.

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Slap the bits on. -- this is the funky-doodle stuff.

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    ulNext >>= 1;

                // Write complete bytes from the source

                    while (ulNext)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, ajColours, BYTE,
                                             pulXlate);
                        pjDst[lOutCol]   = ajColours[0];
                        pjDst[lOutCol+1] = ajColours[1];
                        lOutCol += 2;
                        ulNext--;
                    }

                // Account for a partial source byte in the run

                    if (bExtraByte)
                    {
                        jSource = *pjSrc++;
                        pjDst[lOutCol] =
                                (BYTE) pulXlate[GetHighNybble(jSource)];
                        lOutCol++;
                        pjSrc += (ulCount >> 1);       // Clip Adjustment
                    }
                    else
                        pjSrc += ((ulCount + 1) >> 1); // Clip Adjustment

                // Adjust the column for the right side clipping.

                    lOutCol += ulCount;

                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc   += (ulNext + 1) >> 1;

                } /* if */

            // Pad so the run ends on a WORD boundary

                RLE4_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        /* Encoded Mode
         * The run length is stored in <ulCount>, <ulClipMargin> is used
         * to  hold left and right clip amounts.
         */

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {

            // Left Side Clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    ulCount     -= ulClipMargin;
                    lOutCol     += ulClipMargin;
                }

            // Right Side Clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Setup for the run

                bExtraByte = (BOOL) bIsOdd(ulCount);
                ulCount >>= 1;
                RLE4_MakeColourBlock(ulNext, ajColours, BYTE, pulXlate);

            // Write it

                while (ulCount)
                {
                    pjDst[lOutCol]   = ajColours[0];
                    pjDst[lOutCol+1] = ajColours[1];
                    lOutCol += 2;
                    ulCount--;
                }

                /* Write the extra byte from an odd run length */

                if (bExtraByte)
                {
                    pjDst[lOutCol] = ajColours[0];
                    lOutCol++;
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.  Adjust our x output position */

                lOutCol += ulCount;

            } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE4D8 */

/********************************Public*Routine****************************\
* bSrcCopySRLE4D1
*
* Secure RLE blting to a 1 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*   5 Feb 1992 - Andrew Milton (w-andym):
*       Added clip support.
*  22 Jan 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

/* Local Macros ***********************************************************/

/* NOTE:  In the Escape Modes, the current working byte must be
 *        written to destination before the escape is executed.
 *        These writes look unpleasant because we have to mask
 *        current destination contents onto the working byte when
 *        it is written.  To such an end, the below macro...
 */

#define RLE4to1_WritePartial(DstPtr, OutByte, OutColumn, WritePos)            \
    if (RLE_RowVisible && (jBitPos = (BYTE) (OutColumn) & 7))                              \
    {                                                                         \
        if (RLE_ColVisible(OutColumn))                                        \
            DstPtr[WritePos] = OutByte |                                      \
                 ((~ajBits[jBitPos]) & DstPtr[WritePos]);         \
        else                                                                  \
            if (RLE_PastRightEdge(OutColumn))                                 \
        DstPtr[ulRightWritePos] =  OutByte |                  \
                (DstPtr[ulRightWritePos] &  jRightMask);      \
    }                                                                         \

/* Converts an output column to a bitnumber in the working byte */
#define ColToBitPos(col) (7 - (BYTE)((col) & 7))

/* Lookup tables for bit patterns *****************************************/

static BYTE
ajPosMask[] =    // The i'th entry contains a byte with the i'th bit set
{
    0x01, 0x02, 0x04, 0x08,
    0x10, 0x20, 0x40, 0x80, 0x00
};

static BYTE
ajBits[] =       // The i'th entry contains a byte with the high i bits set
{
    0x00, 0x80, 0xC0, 0xE0, 0xF0,
          0xF8, 0xFC, 0xFE, 0xFF
};

static BYTE
ajBitPatterns[] = // The four possible full byte bit patterns of a packed colour
{
    0x00, 0x55, 0xAA, 0xFF
};

/* And now the function ***************************************************/

BOOL
bSrcCopySRLE4D1(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol,
                 pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.
// Extra Variables

    BYTE  jWorking;      // Hold area to build a byte for output
    ULONG ulWritePos;    // Write position off <pjDst> into the destination

    ULONG ulLeftWritePos; // Leftmost write position
    BYTE  jLeftMask;      // Bitmask for taking bytes off the left edge

    ULONG ulRightWritePos; // Rightmost write position
    BYTE  jRightMask;      // Bitmask for taking bytes off the right edge

    BYTE  jBitPos;       // Bit number of the next write into <jWorking>
    BYTE  jBitPosMask;   // Bitmask with the <jBitPos>th bit set.

    ULONG ulCompBytes;   // Number of full bytes in an Encoded run.
    ULONG ulClipMargin;  // Number of bytes clipped off the right side of a run

    BYTE jSource;        // Packed RLE 4 colour code
    BYTE ajColours[2];   // Destination for unpacking an RLE 4 code
    BOOL bExtraByte;     // TRUE when an absolute run ends with a partial byte

    UINT i=0, j=0;

// Our Initialization

    ulLeftWritePos = (ULONG)(ulDstLeft >> 3);
    jLeftMask = ajBits[ulDstLeft % 8];
    ulRightWritePos = (ULONG) (ulDstRight >> 3);
    jRightMask = ~ajBits[(ulDstRight % 8)];

/* Fetch first working byte from the source.  Yes, this is ugly.
 * We cannot assume we are at a left edge because the complex clipping
 * case could resume an RLE in the middle of its bitmap.  We cannot do
 * a simple bounds check like RLE 8 to 4 because of bitmasking.  Argh.
 */

    ulWritePos = lOutCol >> 3;

    if (RLE_RowVisible)
    {
        if (RLE_ColVisible(lOutCol))
            jWorking = pjDst[ulWritePos] & ajBits[lOutCol & 7];
        else
        {
            if (RLE_PastRightEdge(lOutCol))
                jWorking = pjDst[ulRightWritePos];
            else
                jWorking = pjDst[ulLeftWritePos] & jLeftMask;
        }
    }

// Diddle the translation table

    for (i = 1, j = 1; i < 16; i+=1, j ^= 1) pulXlate[i] = j;

// Main Process loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        ulWritePos = lOutCol >> 3;

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

            case 0:

            // New Line.

                RLE4to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                if (RLE_RowVisible)
                    jWorking = pjDst[ulLeftWritePos] & jLeftMask;
                break;

            case 1:

            // End of the bitmap.

                RLE4to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                return(FALSE);

            case 2:

            // Positional Delta

                RLE4to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

            // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

            // Fetch a new working byte off the destination

                ulWritePos = lOutCol >> 3;
                if (RLE_ColVisible(lOutCol))
                    jWorking = pjDst[ulWritePos] & ajBits[lOutCol & 7];
                else
                    if (RLE_PastRightEdge(lOutCol))
                        jWorking = pjDst[ulRightWritePos];
                    else
                        jWorking = pjDst[ulLeftWritePos] & jLeftMask;
                break;

            default:

            /* Absolute Mode.
                 * The run length is stored in <ulNext>, <ulCount> is used to
                 * hold left and right clip amounts.
             */

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount     = ulDstLeft - lOutCol;
                        ulNext     -= ulCount;
                        lOutCol    += ulCount;
                        ulWritePos  = lOutCol >> 3;

                        pjSrc += (ulCount >> 1);

                        jBitPos = (BYTE) ColToBitPos(lOutCol);
                        jBitPosMask = ajPosMask[jBitPos]; // Always non-zero.

                    // Force the source to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource = (BYTE)
                                         pulXlate[GetLowNybble(*pjSrc++)];
                            if (jSource)
                                jWorking |= jBitPosMask;
                            jBitPosMask >>= 1;
                            lOutCol++;
                            ulNext--;
                        }

                    }
                    else
                    {
                        jBitPos = (BYTE) ColToBitPos(lOutCol);
                        jBitPosMask = ajPosMask[jBitPos]; // Always non-zero.
                    }

                // Right side clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Run Initialization

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    lOutCol += ulNext;

                // Slap the bits on. -- this is the funky-doodle stuff.

                    i = 0;  // Source read toggle.
                    do {

                    // Fill the working byte

                        while(jBitPosMask && ulNext)
                        {
                            if (!i)
                            {
                                jSource = *pjSrc++;
                                RLE4_MakeColourBlock(jSource, ajColours,
                                                     BYTE, pulXlate);
                            }
                            if (ajColours[i])
                                jWorking |= jBitPosMask;
                            jBitPosMask >>= 1;
                            ulNext--;
                            i ^= 1;
                        }

                    // Write it

                        if (!(jBitPosMask))
                        {
                            pjDst[ulWritePos] = jWorking;
                            ulWritePos++;
                            jBitPosMask = 0x80;
                            jWorking = 0;
                        }

                    } while (ulNext);

                // Adjust for the right side clipping.

                    pjSrc += bExtraByte ? (ulCount >> 1) :
                                         ((ulCount  + 1) >> 1);
                    lOutCol += ulCount;
                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */
                    lOutCol += ulNext;
                    pjSrc += ((ulNext + 1) >> 1);

                } /* if */

            // Fix up if this run was not WORD aligned.
                RLE4_FixAlignment(pjSrc);

            } /* switch */

        }
        else
        {
        /* Encoded Mode
         * The run length is stored in <ulCount>, <ulClipMargin> is used
         * to  hold left and right clip amounts.
         */
            if (RLE_InVisibleRect(ulCount, lOutCol))
            {
            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin  = ulDstLeft - lOutCol;
                    ulCount      -= ulClipMargin;
                    lOutCol   += ulClipMargin;
                    ulWritePos = lOutCol >> 3;
                }

            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Initialize for the run

                RLE4_MakeColourBlock(ulNext, ajColours, BYTE, pulXlate);
                jSource  = ajBitPatterns[2*ajColours[0] + ajColours[1]];

//                jSource  |= ((jSource << 2) |
//                                (jSource << 4) |
//                                (jSource << 6));

                jBitPos   = (BYTE) ColToBitPos(lOutCol);
                jBitPosMask = ajPosMask[jBitPos];
                ulCompBytes = (ulCount < (ULONG)jBitPos + 1) ? 0 :
                            ((BYTE)ulCount - jBitPos - 1) >> 3;

                lOutCol += ulCount;

                ulCount -= (ulCompBytes << 3);

            // Deal with a partial byte on the left

                if (jBitPos >= (LONG) ulCount)
                {
                // Will not fill the working byte

                    jSource &= ajBits[ulCount];
                    jWorking |= (BYTE)(jSource >> (7-jBitPos));
                    jBitPos -= (BYTE)ulCount;
                    ulCount = 0;
                }
                else
                {
                // Will fill the working byte

                    jWorking |= (jSource & ajBits[jBitPos + 1])
                                    >> (7-jBitPos);
                    pjDst[ulWritePos] = jWorking;
                    if (!bIsOdd(jBitPos))
                        jSource = RollLeft(jSource);
                    ulWritePos++;
                    jWorking = 0;
                    ulCount    -= (jBitPos + 1);
                    jBitPos   = 7;
                }

            // Deal with complete byte output

                if (ulCompBytes)
                {
                    for (i = 0; i < ulCompBytes; i++)
                        pjDst[ulWritePos + i] = jSource;
                    ulWritePos += ulCompBytes;
                    jBitPos = 7;
                    jWorking = 0;

                }

            // Deal with the right side partial byte

                if (ulCount)
                    jWorking |= (ajBits[ulCount] & jSource);


            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position and source pointer.
             */

                lOutCol += ulCount;

            } /* if */

        } /* if */

    } /* LOOP_FOREVER */

} /* bSrcCopySRLE4D1 */

/******************************Public*Routine*****************************
** bSrcCopySRLE4D4
*
* Secure RLE blting to a 4 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*   5 Feb 1992 - Andrew Milton (w-andym):
*     Added clip support.
*
*  24 Jan 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

/* NOTE:  In the Escape Modes, the current working byte must be
 *        written to destination before the escape is executed.
 *        To this end, the below macro...
 */

#define RLE4to4_WritePartial(DstPtr, OutByte, OutColumn, WritePos)           \
    if (RLE_RowVisible)                                                      \
    {                                                                        \
        if (RLE_ColVisible(OutColumn) && bIsOdd(OutColumn))                  \
        {                                                                    \
            SetLowNybble(OutByte, DstPtr[WritePos]);                         \
            DstPtr[WritePos] = OutByte;                                      \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (bRightPartial && RLE_PastRightEdge(OutColumn))               \
            {                                                                \
                SetLowNybble(OutByte, DstPtr[ulRightWritePos]);              \
                DstPtr[ulRightWritePos] = OutByte;                           \
            }                                                                \
        }                                                                    \
    }                                                                        \

BOOL
bSrcCopySRLE4D4(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext,
                 lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.

// Extra Variables

    BOOL  bRightPartial;   // TRUE when a visible row ends in a partial byte
    BYTE  jWorking;        // Hold area to build a byte for output
    ULONG ulWritePos;      // Write position off <pjDst> into the destination
    ULONG ulLeftWritePos;  // Leftmost write position
    ULONG ulRightWritePos; // Rightmost write position

    BYTE jSource;          // Packed RLE 4 colour code
    BYTE ajColours[2];     // Destination for unpacking an RLE 4 code

// Our Initialization

    ulLeftWritePos     = ulDstLeft  >> 1;
    ulRightWritePos    = ulDstRight >> 1;
    bRightPartial = (BOOL) bIsOdd(ulDstRight);

// Fetch our inital working byte

    ulWritePos = lOutCol >> 1;
    if (RLE_RowVisible)
        jWorking = pjDst[BoundsCheck(ulLeftWritePos, ulRightWritePos,
                                     ulWritePos)];

// Main processing loop

    LOOP_FOREVER
    {
        ulWritePos = lOutCol >> 1;

    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode.

            switch (ulNext)
            {
            case 0:

            // New Line

                RLE4to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                if (RLE_RowVisible)
                    jWorking = pjDst[ulLeftWritePos];

                break;

            case 1:

            // End of bitmap

                RLE4to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                return(FALSE);

            case 2:

            // Positional Delta

                RLE4to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

            // Read initial working byte

                ulWritePos = lOutCol >> 1;
                jWorking =
                      pjDst[BoundsCheck(ulLeftWritePos, ulRightWritePos,
                                        ulWritePos)];

                break;

            default:

                // Absolute Mode

                // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {

                // Left Side Clipping.  Lots 'o stuff happenin'

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount = ulDstLeft - lOutCol;

                        lOutCol    = ulDstLeft;
                        ulWritePos = ulDstLeft >> 1;

                        ulNext -= ulCount;
                        pjSrc  += (ulCount >> 1);

                    // Align the source run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource = (BYTE) pulXlate[GetLowNybble(*pjSrc++)];

                            if (bIsOdd(lOutCol))
                            {
                                SetLowNybble(jWorking, jSource);
                                pjDst[ulWritePos] = jWorking;
                                ulWritePos++;
                            }
                            else
                                SetHighNybble(jWorking, jSource);
                            lOutCol++;
                            ulNext--;

                        // Deal with the special case only one byte is visible

                            if (!ulNext)
                            {
                                RLE4_FixAlignment(pjSrc);
                                continue;
                            }
                        }

                    }

                // Right Side Clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext  = ulDstRight - lOutCol;
                    }
                    else
                        ulCount = 0;

                // Write the Run

                    ASSERTGDI(lOutCol < (LONG) ulDstRight,
                                "No longer visible\n");

                    if (ulNext != 0)
                    {
                        if (bIsOdd(lOutCol))
                        {
                        // Case 1:  Source & Dest misaligned w.r.t. bytes

                            lOutCol += ulNext;
                            jSource = *pjSrc++;
                            RLE4_MakeColourBlock(jSource, ajColours,
                                                 BYTE, pulXlate);
                            SetLowNybble(jWorking, ajColours[0]);
                            pjDst[ulWritePos] = jWorking;
                            ulWritePos++;
                            ulNext--;
                            ulNext >>= 1;

                            while (ulNext)
                            {
                                SetHighNybble(jWorking, ajColours[1]);
                                jSource = *pjSrc++;
                                RLE4_MakeColourBlock(jSource, ajColours,
                                                     BYTE, pulXlate);
                                SetLowNybble(jWorking, ajColours[0]);
                                pjDst[ulWritePos] = jWorking;
                                ulWritePos++;
                                ulNext--;

                            } /* while */

                        /* Account for the right side partial byte
                         * and do the right clip adjustment on the source
                         */

                            if (bIsOdd(lOutCol))
                            {
                                SetHighNybble(jWorking, ajColours[1]);
                                pjSrc += ((ulCount + 1) >> 1);

                            }
                            else
                            {
                                pjSrc += (ulCount >> 1);
                            }

                        }
                        else
                        {
                        // Case 2:  Source & Dest aligned on byte boundaries

                            lOutCol += ulNext;
                            ulNext >>= 1;

                            while (ulNext)
                            {
                                jSource = *pjSrc++;
                                RLE4_MakeColourBlock(jSource, ajColours,
                                                     BYTE, pulXlate);
                                jWorking = BuildByte(ajColours[0], ajColours[1]);
                                pjDst[ulWritePos] = jWorking;
                                ulWritePos++;
                                ulNext--;
                            } /* while */

                        /* Account for the right side partial byte
                         * and do the right clip adjustment on the source
                         */

                            if (bIsOdd(lOutCol))
                            {
                                jSource = GetHighNybble(*pjSrc++);
                                SetHighNybble(jWorking,
                                              (BYTE)pulXlate[(ULONG)jSource]);
                                pjSrc += (ulCount >> 1);
                            }
                            else
                            {
                                pjSrc += ((ulCount + 1) >> 1);
                            }

                        }
                    }
                    else
                    {
                    /* Do the right clip adjustment on the source
                     */

                        pjSrc += ((ulCount + 1) >> 1);
                    }

                    lOutCol += ulCount;
                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc += ((ulNext + 1) >> 1);

                } /* if */

            // Fix up if this run was not WORD aligned.

                RLE4_FixAlignment(pjSrc);

            } /* switch */
        }
        else
        {
        // Encoded Mode

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;

            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    lOutCol    = ulDstLeft;
                    ulWritePos = ulDstLeft >> 1;
                    ulCount -= ulClipMargin;
                }

            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount      = ulDstRight - lOutCol;
                }
                else
                    ulClipMargin = 0;


                RLE4_MakeColourBlock(ulNext, ajColours, BYTE, pulXlate);

            // Align the destination to a byte boundary

                if (bIsOdd(lOutCol))
                {
                    SetLowNybble(jWorking, ajColours[0]);
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    lOutCol++;
                    ulCount--;
                    SwapValues(ajColours[0], ajColours[1]);
                }

                lOutCol += ulCount;

            // Run initialization

                ulCount >>= 1;

                jWorking = BuildByte(ajColours[0], ajColours[1]);

            // Write complete bytes

                while(ulCount)
                {
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    ulCount--;
                }

            // Account for writing a partial byte on the right side

                if (bIsOdd(lOutCol))
                    SetHighNybble(jWorking, ajColours[0]);

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;

            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

                lOutCol += ulCount;

            } /* if */

        } /* if */

    } /* LOOP_FOREVER */

} /* bSrcCopySRLE4D4 */

/******************************Public*Routine******************************\
* bSrcCopySRLE4D16
*
* Secure RLE blting to a 16 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  28 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/
BOOL
bSrcCopySRLE4D16(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pwDst, PWORD, ulCount, ulNext, lOutCol,
                 pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.

// Extra Variables

    BYTE jSource;       // Packed RLE 4 colour code
    WORD awColours[2];  // Destination for unpacking an RLE 4 code
    BOOL bExtraByte;    // TRUE when an absolute run ends with a partial byte

// Main process loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);
        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {
            case 0:

            // New Line

                RLE_NextLine(PWORD, pwDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pwDst, lOutCol);
                    return(TRUE);
                }
                break;

            case 1:

            // End of the Bitmap.

                return(FALSE);

            case 2:

            /* Positional Delta.
             * The delta values live in the next two source bytes
             */

            // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pwDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pwDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            /* Absolute Mode.
             * The run length is stored in <ulNext>, <ulCount> is used to
             * hold left and right clip amounts.
             */

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount = ulDstLeft - lOutCol;
                        lOutCol = ulDstLeft;
                        ulNext -= ulCount;

                        pjSrc += (ulCount >> 1);

                    // Align the source run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource = (BYTE) *pjSrc++;
                            pwDst[lOutCol] =
                                   (WORD) pulXlate[GetLowNybble(jSource)];
                            lOutCol++;
                            ulNext--;
                        }

                    }

                // Right side clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Slap the bits on. -- this is the funky-doodle stuff.

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    ulNext >>= 1;

                // Deal with complete source bytes

                    while (ulNext)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, awColours, WORD,
                                             pulXlate);
                        pwDst[lOutCol]   = awColours[0];
                        pwDst[lOutCol+1] = awColours[1];

                        lOutCol += 2;
                        ulNext--;
                    }

                // Account for right partial byte in the source */

                    if (bExtraByte)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, awColours, WORD,
                                             pulXlate);
                        pwDst[lOutCol] = awColours[0];
                        lOutCol++;
                        pjSrc += (ulCount >> 1);       // Clip Adjustment
                    }
                    else
                        pjSrc += ((ulCount + 1) >> 1); // Clip Adjustment

                // Adjust the column for the right side clipping.

                    lOutCol += ulCount;

                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc   += (ulNext + 1) >> 1;

                } /* if */

            // Fix up if this run was not WORD aligned.

                RLE4_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
            /* Encoded Mode
             * The run length is stored in <ulCount>, <ulClipMargin> is used
             * to  hold left and right clip amounts.
             */

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;

            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    lOutCol  = ulDstLeft;
                    ulCount -= ulClipMargin;
                }

            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Run initialization

                bExtraByte = (BOOL) bIsOdd(ulCount);
                ulCount >>= 1;
                RLE4_MakeColourBlock(ulNext, awColours, WORD, pulXlate);

            // Write the run

                while (ulCount)
                {
                    pwDst[lOutCol]   = awColours[0];
                    pwDst[lOutCol+1] = awColours[1];
                    lOutCol += 2;
                    ulCount --;
                }

            // ... and an extra byte for an odd run length

                if (bExtraByte)
                {
                    pwDst[lOutCol] = awColours[0];
                    lOutCol++;
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position
             */

                lOutCol += ulCount;

            } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE4D16 */


/******************************Public*Routine*****************************
** bSrcCopySRLE4D24
*
* Secure RLE blting to a 24 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  28 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

#define RLE_24BitWrite(DstPtr, BytePos, Colour)                               \
    DstPtr[BytePos]   = (BYTE)Colour;                                         \
    DstPtr[BytePos+1] = (BYTE)(Colour >> 8);                                  \
    DstPtr[BytePos+2] = (BYTE)(Colour >> 16);                                 \
    BytePos += 3;                                                            \

BOOL
bSrcCopySRLE4D24(
    PBLTINFO psb)
{

// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.

// Extra Variables

    ULONG ulWritePos;    // Write position off <pjDst> into the destination
    BYTE jSource;        // Packed RLE 4 colour code
    DWORD adwColours[2]; // Destination for unpacking an RLE 4 code
    BOOL bExtraByte;     // TRUE when an absolute run ends with a partial byte
    ULONG ulClipMargin;  // Number of bytes clipped off an Encoded run

// Main process loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {
            case 0:

            // New line

                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            /* Positional Delta.
             * The delta values live in the next two source bytes
             */

            // Outta here if we can't get two more bytes

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            /* Absolute Mode.
             * The run length is stored in <ulNext>, <ulCount> is used to
             * hold left and right clip amounts.
             */

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount = ulDstLeft - lOutCol;
                        lOutCol = ulDstLeft;
                        ulNext -= ulCount;
                        ulWritePos = 3*lOutCol;

                        pjSrc += (ulCount >> 1);

                    // Align the Source run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            adwColours[0] = pulXlate[GetLowNybble(*pjSrc++)];
                            RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                            lOutCol++;
                            ulNext--;
                        }

                    }
                    else
                        ulWritePos = 3*lOutCol;

                // Right side clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Run Initialization.

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    lOutCol += ulNext;
                    ulNext >>= 1;

                // Write complete bytes from the source

                    while (ulNext)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, adwColours, DWORD,
                                             pulXlate);
                        RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                        RLE_24BitWrite(pjDst, ulWritePos, adwColours[1]);
                        ulNext--;
                    }

                // Account for a right partial byte in the source

                    if (bExtraByte)
                    {
                        adwColours[0] = pulXlate[GetHighNybble(*pjSrc++)];
                        RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                        pjSrc += (ulCount >> 1);       // Clip Adjustment
                    }
                    else
                        pjSrc += ((ulCount + 1) >> 1); // Clip Adjustment

                // Adjust the column for the right side clipping.

                    lOutCol += ulCount;

                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc   += (ulNext + 1) >> 1;

                } /* if */

            // Fix up if this run was not WORD aligned.

                RLE4_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        /* Encoded Mode
         * The run length is stored in <ulCount>, <ulClipMargin> is used
         * to  hold left and right clip amounts.
         */

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {

            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    lOutCol  = ulDstLeft;
                    ulCount -= ulClipMargin;
                }


            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Run initialization

                ulWritePos = 3*lOutCol;
                lOutCol += ulCount;
                bExtraByte = (BOOL) bIsOdd(ulCount);
                ulCount >>= 1;

                RLE4_MakeColourBlock(ulNext, adwColours, DWORD, pulXlate);

            // Write the run

                while (ulCount)
                {
                    RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                    RLE_24BitWrite(pjDst, ulWritePos, adwColours[1]);
                    ulCount --;
                }

            // Write the extra byte from an odd run length

                if (bExtraByte)
                {
                    RLE_24BitWrite(pjDst, ulWritePos, adwColours[0]);
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position
             */

                lOutCol += ulCount;

            } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE4D24 */

/******************************Public*Routine*****************************
** bSrcCopySRLE4D32
*
* Secure RLE blting to a 32 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  28 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

BOOL
bSrcCopySRLE4D32(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pdwDst, PDWORD, ulCount, ulNext,
                      lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
        return(TRUE);   // Must have bits left in the bitmap since we haven't
                        //  consumed any.

// Extra Variables

    BYTE  jSource;       // Packed RLE 4 colour code
    DWORD adwColours[2]; // Destination for unpacking an RLE 4 code
    BOOL  bExtraByte;    // TRUE when an absolute run ends with a partial byte
    ULONG ulClipMargin;  // Number of bytes clipped off an Encoded run


// Main processing loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

        if (RLE_SourceExhausted(2))
            return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {
            case 0:

            // New line

                RLE_NextLine(PDWORD, pdwDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pdwDst, lOutCol);
                    return(TRUE);
                }

                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            /* Positional Delta.
             * The delta values live in the next two source bytes
             */
            // Outta here if we can't get two more bytes

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pdwDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pdwDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            // Absolute Mode

            // Outta here if the bytes aren't in the source

                if (RLE_SourceExhausted(RLE4_ByteLength(ulNext)))
                    return(FALSE);

                RLE4_AlignToWord(pjSrc, ulNext);

                if (RLE_InVisibleRect(ulNext, lOutCol))
                {

                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount = ulDstLeft - lOutCol;
                        lOutCol = ulDstLeft;
                        ulNext -= ulCount;

                        pjSrc += (ulCount >> 1);

                    // Align the source run to a byte boundary

                        if (bIsOdd(ulCount))
                        {
                            jSource = (BYTE) *pjSrc++;
                            pdwDst[lOutCol] =
                                   (DWORD) pulXlate[GetLowNybble(jSource)];
                            lOutCol++;
                            ulNext--;
                        }

                    }

                // Right side clipping

                    if ((lOutCol + (LONG) ulNext) > (LONG)ulDstRight)
                    {
                        ulCount = (lOutCol + ulNext) - ulDstRight;
                        ulNext -= ulCount;
                    }
                    else
                        ulCount = 0;

                // Slap the bits on. -- this is the funky-doodle stuff.

                    bExtraByte = (BOOL) bIsOdd(ulNext);
                    ulNext >>= 1;

                // Write complete bytes from the source

                    while (ulNext)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, adwColours, DWORD,
                                             pulXlate);
                        pdwDst[lOutCol]   = adwColours[0];
                        pdwDst[lOutCol+1] = adwColours[1];

                        lOutCol += 2;
                        ulNext--;
                    }

                // Account for a right partial byte in the source

                    if (bExtraByte)
                    {
                        jSource = *pjSrc++;
                        RLE4_MakeColourBlock(jSource, adwColours, DWORD,
                                             pulXlate);
                        pdwDst[lOutCol] = adwColours[0];
                        lOutCol++;
                        pjSrc += (ulCount >> 1);       // Clip Adjustment
                    }
                    else
                        pjSrc += ((ulCount + 1) >> 1); // Clip Adjustment

                // Adjust the column for the right side clipping.

                    lOutCol += ulCount;

                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                    lOutCol += ulNext;
                    pjSrc   += (ulNext + 1) >> 1;

                } /* if */

            // Fix up if this run was not WORD aligned.

                RLE4_FixAlignment(pjSrc);

            } /* switch */
        }
        else
        {
        /* Encoded Mode
         * The run length is stored in <ulCount>, <ulClipMargin> is used
         * to  hold left and right clip amounts.
         */

            if (RLE_InVisibleRect(ulCount, lOutCol))
            {
            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin = ulDstLeft - lOutCol;
                    lOutCol  = ulDstLeft;
                    ulCount -= ulClipMargin;
                }

            // Right side clipping

                if ((lOutCol + (LONG) ulCount) > (LONG)ulDstRight)
                {
                    ulClipMargin = (lOutCol + ulCount) - ulDstRight;
                    ulCount -= ulClipMargin;
                }
                else
                    ulClipMargin = 0;

            // Run Initialization.

                bExtraByte = (BOOL) bIsOdd(ulCount);
                ulCount >>= 1;
                RLE4_MakeColourBlock(ulNext, adwColours, DWORD, pulXlate);

            // Write the run

                while (ulCount)
                {
                    pdwDst[lOutCol]   = adwColours[0];
                    pdwDst[lOutCol+1] = adwColours[1];
                    lOutCol += 2;
                    ulCount --;
                }

            // Write the extra byte from an odd run length

                if (bExtraByte)
                {
                    pdwDst[lOutCol] = adwColours[0];
                    lOutCol++;
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position
             */

                lOutCol += ulCount;

            } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE4D32 */




/*******************************Public*Routine*****************************\
* WriteEncoded4
*
* A helper function for EncodeRLE4.  Writes a run of bytes in encoded format.
*
* Created: 28 Oct 92 @ 14:00
*
*  Author: Gerrit van Wingerden [gerritv]
*
\**************************************************************************/


int WriteEncoded4( BYTE bValue, BYTE *pbTarget, UINT uiLength,
                   BYTE *pbEndOfBuffer )
{

    if( pbTarget == NULL )
        return(2);

    if( pbTarget + 2 > pbEndOfBuffer )
        return(0);

    *pbTarget++ = (BYTE) uiLength;
    *pbTarget++ = bValue;
    return(2);
}



/*******************************Public*Routine*****************************\
* WriteAbsolute4
*
* A helper function for EncodeRLE4.  Writes a run of bytes in absolute format.
*
* Created: 28 Oct 92 @ 14:00
*
*  Author: Gerrit van Wingerden [gerritv]
*
\**************************************************************************/


int WriteAbsolute4( BYTE *pbRunStart, BYTE *pbTarget, int cRunLength,
                    BYTE *pbEndOfBuffer )
{
    int iRet;


    if( cRunLength < 3 )
    {
        iRet = 2;
    }
    else
    {

        if( ( cRunLength + 1 ) & 0x02 )
        {
            iRet = (( cRunLength + 1 ) >> 1) + 3;
        }
        else
        {
            iRet = (( cRunLength + 1 ) >> 1) + 2;
        }
    }

    if( pbTarget == NULL )
        return(iRet);

    if( pbTarget + iRet > pbEndOfBuffer )
        return(0);

    if( cRunLength < 3  )
    {
        *pbTarget++ = (BYTE) cRunLength;
        *pbTarget = *pbRunStart;
        return(2);

    }

    *pbTarget++ = 0;
    *pbTarget++ = (BYTE) cRunLength;

    RtlMoveMemory( pbTarget, pbRunStart, ( cRunLength + 1 ) >> 1 );

    pbTarget +=  ( cRunLength + 1 ) >> 1;

    if( ( cRunLength + 1 ) & 0x02 )
    {
        *pbTarget++ = 0;
        return( iRet );
    }
    else
        return( iRet  );

}



/*******************************Public*Routine*****************************\
* EncodeRLE4
*
* Encodes a bitmap into RLE4 format and returns the length of the of the
* encoded format.  If the source is NULL it just returns the length of
* the format.  If the encoded output turns out to be longer than cBufferSize
* the functions stops encoding.
*
* History:
*  28 Oct 1992 Gerrit van Wingerden [gerritv] : creation
*  15 Mar 1993 Stephan J. Zachwieja [szach] : return 0 if buffer too small
*
\**************************************************************************/




int EncodeRLE4( BYTE *pbSource, BYTE *pbTarget, UINT uiWidth, UINT cNumLines,
                UINT cBufferSize )
{

    UINT cLineCount, uiLineWidth;
    BYTE bLastByte,bCurChar;
    BYTE *pbRunStart;
    BYTE *pbLineEnd;
    BYTE *pbEndOfBuffer;
    BYTE *pbCurPos;
    INT  cCurrentRunLength;
    INT  iMode, cTemp;
    UINT cTotal = 0;

    pbEndOfBuffer = pbTarget + cBufferSize;

// Compute width of line in bytes rounded to a DWORD boundary

    uiLineWidth = ( ( uiWidth + 7 ) >> 3 ) << 2 ;

    for( cLineCount = 0; cLineCount < cNumLines; cLineCount ++ )
    {
        pbRunStart = pbSource + uiLineWidth * cLineCount;
        bLastByte = *pbRunStart;
        pbLineEnd = pbRunStart + ( ( uiWidth + 1 ) >> 1 );
        iMode = RLE_START;
        cCurrentRunLength = 2;

        for(pbCurPos = pbRunStart+1;pbCurPos <= pbLineEnd; pbCurPos += 1)
        {

            // We won't really encode the value at *pbLineEnd since it points
            // past the end of the scan so it doesn't matter what value we use.
            // However, it is important not to reference it since it may point
            // past the end of the buffer which can be uncommited memory.

            if( pbCurPos == pbLineEnd )
            {
                bCurChar = 0xFF;
            }
            else
            {
                bCurChar = *pbCurPos;
            }


            switch( iMode )
            {
            case RLE_START:
                iMode = ( bCurChar == bLastByte ) ? RLE_ENCODED : RLE_ABSOLUTE;
                bLastByte = bCurChar;
                break;
            case RLE_ABSOLUTE:

// There are two ways that this run could be over.  We could have exceeded the
// maximum length 0xFE ( since this algorithm works with bytes ), or there
// could be a switch into absolute mode.

                if( ( bCurChar == bLastByte ) ||
                    ( cCurrentRunLength == 0xFE ) )

                {
                    int iOffset;

                    if( cCurrentRunLength == 0xFE )
                    {
// If this is the end of the line and there is and odd line length, ignore the
// last nibble of the the final byte.

                        if( (pbCurPos == pbLineEnd ) && ( uiWidth & 0x01 ))
                            iOffset = 1;
                        else
                            iOffset = 0;

                        iMode = RLE_START;
                    }
                    else
                    {
                        iOffset = 2;
                        iMode = RLE_ENCODED;
                    }

                    cTemp = WriteAbsolute4(pbRunStart, pbTarget,
                       cCurrentRunLength - iOffset, pbEndOfBuffer);

                 // if pbTarget is not NULL and cTemp is zero then
                 // the buffer is too small to hold  encoded  data

                    if(pbTarget != NULL) {
                       if (cTemp == 0) return(0);
                       pbTarget += cTemp;
                    }

                    cTotal += cTemp;
                    pbRunStart = pbCurPos;
                    cCurrentRunLength = iOffset;
                }

                bLastByte = bCurChar;
                break;

            case RLE_ENCODED:
                if( ( bCurChar != bLastByte ) ||
                    ( cCurrentRunLength == 0xFE ) )

                {
// Don't include last nibble if the width of the scan line is odd and this
// this is the last byte.

                    if( (pbCurPos == pbLineEnd ) && ( uiWidth & 0x01 ))
                         cCurrentRunLength -= 1;

                    cTemp = WriteEncoded4(bLastByte,
                       pbTarget, cCurrentRunLength, pbEndOfBuffer);

                 // if pbTarget is not NULL and cTemp is zero then
                 // the buffer is too small to hold  encoded  data

                    if(pbTarget != NULL) {
                        if (cTemp == 0) return(0);
                        pbTarget += cTemp;
                    }

                    cTotal += cTemp;
                    bLastByte = bCurChar;
                    pbRunStart = pbCurPos;
                    cCurrentRunLength = 0;
                    iMode =  RLE_START ;
                }

            }
            cCurrentRunLength += 2;
        }

        if( cCurrentRunLength > 3 )
        {
// Don't include last nibble if the width of the scan line is odd and this
// this is the last byte.

            if(  uiWidth & 0x01 )
                cCurrentRunLength -= 1;


         // if pbTarget is not NULL and cTemp is zero then
         // the buffer is too small to hold  encoded  data

            if(iMode == RLE_ABSOLUTE)
               cTemp = WriteAbsolute4(pbRunStart, pbTarget,
                  cCurrentRunLength - 2, pbEndOfBuffer);
            else {
               cTemp = WriteEncoded4(bLastByte, pbTarget,
                  cCurrentRunLength - 2, pbEndOfBuffer);
            }

            if (pbTarget != NULL) {
               if (cTemp == 0) return(0);
               pbTarget += cTemp;
            }

            cTotal += cTemp;
        }

        if( pbTarget <= pbEndOfBuffer )
            cTotal += 2;

        if( pbTarget != NULL )
        {
            *((WORD *) pbTarget) = 0;
            pbTarget += 2;
        }

    }
// Write "End of bitmap" at the end so we're win31 compatible.

    if( pbTarget == NULL )
        return(cTotal + 2);

    if( pbTarget + 2 > pbEndOfBuffer )
        return(0);

    *pbTarget++ = 0;
    *pbTarget++ = 1;
    return(cTotal + 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\rle8blt.cxx ===
/******************************Module*Header*******************************\
* Module Name: rleblt8.cxx
*
* This contains the bitmap simulation functions that blt from an 8 bit
* Run-Length Encoded (RLE) source to a DIB surface.  The DIB surface can be
* 1, 4, 8, 16, 24, or 32 bits/pel.
*
* The code is based on functions found in 'srcblt8.cxx', version 23,
* although now bears no resembalence to them at all.
*
* Notes:
*
*   1)  These functions return a BOOL value.  This value is TRUE if the
*       function ends before running out of data in the source RLE or before
*   hitting an End-of-Bitmap code.  Otherwise, we return FALSE.  This return
*   value is used by <EngCopyBits> in the complex clipping case to decide
*   if the blt is complete.
*
*   2)  Before exiting a function with a TRUE value, position information is
*       saved by the macro <RLE_SavePosition>.  This is used by <EngCopyBits>
*   to speed up the complex clipping case.
*
*   3)  The below functions use about twenty different macros.  This is
*       because they are all using the same basic algorithm to play an RLE
*   compression. The macros allow us to focus in on the nifty stuff of writing
*   the bytes out to the DIB.  Routine administrivia is handled by the macros.
*
*   The macros themselves are used to manage
*
*          - Source Access and data alignment
*          - Visability Checking
*          - Clipping
*          - Output position changes with Newline & Delta codes
*
*   The macro <RLE_InitVars> is used to define the varibles that relate to
*   the above information, and to define variables common to all RLE 4
*   blt functions.  Note that actual names of the common variables are passed
*   in as parameters to the macro.  Why?  Two reasons.  Firstly, they are
*   initialized by values taken of the BLTINFO structure passed into the blt
*   function.  Secondly, showing the variable names in the macro 'call' means
*   they don't just appear from nowhere into the function.  RLE_InitVars
*   is the one macro that you should think three times about before modifying.
*
*   One further note.  The variables 'ulDstLeft' and 'ulDstRight' appear to
*   come from nowhere.  This is not true.  They are in fact declared by the
*   macro <RLE_GetVisibleRect>.  However, showing these names in the macro
*   'call' tended to obscure the code.  Pretend you can see the declaration.
*
* Where can I find a macro definition?
*
*   Good question, glad you asked.  Look at the prefix:
*
*       RLE_<stuff> - lives in RLEBLT.H
*       RLE8_<blah> - lives in RLE8BLT.H
*
*   Anything else in here that looks like function call is not.  It's a macro.
*   Probably for bitwise manipulations.  Look for it in BITMANIP.H or in
*   the Miscellaneous section of RLEBLT.H

*  Added RLE Encoding functions: 10 Oct 92 @ 10:18
*   Gerrit van Wingerden [gerritv]
*
* Created: 19 Jan 92 @ 19:00
*  Author: Andrew Milton (w-andym)
*
* Copyright (c) 1990, 1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/******************************Public*Routine******************************\
* bSrcCopySRLE8D8
*
* Secure RLE blting that does clipping and won't die or write somewhere
* it shouldn't if given bad data.
*
* History:
*  19 Jan 1992 - Andrew Milton (w-andym):
*      Moved most of the initialization code back up to <EngCopyBits()> in
*      <trivblt.cxx>.  This way it is done once instead of once per call
*      of this function.
*
*      The rclDst field is now the visible rectangle of our bitmap, not the
*      target rectangle.  This cleans up the visible region checking.
*
*  24-Oct-1991 -by- Patrick Haluptzok patrickh
*      Updated, add clipping support
*
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
*      Wrote it.
\**************************************************************************/

BOOL
bSrcCopySRLE8D8(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Main Process Loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

        case 0:

            // Newline

                RLE_NextLine(PBYTE, pjDst, lOutCol);
                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }
                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            // Position Delta.  Fetch & Evaluate

        // Outta here if we can't get the delta values

        if (RLE_SourceExhausted(2))
            return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
        RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

        // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {

                    RLE8_AbsClipLeft(pjSrc, ulCount, ulNext, lOutCol);
                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

        // Slap the bits on. -- this is the funky-doodle stuff.

            while (ulNext--)
                    {
            pjDst[lOutCol] =
                                       (BYTE) pulXlate[(ULONG) *(pjSrc++)];
            lOutCol++;
            }

                // Adjust for the right side clipping.

                    pjSrc += ulCount;
            lOutCol += ulCount;

            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
                    pjSrc += ulNext;

        } /* if */

        // Fix up if this run was not WORD aligned.

        RLE8_FixAlignment(pjSrc)

            } /* switch */

        }
        else
        {

        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;
        ulNext = pulXlate[ulNext];

                RLE8_EncClipLeft(ulClipMargin, ulCount, lOutCol);
                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

        // Slap the bits on.

        while (ulCount--)
                {
            pjDst[lOutCol] = (BYTE) ulNext;
            lOutCol++;
        }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;

            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

        lOutCol += ulCount;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D8 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D1
*
* Secure RLE blting to a 1 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*   5 Feb 1992 - Andrew Milton (w-andym):
*       Added clip support.
*  22 Jan 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

/* NOTE:  In the Escape Modes, the current working byte must be
 *        written to destination before the escape is executed.
 *        These writes look unpleasant because we have to mask
 *        current destination contents onto the working byte when
 *        it is written.  To such an end, the below macro...
 */

#define RLE8to1_WritePartial(DstPtr, OutByte, OutColumn, WritePos)           \
    if (RLE_RowVisible && (jBitPos = (BYTE) (OutColumn) & 7))                \
    {                                                                        \
        if (RLE_ColVisible(OutColumn))                                       \
            DstPtr[WritePos] = OutByte |                                     \
                 ((~ajBits[jBitPos]) & DstPtr[WritePos]);        \
        else                                                                 \
            if (RLE_PastRightEdge(OutColumn))                                \
        DstPtr[ulRightWritePos] = OutByte |              \
                 (DstPtr[ulRightWritePos] &  jRightMask);    \
    }


#define ColToBitPos(col) (7 - (BYTE) ((col) & 7) )

/* Lookup tables for bit patterns *****************************************/

static BYTE
ajPosMask[] =    // The i'th entry contains a byte with the i'th bit set
{
    0x01, 0x02, 0x04, 0x08,
    0x10, 0x20, 0x40, 0x80, 0x00
};

static BYTE
ajBits[] =       // The i'th entry contains a byte with the high i bits set
{
    0x00, 0x80, 0xC0, 0xE0, 0xF0,
          0xF8, 0xFC, 0xFE, 0xFF
};

/* And now the function ***************************************************/

BOOL
bSrcCopySRLE8D1(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Extra Variables

    BYTE  jWorking;      // Hold area to build a byte for output
    ULONG ulWritePos;    // Write position off <pjDst> into the destination

    ULONG ulLeftWritePos; // Leftmost write position
    BYTE  jLeftMask;      // Bitmask for taking bytes off the left edge

    ULONG ulRightWritePos; // Rightmost write position
    BYTE  jRightMask;      // Bitmask for taking bytes off the right edge

    BYTE  jBitPos;       // Bit number of the next write into <jWorking>
    BYTE  jBitPosMask;   // Bitmask with the <jBitPos>th bit set.

    ULONG ulClipMargin;  // Number of bytes clipped off the right side of a run
    ULONG ulCompBytes;     // Number of complete bytes in an absolute run.

// Our Initialization

    ulLeftWritePos = (ULONG)(ulDstLeft >> 3);
    jLeftMask = ajBits[(ulDstLeft % 8)];

    ulRightWritePos = (ULONG) (ulDstRight >> 3);
    jRightMask = ~ajBits[(ulDstRight % 8)];

/* Fetch first working byte from the source.  Yes, this is ugly.
 * We cannot assume we are at a left edge because the complex clipping
 * case could resume an RLE in the middle of its bitmap.  We cannot do
 * a simple bounds check like RLE 8 to 4 because of bitmasking.  Argh.
 */

    ulWritePos = lOutCol >> 3;

    if (RLE_RowVisible)
    {
        if (RLE_ColVisible(lOutCol))
            jWorking = pjDst[ulWritePos] & ajBits[lOutCol & 7];
        else
        {
            if (RLE_PastRightEdge(lOutCol))
                jWorking = pjDst[ulRightWritePos];
            else
                jWorking = pjDst[ulLeftWritePos] & jLeftMask;
        }
    }
// Diddle the translation table

    int i, j;
    for (i = 1, j=1; i < 256; i+=1, j^= 1) pulXlate[i] = j;

    LOOP_FOREVER
    {

    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        ulWritePos = lOutCol >> 3;

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {
            case 0:

            // New line

                RLE8to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                if (RLE_RowVisible)
                    jWorking = pjDst[ulLeftWritePos] & jLeftMask;
                break;

            case 1:

            // End of the bitmap

                RLE8to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                return(FALSE);

            case 2:

            // Positional Delta

                RLE8to1_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

            // Fetch a new working byte off the destination

                ulWritePos = lOutCol >> 3;
                if (RLE_RowVisible)
                {
                    if (RLE_ColVisible(lOutCol))
                        jWorking = pjDst[ulWritePos] & ajBits[lOutCol & 7];
                    else
                    {
                        if (RLE_PastRightEdge(lOutCol))
                            jWorking = pjDst[ulRightWritePos];
                        else
                            jWorking = pjDst[ulLeftWritePos] & jLeftMask;
                    }
                }
                break;

            default:

        // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

            // Output if we are on a visible scanline.

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount    = ulDstLeft - lOutCol;
                    ulNext    -= ulCount;
                    lOutCol   += ulCount;
                        ulWritePos = lOutCol >> 3;
                        pjSrc += ulCount;
                    }

                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

                    jBitPos = (BYTE) ColToBitPos(lOutCol);
                    jBitPosMask = ajPosMask[jBitPos];
                    lOutCol += (LONG) ulNext;

                // Write the run

                    do {

                    // Fill the working byte

                        while(jBitPosMask && ulNext)
                        {
                            if (pulXlate[*pjSrc++])
                                jWorking |= jBitPosMask;
                            jBitPosMask >>= 1;
                            ulNext--;
                        }

                    // Write it

                        if (!(jBitPosMask))
                        {
                            pjDst[ulWritePos] = jWorking;
                            ulWritePos++;
                            jBitPosMask = 0x80;
                            jWorking = 0;
                        }

                    } while (ulNext);

                // Adjust for the right side clipping.

            pjSrc      += ulCount;
            lOutCol += ulCount;
                }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
            pjSrc   += ulNext;

        } /* if */

            // Fix up if this run was not WORD aligned.

            RLE8_FixAlignment(pjSrc);

            } /* switch */

        }
        else
        {
        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin  = ulDstLeft - lOutCol;
                ulCount      -= ulClipMargin;
                lOutCol      += ulClipMargin;
                    ulWritePos    = lOutCol >> 3;
                }

                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

            // Initialize for the run.  Now we get funky-doodle

                jBitPos  = ColToBitPos(lOutCol);
                lOutCol += ulCount;
                ulNext   = pulXlate[ulNext];

            // Deal with the left side partial byte

                if (jBitPos >= (BYTE) ulCount)
                {
                // Will not fill the current working byte

                    ulCompBytes = 0;    // No Complete bytes.
                    if (ulNext)
                        jWorking |= (ajBits[ulCount] >> (7-jBitPos));
                    else
                        jWorking &= ~(ajBits[ulCount] >> (7-jBitPos));
                    jBitPos -= (BYTE)ulCount;
                    ulCount = 0;
                }
                else
                {
                /* Will fill the current working byte.
                 * We may have complete bytes to output.
                 */
                    ulCompBytes = ((BYTE)ulCount - jBitPos - 1) >> 3;

                    if (ulNext)
                        jWorking |= (~ajBits[7 - jBitPos]);
                    else
                        jWorking &= (ajBits[7 - jBitPos]);
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    jWorking = 0;
                    ulCount -= (jBitPos + 1);
                    jBitPos  = 7;
                }

            // Deal with complete byte output

                if (ulCompBytes)
                {
                    UINT i;
                    jWorking = (ulNext) ? 0xFF : 0x00;
                    for (i = 0; i < ulCompBytes; i++)
                        pjDst[ulWritePos + i] = jWorking;
                    ulWritePos += ulCompBytes;
                    jBitPos  = 7;
                    jWorking = 0;
                    ulCount -= (ulCompBytes << 3);

                } /* if */

            // Deal with the right side partial byte

                if (ulCount)
                {
                    if (ulNext)
                        jWorking |= ajBits[ulCount];
                    else
                        jWorking = 0;
                }

            // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position and source pointer.
             */

        lOutCol += ulCount;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D1 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D4
*
* Secure RLE blting to a 4 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*   5 Feb 1992 - Andrew Milton (w-andym):
*     Added clip support.
*
*  24 Jan 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

/* NOTE:  In the Escape Modes, the current working byte must be
 *        written to destination before the escape is executed.
 *        To this end, the below macro...
 */

#define RLE8to4_WritePartial(DstPtr, OutByte, OutColumn, WritePos)           \
    if (RLE_RowVisible)                                                      \
    {                                                                        \
        if (RLE_ColVisible(OutColumn) && bIsOdd(OutColumn))                  \
        {                                                                    \
            SetLowNybble(OutByte, DstPtr[WritePos]);                         \
            DstPtr[WritePos] = OutByte;                                      \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (bRightPartial && RLE_PastRightEdge(OutColumn))               \
            {                                                                \
                /*DbgBreakPoint();*/                                         \
                SetLowNybble(OutByte, DstPtr[ulRightWritePos]);                   \
                DstPtr[ulRightWritePos] = OutByte;                                \
            }                                                                \
        }                                                                    \
    }                                                                        \

BOOL
bSrcCopySRLE8D4(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext,
                 lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Extra Variables

    BOOL  bRightPartial;   // TRUE when a visible row ends in a partial byte
    BYTE  jWorking;        // Hold area to build a byte for output
    ULONG ulWritePos;      // Write position off <pjDst> into the destination
    ULONG ulLeftWritePos;  // Leftmost write position
    ULONG ulRightWritePos; // Rightmost write position
    ULONG ulClipMargin;    // Number of bytes clipped in an encoded run

// Our Initialization

    ulLeftWritePos  = ulDstLeft  >> 1;
    ulRightWritePos = ulDstRight >> 1;
    bRightPartial = (BOOL) bIsOdd(ulDstRight);

// Fetch our inital working byte

    ulWritePos = lOutCol >> 1;
    if (RLE_RowVisible)
        jWorking = pjDst[BoundsCheck(ulLeftWritePos, ulRightWritePos,
                                     ulWritePos)];

// Main processing loop

    LOOP_FOREVER
    {
        ulWritePos = lOutCol >> 1;

    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

            case 0:

            // New line.

                RLE8to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                RLE_NextLine(PBYTE, pjDst, lOutCol);
                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                if (RLE_RowVisible)
                    jWorking = pjDst[ulLeftWritePos];

                break;

            case 1:

            // End of the bitmap.

                RLE8to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);
                return(FALSE);

            case 2:

            // Positional Delta  - Fetch and evaluate

                RLE8to4_WritePartial(pjDst, jWorking, lOutCol, ulWritePos);

                // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

            // Read a new working byte off the destination

                ulWritePos = lOutCol >> 1;

                if (RLE_RowVisible)
                    jWorking   = pjDst[BoundsCheck(ulLeftWritePos, ulRightWritePos,
                                                   ulWritePos)];

                break;

            default:

        // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                // Left side clipping

                    if (lOutCol < (LONG)ulDstLeft)
                    {
                        ulCount     = ulDstLeft - lOutCol;
                    ulNext     -= ulCount;
                    lOutCol += ulCount;
                        ulWritePos = lOutCol >> 1;
                        pjSrc += ulCount;
                    }

                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

                // Account for a right side partial byte

                    if (bIsOdd(lOutCol))
                    {
                        SetLowNybble(jWorking,
                                 (BYTE)(pulXlate[(ULONG) *pjSrc++]));
                        pjDst[ulWritePos] = jWorking;
                        lOutCol++;
                        ulWritePos++;
                        ulNext--;
                    }

                // Write the run

                    lOutCol += ulNext;
                    ulNext >>= 1;

                    while (ulNext)
                    {
                        jWorking = ((BYTE)pulXlate[(ULONG) *pjSrc++]) << 4;
                        SetLowNybble(jWorking,
                                    (BYTE)pulXlate[(ULONG) *pjSrc++]);
                        pjDst[ulWritePos] = jWorking;
                        ulWritePos++;
                        ulNext--;
                    }

                // Account for a left side partial byte

                    if (bIsOdd(lOutCol))
                        SetHighNybble(jWorking,
                                      (BYTE)pulXlate[(ULONG) *pjSrc++]);


                // Adjust for the right side clipping.

                    pjSrc      += ulCount;
            lOutCol += ulCount;
            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

                pjSrc   += ulNext;
                lOutCol += ulNext;

        } /* if */

        // Fix up if this run was not WORD aligned.

        RLE8_FixAlignment(pjSrc);

            } /* switch */

        } else {

        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
            // Left side clipping

                if (lOutCol < (LONG)ulDstLeft)
                {
                    ulClipMargin  = ulDstLeft - lOutCol;
                ulCount      -= ulClipMargin;
                lOutCol      += ulClipMargin;
                    ulWritePos    = lOutCol >> 1;
                }

                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

            ulNext = pulXlate[ulNext];

            // Account for a left side partial byte

                if (bIsOdd(lOutCol))
                {
                    SetLowNybble(jWorking, (BYTE)ulNext);
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    lOutCol++;
                    ulCount--;
                }

            // Write complete bytes of the run

                lOutCol += ulCount;
                ulCount >>= 1;
                jWorking = BuildByte((BYTE)ulNext, (BYTE)ulNext);

                while(ulCount)
                {
                    pjDst[ulWritePos] = jWorking;
                    ulWritePos++;
                    ulCount--;
                }

            // Account for the partial byte on the right side

                if (bIsOdd(lOutCol))
                {
                    SetHighNybble(jWorking, (BYTE)ulNext);
                }

            // Adjust for the right side clipping.

        lOutCol    += ulClipMargin;
                ulWritePos  = lOutCol >> 1;
            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

        lOutCol    += ulCount;
                ulWritePos  = lOutCol >> 1;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D4 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D16
*
* Secure RLE blting to a 16 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  02 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

BOOL
bSrcCopySRLE8D16(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pwDst, PWORD, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

    ULONG ulClipMargin = 0;

// Main Processing Loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

        case 0:

            // Newline

                RLE_NextLine(PWORD, pwDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pwDst, lOutCol);
                    return(TRUE);
                }

                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            // Positional Delta. -- Fetch & Evaluate

        // Outta here if we can't get the delta values

        if (RLE_SourceExhausted(2))
            return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);

        RLE_PosDelta(pwDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pwDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {
                    RLE8_AbsClipLeft(pjSrc, ulCount, ulNext, lOutCol);
                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

                // Slap the bits on. -- this is the funky-doodle stuff.

            while (ulNext--)
                    {
            pwDst[lOutCol] = (WORD)pulXlate[(ULONG)*(pjSrc++)];
            lOutCol++;
            }

                // Adjust for the right side clipping

                    pjSrc   += ulCount;
            lOutCol += ulCount;
            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
                    pjSrc   += ulNext;

        }

        // Fix up if this run was not WORD aligned.

        RLE8_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ulNext = pulXlate[ulNext];

                RLE8_EncClipLeft(ulClipMargin, ulCount, lOutCol);
                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

            // Slap the bits on.

        while (ulCount--)
                {
            pwDst[lOutCol] = (WORD)ulNext;
            lOutCol++;
        }

        // Adjust for the right side clipping.

                lOutCol += ulClipMargin;
            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

        lOutCol += ulCount;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D16 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D24
*
* Secure RLE blting to a 24 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  02 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

#define RLE_24BitWrite(pjDst, BytePos, Colour)                               \
    pjDst[BytePos]   = (BYTE)Colour;                                         \
    pjDst[BytePos+1] = (BYTE)(Colour >> 8);                                  \
    pjDst[BytePos+2] = (BYTE)(Colour >> 16);                                 \
    BytePos += 3;                                                            \

BOOL
bSrcCopySRLE8D24(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pjDst, PBYTE, ulCount, ulNext, lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Extra Variables

    ULONG ulWritePos;
    ULONG ulNextColour;

// Main Processing Loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

        case 0:

            // New line

                RLE_NextLine(PBYTE, pjDst, lOutCol);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }
                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            // Positional Delta.  Fetch & Evaluate

                // Outta here if we can't get the delta values

                if (RLE_SourceExhausted(2))
                    return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);

                RLE_PosDelta(pjDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pjDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

        RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
        {
            RLE8_AbsClipLeft(pjSrc, ulCount, ulNext, lOutCol);
            ulWritePos = 3*lOutCol;

            RLE8_ClipRight(ulCount, ulNext, lOutCol);

        // Slap the bits on. -- this is the funky-doodle stuff.

        // Brute force & ignorance hard at work in this loop

            while (ulNext--)
            {
                ulNextColour = pulXlate[*pjSrc++];
                RLE_24BitWrite(pjDst, ulWritePos, ulNextColour);
                lOutCol += 1;
            }

        // Adjust for the right side clipping.

            pjSrc   += ulCount;
            lOutCol += ulCount;
            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
            pjSrc   += ulNext;

        } /* if */

            // Fix up if this run was not WORD aligned.
        RLE8_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;
        ulNext = pulXlate[ulNext];

                RLE8_EncClipLeft(ulClipMargin, ulCount, lOutCol);
                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);
                ulWritePos = 3*lOutCol;
                lOutCol += ulCount;

            // Slap the bits on. -- Not very funky-doodle this time....

            // ...but more brute force and ignorance

                while (ulCount--)
                {
                    RLE_24BitWrite(pjDst, ulWritePos, ulNext);
                }

            // Adjust for the right side clipping.

        lOutCol += ulClipMargin;
            }
            else
            {
            /* Not on a visible scanline.
             * Adjust our x output position
             */

        lOutCol += ulCount;

        } /* if */

        } /* if */
    } /* LOOP_FOREVER */
} /* bSrcCopySRLE8D24 */

/******************************Public*Routine******************************\
* bSrcCopySRLE8D32
*
* Secure RLE blting to a 32 BPP DIB that does clipping and won't die or
* write somewhere it shouldn't if given bad data.
*
* History:
*  02 Feb 1992 - Andrew Milton (w-andym):  Creation.
*
\**************************************************************************/

BOOL
bSrcCopySRLE8D32(
    PBLTINFO psb)
{
// Common RLE Initialization

    RLE_InitVars(psb, pjSrc, pdwDst, PDWORD, ulCount, ulNext,
                 lOutCol, pulXlate);
    RLE_AssertValid(psb);
    RLE_FetchVisibleRect(psb);
    RLE_SetStartPos(psb, lOutCol);

// Outta here if we start past the top edge.  Don't need to save our position.

    if (RLE_PastTopEdge)
    return(TRUE);    // Must have bits left in the bitmap since we haven't
             //  consumed any.

// Main Process Loop

    LOOP_FOREVER
    {
    // Outta here if we can't get two more bytes

    if (RLE_SourceExhausted(2))
        return(FALSE);

        RLE_GetNextCode(pjSrc, ulCount, ulNext);

        if (ulCount == 0)
        {
        // Absolute or Escape Mode

            switch (ulNext)
            {

        case 0:

            // New line

                RLE_NextLine(PDWORD, pdwDst, lOutCol);
                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pdwDst, lOutCol);
                    return(TRUE);
                }
                break;

            case 1:

            // End of the Bitmap

                return(FALSE);

            case 2:

            // Positional Delta. -- Fetch & Evaluate

        // Outta here if we can't get the delta values

        if (RLE_SourceExhausted(2))
            return(FALSE);

                RLE_GetNextCode(pjSrc, ulCount, ulNext);
        RLE_PosDelta(pdwDst, lOutCol, ulCount, ulNext);

                if (RLE_PastTopEdge)
                {
                    RLE_SavePosition(psb, pjSrc, pdwDst, lOutCol);
                    return(TRUE);
                }

                break;

            default:

            // Absolute Mode

        // Outta here if the bytes are not in the source

        if (RLE_SourceExhausted(ulNext))
            return(FALSE);

                RLE8_AlignToWord(pjSrc, ulNext);

        if (RLE_InVisibleRect(ulNext, lOutCol))
                {

                    RLE8_AbsClipLeft(pjSrc, ulCount, ulNext, lOutCol);
                    RLE8_ClipRight(ulCount, ulNext, lOutCol);

                // Slap the bits on. -- this is the funky-doodle stuff.

            while (ulNext--)
                    {
            pdwDst[lOutCol] = pulXlate[(ULONG) *(pjSrc++)];
            lOutCol++;
            }

                // Adjust for the right side clipping.

            lOutCol += ulCount;
            pjSrc   += ulCount;

            }
                else
                {
                /* Not on a visible scanline.
                 * Adjust our x output position and source pointer.
                 */

            lOutCol += ulNext;
            pjSrc   += ulNext;

        } /* if */

        // Fix up if this run was not WORD aligned.

            RLE8_FixAlignment(pjSrc)

            } /* switch */
        }
        else
        {
        // Encoded Mode

        if (RLE_InVisibleRect(ulCount, lOutCol))
            {
                ULONG ulClipMargin = 0;
        ulNext = pulXlate[ulNext];

                RLE8_EncClipLeft(ulClipMargin, ulCount, lOutCol);
                RLE8_ClipRight(ulClipMargin, ulCount, lOutCol);

            // Slap the bits on.

        while (ulCount--)
                {
            pdwDst[lOutCol] = ulNext;
            lOutCol++;
        }

        // Adjust for the right side clipping.

        lOutCol += ulClipMargin;

            }
            else
            {
            // Not on a visible scanline.  Adjust our x output position

        lOutCol += ulCount;

        } /* if */

        } /* if */

    } /* LOOP_FOREVER */

} /* bSrcCopySRLE8D32 */



/*******************************Public*Routine*****************************\
* WriteEncoded8
*
* A helper function for EncodeRLE8.  Writes a run of bytes in encoded format.
*
* Created: 28 Oct 92 @ 14:00
*
*  Author: Gerrit van Wingerden [gerritv]
*
\**************************************************************************/


int WriteEncoded8( BYTE bValue, BYTE *pbTarget, UINT uiLength,
                   BYTE *pbEndOfBuffer )
{
    if( pbTarget == NULL )
        return(2);

    if( pbTarget + 2 > pbEndOfBuffer )
        return(0);

    *pbTarget++ = (BYTE) uiLength;
    *pbTarget++ = bValue;
    return(2);
}


/*******************************Public*Routine*****************************\
* WriteAbsolute8
*
* A helper function for EncodeRLE8.  Writes a run of bytes in absolute format.
*
* Created: 28 Oct 92 @ 14:00
*
*  Author: Gerrit van Wingerden [gerritv]
*
\**************************************************************************/


int WriteAbsolute8( BYTE *pbRunStart, BYTE *pbTarget, int cRunLength,
                    BYTE *pbEndOfBuffer )
{
    int iRet;

    if( cRunLength == 1 )
    {
        iRet = 2;
    }
    else
    {
        if( cRunLength == 2 )
        {
            iRet = 4;
        }
        else
        {
            if( cRunLength & 0x01 )
            {
                iRet = cRunLength + 3;
            }
            else
            {
                iRet = cRunLength + 2;
            }
        }
    }

    if( pbTarget == NULL )
        return(iRet);

    if( pbTarget + iRet > pbEndOfBuffer )
        return(0);

    if( cRunLength == 1  )
    {
        *pbTarget++ = 0x01;
        *pbTarget = *pbRunStart;
        return(2);

    }

    if( cRunLength == 2 )
    {
        *pbTarget++ = 0x01;
        *pbTarget++ = *pbRunStart++;
        *pbTarget++ = 0x01;
        *pbTarget = *pbRunStart;
        return(4);
    }

    *pbTarget++ = 0;
    *pbTarget++ = (BYTE) cRunLength;

    RtlMoveMemory( pbTarget, pbRunStart, cRunLength );

    pbTarget += cRunLength;

    if( cRunLength & 0x01 )
    {
        *pbTarget++ = 0;
        return( iRet );
    }
    else
        return( iRet );

}



/*******************************Public*Routine*****************************\
* EncodeRLE8
*
* Encodes a bitmap into RLE8 format and returns the length of the of the
* encoded format.    If the target is NULL it just returns the length of
* the format. If there is a target and the encoded output is longer than
* cBufferSize then the function stops encoding and returns 0.
*
* History:
*  28 Oct 1992 Gerrit van Wingerden [gerritv] : creation
*  15 Mar 1993 Stephan J. Zachwieja [szach] : return 0 if buffer too small
*
\**************************************************************************/


int EncodeRLE8( BYTE *pbSource, BYTE *pbTarget, UINT uiWidth, UINT cNumLines,
                UINT cBufferSize )
{

    UINT cLineCount;
    BYTE bLastByte;
    BYTE *pbEndOfBuffer;
    BYTE *pbRunStart;
    BYTE *pbLineEnd;
    BYTE *pbCurPos;
    BYTE bCurChar;
    INT  cCurrentRunLength;
    INT  iMode, cTemp, uiLineWidth;
    UINT cTotal = 0;

    pbEndOfBuffer = pbTarget + cBufferSize;

    uiLineWidth = ( ( uiWidth + 3 ) >> 2 ) << 2;


    for( cLineCount = 0; cLineCount < cNumLines; cLineCount ++ )
    {
        pbRunStart = pbSource + uiLineWidth * cLineCount;
        bLastByte = *pbRunStart;
        pbLineEnd = pbRunStart + uiWidth;
        iMode = RLE_START;
        cCurrentRunLength = 1;

        for(pbCurPos = pbRunStart+1;pbCurPos <= pbLineEnd; pbCurPos += 1)
        {

            // We won't really encode the value at *pbLineEnd since it points
            // past the end of the scan so it doesn't matter what value we use.
            // However, it is important not to reference it since it may point
            // past the end of the buffer which can be uncommited memory.

            if( pbCurPos == pbLineEnd )
            {
                bCurChar = 0xFF;
            }
            else
            {
                bCurChar = *pbCurPos;
            }

            switch( iMode )
            {
            case RLE_START:
                iMode = (bCurChar == bLastByte) ? RLE_ENCODED : RLE_ABSOLUTE;
                bLastByte = bCurChar;
                break;

            case RLE_ABSOLUTE:
                if( ( bCurChar == bLastByte ) ||
                    ( cCurrentRunLength == 0xFF ) )

                {
                    int iOffset;

                    if( cCurrentRunLength == 0xFF )
                    {
                        iOffset = 0;
                        iMode = RLE_START;
                    }
                    else
                    {
                        iOffset = 1;
                        iMode = RLE_ENCODED;
                    }

                 // if pbTarget is not NULL and cTemp is zero then
                 // the buffer is too small to hold  encoded  data

                    cTemp = WriteAbsolute8(pbRunStart, pbTarget,
                        cCurrentRunLength - iOffset, pbEndOfBuffer);


                    if(pbTarget != NULL) {
                       if (cTemp == 0) return(0);
                        pbTarget += cTemp;
                    }

                    cTotal += cTemp;
                    pbRunStart = pbCurPos;
                    cCurrentRunLength = iOffset;
                }

                bLastByte = bCurChar;
                break;

            case RLE_ENCODED:
                if( ( bCurChar != bLastByte ) ||
                    ( cCurrentRunLength == 0xFF ) )

                {
                    cTemp = WriteEncoded8( bLastByte, pbTarget,
                       cCurrentRunLength, pbEndOfBuffer);

                 // if pbTarget is not NULL and cTemp is zero then
                 // the buffer is too small to hold  encoded  data

                    if (pbTarget != NULL) {
                       if (cTemp == 0) return(0);
                       pbTarget += cTemp;
                    }

                    cTotal += cTemp;
                    bLastByte = bCurChar;
                    pbRunStart = pbCurPos;
                    cCurrentRunLength = 0;
                    iMode =  RLE_START ;
                }

            }
            cCurrentRunLength += 1;
        }

        if( cCurrentRunLength > 1 )
        {
           if(iMode == RLE_ABSOLUTE)
              cTemp = WriteAbsolute8(pbRunStart, pbTarget,
                 cCurrentRunLength - 1, pbEndOfBuffer);
           else {
              cTemp = WriteEncoded8(bLastByte, pbTarget,
                 cCurrentRunLength - 1, pbEndOfBuffer);
           }

        // if pbTarget is not NULL and cTemp is zero then
        // the buffer is too small to hold  encoded  data

           if (pbTarget != NULL) {
              if (cTemp == 0) return(0);
              pbTarget += cTemp;
           }

           cTotal += cTemp;
        }

        if( pbTarget <= pbEndOfBuffer )
            cTotal += 2;

        if( pbTarget != NULL )
        {
            *((WORD *) pbTarget) = 0;
            pbTarget += 2;
        }

    }

// Write "End of bitmap" at the end so we're win31 compatible.

    if( pbTarget == NULL )
        return(cTotal + 2);

    if( pbTarget + 2 > pbEndOfBuffer )
        return(0);

    *pbTarget++ = 0;
    *pbTarget++ = 1;
    return(cTotal + 2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\server.h ===
/******************************Module*Header*******************************\
* Module Name: server.h                                                    *
*                                                                          *
* Server side stubs for GDI functions.                                     *
*                                                                          *
* Created: 14-Jan-1992 11:04:08                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                            *
\**************************************************************************/


int APIENTRY GreSetDIBitsToDeviceInternal(
    HDC hdcDest,
    int xDst,
    int yDst,
    DWORD cx,
    DWORD cy,
    int xSrc,
    int ySrc,
    DWORD iStartScan,
    DWORD cNumScan,
    LPBYTE pInitBits,
    LPBITMAPINFO pInfoHeader,
    DWORD iUsage,
    UINT cjMaxBits,
    UINT cjMaxInfo,
    BOOL bTransformoordinates,
    HANDLE hcmXform);

BOOL
GreTransparentDIBits(
    HDC          hdcDst,
    LONG         xDst,
    LONG         yDst,
    LONG         cxDst,
    LONG         cyDst,
    LPBYTE       pInitBits,
    LPBITMAPINFO pInfoHeader,
    UINT         iUsage,
    LONG         xSrc,
    LONG         ySrc,
    LONG         cxSrc,
    LONG         cySrc,
    COLORREF     TransColor,
    ULONG        cjMaxInfo,
    ULONG        cjMaxBits,
    HANDLE hcmXform
    );

HBITMAP APIENTRY
GreCreateDIBitmapComp(
    HDC hdc,
    INT cx,
    INT cy,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    FLONG fl,
    HANDLE hcmXform);

HBITMAP APIENTRY
GreCreateDIBitmapReal(
    HDC hdc,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    HANDLE hSection,
    DWORD dwOffset,
    HANDLE hSecure,
    FLONG fl,
    ULONG_PTR dwClientColorSpace, //dwClientColorSpace used to pass pointer
    PVOID *ppvBits); 

HBITMAP APIENTRY GreCreateDIBitmapInternal(
    HDC hdc,
    LPBITMAPINFOHEADER pInfoHeader,
    DWORD fInit,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    DWORD iUsage,
    UINT cjMaxInfo,
    UINT cjMaxInitInfo,
    UINT cjMaxBits,
    FLONG fl);

int APIENTRY GreSetDIBitsInternal(
    HDC hdc,
    HBITMAP hbm,
    UINT iStartScans,
    UINT cNumScans,
    LPBYTE pInitBits,
    LPBITMAPINFO pInitInfo,
    UINT iUsage,
    UINT cjMaxInfo,
    UINT cjMaxBits,
    HANDLE hcmXform);

int APIENTRY GreStretchDIBitsInternal(
    HDC hdc,
    int xDest,
    int yDest,
    int cWidthDest,
    int cHeightDest,
    int xSrc,
    int ySrc,
    int cWidthSrc,
    int cHeightSrc,
    LPBYTE pjBits,
    LPBITMAPINFO lpBitsInfo,
    DWORD iUsage,
    DWORD Rop,
    UINT  cjMaxInfo,
    UINT  cjMaxBits,
    HANDLE hcmXform
    );

BOOL APIENTRY GrePolyPolygonInternal(
    HDC         hdc,
    LPPOINT     pptl,
    LPINT       pcptl,
    int         ccptl,
    UINT        cMaxPoints);

typedef struct _POLYPATBLT POLYPATBLT,*PPOLYPATBLT;

BOOL
GrePolyPatBlt(
    HDC         hdcDst,
    DWORD       rop4,
    PPOLYPATBLT pPolyPat,
    DWORD       Count,
    DWORD       Mode
);


BOOL APIENTRY GrePolyPolylineInternal(
    HDC         hdc,
    CONST POINT *pptl,
    PULONG      pcptl,
    ULONG       ccptl,
    UINT        cMaxPoints);

HRGN APIENTRY GreCreatePolyPolygonRgnInternal(
    CONST POINT *aptl,
    CONST INT   *acptl,
    int     cPoly,
    int     iFill,
    UINT    cMaxPoints);

BOOL GetFontResourceInfoInternalW(
    LPWSTR       lpPathname,
    ULONG        cwc,
    ULONG        cFiles,
    UINT         cjIn,
    PSIZE_T      lpBytes,
    LPVOID       lpBuffer,
    DWORD        iType);

HBRUSH GreCreateDIBBrush(PVOID pv, FLONG fl, UINT cjMax, BOOL b8X8, BOOL bPen, PVOID pClient);

HPALETTE APIENTRY GreCreatePaletteInternal(LPLOGPALETTE pLogPal, UINT cEntries);

ULONG  GreGetKerningPairs(HDC hdc, ULONG  cPairs, KERNINGPAIR *pkpDst);

BOOL GrePlayScript(
    PULONG pulScript,
    ULONG  cjScript,
    PULONG pulEnv,
    ULONG  cjEnv,
    PULONG pulOut,
    ULONG  cjOut,
    ULONG  cLimit);

BOOL GreXformUpdate( HDC, FLONG, LONG, LONG, LONG, LONG, LONG, PVOID );

BOOL GreArcInternal
(
    ARCTYPE     arctype,
    HDC         hdc,
    int         x1,
    int         y1,
    int         x2,
    int         y2,
    int         x3,
    int         y3,
    int         x4,
    int         y4
);

LONG GreGetBitmapBits(HBITMAP hbm, ULONG cjTotal, PBYTE pjBuffer, PLONG pOffset);
LONG GreSetBitmapBits(HBITMAP hbm, ULONG cjTotal, PBYTE pjBuffer, PLONG pOffset);
BOOL GreGetRasterizerCaps(LPRASTERIZER_STATUS praststat);

ULONG GreSetPolyFillMode(HDC hdc, int iPolyFillMode);
ULONG GreSetROP2(HDC hdc,int iROP);

HANDLE GreGetDCObject (HDC hdc, int itype);

HBRUSH GreCreateSolidBrushInternal(COLORREF clrr,BOOL bPen,HBRUSH hbr);
HBRUSH GreCreateHatchBrushInternal(ULONG iStyle, COLORREF clrr, BOOL bPen);
HBRUSH GreCreatePatternBrushInternal(HBITMAP hbm,BOOL bPen,BOOL b8X8);

ULONG  GreGetOutlineTextMetricsInternalW(
    HDC                  hdc,
    ULONG                cjotm,
    OUTLINETEXTMETRICW   *potmw,
    TMDIFF               *ptmd
    );

BOOL     APIENTRY GreDeleteObjectApp(HANDLE hobj);
NTSTATUS GdiServerDllInitialization(PVOID psrv);

BOOL bSyncBrushObj(
    HBRUSH hbr);

typedef struct _WIDTHDATA WIDTHDATA;

BOOL GreGetWidthTable
(
    HDC        hdc,
    ULONG      cSpecial,
    WCHAR     *pwc,
    ULONG      cwc,
    USHORT    *psWidth,
    WIDTHDATA *pwd,
    FLONG     *pflInfo
    );

HANDLE
APIENTRY
GreSelectObject(
    HDC    hdc,
    HANDLE h
    );




HDC hdcOpenDCW(
    PWSZ               pwszDevice,
    DEVMODEW          *pdriv,
    ULONG              iType,
    HANDLE             hspool,
    PREMOTETYPEONENODE prton,
    DRIVER_INFO_2W    *pDriverInfo,
    PVOID             pUMdhpdev
);


// WINBUG #83106 2-7-2000 bhouse Investigate moving prototypes to ntgdi.h
// Old Comment:
//    - This prototype should go in ntgdi.h

BOOL GreGetDCDword( HDC hdc, UINT u, DWORD *Result);
BOOL GreGetAndSetDCDword( HDC hdc, UINT u, DWORD value, DWORD *result );

BOOL APIENTRY GreGetDCPoint(HDC,UINT,PPOINTL);

BOOL APIENTRY GreScaleViewportExtEx(HDC,int,int,int,int,LPSIZE);
BOOL APIENTRY GreScaleWindowExtEx(HDC,int,int,int,int,LPSIZE);
BOOL APIENTRY GreSetVirtualResolution(HDC,int,int,int,int);
BOOL APIENTRY GreTransformPoints(HDC hdc,PPOINT pptIn,PPOINT pptOut,int c,int iMode);

BOOL   GreDeleteClientObj(HANDLE h);
HANDLE GreFixUpHandle(HANDLE h);

int  GreAddFontResourceWInternal(LPWSTR  pwszFileName, ULONG cwc, ULONG cFiles, FLONG fl, DWORD dwPidTid, DESIGNVECTOR *pdv, ULONG cjDV);
HANDLE GreAddFontMemResourceEx(PVOID pvBuffer, DWORD cjBuffer, DESIGNVECTOR *pdv, DWORD cjDV, DWORD *pNumFonts);
BOOL GreRemoveFontResourceW(LPWSTR pwszPath, ULONG cwc, ULONG cFiles, FLONG fl, DWORD dwPidTid, DESIGNVECTOR *pdv, ULONG cjDV);
BOOL GreRemoveFontMemResourceEx(HANDLE hMMFont);
LONG cCapString(WCHAR *pwcDst,WCHAR *pwcSrc,INT cMax);

BOOL bGetPathName (
    PWCHAR awcPathName,
    LPWSTR pwszFileName
    );


HDC
GreGetDCforBitmap(
    HBITMAP hsurf
    );

BOOL
GreDoBanding( HDC hdc,BOOL bStart,POINTL *pptl );

BOOL
GreGetUFIBits(
    PUNIVERSAL_FONT_ID pufi,
    ULONG cjMaxBits,
    VOID *pvBits,
    ULONG *pulFileSize,
    FLONG fl);

BOOL
GreGetUFI( HDC hdc,
           PUNIVERSAL_FONT_ID pufi,
           DESIGNVECTOR *pdv,
           ULONG *pcjDV,
           ULONG *pulCheckSumDV,
           FLONG *pfl,
           VOID  **pfontID);

BOOL
GreForceUFIMapping(HDC hdc, PUNIVERSAL_FONT_ID pufi);

BOOL
GreGetUFIPathname(
    PUNIVERSAL_FONT_ID pufi,
    ULONG* pcwc,
    LPWSTR pwszPathname,
    ULONG* pcNumFiles,
    FLONG  fl,
    BOOL*  pbMemFont,
    ULONG* pcjView,
    PVOID  pvView,
    BOOL*  pbTTC,
    ULONG* iTTC
    );

ULONG  APIENTRY GreGetEmbedFonts();
BOOL   APIENTRY GreChangeGhostFont(VOID *fontID, BOOL bLoad);

DWORD  APIENTRY GreGetCharacterPlacementW(HDC, LPWSTR, DWORD, DWORD, LPGCP_RESULTSW, DWORD);

ULONG  GreGetGlyphOutlineInternal (
    HDC              hdc,
    WCHAR            wch,
    UINT             ulFormat,
    LPGLYPHMETRICS  lpgm,
    ULONG            cjBuffer,
    PVOID           pvBuffer,
    LPMAT2           lpmat2,
    BOOL            bIgnoreRotation
    );

BOOL GreResetDCInternal( HDC, DEVMODEW*, BOOL*, DRIVER_INFO_2W *, VOID * );

// It actually returns a handle
ULONG_PTR GreEnumFontOpen (
    HDC   hdc,
    ULONG iEnumType,
    FLONG flWin31Compat,
    ULONG cwchMax,
    PWSZ  pwszName,
    ULONG lfCharSet,
    ULONG *pulCount
    );

BOOL
GreSetupDCAttributes(
    HDC hdc
    );

BOOL
GreFreeDCAttributes(
    HDC hdc
    );

INT
GreQueryFonts(
    PUNIVERSAL_FONT_ID pufiFontList,
    ULONG nBufferSize,
    PLARGE_INTEGER pTimeStamp
    );

LPBITMAPINFO
pbmiConvertInfo(
    CONST BITMAPINFO *pbmi,
    ULONG iUsage);

BOOL bSetupBrushAttr (HBRUSH hbrush);

ULONG GreMakeFontDir(
    FLONG    flEmbed,       // mark file as "hidden"
    PBYTE    pjFontDir,     // pointer to structure to fill
    PWSZ     pwszPathname   // path of font file to use
    );

DWORD GreGetGlyphIndicesW (
    HDC     hdc,
    WCHAR  *pwc,
    DWORD   cwc,
    USHORT *pgi,
    DWORD   iMode,
    BOOL    bSubset
    );

DWORD GreGetFontUnicodeRanges(HDC, LPGLYPHSET);

#ifdef LANGPACK
BOOL GreGetRealizationInfo(HDC, PREALIZATION_INFO);
#endif

#define STRETCHBLT_ENABLE_ICM  0x0001

BOOL GreStretchBltInternal(
HDC     hdcTrg,
int     x,
int     y,
int     cx,
int     cy,
HDC     hdcSrc,
int     xSrc,
int     ySrc,
int     cxSrc,
int     cySrc,
DWORD   rop4,
DWORD   crBackColor,
FLONG   ulFlags
);







=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\solid.cxx ===
/******************************Module*Header*******************************\
* Module Name: solid.cxx
*
* This contains the special case blting code for P, Pn, DPx and Dn rops
* with solid colors.
*
* Created: 03-Mar-1991 22:01:14
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1991-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"

// Array of masks for blting

ULONG aulMsk[] =
{
    0xFFFFFFFF,
    0xFFFFFF7F,
    0xFFFFFF3F,
    0xFFFFFF1F,
    0xFFFFFF0F,
    0xFFFFFF07,
    0xFFFFFF03,
    0xFFFFFF01,
    0xFFFFFF00,
    0xFFFF7F00,
    0xFFFF3F00,
    0xFFFF1F00,
    0xFFFF0F00,
    0xFFFF0700,
    0xFFFF0300,
    0xFFFF0100,
    0xFFFF0000,
    0xFF7F0000,
    0xFF3F0000,
    0xFF1F0000,
    0xFF0F0000,
    0xFF070000,
    0xFF030000,
    0xFF010000,
    0xFF000000,
    0x7F000000,
    0x3F000000,
    0x1F000000,
    0x0F000000,
    0x07000000,
    0x03000000,
    0x01000000,
};

#define DBG_SOLID 0

#if DBG_SOLID
ULONG   DbgSolid = 0;
#endif

/******************************Public*Routine******************************\
* vSolidFillRect1
*
* Does a solid blt to a DIB of 1, 4, 8, 16 or 32 bpp.
*
* History:
*
*  17-Nov-1992 -by- Jim Thomas [jimt]
*       Change call to work on list of rectangles.
*       Change center loop to call RtlFillMemory only for wide
*       scan lines
*
*  03-Feb-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  01-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSolidFillRect1(
PRECTL prcl,
ULONG  cRcl,
PBYTE  pjDst,
LONG   lDeltaDst,
ULONG  iColor,
ULONG  cShift)
{
    ULONG   ulMskLeft;
    ULONG   ulMskRight;
    ULONG   cLeft;
    ULONG   cRight;
    ULONG   cxDword;
    ULONG   yRow;
    ULONG   ulColor;
    PULONG  pulTmp;
    PULONG  pulDst;
    ULONG   cx;
    ULONG   cy;
    ULONG   xDstStart;

    #if DBG_SOLID
        if (DbgSolid >= 1) {
            DbgPrint("SolidFillRect1:\n");
            DbgPrint("  pjDst     = 0x%08lx\n",pjDst);

            if (DbgSolid >= 2) {
                DbgPrint("  prcl      = 0x%08lx\n",prcl);
                DbgPrint("  cRcl      = %li\n",cRcl);
                DbgPrint("  lDeltaDst =  %li\n",lDeltaDst);
                DbgPrint("  iColor    = 0x%08lx\n",iColor);
                DbgPrint("  cShift    = %li\n",cShift);
            }
        }
    #endif

    //
    // loop through each rectangle
    //

    for ( ;cRcl > 0;cRcl--, prcl++ )
    {
        //
        // make sure rectangle is well ordered
        //

        ASSERTGDI(prcl != NULL,"ERROR: prcl = NULL");
        ASSERTGDI(prcl->right  >  prcl->left,"ERROR: left >= right");
        ASSERTGDI(prcl->bottom >  prcl->top, "ERROR: top >= bottom");

        #if DBG_SOLID

            if (DbgSolid >= 1) {
                DbgPrint("  Rect:   %li,%li to %li,%li\n",
                    prcl->left,prcl->top,
                    prcl->right,prcl->bottom);
            }

        #endif

        pulDst = (PULONG)(pjDst + prcl->top * lDeltaDst);

        cy = prcl->bottom - prcl->top;

        //
        // cx is the number of bits in the scan line to fill
        //

        cx = (prcl->right - prcl->left) << cShift;

        //
        // Starting bit
        //

        xDstStart = prcl->left << cShift;

        //
        // starting and ending DWORD offset
        //

        cLeft  = xDstStart >> 5;
        cRight = (xDstStart + cx) >> 5;

        //
        // generate left and right bit masks
        //

        ulMskLeft  = aulMsk[xDstStart      & 0x1f];
        ulMskRight = aulMsk[(xDstStart+cx) & 0x1f];

        //
        // if cLeft equals cRight then onyl 1 DWORD needs to be modified,
        // combine left and right masks. Do entire strip.
        //

        if (cLeft == cRight) {
            ulMskLeft &= ~ulMskRight;
            ulColor = iColor & ulMskLeft;
            ulMskLeft = ~ulMskLeft;
            pulTmp    = pulDst + cLeft;

            while (cy--) {
                *pulTmp = (*pulTmp & ulMskLeft) | ulColor;
                pulTmp  = (PULONG)((PBYTE)pulTmp + lDeltaDst);
            }

        } else {

            //
            // do solid fill in three portions,
            //
            // left edge  (partial DWORD)
            // center     (full DWORD)
            // right edge (partial DWORD)
            //

            //
            // left strip
            //

            if (ulMskLeft != ~0) {
                pulTmp = pulDst + cLeft;
                ulColor = iColor & ulMskLeft;
                ulMskLeft = ~ulMskLeft;
                yRow = cy;

                while (yRow--) {
                    *pulTmp = (*pulTmp & ulMskLeft) | ulColor;
                    pulTmp  = (PULONG)((PBYTE)pulTmp + lDeltaDst);
                }

                cLeft++;
            }

            //
            // center calc number of DWORDS
            //

            cxDword = cRight - cLeft;
            pulTmp  = pulDst + cLeft;
            if (cxDword != 0) {

                yRow = cy;

                while (yRow--) {

                    switch (cxDword) {
                    case 7:
                        *(pulTmp+6) = iColor;
                    case 6:
                        *(pulTmp+5) = iColor;
                    case 5:
                        *(pulTmp+4) = iColor;
                    case 4:
                        *(pulTmp+3) = iColor;
                    case 3:
                        *(pulTmp+2) = iColor;
                    case 2:
                        *(pulTmp+1) = iColor;
                    case 1:
                        *(pulTmp)   = iColor;
                        break;
                    default:
                        RtlFillMemoryUlong((PVOID)pulTmp,cxDword<<2,iColor);
                    }

                    pulTmp  = (PULONG)((PBYTE)pulTmp + lDeltaDst);
                }

            }

            //
            // right edge
            //

            if (ulMskRight != ~0) {
                pulTmp   = pulDst + cRight;
                ulColor  = iColor & ~ulMskRight;


                while (cy--) {
                    *pulTmp = (*pulTmp & ulMskRight) | ulColor;
                    pulTmp  = (PULONG)((PBYTE)pulTmp + lDeltaDst);
                }
            }

        }



    }
}

/******************************Public*Routine******************************\
* vSolidFillRect24
*
* Does a solid blt to a 24 bpp DIB.
*
* History:
*
*  17-Nov-1992 -by- Jim Thomas [jimt]
*       Change call to list of rects
*
*  02-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSolidFillRect24(
PRECTL prcl,
ULONG  cRcl,
PBYTE  pjDst,
LONG   lDeltaDst,
ULONG  iColor,
ULONG  cShift)
{
    PBYTE   pjDstRow;
    BYTE    jRed,jGreen,jBlue;
    ULONG   cxTemp;
    ULONG   cx;
    ULONG   cy;
    LONG    lDelta;

    DONTUSE(cShift);

    //
    // place any asserts here
    //


    jRed   = (BYTE)iColor;
    jGreen = (BYTE)(iColor >> 8);
    jBlue  = (BYTE)(iColor >> 16);


    //
    // loop through each rectangle
    //

    for ( ;cRcl > 0;cRcl--, prcl++ )
    {
        pjDstRow = pjDst + (prcl->top * lDeltaDst) + 3 * prcl->left;

        cy = prcl->bottom  - prcl->top;
        cx = prcl->right - prcl->left;

        //
        // lDelta is adjusted to go from the end of one scan
        // line to the start of the next.
        //

        lDelta = lDeltaDst - 3*cx;

        while (cy--) {

            cxTemp = cx;

            while (cxTemp--) {

                *(pjDstRow)   = jRed;
                *(pjDstRow+1) = jGreen;
                *(pjDstRow+2) = jBlue;

                pjDstRow += 3;
            }

            pjDstRow += lDelta;

        }
    }
}


/******************************Public*Routine******************************\
* vSolidXorRect1
*
* Does an xor blt to a DIB or 1, 4, 8, 16 or 32 bpp.
*
* History:
*
*  17-Nov-1992 -by- Jim Thomas [jimt]
*       Change call to list of rects
*
*
*  03-Feb-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  01-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSolidXorRect1(
PRECTL prcl,
ULONG  cRcl,
PBYTE  pjDst,
LONG   lDeltaDst,
ULONG  iColor,
ULONG  cShift)
{
    ULONG   ulMskLeft;
    ULONG   ulMskRight;
    ULONG   iLeft;
    ULONG   iRight;
    ULONG   cLeft;
    ULONG   cRight;
    ULONG   culFill;
    ULONG   yRow;
    PULONG  pulTmp;
    PULONG  pulDst;
    ULONG   cx;
    ULONG   cy;
    ULONG   xDstStart;
    BOOL    bSimple;

    #if DBG_SOLID

        if (DbgSolid >= 1) {
            DbgPrint("SolidXorRect1:\n");
            DbgPrint("  pjDst     = 0x%08lx\n",pjDst);

            if (DbgSolid >= 2) {
                DbgPrint("  prcl      = 0x%08lx\n",prcl);
                DbgPrint("  cRcl      = %li\n",cRcl);
                DbgPrint("  lDeltaDst =  %li\n",lDeltaDst);
                DbgPrint("  iColor    = 0x%08lx\n",iColor);
                DbgPrint("  cShift    = %li\n",cShift);
            }
        }

    #endif

    //
    // loop through each rectangle
    //

    for ( ; cRcl > 0;cRcl--, prcl++ )
    {
        //
        // init rect params
        //

        ASSERTGDI(prcl != NULL,"ERROR: prcl = NULL");
        ASSERTGDI(prcl->right  >  prcl->left,"ERROR: left >= right");
        ASSERTGDI(prcl->bottom >  prcl->top, "ERROR: top >= bottom");

        pulDst = (PULONG)(pjDst + prcl->top * lDeltaDst);

        cx     = (prcl->right - prcl->left) << cShift;

        cy     = prcl->bottom - prcl->top;

        xDstStart = (prcl->left << cShift);

        //
        // calc index of leftmost and rightmost DWORDS
        //

        cLeft = xDstStart >> 5;
        cRight = (xDstStart + cx) >> 5;

        //
        // calc number of bits used in leftmost and rightmost DWORDs
        //

        iLeft = xDstStart & 31;
        iRight = (xDstStart + cx) & 31;

        //
        // generate DWORD store masks
        //

        ulMskLeft  =  aulMsk[iLeft];
        ulMskRight = ~aulMsk[iRight];

        //
        // If the leftmost and rightmost DWORDs are the same, then only one
        // strip is needed.  Merge the two masks together and note this.
        //

        bSimple = FALSE;

        if (cLeft == cRight)
        {
            ulMskLeft &= ulMskRight;
            bSimple = TRUE;
        }


        #if DBG_SOLID

            if (DbgSolid >= 1) {
                DbgPrint("  Rect:   %li,%li to %li,%li\n",
                    prcl->left,prcl->top,
                    prcl->right,prcl->bottom);
            }

        #endif


        //
        // Lay down the left edge, if needed.
        //

        if (bSimple || (iLeft != 0))
        {
            pulTmp = pulDst + cLeft;
            ulMskLeft &= iColor;

            for (yRow = 0; yRow != cy; yRow++)
            {
                *pulTmp ^= ulMskLeft;
                pulTmp = (ULONG *) ((BYTE *) pulTmp + lDeltaDst);
            }

            cLeft++;
        }

        if (!bSimple) {

            //
            // Lay down the center strip, if needed.
            //

            culFill = cRight - cLeft;

            if (culFill != 0)
            {
                pulTmp = pulDst + cLeft;
                for (yRow = 0; yRow != cy; yRow++)
                {
                    cx = culFill;
                    while (cx--)
                    *pulTmp++ ^= iColor;

                    pulTmp -= culFill;
                    pulTmp = (ULONG *) ((BYTE *) pulTmp + lDeltaDst);
                }
            }

            //
            // Lay down the right edge, if needed.
            //

            if (iRight != 0)
            {
                pulTmp = pulDst + cRight;
                ulMskRight &= iColor;

                for (yRow = 0; yRow != cy; yRow++)
                {
                    *pulTmp ^= ulMskRight;
                    pulTmp = (ULONG *) ((BYTE *) pulTmp + lDeltaDst);
                }
            }

        }

    }
}

/******************************Public*Routine******************************\
* vSolidXorRect24
*
* Does a solid blt to a 24 bpp DIB.
*
* History:
*
*  17-Nov-1992 -by- Jim Thomes [jimt]
*   change call to list of rects
*
*  03-Feb-1992 -by- Donald Sidoroff [donalds]
* Rewrote it.
*
*  02-Mar-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSolidXorRect24(
PRECTL prcl,
ULONG  cRcl,
PBYTE  pjDst,
LONG   lDeltaDst,
ULONG  iColor,
ULONG  cShift)
{
    PBYTE pjDstTmp;
    BYTE  jRed, jGreen, jBlue;
    ULONG cxTemp;
    ULONG cx;
    ULONG cy;
    LONG  lDelta;

    DONTUSE(cShift);

    //
    // lDelta is adjusted to go from the end of one scan
    // line to the start of the next.
    //


    jRed = (BYTE) iColor;
    jGreen = (BYTE) (iColor >> 8);
    jBlue = (BYTE) (iColor >> 16);


    for ( ;cRcl > 0;cRcl--, prcl++ )
    {
        //
        // init rect params
        //

        pjDstTmp = pjDst + prcl->top * lDeltaDst + prcl->left * 3;

        cx    = prcl->right - prcl->left;
        cy    = prcl->bottom - prcl->top;

        lDelta = lDeltaDst - (3 * cx);

        ASSERTGDI(cx != 0, "ERROR vDibSolidBlt32");
        ASSERTGDI(cy != 0, "ERROR vDibSolidBlt32");

        while(cy--)
        {
            cxTemp = cx;

            while(cxTemp--)
            {
                *(pjDstTmp)   ^= jRed;
                *(pjDstTmp+1) ^= jGreen;
                *(pjDstTmp+2) ^= jBlue;

                pjDstTmp += 3;

            }

            pjDstTmp = pjDstTmp + lDelta;
        }
    }
}

/******************************Public*Routine******************************\
* vSolidFillRow1
*
*   Blt a list of adjacent rows to a DIB of of 1, 4, 8, 16 or 32 bpp.
*
* History:
*  11-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSolidFillRow1(
    PROW   prow,
    ULONG  crow,
    LONG   yTop,
    PBYTE  pjBits,
    ULONG  iColor,
    LONG   lDelta,
    ULONG  cShift)
{
    pjBits += yTop * lDelta;

    for (UINT i = 0; i < crow; i++, prow++, pjBits += lDelta)
    {
        ULONG *pulDst = (PULONG)pjBits;

        LONG  cx        = (prow->right - prow->left) << cShift;
        ULONG xDstStart = prow->left << cShift;

        BOOL  bSimple = FALSE;

        ULONG cLeft = xDstStart >> 5;                 // Index of leftmost DWORD
        ULONG cRght = (xDstStart + cx) >> 5;          // Index of rightmost DWORD

        ULONG iLeft = xDstStart & 31;                 // Bits used in leftmost DWORD
        ULONG iRght = (xDstStart + cx) & 31;          // Bits used in rightmost DWORD

        ULONG ulMskLeft =  aulMsk[iLeft];
        ULONG ulMskRght = ~aulMsk[iRght];

    // If the leftmost and rightmost DWORDs are the same, then only one
    // strip is needed.  Merge the two masks together and note this.

        if (cLeft == cRght)
        {
            ulMskLeft &= ulMskRght;
            bSimple = TRUE;
        }

    // Lay down the left edge, if needed.

        if (bSimple || (iLeft != 0))
        {
            pulDst[cLeft] = (pulDst[cLeft] & ~ulMskLeft) | (iColor & ulMskLeft);

            if (bSimple)
                continue;

            cLeft++;
        }

    // Lay down the center strip, if needed.

        ULONG cjFill = (cRght - cLeft) << 2;

        if (cjFill != 0)
            RtlFillMemoryUlong((PVOID) (pulDst+cLeft), cjFill, iColor);

    // Lay down the right edge, if needed.

        if (iRght != 0)
            pulDst[cRght] = (pulDst[cRght] & ~ulMskRght) | (iColor & ulMskRght);
    }
}

/******************************Public*Routine******************************\
* vSolidFillRow24
*
*   Blt a list of adjacent rows to a 24 bpp DIB.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSolidFillRow24(
    PROW   prow,
    ULONG  crow,
    LONG   yTop,
    PBYTE  pjBits,
    ULONG  iColor,
    LONG   lDelta,
    ULONG  cShift)
{
    BYTE  jRed, jGreen, jBlue;

    jRed   = (BYTE) iColor;
    jGreen = (BYTE) (iColor >> 8);
    jBlue  = (BYTE) (iColor >> 16);

    pjBits += (yTop * lDelta);

    for (UINT i = 0; i < crow; i++, prow++, pjBits += lDelta)
    {
        LONG   cx        = (prow->right - prow->left) << cShift;
        ULONG  xDstStart = prow->left << cShift;
        BYTE*  pjDst     = pjBits + (3 * xDstStart);

        ULONG cxTemp = cx;

        while(cxTemp--)
        {
            *(pjDst++) = jRed;
            *(pjDst++) = jGreen;
            *(pjDst++) = jBlue;
        }
    }
}

/******************************Public*Routine******************************\
* vSolidXorRow1
*
* Does an xor blt of a list of adjacent rows to a DIB or 1, 4, 8, 16 or 32 bpp.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSolidXorRow1(
    PROW   prow,
    ULONG  crow,
    LONG   yTop,
    PBYTE  pjBits,
    ULONG  iColor,
    LONG   lDelta,
    ULONG  cShift)
{
    pjBits += yTop * lDelta;

    for (UINT i = 0; i < crow; i++, prow++,pjBits += lDelta)
    {
        ULONG*  pulDst    = (ULONG *) pjBits;
        LONG    cx        = (prow->right - prow->left) << cShift;
        ULONG   xDstStart = prow->left << cShift;

        ULONG   ulMskLeft;
        ULONG   ulMskRght;
        ULONG   iLeft;
        ULONG   iRght;
        ULONG   cLeft;
        ULONG   cRght;
        ULONG   culFill;
        BOOL    bSimple = FALSE;

        cLeft = xDstStart >> 5;                 // Index of leftmost DWORD
        cRght = (xDstStart + cx) >> 5;          // Index of rightmost DWORD

        iLeft = xDstStart & 31;                 // Bits used in leftmost DWORD
        iRght = (xDstStart + cx) & 31;          // Bits used in rightmost DWORD

        ulMskLeft =  aulMsk[iLeft];
        ulMskRght = ~aulMsk[iRght];

    // If the leftmost and rightmost DWORDs are the same, then only one
    // strip is needed.  Merge the two masks together and note this.

        if (cLeft == cRght)
        {
            ulMskLeft &= ulMskRght;
            bSimple = TRUE;
        }

    // Lay down the left edge, if needed.

        if (bSimple || (iLeft != 0))
        {
            ulMskLeft &= iColor;

            pulDst[cLeft] ^= ulMskLeft;

            if (bSimple)
                continue;

            cLeft++;
        }

    // Lay down the center strip, if needed.

        culFill = cRght - cLeft;

        if (culFill != 0)
        {
            PULONG pulTmp = pulDst + cLeft;
            cx = culFill;
            while (cx--)
                *pulTmp++ ^= iColor;
        }

    // Lay down the right edge, if needed.

        if (iRght != 0)
        {
            ulMskRght &= iColor;

            pulDst[cRght] ^= ulMskRght;
        }
    }
}



/******************************Public*Routine******************************\
* vSolidXorRow24
*
* Does a solid blt with a list of adjacent rows to a 24 bpp DIB.
*
* History:
*  12-Oct-1993 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSolidXorRow24(
    PROW   prow,
    ULONG  crow,
    LONG   yTop,
    PBYTE  pjBits,
    ULONG  iColor,
    LONG   lDelta,
    ULONG  cShift)
{
    BYTE  jRed, jGreen, jBlue;

    jRed   = (BYTE) iColor;
    jGreen = (BYTE) (iColor >> 8);
    jBlue  = (BYTE) (iColor >> 16);
    pjBits += yTop * lDelta;

    for (UINT i = 0; i < crow; i++, prow++, pjBits += lDelta)
    {
        LONG   cx        = (prow->right - prow->left) << cShift;
        ULONG  xDstStart = prow->left << cShift;
        BYTE*  pjDst     = pjBits + (3 * xDstStart);

        ULONG cxTemp = cx;

        while(cxTemp--)
        {
            *(pjDst++) ^= jRed;
            *(pjDst++) ^= jGreen;
            *(pjDst++) ^= jBlue;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\sort.cxx ===
/******************************Module*Header*******************************\
* Module Name: sort.c
*
*
* Created: 20-Mar-1995 09:52:19
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
*
\**************************************************************************/

#include "precomp.hxx"

typedef struct _SORTSTACK
{
    ULONG iStart;
    ULONG c;
} SORTSTACK;

#define MAXSORT 20

typedef struct _SORTDATA
{
    PBYTE     pjBuf;
    ULONG     iStack;
    ULONG     cjElem;
    SORTCOMP  pfnComp;
    SORTSTACK sStack[MAXSORT];

} SORTDATA;

/******************************Public*Routine******************************\
* vSortSwap()
*
*   Swap the data pointed to by pj1 and pj2, each containing cj bytes.
*
*   Note: this assumes cj is a multiple of 4.
*
*   NOTE: vSortSwap should be inline.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSortSwap(
    PBYTE pj1,
    PBYTE pj2,
    ULONG cj)
{
    PLONG pl1 = (PLONG)pj1;
    PLONG pl2 = (PLONG)pj2;

    do
    {
        LONG l;

        l    = *pl1;
        *pl1++ = *pl2;
        *pl2++ = l;

    } while (cj -= 4);
}

/******************************Public*Routine******************************\
* vSortPush()
*
*   Add a range to the stack to be sorted.
*
*   If there are 0 or 1 elements, just return, sorting done.
*   If there are 2, 3, 4, or 5 elements, just do a bubble sort. sorting done.
*   If the stack is full, just do a bubble sort. sorting done.
*   Otherwise, add a new range to the stack.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vSortPush(
    SORTDATA *psd,
    ULONG    iStart,
    ULONG    c)
{
    PBYTE  pj   = psd->pjBuf + iStart;

#if DBGSORT
    DbgPrintf("vSortPush - iStack = %ld, iStart = %ld, c = %ld\n",psd->iStack,iStart,c);
#endif

    if (c > psd->cjElem)
    {
        ULONG i,j;
        ULONG cjElem = psd->cjElem;

        //for (i = 0; i < (c - cjElem); i += cjElem)
        {
        //    if ((*psd->pfnComp)(&pj[i],&pj[i+cjElem]) > 0)
            {
                if ((c <= (4 * psd->cjElem)) || (psd->iStack == MAXSORT))
                {
                    // we have 4 or fewer elements.  Just do a buble sort.  With 4 elements
                    // this will be a 6 compares and upto 6 swaps.
                    // We make c-1 passes over then entire array.  Each pass guarantees that
                    // the next smallest element is shifted to location i.  After the first pass
                    // the smallest element is in location 0.  After the second pass the second
                    // smallest element is in location 1. etc.


                #if DBGSORT
                    if (c > (4 * cjElem))
                        DbgPrintf("******* Stack too deep: c = %ld\n",c / cjElem);
                #endif

                    for (i = 0; i < (c - cjElem); i += cjElem)
                        for (j = c - cjElem; j > i; j -= cjElem)
                            if ((*psd->pfnComp)(&pj[j-cjElem],&pj[j]) > 0)
                                vSortSwap(&pj[j-cjElem],&pj[j],cjElem);
                }
                else
                {
                    psd->sStack[psd->iStack].iStart = iStart;
                    psd->sStack[psd->iStack].c      = c;
                    psd->iStack++;
                }
        //        break;
            }
        }
    }
}

/******************************Public*Routine******************************\
* EngSort()
*
*   This is an implementation of the c-runtime qsort.
*
* History:
*  18-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

extern "C" VOID EngSort(
    PBYTE pjBuf,
    ULONG c,
    ULONG cjElem,
    SORTCOMP pfnComp)
{
    SORTDATA sd;

#if DBGSORT
    ULONG cOrg = c;
    ULONG i;

    DbgPrintf("\n\nvDrvSort - c = %d\n",c);

#endif

    ASSERTGDI((cjElem & 0x3) == 0,"EngSort not dword aligned");

    if (cjElem & 3)
        return;

    sd.pjBuf   = pjBuf;
    sd.iStack  = 0;
    sd.pfnComp = pfnComp;
    sd.cjElem  = cjElem;

    vSortPush(&sd,0,c * cjElem);

    while (sd.iStack)
    {
        PBYTE pj;
        ULONG iStart;
        ULONG iLow;
        ULONG iHi;

        --sd.iStack;
        iStart = sd.sStack[sd.iStack].iStart;
        pj     = &pjBuf[iStart];
        c      = sd.sStack[sd.iStack].c;

    #if DBGSORT

        for (i = 0; i < cOrg;++i)
            vPrintElem(&pjBuf[i * cjElem]);
        DbgPrintf("\n");

        DbgPrintf("iStart = %ld, c = %ld, iStack = %lx - ",iStart/cjElem,c/cjElem,sd.iStack);

        for (i = 0; i < c;i += cjElem)
            vPrintElem(&pj[i]);
        DbgPrintf("\n");

    #endif

        // pick a random value to use for dividing.  Don't use the first since this
        // will reduce the chances of worst case if the list is sorted in reverse order.

        vSortSwap(&pj[0],&pj[(c / cjElem) / 2 * cjElem],cjElem);

        // initialize the starting and ending indexes.  Note that all operations
        // use cjElem as the increment instead of 1.

        iLow = 0;
        iHi  = c - cjElem;

        // divide the array into two pieces, all elements <= before current one

        for (;;)
        {
            // while (pj[iHi] > pj[0]))

            while ((iHi > iLow) && ((*pfnComp)(&pj[iHi],&pj[0]) >= 0))
                iHi -= cjElem;

            // while (pj[iLow] <= pj[0]))

            while ((iLow < iHi) && ((*pfnComp)(&pj[iLow],&pj[0]) <= 0))
                iLow += cjElem;

            if (iHi == iLow)
                break;

            vSortSwap(&pj[iLow],&pj[iHi],cjElem);

            iHi -= cjElem;
            //if (iLow < iHi)
            //    iLow += cjElem;

        #if DBGSORT
            DbgPrintf("\tiLow = %ld, iHi = %ld\n",iLow/cjElem,iHi/cjElem);
        #endif
        }

        // now add the two pieces to stack
        // 0 -> (iLow - 1), (iLow + 1) -> (c - 1)

        if (iLow != 0)
        {
            vSortSwap(&pj[0],&pj[iLow],cjElem);
            if (iLow > 1)
                vSortPush(&sd,iStart,iLow);
        }

        c = c - iLow - cjElem;
        if (c > 1)
            vSortPush(&sd,iStart + iLow + cjElem,c);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\sources.inc ===
MAJORCOMP=windows

TARGETTYPE=LIBRARY

MINORCOMP=gre
TARGETNAME=gre
TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

INCLUDES=..;                             \
         ..\..\inc;                      \
         $(WINCORE_PATH)\dxkernel\inc;   \
         $(WINCORE_PATH)\w32inc;         \
         $(BASE_INC_PATH);               \
         $(DDK_INC_PATH);                \
         $(DRIVERS_INC_PATH);            \
         $(MULTIMEDIA_INC_PATH);         \

## Hydra
INCLUDES=$(INCLUDES);                    \
         $(TERMSRV_INC_PATH)

C_DEFINES=$(C_DEFINES) -DNTOS_KERNEL_RUNTIME=1 -D_NTDRIVER_ -D_HYDRA_
C_DEFINES=$(C_DEFINES) -DNO_INTERLOCKED_INTRINSICS=1 -DFE_SB -DLANGPACK -D_NTSYSTEM_DRIVER_ -DUSE_MIRRORING -DDS_ENABLE_OLD_STUFF=0

## Hydra
C_DEFINES=$(C_DEFINES) -D_HYDRA_

## OpenGL with multi monitor
C_DEFINES=$(C_DEFINES) -DOPENGL_MM

## Watchdog
C_DEFINES=$(C_DEFINES) -DDDI_WATCHDOG

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

ASM_DEFINES=$(ASM_DEFINES) -DFE_SB

!IFDEF PENTIUMCOUNTER
C_DEFINES=$(C_DEFINES) -DPENTIUMCOUNTER
ASM_DEFINES=$(ASM_DEFINES) -DPENTIUMCOUNTER
!endif

SOURCES=$(SOURCES)         \
        ..\globals.c       \
        ..\guids.c         \
        ..\mapfile.c       \
        ..\ntgdi.c         \
        ..\textxl.c        \
        ..\w32kevnt.c      \
        ..\aatext.cxx      \
        ..\alphablt.cxx    \
        ..\alphaimg.cxx    \
        ..\alphatran.cxx   \
        ..\atmstub.c       \
        ..\bbddi.cxx       \
        ..\bltlnk.cxx      \
        ..\bltlnkfn.cxx    \
        ..\brushapi.cxx    \
        ..\brushddi.cxx    \
        ..\brushobj.cxx    \
        ..\cache.cxx       \
        ..\cleanup.cxx     \
        ..\clipline.cxx    \
        ..\clipobj.cxx     \
        ..\cpanel.cxx      \
        ..\curseng.cxx     \
        ..\dcgdi.cxx       \
        ..\dcobj.cxx       \
        ..\dcrgn.cxx       \
        ..\dda.cxx         \
        ..\debugko.cxx     \
        ..\dibapi.cxx      \
        ..\dither.cxx      \
        ..\drawattr.cxx    \
        ..\draweng.cxx     \
        ..\drawgdi.cxx     \
        ..\drawstream.cxx  \
        ..\drvobj.cxx      \
        ..\drvsup.cxx      \
        ..\engbrush.cxx    \
        ..\engline.cxx     \
        ..\engstrps.cxx    \
        ..\engstrok.cxx    \
        ..\enumgdi.cxx     \
        ..\fastfill.cxx    \
        ..\fillddi.cxx     \
        ..\flinkgdi.cxx    \
        ..\floodgdi.cxx    \
        ..\fntassoc.cxx    \
        ..\fntcache.cxx    \
        ..\fntxform.cxx    \
        ..\fontddi.cxx     \
        ..\fontgdi.cxx     \
        ..\fontgdip.cxx    \
        ..\fontmap.cxx     \
        ..\fontsub.cxx     \
        ..\fontsup.cxx     \
        ..\gradfill.cxx    \
        ..\hmgrapi.cxx     \
        ..\htblt.cxx       \
        ..\icmapi.cxx      \
        ..\icmobj.cxx      \
        ..\init.cxx        \
        ..\invcmap.cxx     \
        ..\lfntobj.cxx     \
        ..\mapfile2.cxx    \
        ..\maskblt.cxx     \
        ..\meta.cxx        \
        ..\misceudc.cxx    \
        ..\miscgdi.cxx     \
        ..\multi.cxx       \
        ..\opendc.cxx      \
        ..\os.cxx          \
        ..\paintddi.cxx    \
        ..\palddi.cxx      \
        ..\paleng.cxx      \
        ..\palgdi.cxx      \
        ..\palobj.cxx      \
        ..\panning.cxx     \
        ..\patblt.cxx      \
        ..\pathclip.cxx    \
        ..\pathflat.cxx    \
        ..\pathgdi.cxx     \
        ..\pathobj.cxx     \
        ..\pathwide.cxx    \
        ..\pattern.cxx     \
        ..\pdevobj.cxx     \
        ..\pfeobj.cxx      \
        ..\pffobj.cxx      \
        ..\pftobj.cxx      \
        ..\pixelapi.cxx    \
        ..\pixelfmt.cxx    \
        ..\plgblt.cxx      \
        ..\print.cxx       \
        ..\rfntobj.cxx     \
        ..\rfntxlat.cxx    \
        ..\rgn2path.cxx    \
        ..\rgngdi.cxx      \
        ..\rgnobj.cxx      \
        ..\rle4blt.cxx     \
        ..\rle8blt.cxx     \
        ..\rotate.cxx      \
        ..\solid.cxx       \
        ..\solline.cxx     \
        ..\sort.cxx        \
        ..\spool.cxx       \
        ..\sprite.cxx      \
        ..\srcalign.cxx    \
        ..\srcblt1.cxx     \
        ..\srcblt4.cxx     \
        ..\srcblt8.cxx     \
        ..\srcblt16.cxx    \
        ..\srcblt24.cxx    \
        ..\srcblt32.cxx    \
        ..\stockfnt.cxx    \
        ..\strchblt.cxx    \
        ..\strdir.cxx      \
        ..\stretch.cxx     \
        ..\surfddi.cxx     \
        ..\surfeng.cxx     \
        ..\surfgdi.cxx     \
        ..\surfobj.cxx     \
        ..\textddi.cxx     \
        ..\textgdi.cxx     \
        ..\textobj.cxx     \
        ..\timer.cxx       \
        ..\tranblt.cxx     \
        ..\trig.cxx        \
        ..\trimesh.cxx     \
        ..\trivblt.cxx     \
        ..\ttgdi.cxx       \
        ..\umpd.cxx        \
        ..\umpdobj.cxx     \
        ..\umpddrv.cxx     \
        ..\umpdeng.cxx     \
        ..\usersrv.cxx     \
	..\verifier.cxx    \
	..\watchdog.cxx    \
        ..\wndobj.cxx      \
        ..\xformddi.cxx    \
        ..\xformgdi.cxx    \
        ..\xformobj.cxx    \
        ..\ylateddi.cxx    \
        ..\ylateobj.cxx

## Hydra
SOURCES=$(SOURCES)         \
        ..\misc.cxx        \
        ..\helpers.cxx     \
        ..\muclean.cxx     \
        ..\muio.c

## DirectDraw and Direct3D
SOURCES=$(SOURCES)         \
       ..\ddsup.cxx

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\solline.cxx ===
/******************************Module*Header*******************************\
* Module Name:
*
*   solline.cxx
*
* Abstract
*
*   This module draws solid color, single pixel wide, non-styled, trivial or
*   rectangularly clipped lines to a DIB.
*
* Author:
*
*   Mark Enstrom    (marke) 12-1-93
*
* Copyright (c) 1993-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.hxx"
#include "solline.hxx"

#define DBG_LINE 0


#if DBG_LINE
    ULONG   DbgLine = 0;
#endif

//
// horizontal line accelerators
//

PFN_HORZ   gapfnHorizontal[6] =
    {
        vHorizontalLine1,vHorizontalLine4,vHorizontalLine8,
        vHorizontalLine16,vHorizontalLine24,vHorizontalLine32
    };


//
// line DDA routines for each DIB format
//

PFN_OCTANT gapfnOctant[6][8] =
    {
        {
            vLine1Octant07,vLine1Octant16,vLine1Octant07,vLine1Octant16,
            vLine1Octant34,vLine1Octant25,vLine1Octant34,vLine1Octant25
        },
        {
            vLine4Octant07,vLine4Octant16,vLine4Octant07,vLine4Octant16,
            vLine4Octant34,vLine4Octant25,vLine4Octant34,vLine4Octant25
        },
        {
            vLine8Octant07,vLine8Octant16,vLine8Octant07,vLine8Octant16,
            vLine8Octant34,vLine8Octant25,vLine8Octant34,vLine8Octant25
        },
        {
            vLine16Octant07,vLine16Octant16,vLine16Octant07,vLine16Octant16,
            vLine16Octant34,vLine16Octant25,vLine16Octant34,vLine16Octant25
        },
        {
            vLine24Octant07,vLine24Octant16,vLine24Octant07,vLine24Octant16,
            vLine24Octant34,vLine24Octant25,vLine24Octant34,vLine24Octant25
        },
        {
            vLine32Octant07,vLine32Octant16,vLine32Octant07,vLine32Octant16,
            vLine32Octant34,vLine32Octant25,vLine32Octant34,vLine32Octant25
        }

    };

//
// mask for 4bpp pixels
//

UCHAR PixelLineMask4[2] = {0x0f,0xf0};


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vSolidLine
*
* Routine Description:
*
*   Extract line end points from path object and call lower lever drawing
*   routine
*
* Arguments:
*
*   pso             - destination surface object
*   ppo             - path object
*   pptfx           - line coordinates if 'ppo' is NULL
*   pco             - clip object
*   iSolidColor     - solid color to draw
*
* Return Value:
*
*   none
*
\**************************************************************************/

VOID
vSolidLine (
    SURFACE *pSurf,
    PATHOBJ *ppo,
    POINTFIX*pptfx,
    CLIPOBJ *pco,
    ULONG   iSolidColor
)
{

    PATHDATA    pd;
    BOOL        bMore;
    ULONG       cptfx;
    POINTFIX    ptfxStartFigure;
    POINTFIX    ptfxLast;
    POINTFIX*   pptfxFirst;
    POINTFIX*   pptfxBuf;
    ULONG       ulFormat;
    LONG        lDelta;
    PBYTE       pjDst;
    RECTL       arclClip[4];
    PRECTL      prclClip = (PRECTL) NULL;

    //
    // check out params
    //

    ASSERTGDI((pco == NULL) || (pco->iDComplexity != DC_COMPLEX),
              "Routine does not handle complex clipping");

    ulFormat       = pSurf->iFormat();
    lDelta         = pSurf->lDelta();
    pjDst          = (PUCHAR)(pSurf->pvScan0());

    //
    // determine format and routines
    //

    switch (ulFormat)
    {
    case BMF_1BPP:
        iSolidColor = iSolidColor ? 0xffffffff : 0x00000000;
        break;

        //
        // rest fall through
        //

    case BMF_4BPP:
        iSolidColor |= (iSolidColor << 4);
    case BMF_8BPP:
        iSolidColor |= (iSolidColor << 8);
    case BMF_16BPP:
        iSolidColor |= (iSolidColor << 16);
    case BMF_24BPP:
    case BMF_32BPP:
    break;
    default:
        RIP("Invalid bitmap format");
    }

    //
    //  get clipping rectangle if needed, copy the rectangle into several
    //  formats for use by the GIQ clipping routine
    //

    if ((pco != NULL) && (pco->iDComplexity == DC_RECT))
    {
        //
        // assign temp rectangles to clipping bounds
        //

        arclClip[0]        =  pco->rclBounds;

        #if DBG_LINE
            if (DbgLine >= 2) {
                DbgPrint("Clipping rect = %li,%li to %li,%li\n",
                            arclClip[0].left,
                            arclClip[0].top,
                            arclClip[0].right,
                            arclClip[0].bottom);
            }
        #endif

        //
        // generate clipping rect variants for use in
        // GIQ line routines
        //

        arclClip[1].top    =  pco->rclBounds.left;
        arclClip[2].left   =  pco->rclBounds.left;
        arclClip[3].top    =  pco->rclBounds.left;

        arclClip[1].left   =  pco->rclBounds.top;
        arclClip[2].bottom = -pco->rclBounds.top + 1;
        arclClip[3].right  = arclClip[2].bottom;

        arclClip[1].bottom =  pco->rclBounds.right;
        arclClip[2].right  =  pco->rclBounds.right;
        arclClip[3].bottom =  pco->rclBounds.right;

        arclClip[1].right  =  pco->rclBounds.bottom;
        arclClip[2].top    = -pco->rclBounds.bottom + 1;
        arclClip[3].left   = arclClip[2].top;

        prclClip = arclClip;

    }

    //
    // subtract 1 from ulFormat to use as array index
    //

    ulFormat --;

    //
    // if the path pointer 'ppo' is NULL, then we must use the vertice
    // pointer 'pptfx':
    //

    if (ppo == NULL)
    {
        vDrawLine(pptfx,pptfx + 1,pjDst,lDelta,iSolidColor,prclClip,ulFormat);
    }
    else
        {
        //
        // Enumerate the paths and send line segments to
        // vDrawLine
        //
        //
        // start enumeration of lines
        //

        pd.flags = 0;

        ((EPATHOBJ*) ppo)->vEnumStart();

        //
        // enumerate each set
        //

        do
        {
            bMore = ((EPATHOBJ*) ppo)->bEnum(&pd);

            cptfx = pd.count;

            //
            // Should not get to here with empty path
            //

            if (cptfx == 0)
            {
                ASSERTGDI(!bMore, "Empty path record in non-empty path");
                break;
            }

            //
            // if BEGINSUBPATH, save the starting point for the
            // figure
            //

            if (pd.flags & PD_BEGINSUBPATH)
            {
                ptfxStartFigure  = *pd.pptfx;
                pptfxFirst       = pd.pptfx;
                pptfxBuf         = pd.pptfx + 1;
                cptfx--;

            } else {

                pptfxFirst       = &ptfxLast;
                pptfxBuf         = pd.pptfx;

            }


            //
            // draw line segments
            //

            if (cptfx > 0)
            {
                //
                // draw line segment
                //

                while (cptfx --) {

                    vDrawLine(pptfxFirst,pptfxBuf,pjDst,lDelta,iSolidColor,prclClip,ulFormat);

                    pptfxFirst = pptfxBuf;
                    pptfxBuf++;

                }

            }

            ptfxLast = pd.pptfx[pd.count - 1];

            if (pd.flags & PD_CLOSEFIGURE)
            {

                //
                // draw closure line segment
                //

                vDrawLine(&ptfxLast,&ptfxStartFigure,pjDst,lDelta,iSolidColor,prclClip,ulFormat);

            }

        } while (bMore);
    }
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   vDrawLine
*
* Routine Description:
*
*   This routine is passed end points of a line segment, either integer or
*   GIQ. The DDA equation for the line is determined then specific routines
*   are called to run the line DDA and draw the pixels for each bitmap format
*
*
* Arguments:
*
*   pptfx0          - end point 0
*   pptfx1          - end point 1
*   pjDst           - pointer to dst
*   lDelta          - byte scan line increment for dst
*   iSolidColor     - draw color expnaded to 32 bits
*   prclClip        - clip rectangles
*   FormatIndex     - look up for dst bitmap format
*
* Return Value:
*
*   none
*
\**************************************************************************/
VOID
vDrawLine (
    POINTFIX    *pptfx0,
    POINTFIX    *pptfx1,
    PUCHAR      pjDst,
    LONG        lDelta,
    ULONG       iSolidColor,
    PRECTL      prclClip,
    ULONG       FormatIndex
)
{
    LONG        x0;
    LONG        y0;
    LONG        x1;
    LONG        y1;
    LONG        dx;
    LONG        dy;
    ULONG       ulTmp;
    PFN_OCTANT  pfnOctant;
    LONG        DeltaDst = lDelta;
    DDALINE     DDALine;
    LONG        Reduce;

    DDALine.ulFlags = 0;

    //
    // check for GIQ lines
    //

    ulTmp = (   (ULONG)pptfx0->x |
                (ULONG)pptfx0->y |
                (ULONG)pptfx1->x |
                (ULONG)pptfx1->y
            ) & 0x0F;


    //
    // check for integer lines
    //

    if (ulTmp == 0)
    {

        //
        // check for no clipping rectangle or trivial
        // accept/reject of each line with the clipping
        // rectangle
        //

        x0 = pptfx0->x >> 4;
        y0 = pptfx0->y >> 4;
        x1 = pptfx1->x >> 4;
        y1 = pptfx1->y >> 4;
        DDALine.ptlStart.x = x0;
        DDALine.ptlStart.y = y0;

        //
        // order x0,x1 and y0,y1 for clip check and slope calculation
        //

        if (x1  < x0) {
            ULONG   Tmp = x1;
            x1 = x0;
            x0 = Tmp;
            DDALine.ulFlags |= FL_SOL_FLIP_H;
        }

        if (y1  < y0) {
            ULONG   Tmp = y1;
            y1 = y0;
            y0 = Tmp;
            DDALine.ulFlags |= FL_SOL_FLIP_V;
        }

        if (prclClip != (PRECTL) NULL)
        {

            //
            // check for a line totally outside clip rect
            //

            if  (
                 (x1 <  prclClip->left)  ||
                 (x0 >= prclClip->right) ||
                 (y1 <  prclClip->top)   ||
                 (y0 >= prclClip->bottom)
                )
            {
                //
                // line is totally clipped out
                //

                #if DBG_LINE
                    if (DbgLine >= 1) {
                        DbgPrint("Trivial reject line %li,%li to %li,%li\n",x0,y0,x1,y1);
                        DbgPrint("Clipping rect:      %li,%li to %li,%li\n",
                            prclClip->left,
                            prclClip->top,
                            prclClip->right,
                            prclClip->bottom);
                    }
                #endif

                return;

            }

            //
            // check for line that is not totally inside clip rect,
            // if not then call GIQ routine which has rectangular
            // clipping.
            //

            if
              (
               (x0 <  prclClip->left)  ||
               (x1 >= prclClip->right) ||
               (y0 <  prclClip->top)   ||
               (y1 >= prclClip->bottom)
              )
            {
                goto calc_GIQ_line;
            }

        }

        //
        // transform line to the first octant and calculate
        // terms and flags
        //

        //
        // find out if line is x major or y major
        //

        dx = x1 - x0;
        dy = y1 - y0;

        //
        // check for x-major or y-major lines
        //

        if (dx >= dy) {

            //
            // check for horizontal line
            //

            if (dy == 0)
            {

                PFN_HORZ pfnHorz = gapfnHorizontal[FormatIndex];
                pjDst = pjDst + (DDALine.ptlStart.y * lDelta);

                //
                // must check to see if end points have been
                // swapped due to exclusive line drawing
                //

                if (DDALine.ulFlags & FL_SOL_FLIP_H)
                {
                   x0++;
                   x1++;
                }

                (*pfnHorz)(pjDst,x0,x1,iSolidColor);
                return;
            }

            //
            // check for zero length
            //

            if (dx == 0) {
                return;
            }

            Reduce = -1;

            //
            // x major line
            //

            DDALine.dMajor = dx;
            DDALine.dMinor = dy;

            //
            // see if y has been flipped
            //

            if (DDALine.ulFlags & FL_SOL_FLIP_V)
            {
                DeltaDst = -DeltaDst;
                Reduce   = 0;
            }

            //
            //  Bresenham term except lErrorTerm is normally dy - dx/2 or
            //  2x which is 2*dy - dx. In this case the 2*2y is not added to
            //  the error term until the start of the inner loop routine so that
            //  the x86 can immediately use the flag register to determine the sign
            //  of the error term after the addition of 2*dy.
            //

            DDALine.cPels      = DDALine.dMajor;
            DDALine.lErrorTerm = -DDALine.dMajor;
            DDALine.dMajor     = 2 * DDALine.dMajor;
            DDALine.dMinor     = 2 * DDALine.dMinor;

            //
            // if FL_SOL_FLIP_V then lError term must be reduced by one to
            // compensate for the rounding convention
            //

            DDALine.lErrorTerm += Reduce;

        } else {

            //
            // check for 0 length
            //

            if (dy == 0) {
                return;
            }

            Reduce = -1;

            //
            // y major line, swap the meaning of dMajor and dMinor
            //

            DDALine.dMajor = dy;
            DDALine.dMinor = dx;

            DDALine.ulFlags |= FL_SOL_FLIP_D;

            DDALine.xInc = 1;

            //
            // check for flipped x
            //

            if (DDALine.ulFlags & FL_SOL_FLIP_H) {

                //
                // compensate for negative x in y major line
                //

                Reduce = 0;
            }

            //
            // + or - y
            //

            if (DDALine.ulFlags & FL_SOL_FLIP_V) {
                DeltaDst = -DeltaDst;
            }

            //
            //  Bresenham term except lErrorTerm is normally dy - dx/2 or
            //  2x which is 2*dy - dx. In this case the 2*2y is not added to
            //  the error term until the start of the inner loop routine so that
            //  the x86 can immediately use the flag register to determine the sign
            //  of the error term after the addition of 2*dy.
            //

            DDALine.cPels      = DDALine.dMajor;
            DDALine.lErrorTerm = -DDALine.dMajor;
            DDALine.dMajor     =   2 * DDALine.dMajor;
            DDALine.dMinor     =   2 * DDALine.dMinor;

            //
            // if FL_SOL_FLIP_H then lError term must be reduced by one to
            // compensate for the rounding convention
            //

            DDALine.lErrorTerm += Reduce;

        }

        #if DBG_LINE

            if (DbgLine >= 2) {
                DbgPrint("Integer line:\n");
                DbgPrint("x0 = %li, y0 = %li\n",x0,y0);
                DbgPrint("Error term  = %li\n",DDALine.lErrorTerm);
                DbgPrint("dMajor      = %li\n",DDALine.dMajor);
                DbgPrint("dMinor      = %li\n",DDALine.dMinor);
                DbgPrint("Pixel Count = %li\n",DDALine.cPels);
                DbgPrint("ulFlags     = 0x%08lx\n\n",DDALine.ulFlags);
            }

        #endif

    } else {

        calc_GIQ_line:

        //
        // caclulate GIQ parameters
        //


        if (!bGIQtoIntegerLine(pptfx0,pptfx1,prclClip,&DDALine)) {
            return;
        }

        //
        // check for 0 length
        //

        if (DDALine.cPels <= 0) {
            return;
        }

        if (DDALine.ulFlags & FL_SOL_FLIP_V)
        {
            DeltaDst = -DeltaDst;
        }

        #if DBG_LINE
            if (DbgLine >= 2) {
                DbgPrint("GIQ line:\n");
                DbgPrint("x0          = %li\n",DDALine.ptlStart.x);
                DbgPrint("y0          = %li\n",DDALine.ptlStart.y);
                DbgPrint("Error term  = %li\n",DDALine.lErrorTerm);
                DbgPrint("dMajor      = %li\n",DDALine.dMajor);
                DbgPrint("dMinor      = %li\n",DDALine.dMinor);
                DbgPrint("Pixel Count = %li\n",DDALine.cPels);
                DbgPrint("DeltaDst    = %li\n",DeltaDst);
                DbgPrint("xInc        = %li\n",DDALine.xInc);
                DbgPrint("ulFlags     = 0x%08lx\n\n",DDALine.ulFlags);
            }
        #endif
    }

    //
    // select drawing routine based on format and octant
    //

    pfnOctant = gapfnOctant[FormatIndex][DDALine.ulFlags & 0x07];

    pjDst = pjDst + (DDALine.ptlStart.y * lDelta);

    (*pfnOctant)(&DDALine,pjDst,DeltaDst,iSolidColor);

}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 8bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

#if !defined(_X86_)

VOID
vLine8Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    pjDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pjDst = (UCHAR)iSolidColor;

        if (--PixelCount == 0) {
            return;
        }

        pjDst++;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;
        }

    }

}

VOID
vLine8Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    pjDst += pDDALine->ptlStart.x;


    //
    // integer line
    //

    while (TRUE) {

        *pjDst = (UCHAR)iSolidColor;

        if (--PixelCount == 0) {
            return;
        }

        pjDst--;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }
    }
}


VOID
vLine8Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;

    //
    //  octant 1
    //
    //  y major
    //
    //  x - positive/negative
    //  y - positive
    //

    pjDst += pDDALine->ptlStart.x;


    while (TRUE) {

        *pjDst = (UCHAR)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pjDst     ++;
        }
    }
}

VOID
vLine8Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;

    //
    //  octant 5,6
    //
    //  y major
    //
    //  x - positive/negative
    //  y - negative
    //

    pjDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pjDst = (UCHAR)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pjDst     --;
        }
    }
}
#endif

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 16 bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vLine16Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    PUSHORT pusDst     = (PUSHORT)pjDst;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    pusDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pusDst = (USHORT)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pusDst++;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pusDst    = (PUSHORT)((PUCHAR)pusDst + lDeltaDst);

        }
    }
}


VOID
vLine16Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    PUSHORT pusDst     = (PUSHORT)pjDst;

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    pusDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pusDst = (USHORT)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pusDst--;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pusDst    = (PUSHORT)((PUCHAR)pusDst + lDeltaDst);

        }
    }
}


VOID
vLine16Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    PUSHORT pusDst     = (PUSHORT)pjDst;

    //
    //  octant 1
    //
    //  y major
    //
    //  x - positive
    //  y - positive/negative
    //

    pusDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pusDst = (USHORT)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pusDst    = (PUSHORT)((PUCHAR)pusDst + lDeltaDst);
        ErrorTerm += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pusDst    ++;
        }
    }
}

VOID
vLine16Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    PUSHORT pusDst     = (PUSHORT)pjDst;

    //
    //  octant 5,6
    //
    //  y major
    //
    //  x - negative
    //  y - positive/ negative
    //

    pusDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pusDst = (USHORT)iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pusDst    = (PUSHORT)((PUCHAR)pusDst + lDeltaDst);
        ErrorTerm += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pusDst    --;
        }
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 24bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vLine24Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    UCHAR   Red        = (UCHAR)iSolidColor;
    UCHAR   Green      = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue       = (UCHAR)(iSolidColor >> 16);

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    pjDst += (3 * pDDALine->ptlStart.x);

    while (TRUE) {

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += 3;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;
    }
}


VOID
vLine24Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    UCHAR   Red        = (UCHAR)iSolidColor;
    UCHAR   Green      = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue       = (UCHAR)(iSolidColor >> 16);

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    pjDst += (3 * pDDALine->ptlStart.x);

    while (TRUE) {

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst -= 3;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;
    }
}


VOID
vLine24Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    UCHAR   Red        = (UCHAR)iSolidColor;
    UCHAR   Green      = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue       = (UCHAR)(iSolidColor >> 16);

    //
    //  octant 1,2
    //
    //  y major
    //
    //  x - positive
    //  y - positive/negative
    //

    pjDst += (3*pDDALine->ptlStart.x);

    while (TRUE) {

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pjDst+=3;
        }
    }
}

VOID
vLine24Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    UCHAR   Red        = (UCHAR)iSolidColor;
    UCHAR   Green      = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue       = (UCHAR)(iSolidColor >> 16);

    //
    //  octant 5,6
    //
    //  y major
    //
    //  x - negative
    //  y - positive/negative
    //

    pjDst += (3*pDDALine->ptlStart.x);

    while (TRUE) {

        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pjDst-=3;
        }
    }
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 32 bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/

VOID
vLine32Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    PULONG  pulDst     = (PULONG)pjDst;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    pulDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pulDst = iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pulDst++;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pulDst    = (PULONG)((PUCHAR)pulDst + lDeltaDst);

        }
    }
}


VOID
vLine32Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    PULONG  pulDst     = (PULONG)pjDst;

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    pulDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pulDst = iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pulDst--;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pulDst    = (PULONG)((PUCHAR)pulDst + lDeltaDst);

        }
    }
}


VOID
vLine32Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    PULONG  pulDst     = (PULONG)pjDst;

    //
    //  octant 1
    //
    //  y major
    //
    //  x - positive/negative
    //  y - positive
    //

    pulDst += pDDALine->ptlStart.x;


    while (TRUE) {

        *pulDst = iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pulDst    = (PULONG)((PUCHAR)pulDst + lDeltaDst);
        ErrorTerm += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pulDst++;
        }

        *pulDst = iSolidColor;
    }
}

VOID
vLine32Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    PULONG  pulDst     = (PULONG)pjDst;

    //
    //  octant 5,6
    //
    //  y major
    //
    //  x - positive/negative
    //  y - negative
    //

    pulDst += pDDALine->ptlStart.x;

    while (TRUE) {

        *pulDst = iSolidColor;

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pulDst    = (PULONG)((PUCHAR)pulDst + lDeltaDst);
        ErrorTerm += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            pulDst--;
        }

        *pulDst = iSolidColor;
    }
}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 1bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/


VOID
vLine1Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    Pixel      = pDDALine->ptlStart.x;

    UCHAR Mask = (UCHAR)(0x80 >> (Pixel & 0x07));

    pjDst  = pjDst + (Pixel >> 3);

    //
    // integer line
    //

    if (iSolidColor) {

        //
        // loop for storing '1' pixels
        //

        while (TRUE) {

            *pjDst |= Mask;

            if (--PixelCount == 0) {
                return;
            }

            Mask = (UCHAR)(Mask >> 1);

            if (!(Mask)) {
                Mask = 0x80;
                pjDst++;
            }


            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;
                pjDst += lDeltaDst;

            }
        }

    } else {

        //
        // loop for storing '0' pixels
        //

        while (TRUE) {

            *pjDst &= (~Mask);

            if (--PixelCount == 0) {
                return;
            }

            Mask = (UCHAR)(Mask >> 1);

            if (!(Mask)) {
                Mask = 0x80;
                pjDst++;
            }


            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;
                pjDst     += lDeltaDst;

            }
        }
    }

}

VOID
vLine1Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;

    //
    //  octant 3,4
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    Pixel      = pDDALine->ptlStart.x;

    UCHAR Mask = (UCHAR)(0x80 >> (Pixel & 0x07));

    pjDst  = pjDst + (Pixel >> 3);

    //
    // integer line
    //

    if (iSolidColor) {

        //
        // loop for storing '1' pixels
        //

        while (TRUE) {

            *pjDst |= Mask;

            if (--PixelCount == 0) {
                return;
            }

            Mask = (UCHAR)(Mask << 1);

            if (!(Mask)) {
                Mask = 0x01;
                pjDst--;
            }

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;
                pjDst     += lDeltaDst;

            }
        }


    } else {

        while (TRUE) {

            *pjDst &= (~Mask);

            if (--PixelCount == 0) {
                return;
            }

            Mask = (UCHAR)(Mask << 1);

            if (!(Mask)) {
                Mask = 0x01;
                pjDst--;
            }

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;
                pjDst     += lDeltaDst;

            }
        }
    }
}

VOID
vLine1Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;

    //
    //  octant 1,6
    //
    //  y major
    //
    //  x - positive
    //  y - positive/negative
    //

    Pixel      = pDDALine->ptlStart.x;

    UCHAR Mask = (UCHAR)(0x80 >> (Pixel & 0x07));

    pjDst  = pjDst + (Pixel >> 3);

    //
    // integer line
    //

    if (iSolidColor) {

        //
        // loop for storing '1' pixels
        //

        while (TRUE) {

            *pjDst |= Mask;

            if (--PixelCount == 0) {
                return;
            }

            pjDst     += lDeltaDst;

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;

                Mask = (UCHAR)(Mask >> 1);

                if (!(Mask)) {
                    Mask = 0x80;
                    pjDst++;
                }

            }
        }


    } else {

        while (TRUE) {

            *pjDst &= (~Mask);

            if (--PixelCount == 0) {
                return;
            }

            pjDst     += lDeltaDst;

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;

                Mask = (UCHAR)(Mask >> 1);

                if (!(Mask)) {
                    Mask = 0x80;
                    pjDst++;
                }

            }
        }
    }

}

VOID
vLine1Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    ULONG   Pixel;

    //
    //  octant 2,5
    //
    //  y major
    //
    //  x - negative
    //  y - negative/positive
    //

    Pixel      = pDDALine->ptlStart.x;

    UCHAR Mask = (UCHAR)(0x80 >> (Pixel & 0x07));

    pjDst  = pjDst + (Pixel >> 3);

    //
    // integer line
    //

    if (iSolidColor) {

        //
        // loop for storing '1' pixels
        //

        while (TRUE) {

            *pjDst |= Mask;

            if (--PixelCount == 0) {
                return;
            }

            pjDst     += lDeltaDst;

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;

                Mask = (UCHAR)(Mask << 1);

                if (!(Mask)) {
                    Mask = 0x01;
                    pjDst--;
                }

            }
        }


    } else {

        while (TRUE) {

            *pjDst &= (~Mask);

            if (--PixelCount == 0) {
                return;
            }

            pjDst     += lDeltaDst;

            ErrorTerm += dN;

            if (ErrorTerm >= 0){

                ErrorTerm -= dM;

                Mask = (UCHAR)(Mask << 1);

                if (!(Mask)) {
                    Mask = 0x01;
                    pjDst--;
                }

            }
        }
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   Inner loop DDA line drawing routines for 4bpp
*
* Routine Description:
*
*   4 dda routines for line drawing in each octant for each resolution
*
*
* Arguments:
*
*    pDDALine        -   dda parameters
*    pjDst           -   Destination line address
*    lDeltaDst       -   Destination address scan line increment (bytes)
*    iSolidColor     -   Solid color for line
*
* Return Value:
*
*   VOID
*
\**************************************************************************/


VOID
vLine4Octant07(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;
    PUCHAR  PixelAddr;


    iSolidColor &= 0x0f;
    iSolidColor |= iSolidColor << 4;

    //
    //  octant 0
    //
    //  x major
    //
    //  x - positive
    //  y - positive/negative
    //

    Pixel     = pDDALine->ptlStart.x;

    while (TRUE) {

        PixelAddr = pjDst + (Pixel >> 1);

        *PixelAddr = (UCHAR)((*PixelAddr & PixelLineMask4[Pixel & 1]) |
                             (iSolidColor & ~PixelLineMask4[Pixel & 1]));

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        Pixel++;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }
    }
}


VOID
vLine4Octant34(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    ULONG   Pixel;
    PUCHAR  PixelAddr;

    iSolidColor &= 0x0f;
    iSolidColor |= iSolidColor << 4;

    //
    //  octant 3
    //
    //  x major
    //
    //  x - negative
    //  y - positive/negative
    //

    Pixel     = pDDALine->ptlStart.x;

    while (TRUE) {

        PixelAddr = pjDst + (Pixel >> 1);

        *PixelAddr = (UCHAR)((*PixelAddr & PixelLineMask4[Pixel & 1]) |
                             (iSolidColor & ~PixelLineMask4[Pixel & 1]));

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        Pixel--;
        ErrorTerm += dN;

        if (ErrorTerm >= 0){

            ErrorTerm -= dM;
            pjDst     += lDeltaDst;

        }
    }

}


VOID
vLine4Octant16(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    ULONG   Pixel;
    PUCHAR  PixelAddr;

    iSolidColor &= 0x0f;
    iSolidColor |= iSolidColor << 4;

    //
    //  octant 1,6
    //
    //  y major
    //
    //  x - positive
    //  y - positive/negative
    //

    Pixel     = pDDALine->ptlStart.x;

    while (TRUE) {

        PixelAddr = pjDst + (Pixel >> 1);
        *PixelAddr = (UCHAR)((*PixelAddr & PixelLineMask4[Pixel & 1]) |
                             (iSolidColor & ~PixelLineMask4[Pixel & 1]));

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            Pixel     ++;
        }
    }
}

VOID
vLine4Octant25(
    PDDALINE pDDALine,
    PUCHAR   pjDst,
    LONG     lDeltaDst,
    ULONG    iSolidColor
)
{

    LONG    ErrorTerm  = pDDALine->lErrorTerm;
    LONG    dM         = pDDALine->dMajor;
    LONG    dN         = pDDALine->dMinor;
    LONG    PixelCount = pDDALine->cPels;
    LONG    xInc       = pDDALine->xInc;
    ULONG   Pixel;
    PUCHAR  PixelAddr;

    iSolidColor &= 0x0f;
    iSolidColor |= iSolidColor << 4;

    //
    //  octant 2,5
    //
    //  y major
    //
    //  x - negative
    //  y - psoitive\negative
    //

    Pixel     = pDDALine->ptlStart.x;

    while (TRUE) {

        PixelAddr = pjDst + (Pixel >> 1);
        *PixelAddr = (UCHAR)((*PixelAddr & PixelLineMask4[Pixel & 1]) |
                             (iSolidColor & ~PixelLineMask4[Pixel & 1]));

        //
        // integer line
        //

        if (--PixelCount == 0) {
            return;
        }

        pjDst += lDeltaDst;
        ErrorTerm   += dN;

        if (ErrorTerm >= 0){
            ErrorTerm -= dM;
            Pixel     --;
        }
    }

}

/******************************Public*Routine******************************\
*
* Routine Name
*
*   vHorizontalLineN
*
* Routine Description:
*
*   Accelerator for horizontal lines
*
* Arguments:
*
*   pjDst       - Scan line dst address
*   x0          - Starting pixel location
*   x1          - Ending pixel location (exclusive)
*   iSolidColor - Solid Color replicated to 32 bits if needed
*
* Return Value:
*
*   VOID
*
\**************************************************************************/


VOID
vHorizontalLine1(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    ULONG  Count;
    ULONG  Alignment;

    //
    // count = number of pixels to write, make sure it is not 0
    //

    Count = x1 - x0;

    if (Count) {

        pjDst += (x0 >> 3);

        Alignment = x0 & 0x07;

        //
        // alignment Start bits
        //

        if ((Alignment) && ((ULONG)Count >= (8 - Alignment)))
        {
            //
            // partial byte
            //

            *pjDst = (UCHAR)((*pjDst & (~(0xFF >> Alignment))) |
                             (iSolidColor & (0xFF >> Alignment)));

            pjDst ++;
            Count -= ( 8 - Alignment);
            Alignment = 0;

        }

        //
        // byte loop
        //

        if (Alignment == 0) {

            //
            // full byte stores
            //

            ULONG   NumBytes = Count >> 3;

            if (NumBytes > 0) {
                RtlFillMemory((PVOID)pjDst,NumBytes,(UCHAR)iSolidColor);
                pjDst += NumBytes;
                Count = (Count & 0x07);
            }

            //
            // last store
            //

            if (Count > 0) {
                *pjDst = (UCHAR)((*pjDst & (0xFF >> Count)) |
                                 (iSolidColor & (~(0xFF >> Count))));
            }

            return;
        }

        //
        // do whats left, partial of 1 byte with
        // start bit = alignment, number of bits = Count
        //
        //
        //   bit
        //  
        //  76543210
        //  
        //
        //   pixel
        //  
        //  01234567
        //  

        {
            UCHAR DstMask = (UCHAR)(0xff >> Alignment);
            UCHAR AndMask = (UCHAR)(0xff << (8 - (Count + Alignment)));

            DstMask &= AndMask;

            *pjDst = (UCHAR)((*pjDst & (~DstMask)) | (iSolidColor & DstMask));

        }
    }

}

VOID
vHorizontalLine4(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    ULONG  Count;
    ULONG  Alignment;
    ULONG  NumBytes;


    Count = x1 - x0;

    if (Count) {

        pjDst += (x0 >> 1);

        //
        // alignment Start nibble
        //

        Alignment = x0 & 0x01;

        if (Alignment)
        {
            *pjDst = (UCHAR)((*pjDst      & 0xf0) |
                             (iSolidColor & 0x0f));
            Count--;
            pjDst++;
        }

        //
        // aligned to byte boundary
        //

        NumBytes = Count >> 1;

        if (NumBytes) {

            RtlFillMemory((PVOID)pjDst,NumBytes,(BYTE)iSolidColor);

            pjDst += NumBytes;
            Count = Count & 0x01;
        }

        //
        // end alignment if needed
        //

        if (Count) {
            *pjDst = (UCHAR)((*pjDst      & 0x0f) |
                             (iSolidColor & 0xf0));
        }

    }
}

VOID
vHorizontalLine8(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    ULONG   Count;
    UCHAR   Align;

    //
    // increment pjDst to x0 address
    //

    pjDst += x0;

    //
    // if byte count is less then 7, then just quickly do
    // the bytes
    //

    Count = x1 - x0;

    if (Count <= 6) {

        while (Count--) {
            *pjDst++ = (UCHAR)iSolidColor;
        }

        return;
    }

    //
    // large scan line that at least covers 1 full DWORD,
    // first do partial bytes if needed
    //

    //
    // do partial bytes, count is gaurenteed to be
    // greater than max of 3 alignment bytes
    //

    Align = (UCHAR)(x0 & 0x03);

    switch (Align) {
    case 1:
        *pjDst++ = (UCHAR)iSolidColor;
        Count--;
    case 2:
        *(PUSHORT)pjDst = (USHORT)iSolidColor;
        pjDst += 2;
        Count -= 2;
        break;
    case 3:
        *pjDst++ = (UCHAR)iSolidColor;
        Count--;
    }

    ULONG NumBytes = Count & (~0x03);

    //
    // fill Dwords
    //

    RtlFillMemoryUlong((PVOID)pjDst,NumBytes,iSolidColor);
    pjDst += NumBytes;

    //
    // fill last partial bytes
    //

    switch (Count & 0x03)  {
    case 1:
        *pjDst = (UCHAR)iSolidColor;
        break;
    case 2:
        *(PUSHORT)pjDst = (USHORT)iSolidColor;
        break;
    case 3:
        *(PUSHORT)pjDst = (USHORT)iSolidColor;
        *(pjDst+2) = (UCHAR)iSolidColor;
    }

}

VOID
vHorizontalLine16(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    PUSHORT pusDst = (PUSHORT)pjDst + x0;
    ULONG   Count = x1 - x0;

    if (Count) {

        //
        // do starting alignment
        //

        if (x0 & 0x01) {
            *pusDst++ = (USHORT)iSolidColor;
            Count--;
        }

        //
        // fill dwords
        //

        ULONG NumDwords = Count >> 1;

        if (NumDwords) {
            RtlFillMemoryUlong((PVOID)pusDst,NumDwords << 2,iSolidColor);
        }

        //
        // fill last 16 if needed
        //

        if (Count & 0x01) {

            //
            //  add Number of USHORTS stored in RtlFillMemoryUlong to pusDst
            //  then store final USHORT
            //

            pusDst += NumDwords << 1;

            *pusDst = (USHORT)iSolidColor;
        }
    }
}

VOID
vHorizontalLine24(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{
    UCHAR   Red   = (UCHAR)iSolidColor;
    UCHAR   Green = (UCHAR)(iSolidColor >> 8);
    UCHAR   Blue  = (UCHAR)(iSolidColor >> 16);
    PUCHAR  pjEnd = pjDst + 3*x1;

    pjDst += 3*x0;

    while (pjDst < pjEnd) {
        *pjDst     = Red;
        *(pjDst+1) = Green;
        *(pjDst+2) = Blue;
        pjDst += 3;
    }
}

VOID
vHorizontalLine32(
    PUCHAR  pjDst,
    LONG    x0,
    LONG    x1,
    ULONG   iSolidColor)
{

    //
    // incremnet pjDst x0 DWORDs
    //

    pjDst += (x0 << 2);

    //
    // fill
    //

    if (x1 != x0) {
        RtlFillMemoryUlong((PVOID)pjDst,(x1 - x0) << 2,iSolidColor);
    }
}


/******************************Public*Routine******************************\
*
* Routine Name
*
*   bGIQtoIntegerLine
*
* Routine Description:
*
*   This routine takes GIQ endpoints and calculates the correct integer
*   endpoints, error term and flags.
*
* Arguments:
*
*   pptfxStart  -   GIQ point 0
*   pptfxEnd    -   GIQ point 1
*   prclClip    -   clip rectangles
*   pDDALine    -   Interger line params
*
* Return Value:
*
*   True if this line can be drawn with 32 bit arithmatic and
*   all params are calculated, otherwise false
*
\**************************************************************************/

#define HW_X_ROUND_DOWN     0x0100L     // x = 1/2 rounds down in value
#define HW_Y_ROUND_DOWN     0x0200L     // y = 1/2 rounds down in value

FLONG gaflHardwareRound[] = {
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        |
    HW_X_ROUND_DOWN | HW_Y_ROUND_DOWN,  //           |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    //           |        | FLIP_V |
    HW_Y_ROUND_DOWN,                    //           |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    //           | FLIP_H |        |
    HW_X_ROUND_DOWN,                    //           | FLIP_H |        | FLIP_D
    0,                                  //           | FLIP_H | FLIP_V |
    0,                                  //           | FLIP_H | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE |        |        |
    0xffffffff,                         // SLOPE_ONE |        |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE |        | FLIP_V |
    0xffffffff,                         // SLOPE_ONE |        | FLIP_V | FLIP_D
    HW_Y_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H |        |
    0xffffffff,                         // SLOPE_ONE | FLIP_H |        | FLIP_D
    HW_X_ROUND_DOWN,                    // SLOPE_ONE | FLIP_H | FLIP_V |
    0xffffffff                          // SLOPE_ONE | FLIP_H | FLIP_V | FLIP_D
};

BOOL bGIQtoIntegerLine(
    POINTFIX* pptfxStart,
    POINTFIX* pptfxEnd,
    PRECTL    prclClip,
    DDALINE*  pDDALine)

{
    FLONG fl;    // Various flags
    ULONG M0;    // Normalized fractional unit x start coordinate (0 <= M0 < F)
    ULONG N0;    // Normalized fractional unit y start coordinate (0 <= N0 < F)
    ULONG M1;    // Normalized fractional unit x end coordinate (0 <= M1 < F)
    ULONG N1;    // Normalized fractional unit x end coordinate (0 <= N1 < F)
    ULONG dM;    // Normalized fractional unit x-delta (0 <= dM)
    ULONG dN;    // Normalized fractional unit y-delta (0 <= dN <= dM)
    LONG  x;     // Normalized x coordinate of origin
    LONG  y;     // Normalized y coordinate of origin
    LONG  x0;    // Normalized x offset from origin to start Pixel (inclusive)
    LONG  y0;    // Normalized y offset from origin to start Pixel (inclusive)
    LONG  x1;    // Normalized x offset from origin to end Pixel (inclusive)
    LONG  lGamma; // Possibly overflowing Bresenham error term at origin
    LONGLONG eqGamma;// Non-overflowing Bresenham error term at origin
    BOOL  bReturn = FALSE;


/***********************************************************************\
* Normalize line to the first octant.
\***********************************************************************/


    #if DBG_LINE

        if (DbgLine >= 2) {
            DbgPrint("\nCalculate GIQ parameters for line:\n");
            DbgPrint("pptfxStart    = %li.%li, %li.%li\n",
                            pptfxStart->x >> 4,
                            pptfxStart->x & 0x0f,
                            pptfxStart->y >> 4,
                            pptfxStart->y & 0x0f);

            DbgPrint("pptxEnd      = %li.%li, %li.%li\n\n",
                            pptfxEnd->x >> 4,
                            pptfxEnd->x & 0x0f,
                            pptfxEnd->y >> 4,
                            pptfxEnd->y & 0x0f);
        }

    #endif

    fl = 0;

    M0 = pptfxStart->x;
    dM = pptfxEnd->x;

    if ((LONG) dM < (LONG) M0)
    {
        //
        // Line runs from right to left, so flip across x = 0:
        //

        M0 = -(LONG) M0;
        dM = -(LONG) dM;
        fl |= FL_SOL_FLIP_H;
    }

    //
    // Compute the delta dx.  The DDI says we can never have a valid delta
    // with a magnitude more than 2^31 - 1, but the engine never actually
    // checks its transforms.  Check for that case and simply refuse to draw
    // the line:
    //

    dM -= M0;
    if ((LONG) dM < 0)
    {
        goto GIQEnd;
    }

    N0 = pptfxStart->y;
    dN = pptfxEnd->y;

    if ((LONG) dN < (LONG) N0)
    {

        //
        // Line runs from bottom to top, so flip across y = 0
        //

        N0 = -(LONG) N0;
        dN = -(LONG) dN;
        fl |= FL_SOL_FLIP_V;
    }

    //
    // Compute the delta dy
    //

    dN -= N0;
    if ((LONG) dN < 0)
    {
        goto GIQEnd;
    }

    //
    // check for y-major lines and lines with
    // slope = 1
    //

    if (dN >= dM)
    {
        if (dN == dM)
        {

            //
            // Have to special case slopes of one:
            //

            fl |= FL_SOL_FLIP_SLOPE_ONE;
        }
        else
        {
            //
            // Since line has slope greater than 1, flip across x = y:
            //

            register ULONG ulTmp;
            ulTmp = dM; dM = dN; dN = ulTmp;
            ulTmp = M0; M0 = N0; N0 = ulTmp;
            fl |= FL_SOL_FLIP_D;
        }
    }

    //
    //  look up rounding for this line from the table
    //

    fl |= gaflHardwareRound[fl];

    //
    //  Calculate the error term at Pixel 0
    //

    x = LFLOOR((LONG) M0);
    y = LFLOOR((LONG) N0);


    M0 = FXFRAC(M0);
    N0 = FXFRAC(N0);

    #if DBG_LINE

        if (DbgLine >= 2) {
            DbgPrint("Calc x  = %li\n",x);
            DbgPrint("Calc y  = %li\n",y);
            DbgPrint("Calc M0 = %li\n",M0);
            DbgPrint("Calc N0 = %li\n",N0);
        }

    #endif

    //
    // Calculate the remainder term [ dM * (N0 + F/2) - M0 * dN ].  Note
    // that M0 and N0 have at most 4 bits of significance (and if the
    // arguments are properly ordered, on a 486 each multiply would be no
    // more than 13 cycles):
    //

    //
    // For the sake of speed, we're only going to do 32-bit multiplies
    // in this routine.  If the line is long enough though, we may
    // need 38 bits for this calculation.  Since at this point
    // dM >= dN >= 0, and 0 <= N0 < 16, we'll just need to have 6 bits
    // unused in 'dM':
    //

    if (dM <= (LONG_MAX >> 6))
    {
        lGamma = (N0 + F/2) * dM - M0 * dN;

        if (fl & HW_Y_ROUND_DOWN)
            lGamma--;

        lGamma >>= FLOG2;

        eqGamma = lGamma;
    }
    else
    {
        LONGLONG eq;

        //
        // Ugh, use safe 64-bit multiply code (cut and pasted from
        // 'engline.cxx'):
        //

        eqGamma = Int32x32To64(N0 + F/2, dM);
        eq      = Int32x32To64(M0, dN);

        eqGamma -= eq;

        if (fl & FL_V_ROUND_DOWN)
            eqGamma -= 1;              // Adjust so y = 1/2 rounds down

        eqGamma >>= FLOG2;
    }

    //
    //  Figure out which Pixels are at the ends of the line.
    //

    //
    // The toughest part of GIQ is determining the start and end pels.
    //
    // Our approach here is to calculate x0 and x1 (the inclusive start
    // and end columns of the line respectively, relative to our normalized
    // origin).  Then x1 - x0 + 1 is the number of pels in the line.  The
    // start point is easily calculated by plugging x0 into our line equation
    // (which takes care of whether y = 1/2 rounds up or down in value)
    // getting y0, and then undoing the normalizing flips to get back
    // into device space.
    //
    // We look at the fractional parts of the coordinates of the start and
    // end points, and call them (M0, N0) and (M1, N1) respectively, where
    // 0 <= M0, N0, M1, N1 < 16.  We plot (M0, N0) on the following grid
    // to determine x0:
    //
    //   +-----------------------> +x
    //   |
    //   | 0                     1
    //   |     0123456789abcdef
    //   |
    //   |   0 ........?xxxxxxx
    //   |   1 ..........xxxxxx
    //   |   2 ...........xxxxx
    //   |   3 ............xxxx
    //   |   4 .............xxx
    //   |   5 ..............xx
    //   |   6 ...............x
    //   |   7 ................
    //   |   8 ................
    //   |   9 ......**........
    //   |   a ........****...x
    //   |   b ............****
    //   |   c .............xxx****
    //   |   d ............xxxx    ****
    //   |   e ...........xxxxx        ****
    //   |   f ..........xxxxxx
    //   |
    //   | 2                     3
    //   v
    //
    //   +y
    //
    // This grid accounts for the appropriate rounding of GIQ and last-pel
    // exclusion.  If (M0, N0) lands on an 'x', x0 = 2.  If (M0, N0) lands
    // on a '.', x0 = 1.  If (M0, N0) lands on a '?', x0 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // For the end point, if (M1, N1) lands on an 'x', x1 =
    // floor((M0 + dM) / 16) + 1.  If (M1, N1) lands on a '.', x1 =
    // floor((M0 + dM)).  If (M1, N1) lands on a '?', x1 rounds up or down,
    // depending on what flips have been done to normalize the line.
    //
    // Lines of exactly slope one require a special case for both the start
    // and end.  For example, if the line ends such that (M1, N1) is (9, 1),
    // the line has gone exactly through (8, 0) -- which may be considered
    // to be part of 'x' because of rounding!  So slopes of exactly slope
    // one going through (8, 0) must also be considered as belonging in 'x'
    // when an x value of 1/2 is supposed to round up in value.
    //
    //
    // Calculate x0, x1:
    //

    N1 = FXFRAC(N0 + dN);
    M1 = FXFRAC(M0 + dM);

    x1 = LFLOOR(M0 + dM);

    //
    // Line runs left-to-right
    //
    //
    // Compute x1
    //

    x1--;
    if (M1 > 0)
    {
        if (N1 == 0)
        {
            if (LROUND(M1, fl & HW_X_ROUND_DOWN))
                x1++;
        }
        else if (ABS((LONG) (N1 - F/2)) <= (LONG) M1)
        {
            x1++;
        }
    }

    if ((fl & (FL_SOL_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
           == (FL_SOL_FLIP_SLOPE_ONE | HW_X_ROUND_DOWN))
    {

        //
        // Have to special-case diagonal lines going through our
        // the point exactly equidistant between two horizontal
        // Pixels, if we're supposed to round x=1/2 down:
        //

        if ((M1 > 0) && (N1 == M1 + 8))
            x1--;

        if ((M0 > 0) && (N0 == M0 + 8))
        {
            x0 = 0;
            goto left_to_right_compute_y0;
        }
    }

    //
    // Compute x0:
    //

    x0 = 0;
    if (M0 > 0)
    {
        if (N0 == 0)
        {
            if (LROUND(M0, fl & HW_X_ROUND_DOWN))
                x0 = 1;
        }
        else if (ABS((LONG) (N0 - F/2)) <= (LONG) M0)
        {
            x0 = 1;
        }
    }

left_to_right_compute_y0:


    //**********************************************************************
    // Calculate the start Pixel.
    //***********************************************************************

    //
    // We now compute y0 and adjust the error term.  We know x0, and we know
    // the current formula for the Pixels to be lit on the line:
    //
    //                     dN * x + eqGamma
    //       y(x) = floor( ---------------- )
    //                           dM
    //
    // The remainder of this expression is the new error term at (x0, y0).
    // Since x0 is going to be either 0 or 1, we don't actually have to do a
    // multiply or divide to compute y0.  Finally, we subtract dM from the
    // new error term so that it is in the range [-dM, 0).
    //

    y0 = 0;

    if ((eqGamma >= 0) &&
        (eqGamma >= (dM - (dN & (-(LONG) x0)))))
    {
        y0 = 1;
    }

    //
    // check to see if the line is NULL, this should only happen
    // with a line of slope = 1.
    //

    if (x1 < x0) {
        pDDALine->cPels = 0;
        bReturn = TRUE;
        goto GIQEnd;
    }


    //*******************************************************************
    //
    // Must perform rectangular clipping
    //
    //*******************************************************************

    if (prclClip != (PRECTL) NULL)
    {
        ULONG y1;
        LONG  xRight;
        LONG  xLeft;
        LONG  yBottom;
        LONG  yTop;
        LONGLONG euq;
        LONGLONG eq;
        LONGLONG eqBeta;
        RECTL rclClip;

        //
        // Note that y0 and y1 are actually the lower and upper bounds,
        // respectively, of the y coordinates of the line (the line may
        // have actually shrunk due to first/last pel clipping).
        //
        // Also note that x0, y0 are not necessarily zero.
        //

        RECTL* prcl = &prclClip[(fl & FL_SOL_RECTLCLIP_MASK)];

        //
        // take flip_h into account
        //

        if (fl & FL_SOL_FLIP_H) {

            if (fl & FL_SOL_FLIP_D) {

                rclClip.top    = -prcl->bottom + 1;
                rclClip.bottom = -prcl->top    + 1;
                rclClip.left   = prcl->left;
                rclClip.right  = prcl->right;

            } else {

                rclClip.left   = -prcl->right + 1;
                rclClip.right  = -prcl->left  + 1;
                rclClip.top    = prcl->top;
                rclClip.bottom = prcl->bottom;

            }

        } else {

            rclClip.left   = prcl->left;
            rclClip.right  = prcl->right;
            rclClip.top    = prcl->top;
            rclClip.bottom = prcl->bottom;

        }

        //
        // Normalize to the same point we've normalized for the DDA
        // calculations:
        //

        xRight  = rclClip.right  - x;
        xLeft   = rclClip.left   - x;
        yBottom = rclClip.bottom - y;
        yTop    = rclClip.top    - y;

        #if DBG_LINE

            if (DbgLine >= 2) {

                DbgPrint("Clipping line to rect %li,%li to %li,%li\n",
                                rclClip.left,
                                rclClip.top,
                                rclClip.right,
                                rclClip.bottom);

                DbgPrint("Clipping Parameters:  xLeft %li xRight %li yBottom %li yTop %li\n",
                                xLeft,
                                xRight,
                                yBottom,
                                yTop);


                DbgPrint("normalized line before clip,  x = %li, y = %li, x0 = %li, x1 = %li,  y0 = %li\n",
                                x,y,x0,x1,y0);

                DbgPrint("Line Params:  dM = %li,   dN = %li,   eqGamma = %lx\n",dM,dN,(ULONG)eqGamma);
            }

        #endif

        if (yBottom <= (LONG) y0 ||
            xRight  <= (LONG) x0 ||
            xLeft   >  (LONG) x1)
        {
            Totally_Clipped:

            #if DBG_LINE

                if (DbgLine >= 2) {
                    DbgPrint("Line is totally clipped\n");
                }

            #endif

            pDDALine->cPels = 0;
            bReturn = TRUE;
            goto GIQEnd;
        }

        if ((LONG) x1 >= xRight)
        {
            x1 = xRight - 1;

            #if DBG_LINE

                if (DbgLine >= 2) {
                    DbgPrint("Line clip x1 to %li\n",x1);
                }

            #endif
        }

        //
        // We have to know the correct y1, which we haven't bothered to
        // calculate up until now.  This multiply and divide is quite
        // expensive; we could replace it with code similar to that which
        // we used for computing y0.
        //
        // The reason why we need the actual value, and not an upper
        // bounds guess like y1 = LFLOOR(dM) + 2 is that we have to be
        // careful when calculating x(y) that y0 <= y <= y1, otherwise
        // we can overflow on the divide (which, needless to say, is very
        // bad).
        //

        eqBeta = ~eqGamma;
        euq = Int32x32To64(x1, dN);
        euq += eqGamma;

        y1 = DIV(euq, dM);

        #if DBG_LINE

            if (DbgLine >= 2) {

                DbgPrint("Clipping: calculated y1 = %li   eqBeta = 0x%lx 0x%lx\n",y1,(LONG)(eqBeta>>32),(ULONG)eqBeta);

            }

        #endif

        //
        // check for y1 less than the top of the clip rect
        //

        if (yTop > (LONG) y1)
            goto Totally_Clipped;

        //
        // check for y1 > the bottom of the clip rect, clip if true
        //

        if (yBottom <= (LONG) y1)
        {
            y1 = yBottom;

            euq = Int32x32To64(y1, dM);
            euq += eqBeta;
            x1 = DIV(euq,dN);

            #if DBG_LINE

                if (DbgLine >= 2) {

                    DbgPrint("Clipped y1 to %li, x1 = %li\n",y1,x1);

                }

            #endif
        }

        //
        // At this point, we've taken care of calculating the intercepts
        // with the right and bottom edges.  Now we work on the left and
        // top edges:
        //

        if (xLeft > (LONG) x0)
        {
            x0 = xLeft;

            euq = Int32x32To64(x0, dN);
            euq += eqGamma;
            y0 = DIV(euq, dM);

            if (yBottom <= (LONG) y0)
                goto Totally_Clipped;

            #if DBG_LINE

                if (DbgLine >= 2) {

                    DbgPrint("Clipped x0 to %li, y0 = %li\n",x0,y0);

                }

            #endif

        }

        //
        // check for y0 less than the top of the clip rect, clip if true
        //

        if (yTop > (LONG) y0)
        {
            y0 = yTop;

            euq = Int32x32To64(y0, dM);
            euq += eqBeta;
            x0 = DIV(euq, dN) + 1;

            if (xRight <= (LONG) x0)
                goto Totally_Clipped;

            #if DBG_LINE

                if (DbgLine >= 2) {

                    DbgPrint("Clipped y0 to %li, x0 = %li\n",y0,x0);

                }

            #endif
        }

        euq = Int32x32To64(x0,dN);
        eq  = Int32x32To64(y0,dM);

        euq -= eq;

        eqGamma += euq;

        eqGamma -= dM;

        #if DBG_LINE

            if (DbgLine >= 2) {
                DbgPrint("Clipped  line: x0 = %li,  x1 = %li,  y0 = %li, y1 = %li\n",
                                x0,
                                x1,
                                y0,
                                y1);

                DbgPrint("eqGamma = %lx\n",eqGamma);
            }

            if (x0 > x1) {
                DbgPrint("Clip Error: x0 > x1\n");

                DbgPrint(" pptxStart    = %li.%li, %li.%li\n",
                                pptfxStart->x >> 4,
                                pptfxStart->x & 0x0f,
                                pptfxStart->y >> 4,
                                pptfxStart->y & 0x0f);

                DbgPrint(" pptxEnd      = %li.%li, %li.%li\n",
                                pptfxEnd->x >> 4,
                                pptfxEnd->x & 0x0f,
                                pptfxEnd->y >> 4,
                                pptfxEnd->y & 0x0f);


                DbgPrint("  prclClip = 0x%lx\n",prclClip);

                DbgPrint("  x0    = %li\n",x0);
                DbgPrint("  y0    = %li\n",y0);
                DbgPrint("  x1    = %li\n",x1);
                DbgPrint("  y1    = %li\n",y1);

                DbgPrint("  dM    = %li\n",dM);
                DbgPrint("  dN    = %li\n",dN);

                DbgPrint("  lGamma = %li\n",lGamma);

                DbgPrint("  Clipping line to rect %li,%li to %li,%li\n",
                                rclClip.left,
                                rclClip.top,
                                rclClip.right,
                                rclClip.bottom);

            }



        #endif



        ASSERTGDI(x0 <= x1, "Improper rectangle clip");

    } else {

        //
        // adjust lGamma
        //

        eqGamma += (dN & (-x0));
        eqGamma -= dM;

        if (eqGamma >= 0)
        {
            eqGamma -= dM;
        }
    }


    //
    // END of simple clipping
    //

    //
    // Undo our flips to get the start coordinate:
    //

    x += x0;
    y += y0;

    if (fl & FL_SOL_FLIP_D)
    {
        register LONG lTmp;
        lTmp = x; x = y; y = lTmp;
    }

    if (fl & FL_SOL_FLIP_V)
    {
        y = -y;
    }

    if (fl & FL_SOL_FLIP_H)
    {
        x = -x;
    }

/***********************************************************************\
* Return the Bresenham terms:
\***********************************************************************/

    //
    // check values
    //

    pDDALine->ulFlags    = fl;
    pDDALine->ptlStart.x = x;
    pDDALine->ptlStart.y = y;
    pDDALine->cPels      = x1 - x0 + 1;  // NOTE: You'll have to check if cPels <= 0!
    pDDALine->dMajor     = dM;
    pDDALine->dMinor     = dN;
    pDDALine->lErrorTerm = (LONG) eqGamma;
    pDDALine->xInc       = 1;
    bReturn = TRUE;

    //
    // end routine
    //

GIQEnd:

    return(bReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\srcalign.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcalign.cxx
*
* This contains code that can be used to do source aligned reads. This
* will improve performance when reading from non cached video memory resisdent
* surfaces.
*
* Created: 04-May-1999
* Author: Pravin Santiago pravins. 
*
* Copyright (c) 1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

void vSrcAlignCopyMemory(PBYTE pjDst, PBYTE pjSrc, ULONG c)
{
    // If overlap use RtlMoveMemory()
    if(pjSrc < pjDst && pjDst < pjSrc + c)
    {
        RtlMoveMemory((PVOID)pjDst,(PVOID)pjSrc,c);
    }
    else
    {
        while(c != 0) 
        {
            // Do correctly aligned data reads from the source while
            // maximizing the number of QuadWord reads.

            if((((ULONG_PTR)pjSrc & 7) == 0) && (c >= 8)) // 8 byte aligned
            {
                // Maximize QuadWord reads of pjSrc. 
#if i386
                if(HasMMX)
                {
                    __asm
                    {
                        mov ecx, c 
                        mov esi, pjSrc
                        mov edi, pjDst
                    nextf:
                        movq mm0, [esi]
                        movq [edi], mm0
                        add esi, 8
                        add edi, 8
                        sub ecx, 8
                        cmp ecx, 8
                        jae nextf
                        mov pjSrc, esi
                        mov pjDst, edi
                        mov c,     ecx
                    }
                }
                else
#endif
                {
                    do
                    {
                        *(ULONGLONG UNALIGNED*)pjDst = *(ULONGLONG *)pjSrc;
                        pjDst += 8; pjSrc += 8;
                        c -= 8;
                    } while(c >= 8);
                }
            }
            else if((((ULONG_PTR)pjSrc & 3) == 0) && (c >= 4))// 4 byte aligned
            {
                *(ULONG UNALIGNED*)pjDst = *(ULONG*)pjSrc;
                pjDst += 4; pjSrc += 4;
                c -= 4;
            }
            else if((((ULONG_PTR)pjSrc & 1) == 0) && (c >= 2))// 2 byte aligned
            {
                *(USHORT UNALIGNED*)pjDst = *(USHORT*)pjSrc;
                pjDst += 2; pjSrc += 2;
                c -= 2;
            }
            else // odd byte aligned
            {
                *pjDst++ = *pjSrc++;
                c--;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\srcblt1.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt1.cxx
*
* This contains the bitmap simulation functions that blt to a 1 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*******************Public*Routine*****************\
* vSrcCopyS1D1LtoR
*
* There are three main loops in this function.
*
* The first loop deals with the full bytes part of
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the left most strip
* of the partial bytes.
*
* The third loop deals with the right most strip
* of the partial bytes.
*
* Special case:
* when the Src and Dst are aligned, we enter
* a different loop to use rltcopymem to avoid
* shifting
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
*
\**************************************************/


VOID vSrcCopyS1D1LtoR(PBLTINFO psb)
{
    BYTE  jSrc;     // holds a source byte
    BYTE  jDst;     // holds a dest byte
    INT   iSrc;     // bit position in the first Src byte
    INT   iDst;     // bit position in the first Dst byte
    INT   ixlate;   // set flag to indicate if it is
                    // source invert, source copy or
                    // all 0's or all 1's
    PBYTE pjDst;    // pointer to the Src bytes
    PBYTE pjSrc;    // pointer to the Dst bytes
    PBYTE pjLDst;   // pointer to the last Dst byte
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;       // number of pixels
    LONG  cx;       // number of rows
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    BYTE  jMask;    // Masks used for shifting
    BYTE  jEndMask;
    LONG  cFullBytes;  //number of full bytes to deal with
    BOOL  bNextByte;
    LONG  xDstEnd;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    BOOL  bNextSrc = TRUE;

    // We assume we are doing left to right top to bottom blting
    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D1LtoR - direction not left to right");
    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d1ltor\n");

    // if ixlate is 0x00, all 0's
    // if ixlate is 0x01, src copy
    // if ixlate is 0x10, src invert
    // if ixlate is 0x11, all 1's

    ixlate = (psb->pxlo->pulXlate[0]<<1) | psb->pxlo->pulXlate[1];

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    // Checking alignment

    // If Src starting point is ahead of Dst
    if (iSrc < iDst)
        jAlignL = 8 - (iDst - iSrc);
    // If Dst starting point is ahead of Src
    else
        jAlignL = iSrc - iDst;

    //jAlignR = (8 - jAlignL) & 0x07;
    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    xDstEnd = psb->xDstStart + cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    //check if there is a next byte
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // The following loop is the inner loop part
    // where we deals with a byte at a time
    // when this main part is done, we deal
    // with the begin and end partial bytes
    //
    // if Src and Dst are aligned, use a separete loop
    // to obtain better performance;
    // If not, we shift the Src bytes to match with
    // the Dst byte one at a time

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;

        //Get first Dst full byte
        pjDst = psb->pjDst + ((psb->xDstStart+7)>>3);

        //Get the Src byte that matches the first Dst
        // full byte
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get last full byte
        pjLDst = psb->pjDst + (xDstEnd>>3);

        //Get the number of full bytes

        // Sundown: xSrcStart and xSrcEnd are both LONG, safe to truncate

        cFullBytes = (ULONG)(pjLDst - pjDst);

        //the increment to the full byte on the next scan line

        iStrideDst = lDeltaDst - cFullBytes;
        iStrideSrc = lDeltaSrc - cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL || (ixlate == 0) || (ixlate == 3))
        {
            BYTE jConstant;

            switch (ixlate)
            {
            case 0:
            case 3:
                jConstant = (!ixlate)?0:0xFF;

                while (cy--)
                {
                    int i;

                    i = cFullBytes;

                    while (i--)
                        *pjDst++ = jConstant;

                    //move to the beginning full byte
                    // on the next scan line

                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;
                };
                break;
            case 1:
                while (cy--)
                {
                    RtlCopyMemory(pjDst,pjSrc,cFullBytes);

                    // move to the beginning full byte
                    // on the next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                };
                break;

            case 2:
                while (cy--)
                {
                    int i;

                    i = cFullBytes;

                    while (i--)
                        *pjDst++ = ~*pjSrc++;

                    //move to the beginning full byte
                    // on the next scan line

                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;
                };
                break;


            default:;
            } //switch
        }   //end of if (!jAlignL)

        else
        // if neither aligned nor all 0's or all 1's
        {
            BYTE jRem; //remainder

            switch (ixlate)
            {
            case 1:
                while (cy--)
                {
                    jRem = *pjSrc << jAlignL;

                    pjSrcEnd = pjSrc+cFullBytes;

                    while (pjSrc != pjSrcEnd)
                    {
                        jSrc = *(++pjSrc);
                        jDst = (jSrc>>jAlignR) | jRem;
                        *pjDst++ = jDst;

                        //next remainder
                        jRem = jSrc << jAlignL;
                    }

                    // go to the beginging full byte of
                    // next scan line
                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;

                };
                break;

            case 2:
                while (cy--)
                {
                    jRem = *pjSrc << jAlignL;

                    pjSrcEnd = pjSrc+cFullBytes;

                    while (pjSrc != pjSrcEnd)
                    {
                        jSrc = *(++pjSrc);
                        jDst = (jSrc>>jAlignR) | jRem;
                        *pjDst++ = ~jDst;

                        //next remainder
                        jRem = jSrc << jAlignL;
                    }

                    // go to the beginging full byte of
                    // next scan line
                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;

                }; //while
                break;

            default: ;
            } //switch
        } //else
    } //if
    // End of our dealing with the full bytes

    //build our masks
    jMask = 0xFF >> iDst;

    // if there are only one partial left byte,
    // the mask is special
    // for example, when we have 00111000 for
    // Dst
    if (!bNextByte)
    {
        jEndMask = 0XFF << (8-(xDstEnd & 0x0007));

        jMask = jMask & jEndMask;

        bNextSrc = ((iSrc + cx) > 8);

    }

    // Begin dealing with the left strip of the first
    // partial byte
    // First check if there are any partial
    // left byte.  Otherwise don't bother
    if (iDst | !bNextByte)
    {
        pjDst = psb->pjDst + (psb->xDstStart>>3);
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        switch (ixlate)
        {
        case 0:
            while (cy--)
            {
                *pjDst = *pjDst & ~jMask;

                pjDst += lDeltaDst;
            }
            break;

        case 1:
            if (iSrc > iDst)
            {
                if (bNextSrc)
                    while (cy--)
                    {
                        jSrc = *pjSrc << jAlignL;
                        jSrc |= *(pjSrc+1) >> jAlignR;

                        jSrc &= jMask;

                        *pjDst = (*pjDst & (~jMask)) | jSrc;

                        pjDst += lDeltaDst;
                        pjSrc += lDeltaSrc;

                    }
               else //if !bNextSrc
                   while (cy--)
                    {
                        jSrc = *pjSrc << jAlignL;

                        jSrc &= jMask;

                        *pjDst = (*pjDst & (~jMask)) | jSrc;

                        pjDst += lDeltaDst;
                        pjSrc += lDeltaSrc;

                    }

            }
            else if (iSrc < iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc >> jAlignR;

                    jSrc &= jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }

            }
            else   // iSrc = iDst
            {
                while (cy--)
                {
                    jSrc = *pjSrc;

                    jSrc &= jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }

            }

            break;

        case 2:
            if (iSrc > iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;
                    jSrc |= *(pjSrc+1) >> jAlignR;

                    jSrc = ~jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else if (iSrc < iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc >> jAlignR;

                    jSrc = ~jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            else   // iSrc = iDst
            {
                while (cy--)
                {
                    jSrc = *pjSrc;

                    jSrc = ~jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            break;

        case 3:
            while (cy--)
            {
                *pjDst = *pjDst | jMask;

                pjDst += lDeltaDst;
            }
            break;

        default: ;
        } //switch
   } //if

   // Begin dealing with the right edge
   // of partial bytes

   jMask = 0xFF >> ((BYTE)(psb->xDstStart+cx) & 0x0007);

   // first check if there is any partial
   // byte left
   // and has next byte

   if ((xDstEnd & 0x0007)
       && bNextByte)
   {
        // Get the last partial bytes on the
        // scan line

        pjDst = pjLDst;

        // Get the Src byte that matches the
        // right partial Dst byte
        // since xSrcEnd always point one
        // pixel after the last pixel, minus 1
        // from it
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        cy = psb->cy;

        switch (ixlate)
        {
        case 0:
            while (cy--)
            {
                *pjDst &= jMask;

                pjDst += lDeltaDst;
            }
            break;

        case 1:
            if (iSrc > iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;

                    jSrc &= ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                     //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else if (iSrc < iDst)
            {
                while (cy--)
                {
                    jSrc = *(pjSrc-1) << jAlignL;

                    jSrc |= *pjSrc >> jAlignR;

                    jSrc &= ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                     //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            else   // iSrc = iDst
            {
                while (cy--)
                {
                    jSrc = *pjSrc;

                    jSrc &= ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                     //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                 }
             }
             break;

        case 2:
            if (iSrc > iDst)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;

                    jSrc = ~jSrc & ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                    //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else if (iSrc < iDst)
            {
                while (cy--)
                {
                    jSrc = *(pjSrc-1) << jAlignL;
                    jSrc |= *pjSrc >> jAlignR;

                    jSrc = ~jSrc & ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                    //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else   // iSrc = iDst
            {
                while (cy--)
                {
                    jSrc = *pjSrc;

                    jSrc = ~jSrc & ~jMask;

                    *pjDst = (*pjDst & jMask) | jSrc;

                    //go to next scan line

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            break;

       case 3:
            while (cy--)
            {
                *pjDst = *pjDst | ~jMask;

                pjDst += lDeltaDst;
            }
            break;

       default: ;
       } //switch
   } //if
}

/*******************Public*Routine*****************\
* vSrcCopyS1D1RtoL
*
* this function is only called when copy to the
* same surface and has overlapping.
*
* There are three main loops in this function.
*
* The first loop deals with the starting pixels on the
* right most partial bytes.  This must
* come first because it is Right to Left and overlapping.
*
* The second loop deals with the full bytes part of
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The third loop deals with the ending pixles on the
* left most partial bytes.
*
* Special case:
* when the Src and Dst are aligned, we enter
* a different loop to use RltMoveMem to avoid
* shifting.  RltMoveMemory gurantee the overlapping
* parts to be correct.
*
* History:
* 26-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.

\**************************************************/



VOID vSrcCopyS1D1RtoL(PBLTINFO psb)
{
    BYTE  jSrc;     // holds a source byte
    BYTE  jDst;     // holds a dest byte
    INT   iSrc;     // bit position in the first Src byte
    INT   iDst;     // bit position in the first Dst byte
    PBYTE pjDst;    // pointer to the Src bytes
    PBYTE pjSrc;    // pointer to the Dst bytes
    PBYTE pjLDst;   // pointer to the last Dst byte
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;       // number of pixels
    LONG  cx;       // number of rows
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    BYTE  jMask;    // Masks used for shifting
    BYTE  jEndMask;
    LONG  cFullBytes;  //number of full bytes to deal with
    BOOL  bNextByte;
    LONG  xDstEnd;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    BOOL  bNextSrc = TRUE;

    // We assume we are doing right to left top to bottom blting
    ASSERTGDI(psb->xDir == -1, "vSrcCopyS1D1RtoL - direction not right to left");
    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");
    ASSERTGDI (psb->pxlo->pulXlate[0] == 0, "vSrcCopyS1D1RtoL - should be straight copy");
    ASSERTGDI (psb->pxlo->pulXlate[1] == 1, "vSrcCopyS1D1RtoL - should be straight copy");

    //DbgPrint ("vsrccopys1d1rtol\n");

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    // Checking alignment

    // If Src starting point is ahead of Dst
    if (iSrc < iDst)
        jAlignL = 8-(iDst - iSrc);
    // If Dst starting point is ahead of Src
    else
        jAlignL = iSrc - iDst;

    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    xDstEnd = psb->xDstStart - cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    //check if there is a next byte
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // prepare our mask for the beggining
    // partial bytes (this is on the right
    // hand side)
    jMask = 0xFF << (7-(psb->xDstStart&0x07));

    // if there are only one partial byte, the
    // mask is special, for example, when
    // we have 00111000 for dst.
    if (!bNextByte)
    {
        jEndMask = 0XFF >> ((1+xDstEnd) & 0x0007);

        jMask = jMask & jEndMask;

        // test if src needs to go to 1 byte left
        // for example, iSrc == 0, cx==1, does
        // not need to fetch the byte to the left
        if (iSrc < iDst)
            bNextSrc = ((iSrc-cx) < -1);

    }
    // Dealing with the starting pixels
    // first,  since we are doing right
    // to left.

    if (((iDst+1)&0x07) | !bNextByte)
    {

        pjDst = psb->pjDst + (psb->xDstStart>>3);
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc > iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;

                jSrc = jSrc & jMask;

                *pjDst = (*pjDst & (~jMask)) | jSrc;

                //go to next scan line
                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;

            }
        }
        else if (iSrc < iDst)
        {
            if (bNextSrc)
                while (cy--)
                {
                    jSrc = *pjSrc >> jAlignR;
                    jSrc |= *(pjSrc-1) << jAlignL;

                    jSrc = jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            else
            // if there is no next src byte,
            // accessing pjSrc-1 will cause
            // access violation.
            // this only happens on the starting
            // partial byte when bNextByte is False
                while (cy--)
                {
                    jSrc = *pjSrc >> jAlignR;

                    jSrc = jSrc & jMask;

                    *pjDst = (*pjDst & (~jMask)) | jSrc;

                    //go to next scan line
                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }

        }
        else   // iSrc = iDst
        {
            while (cy--)
            {
                jSrc = *pjSrc;

                jSrc = jSrc & jMask;

                *pjDst = (*pjDst & (~jMask)) | jSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
   }


    // The following loop is the inner loop part
    // where we deals with a byte at a time
    // when this main part is done, we deal
    // with the begin and end partial bytes
    //
    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;

        //Get first Dst full byte
        pjDst = psb->pjDst + ((psb->xDstStart-7)>>3);

        //Get the Src byte that matches the first Dst
        // full byte
        pjSrc = psb->pjSrc + ((psb->xSrcStart-((iDst+1)&0x07))>>3);

        //Get last byte
        pjLDst = psb->pjDst + (xDstEnd>>3);

        //Get the number of full bytes

        // Sundown safe truncation
        cFullBytes = (ULONG)(pjDst - pjLDst);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst + cFullBytes;
        iStrideSrc = lDeltaSrc + cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL)
        {
            while (cy--)
            {
                RtlMoveMemory(pjDst-(cFullBytes-1),pjSrc-(cFullBytes-1),cFullBytes);

                // move to the beginning full byte
                // on the next scan line

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }   //end of if (!jAlignL)
        else
        {
            BYTE jRem;

            while (cy--)
            {
                    jRem = *pjSrc >> jAlignR;

                    pjSrcEnd = pjSrc-cFullBytes;

                    while (pjSrc != pjSrcEnd)
                    {
                        jSrc = *(--pjSrc);

                        jDst = (jSrc<<jAlignL) | jRem;

                        *pjDst-- = jDst;

                        //next remainder
                        jRem = jSrc >> jAlignR;
                    }

                    // go to the beginging full byte of
                    // next scan line
                    pjDst += iStrideDst;
                    pjSrc += iStrideSrc;

            }
        }
    } //if

       // Begin dealing with the ending pixels

   jMask = 0xFF << (8-((1+xDstEnd) & 0x0007));

   // first check if there is any partial
   // byte left
   // and has next byte

   if (((1+xDstEnd) & 0x0007)
       && bNextByte)
   {
        // Get the last partial bytes on the
        // scan line
        pjDst = pjLDst;

        // Get the Src byte that matches the
        // right partial Dst byte
        //
        pjSrc = psb->pjSrc + ((psb->xSrcEnd+1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd+1) & 0x0007;
        iDst = (xDstEnd + 1)& 0x0007;

        cy = psb->cy;

        if (iSrc > iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;
                jSrc |= *(pjSrc+1) >> jAlignR;

                jSrc &= ~jMask;

                *pjDst = (*pjDst & jMask) | jSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;

            }
        }
        else if (iSrc < iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc >> jAlignR;

                jSrc &= ~jMask;

                *pjDst = (*pjDst & jMask) | jSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else   // iSrc = iDst
        {
            while (cy--)
            {
                jSrc = *pjSrc;

                jSrc &= ~jMask;

                *pjDst = (*pjDst & jMask) | jSrc;

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;

           }
         }
   } //if
}


/******************************Public*Routine******************************\
* vSrcCopyS4D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D1 - direction not up to down");

    BYTE  jSrc;
    BYTE  jDst;
    LONG  iSrc;
    LONG  iDst;
    PBYTE pjDstTemp;
    PBYTE pjSrcTemp;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PBYTE pjSrc = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cy = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize all the variables

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;

        iSrc = psb->xSrcStart;
        iDst = psb->xDstStart;

    // Set up the Src. Left to Right.

        if (iSrc & 0x00000001)
            jSrc = *(pjSrcTemp++);

    // Set up the Dst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iSrc != psb->xSrcEnd)
        {
            jDst <<= 1;

            if (iSrc & 0x00000001)
            {
                if (pulXlate[(jSrc & 0x0F)])
                    jDst |= 0x01;
            }
            else
            {
                jSrc = *(pjSrcTemp++);

                if (pulXlate[((jSrc & 0xF0) >> 4)])
                    jDst |= 0x01;
            }

            iDst++;
            iSrc++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jSrc = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jSrc) | (jDst & ~jSrc));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D1 - direction not up to down");

    BYTE  jDst;
    LONG  iDst;
    PBYTE pjDstTemp;
    PBYTE pjSrcTemp;
    LONG  xDstEnd = psb->xDstStart + psb->cx;
    PULONG pulXlate = psb->pxlo->pulXlate;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PBYTE pjSrc = psb->pjSrc + psb->xSrcStart;
    ULONG cy = psb->cy;
    BYTE jMask;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize the variables

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;
        iDst = psb->xDstStart;

    // Set up jDst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iDst != xDstEnd)
        {
            jDst <<= 1;

            if (pulXlate[(*(pjSrcTemp++))])
               jDst |= 0x01;

            iDst++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS16D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D1 - direction not up to down");

    BYTE  jDst;
    LONG  iDst;
    PBYTE pjDstTemp;
    PUSHORT pusSrcTemp;
    LONG  xDstEnd = psb->xDstStart + psb->cx;
    XLATE *pxlo = (XLATE *) psb->pxlo;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PUSHORT pusSrc = (PUSHORT) (psb->pjSrc + (psb->xSrcStart << 1));
    ULONG cy = psb->cy;
    BYTE jMask;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize the variables

        pjDstTemp = pjDst;
        pusSrcTemp = pusSrc;
        iDst = psb->xDstStart;

    // Set up jDst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iDst != xDstEnd)
        {
            jDst <<= 1;

            if (pxlo->ulTranslate(*(pusSrcTemp++)))
               jDst |= 0x01;

            iDst++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
	    pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS24D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D1 - direction not up to down");

    BYTE  jDst;
    LONG  iDst;
    ULONG ulDink;     // variable to dink around with bytes
    PBYTE pjDstTemp;
    PBYTE pjSrcTemp;
    LONG  xDstEnd = psb->xDstStart + psb->cx;
    XLATE *pxlo = (XLATE *) psb->pxlo;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PBYTE pjSrc = psb->pjSrc + (psb->xSrcStart * 3);
    ULONG cy = psb->cy;
    BYTE jMask;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize the variables

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;
        iDst = psb->xDstStart;

    // Set up jDst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iDst != xDstEnd)
        {
            jDst <<= 1;

            ulDink = *(pjSrcTemp + 2);
            ulDink = ulDink << 8;
            ulDink |= (ULONG) *(pjSrcTemp + 1);
            ulDink = ulDink << 8;
            ulDink |= (ULONG) *pjSrcTemp;
            pjSrcTemp += 3;

            if (pxlo->ulTranslate(ulDink))
               jDst |= 0x01;

            iDst++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS32D1
*
* Note we use pxlo to translate rather than looking at the foreground
* or background color.  This is to keep the PM/Windows differences
* transparent to the blt code.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS32D1(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D1 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D1 - direction not up to down");

    BYTE  jDst;
    LONG  iDst;
    PBYTE pjDstTemp;
    PULONG pulSrcTemp;
    LONG  xDstEnd = psb->xDstStart + psb->cx;
    XLATE *pxlo = (XLATE *) psb->pxlo;
    PBYTE pjDst = psb->pjDst + (psb->xDstStart >> 3);
    PULONG pulSrc = (PULONG) (psb->pjSrc + (psb->xSrcStart << 2));
    ULONG cy = psb->cy;
    BYTE jMask;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
    // Initialize the variables

        pjDstTemp  = pjDst;
        pulSrcTemp  = pulSrc;
        iDst = psb->xDstStart;

    // Set up jDst.  We just keep adding bits to the right and
    // shifting left.

        if (iDst & 0x00000007)
        {
        // We're gonna need some bits from the 1st byte of Dst.

            jDst = (BYTE) ( ((ULONG) (*pjDstTemp)) >> (8 - (iDst & 0x00000007)) );
        }

    // Do the inner loop on a scanline

        while(iDst != xDstEnd)
        {
            jDst <<= 1;

            if (pxlo->ulTranslate(*(pulSrcTemp++)))
               jDst |= 0x01;

            iDst++;

            if (!(iDst & 0x07))
                *(pjDstTemp++) = jDst;
        }

    // Clean up after the inner loop

        if (iDst & 0x00000007)
        {
        // We need to build up the last pel correctly.

            jMask = (BYTE) (0x000000FF >> (iDst & 0x00000007));

            jDst = (BYTE) (jDst << (8 - (iDst & 0x00000007)));

	    *pjDstTemp = (BYTE) ((*pjDstTemp & jMask) | (jDst & ~jMask));
        }

    // Check if we have anymore scanlines to do

        if (--cy)
        {
	    pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\spool.cxx ===
/******************************Module*Header*******************************\
* Module Name: spool.cxx
*
* Created: 21-Feb-1995 10:13:18
* Author:  Eric Kutter [erick]
*
* Copyright (c) 1993-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"



DWORD DriverInfo1Offsets[]={offsetof(DRIVER_INFO_1W, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Offsets[]={offsetof(DRIVER_INFO_2W, pName),
                            offsetof(DRIVER_INFO_2W, pEnvironment),
                            offsetof(DRIVER_INFO_2W, pDriverPath),
                            offsetof(DRIVER_INFO_2W, pDataFile),
                            offsetof(DRIVER_INFO_2W, pConfigFile),
                            0xFFFFFFFF};
DWORD DriverInfo3Offsets[]={offsetof(DRIVER_INFO_3W, pName),
                            offsetof(DRIVER_INFO_3W, pEnvironment),
                            offsetof(DRIVER_INFO_3W, pDriverPath),
                            offsetof(DRIVER_INFO_3W, pDataFile),
                            offsetof(DRIVER_INFO_3W, pConfigFile),
                            offsetof(DRIVER_INFO_3W, pHelpFile),
                            offsetof(DRIVER_INFO_3W, pDependentFiles),
                            offsetof(DRIVER_INFO_3W, pMonitorName),
                            offsetof(DRIVER_INFO_3W, pDefaultDataType),
                            0xFFFFFFFF};

DWORD DriverInfo1Strings[]={offsetof(DRIVER_INFO_1W, pName),
                            0xFFFFFFFF};

DWORD DriverInfo2Strings[]={offsetof(DRIVER_INFO_2W, pName),
                            offsetof(DRIVER_INFO_2W, pEnvironment),
                            offsetof(DRIVER_INFO_2W, pDriverPath),
                            offsetof(DRIVER_INFO_2W, pDataFile),
                            offsetof(DRIVER_INFO_2W, pConfigFile),
                            0xFFFFFFFF};
DWORD DriverInfo3Strings[]={offsetof(DRIVER_INFO_3W, pName),
                            offsetof(DRIVER_INFO_3W, pEnvironment),
                            offsetof(DRIVER_INFO_3W, pDriverPath),
                            offsetof(DRIVER_INFO_3W, pDataFile),
                            offsetof(DRIVER_INFO_3W, pConfigFile),
                            offsetof(DRIVER_INFO_3W, pHelpFile),
                            offsetof(DRIVER_INFO_3W, pMonitorName),
                            offsetof(DRIVER_INFO_3W, pDefaultDataType),
                            0xFFFFFFFF};


DWORD FormInfo1Offsets[] = {    offsetof(FORM_INFO_1W, pName),
                                0xFFFFFFFF};


DWORD PrinterInfo1Offsets[]={offsetof(PRINTER_INFO_1W, pDescription),
                             offsetof(PRINTER_INFO_1W, pName),
                             offsetof(PRINTER_INFO_1W, pComment),
                             0xFFFFFFFF};

DWORD PrinterInfo2Offsets[]={offsetof(PRINTER_INFO_2W, pServerName),
                             offsetof(PRINTER_INFO_2W, pPrinterName),
                             offsetof(PRINTER_INFO_2W, pShareName),
                             offsetof(PRINTER_INFO_2W, pPortName),
                             offsetof(PRINTER_INFO_2W, pDriverName),
                             offsetof(PRINTER_INFO_2W, pComment),
                             offsetof(PRINTER_INFO_2W, pLocation),
                             offsetof(PRINTER_INFO_2W, pDevMode),
                             offsetof(PRINTER_INFO_2W, pSepFile),
                             offsetof(PRINTER_INFO_2W, pPrintProcessor),
                             offsetof(PRINTER_INFO_2W, pDatatype),
                             offsetof(PRINTER_INFO_2W, pParameters),
                             offsetof(PRINTER_INFO_2W, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo3Offsets[]={offsetof(PRINTER_INFO_3, pSecurityDescriptor),
                             0xFFFFFFFF};

DWORD PrinterInfo4Offsets[]={offsetof(PRINTER_INFO_4W, pPrinterName),
                             offsetof(PRINTER_INFO_4W, pServerName),
                             0xFFFFFFFF};

DWORD PrinterInfo5Offsets[]={offsetof(PRINTER_INFO_5W, pPrinterName),
                             offsetof(PRINTER_INFO_5W, pPortName),
                             0xFFFFFFFF};






/*********************************Class************************************\
* SPOOLMSG
*
*   structure containg a message waiting to be grabbed by a spooler thread.
*   This is a private structure to communicate between the applications thread
*   and the spoolers thread
*
* History:
*  27-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

#define SPOOLMSG_DELETE_INBUF   0x00000002
#define SPOOLMSG_MAXINPUT_BUF   4
#define NO_CLIENT               1
#define NON_SPOOL_INSTANCE      ((DWORD) -1)
#define MIN_DEVMODE_SIZE        72      // Win 3.1 DevMode size.  Also hard-coded in yspool

typedef struct _SPOOLMSG
{
    ULONG     cj;
    ULONG     iMsg;
    ULONG     fl;

    HSPOOLOBJ hso;
    PETHREAD  pthreadClient;
    SECURITY_CLIENT_CONTEXT sccSecurity;

    // in order to avoid extra copying into a single buffer, there are multiple
    // input buffers.  For example, WritePrinter uses a header buffer on the
    // stack with a second buffer containing the output data.

    ULONG     cjIn;                         // combined size of input buffers
    ULONG     cBuf;                         // number of input buffers
    PULONG    apulIn[SPOOLMSG_MAXINPUT_BUF];// input buffers
    ULONG     acjIn[SPOOLMSG_MAXINPUT_BUF];

    PULONG    pulOut;       // location to put output data
    ULONG     cjOut;        // size of output

    ULONG     ulRet;        // return value
    ULONG     ulErr;        // transfer last error from spooler thread to client

    struct _SPOOLMSG *pNext;

} SPOOLMSG, *PSPOOLMSG;


/*********************************Class************************************\
* SPOOLOBJ : public OBJECT
*
* a SPOOLOBJ is GDI's internal spooler object containing data need to access
* the spooler for a particular print job.
*
* Public Interface:
*
* History:
*  21-Jun-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

class SPOOLOBJ : public OBJECT
{
public:

    KEVENT  *pkevent;
    HANDLE  hSpool;
    PVOID   pvMsg;
    SPOOLMSG sm;
    DWORD   dwFlags;
    DWORD   dwSpoolInstance;
    GREWRITEPRINTER WritePrinter;
    DWORD   dwWritePrinterReturn;
};
typedef SPOOLOBJ *PSPOOLOBJ;


/**************************************************************************\
 *
\**************************************************************************/

BOOL        gbInitSpool = FALSE;        // set/cleared as the spooler comes and goes
PW32PROCESS gpidSpool = 0;              // process ID of the spooler
PEPROCESS   gpeSpool = 0;               // process pointer of the spooler

PKEVENT     gpeventGdiSpool;            // spooler lock
PKEVENT     gpeventSpoolerTermination;  // signals spooler termination so client threads in spooler process can exit

DWORD       gdwSpoolInstance = 0;     // Keeps track of the spooler instance

LONG        gpInfiniteWait = TRUE;      // LONG used to ensure we have one spooler thread waiting with INFINITE timeoue

// there is a queue of spool messages.  Elements are removed from the head
// and added to the tail

PSPOOLMSG gpsmSpoolHead     = NULL;
PSPOOLMSG gpsmSpoolTail     = NULL;

int       gcSpoolMsg        = 0;
int       gcSpoolMsgCurrent = 0;
int       gcSpoolMsgMax     = 0;


#define LOCKSPOOLER   GreAcquireSemaphore(ghsemGdiSpool)
#define UNLOCKSPOOLER GreReleaseSemaphore(ghsemGdiSpool)

#define POFFSET(pBase,pCur) ((PBYTE)(pCur) - (PBYTE)(pBase))


/*********************************Class************************************\
* class SPOOLREF
*
* Public Interface:
*
* History:
*  22-May-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

class SPOOLREF
{
public:

    PSPOOLOBJ pso;

    SPOOLREF()                  {}
    SPOOLREF(HANDLE hspool)
    {
        pso = (PSPOOLOBJ)HmgLock((HOBJ)hspool,SPOOL_TYPE);
    }


   ~SPOOLREF()
    {
        if (bValid())
        {
            DEC_EXCLUSIVE_REF_CNT(pso);
            pso = NULL;
        }
    }

    BOOL bDelete();
    BOOL GreEscapeSpool();

    BOOL bValid()               {return(pso != NULL); }
    HSPOOLOBJ hGet()            {return((HSPOOLOBJ)pso->hGet());}
    PSPOOLMSG psm()             {return(&pso->sm);          }

    // we need to know the lock count for cleanup so we don't free up a message
    // when it still may be accessed.

    ULONG cAltLock()
    {
        return(((POBJ) (pso))->ulShareCount);
    }
};


class SPOOLALTREF : public SPOOLREF
{
public:

    SPOOLALTREF(HANDLE hspool)
    {
        pso = (PSPOOLOBJ)HmgShareLock((HOBJ)hspool,SPOOL_TYPE);
    }

   ~SPOOLALTREF()
    {
        if (bValid())
        {
            DEC_SHARE_REF_CNT(pso);
            pso = NULL;
        }
    }
};

typedef SPOOLALTREF *PSPOOLALTREF;



class SPOOLMEMOBJ : public SPOOLREF
{
public:

    SPOOLMEMOBJ();
   ~SPOOLMEMOBJ()   {}
};


ULONG
ulFinishMessage(
    PSPOOLMSG psm,
    PSPOOLESC psesc,
    PSPOOLALTREF sr,
    PBYTE pjEscData,
    ULONG cjEscData
    );

BOOL AddMessage2Q(
    PSPOOLMSG psm,
    DWORD     dwSpoolInstance
    );

VOID SubtractMessageFromQ(PSPOOLMSG psmIn);


/******************************Public*Routine******************************\
*
*
* History:
*  22-May-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

SPOOLMEMOBJ::SPOOLMEMOBJ()
{
    KEVENT *pkevent = (PKEVENT) GdiAllocPoolNonPagedNS(
                                                      sizeof(KEVENT), 'lpsG');

    if (pkevent == NULL)
    {
        pso = NULL;
    }
    else
    {
        pso = (PSPOOLOBJ)HmgAlloc(sizeof(SPOOLOBJ),SPOOL_TYPE, HMGR_ALLOC_LOCK);

        if (bValid())
        {

LOCKSPOOLER;
            pso->dwSpoolInstance = gdwSpoolInstance;
UNLOCKSPOOLER;

            pso->pkevent = pkevent;

            KeInitializeEvent(
                            pso->pkevent,
                            SynchronizationEvent,
                            FALSE);
        }
        else
        {
            VFREEMEM(pkevent);
        }
    }
}

/******************************Public*Routine******************************\
*
*
* History:
*  22-May-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL SPOOLREF::bDelete()
{
    if (bValid())
    {
        VFREEMEM(pso->pkevent);

        HmgFree((HOBJ)hGet());

        pso = NULL;
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* bIsProcessLocalSystem()
*
* History:
*  19-Jun-2001 -by-  Barton House [bhouse]
* Wrote it.
\**************************************************************************/

static BOOL bIsProcessLocalSystem(void)
{
    BOOL                        bResult = FALSE;
    PEPROCESS                   peprocess;
    PACCESS_TOKEN               paccessToken;
    NTSTATUS                    status;
    PTOKEN_USER                 ptu;

    peprocess = PsGetCurrentProcess();

    paccessToken = PsReferencePrimaryToken(peprocess);

    status = SeQueryInformationToken(paccessToken, TokenUser, (PVOID *) &ptu);

    PsDereferencePrimaryToken(paccessToken);

    if (NT_SUCCESS(status) == TRUE)
    {
        bResult = RtlEqualSid(SeExports->SeLocalSystemSid, ptu->User.Sid);
        ExFreePool(ptu);
    }

    return bResult;
}

/******************************Public*Routine******************************\
* GreInitSpool()
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL NtGdiInitSpool()
{
    BOOL bRet = FALSE;

    LOCKSPOOLER;

    if (gbInitSpool)
    {
        EngSetLastError(ERROR_INVALID_ACCESS);
        WARNING("GreInitSpool - already called\n");
    }
    else if(!bIsProcessLocalSystem())
    {
        EngSetLastError(ERROR_INVALID_ACCESS);
        WARNING("GreInitSpool - caller is not system\n");
    }
    else
    {
        NTSTATUS status;

        // intialize the spooler events

        gpeventGdiSpool = (PKEVENT) GdiAllocPoolNonPagedNS(
                                       sizeof(KEVENT), 'gdis');

        gpeventSpoolerTermination = (PKEVENT) GdiAllocPoolNonPagedNS(
                                       sizeof(KEVENT), 'gdis');

        if (gpeventGdiSpool && gpeventSpoolerTermination)
        {
            KeInitializeEvent(
                        gpeventGdiSpool,
                        SynchronizationEvent,
                        FALSE);

            KeInitializeEvent(
                        gpeventSpoolerTermination,
                        NotificationEvent,
                        FALSE);

            gbInitSpool = TRUE;
            bRet = TRUE;
            gpeSpool = PsGetCurrentProcess();

        }
        else
        {
            EngSetLastError(ERROR_NOT_ENOUGH_MEMORY);

            if (gpeventGdiSpool)
            {
                VFREEMEM(gpeventGdiSpool);
                gpeventGdiSpool = NULL;
            }

            if (gpeventSpoolerTermination)
            {
                VFREEMEM(gpeventSpoolerTermination);
                gpeventSpoolerTermination = NULL;
            }
        }

        gpidSpool = W32GetCurrentProcess();

        if (++gdwSpoolInstance == NON_SPOOL_INSTANCE)
            ++gdwSpoolInstance;
    }

    UNLOCKSPOOLER;

    return(bRet);
}

/******************************Public*Routine******************************\
*
*
* History:
*  01-Jun-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

VOID vCleanupSpool()
{
    if (gpidSpool == W32GetCurrentProcess())
    {
        //DbgPrint("vCleanupSpool() - cleaning up the spooler process\n");

        LOCKSPOOLER;

        if (gbInitSpool == TRUE)
        {

            while (gpsmSpoolHead != NULL)
            {
                //DbgPrint("vCleanupSpool() - got another\n");

                PSPOOLMSG psm = gpsmSpoolHead;

                gpsmSpoolHead = psm->pNext;

                // and some stats

                ASSERTGDI(gcSpoolMsgCurrent > 0, "GreGetSpoolMsg - invalid count\n");
                gcSpoolMsgCurrent--;

                SPOOLALTREF sr(psm->hso);

                if (sr.bValid())
                {
                    KeSetEvent(sr.pso->pkevent,0,FALSE);
                }
            }

            gpsmSpoolTail = NULL;


            VFREEMEM(gpeventGdiSpool);
            VFREEMEM(gpeventSpoolerTermination);

            gpeventGdiSpool = NULL;
            gpeventSpoolerTermination = NULL;
            gbInitSpool = FALSE;
            gpeSpool = NULL;

            gcSpoolMsg = 0;
            gcSpoolMsgCurrent = 0;
            gcSpoolMsgMax = 0;

            gpidSpool = NULL;

            //DbgPrint("Done cleaning up spooler for this thread\n");
        }

        UNLOCKSPOOLER;
    }
}

/******************************Public*Routine******************************\
* GreGetSpoolMessage()
*
* This is intended to be called from the spooler process (GdiGetSpoolMessage)
* to get the next spooler message out of the kernel.
*
*
*   if (output buffer exists)
*       copy out output buffer
*
*   wait for next message
*
*   copy in input buffer
*
* input:
*
*   psesc  - buffer to place message
*   cjmsg  - size of message buffer
*   pulOut - buffer containing data to be copied to output buffer
*   cjOut  - size of output buffer
*
*
* returns:
*
*   size of data placed in psesc.
*
*
* Note: the output buffer is filled by the calling routine before calling
*       this function again.
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
*
*  6-Aug-1995 - Added Input buffer growing (Steve Wilson [swilson])
*
* Wrote it.
\**************************************************************************/

SECURITY_QUALITY_OF_SERVICE Sqos =
{
    sizeof(SECURITY_QUALITY_OF_SERVICE),
    SecurityImpersonation,
    SECURITY_DYNAMIC_TRACKING,
    FALSE
};

ULONG GreGetSpoolMessage(
    PSPOOLESC psesc,
    PBYTE     pjEscData,    // this must only be accessed under a try/except
    ULONG     cjEscData,
    PULONG    pulOut,
    ULONG     cjOut
    )
{
    ULONG     ulRet = 0;
    NTSTATUS status;
    LONG lState;

    //DbgPrint("Entered GreGetSpoolMessage\n");

    if (!gbInitSpool)
    {
        WARNING("GreGetSpoolMessage - not initialized\n");
    }
    else if (gpidSpool != W32GetCurrentProcess())
    {
        WARNING("GreGetSpoolMessage - called from non-spooler process\n");
    }
    else
    {
        KEVENT *pkevent = NULL;

        // see if we need to copy any data out

        if (psesc->hso)
        {
            SPOOLALTREF sr(psesc->hso);

            if (sr.bValid())
            {

                // we have found the spool obj.  Now see if we really have
                // an output buffer and need to copy anything.

                PSPOOLMSG psm = (PSPOOLMSG)sr.pso->pvMsg;

                // if we asked the spooler to grow the buffer and it succeeded
                // finish copying the message and return.  If it failed, we still
                // need to cleanup this message and release the thread.

                if (psesc->iMsg == GDISPOOL_INPUT2SMALL)
                {
                    if (psesc->ulRet && psm)
                    {
                        return(ulFinishMessage(psm, psesc,  &sr, pjEscData, cjEscData));
                    }

                    pulOut       = NULL;
                    psesc->ulRet = 0;
                }

                // if we actualy have a message, we need to copy out the data
                // if there is any and remember the event in order to let the
                // client continue.

                if (psm)
                {
                    // if we are still impersonating the client, undo it

                    if (psm->pthreadClient)
                    {
                        SeStopImpersonatingClient();
                        SeDeleteClientSecurity(&psm->sccSecurity);
                        psm->pthreadClient = NULL;
                    }

                    // see if we have anything to copy out

                    if (pulOut && psm->pulOut)
                    {
                        if (cjOut > psm->cjOut)
                            cjOut = psm->cjOut;

                        __try
                        {
                            // this is the only place that pulOut is validated

                            ProbeForRead(pulOut,cjOut,sizeof(ULONG));

                            RtlCopyMemory(psm->pulOut,pulOut,cjOut);

                            psm->cjOut = cjOut;
                        }
                        __except(EXCEPTION_EXECUTE_HANDLER)
                        {
                            psm->cjOut = 0;
                        }
                    }
                    else
                    {
                        psm->cjOut = 0;
                    }

                    psm->ulRet = psesc->ulRet;
                    psm->ulErr = EngGetLastError();

                    // Since to have output the message must have been synchronous,
                    // we need to let the other thread go now.

                    pkevent = sr.pso->pkevent;
                }


                // the spool obj is now done with this message

                sr.pso->pvMsg = NULL;
            }
            else
            {
                WARNING("GreGetSpoolMessage - hso but no pso\n");
            }
        }

        // the release of the other thread needs to be done once the SPOOLOBJ has
        // been unlocked.

        if (pkevent)
        {
            lState = KeSetEvent(pkevent,0,FALSE);

            ASSERTGDI(lState == 0,"GreGetSpoolMessage - lState not 0, a\n");
        }

        // done with the last message.  Wait for the next message.

        PSPOOLMSG psm = NULL;
        BOOL bDone;
        LARGE_INTEGER Timeout;

        // 600/(100*10(-9)) : negative value is interval, positive is absolute
        Timeout.QuadPart = (LONGLONG) -6000000000;    // Timeout is in 100 nsec, so 6,000,000,000 == 10 min

        do
        {
            BOOL bGrabIt = TRUE;
            bDone = TRUE;

            if (gpsmSpoolHead == NULL)
            {
                LONG    bInfiniteWait = InterlockedExchange(&gpInfiniteWait, FALSE);

                //DbgPrint("\nGDISPOOL(%lx): waiting for message\n",psesc);
                status = KeWaitForSingleObject(
                                gpeventGdiSpool,
                                (KWAIT_REASON)WrExecutive,
                                UserMode,
                                FALSE,
                                (bInfiniteWait ? NULL : &Timeout));

                if(bInfiniteWait)
                    InterlockedExchange(&gpInfiniteWait, TRUE);

                if (status == STATUS_TIMEOUT)
                {
                    SendSimpleMessage(0, GDISPOOL_TERMINATETHREAD, NON_SPOOL_INSTANCE);
                }
                else if (status == STATUS_USER_APC)   // Upon this return, User mode spooler does not execute
                {
                    KeSetEvent(gpeventSpoolerTermination,0,FALSE);
                    return (ULONG) -1;
                }
                else if (!NT_SUCCESS(status))
                {
                    WARNING("GDISPOOL: wait error\n");
                    bGrabIt = FALSE;
                }
            }
            else
            {
                //DbgPrint("\nGDISPOOL(%lx): message already there\n",psesc);
            }

            if (bGrabIt)
            {
                // now find the message and the spoolobj

                LOCKSPOOLER;

                if (gpsmSpoolHead == NULL)
                {
                    bDone = FALSE;
                }
                else
                {
                    psm = gpsmSpoolHead;
                    gpsmSpoolHead = psm->pNext;

                    if (gpsmSpoolHead == NULL)
                        gpsmSpoolTail = NULL;

                    // and some stats

                    ASSERTGDI(gcSpoolMsgCurrent > 0, "GreGetSpoolMsg - invalid count\n");
                    gcSpoolMsgCurrent--;
                    //DbgPrint("    got a message(%lx), hso = %lx - count = %ld\n",psesc,psm->hso,gcSpoolMsgCurrent);
                }

                UNLOCKSPOOLER;
            }

        } while ((psm == NULL) && !bDone);

        // did we get a message?

        if (psm != NULL)
        {
            if (psm->iMsg == GDISPOOL_TERMINATETHREAD || psm->iMsg == GDISPOOL_CLOSEPRINTER)
            {
                // going to terminate the thread so just get out.

                ulRet         = sizeof(SPOOLESC);
                psesc->cj     = sizeof(SPOOLESC);
                psesc->iMsg   = psm->iMsg;
                psesc->hso    = psm->hso;

                if (psm->iMsg & GDISPOOL_API)    // Let API messages have a spool handle
                {
                    psesc->hSpool = psm->hso;

                    if (psm->iMsg & GDISPOOL_CLOSEPRINTER)
                    {
                        psesc->hso = NULL;
                    }
                }

                psesc->cjOut  = 0;
                VFREEMEM(psm);
            }
            else  // Got a non-null, non-TERMINATETHREAD message to send to spooler
            {
                SPOOLALTREF sr(psm->hso);

                if (sr.bValid())
                {
                    if (cjEscData < psm->cjIn)
                    {
                        // set up the header

                        ulRet = offsetof(SPOOLESC, ajData);

                        psesc->cj     = sizeof(SPOOLESC);
                        psesc->iMsg   = GDISPOOL_INPUT2SMALL;
                        psesc->hSpool = sr.pso->hSpool;
                        psesc->hso    = psm->hso;
                        sr.pso->pvMsg = (PVOID)psm;

                        // required message buffer size

                        psesc->cjOut  = psm->cjIn + offsetof(SPOOLESC,ajData);
                    }
                    else
                    {
                        ulRet = ulFinishMessage(psm, psesc, &sr, pjEscData, cjEscData);
                    }
                }
            }
        }
    }

    return(ulRet);
}

/******************************Public*Routine******************************\
* ulFinishMessage()
*
* Fills in psesc structure and impersonates client
*
*
* History:
*  8-Aug-95 -by-  Steve Wilson [swilson]
* Wrote it.
\**************************************************************************/

ULONG
ulFinishMessage(
    PSPOOLMSG    psm,
    PSPOOLESC    psesc,  // this must only be accessed under a try/except
    PSPOOLALTREF psr,
    PBYTE        pjEscData,
    ULONG        cjEscDAta
    )
{
    NTSTATUS status;
    ULONG    ulRet;

    // impersonate the client

    status = SeCreateClientSecurity(
                    psm->pthreadClient,
                    &Sqos,
                    FALSE,
                    &psm->sccSecurity);

    if (NT_SUCCESS(status))
    {
        status = SeImpersonateClientEx(&psm->sccSecurity,NULL);
    }

    if (!NT_SUCCESS(status))
    {
        WARNING("FinishMessage - CreateClientSecurity failed\n");
        psm->pthreadClient = NULL;
    }

    // copy the data

    ulRet = 0;

    if (psm->cjIn)
    {
        __try
        {
            // copy all the buffers into the input buffer

            ulRet = 0;

            for (DWORD i = 0; i < psm->cBuf; ++i)
            {
                RtlCopyMemory(pjEscData+ulRet,psm->apulIn[i],psm->acjIn[i]);
                ulRet     += psm->acjIn[i];
            }

            ASSERTGDI(ulRet == psm->cjIn,"ulFinishMessage - invalid size\n");
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            ulRet = 0;
        }
    }

    // if the input buffer was only temporary, delete it.

    if (psm->fl & SPOOLMSG_DELETE_INBUF)
    {
        ASSERTGDI(psm->cBuf == 1,"ulFinishMessage - delete more than 1\n");

        VFREEMEM(psm->apulIn[0]);
        psm->apulIn[0] = NULL;
    }

    // set up the header

    ulRet += offsetof(SPOOLESC,ajData);

    psesc->iMsg   = psm->iMsg;
    psesc->cj     = ulRet;
    psesc->hSpool = psr->pso->hSpool;
    psesc->cjOut  = psm->cjOut;

    psesc->hso    = psm->hso;
    psr->pso->pvMsg = (PVOID)psm;

    return(ulRet);
}

/******************************Public*Routine******************************\
* GreEscapeSpool()
*
* given a spool message, add it to the queue and notify the spooler thread
*
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL SPOOLREF::GreEscapeSpool()
{
    BOOL bRet = FALSE;
    NTSTATUS status;

    ASSERTGDI(psm()->iMsg != GDISPOOL_TERMINATETHREAD,"GreEscapeSpool - GDISPOOL_TERMINATETHREAD\n");
    ASSERTGDI(psm()->iMsg != GDISPOOL_CLOSEPRINTER,"GreEscapeSpool - GDISPOOL_CLOSEPRINTER\n");
    ASSERTGDI(psm() != NULL,"GreEscapeSpool - null\n");

    //DbgPrint("Entered GreEscapeSpool\n");

    if (!gbInitSpool)
    {
        EngSetLastError(ERROR_NOT_READY);
        WARNING("GreEscapeSpool - not initialized\n");
    }
    else if (pso->dwFlags & NO_CLIENT)
    {
        //DbgPrint(" GreEscapeSpool: NO_CLIENT, message received: %x\n",psm()->iMsg);
        EngSetLastError(ERROR_PROCESS_ABORTED);
    }
    else
    { // add the message to the queue

        //NOTE: we may want to reference count this in the future
        psm()->pthreadClient = PsGetCurrentThread();
        if (AddMessage2Q(psm(), pso->dwSpoolInstance))
        {

            PVOID  pEvent[3];

            pEvent[0] = gpeSpool;
            pEvent[1] = pso->pkevent;
            pEvent[2] = gpeventSpoolerTermination;

            status = KeWaitForMultipleObjects(  3,
                                                pEvent,
                                                WaitAny,
                                                (KWAIT_REASON)0,
                                                UserMode,
                                                FALSE,
                                                0,
                                                NULL);

            switch (status)
            {
                case 0:                 // Spooler terminated
                    SubtractMessageFromQ(psm());
                    EngSetLastError(ERROR_PROCESS_ABORTED);

                    ASSERTGDI(cAltLock() == 0,"GreEscapeSpool - invalid lock 0\n");
                    bRet = FALSE;
                    break;

                case 1:                 // Spooler returned
                    bRet = TRUE;
                    EngSetLastError(psm()->ulErr);

                    ASSERTGDI(cAltLock() == 0,"GreEscapeSpool - invalid lock 1\n");

                    break;

                case STATUS_USER_APC:   // Client terminated
                case 2:                 // Spooler terminated, this client may be the spooler

                    // Stress Failure Note:
                    // AddMessage2Q is called above here to add a message to the message queue.
                    // After the message is in the queue, we leave the spooler lock and set
                    // gpeventGdiSpool, which wakes up the spooler thread.  The spooler thread
                    // then grabs the message and removes it from the message queue inside the spooler
                    // lock.  It then returns to user mode and creates a new message thread.  All this
                    // typically works fine.
                    //
                    // Now suppose just after AddMessage2Q adds a new message and before gpeventGdiSpool
                    // is set, the spooler shuts down.  When the spooler shuts down, STATUS_USER_APC is
                    // returned from the gpeventGdiSpool Wait and all spooler messaging threads will set
                    // gpeventSpoolerTermination, which is case 2 in this switch statement.  This wakes
                    // up the client thread, which proceeds to terminate and frees the psm before exiting.
                    // Meanwhile, the spooler is down to its very last thread and calls vCleanupSpool, which
                    // traverses and frees the psm queue.  vCleanupSpool will AV when it hits one of the freed
                    // messages in the queue.
                    //
                    // The problem was rarely encountered because it would only occur if the spooler shut down
                    // after a message was entered in the queue and before the gpeventGdiSpool event was seen.
                    //
                    // Removing the message from the queue when the spooler or client terminates should solve
                    // the problem.  Note that this was always done for the STATUS_USER_APC case, and has now
                    // been added to case 0 and case 2.
                    //
                    // Steve Wilson (NT)
                    //
                    SubtractMessageFromQ(psm());

                    WARNING("Win32K spool: Client is dying!\n");

                    pso->dwFlags |= NO_CLIENT;
                    EngSetLastError(ERROR_PROCESS_ABORTED);
                    bRet = FALSE;

                    // we need to make sure there is no alt lock

                    pso->pvMsg = NULL;

                    while (cAltLock())
                        KeDelayExecutionThread(KernelMode,FALSE,gpLockShortDelay);

                    break;

                default:
#if 1
                    DbgPrint("GreEscapeSpool - WaitForSingleObject failed w/ status 0x%lx\n", status);
                    DbgBreakPoint();
#else
                    WARNING("GreEscapeSpool - WaitForSingleObject failed\n");
#endif
                    break;
            }
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* SendSimpleMessage()
*
*   allow a client app to send a spool message
*
*
* History:
*  21-Feb-1995 -by-  Eric Kutter [erick]
*  7-Jun-1996 - Steve Wilson [SWilson] - Changed from NtGdiSpoolEsc to SendSimpleMessage
*
\**************************************************************************/

ULONG SendSimpleMessage(
    HANDLE hSpool,
    ULONG iMsg,
    DWORD dwSpoolInstance)
{
    ULONG ulRet = 0;

    if (!gbInitSpool)
    {
        WARNING("GreEscapeSpool - not initialized\n");
    }
    else if (iMsg == GDISPOOL_TERMINATETHREAD || iMsg == GDISPOOL_CLOSEPRINTER)
    {
        PSPOOLMSG psm = (PSPOOLMSG) PALLOCMEM(sizeof(SPOOLMSG),'lpsG');

        if (psm)
        {
            psm->cj = sizeof(SPOOLMSG);
            psm->iMsg = iMsg;
            psm->hso = (HSPOOLOBJ) hSpool;              // This is Spooler's handle, not kernel handle

            ulRet = AddMessage2Q(psm, dwSpoolInstance);
            if (ulRet == FALSE)
                VFREEMEM(psm);
        }
    }

    return ulRet;
}


/*****************************
    SubtractMessageFromQ()
*****************************/

VOID SubtractMessageFromQ(PSPOOLMSG psmIn)
{
    PSPOOLMSG psm;
    PSPOOLMSG psmPrev = NULL;

    //DbgPrint("Enter SubtractMessageFromQ\n");

    LOCKSPOOLER;

    for (psm = gpsmSpoolHead ; psm ; psmPrev = psm , psm = psm->pNext)
    {
        if (psm == psmIn)
        {
            if (psmPrev)
            {
                psmPrev->pNext = psm->pNext;

                if (!psmPrev->pNext)
                {
                    ASSERTGDI(psm == gpsmSpoolTail,"SubtractMessageFromQ: Bad gpsmSpoolTail!\n");
                    gpsmSpoolTail = psmPrev;
                }
            }
            else
            {
                gpsmSpoolHead = psm->pNext;

                if (!gpsmSpoolHead)
                {
                    ASSERTGDI(psm == gpsmSpoolTail,"SubtractMessageFromQ: Bad gpsmSpoolTail!\n");
                    gpsmSpoolTail = gpsmSpoolHead;
                }
            }

            // gcSpool stuff is for debug purposes only
            gcSpoolMsgCurrent--;

            break;
        }
    }

    UNLOCKSPOOLER;
}


/******************************Public*Routine******************************\
* BOOL AddMessage2Q (PSPOOLMSG psm)
*
* History:
*  6-Aug-1995 -by-  Steve Wilson [swilson]
*
\**************************************************************************/

BOOL AddMessage2Q(PSPOOLMSG psm, DWORD dwSpoolInstance)
{
    BOOL bRet = FALSE;

    // add the message to the queue

    LOCKSPOOLER;

    if (psm == NULL)
    {
        bRet = FALSE;
    }
    else if ((dwSpoolInstance != gdwSpoolInstance) && (dwSpoolInstance != NON_SPOOL_INSTANCE))
    {
        EngSetLastError(ERROR_INVALID_HANDLE);
        bRet = FALSE;
    }
    else
    {
        if (gpsmSpoolTail)
        {
            // list isn't empty, so add it to the list

            ASSERTGDI(gpsmSpoolHead != NULL,"GreEscapeSpool - head is null\n");

            gpsmSpoolTail->pNext = psm;
        }
        else
        {
            ASSERTGDI(gpsmSpoolHead == NULL,"GreEscapeSpool - head not null\n");
            gpsmSpoolHead = psm;
        }

        // the tail now always points to the new element

        gpsmSpoolTail = psm;
        psm->pNext = NULL;

        // and some stats

        gcSpoolMsg++;
        gcSpoolMsgCurrent++;
        if (gcSpoolMsgCurrent > gcSpoolMsgMax)
            gcSpoolMsgMax = gcSpoolMsgCurrent;

        bRet = TRUE;
    }

    UNLOCKSPOOLER;

    // notify the spooler that there is a message ready
    if (bRet == TRUE)
    {
        KeSetEvent(gpeventGdiSpool,0,FALSE);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GreOpenPrinterW()
*
* History:
*  28-Mar-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
WINAPI
GreOpenPrinterW(
   GREOPENPRINTER *pOpenPrinter,
   LPHANDLE  phPrinter)
{
    ULONG bRet;
    ULONG ul;

    SPOOLMEMOBJ spmo;           // Creates (PSPOOLOBJ) spmo.pso, containing pkevent, hSpool, pvMsg

    //DbgPrint("Enter GreOpenPrinterW\n");

    if (spmo.bValid())
    {
        // setup the message

        PSPOOLMSG psm = spmo.psm();

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_OPENPRINTER;
        psm->fl       = 0;
        psm->cBuf     = 1;
        psm->cjIn     = pOpenPrinter->cj;
        psm->acjIn[0] = pOpenPrinter->cj;
        psm->apulIn[0]= (PULONG)pOpenPrinter;
        psm->pulOut   = (PULONG)&spmo.pso->hSpool;

        psm->cjOut    = sizeof(*phPrinter);

        psm->hso      = spmo.hGet();            // returns ((HSPOOLOBJ) pso)

        if (spmo.GreEscapeSpool() && psm->ulRet)
        {
            *phPrinter = (HANDLE)spmo.hGet();

            bRet = TRUE;
        }
        else
        {
            spmo.bDelete();
            bRet = FALSE;
        }
    }
    else
    {
       bRet = FALSE;
    }

    return(bRet);
}


/*****************************************************************************
*  GreEnumFormsW
*
*  History:
*   25/7/95 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

BOOL
WINAPI
GreEnumFormsW(
   HANDLE hSpool,
   GREENUMFORMS *pEnumForms,
   GREENUMFORMS *pEnumFormsReturn,
   LONG cjOut )
{
    ULONG bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter GreEnumFormsW\n");

        // setup the message

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_ENUMFORMS;
        psm->fl       = 0;
        psm->cBuf     = 1;
        psm->cjIn     = pEnumForms->cj;
        psm->acjIn[0] = pEnumForms->cj;
        psm->apulIn[0]= (PULONG) pEnumForms;
        psm->pulOut   = (PULONG) pEnumFormsReturn;
        psm->cjOut    = cjOut;
        psm->hso      = (HSPOOLOBJ) hSpool;

        bRet = sr.GreEscapeSpool() ? psm->ulRet : FALSE;
    }

    return bRet;
}

/*****************************************************************************
*  GreGenericW
*
*  History:
*   25-Jul-95 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

BOOL
GreGenericW(
    HANDLE hSpool,
    PULONG pX,
    PULONG pXReturn,
    LONG   cjOut,
    LONG   MessageID,
    ULONG  ulFlag )
{
    ULONG bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter GreGenericW\n");

        // setup the message

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = MessageID;
        psm->fl       = ulFlag;
        psm->cBuf     = 1;
        psm->cjIn     = pX ? *(PULONG) pX : 0;    // Must be sure first element of pX is LONG cj: (pX->cj)
        psm->acjIn[0] = pX ? *(PULONG) pX : 0;    // Must be sure first element of pX is LONG cj: (pX->cj)
        psm->apulIn[0]= (PULONG) pX;
        psm->pulOut   = (PULONG) pXReturn;
        psm->cjOut    = cjOut;
        psm->hso      = (HSPOOLOBJ) hSpool;

        bRet = sr.GreEscapeSpool() ? psm->ulRet : FALSE;
    }

    return bRet;
}

/*****************************************************************************\
*  GrePrinterDriverUnloadW
*
*  This function is used to a send a message to the spooler when a printer
*  driver is unloaded (i.e the DC count on the driver goes to zero)
*  On receipt of this message, the spooler attempts to upgrade the driver if
*  neccesary.
*
*  History:
*   11/17/97 by Ramanathan N Venkatapathy
*  Wrote it.
\*****************************************************************************/

BOOL GrePrinterDriverUnloadW(
    LPWSTR  pDriverName
    )
{
    BOOL      bRet = FALSE;
    ULONG     cbDriverName;
    LPWSTR    pDriverFile = NULL;

    SPOOLMEMOBJ spmo;

    // Check for invalid printer driver names.
    if (!pDriverName || !*pDriverName)
    {
        return bRet;
    }

    // Copy the driver name into another buffer.
    cbDriverName = (wcslen(pDriverName) + 1) * sizeof(WCHAR);
    pDriverFile  = (LPWSTR) PALLOCMEM(cbDriverName, 'lpsG');

    if (spmo.bValid() && pDriverFile)
    {
        PSPOOLMSG psm = spmo.psm();

        memcpy(pDriverFile, pDriverName, cbDriverName);

        psm->cj        = sizeof(SPOOLMSG);
        psm->iMsg      = GDISPOOL_UNLOADDRIVER_COMPLETE;
        psm->fl        = 0;

        psm->cBuf      = 1;
        psm->cjIn      = cbDriverName;
        psm->apulIn[0] = (PULONG) pDriverFile;
        psm->acjIn[0]  = cbDriverName;

        psm->pulOut    = NULL;
        psm->cjOut     = 0;

        psm->hso       = spmo.hGet();

        bRet           = spmo.GreEscapeSpool() && psm->ulRet;

        spmo.bDelete();
    }

    if (pDriverFile) {
        VFREEMEM(pDriverFile);
    }

    return bRet;
}

/*****************************************************************************
*  GreGetPrinterDriverW
*
*  History:
*   4/14/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

BOOL WINAPI GreGetPrinterDriverW(
   HANDLE hSpool,
   GREGETPRINTERDRIVER *pGetPrinterDriver,
   GREGETPRINTERDRIVER *pGetPrinterDriverReturn,
   LONG cjOut
   )
{
    ULONG bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter GreGetPrinterDriverW\n");

        // setup the message

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_GETPRINTERDRIVER;
        psm->fl       = 0;
        psm->cBuf     = 1;
        psm->cjIn     = pGetPrinterDriver->cj;
        psm->acjIn[0] = pGetPrinterDriver->cj;
        psm->apulIn[0]= (PULONG) pGetPrinterDriver;
        psm->pulOut   = (PULONG)pGetPrinterDriverReturn;
        psm->cjOut    = cjOut;
        psm->hso      = (HSPOOLOBJ)hSpool;

        if( sr.GreEscapeSpool() )
        {
            bRet = psm->ulRet;
        }
        else
        {
            bRet = FALSE;
        }
    }

    return(bRet);
}

/****************************************************************************
*  BOOL StartPagePrinter( HANDLE hPrinter )
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL
WINAPI
StartPagePrinter(
    HANDLE hSpool
    )
{
    BOOL bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter StartPagePrinter\n");

        psm->cj      = sizeof(SPOOLMSG);
        psm->iMsg    = GDISPOOL_STARTPAGEPRINTER;
        psm->fl      = 0;
        psm->cBuf    = 0;
        psm->cjIn    = 0;
        psm->pulOut  = NULL;
        psm->cjOut   = 0;
        psm->hso     = (HSPOOLOBJ)hSpool;

        if( sr.GreEscapeSpool() )
        {
            bRet = psm->ulRet;
        }
    }

    return(bRet);
}


/****************************************************************************
*  BOOL EndPagePrinter( HANDLE hPrinter )
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL
WINAPI
EndPagePrinter(
    HANDLE hSpool
    )
{
    BOOL bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        //DbgPrint("Enter EndPagePrinter\n");

        psm->cj      = sizeof(SPOOLMSG);
        psm->iMsg    = GDISPOOL_ENDPAGEPRINTER;
        psm->fl      = 0;
        psm->cBuf    = 0;
        psm->cjIn    = 0;
        psm->pulOut  = NULL;
        psm->cjOut   = 0;
        psm->hso     = (HSPOOLOBJ)hSpool;

        if(sr.GreEscapeSpool())
        {
            bRet = psm->ulRet;
        }
    }

    return(bRet);

}


/****************************************************************************
*  BOOL EndDocPrinter( HANDLE hPrinter )
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

BOOL
WINAPI
EndDocPrinter(
    HANDLE hSpool
    )
{
    BOOL bRet = FALSE;
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();


        //DbgPrint("Enter EndDocPrinter\n");

        psm->cj      = sizeof(SPOOLMSG);
        psm->iMsg    = GDISPOOL_ENDDOCPRINTER;
        psm->fl      = 0;
        psm->cBuf    = 0;
        psm->cjIn    = 0;
        psm->pulOut  = NULL;
        psm->cjOut   = 0;
        psm->hso     = (HSPOOLOBJ)hSpool;

        if( sr.GreEscapeSpool() )
        {
            bRet = (DWORD) psm->ulRet;
        }
    }

    return(bRet);

}


/****************************************************************************
*  ClosePrinter( HANDLE hPrinter )
*
*  History:
*   12-Feb-1996 -by- Steve Wilson (swilson)
*  Wrote it.
*****************************************************************************/

BOOL
WINAPI
ClosePrinter(
    HANDLE hSpool
    )
{
    SPOOLREF sr(hSpool);

    if (sr.bValid())
    {
        //DbgPrint("Enter ClosePrinter: %d\n", sr.pso->hSpool);

        SendSimpleMessage(sr.pso->hSpool, GDISPOOL_CLOSEPRINTER, sr.pso->dwSpoolInstance);

        sr.bDelete();
    }

    return TRUE;
}


/******************************Public*Routine******************************\
* AbortPrinter()
*
* History:
*  18-Jul-1995 -by-  Steve Wilson (swilson)
* Wrote it.
\**************************************************************************/

BOOL
WINAPI
AbortPrinter(
    HANDLE   hPrinter)
{
    BOOL bRet = FALSE;
    SPOOLREF sr(hPrinter);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();


        //DbgPrint("Enter AbortPrinter\n");

        psm->cj      = sizeof(SPOOLMSG);
        psm->iMsg    = GDISPOOL_ABORTPRINTER;
        psm->fl      = 0;
        psm->cBuf    = 0;
        psm->cjIn    = 0;
        psm->pulOut  = NULL;
        psm->cjOut   = 0;
        psm->hso     = (HSPOOLOBJ)hPrinter;

        if( sr.GreEscapeSpool() )
        {
            bRet = (DWORD) psm->ulRet;
        }
    }

    return(bRet);
}



/****************************************************************************
* StartDocPrinter()
*
*  History:
*   4/28/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*****************************************************************************/

DWORD
WINAPI
StartDocPrinterW(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbDocInfo
   )
{
    LONG cj = offsetof(GRESTARTDOCPRINTER,alData);
    LONG cjDocName = 0;
    LONG cjOutputFile = 0;
    LONG cjDatatype = 0;
    DOC_INFO_1W* pDocInfo = (DOC_INFO_1W*) lpbDocInfo;
    DWORD ret = 0;

    //DbgPrint("Enter StartDocPrinterW\n");

    ASSERTGDI( dwLevel == 1, "StartDocPrinter: dwLevel != 1\n" );
    ASSERTGDI( lpbDocInfo != NULL, "StarDocPrinter lpbDocInfo is NULL\n");

    // first we need to compute the sizes.

    if (pDocInfo->pDocName)
    {
        cjDocName = (wcslen(pDocInfo->pDocName) + 1) * sizeof(WCHAR);

        cj += cjDocName;
        cj = (cj + 3) & ~3;
    }

    if (pDocInfo->pOutputFile)
    {
        cjOutputFile = (wcslen(pDocInfo->pOutputFile) + 1) * sizeof(WCHAR);

        cj += cjOutputFile;
        cj = (cj + 3) & ~3;
    }

    if (pDocInfo->pDatatype)
    {
        cjDatatype = (wcslen(pDocInfo->pDatatype) + 1) * sizeof(WCHAR);

        cj += cjDatatype;
        cj = (cj + 3) & ~3;
    }


    SPOOLREF sr(hPrinter);

    if (sr.bValid())
    {
        PLONG plData;

        GRESTARTDOCPRINTER *pStartDocPrinter;
        pStartDocPrinter = (GRESTARTDOCPRINTER*)PALLOCNOZ(cj,'lpsG');

        if (pStartDocPrinter)
        {
            PSPOOLMSG psm = sr.psm();

            // we got memory, now copy the stuff in

            pStartDocPrinter->cj = cj;
            plData = pStartDocPrinter->alData;

            pStartDocPrinter->cjDocName  = (cjDocName     + 3) & ~3;
            pStartDocPrinter->cjOutputFile = (cjOutputFile + 3) & ~3;
            pStartDocPrinter->cjDatatype  = (cjDatatype  + 3) & ~3;

            if (pDocInfo->pDocName)
            {
                memcpy(plData,pDocInfo->pDocName,cjDocName);
                plData += (cjDocName+3)/4;
            }

            if (pDocInfo->pOutputFile)
            {
                memcpy(plData,pDocInfo->pOutputFile,cjOutputFile);
                plData += (cjOutputFile+3)/4;
            }

            if (pDocInfo->pDatatype)
            {
                memcpy(plData,pDocInfo->pDatatype,cjDatatype);
                plData += (cjDatatype+3)/4;
            }

            ASSERTGDI(POFFSET(pStartDocPrinter,plData) == cj,
                        "EngStartDocPrinter - sizes are wrong\n");

            // pStartDocPrinter now contains all needed data, call out
            // setup the message

            psm->cj       = sizeof(SPOOLMSG);
            psm->iMsg     = GDISPOOL_STARTDOCPRINTER;
            psm->fl       = 0;
            psm->cBuf     = 1;
            psm->cjIn     = pStartDocPrinter->cj;
            psm->acjIn[0] = pStartDocPrinter->cj;
            psm->apulIn[0]= (PULONG)pStartDocPrinter;
            psm->pulOut   = NULL;
            psm->cjOut    = 0;
            psm->hso      = (HSPOOLOBJ)hPrinter;

            if( sr.GreEscapeSpool() )
            {
                ret = (DWORD) psm->ulRet;
            }

            VFREEMEM(pStartDocPrinter);
        }
    }

    return(ret);

}



/******************************Public*Routine******************************\
* OpenPrinterW()
*
* History:
*  05-Apr-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
WINAPI
OpenPrinterW(
   LPWSTR    pPrinterName,
   LPHANDLE  phPrinter,
   LPPRINTER_DEFAULTSW pDefault)
{
    LONG cjName     = 0;
    LONG cjDatatype = 0;
    LONG cjDevMode  = 0;
    LONG cj         = offsetof(GREOPENPRINTER,alData);
    BOOL bRet       = FALSE;

    PLONG plData;

    GREOPENPRINTER  *pOpenPrinter;

    //DbgPrint("Enter OpenPrinterW\n");

    // first we need to compute the sizes.

    if (pPrinterName)
    {
        cjName = (wcslen(pPrinterName) + 1) * sizeof(WCHAR);

        cj += cjName;
        cj = (cj + 3) & ~3;
    }

    if (pDefault)
    {
        if (pDefault->pDatatype)
        {
            cjDatatype = (wcslen(pDefault->pDatatype) + 1) * sizeof(WCHAR);

            cj += cjDatatype;
            cj = (cj + 3) & ~3;
        }

        if (pDefault->pDevMode)
        {

            //DbgPrint("cjMinDevmode = %d, dmSize = %d, dmDriverExtra = %d\n", MIN_DEVMODE_SIZE, pDefault->pDevMode->dmSize, pDefault->pDevMode->dmDriverExtra);

            cjDevMode = pDefault->pDevMode->dmSize + pDefault->pDevMode->dmDriverExtra;

            if (cjDevMode < MIN_DEVMODE_SIZE)
            {
                EngSetLastError(ERROR_INVALID_PARAMETER);
                return bRet;
            }

            cj += cjDevMode;
            cj = (cj + 3) & ~3;
        }

    }

    // allocate the memory

    pOpenPrinter = (GREOPENPRINTER*)PALLOCNOZ(cj,'lpsG');

    if (pOpenPrinter)
    {
        // we got memory, now copy the stuff in

        pOpenPrinter->cj = cj;
        pOpenPrinter->pd = *pDefault;
        plData = pOpenPrinter->alData;

        pOpenPrinter->cjName     = (cjName     + 3) & ~3;
        pOpenPrinter->cjDatatype = (cjDatatype + 3) & ~3;
        pOpenPrinter->cjDevMode  = (cjDevMode  + 3) & ~3;

        if (pPrinterName)
        {
            memcpy(plData,pPrinterName,cjName);
            plData += (cjName+3)/4;
        }

        if (pDefault)
        {
            if (pDefault->pDatatype)
            {
                pOpenPrinter->pd.pDatatype = (WCHAR*)POFFSET(pOpenPrinter,plData);
                memcpy(plData,pDefault->pDatatype,cjDatatype);
                plData += (cjDatatype+3)/4;
            }

            if (pDefault->pDevMode)
            {
                pOpenPrinter->pd.pDevMode = (PDEVMODEW)POFFSET(pOpenPrinter,plData);
                memcpy(plData,pDefault->pDevMode,cjDevMode);
                plData += (cjDevMode+3)/4;
            }
        }

        ASSERTGDI(POFFSET(pOpenPrinter,plData) == cj,
                    "EngOpenPrinter - sizes are wrong\n");

        // pOpenPrinter now contains all needed data, call out

        bRet = GreOpenPrinterW(pOpenPrinter,phPrinter);


        VFREEMEM(pOpenPrinter);
    }

    return(bRet);
}

/*******************************************************************************
*  void MarshallUpStructure( LPBYTE  lpStructure, LPDWORD lpOffsets )
*
*  This routine does pointer adjustment to offsets within the buffer
*
*  History:
*   6/30/1995 by Muhunthan Sivapragasam (MuhuntS)
*  Got from spoolss code
*******************************************************************************/

void
MarshallUpStructure(
    LPBYTE  lpStructure,
    LPDWORD lpOffsets
    )
{
   register DWORD       i=0;

   while (lpOffsets[i] != -1) {

      if ((*(LPBYTE *)(lpStructure+lpOffsets[i]))) {
         (*(LPBYTE *)(lpStructure+lpOffsets[i]))+=(ULONG_PTR)lpStructure;
      }

      i++;
   }
}

/*******************************************************************************
*  BOOL ValidateString( LPWSTR pString, PBYTE pBuffer, LONG cjLength )
*
*  This routine validates a LPWSTR to make sure that it really lies inside of a buffer.
*
*  History:
*   4/19/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

BOOL
ValidateString(
    LPWSTR pString,
    PBYTE pBuffer,
    LONG cjLength )
{
    LPWSTR pEnd = (LPWSTR) ( pBuffer + cjLength );

    if( pString > pEnd || pString < (LPWSTR) pBuffer )
    {
        return(FALSE);
    }

    while( *pString && pString < pEnd )
    {
        pString++;
    }

    return( pString < pEnd );

}

/*******************************************************************************
*  BOOL ValidateStrings( LPBYTE  lpStructure, LPDWORD lpOffsets, LONG cjLength )
*
*  This routine validates all the strings in the structure to make sure they really lie inside of a buffer.
*
*  History:
*   6/30/1995 by Muhunthan Sivapragasam (MuhuntS)
*  Wrote it.
*******************************************************************************/
BOOL
ValidateStrings(
    LPBYTE  lpStructure,
    LPDWORD lpOffsets,
    LONG    cjLength
    )
{
   register DWORD       i=0;

   while (lpOffsets[i] != -1)
   {

        if ( (*(LPWSTR *) (lpStructure+lpOffsets[i])) &&
             !ValidateString(*(LPWSTR *) (lpStructure+lpOffsets[i]),
                             lpStructure,
                             cjLength) )
        {
            return FALSE;
        }

      i++;
   }

   return TRUE;
}

/*******************************************************************************
*  BOOL ValidateDependentFiles( LPWSTR pString, PBYTE pBuffer, LONG cjLength )
*
*  This routine validates DependentFiles field (which is a list of strings
*  up to \0\0) to make sure that it really lies inside of a buffer.
*
*  History:
*   6/30/1995 by Muhunthan Sivapragasam
*  Wrote it.
*******************************************************************************/

BOOL
ValidateDependentFiles(
    LPWSTR pString,
    PBYTE pBuffer,
    LONG cjLength )
{
    LPWSTR pEnd = (LPWSTR) ( pBuffer + cjLength );

    if( pString > pEnd || pString < (LPWSTR) pBuffer )
    {
        return(FALSE);
    }

    while( ( *pString || *(pString+1) ) && pString < pEnd )
    {
        pString++;
    }

    return( pString < pEnd );
}

/*******************************************************************************
* EngEnumForms()
*
*  History:
*  7/24/1995 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

BOOL
WINAPI
EngEnumForms(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  lpbForms,
    DWORD   cbBuf,
    LPDWORD pcbNeeded,
    LPDWORD pcbReturned
)
{
    LONG cj;
    DWORD cjReturn;
    BOOL bRet = FALSE;
    GREENUMFORMS *pEnumForms, *pEnumFormsReturn;

    //DbgPrint("Enter EngEnumFormsW\n");

    if(!pcbNeeded || !pcbReturned)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cj = sizeof(GREENUMFORMS);

    // Allocate TO buffer
    pEnumForms = (GREENUMFORMS *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pEnumForms) {

        pEnumForms->cj = cj;
        pEnumForms->cjData = cbBuf;
        pEnumForms->dwLevel = dwLevel;

        // Allocate RETURN buffer
        pEnumFormsReturn = (GREENUMFORMS *) PALLOCNOZ(cjReturn = sizeof(GREENUMFORMS) + cbBuf, 'lpsG');

        // SEND MESSAGE
        if (pEnumFormsReturn) {
            bRet = GreEnumFormsW(hPrinter, pEnumForms, pEnumFormsReturn, cjReturn);

            // Fill in return sizes
            *pcbNeeded = pEnumFormsReturn->cjData;          // # return data bytes
            *pcbReturned = pEnumFormsReturn->nForms;        // # forms in return data

            // UnMarshall Message
            if (bRet) {

                ASSERTGDI(*pcbNeeded <= cbBuf,"EnumFormsW - error\n");

                if (lpbForms && *pcbNeeded <= cbBuf) {
                    // Copy returned data into supplied FORM_INFO_1 structure
                    memcpy(lpbForms, pEnumFormsReturn->alData, pEnumFormsReturn->cjData);

                    DWORD   i;

                    for (i = 0 ; i < *pcbReturned ; ++i, lpbForms += sizeof(FORM_INFO_1W)) {
                        MarshallUpStructure(lpbForms, FormInfo1Offsets);
                    }
                }
            }
            VFREEMEM(pEnumFormsReturn);
        }
        VFREEMEM(pEnumForms);
    }
    return bRet;
}

/*******************************************************************************
* EngGetPrinter()
*
*  History:
*  9/30/1995 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/
BOOL
WINAPI
EngGetPrinter(
    HANDLE  hPrinter,
    DWORD   dwLevel,
    LPBYTE  pPrinter,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LONG cj;
    DWORD cjReturn;
    BOOL bRet = FALSE;
    GREGETPRINTER *pGetPrinter, *pGetPrinterReturn;

    DWORD   *pOffsets;


    //DbgPrint("Enter EngGetPrinter\n");

    if (!pcbNeeded)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    switch (dwLevel)
    {
        case 1:
            pOffsets = PrinterInfo1Offsets;
            break;

        case 2:
            pOffsets = PrinterInfo2Offsets;
            break;

        case 3:
            pOffsets = PrinterInfo3Offsets;
            break;

        case 4:
            pOffsets = PrinterInfo4Offsets;
            break;

        case 5:
            pOffsets = PrinterInfo5Offsets;
            break;

        default:
            EngSetLastError(ERROR_INVALID_LEVEL);
            return FALSE;
    }


    cj = sizeof(GREGETPRINTER);

    // Allocate TO buffer
    pGetPrinter = (GREGETPRINTER *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pGetPrinter)
    {

        pGetPrinter->cj = cj;
        pGetPrinter->cjData = cbBuf;
        pGetPrinter->dwLevel = dwLevel;

        // Allocate RETURN buffer
        pGetPrinterReturn = (GREGETPRINTER *) PALLOCNOZ(cjReturn = sizeof(GREGETPRINTER) + cbBuf, 'lpsG');

        // SEND MESSAGE
        if (pGetPrinterReturn)
        {
            bRet = GreGenericW(hPrinter, (PULONG) pGetPrinter, (PULONG) pGetPrinterReturn, cjReturn, GDISPOOL_GETPRINTER, 0);

            // Fill in return size
            *pcbNeeded = pGetPrinterReturn->cjData;

            // UnMarshall Message
            if (bRet)
            {
                ASSERTGDI(*pcbNeeded <= cbBuf,"EngGetPrinter - error\n");

                if (pPrinter && *pcbNeeded <= cbBuf)
                {
                    memcpy(pPrinter, pGetPrinterReturn->alData, pGetPrinterReturn->cjData);
                    MarshallUpStructure(pPrinter, pOffsets);
                }
            }
            VFREEMEM(pGetPrinterReturn);
        }
        VFREEMEM(pGetPrinter);
    }
    return bRet;
}

/*******************************************************************************
* EngGetForm()
*
*  History:
*  7/24/1995 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

BOOL
WINAPI
EngGetForm(
    HANDLE  hPrinter,
    LPWSTR  pFormName,
    DWORD   dwLevel,
    LPBYTE  lpbForm,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    LONG cj, cjFormName;
    DWORD cjReturn;
    BOOL bRet = FALSE;
    GREGETFORM    *pGetForm, *pGetFormReturn;

    //DbgPrint("Enter EngGetForm\n");

    if (!pcbNeeded)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Accumulate sizes of base struct plus strings
    cj = sizeof(GREGETFORM);
    cj += (cjFormName = pFormName ? (wcslen(pFormName) + 1)*sizeof *pFormName : 0);

    // Allocate TO buffer
    pGetForm = (GREGETFORM *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pGetForm)
    {
        pGetForm->cj = cj;
        pGetForm->cjData = cbBuf;
        pGetForm->dwLevel = dwLevel;

        if (pFormName)
        {
            memcpy(pGetForm->alData,pFormName,cjFormName);
        }

        // Allocate RETURN buffer
        pGetFormReturn = (GREGETFORM *) PALLOCNOZ(cjReturn = sizeof(GREGETFORM) + cbBuf, 'lpsG');

        // SEND MESSAGE
        if (pGetFormReturn)
        {
            bRet = GreGenericW(hPrinter, (PULONG) pGetForm, (PULONG) pGetFormReturn, cjReturn, GDISPOOL_GETFORM, 0);

            if (bRet)
            {

                // Fill in return sizes
                *pcbNeeded = pGetFormReturn->cjData;          // # return data bytes

                // UnMarshall Message
                if (lpbForm && bRet)
                {

                    if (*pcbNeeded <= cbBuf)
                        memcpy(lpbForm, pGetFormReturn->alData, pGetFormReturn->cjData);
                    else
                        ASSERTGDI(*pcbNeeded <= cbBuf,"GetFormW - error\n");

                    MarshallUpStructure(lpbForm, FormInfo1Offsets);

                }
            }
            VFREEMEM(pGetFormReturn);
        }
        VFREEMEM(pGetForm);
    }
    return bRet;

}

/*******************************************************************************
* GetPrinterDriverW()
*
*  History:
*   4/19/1995 by Gerrit van Wingerden [gerritv]
*  Wrote it.
*******************************************************************************/

BOOL WINAPI GetPrinterDriverW(
    HANDLE  hPrinter,
    LPWSTR  pEnvironment,
    DWORD   dwLevel,
    LPBYTE  lpbDrvInfo,
    DWORD   cbBuf,
    LPDWORD pcbNeeded
)
{
    BOOL bRet = FALSE;
    LONG cj, cjEnvironment;
    DWORD *pOffsets, *pStrings;

    //DbgPrint("Enter GetPrinterDriverW\n");

    if (!pcbNeeded)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    cj = sizeof(GREGETPRINTERDRIVER);
    cjEnvironment = 0;

    *pcbNeeded = 0;

    if( pEnvironment )
    {
        cjEnvironment += (wcslen(pEnvironment) + 1) * sizeof(WCHAR);
    }

    cj += cjEnvironment;

    GREGETPRINTERDRIVER *pGetPrinterDriver;

    pGetPrinterDriver = (GREGETPRINTERDRIVER*)PALLOCMEM(cj, 'lpsG');

    if( pGetPrinterDriver )
    {
        pGetPrinterDriver->cj      = cj;
        pGetPrinterDriver->cjData  = cbBuf;
        pGetPrinterDriver->dwLevel = dwLevel;

        if( pEnvironment )
        {
            memcpy(pGetPrinterDriver->alData,pEnvironment,cjEnvironment);
        }

        GREGETPRINTERDRIVER *pGetPrinterDriverReturn = NULL;
        UINT cjSize = cbBuf + sizeof(GREGETPRINTERDRIVER);

        pGetPrinterDriverReturn = (GREGETPRINTERDRIVER*) PALLOCNOZ(cjSize, 'lpsG');

        if( pGetPrinterDriverReturn )
        {
            bRet = GreGetPrinterDriverW(hPrinter,pGetPrinterDriver, pGetPrinterDriverReturn, cjSize );

            DWORD cjData = pGetPrinterDriverReturn->cjData;

            if (bRet == FALSE)
            {
                if (cjData > cbBuf)
                {
                    // need to return the size needed.

                    *pcbNeeded = pGetPrinterDriverReturn->cjData;
                }
            }
            else
            {
                ASSERTGDI(cjData <= cbBuf,"GetPrinterDriverW - error\n");

                // return the size needed whether everything fits or not

                *pcbNeeded = cjData;

                // only copy data and return success if everything fits
                switch (dwLevel) {
                    case 1:
                        pOffsets = DriverInfo1Offsets;
                        pStrings = DriverInfo1Strings;
                        break;

                    case 2:
                        pOffsets = DriverInfo2Offsets;
                        pStrings = DriverInfo2Strings;
                        break;

                    case 3:
                        pOffsets = DriverInfo3Offsets;
                        pStrings = DriverInfo3Strings;
                        break;

                    default:
                        // We should not get here
                        ASSERTGDI(0, "GetPrinterDriverW invalid level\n");
                }

                if (lpbDrvInfo)
                {
                    memcpy( lpbDrvInfo, pGetPrinterDriverReturn->alData, cjData );
                    MarshallUpStructure((LPBYTE)lpbDrvInfo, pOffsets);
                    if ( !ValidateStrings((LPBYTE)lpbDrvInfo, pStrings, cjData) ||
                         (dwLevel == 3 &&
                          ((PDRIVER_INFO_3W) lpbDrvInfo)->pDependentFiles &&
                          !ValidateDependentFiles(((PDRIVER_INFO_3W) lpbDrvInfo)->pDependentFiles,
                                                  (LPBYTE)lpbDrvInfo, cjData) ) ) {
                        WARNING("GetPrinterDriverW: String does not fit in buffer\n");
                        bRet = FALSE;
                    }
                }
            }

            VFREEMEM(pGetPrinterDriverReturn);
        }

        VFREEMEM(pGetPrinterDriver);
    }
    return(bRet);
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   EngGetPrinterDriver
*
* Routine Description:
*
* Arguments:
*
* Called by:
*
* Return Value:
*
\**************************************************************************/

extern "C" BOOL APIENTRY EngGetPrinterDriver(
    HANDLE  hPrinter
  , LPWSTR  pEnvironment
  , DWORD   dwLevel
  , BYTE   *lpbDrvInfo
  , DWORD   cbBuf
  , DWORD  *pcbNeeded
    )
{
    BOOL ReturnValue;
    ReturnValue = GetPrinterDriverW(
                      hPrinter
                    , pEnvironment
                    , dwLevel
                    , lpbDrvInfo
                    , cbBuf
                    , pcbNeeded
                      );
    return( ReturnValue );
}


/*******************************************************************************
* EngGetPrinterDataW()
*
*  History:
*   25-Jul-95 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

DWORD
WINAPI
EngGetPrinterData(
   HANDLE   hPrinter,       // IN
   LPWSTR   pValueName,     // IN
   LPDWORD  pType,          // OUT -- may be NULL
   LPBYTE   lpbData,        // OUT
   DWORD    cbBuf,          // IN
   LPDWORD  pcbNeeded       // OUT
)
{
    LONG cj, cjValueName;
    DWORD cjReturn;
    DWORD dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    GREGETPRINTERDATA    *pX, *pXReturn;

    //DbgPrint("Enter EngGetPrinterData\n");

    if (!pcbNeeded)
    {
        EngSetLastError(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // Accumulate sizes of base struct plus strings
    cj = sizeof *pX;
    cj += (cjValueName = pValueName ? (wcslen(pValueName) + 1)*sizeof *pValueName : 0);

    // Allocate TO buffer
    pX = (GREGETPRINTERDATA *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pX)
    {

        pX->cj = cj;
        pX->cjData = cbBuf;        // Client's buffer size

        // Write strings at end of GRE struct
        if (pValueName) {
            memcpy(pX->alData,pValueName,cjValueName);
            pX->cjValueName = cjValueName;
        }

        // Allocate RETURN buffer
        pXReturn = (GREGETPRINTERDATA *) PALLOCNOZ(cjReturn = sizeof *pX + cbBuf, 'lpsG');

        // SEND MESSAGE
        if (pXReturn)
        {
            // GreGenericW return value indicates success or failure of GreEscapeSpool() and KMGetPrinterData()
            GreGenericW( hPrinter,
                        (PULONG) pX,
                        (PULONG) pXReturn,
                        cjReturn,
                        (LONG) GDISPOOL_GETPRINTERDATA, 0);

            dwLastError = EngGetLastError();

            // return from GreGenericW may be 0, meaning any number of things, including ERROR_MORE_DATA
            if (dwLastError != ERROR_PROCESS_ABORTED)
            {
                // Fill in return sizes
                if (pcbNeeded)
                {
                   *pcbNeeded = pXReturn->dwNeeded;          // # return data bytes

                    //DbgPrint("EngGetPrinterData *pcbNeeded = %d\n", *pcbNeeded);
                }

                if (pType)
                    *pType = pXReturn->dwType;

                if (dwLastError == ERROR_SUCCESS)
                {
                    // Copy returned data into supplied structure
                    if (lpbData)
                    {
                        if ((DWORD) pXReturn->cjData <= cbBuf)
                            memcpy(lpbData, pXReturn->alData, pXReturn->cjData);
                        else
                            ASSERTGDI((DWORD) pXReturn->cjData <= cbBuf, "GetPrinterDataW - Bad spooler buffer size\n");
                    }
                }
            }

            VFREEMEM(pXReturn);
        }
        VFREEMEM(pX);
    }

    //DbgPrint("GetPrinterData return: %d\n", dwLastError);

    return dwLastError;
}



/*******************************************************************************
* EngSetPrinterData()
*
*  History:
*   25-Oct-95 by Steve Wilson [swilson]
*  Wrote it.
*******************************************************************************/

DWORD
WINAPI
EngSetPrinterData(
   HANDLE   hPrinter,           // IN
   LPWSTR   pType,              // IN
   DWORD    dwType,             // IN
   LPBYTE   lpbPrinterData,     // IN
   DWORD    cjPrinterData       // IN
)
{
    LONG cj, cjType;
    DWORD cjReturn;
    DWORD dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    GRESETPRINTERDATA    *pTo, *pFrom;

    //DbgPrint("Enter EngSetPrinterData\n");

    // Accumulate sizes of base struct plus strings
    cj = sizeof *pTo;
    cj += (cjType = pType ? (wcslen(pType) + 1)*sizeof *pType : 0);
    cj += lpbPrinterData ? cjPrinterData : 0;

    // Allocate TO buffer
    pTo = (GRESETPRINTERDATA *) PALLOCMEM(cj, 'lpsG');

    // Marshall TO buffer
    if (pTo)
    {

        pTo->cj = cj;

        // Write incoming data at end of GRE struct
        if (pType) {
            memcpy(pTo->alData,pType,cjType);
            pTo->cjType = cjType;
        }

        if (lpbPrinterData) {
            memcpy((BYTE *)pTo->alData + cjType,lpbPrinterData,cjPrinterData);
            pTo->cjPrinterData = cjPrinterData;
        }


        // Allocate RETURN buffer
        pFrom = (GRESETPRINTERDATA *) PALLOCNOZ(cjReturn = sizeof *pTo, 'lpsG');

        // SEND MESSAGE
        if (pFrom)
        {
            pTo->dwType = dwType;

            // GreGenericW return value indicates success or failure of GreEscapeSpool() and KMGetPrinterData()
            GreGenericW( hPrinter,
                        (PULONG) pTo,
                        (PULONG) pFrom,
                        cjReturn,
                        (LONG) GDISPOOL_SETPRINTERDATA, 0);

            dwLastError = EngGetLastError();

            VFREEMEM(pFrom);
        }
        VFREEMEM(pTo);
    }

    //DbgPrint("GetPrinterData return: %d\n", dwLastError);

    return dwLastError;
}




/******************************Public*Routine******************************\
*
*
* History:
*  27-Feb-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL
WINAPI
EngWritePrinter(
    HANDLE  hPrinter,
    LPVOID  pBuf,
    DWORD   cbBuf,
    LPDWORD pcWritten
)
{
    DWORD ulRet = 0;
    SPOOLREF sr(hPrinter);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();
        LPVOID pKmBuf = NULL;

        GREWRITEPRINTER *wp = &sr.pso->WritePrinter;

        //DbgPrint("Enter EngWritePrinter\n");

        wp->cj = offsetof(GREWRITEPRINTER,alData) + cbBuf;
        wp->cjData = cbBuf;

        if (gpeSpool == PsGetCurrentProcess() &&
            pBuf <= MM_HIGHEST_USER_ADDRESS &&
            pBuf >= MM_LOWEST_USER_ADDRESS)
        {
            wp->pUserModeData = (PULONG) pBuf;
            wp->cjUserModeData = cbBuf;
            psm->cBuf = 1;
            psm->cjIn = offsetof(GREWRITEPRINTER, alData);
        }
        else
        {
            //
            // if we recevie a user mode buffer, make a kernel copy.
            // This is to patch PSCRIPT 4 driver running on NT5.
            //

            if (pBuf <= MM_HIGHEST_USER_ADDRESS &&
                pBuf >= MM_LOWEST_USER_ADDRESS)
            {
                if (pKmBuf = PALLOCNOZ(cbBuf,'lpsG'))
                {
                   __try
                   {
                       ProbeAndReadBuffer(pKmBuf,pBuf,cbBuf);
                   }
                   __except(EXCEPTION_EXECUTE_HANDLER)
                   {
                       VFREEMEM(pKmBuf);
                       return (FALSE);
                   }

                   pBuf = pKmBuf;
                }
                else
                {
                   WARNING ("failed to allocate memory in EngWritePrinter\n");
                   return (FALSE);
                }
            }

            wp->pUserModeData = NULL;
            wp->cjUserModeData = 0;
            psm->cBuf = 2;
            psm->apulIn[1]= (PULONG)pBuf;
            psm->acjIn[1] = cbBuf;
            psm->cjIn = wp->cj;
        }


        // setup the message

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_WRITE;
        psm->fl       = 0;

        // there are two buffers, one for the GREWRITEPRINTER header and one
        // for the data.

        psm->apulIn[0]= (PULONG)wp;
        psm->acjIn[0] = offsetof(GREWRITEPRINTER,alData);

        // place the return value in ulRet

        psm->pulOut   = &sr.pso->dwWritePrinterReturn;
        psm->cjOut    = sizeof(sr.pso->dwWritePrinterReturn);
        psm->hso      = (HSPOOLOBJ)hPrinter;

        if (!sr.GreEscapeSpool())
        {
            ulRet = 0;
        }
        else
        {
            ulRet = sr.pso->dwWritePrinterReturn;
        }

        if (pcWritten)
            *pcWritten = ulRet;

        if (pKmBuf)
        {
            VFREEMEM(pKmBuf);
        }
    }

    // return TRUE or FALSE

    return(!!ulRet);
}

/*******************************************************************************
 * BOOL GetFontPathName( WCHAR *pFullPath, WCHAR *pFileName )
 *
 * Goes to the spooler and does a search path in the font path to find the
 * full path given a font file name.  We expect pFullName and pFileName to
 * point to the same piece of memory although we don't require this to be the case.
 *
 * History
 *   7-31-95 Gerrit van Wingerden [gerritv]
 * Wrote it.
 *
 *******************************************************************************/

BOOL GetFontPathName( WCHAR *pFullPath, WCHAR *pFileName )
{
    BOOL bRet = FALSE;
    SPOOLMEMOBJ spmo;

    if (spmo.bValid())
    {
        PSPOOLMSG psm = spmo.psm();

        psm->cj        = sizeof(SPOOLMSG);
        psm->iMsg      = GDISPOOL_GETPATHNAME;
        psm->fl        = 0;

        psm->cBuf      = 1;
        psm->cjIn      = (wcslen(pFileName) + 1) * sizeof(WCHAR);
        psm->apulIn[0] = (PULONG) pFileName;
        psm->acjIn[0]  = psm->cjIn;

        psm->pulOut    = (PULONG) pFullPath;
        psm->cjOut     = sizeof(WCHAR) * (MAX_PATH+1);

        psm->hso       = spmo.hGet();

        bRet           = spmo.GreEscapeSpool() && psm->ulRet;

        spmo.bDelete();
    }

    return(bRet);

}

/******************************Public*Routine******************************\
* EngEscape()
*
* History:
*  18-Sep-1995 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

ULONG APIENTRY EngEscape(
    HANDLE   hPrinter,
    ULONG    iEsc,
    ULONG    cjIn,
    PVOID    pvIn,
    ULONG    cjOut,
    PVOID    pvOut)
{
    BOOL ulRet = FALSE;
    SPOOLREF sr(hPrinter);

    if (sr.bValid())
    {
        PSPOOLMSG psm = sr.psm();

        psm->cj       = sizeof(SPOOLMSG);
        psm->iMsg     = GDISPOOL_ENDDOCPRINTER;
        psm->fl       = 0;

        psm->cBuf     = 2;
        psm->cjIn     = sizeof(ULONG)+cjIn;

        psm->apulIn[0]= &iEsc;
        psm->acjIn[0] = sizeof(ULONG);

        psm->apulIn[1]= (PULONG)pvIn;
        psm->acjIn[1] = cjIn;

        psm->pulOut   = (PULONG)pvOut;
        psm->cjOut    = cjOut;

        psm->hso      = (HSPOOLOBJ)hPrinter;

        if( sr.GreEscapeSpool() )
        {
            ulRet = (DWORD) psm->ulRet;
        }
    }

    return(ulRet);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\srcblt16.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt16.cxx
*
* This contains the bitmap simulation functions that blt to a 16 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Turn off validations
#if 1

    // On free builds, don't call any verification code:

    #define VERIFYS16D16(psb)
    #define VERIFYS24D16(psb)
    #define VERIFYS32D16(psb)

#else

    // On checked builds, verify the RGB conversions:

    VOID VERIFYS16D16(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting
    // If it was on the same surface it would be the identity case.

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D16 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D16 - direction not up to down");

    // These are our holding variables

        PUSHORT pusSrcTemp;
        PUSHORT pusDstTemp;
        ULONG  cxTemp;
        PUSHORT pusSrc  = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
        PUSHORT pusDst  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {
            pusSrcTemp  = pusSrc;
            pusDstTemp  = pusDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                if (*(pusDstTemp++) != (USHORT) (pxlo->ulTranslate((ULONG) *(pusSrcTemp++))))
                    RIP("RGB mis-match");
            }

            if (--cy)
            {
                pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
                pusDst = (PUSHORT) (((PBYTE) pusDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }

    VOID VERIFYS24D16(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D16 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D16 - direction not up to down");

    // These are our holding variables

        ULONG ulDink;          // variable to dink around with the bytes in
        PBYTE pjSrcTemp;
        PUSHORT pusDstTemp;
        ULONG  cxTemp;
        PBYTE pjSrc  = psb->pjSrc + (3 * psb->xSrcStart);
        PUSHORT pusDst  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {

            pjSrcTemp  = pjSrc;
            pusDstTemp  = pusDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                ulDink = *(pjSrcTemp + 2);
                ulDink = ulDink << 8;
                ulDink |= (ULONG) *(pjSrcTemp + 1);
                ulDink = ulDink << 8;
                ulDink |= (ULONG) *pjSrcTemp;

                if (*pusDstTemp != (USHORT) (pxlo->ulTranslate(ulDink)))
                    RIP("RGB mis-match");

                pusDstTemp++;
                pjSrcTemp += 3;
            }

            if (--cy)
            {
                pjSrc += psb->lDeltaSrc;
                pusDst = (PUSHORT) (((PBYTE) pusDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }

    VOID VERIFYS32D16(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting.

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D16 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D16 - direction not up to down");

    // These are our holding variables

        PULONG pulSrcTemp;
        PUSHORT pusDstTemp;
        ULONG  cxTemp;
        PULONG pulSrc  = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
        PUSHORT pusDst  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;
        ULONG  ulLastSrcPel;
        USHORT usLastDstPel;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        usLastDstPel = (USHORT) (pxlo->ulTranslate(ulLastSrcPel = *pulSrc));

        while(1)
        {

            pulSrcTemp  = pulSrc;
            pusDstTemp  = pusDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                ULONG ulTemp;

                if ((ulTemp = *(pulSrcTemp)) != ulLastSrcPel)
                {
                    ulLastSrcPel = ulTemp;
                    usLastDstPel = (USHORT) (pxlo->ulTranslate(ulLastSrcPel));
                }

                if (*pusDstTemp++ != usLastDstPel)
                    RIP("RGB mis-match");

                pulSrcTemp++;
            }

            if (--cy)
            {
                pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
                pusDst = (PUSHORT) (((PBYTE) pusDst) + psb->lDeltaDst);
            }
            else
                break;
        }
    }

#endif

/*******************Public*Routine*****************\
* vSrcCopyS1D16
*
* There are three main loops in this function.
*
* The first loop deals with the full byte part mapping
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the left starting
* pixels.
*
* The third loop deals with the ending pixels.
*
* For the full bytes, we walk thru Src one byte at a time
* and expand to Dst 8 words at a time.  Dst is
* DWORD aligned.
*
* We expand the starting/ending pixels one bit
* at a time.
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
*
\**************************************************/
VOID vSrcCopyS1D16(PBLTINFO psb)
{
    BYTE  jSrc;    // holds a source byte
    INT   iDst;    // Position in the first 8 Dst words
    INT   iSrc;    // bit position in the first Src byte
    PBYTE pjDst;   // pointer to the Src bytes
    PBYTE pjSrc;   // pointer to the Dst bytes
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;      // number of rows
    LONG  cx;      // number of pixels
    BYTE  alignL;  // alignment bits to the left
    BYTE  alignR;  // alignment bits to the right
    LONG  cibytes;  //number of full 8 bytes dealed with
    BOOL  bNextByte;
    LONG  xDstEnd = psb->xDstStart+psb->cx;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    USHORT ausTable[2];
    ULONG ulB = (ULONG)(psb->pxlo->pulXlate[0]);
    ULONG uF = (ULONG)(psb->pxlo->pulXlate[1]);
    USHORT usB = (USHORT)(psb->pxlo->pulXlate[0]);
    USHORT usF = (USHORT)(psb->pxlo->pulXlate[1]);
    ULONG aulTable[4];
    INT   count;
    BOOL  bNextSrc = TRUE;

    // We assume we are doing left to right top to bottom blting
    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D16 - direction not up to down");

    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d16\n");

    // Generate aulTable. 4 entries.
    // Each 2 bits will be an index to the aulTable
    // which translates to a 32 bit ULONG
    ULONG ulValB = ulB;
    ULONG ulValF = uF;

    ulValB = (ulValB << 16) | ulValB;
    ulValF = (ulValF << 16) | ulValF;

    aulTable[0] = ulValB;         //0 0
    aulTable[1] = (ulValF<<16) | (ulValB>>16);         //1 0
    aulTable[2] = (ulValB<<16) | (ulValF>>16);         //0 1
    aulTable[3] =  ulValF ;         //1 1

    // Generate ausTable.
    // Two entries.  This table used when dealing
    // with begin and end parts.
    ausTable[0] = usB;
    ausTable[1] = usF;

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    if (iSrc < iDst)
        alignL = 8 - (iDst - iSrc);
    else
        alignL = iSrc - iDst;

    alignR = 8 - alignL;

    cx=psb->cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    // if there is a next 8 words
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // if Src and Dst are aligned, use a separete loop
    // to obtain better performance;
    // If not, we shift the Src bytes to match with
    // the Dst 8 bytes (2 dwords) one at a time

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;

        // Get first Dst full 8 words
        pjDst = psb->pjDst + 2*((psb->xDstStart+7)&~0x07);

        // Get the Src byte that matches the first Dst
        // full 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get the number of full 8 words
        cibytes = (xDstEnd>>3)-((psb->xDstStart+7)>>3);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst - cibytes*16;
        iStrideSrc = lDeltaSrc - cibytes;

        // deal with our special case
        cy = psb->cy;

        if (!alignL)
        {
            while (cy--)
            {
                pjSrcEnd = pjSrc + cibytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = *pjSrc++;

                    *(PULONG) (pjDst + 0) = aulTable[(jSrc >> 6) & 0x03];
                    *(PULONG) (pjDst + 4) = aulTable[(jSrc >> 4) & 0x03];
                    *(PULONG) (pjDst + 8) = aulTable[(jSrc >> 2)& 0x03];
                    *(PULONG) (pjDst + 12) = aulTable[jSrc & 0x03];

                    pjDst +=16;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }

        }   //end of if (!alignL)

        // Here comes our general case for the main full
        // bytes part

        else  // if not aligned
        {
            BYTE jRem; //remainder

            while (cy--)
            {
                jRem = *pjSrc << alignL;

                pjSrcEnd = pjSrc + cibytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = ((*(++pjSrc))>>alignR) | jRem;

                    *(PULONG) (pjDst + 0) = aulTable[(jSrc >> 6) & 0x03];
                    *(PULONG) (pjDst + 4) = aulTable[(jSrc >> 4) & 0x03];
                    *(PULONG) (pjDst + 8) = aulTable[(jSrc >> 2)& 0x03];
                    *(PULONG) (pjDst + 12) = aulTable[jSrc & 0x03];

                    pjDst +=16;

                    //next remainder
                    jRem = *pjSrc << alignL;
                }

                // go to the beginging full byte of
                // next scan line
                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }
        } //else
    } //if
    // End of our dealing with the full bytes

    //Deal with the starting pixels
    if (!bNextByte)
    {
        count = cx;
        bNextSrc = ((iSrc+cx) > 8);
    }
    else
        count = 8-iDst;

    if (iDst | !bNextByte)
    {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        pjDst = psb->pjDst + 2*psb->xDstStart;
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc > iDst)
        {
            if (bNextSrc)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << alignL;
                    jSrc |= *(pjSrc+1) >> alignR;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;
                    pjDstEnd = pjDst + count*2;

                    while (pjDstTemp != pjDstEnd)
                    {
                        *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                        jSrc <<= 1;
                        pjDstTemp +=  2;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            else
            {
                 while (cy--)
                {
                    jSrc = *pjSrc << alignL;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;
                    pjDstEnd = pjDst + count*2;

                    while (pjDstTemp != pjDstEnd)
                    {
                        *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                        jSrc <<= 1;
                        pjDstTemp +=  2;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << iSrc;

                pjDstTemp = pjDst;
                pjDstEnd = pjDst + 2*count;

                while (pjDstTemp != pjDstEnd)
                {
                    *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                    pjDstTemp +=  2;
                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }

        }

   } //if

   // Deal with the ending pixels
   if ((xDstEnd & 0x0007)
       && bNextByte)
   {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        // Get the last partial bytes on the
        // scan line
        pjDst = psb->pjDst+2*(xDstEnd&~0x07);

        // Get the Src byte that matches the
        // right partial Dst 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        count = iDst+1;

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << alignL;

                pjDstTemp = pjDst;
                pjDstEnd = pjDst + 2*count;

                while (pjDstTemp != pjDstEnd)
                {
                    *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                    pjDstTemp +=  2;
                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else if (iSrc < iDst)
        {
            while (cy--)
            {
                 jSrc = *(pjSrc-1) << alignL;

                 jSrc |= *pjSrc >> alignR;

                 pjDstTemp = pjDst;

                 pjDstEnd = pjDst + 2*count;

                 while (pjDstTemp != pjDstEnd)
                 {
                    *(PUSHORT) pjDstTemp = ausTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                    pjDstTemp +=  2;
                 }

                 pjDst += lDeltaDst;
                 pjSrc += lDeltaSrc;
            }
        }
     } //if
}


/******************************Public*Routine******************************\
* vSrcCopyS4D16
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D16 - direction not up to down");

    BYTE  jSrc;
    LONG  i;
    PUSHORT pusDst;
    PBYTE pjSrc;
    PUSHORT pusDstHolder  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cy = psb->cy;
    XLATE *pxlo = psb->pxlo;
    PULONG pulXlate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        pusDst  = pusDstHolder;
        pjSrc  = pjSrcHolder;

        i = psb->xSrcStart;

        if (i & 0x00000001)
            jSrc = *(pjSrc++);

        while(i != psb->xSrcEnd)
        {
            if (i & 0x00000001)
                *(pusDst++) = (USHORT) pulXlate[jSrc & 0x0F];
            else
            {
            // We need a new byte

                jSrc = *(pjSrc++);
                *(pusDst++) = (USHORT) pulXlate[((ULONG) (jSrc & 0xF0)) >> 4];
            }

            ++i;
        }

        if (--cy)
        {
            pjSrcHolder += psb->lDeltaSrc;
            pusDstHolder = (PUSHORT) (((PBYTE) pusDstHolder) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D16
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D16 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + (2 * psb->xDstStart);
    LONG cx     = psb->cx;
    LONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    PULONG pulXlate = psb->pxlo->pulXlate;
    LONG lSrcSkip = psb->lDeltaSrc - cx;
    LONG lDstSkip = psb->lDeltaDst - (cx * 2);
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    while(1)
    {
        i = cx;

        // Get 'dword' alignment on the destination:

        if (((ULONG_PTR) pjDst) & 2)
        {
            *((USHORT*) pjDst) = (USHORT) pulXlate[*pjSrc];
            pjDst += 2;
            pjSrc += 1;
            i--;
        }

        // Now write pixels a dword at a time.  This is almost a 2x win
        // over doing word writes if we're writing to frame buffer memory
        // over the PCI bus on Pentium class systems, because the PCI
        // write throughput is so slow:

        while(1)
        {
            i -=2;
            if (i < 0)
                break;

            *((ULONG*) pjDst) = (pulXlate[*(pjSrc)])
                              | (pulXlate[*(pjSrc + 1)] << 16);
            pjDst += 4;
            pjSrc += 2;
        }

        // Take care of the end alignment:

        if (i & 1)
        {
            *((USHORT*) pjDst) = (USHORT) pulXlate[*pjSrc];
            pjDst += 2;
            pjSrc += 1;
        }

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D16
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS16D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting
// If it was on the same surface it would be the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D16 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (2 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (2 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 2);
    LONG lDstSkip = psb->lDeltaDst - (cx * 2);
    PFN_pfnXlate pfnXlate;
    LONG i;
    USHORT us;
    ULONG ul;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

// Optimize 5-5-5 to 5-6-5.

    if (palSrc.bIs555() && palDst.bIs565())
    {
        while (1)
        {
            i = cx;

            if (((ULONG_PTR) pjDst) & 2)
            {
                us = *((USHORT*) pjSrc);

                *((USHORT*) pjDst) = ((us) & 0x001f)
                                   | ((us << 1) & 0xffc0)
                                   | ((us >> 4) & 0x0020);
                pjDst += 2;
                pjSrc += 2;
                i--;
            }

            while(1)
            {
                i -=2;
                if (i < 0)
                    break;

                ul = *((ULONG UNALIGNED *) pjSrc);

                *((ULONG*) pjDst) = ((ul) & 0x001f001f)
                                  | ((ul << 1) & 0xffc0ffc0)
                                  | ((ul >> 4) & 0x00200020);
                pjDst += 4;
                pjSrc += 4;
            }

            if (i & 1)
            {
                us = *((USHORT*) pjSrc);

                *((USHORT*) pjDst) = ((us) & 0x001f)
                                   | ((us << 1) & 0xffc0)
                                   | ((us >> 4) & 0x0020);
                pjDst += 2;
                pjSrc += 2;
            }

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS16D16(psb);
        return;
    }

// Optimize 5-6-5 to 5-5-5.

    if (palSrc.bIs565() && palDst.bIs555())
    {
        while (1)
        {
            i = cx;

            if (((ULONG_PTR) pjDst) & 2)
            {
                us = *((USHORT*) pjSrc);

                *((USHORT*) pjDst) = ((us) & 0x001f)
                                   | ((us >> 1) & 0x7fe0);
                pjDst += 2;
                pjSrc += 2;
                i--;
            }

            while(1)
            {
                i -=2;
                if (i < 0)
                    break;

                ul = *((ULONG UNALIGNED *) pjSrc);

                *((ULONG*) pjDst) = ((ul) & 0x001f001f)
                                  | ((ul >> 1) & 0x7fe07fe0);
                pjDst += 4;
                pjSrc += 4;
            }

            if (i & 1)
            {
                us = *((USHORT*) pjSrc);

                *((USHORT*) pjDst) = ((us) & 0x001f)
                                   | ((us >> 1) & 0x7fe0);
                pjDst += 2;
                pjSrc += 2;
            }

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS16D16(psb);
        return;
    }

// Finally, fall back to the generic case:

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;

        do {
            *((USHORT*) pjDst) = (USHORT) pfnXlate(pxlo, *((USHORT*) pjSrc));
            pjDst += 2;
            pjSrc += 2;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS16D16(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS16D16Identity
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps.
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS16D16Identity(PBLTINFO psb)
{
// These are our holding variables

    PUSHORT pusSrc  = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
    PUSHORT pusDst  = (PUSHORT) (psb->pjDst + (2 * psb->xDstStart));
    ULONG  cx     = psb->cx;
    ULONG  cy     = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    if (psb->xDir < 0)
    {
        pusSrc -= (cx - 1);
        pusDst -= (cx - 1);
    }

    cx = cx << 1;

    while(1)
    {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory((PBYTE)pusDst,(PBYTE)pusSrc,cx);
        else
            RtlMoveMemory((PVOID)pusDst, (PVOID)pusSrc, cx);

        if (--cy)
        {
            pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
            pusDst = (PUSHORT) (((PBYTE) pusDst) + psb->lDeltaDst);
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS24D16
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D16 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (3 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (2 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 3);
    LONG lDstSkip = psb->lDeltaDst - (cx * 2);
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    PFN_pfnXlate pfnXlate;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0,
        "ERROR: Src Move cy == 0");
    ASSERTGDI(((pxlo->flXlate & (XO_TABLE | XO_TO_MONO)) == 0)
              && ((pxlo->flPrivate & XLATE_PAL_MANAGED) == 0),
        "ERROR: flXlate != 0 or flPrivate != 0");
    ASSERTGDI(((XEPALOBJ) pxlo->ppalDst).cEntries() == 0,
        "ERROR: cEntries != 0");
    ASSERTGDI(palDst.bIsBitfields(),
        "ERROR: destination not bitfields");

    if (palSrc.bIsBGR())
    {

    // First, try to optimize BGR to 5-6-5:

        if (palDst.bIs565())
        {
            while (1)
            {
                i = cx;

                if (((ULONG_PTR) pjDst) & 2)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 3) & 0x07e0)
                       | ((*(pjSrc + 2) << 8) & 0xf800);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 3;
                    i--;
                }

                #if defined(_X86_)

                    _asm {

                        mov   esi, pjSrc
                        mov   edi, pjDst
                        sub   i, 2
                        js    Done_565_Loop

                    Middle_565_Loop:

                        movzx eax, byte ptr [esi]
                        movzx ebx, byte ptr [esi+1]
                        shr   eax, 3
                        shl   ebx, 3
                        movzx edx, byte ptr [esi+2]
                        movzx ecx, byte ptr [esi+3]
                        shl   edx, 8
                        shl   ecx, 13
                        or    eax, edx
                        or    ebx, ecx
                        movzx edx, byte ptr [esi+4]
                        movzx ecx, byte ptr [esi+5]
                        shl   edx, 19
                        shl   ecx, 24
                        or    eax, edx
                        or    ebx, ecx
                        and   eax, 0x07e0f81f
                        and   ebx, 0xf81f07e0
                        or    eax, ebx
                        add   esi, 6
                        mov   [edi], eax
                        add   edi, 4
                        sub   i, 2
                        jns   Middle_565_Loop

                    Done_565_Loop:

                        mov   pjSrc, esi
                        mov   pjDst, edi
                    }

                #else

                    while (1)
                    {
                        i -= 2;
                        if (i < 0)
                            break;

                        ul0 = (*(pjSrc) >> 3)
                            | (*(pjSrc + 2) << 8)
                            | (*(pjSrc + 4) << 19);
                        ul1 = (*(pjSrc + 1) << 3)
                            | (*(pjSrc + 3) << 13)
                            | (*(pjSrc + 5) << 24);

                        *((ULONG*) pjDst) = (ul0 & 0x07e0f81f)
                                          | (ul1 & 0xf81f07e0);

                        pjDst += 4;
                        pjSrc += 6;
                    }

                #endif

                if (i & 1)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 3) & 0x07e0)
                       | ((*(pjSrc + 2) << 8) & 0xf800);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 3;
                }

                if (--cy == 0)
                    break;

                pjSrc += lSrcSkip;
                pjDst += lDstSkip;
            }

            VERIFYS24D16(psb);
            return;
        }

    // Next, try to optimize BGR to 5-5-5:

        if (palDst.bIs555())
        {
            while (1)
            {
                i = cx;

                if (((ULONG_PTR) pjDst) & 2)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 2) & 0x03e0)
                       | ((*(pjSrc + 2) << 7) & 0x7c00);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 3;
                    i--;
                }

                #if defined(_X86_)

                    _asm {

                        mov   esi, pjSrc
                        mov   edi, pjDst
                        sub   i, 2
                        js    Done_555_Loop

                    Middle_555_Loop:

                        movzx eax, byte ptr [esi]
                        movzx ebx, byte ptr [esi+1]
                        shr   eax, 3
                        shl   ebx, 2
                        movzx edx, byte ptr [esi+2]
                        movzx ecx, byte ptr [esi+3]
                        shl   edx, 7
                        shl   ecx, 13
                        or    eax, edx
                        or    ebx, ecx
                        movzx edx, byte ptr [esi+4]
                        movzx ecx, byte ptr [esi+5]
                        shl   edx, 18
                        shl   ecx, 23
                        or    eax, edx
                        or    ebx, ecx
                        and   eax, 0x03e07c1f
                        and   ebx, 0x7c1f03e0
                        or    eax, ebx
                        add   esi, 6
                        mov   [edi], eax
                        add   edi, 4
                        sub   i, 2
                        jns   Middle_555_Loop

                    Done_555_Loop:

                        mov   pjSrc, esi
                        mov   pjDst, edi
                    }

                #else

                    while (1)
                    {
                        i -= 2;
                        if (i < 0)
                            break;

                        ul0 = (*(pjSrc) >> 3)
                            | (*(pjSrc + 2) << 7)
                            | (*(pjSrc + 4) << 18);
                        ul1 = (*(pjSrc + 1) << 2)
                            | (*(pjSrc + 3) << 13)
                            | (*(pjSrc + 5) << 23);

                        *((ULONG*) pjDst) = (ul0 & 0x03e07c1f)
                                          | (ul1 & 0x7c1f03e0);

                        pjDst += 4;
                        pjSrc += 6;
                    }

                #endif

                if (i & 1)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 2) & 0x03e0)
                       | ((*(pjSrc + 2) << 7) & 0x7c00);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 3;
                }

                if (--cy == 0)
                    break;

                pjSrc += lSrcSkip;
                pjDst += lDstSkip;
            }

            VERIFYS24D16(psb);
            return;
        }
    }

// Finally, fall back to the generic case:

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;

        do {
            ul = ((ULONG) *(pjSrc))
               | ((ULONG) *(pjSrc + 1) << 8)
               | ((ULONG) *(pjSrc + 2) << 16);

            *((USHORT*) pjDst) = (USHORT) pfnXlate(pxlo, ul);
            pjDst += 2;
            pjSrc += 3;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS24D16(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS32D16
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS32D16(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D16 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D16 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (4 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (2 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 4);
    LONG lDstSkip = psb->lDeltaDst - (cx * 2);
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    PFN_pfnXlate pfnXlate;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    if (palSrc.bIsBGR())
    {

    // First, try to optimize BGR to 5-6-5:

        if (palDst.bIs565())
        {
            while (1)
            {
                i = cx;

                if (((ULONG_PTR) pjDst) & 2)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 3) & 0x07e0)
                       | ((*(pjSrc + 2) << 8) & 0xf800);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 4;
                    i--;
                }

                #if defined(_X86_)

                    _asm {

                        mov   esi, pjSrc
                        mov   edi, pjDst
                        sub   i, 2
                        js    Done_565_Loop

                    Middle_565_Loop:

                        movzx eax, byte ptr [esi]
                        movzx ebx, byte ptr [esi+1]
                        shr   eax, 3
                        shl   ebx, 3
                        movzx edx, byte ptr [esi+2]
                        movzx ecx, byte ptr [esi+4]
                        shl   edx, 8
                        shl   ecx, 13
                        or    eax, edx
                        or    ebx, ecx
                        movzx edx, byte ptr [esi+5]
                        movzx ecx, byte ptr [esi+6]
                        shl   edx, 19
                        shl   ecx, 24
                        or    eax, edx
                        or    ebx, ecx
                        and   eax, 0x07e0f81f
                        and   ebx, 0xf81f07e0
                        or    eax, ebx
                        add   esi, 8
                        mov   [edi], eax
                        add   edi, 4
                        sub   i, 2
                        jns   Middle_565_Loop

                    Done_565_Loop:

                        mov   pjSrc, esi
                        mov   pjDst, edi
                    }

                #else

                    while (1)
                    {
                        i -= 2;
                        if (i < 0)
                            break;

                        ul0 = (*(pjSrc) >> 3)
                            | (*(pjSrc + 2) << 8)
                            | (*(pjSrc + 5) << 19);
                        ul1 = (*(pjSrc + 1) << 3)
                            | (*(pjSrc + 4) << 13)
                            | (*(pjSrc + 6) << 24);

                        *((ULONG*) pjDst) = (ul0 & 0x07e0f81f)
                                          | (ul1 & 0xf81f07e0);

                        pjDst += 4;
                        pjSrc += 8;
                    }

                #endif

                if (i & 1)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 3) & 0x07e0)
                       | ((*(pjSrc + 2) << 8) & 0xf800);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 4;
                }

                if (--cy == 0)
                    break;

                pjSrc += lSrcSkip;
                pjDst += lDstSkip;
            }

            VERIFYS32D16(psb);
            return;
        }

    // Next, try to optimize BGR to 5-5-5:

        if (palDst.bIs555())
        {
            while (1)
            {
                i = cx;

                if (((ULONG_PTR) pjDst) & 2)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 2) & 0x03e0)
                       | ((*(pjSrc + 2) << 7) & 0x7c00);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 4;
                    i--;
                }

                #if defined(_X86_)

                    _asm {

                        mov   esi, pjSrc
                        mov   edi, pjDst
                        sub   i, 2
                        js    Done_555_Loop

                    Middle_555_Loop:

                        movzx eax, byte ptr [esi]
                        movzx ebx, byte ptr [esi+1]
                        shr   eax, 3
                        shl   ebx, 2
                        movzx edx, byte ptr [esi+2]
                        movzx ecx, byte ptr [esi+4]
                        shl   edx, 7
                        shl   ecx, 13
                        or    eax, edx
                        or    ebx, ecx
                        movzx edx, byte ptr [esi+5]
                        movzx ecx, byte ptr [esi+6]
                        shl   edx, 18
                        shl   ecx, 23
                        or    eax, edx
                        or    ebx, ecx
                        and   eax, 0x03e07c1f
                        and   ebx, 0x7c1f03e0
                        or    eax, ebx
                        add   esi, 8
                        mov   [edi], eax
                        add   edi, 4
                        sub   i, 2
                        jns   Middle_555_Loop

                    Done_555_Loop:

                        mov   pjSrc, esi
                        mov   pjDst, edi
                    }

                #else

                    while (1)
                    {
                        i -= 2;
                        if (i < 0)
                            break;

                        ul0 = (*(pjSrc) >> 3)
                            | (*(pjSrc + 2) << 7)
                            | (*(pjSrc + 5) << 18);
                        ul1 = (*(pjSrc + 1) << 2)
                            | (*(pjSrc + 4) << 13)
                            | (*(pjSrc + 6) << 23);

                        *((ULONG*) pjDst) = (ul0 & 0x03e07c1f)
                                          | (ul1 & 0x7c1f03e0);

                        pjDst += 4;
                        pjSrc += 8;
                    }

                #endif

                if (i & 1)
                {
                    ul = ((*(pjSrc) >> 3))
                       | ((*(pjSrc + 1) << 2) & 0x03e0)
                       | ((*(pjSrc + 2) << 7) & 0x7c00);

                    *((USHORT*) pjDst) = (USHORT) ul;
                    pjDst += 2;
                    pjSrc += 4;
                }

                if (--cy == 0)
                    break;

                pjSrc += lSrcSkip;
                pjDst += lDstSkip;
            }

            VERIFYS32D16(psb);
            return;
        }
    }

// Finally, fall back to the generic case:

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;

        do {
            *((USHORT*) pjDst) = (USHORT) pfnXlate(pxlo, *((ULONG*) pjSrc));
            pjDst += 2;
            pjSrc += 4;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS32D16(psb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\sprite.cxx ===
/******************************Module*Header*******************************\
* Module Name: sprite.cxx
*
* Contains all the drawing code for handling GDI sprites.
*
* Created: 16-Sep-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Notes
//
//  - EngAlphaBlend always calls 32BitfieldsToBGRA with identity pxlo
//  - pSprite->rclSrc no longer needed
//  - Fix vProfile for smart heap management

// Global variable that defines a (0, 0) offset:

POINTL gptlZero;
POINTL gptl00;

// Handy forward declarations:

VOID vSpComputeUnlockedRegion(SPRITESTATE*);
VOID vSpCheckForWndobjOverlap(SPRITESTATE*, RECTL*, RECTL*);

/******************************Public*Routine******************************\
* VOID vSpDirectDriverAccess
*
* If 'bEnable' is TRUE, this routine undoes any sprite modifications to
* the surface, in order to allow us to call the driver from within the
* sprite code.
*
* If 'bEnable' is FALSE, this routine redoes any sprite modifications to
* the surface that are needed for any drawing calls outside of this file,
* in order to be redirected through the sprite code as appropriate.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDirectDriverAccess(
SPRITESTATE*    pState,
BOOL            bEnable)
{
    PDEVOBJ po(pState->hdev);

    po.vAssertDevLock();

    if (bEnable)
    {
        SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->
                flags(pState->flOriginalSurfFlags);
        SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->
                iType(pState->iOriginalType);

        pState->bInsideDriverCall = TRUE;
    }
    else
    {
        SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->
                flags(pState->flSpriteSurfFlags);
        SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->
                iType(pState->iSpriteType);

        pState->bInsideDriverCall = FALSE;
    }
}


#if DEBUG_SPRITES
/******************************Debug*Routine*******************************\
* VOID vSpValidateVisibleSprites
*
* Walk visible spritelist and validates cVisible count equals number of
*  sprites in pListVisible.
*
*  08-May-2001 -by- Jason Hartman [jasonha]
* Wrote it.
\**************************************************************************/

void vSpValidateVisibleSprites(
    SPRITESTATE *pState
    )
{
    ULONG   cVisible;
    SPRITE *pSprite;

    cVisible = pState->cVisible;
    for (pSprite = pState->pListVisible;
         pSprite != NULL;
         pSprite = pSprite->pNextVisible)
    {
        ASSERTGDI(cVisible != 0, "Invalid visible sprite list: list is longer than cVisible.\n");
        cVisible--;
        ASSERTGDI(pSprite->fl & SPRITE_FLAG_VISIBLE, "Invalid sprite visible state: invisible sprite in visible list.\n");
    }
    ASSERTGDI(cVisible == 0, "Invalid visible sprite list: list is missing a sprite or more.\n");

    cVisible = pState->cVisible;
    for (pSprite = pState->pListZ;
         pSprite != NULL;
         pSprite = pSprite->pNextZ)
    {
        if (pSprite->fl & SPRITE_FLAG_VISIBLE)
        {
            ASSERTGDI(cVisible != 0, "Invalid visible sprite count: cVisible is too small.\n");
            cVisible--;
        }
    }
    ASSERTGDI(cVisible == 0, "Invalid visible sprite count: cVisible is too big.\n");
}
#endif


/*********************************Class************************************\
* class SPRITELOCK
*
* This class is responsible for reseting whatever sprite state is
* necessary so that we can call the driver directly, bypassing any sprite
* code.
*
* Must be called with the DEVLOCK already held, because we're
* messing with the screen surface.
*
\***************************************************************************/

SPRITELOCK::SPRITELOCK(PDEVOBJ& po)
{
    pState = po.pSpriteState();

    po.vAssertDevLock();

    bWasAlreadyInsideDriverCall = pState->bInsideDriverCall;
    if (!bWasAlreadyInsideDriverCall)
    {
        vSpDirectDriverAccess(pState, TRUE);
    }

#if DEBUG_SPRITES
    vSpValidateVisibleSprites(pState);
#endif
}

SPRITELOCK::~SPRITELOCK()
{
#if DEBUG_SPRITES
    vSpValidateVisibleSprites(pState);
#endif

    if (!bWasAlreadyInsideDriverCall)
    {
        vSpDirectDriverAccess(pState, FALSE);
    }
}

/******************************Public*Routine******************************\
* VOID psoSpCreateSurface
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SURFOBJ* psoSpCreateSurface(
SPRITESTATE*    pState,
ULONG           iBitmapFormat,  // If zero, use same format as display
LONG            cx,
LONG            cy,
BOOL            bWantSystemMemory)  // TRUE if must be system memory, FALSE
                                    //   if can be in video memory
{
    HSURF       hsurf;
    SIZEL       sizl;
    SURFOBJ*    psoScreen;
    SURFOBJ*    psoRet;
    SURFACE*    psurf;

    PDEVOBJ po(pState->hdev);

    psoRet = NULL;

    sizl.cx = cx;
    sizl.cy = cy;

    psoScreen = pState->psoScreen;

    if (iBitmapFormat == 0)
    {
        iBitmapFormat = psoScreen->iBitmapFormat;
    }

    hsurf = 0;

    if ((!bWantSystemMemory) &&
        (PPFNVALID(po, CreateDeviceBitmap)) &&
        (iBitmapFormat == psoScreen->iBitmapFormat))
    {
        hsurf = (HSURF) (*PPFNDRV(po, CreateDeviceBitmap))
                            (psoScreen->dhpdev,
                             sizl,
                             iBitmapFormat);
    }
    if (hsurf == 0)
    {
        hsurf = (HSURF) EngCreateBitmap(sizl,
                                        0,
                                        iBitmapFormat,
                                        BMF_TOPDOWN,
                                        NULL);
    }
    if (hsurf != 0)
    {
        psoRet = EngLockSurface(hsurf);
        ASSERTGDI(psoRet != NULL, "How could lock possibly fail?");

        // Mark the surface, so that it can be special-cased by
        // the dynamic mode change code:

        psurf = SURFOBJ_TO_SURFACE_NOT_NULL(psoRet);
        psurf->hdev(pState->hdev);
    }

    return(psoRet);
}

/******************************Public*Routine******************************\
* VOID vSpDeleteSurface
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDeleteSurface(
SURFOBJ*    pso)
{
    HSURF   hsurf;

    // Note that EngDeleteSurface handles calling DrvDeleteDeviceBitmap
    // if it's a device format bitmap:

    if (pso != NULL)
    {
        hsurf = pso->hsurf;
        EngUnlockSurface(pso);
        EngDeleteSurface(hsurf);
    }
}

/**********************************Macros**********************************\
* OFFSET_POINTL, OFFSET_RECTL
*
* These little macros offset simple structures using a copy on the stack.
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

#define OFFSET_POINTL(pptl, xOff, yOff)                 \
    POINTL ptlCopyOf##pptl;                             \
    POINTL* pptlOriginal##pptl;                         \
    if (pptl != NULL)                                   \
    {                                                   \
        ptlCopyOf##pptl.x = xOff + pptl->x;             \
        ptlCopyOf##pptl.y = yOff + pptl->y;             \
        pptlOriginal##pptl = pptl;                      \
        pptl = &ptlCopyOf##pptl;                        \
    }

#define OFFSET_RECTL(prcl, xOff, yOff)                  \
    RECTL rclCopyOf##prcl;                              \
    if (prcl != NULL)                                   \
    {                                                   \
        rclCopyOf##prcl.left   = xOff + prcl->left;     \
        rclCopyOf##prcl.right  = xOff + prcl->right;    \
        rclCopyOf##prcl.top    = yOff + prcl->top;      \
        rclCopyOf##prcl.bottom = yOff + prcl->bottom;   \
        prcl = &rclCopyOf##prcl;                        \
    }

#define OFFSET_POINTL_NOT_NULL(pptl, xOff, yOff)        \
    POINTL ptlCopyOf##pptl;                             \
    ptlCopyOf##pptl.x = xOff + pptl->x;                 \
    ptlCopyOf##pptl.y = yOff + pptl->y;                 \
    pptl = &ptlCopyOf##pptl;

#define OFFSET_RECTL_NOT_NULL(prcl, xOff, yOff)         \
    RECTL rclCopyOf##prcl;                              \
    rclCopyOf##prcl.left   = xOff + prcl->left;         \
    rclCopyOf##prcl.right  = xOff + prcl->right;        \
    rclCopyOf##prcl.top    = yOff + prcl->top;          \
    rclCopyOf##prcl.bottom = yOff + prcl->bottom;       \
    prcl = &rclCopyOf##prcl;

// The following little macro is here to catch any Drv or Eng functions
// that illegaly modify the value of 'pptlBrush'.  If you hit this assert,
// it means that the function we just called is a culprit.

#define ASSERT_BRUSH_ORIGIN(pptl, xOff, yOff)           \
    ASSERTGDI((pptl == NULL) ||                         \
              ((ptlCopyOf##pptl.x == xOff + pptlOriginal##pptl->x) && \
               (ptlCopyOf##pptl.y == yOff + pptlOriginal##pptl->y)),  \
        "Called function modified pptlBrush");

/******************************Public*Routine******************************\
* VOID CLIPOBJ_vOffset
*
* These are little in-line routines to handle offseting of complex
* structures that must remain in-place.
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID FASTCALL CLIPOBJ_vOffset(
CLIPOBJ*    pco,
LONG        x,
LONG        y)
{
    POINTL ptlOffset;

    if (pco != NULL)
    {
        if ((x != 0) || (y != 0))
        {
            pco->rclBounds.left   += x;
            pco->rclBounds.right  += x;
            pco->rclBounds.top    += y;
            pco->rclBounds.bottom += y;

            if (pco->iDComplexity != DC_TRIVIAL)
            {
                ptlOffset.x = x;
                ptlOffset.y = y;

                ((XCLIPOBJ*) pco)->bOffset(&ptlOffset);
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID STROBJ_vOffset
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID FASTCALL STROBJ_vOffset(
STROBJ* pstro,
LONG    x,
LONG    y)
{
    GLYPHPOS*   pgp;
    ULONG       cGlyphs;

    if ((x != 0) || (y != 0))
    {
        pstro->rclBkGround.left   += x;
        pstro->rclBkGround.right  += x;
        pstro->rclBkGround.top    += y;
        pstro->rclBkGround.bottom += y;

        // We are just offsetting positions, they are always computed,
        // unless;
        //
        // a) this is a fixed pitch font (ulCharInc != 0), in which case only
        //    first position in the batch is set.
        //
        // b) we are dealing with linked fonts.
        //
        // bEnum is just putting bits in the cache, that is independent
        // of computing positions.

        if (((ESTROBJ*)pstro)->flTO & TO_HIGHRESTEXT)
        {
            x <<= 4;
            y <<= 4;
        }

        pgp = ((ESTROBJ*)pstro)->pgpos;

        if(((ESTROBJ*)pstro)->flTO & (TO_PARTITION_INIT|TO_SYS_PARTITION))
        {
            LONG *plFont;

            plFont  = ((ESTROBJ*)pstro)->plPartition;

            for (cGlyphs = pstro->cGlyphs ; cGlyphs != 0; pgp++, plFont++)
            {
                // only offset the glyphs that correspond to the current font:

                if (*plFont == ((ESTROBJ*)pstro)->lCurrentFont)
                {
                    cGlyphs--;
                    pgp->ptl.x += x;
                    pgp->ptl.y += y;
                }
            }
        }
        else
        {
            if (!pstro->ulCharInc)
            {
                cGlyphs = pstro->cGlyphs;

                for (; cGlyphs != 0; cGlyphs--, pgp++)
                {
                    pgp->ptl.x += x;
                    pgp->ptl.y += y;
                }
            }
            else
            {
                // fixed pitch, only fix the first position, the rest will be
                // computed during bEnum phase if necessary

                pgp->ptl.x += x;
                pgp->ptl.y += y;
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID PATHOBJ_vOffset
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID FASTCALL PATHOBJ_vOffset(
PATHOBJ*    ppo,
LONG        x,
LONG        y)
{
    BOOL        bMore;
    PATHDATA    pd;
    POINTFIX*   pptfx;
    ULONG       cptfx;

    if ((x != 0) || (y != 0))
    {
        EPOINTL eptl(x, y);

        ((EPATHOBJ*) ppo)->vOffset(eptl);
    }
}

/*********************************Macro************************************\
* macro OFFBITBLT
*
* This handy little macro invokes OffBitBlt to call either EngBitBlt or
* DrvBitBlt, depending on whether the destination surface is owned by
* the device.
\**************************************************************************/

#define OFFBITBLT(pOffDst_, psoDst_, pOffSrc_, psoSrc_, psoMsk_, pco_,  \
                  pxlo_, prclDst_, pptlSrc_, pptlMsk_, pbo_, pptlBrush_,\
                  rop4_)                                                \
    OffBitBlt(PPFNDIRECT(psoDst_, BitBlt),                              \
     pOffDst_, psoDst_, pOffSrc_, psoSrc_, psoMsk_, pco_,               \
     pxlo_, prclDst_, pptlSrc_, pptlMsk_, pbo_, pptlBrush_, rop4_)

/*********************************Macro************************************\
* macro OFFCOPYBITS
*
* This handy little macro invokes OffCopyBits to call either EngCopyBits or
* DrvCopyBits, depending on whether either of the surfaces are owned by
* the device.
\**************************************************************************/

#define OFFCOPYBITS(pOffDst_, psoDst_, pOffSrc_, psoSrc_, pco_, pxlo_,  \
                    prclDst_, pptlSrc_)                                 \
    OffCopyBits(((!(SURFOBJ_TO_SURFACE_NOT_NULL((psoDst_))->flags() & HOOK_CopyBits)\
        && (psoSrc_->hdev))                                             \
        ? PPFNDIRECT(psoSrc_, CopyBits)                                 \
        : PPFNDIRECT(psoDst_, CopyBits)),                               \
    pOffDst_, psoDst_, pOffSrc_, psoSrc_, pco_, pxlo_, prclDst_,        \
    pptlSrc_)

/******************************Public*Routine******************************\
* BOOL Off*
*
* These routines handle the offseting of coordinates given to the driver,
* for the purposes of multi-monitor and sprite support.  Each of these
* routines correspond to a DDI drawing call, and offsets all drawing
* coordinates by the 'xOffset' and 'yOffset' values in the corresponding
* SURFOBJ.
*
* Some complex DDI data-structures such as PATHOBJs and TEXTOBJs must be
* modified in-place; they are always reset to their original values before
* returning.
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

/******************************Public*Routine******************************\
* BOOL OffStrokePath
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffStrokePath(
PFN_DrvStrokePath   pfnStrokePath,
POINTL*             pOffset,
SURFOBJ*            pso,
PATHOBJ*            ppo,
CLIPOBJ*            pco,
XFORMOBJ*           pxo,
BRUSHOBJ*           pbo,
POINTL*             pptlBrush,
LINEATTRS*          pla,
MIX                 mix)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    PATHOBJ_vOffset(ppo, x, y);
    CLIPOBJ_vOffset(pco, x, y);
    OFFSET_POINTL(pptlBrush, x, y);

    BOOL bRet = pfnStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    if ((bRet == FALSE) &&
        ((pla->fl & LA_GEOMETRIC) || (ppo->fl & PO_BEZIERS)))
    {
        // When given a wideline, or given a line composed of bezier curves,
        // the driver can return FALSE from DrvStrokePath to indicate that
        // it would like the drawing broken up into simpler Drv calls.
        // Unfortunately, this poses a problem for us because we might have
        // just drawn and succeeded an XOR DrvStrokePath to a different area.
        // If we returned FALSE, GDI would pop through the DrvStrokePath
        // path and touch all the areas again, thus erasing the DrvStrokePath
        // that is supposed to be drawn in the previous area!
        //
        // For this reason, we try not to return FALSE from optional calls.

        bRet = EngStrokePath(pso, ppo, pco, pxo, pbo, pptlBrush, pla, mix);
    }

    PATHOBJ_vOffset(ppo, -x, -y);
    CLIPOBJ_vOffset(pco, -x, -y);
    ASSERT_BRUSH_ORIGIN(pptlBrush, x, y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffFillPath
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffFillPath(
PFN_DrvFillPath pfnFillPath,
POINTL*         pOffset,
SURFOBJ*        pso,
PATHOBJ*        ppo,
CLIPOBJ*        pco,
BRUSHOBJ*       pbo,
POINTL*         pptlBrush,
MIX             mix,
FLONG           flOptions)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    PATHOBJ_vOffset(ppo, x, y);
    CLIPOBJ_vOffset(pco, x, y);
    OFFSET_POINTL(pptlBrush, x, y);

    BOOL bRet = pfnFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    if (bRet == FALSE)
    {
        // The driver can return FALSE from DrvFillPath to indicate that
        // it would like the drawing broken up into simpler Drv calls.
        // Unfortunately, this poses a problem for us because we might have
        // just drawn and succeeded an XOR DrvFillPath to a different area.
        // If we returned FALSE, GDI would pop through the DrvFillPath
        // path and touch all the areas again, thus erasing the DrvFillPath
        // that is supposed to be drawn in the previous area!
        //
        // For this reason, we try not to return FALSE from optional calls.

        bRet = EngFillPath(pso, ppo, pco, pbo, pptlBrush, mix, flOptions);
    }

    PATHOBJ_vOffset(ppo, -x, -y);
    CLIPOBJ_vOffset(pco, -x, -y);
    ASSERT_BRUSH_ORIGIN(pptlBrush, x, y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffStrokeAndFillPath
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffStrokeAndFillPath(
PFN_DrvStrokeAndFillPath    pfnStrokeAndFillPath,
POINTL*                     pOffset,
SURFOBJ*                    pso,
PATHOBJ*                    ppo,
CLIPOBJ*                    pco,
XFORMOBJ*                   pxo,
BRUSHOBJ*                   pboStroke,
LINEATTRS*                  pla,
BRUSHOBJ*                   pboFill,
POINTL*                     pptlBrush,
MIX                         mixFill,
FLONG                       flOptions)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    PATHOBJ_vOffset(ppo, x, y);
    CLIPOBJ_vOffset(pco, x, y);
    OFFSET_POINTL(pptlBrush, x, y);

    BOOL bRet = pfnStrokeAndFillPath(pso, ppo, pco, pxo, pboStroke, pla,
                                     pboFill, pptlBrush, mixFill, flOptions);
    if (bRet == FALSE)
    {
        // The driver can return FALSE from DrvStrokeAndFillPath to indicate
        // that it would like the drawing broken up into simpler Drv calls.
        // Unfortunately, this poses a problem for us because we might have
        // just drawn and succeeded an XOR DrvStrokeAndFillPath to a different
        // area.  If we returned FALSE, GDI would pop through the
        // DrvStrokeAndFillPath path and touch all the areas again, thus
        // erasing the DrvStrokeAndFillPath that is supposed to be drawn in
        // the previous area!
        //
        // For this reason, we try not to return FALSE from optional calls.

        bRet = EngStrokeAndFillPath(pso, ppo, pco, pxo, pboStroke, pla,
                                    pboFill, pptlBrush, mixFill, flOptions);
    }

    PATHOBJ_vOffset(ppo, -x, -y);
    CLIPOBJ_vOffset(pco, -x, -y);
    ASSERT_BRUSH_ORIGIN(pptlBrush, x, y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffTextOut
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffTextOut(
PFN_DrvTextOut  pfnTextOut,
POINTL*         pOffset,
SURFOBJ*        pso,
STROBJ*         pstro,
FONTOBJ*        pfo,
CLIPOBJ*        pco,
RECTL*          prclExtra,    // Not used by display drivers
RECTL*          prclOpaque,
BRUSHOBJ*       pboFore,
BRUSHOBJ*       pboOpaque,
POINTL*         pptlOrg,      // Not used by display drivers
MIX             mix)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    ASSERTGDI(prclExtra == NULL, "Unexpected non-NULL prclExtra");

    // Must offset a copy of 'prclOpaque' first because GDI sometimes
    // points 'prclOpaque' to '&pstro->rclBkGround', and so we would
    // do the offset twice.

    OFFSET_RECTL(prclOpaque, x, y);
    STROBJ_vOffset(pstro, x, y);
    CLIPOBJ_vOffset(pco, x, y);

    BOOL bRet = pfnTextOut(pso, pstro, pfo, pco, prclExtra, prclOpaque,
                           pboFore, pboOpaque, pptlOrg, mix);

    STROBJ_vOffset(pstro, -x, -y);
    CLIPOBJ_vOffset(pco, -x, -y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffLineTo
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffLineTo(
PFN_DrvLineTo   pfnLineTo,
POINTL*         pOffset,
SURFOBJ*        pso,
CLIPOBJ*        pco,
BRUSHOBJ*       pbo,
LONG            x1,
LONG            y1,
LONG            x2,
LONG            y2,
RECTL*          prclBounds,
MIX             mix)
{
    LONG    x;
    LONG    y;

    x = pOffset->x;
    y = pOffset->y;

    CLIPOBJ_vOffset(pco, x, y);
    x1 += x;
    x2 += x;
    y1 += y;
    y2 += y;
    OFFSET_RECTL(prclBounds, x, y);

    BOOL bRet = pfnLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
    if (!bRet)
    {
        // The driver can return FALSE from DrvLineTo to indicate that
        // it would like to instead by called via DrvStrokePath.
        // Unfortunately, this poses a problem for us because we might have
        // just drawn and succeeded an XOR DrvLineTo to a different area.
        // If we returned FALSE, GDI would pop through the DrvStrokePath
        // path and touch all the areas again, thus erasing the DrvLineTo
        // that is supposed to be drawn in the previous area!
        //
        // For this reason, we try not to return FALSE from optional calls.

        bRet = EngLineTo(pso, pco, pbo, x1, y1, x2, y2, prclBounds, mix);
    }

    CLIPOBJ_vOffset(pco, -x, -y);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffGradientFill
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffGradientFill(
PFN_DrvGradientFill pfnGradientFill,
POINTL*             pOffset,
SURFOBJ*            pso,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
TRIVERTEX*          pVertex,
ULONG               nVertex,
PVOID               pMesh,
ULONG               nMesh,
RECTL*              prclExtents,
POINTL*             pptlDitherOrg,
ULONG               ulMode)
{
    LONG        x;
    LONG        y;
    ULONG       i;
    TRIVERTEX*  pTmp;

    x = pOffset->x;
    y = pOffset->y;

    CLIPOBJ_vOffset(pco, x, y);
    OFFSET_RECTL(prclExtents, x, y);

    // The offseting of the dither origin is different than that of the other
    // data structures.  The dither origin is defined to be the negative of
    // the offset of the window relative to the origin of the desktop surface.
    // The right value to pass to xxxGradientFill would be the negative of the
    // offset of the window relative to the origin of the sprite surface/
    // PDEV surface (for multimon).  This is computed by subtracting the
    // pOffset from pptlDitherOrg.
    //
    // From definition of dither origin:
    // pptlDitherOrg = (-xWin_surf, -yWin_surf)
    //
    // From surface to desktop coordinate conversion:
    // (xWin_surf, yWin_surf) = (xWin_desk-xSurf_desk, yWin_desk-ySurf_desk)
    // where (xSurf_Desk, ySurf_desk) is the surface origin relative to the
    // desktop (corresponds to -pOffset in this function).
    //
    // Putting the two together, we get:
    // pptlDitherOrg = (-(xWin_desk-xSurf_desk), -(yWin_desk-ySurf_desk))=
    //               = (-xWin_desk+xSurf_desk, -yWin_desk+ySurf_desk) =
    //               = (-xWin_desk, -yWin_desk) + (xSurf_desk, ySurf_desk) =
    //               = pptlDitherOrg_desk + (-pOffset)
    //               = pptlDitherOrg_desk - pOffset
    //

    OFFSET_POINTL(pptlDitherOrg, (-x), (-y));

    for (pTmp = pVertex, i = 0; i < nVertex; i++, pTmp++)
    {
        pTmp->x += x;
        pTmp->y += y;
    }

    BOOL bRet = pfnGradientFill(pso, pco, pxlo, pVertex, nVertex, pMesh,
                                nMesh, prclExtents, pptlDitherOrg, ulMode);

    CLIPOBJ_vOffset(pco, -x, -y);
    for (pTmp = pVertex, i = 0; i < nVertex; i++, pTmp++)
    {
        pTmp->x -= x;
        pTmp->y -= y;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffBitBlt
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffBitBlt(
PFN_DrvBitBlt   pfnBitBlt,
POINTL*         pOffDst,
SURFOBJ*        psoDst,
POINTL*         pOffSrc,
SURFOBJ*        psoSrc,
SURFOBJ*        psoMsk,
CLIPOBJ*        pco,
XLATEOBJ*       pxlo,
RECTL*          prclDst,
POINTL*         pptlSrc,
POINTL*         pptlMsk,
BRUSHOBJ*       pbo,
POINTL*         pptlBrush,
ROP4            rop4)
{
    LONG    xDst;
    LONG    yDst;

    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL_NOT_NULL(prclDst, xDst, yDst);
    OFFSET_POINTL(pptlSrc, pOffSrc->x, pOffSrc->y);
    OFFSET_POINTL(pptlBrush, xDst, yDst);
    ASSERTGDI((!psoSrc)                            ||
              (!(psoSrc->dhpdev) || !(psoDst->dhpdev)) ||
              (psoSrc->dhpdev == psoDst->dhpdev),
              "OffBitBlt: ERROR blitting across devices.");

    BOOL bRet = pfnBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                          pptlMsk, pbo, pptlBrush, rop4);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);
    ASSERT_BRUSH_ORIGIN(pptlBrush, xDst, yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffCopyBits
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffCopyBits(
PFN_DrvCopyBits pfnCopyBits,
POINTL*         pOffDst,
SURFOBJ*        psoDst,
POINTL*         pOffSrc,
SURFOBJ*        psoSrc,
CLIPOBJ*        pco,
XLATEOBJ*       pxlo,
RECTL*          prclDst,
POINTL*         pptlSrc)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    if (pco != NULL)
        CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL_NOT_NULL(prclDst, xDst, yDst);
    OFFSET_POINTL_NOT_NULL(pptlSrc, xSrc, ySrc);
    ASSERTGDI((!psoSrc)                                ||
              (!(psoSrc->dhpdev) || !(psoDst->dhpdev)) ||
              (psoSrc->dhpdev == psoDst->dhpdev),
              "OffCopyBits: ERROR copying across devices.");

    // A defacto DDI rule is that on a CopyBits call, the bounds of a complex
    // clip object must intersect with the destination rectangle.  This
    // is due to that fact that some drivers, such as the VGA driver, do not
    // bother checking for intersection with the destination rectangle when
    // enumerating a complex clip object.  Thus, if this assert is hit, the
    // routine which constructed the clip object will have to be fixed.  Note
    // that this is unrelated to sprites; I simply put this assert here because
    // it was a handy place for it, to check all CopyBits calls.

    ASSERTGDI((pco == NULL)                     ||
              (pco->iDComplexity == DC_TRIVIAL) ||
              bIntersect(&pco->rclBounds, prclDst),
        "Clip object bounds doesn't intersect destination rectangle");

    BOOL bRet = pfnCopyBits(psoDst, psoSrc, pco, pxlo, prclDst, pptlSrc);

    if (pco != NULL)
        CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffStretchBlt
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffStretchBlt(
PFN_DrvStretchBlt   pfnStretchBlt,
POINTL*             pOffDst,
SURFOBJ*            psoDst,
POINTL*             pOffSrc,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlHTOrg,
RECTL*              prclDst,
RECTL*              prclSrc,
POINTL*             pptlMsk,
ULONG               iMode)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL_NOT_NULL(prclDst, xDst, yDst);
    OFFSET_RECTL_NOT_NULL(prclSrc, xSrc, ySrc);
    OFFSET_POINTL(pptlHTOrg, xDst, yDst);

    BOOL bRet = pfnStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                              pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffStretchBltROP
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffStretchBltROP(
PFN_DrvStretchBltROP    pfnStretchBltROP,
POINTL*                 pOffDst,
SURFOBJ*                psoDst,
POINTL*                 pOffSrc,
SURFOBJ*                psoSrc,
SURFOBJ*                psoMsk,
CLIPOBJ*                pco,
XLATEOBJ*               pxlo,
COLORADJUSTMENT*        pca,
POINTL*                 pptlHTOrg,
RECTL*                  prclDst,
RECTL*                  prclSrc,
POINTL*                 pptlMsk,
ULONG                   iMode,
BRUSHOBJ*               pbo,
DWORD                   rop4)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL(prclDst, xDst, yDst);
    OFFSET_RECTL(prclSrc, xSrc, ySrc);
    OFFSET_POINTL(pptlHTOrg, xDst, yDst);

    BOOL bRet = pfnStretchBltROP(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                                 pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode,
                                 pbo, rop4);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);

}

/******************************Public*Routine******************************\
* BOOL OffTransparentBlt
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffTransparentBlt(
PFN_DrvTransparentBlt   pfnTransparentBlt,
POINTL*                 pOffDst,
SURFOBJ*                psoDst,
POINTL*                 pOffSrc,
SURFOBJ*                psoSrc,
CLIPOBJ*                pco,
XLATEOBJ*               pxlo,
RECTL*                  prclDst,
RECTL*                  prclSrc,
ULONG                   iTransColor,
ULONG                   ulReserved)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL(prclDst, xDst, yDst);
    OFFSET_RECTL(prclSrc, xSrc, ySrc);

    BOOL bRet = pfnTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc,
                                  iTransColor, ulReserved);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffDrawStream
*
* 1-27-2001 bhouse
* Wrote it.
\**************************************************************************/

BOOL OffDrawStream(
PFN_DrvDrawStream       pfnDrawStream,
POINTL*                 pOffDst,
SURFOBJ*                psoDst,
SURFOBJ*                psoSrc,
CLIPOBJ*                pco,
XLATEOBJ*               pxlo,
RECTL*                  prclDstBounds,
POINTL*                 pptlDstOffset,
ULONG                   ulIn,
PVOID                   pvIn,
DSSTATE*                pdss
)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL(prclDstBounds, xDst, yDst);
    OFFSET_POINTL(pptlDstOffset, xDst, yDst);

    BOOL bRet = pfnDrawStream(psoDst, psoSrc, pco, pxlo, prclDstBounds, pptlDstOffset, ulIn, pvIn, pdss);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffAlphaBlend
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffAlphaBlend(
PFN_DrvAlphaBlend   pfnAlphaBlend,
POINTL*             pOffDst,
SURFOBJ*            psoDst,
POINTL*             pOffSrc,
SURFOBJ*            psoSrc,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
RECTL*              prclDst,
RECTL*              prclSrc,
BLENDOBJ*           pBlendObj)
{
    LONG    xDst;
    LONG    yDst;
    LONG    xSrc;
    LONG    ySrc;

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_RECTL(prclDst, xDst, yDst);
    OFFSET_RECTL(prclSrc, xSrc, ySrc);

    BOOL bRet = pfnAlphaBlend(psoDst, psoSrc, pco, pxlo, prclDst, prclSrc,
                              pBlendObj);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL OffPlgBlt
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL OffPlgBlt(
PFN_DrvPlgBlt       pfnPlgBlt,
POINTL*             pOffDst,
SURFOBJ*            psoDst,
POINTL*             pOffSrc,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlBrush,
POINTFIX*           pptfx,
RECTL*              prcl,
POINTL*             pptlMsk,
ULONG               iMode)
{
    LONG        xDst;
    LONG        yDst;
    LONG        xSrc;
    LONG        ySrc;
    POINTFIX    aptfx[3];

    xSrc = pOffSrc->x;
    ySrc = pOffSrc->y;
    xDst = pOffDst->x;
    yDst = pOffDst->y;

    CLIPOBJ_vOffset(pco, xDst, yDst);
    OFFSET_POINTL(pptlBrush, xDst, yDst);
    OFFSET_RECTL(prcl, xSrc, ySrc);

    aptfx[0].x = pptfx[0].x + (xDst << 4);
    aptfx[1].x = pptfx[1].x + (xDst << 4);
    aptfx[2].x = pptfx[2].x + (xDst << 4);
    aptfx[0].y = pptfx[0].y + (yDst << 4);
    aptfx[1].y = pptfx[1].y + (yDst << 4);
    aptfx[2].y = pptfx[2].y + (yDst << 4);

    BOOL bRet = pfnPlgBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca, pptlBrush,
                          aptfx, prcl, pptlMsk, iMode);

    CLIPOBJ_vOffset(pco, -xDst, -yDst);
    ASSERT_BRUSH_ORIGIN(pptlBrush, xDst, yDst);

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vSpOrderInY
*
* Re-orders the sprite in the sorted-in-Y list.
*
* 'pSprite' must already be in the list, and all the other elements of the
* list must be properly sorted.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpOrderInY(
SPRITE* pSprite)
{
    LONG    yThis;
    SPRITE* pPrevious;
    SPRITE* pNext;

    ASSERTGDI(pSprite->pState->pListY != NULL,
        "If there's a sprite, there should be a Y-list!");

    yThis = pSprite->rclSprite.top;
    if ((pSprite->pPreviousY != NULL) &&
        (pSprite->pPreviousY->rclSprite.top > yThis))
    {
        // The sprite has to move up in the list.  First, remove
        // the sprite's node from its current position:

        pPrevious = pSprite->pPreviousY;
        pNext = pSprite->pNextY;
        pPrevious->pNextY = pNext;
        if (pNext)
            pNext->pPreviousY = pPrevious;

        // Find the sprite's proper position in the list:

        pNext = pPrevious;
        while (((pPrevious = pNext->pPreviousY) != NULL) &&
               (pPrevious->rclSprite.top > yThis))
            pNext = pPrevious;

        // Insert the sprite in its new position:

        pSprite->pPreviousY = pPrevious;
        pSprite->pNextY = pNext;
        pNext->pPreviousY = pSprite;
        if (pPrevious)
            pPrevious->pNextY = pSprite;
        else
            pSprite->pState->pListY = pSprite;
    }
    else if ((pSprite->pNextY != NULL) &&
             (pSprite->pNextY->rclSprite.top < yThis))
    {
        // The sprite has to move down in the list.  First, remove
        // the sprite's node from its current position:

        pNext = pSprite->pNextY;
        pPrevious = pSprite->pPreviousY;
        pNext->pPreviousY = pPrevious;
        if (pPrevious)
            pPrevious->pNextY = pNext;
        else
            pSprite->pState->pListY = pNext;

        // Find the sprite's proper position in the list:

        pPrevious = pNext;
        while (((pNext = pPrevious->pNextY) != NULL) &&
               (pNext->rclSprite.top < yThis))
            pPrevious = pNext;

        // Insert the sprite in its new position:

        pSprite->pPreviousY = pPrevious;
        pSprite->pNextY = pNext;
        pPrevious->pNextY = pSprite;
        if (pNext)
            pNext->pPreviousY = pSprite;
    }
}

/******************************Public*Routine******************************\
* VOID vSpComputeUncoveredRegion
*
* We construct the true RGNOBJ representing the uncovered portions of
* the screen directly from the sprite-range list.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpComputeUncoveredRegion(
SPRITESTATE*    pState)
{
    REGION* prgnUncovered;
    SIZE_T  sizt;

    // As a simple guess as to the size of the necessary region, we simply
    // use the sprite-range size:

    ASSERTGDI(sizeof(SPRITERANGE) + sizeof(SPRITESCAN) >= NULL_SCAN_SIZE,
        "Our guess will be wrong!");
    ASSERTGDI(pState->pRangeLimit > pState->pRange,
        "pRange/pRangeLimit mismatch");

    sizt = (BYTE*) pState->pRangeLimit - (BYTE*) pState->pRange;

    // Add in the size of a header, which our sprite ranges don't have:

    sizt += NULL_REGION_SIZE;

    prgnUncovered = pState->prgnUncovered;
    if (prgnUncovered->sizeObj < sizt)
    {
        // If the allocation fails, we'll simply stick with the old region
        // and draw wrong (but we won't crash):

        RGNMEMOBJ rmoNew((ULONGSIZE_T)sizt);
        if (!rmoNew.bValid())
            return;

        RGNOBJ roOld(prgnUncovered);
        roOld.vDeleteRGNOBJ();

        prgnUncovered = rmoNew.prgnGet();
        pState->prgnUncovered = prgnUncovered;
    }

    RGNOBJ roUncovered(pState->prgnUncovered);

    PDEVOBJ po(pState->hdev);

    roUncovered.vComputeUncoveredSpriteRegion(po);
    roUncovered.vTighten();

    ASSERTGDI(sizt >= roUncovered.sizeRgn(),
        "Uh oh, we overwrote the end of the region!");

    // Any DirectDraw locked areas have to be added back to the uncovered
    // area:

    if (pState->prgnUnlocked != NULL)
    {
        RGNOBJ roUnlocked(pState->prgnUnlocked);
        RGNOBJ roTmp(pState->prgnTmp);

        RGNMEMOBJTMP rmoLocked;
        if (rmoLocked.bValid())
        {
            roTmp.vSet(&pState->rclScreen);
            if (!rmoLocked.bMerge(roTmp, roUnlocked, gafjRgnOp[RGN_DIFF]))
            {
                rmoLocked.vSet();
            }
            if (!roTmp.bMerge(roUncovered, rmoLocked, gafjRgnOp[RGN_OR]))
            {
                roTmp.vSet();
            }

            pState->prgnUncovered = roTmp.prgnGet();
            pState->prgnTmp = roUncovered.prgnGet();
        }
    }

    pState->prgnUncovered->vStamp();
}

/******************************Public*Routine******************************\
* VOID vSpSetNullRange
*
* Resets the sprite range to a null area.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpSetNullRange(
SPRITESTATE*    pState,
SPRITESCAN*     pScan)  // Must be pool allocated (it will be freed later)
                        //   and at least sizeof(SPRITESCAN)
{
    pScan->yTop         = pState->rclScreen.top;
    pScan->yBottom      = pState->rclScreen.bottom;
    pScan->siztScan     = sizeof(SPRITESCAN);
    pScan->siztPrevious = 0;

    pScan->aRange[0].xLeft   = pState->rclScreen.left;
    pScan->aRange[0].xRight  = pState->rclScreen.right;
    pScan->aRange[0].pSprite = NULL;

    pState->pRange      = pScan;
    pState->pRangeLimit = pScan + 1;
}

#define BATCH_ALLOC_COUNT 20

inline SPRITERANGE* pSpRangeLimit(
SPRITESTATE*    pState)
{
    // We adjust the range limit to leave room for that extra SPRITESCAN
    // structure we allocated.  It's also VERY important that we remove a
    // SPRITERANGE structure to account for sizeof(SPRITERANGE) not
    // dividing evenly into sizeof(SPRITESCAN):

    return((SPRITERANGE*) ((BYTE*) pState->pRangeLimit
            - sizeof(SPRITESCAN) - sizeof(SPRITERANGE)));
}

/******************************Public*Routine******************************\
* SPRITERANGE* pSpGrowRanges
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SPRITERANGE* pSpGrowRanges(
SPRITESTATE*    pState,
SPRITERANGE*    pCurrentRange,
SPRITESCAN**    ppCurrentScan,
SPRITERANGE**   ppRangeLimit)
{
    SPRITESCAN*     pNewRegion;
    SIZE_T          siztOldAlloc;
    SIZE_T          siztNewAlloc;
    SIZE_T          siztCurrentRange;
    SIZE_T          siztCurrentScan;

#if DEBUG_SPRITES
    KdPrint(("GDI: Growing sprite ranges\n"));
#endif

    // We always add in the size of a SPRITESCAN structure to allow
    // 'bSpComputeScan' to initialize it without checking:

    siztCurrentRange  = (BYTE*) pCurrentRange        - (BYTE*) pState->pRange;
    siztCurrentScan   = (BYTE*) *ppCurrentScan       - (BYTE*) pState->pRange;
    siztOldAlloc      = (BYTE*) pState->pRangeLimit - (BYTE*) pState->pRange;
    siztNewAlloc      = siztOldAlloc + sizeof(SPRITESCAN)
                      + sizeof(SPRITERANGE) * BATCH_ALLOC_COUNT;

    pNewRegion = (SPRITESCAN*) PALLOCNOZ((ULONGSIZE_T)siztNewAlloc, 'rpsG');
    if (pNewRegion == NULL)
    {
        vSpSetNullRange(pState, pState->pRange);

        // Should we mark every sprite as invisible?

        return(NULL);
    }

    RtlCopyMemory(pNewRegion, pState->pRange, siztCurrentRange);

    VFREEMEM(pState->pRange);

    pState->pRange      = pNewRegion;
    pState->pRangeLimit = (BYTE*) pNewRegion + siztNewAlloc;

    *ppCurrentScan  = (SPRITESCAN*)  ((BYTE*) pNewRegion + siztCurrentScan);
    *ppRangeLimit   = pSpRangeLimit(pState);

    return((SPRITERANGE*) ((BYTE*) pNewRegion + siztCurrentRange));
}

/******************************Public*Routine******************************\
* BOOL bSpComputeScan
*
*  12-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpComputeScan(
SPRITESTATE*    pState,
SPRITE*         pActiveList,
LONG            yTop,
LONG            yBottom,
SPRITESCAN**    ppScan,
SIZE_T*         psiztPrevious)
{
    SPRITESCAN*     pScan;
    SPRITERANGE*    pRange;
    SPRITERANGE*    pRangeLimit;
    SPRITERANGE*    pTmp;
    SPRITE*         pSprite;
    LONG            xLeft;
    LONG            xRight;
    LONG            xFinalRight;
    LONG            cSprites;

    ASSERTGDI(yTop < yBottom, "Invalid empty row");

    xLeft       = pState->rclScreen.left;
    xRight      = pState->rclScreen.right;
    xFinalRight = pState->rclScreen.right;

    pScan = *ppScan;

    pScan->yTop         = yTop;
    pScan->yBottom      = yBottom;
    pScan->siztPrevious = *psiztPrevious;

    pRangeLimit = pSpRangeLimit(pState);
    pRange      = &pScan->aRange[0];

    // Note that we always adjust 'pRangeLimit' to leave room for a
    // SPRITESCAN structure:

    ASSERTGDI((pScan >= (SPRITESCAN*) pState->pRange) &&
              (pScan + 1 <= (SPRITESCAN*) pState->pRangeLimit),
        "pScan will overwrite buffer end!");
    ASSERTGDI(pState->pRange < pState->pRangeLimit,
        "pRange/pRangeLimit mismatch");

    do {
        cSprites = 0;
        for (pSprite = pActiveList;
             pSprite != NULL;
             pSprite = pSprite->pNextActive)
        {
            ASSERTGDI((pSprite != NULL) &&
                      (pSprite->rclSprite.top <= yTop) &&
                      (pSprite->rclSprite.bottom >= yBottom) &&
                      (pSprite->rclSprite.left < pSprite->rclSprite.right) &&
                      (pSprite->rclSprite.top < pSprite->rclSprite.bottom),
                "Invalid active list");

            if (pSprite->rclSprite.left <= xLeft)
            {
                if (pSprite->rclSprite.right > xLeft)
                {
                    cSprites++;

                    // Add this sprite:

                    if (pRange >= pRangeLimit)
                    {
                        pRange = pSpGrowRanges(pState,
                                               pRange,
                                               &pScan,
                                               &pRangeLimit);
                        if (!pRange)
                            return(FALSE);
                    }

                    pRange->pSprite = pSprite;
                    pRange++;

                    if (pSprite->rclSprite.right <= xRight)
                        xRight = pSprite->rclSprite.right;
                }
            }
            else if (pSprite->rclSprite.left <= xRight)
            {
                xRight = pSprite->rclSprite.left;
            }
        }

        if (cSprites == 0)
        {
            if (pRange >= pRangeLimit)
            {
                pRange = pSpGrowRanges(pState, pRange, &pScan, &pRangeLimit);
                if (!pRange)
                    return(FALSE);
            }

            pRange->pSprite = NULL;
            pRange->xLeft   = xLeft;
            pRange->xRight  = xRight;
            pRange++;
        }
        else
        {
            // Now, fill in the wall values for every range we just
            // put down:

            pTmp = pRange;
            do {
                pTmp--;
                pTmp->xLeft = xLeft;
                pTmp->xRight = xRight;

            } while (--cSprites != 0);
        }

        // Advance to the next rectangle in this scan:

        xLeft  = xRight;
        xRight = xFinalRight;

    } while (xLeft < xRight);

    pScan->siztScan = (BYTE*) pRange - (BYTE*) pScan;
    *psiztPrevious  = pScan->siztScan;
    *ppScan         = (SPRITESCAN*) pRange;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL vSpComputeSpriteRanges
*
* Recalculates the 'range' list that describes how the overlays overlap
* the screen.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpComputeSpriteRanges(
SPRITESTATE* pState)
{
    SPRITE*     pPrevious;
    SPRITE*     pNext;
    SPRITE*     pThis;
    SPRITE*     pSpriteY;
    BOOL        bSprite;
    SPRITE      ActiveHead;
    LONG        yTop;
    LONG        yBottom;
    LONG        yFinalBottom;
    SPRITESCAN* pCurrentScan;
    SIZE_T      siztPrevious;

    ASSERTGDI(!(pState->bValidRange),
        "Should be called only when dirty.");

    pCurrentScan = pState->pRange;
    siztPrevious = 0;

    ActiveHead.pNextActive = NULL;

    yTop         = pState->rclScreen.top;
    yBottom      = pState->rclScreen.bottom;
    yFinalBottom = pState->rclScreen.bottom;

    // First, skip over any invisible sprites:

    pSpriteY = pState->pListY;
    while ((pSpriteY != NULL) && (pSpriteY->rclSprite.bottom <= yTop))
        pSpriteY = pSpriteY->pNextY;

    do {
        // Prune the active list, throwing out anyone whose bottom
        // matches the previous row's bottom, and at the same time
        // compute the new bottom:

        pPrevious = &ActiveHead;
        while ((pThis = pPrevious->pNextActive) != NULL)
        {
            if (pThis->rclSprite.bottom == yTop)
            {
                pPrevious->pNextActive = pThis->pNextActive;
            }
            else
            {
                if (pThis->rclSprite.bottom <= yBottom)
                    yBottom = pThis->rclSprite.bottom;

                // Advance to next node:

                pPrevious = pThis;
            }
        }

        // Add to the active list any sprites that have a 'top'
        // value equal to the new top, watching out for a new
        // 'bottom' value:

        while (pSpriteY != NULL)
        {
            if (pSpriteY->rclSprite.top != yTop)
            {
                // Any not-yet-used sprites may affect the height of
                // this row:

                if (pSpriteY->rclSprite.top <= yBottom)
                    yBottom = pSpriteY->rclSprite.top;

                break;                          // =======>
            }

            // The active list is kept in back-to-front z-order:

            pNext = &ActiveHead;
            do {
                pPrevious = pNext;
                pNext = pPrevious->pNextActive;
            } while ((pNext != NULL) && (pNext->z < pSpriteY->z));

            pPrevious->pNextActive = pSpriteY;
            pSpriteY->pNextActive = pNext;

            if (pSpriteY->rclSprite.bottom <= yBottom)
                yBottom = pSpriteY->rclSprite.bottom;

            pSpriteY = pSpriteY->pNextY;
        }

        // Now, use the active-list to compute the new row:

        if (!bSpComputeScan(pState,
                            ActiveHead.pNextActive,
                            yTop,
                            yBottom,
                            &pCurrentScan,
                            &siztPrevious))
        {
            // In case of failure, 'bSpComputeScan' leaves the structure
            // empty but consistent, so we can safely just leave:

            return;
        }

        // Advance to the next row:

        yTop    = yBottom;
        yBottom = yFinalBottom;

    } while (yTop < yBottom);

    // The range cache is now valid:

    pState->bValidRange = TRUE;

    // Finally, use the sprite range to compute a true region representing
    // the uncovered parts:

    vSpComputeUncoveredRegion(pState);
}

/******************************Public*Routine******************************\
* ENUMAREAS::ENUMAREAS
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ENUMAREAS::ENUMAREAS(
SPRITESTATE*    pState,
RECTL*          prclBounds,       // Must be pre-clipped to screen
ULONG           iDirection)       // CD_RIGHTDOWN is the default
{
    LONG            yStart;
    SPRITESCAN*     pTmpScan;
    SPRITERANGE*    pTmpRange;

    if (!pState->bValidRange)
    {
        vSpComputeSpriteRanges(pState);
    }
    bValidRange = pState->bValidRange; // valid only if the sprite range
                                       // computation succeeded

    // BUGFIX #22140 2-18-2000 bhouse
    // We will just leave this assertion code commented out for now.  If we
    // ever have a bug causing us to fix the how we calculate the bounds
    // in BLTRECORD__bRotate then perhaps we can un-comment out these
    // lines.
    // ASSERTGDI((prclBounds->left   >= pState->rclScreen.left)   &&
    //           (prclBounds->top    >= pState->rclScreen.top)),
    //           "invalid rectangle");

    ASSERTGDI((prclBounds->right  <= pState->rclScreen.right)  &&
              (prclBounds->bottom <= pState->rclScreen.bottom) &&
              (prclBounds->left   < prclBounds->right)         &&
              (prclBounds->top    < prclBounds->bottom),
        "Invalid rectangle specified");

    iDir          = iDirection;
    xBoundsLeft   = prclBounds->left;
    xBoundsRight  = prclBounds->right;
    yBoundsTop    = prclBounds->top;
    yBoundsBottom = prclBounds->bottom;

    // Find the first scan that contains the start 'y' value:

    yStart = (iDirection & 2) ? (yBoundsBottom - 1) : (yBoundsTop);
    pTmpScan = pState->pRange;
    while (pTmpScan->yBottom <= yStart)
        pTmpScan = pSpNextScan(pTmpScan);

    // If more than one sprite overlaps a region, there will be
    // multiple sprite-range records for the same area.  When
    // going left-to-right, we should leave 'pTmpRange' pointing to
    // the start of this sequence; when going right-to-left, we
    // should leave 'pTmpRange' pointing to the end of this sequence.

    if ((iDirection & 1) == 0)          // Left-to-right
    {
        pTmpRange = &pTmpScan->aRange[0];
        while (pTmpRange->xRight <= xBoundsLeft)
            pTmpRange++;
    }
    else                                // Right-to-left
    {
        pTmpRange = pSpLastRange(pTmpScan);
        while (pTmpRange->xLeft >= xBoundsRight)
            pTmpRange--;
    }

    yTop    = max(pTmpScan->yTop,    yBoundsTop);
    yBottom = min(pTmpScan->yBottom, yBoundsBottom);

    // We used temporary variables as opposed to the structure members
    // directly so that the compiler would be more efficient:

    pScan = pTmpScan;
    pRange = pTmpRange;
}

/******************************Public*Routine******************************\
* BOOL ENUMAREAS::bEnum
*
* This routine enumerates the list of sprite and non-sprite ranges
* comprising a rectangular area on the screen.  If two sprites overlap,
* for the overlapping rectangle this routine will always return the
* bottom-most sprite.
*
* Returns TRUE if more ranges after this remain to be enumerated.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMAREAS::bEnum(
SPRITE**    ppSprite,       // Returns touched sprite.  This will be NULL
                            //   if the enumerated area is touched by
                            //   no sprite
RECTL*      prclSprite)     // Returns area of sprite touched
{
    SPRITESCAN*     pTmpScan;
    SPRITERANGE*    pTmpRange;

    // Use local variables where possible to be more efficient in our
    // inner loops:

    pTmpRange = pRange;

    // Remember some state for enumerating the layers:

    pRangeLayer = pTmpRange;
    pScanLayer = pScan;

    // Fill in details about the current range:

    *ppSprite = pTmpRange->pSprite;

    prclSprite->left   = max(pTmpRange->xLeft,  xBoundsLeft);
    prclSprite->right  = min(pTmpRange->xRight, xBoundsRight);
    prclSprite->top    = yTop;
    prclSprite->bottom = yBottom;

    ASSERTGDI((prclSprite->left < prclSprite->right) &&
              (prclSprite->top < prclSprite->bottom),
            "Invalid return rectangle");
    ASSERTGDI((*ppSprite == NULL) ||
              (((*ppSprite)->rclSprite.left   <= prclSprite->left)  &&
               ((*ppSprite)->rclSprite.top    <= prclSprite->top)   &&
               ((*ppSprite)->rclSprite.right  >= prclSprite->right) &&
               ((*ppSprite)->rclSprite.bottom >= prclSprite->bottom)),
            "Invalid return sprite");

    if ((iDir & 1) == 0)            // Left-to-right
    {
        if (pTmpRange->xRight < xBoundsRight)
        {
            do {
                pTmpRange++;
            } while ((pTmpRange - 1)->xLeft == pTmpRange->xLeft);
        }
        else
        {
            pTmpScan = pScan;

            if (iDir == CD_RIGHTDOWN)
            {
                if (pTmpScan->yBottom >= yBoundsBottom)
                    return(FALSE);

                pTmpScan = pSpNextScan(pTmpScan);
            }
            else
            {
                ASSERTGDI(iDir == CD_RIGHTUP, "Unexpected iDir");

                if (pTmpScan->yTop <= yBoundsTop)
                    return(FALSE);

                pTmpScan = pSpPreviousScan(pTmpScan);
            }

            pScan = pTmpScan;

            yTop      = max(pTmpScan->yTop,    yBoundsTop);
            yBottom   = min(pTmpScan->yBottom, yBoundsBottom);
            pTmpRange = &pTmpScan->aRange[0];

            while (pTmpRange->xRight <= xBoundsLeft)
                pTmpRange++;
        }
    }
    else                            // Right-to-left
    {
        if (pTmpRange->xLeft > xBoundsLeft)
        {
            do {
                pTmpRange--;
            } while ((pTmpRange + 1)->xLeft == pTmpRange->xLeft);
        }
        else
        {
            pTmpScan = pScan;

            if (iDir == CD_LEFTDOWN)
            {
                if (pTmpScan->yBottom >= yBoundsBottom)
                    return(FALSE);

                pTmpScan = pSpNextScan(pTmpScan);
            }
            else
            {
                ASSERTGDI(iDir == CD_LEFTUP, "Unexpected iDir");

                if (pTmpScan->yTop <= yBoundsTop)
                    return(FALSE);

                pTmpScan = pSpPreviousScan(pTmpScan);
            }

            pScan = pTmpScan;

            yTop      = max(pTmpScan->yTop,    yBoundsTop);
            yBottom   = min(pTmpScan->yBottom, yBoundsBottom);
            pTmpRange = pSpLastRange(pTmpScan);

            while (pTmpRange->xLeft >= xBoundsRight)
                pTmpRange--;
        }
    }

    pRange = pTmpRange;
    return(TRUE);
}

/******************************Public*Routine******************************\
* ENUMUNCOVERED::ENUMUNCOVERED
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ENUMUNCOVERED::ENUMUNCOVERED(
SPRITESTATE* pState)
{
    if (!pState->bValidRange)
    {
        vSpComputeSpriteRanges(pState);
    }

    yBoundsBottom = pState->rclScreen.bottom;
    pScan = pState->pRange;
    pRange = &pScan->aRange[0] - 1;
    pNextScan = pSpNextScan(pScan);
}

/******************************Public*Routine******************************\
* BOOL ENUMUNCOVERED::bEnum
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMUNCOVERED::bEnum(
RECTL* prclUncovered)
{
    SPRITESCAN*  pTmpScan  = pScan;
    SPRITERANGE* pTmpRange = pRange;

    do {
        pTmpRange++;
        if (pTmpRange >= (SPRITERANGE*) pNextScan)
        {
            if (pTmpScan->yBottom >= yBoundsBottom)
                return(FALSE);

            pTmpScan  = pNextScan;
            pNextScan = pSpNextScan(pNextScan);
            pTmpRange = &pTmpScan->aRange[0];
        }
    } while (pTmpRange->pSprite != NULL);

    prclUncovered->top    = pTmpScan->yTop;
    prclUncovered->bottom = pTmpScan->yBottom;
    prclUncovered->left   = pTmpRange->xLeft;
    prclUncovered->right  = pTmpRange->xRight;

    pScan  = pTmpScan;
    pRange = pTmpRange;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL ENUMAREAS::bEnumLayers
*
* This routine may be called only after 'bEnum' is called, and lists
* the sprites that overlay the 'bEnum' rectangle, bottom-most to top-most.
*
* Returns TRUE if the returned 'ppSprite' is a valid layer.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMAREAS::bEnumLayers(
SPRITE**    ppSprite)
{
    BOOL bRet = FALSE;

    if ((iDir & 1) == 0)            // Left-to-right
    {
        if ((pRangeLayer < pSpLastRange(pScanLayer)) &&
            ((pRangeLayer + 1)->xLeft == pRangeLayer->xLeft))
        {
            pRangeLayer++;
            bRet = TRUE;
        }
    }
    else                            // Right-to-left
    {
        if ((pRangeLayer > &pScanLayer->aRange[0]) &&
            ((pRangeLayer - 1)->xLeft == pRangeLayer->xLeft))
        {
            pRangeLayer--;
            bRet = TRUE;
        }
    }

    *ppSprite = pRangeLayer->pSprite;
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL ENUMAREAS::bAdvanceToTopMostOpaqueLayer
*
* This routine may be called only after 'bEnum' is called, and advances
* to the top-most, unclipped opaque layer for this range.
*
* Returns TRUE if there was an opaque layer; FALSE if not.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMAREAS::bAdvanceToTopMostOpaqueLayer(
SPRITE**    ppSprite)
{
    SPRITERANGE*    pThis;
    SPRITERANGE*    pLast;
    SPRITERANGE*    pOpaque;
    SPRITE*         pSprite;
    REGION*         prgnClip;
    BOOL            bRet;

    ASSERTGDI((iDir & 1) == 0, "Can use only when enumerating left-to-right");

    pLast   = pSpLastRange(pScanLayer);
    pThis   = pRangeLayer;
    pOpaque = NULL;

    // We can't do the opaque trick if any WNDOBJs are present on the screen,
    // because we rely on the background repainting to refresh any sprites
    // unveiled when a WNDOBJ moves.

    if (gpto != NULL)
    {
        while (TRUE)
        {
            pSprite = pThis->pSprite;
            if (pSprite->fl & SPRITE_FLAG_EFFECTIVELY_OPAQUE)
            {
                // Do a quick check to make sure this opaque sprite isn't
                // clipped for this range.

                prgnClip = pSprite->prgnClip;
                if ((prgnClip == NULL) ||
                    ((prgnClip->sizeRgn <= SINGLE_REGION_SIZE) &&
                     (prgnClip->rcl.left   <= pThis->xLeft)    &&
                     (prgnClip->rcl.right  >= pThis->xRight)   &&
                     (prgnClip->rcl.top    <= yTop)            &&
                     (prgnClip->rcl.bottom >= yBottom)))
                {
                    pOpaque = pThis;
                }
            }

            if ((pThis >= pLast) || ((pThis + 1)->xLeft != pThis->xLeft))
                break;

            pThis++;
        }
    }

    bRet = FALSE;
    if (pOpaque)
    {
        pRangeLayer = pOpaque;
        bRet = TRUE;
    }

    *ppSprite = pRangeLayer->pSprite;
    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vSpReadFromScreen
*
* All reads from the screen should be routed through this call so that
* we can:
*
*   1.  Exclude any DirectDraw locked regions;
*   2.  Respect any WNDOBJ boundaries.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpReadFromScreen(
SPRITESTATE*    pState,
POINTL*         pOffDst,
SURFOBJ*        psoDst,
RECTL*          prclDst)
{
    ECLIPOBJ    ecoUnlocked;
    ECLIPOBJ*   pcoUnlocked;

    pcoUnlocked = NULL;
    if (pState->prgnUnlocked != NULL)
    {
        ecoUnlocked.vSetup(pState->prgnUnlocked, *(ERECTL*)prclDst);
        if (ecoUnlocked.erclExclude().bEmpty())
            return;             // ======>

        pcoUnlocked = &ecoUnlocked;
    }

    XLATEOBJ* pxlo     = NULL;
    SURFOBJ*  psoSrc   = pState->psoScreen;
    PSURFACE  pSurfSrc = SURFOBJ_TO_SURFACE(psoSrc);
    EXLATEOBJ xloParent;

    PFN_DrvCopyBits pfnCopyBits;

    PDEVOBJ pdoSrc(pSurfSrc->hdev());

    // If source is mirror driver, redirect the call to DDML.

    if (pSurfSrc->bMirrorSurface() &&
        (pdoSrc.hdev() != pdoSrc.hdevParent()))
    {
        PDEVOBJ pdoParent(pdoSrc.hdevParent());
        SURFREF srParent((HSURF)pSurfSrc->hMirrorParent);
        if (!srParent.bValid()) return;
        if (xloParent.bInitXlateObj(
                      NULL,DC_ICM_OFF,
                      pdoParent.ppalSurf(), pdoSrc.ppalSurf(),
                      ppalDefault, ppalDefault,
                      0L,0L,0L, XLATE_USE_SURFACE_PAL))
            pxlo = xloParent.pxlo();
        else
            return;

        psoSrc      = srParent.ps->pSurfobj();
        pfnCopyBits = PPFNDRV(pdoParent, CopyBits);
    }
    else if (!(SURFOBJ_TO_SURFACE_NOT_NULL(psoDst)->flags() & HOOK_CopyBits) &&
              (psoSrc->hdev))
    {
        pfnCopyBits = PPFNDIRECT(psoSrc, CopyBits);
    }
    else
    {
        pfnCopyBits = PPFNDIRECT(psoDst, CopyBits);
    }

    OffCopyBits(pfnCopyBits,
                pOffDst,
                psoDst,
                &gptlZero,
                psoSrc,
                pcoUnlocked,
                pxlo,
                prclDst,
                (POINTL*) prclDst);
}

/******************************Public*Routine******************************\
* VOID vSpWriteToScreen
*
* All writes to the screen should be routed through this call so that
* we can:
*
*   1.  Exclude any DirectDraw locked regions;
*   2.  Respect any WNDOBJ boundaries.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpWriteToScreen(
SPRITESTATE*    pState,
POINTL*         pOffSrc,
SURFOBJ*        psoSrc,
RECTL*          prclSrc)
{
    GDIFunctionID(vSpWriteToScreen);

    ECLIPOBJ    ecoUnlocked;
    ECLIPOBJ*   pcoUnlocked;

    pcoUnlocked = NULL;
    if (pState->prgnUnlocked != NULL)
    {
        ecoUnlocked.vSetup(pState->prgnUnlocked, *(ERECTL*)prclSrc);
        if (ecoUnlocked.erclExclude().bEmpty())
            return;             // ======>

        pcoUnlocked = &ecoUnlocked;
    }

    // Mark the source surface to indicate that it shouldn't be cached,
    // as it's pretty much guaranteed that we won't be blting the bitmap
    // with exactly the same contents again.
    //
    // Note that this has to be in addition to any BMF_DONTCACHE flag
    // that might have been set, as the TShare driver ignores the
    // BMF_DONTCACHE flag.

    psoSrc->iUniq = 0;

    ASSERTGDI((pState->psoScreen->iType == pState->iOriginalType) &&
              (SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->flags() == pState->flOriginalSurfFlags),
              "Writing to screen without restoring orignal surface settings.");

    OFFCOPYBITS(&gptlZero,
                pState->psoScreen,
                pOffSrc,
                psoSrc,
                pcoUnlocked,
                NULL,
                prclSrc,
                (POINTL*) prclSrc);
}

/******************************Public*Routine******************************\
* VOID vSpDrawCursor
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDrawCursor(
SPRITE*     pSprite,
POINTL*     pOffComposite,
SURFOBJ*    psoComposite,
RECTL*      prclEnum,
POINTL*     pptlSrc)
{
    SPRITESTATE*    pState;
    POINTL          ptlSrc;
    SURFOBJ*        psoShape;
    POINTL*         pOffShape;
    XLATEOBJ*       pxlo;

    // A NULL mask means that the shape couldn't be allocated:

    if (pSprite->psoMask == NULL)
        return;

    pState = pSprite->pState;

    EXLATEOBJ xloMono;
    XEPALOBJ  palMono(ppalMono);
    XEPALOBJ  palScreen(SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->ppal());
    XEPALOBJ  palDefault(ppalDefault);

    // The XLATEOBJ should always be in the cache, so this should be pretty
    // cheap most of the time:

    if (xloMono.bInitXlateObj(NULL, DC_ICM_OFF, palMono, palScreen, palDefault,
                              palDefault, 0, 0xffffff, 0))
    {
        OFFBITBLT(pOffComposite, psoComposite, &gptlZero, pSprite->psoMask,
                  NULL, NULL, xloMono.pxlo(), prclEnum, pptlSrc, NULL,
                  NULL, NULL, 0x8888);      // SRCAND

        if (pSprite->psoShape == NULL)
        {
            ptlSrc.x  = pptlSrc->x;
            ptlSrc.y  = pptlSrc->y + (pSprite->psoMask->sizlBitmap.cy >> 1);
            psoShape  = pSprite->psoMask;
            pOffShape = &gptlZero;
            pxlo      = xloMono.pxlo();
        }
        else
        {
            ptlSrc.x  = pptlSrc->x;
            ptlSrc.y  = pptlSrc->y;
            psoShape  = pSprite->psoShape;
            pOffShape = &pSprite->OffShape;
            pxlo      = NULL;
        }

        OFFBITBLT(pOffComposite, psoComposite, pOffShape, psoShape, NULL,
                  NULL, pxlo, prclEnum, &ptlSrc, NULL, NULL, NULL,
                  0x6666);      // SRCINVERT
    }
}

/******************************Public*Routine******************************\
* VOID vSpComposite
*
* Draws the specified sprite into the composition buffer.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpComposite(
SPRITE*     pSprite,
POINTL*     pOffComposite,
SURFOBJ*    psoComposite,
RECTL*      prclEnum)
{
    SPRITESTATE*    pState;
    POINTL          ptlSrc;
    CLIPOBJ*        pco;
    DWORD           dwShape;
    ECLIPOBJ        ecoClip;
    CLIPOBJ*        pcoClip;
    SURFOBJ*        psoNull = NULL;

    // First, calculate the clipping:

    pcoClip = NULL;
    if (pSprite->prgnClip != NULL)
    {
        pcoClip = &ecoClip;

        ecoClip.vSetup(pSprite->prgnClip, *((ERECTL*) prclEnum));

        if ((ecoClip.rclBounds.left >= ecoClip.rclBounds.right) ||
            (ecoClip.rclBounds.top >= ecoClip.rclBounds.bottom))
        {
            // It's completely clipped, so we're outta here:

            return;
        }
    }

    pState = pSprite->pState;

    ASSERTGDI(pState->bInsideDriverCall, "Must have sprite lock");

    dwShape = pSprite->dwShape;
    if (pSprite->fl & SPRITE_FLAG_EFFECTIVELY_OPAQUE)
        dwShape = ULW_OPAQUE;

    ptlSrc.x = pSprite->rclSrc.left + (prclEnum->left - pSprite->ptlDst.x);
    ptlSrc.y = pSprite->rclSrc.top  + (prclEnum->top - pSprite->ptlDst.y);

    XEPALOBJ palScreen(SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen)->ppal());
    XEPALOBJ palSprite(pSprite->ppalShape);
    XEPALOBJ palDefault(ppalDefault);
    XEPALOBJ palRGB(gppalRGB);
    EXLATEOBJ xloSpriteToDst;

    // If the current color depth is the same as the color depth in which
    // the sprite was originally created, we don't need an XLATEOBJ.
    // Otherwise, create one now:

    if (((pSprite->iModeFormat == pState->iModeFormat) &&
         (pSprite->flModeMasks == pState->flModeMasks)) ||
        (xloSpriteToDst.bInitXlateObj(NULL, DC_ICM_OFF, palSprite, palScreen,
                                      palDefault, palDefault, 0, 0, 0)))
    {
        if (dwShape != ULW_ALPHA)
        {
            if (dwShape == ULW_OPAQUE)
            {
                if (pSprite->psoShape)
                {
                    OFFCOPYBITS(pOffComposite,
                                psoComposite,
                                &pSprite->OffShape,
                                pSprite->psoShape,
                                pcoClip,
                                xloSpriteToDst.pxlo(),
                                prclEnum,
                                &ptlSrc);
                }
            }
            else if (dwShape == ULW_COLORKEY)
            {
                if (pSprite->psoShape)
                {
                    ERECTL rclSrc(ptlSrc.x,
                                  ptlSrc.y,
                                  ptlSrc.x + (prclEnum->right - prclEnum->left),
                                  ptlSrc.y + (prclEnum->bottom - prclEnum->top));

                    OffTransparentBlt(PPFNDIRECT(psoComposite, TransparentBlt),
                                  pOffComposite,
                                  psoComposite,
                                  &pSprite->OffShape,
                                  pSprite->psoShape,
                                  pcoClip,
                                  xloSpriteToDst.pxlo(),
                                  prclEnum,
                                  &rclSrc,
                                  pSprite->iTransparent,
                                  0);
                }
            }
            else if (dwShape == ULW_CURSOR)
            {
                vSpDrawCursor(pSprite,
                              pOffComposite,
                              psoComposite,
                              prclEnum,
                              &ptlSrc);
            }
            else
            {
                ASSERTGDI(dwShape == ULW_DRAGRECT, "Unexpected shape");

                PDEVOBJ po(pState->hdev);

                OFFBITBLT(pOffComposite, psoComposite, NULL, psoNull, NULL, NULL,
                          NULL, prclEnum, NULL, NULL, po.pbo(), &gptlZero,
                          0x5a5a);
            }
        }
        else
        {
            ASSERTGDI(dwShape == ULW_ALPHA, "Unexpected case");

            if (pSprite->psoShape)
            {
                EBLENDOBJ eBlendObj;
                EXLATEOBJ xloSpriteTo32;
                EXLATEOBJ xloScreenTo32;
                EXLATEOBJ xlo32ToScreen;

                ERECTL rclSrc(ptlSrc.x,
                              ptlSrc.y,
                              ptlSrc.x + (prclEnum->right - prclEnum->left),
                              ptlSrc.y + (prclEnum->bottom - prclEnum->top));

                if ((xloSpriteTo32.bInitXlateObj(NULL, DC_ICM_OFF, palSprite, palRGB,
                                                 palDefault, palDefault, 0, 0, 0)) &&
                    (xloScreenTo32.bInitXlateObj(NULL, DC_ICM_OFF, palScreen, palRGB,
                                                 palDefault, palDefault, 0, 0, 0)) &&
                    (xlo32ToScreen.bInitXlateObj(NULL, DC_ICM_OFF, palRGB, palScreen,
                                                 palDefault, palDefault, 0, 0, 0)))
                {
                    eBlendObj.BlendFunction = pSprite->BlendFunction;
                    eBlendObj.pxloSrcTo32   = xloSpriteTo32.pxlo();
                    eBlendObj.pxloDstTo32   = xloScreenTo32.pxlo();
                    eBlendObj.pxlo32ToDst   = xlo32ToScreen.pxlo();

                    OffAlphaBlend(PPFNDIRECT(psoComposite, AlphaBlend),
                                  pOffComposite,
                                  psoComposite,
                                  &pSprite->OffShape,
                                  pSprite->psoShape,
                                  pcoClip,
                                  xloSpriteToDst.pxlo(),
                                  prclEnum,
                                  &rclSrc,
                                  &eBlendObj);
                }
            }
        }
    }
}

/******************************Public*Routine******************************\
* SURFOBJ* psoSpGetComposite
*
* Returns a surface to be used for compositing.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SURFOBJ* psoSpGetComposite(
SPRITESTATE*    pState,
RECTL*          prcl)
{
    SURFOBJ*    psoComposite;
    LONG        cxMax;
    LONG        cyMax;
    LONG        cMaxArea;
    LONG        cx;
    LONG        cy;
    LONG        cArea;
    BOOL        bWantSystemMemory;
    SPRITE*     pSprite;
    SPRITE*     pBiggest;

    psoComposite = pState->psoComposite;
    if ((psoComposite == NULL) ||
        (psoComposite->sizlBitmap.cx < (prcl->right - prcl->left)) ||
        (psoComposite->sizlBitmap.cy < (prcl->bottom - prcl->top)))
    {
        vSpDeleteSurface(psoComposite); // Handles NULL case

        cMaxArea = 0;
        cxMax    = 0;
        cyMax    = 0;

        // Find the minimum dimensions needed to accomodate every sprite:

        for (pSprite = pState->pListZ;
             pSprite != NULL;
             pSprite = pSprite->pNextZ)
        {
            cx = pSprite->rclSprite.right - pSprite->rclSprite.left;
            if (cx > cxMax)
                cxMax = cx;

            cy = pSprite->rclSprite.bottom - pSprite->rclSprite.top;
            if (cy > cyMax)
                cyMax = cy;

            cArea = cx * cy;
            if (cArea > cMaxArea)
            {
                cMaxArea = cArea;
                pBiggest = pSprite;
            }
        }

        ASSERTGDI((cxMax > 0) && (cyMax > 0), "Expected a non-zero sprite");

        bWantSystemMemory = FALSE;
        if (pBiggest->dwShape == ULW_ALPHA)
        {
            PDEVOBJ po(pState->hdev);

            if (pBiggest->BlendFunction.AlphaFormat & AC_SRC_ALPHA)
            {
                if (!(po.flAccelerated() & ACCELERATED_PIXEL_ALPHA))
                {
                    bWantSystemMemory = TRUE;
                }
            }
            else
            {
                if (!(po.flAccelerated() & ACCELERATED_CONSTANT_ALPHA))
                {
                    bWantSystemMemory = TRUE;
                }
            }
        }

        // The compositing surface should always be in video-memory, unless
        // there is a big alpha sprite somewhere, and the hardware doesn't
        // accelerate alpha:

        psoComposite = psoSpCreateSurface(pState,
                                          0,
                                          cxMax,
                                          cyMax,
                                          bWantSystemMemory);

    #if DEBUG_SPRITES
        KdPrint(("psoComposite: %p\n", psoComposite));
    #endif

        pState->psoComposite = psoComposite;

        // Mark the surface as uncacheable, so that we won't pollute the
        // cache of the TShare driver, and the like:

        if (psoComposite != NULL)
        {
            psoComposite->fjBitmap |= BMF_DONTCACHE;

            // BMF_SPRITE appears to be unused.  We are temporarily removing
            // support to see if 3DLabs complains.
            // psoComposite->fjBitmap |= BMF_SPRITE;
        }
}

    return(psoComposite);
}

/******************************Public*Routine******************************\
* VOID vSpRedrawArea
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpRedrawArea(
SPRITESTATE*    pState,
RECTL*          prclBounds,
BOOL            bMustRedraw = FALSE)
{
    SPRITE*     pSprite;
    RECTL       rclEnum;
    SURFOBJ*    psoComposite;
    POINTL      OffComposite;
    BOOL        bMore;
    BOOL        hHasOpaqueLayer;

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall, "Must have sprite lock");

    ENUMAREAS Enum(pState, prclBounds);

    do {
        bMore = Enum.bEnum(&pSprite, &rclEnum);

        ASSERTGDI((rclEnum.left   >= pState->rclScreen.left)  &&
                  (rclEnum.top    >= pState->rclScreen.top)   &&
                  (rclEnum.right  <= pState->rclScreen.right) &&
                  (rclEnum.bottom <= pState->rclScreen.bottom),
            "Enumerated rectangle exceeds screen bounds");

        if (pSprite != NULL)
        {
            // We always draw bottom-to-top, but we don't have to
            // bother drawing any layers that are below the top-most
            // opaque layer:

            hHasOpaqueLayer = Enum.bAdvanceToTopMostOpaqueLayer(&pSprite);

            // If something was drawn under this layer region, and
            // there was any opaque layer, we can early-out because
            // we know we won't have to update the screen:

            if ((!hHasOpaqueLayer) || (bMustRedraw))
            {
                // Create the compositing surface:

                psoComposite = psoSpGetComposite(pState, &rclEnum);
                if (psoComposite == NULL)
                    return;                             // ======>

                // Set the composite buffer's origin for ease of use:

                OffComposite.x = -rclEnum.left;
                OffComposite.y = -rclEnum.top;

                // Okay, we have to do things the slow way.  First, copy
                // the underlay to the composite buffer:

                OFFCOPYBITS(&OffComposite,
                            psoComposite,
                            &pSprite->OffUnderlay,
                            pSprite->psoUnderlay,
                            NULL,
                            NULL,
                            &rclEnum,
                            (POINTL*) &rclEnum);

                // Now composite each sprite:

                do {
                    vSpComposite(pSprite,
                                 &OffComposite,
                                 psoComposite,
                                 &rclEnum);

                } while (Enum.bEnumLayers(&pSprite));

                // Now copy the final composited result back to the screen:

                vSpWriteToScreen(pState,
                                 &OffComposite,
                                 psoComposite,
                                 &rclEnum);
            }
        }
    } while (bMore);
}

/******************************Public*Routine******************************\
* SPRITE* pSpFindInZ
*
* Finds the next sprite in the list that intersects with the specified
* rectangle.
*
* This function's entire raison d'etre is for speed.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SPRITE* FASTCALL pSpFindInZ(
SPRITE* pSprite,
RECTL*  prcl)
{
    LONG xLeft   = prcl->left;
    LONG yTop    = prcl->top;
    LONG xRight  = prcl->right;
    LONG yBottom = prcl->bottom;

    while (pSprite != NULL)
    {
        if ((pSprite->rclSprite.left   < xRight)  &&
            (pSprite->rclSprite.top    < yBottom) &&
            (pSprite->rclSprite.right  > xLeft)   &&
            (pSprite->rclSprite.bottom > yTop))
        {
            return(pSprite);
        }

        pSprite = pSprite->pNextZ;
    }

    return(pSprite);
}

/******************************Public*Routine******************************\
* VOID  vSpRedrawSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpRedrawSprite(
SPRITE*     pSprite)
{
    GDIFunctionID(vSpRedrawSprite);

    SPRITESTATE*    pState;
    SURFOBJ*        psoComposite;
    POINTL          OffComposite;
    SPRITE*         pIntersect;
    RECTL           rclIntersect;

    pState = pSprite->pState;

    // There's nothing to redraw if we're full-screen:

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    if (pSprite->fl & SPRITE_FLAG_VISIBLE)
    {
        ASSERTGDI((pSprite->rclSprite.left < pSprite->rclSprite.right) &&
                  (pSprite->rclSprite.top < pSprite->rclSprite.bottom),
            "Badly ordered rclSprite");

        psoComposite = psoSpGetComposite(pState, &pSprite->rclSprite);
        if (psoComposite == NULL)
            return;

        // Set the composite buffer's origin for ease of use:

        OffComposite.x = -pSprite->rclSprite.left;
        OffComposite.y = -pSprite->rclSprite.top;

        // First, copy the underlay to the composite buffer:

        OFFCOPYBITS(&OffComposite,
                    psoComposite,
                    &pSprite->OffUnderlay,
                    pSprite->psoUnderlay,
                    NULL,
                    NULL,
                    &pSprite->rclSprite,
                    (POINTL*) &pSprite->rclSprite);

        // Now composite each sprite:

        pIntersect = pSpFindInZ(pState->pListZ, &pSprite->rclSprite);
        while (pIntersect != NULL)
        {
            if (bIntersect(&pIntersect->rclSprite,
                           &pSprite->rclSprite,
                           &rclIntersect))
            {
                vSpComposite(pIntersect,
                             &OffComposite,
                             psoComposite,
                             &rclIntersect);
            }

            pIntersect = pSpFindInZ(pIntersect->pNextZ, &pSprite->rclSprite);
        }

        // Now copy the final composited result back to the screen:

        vSpWriteToScreen(pState,
                         &OffComposite,
                         psoComposite,
                         &pSprite->rclSprite);

        // set time stamp

        pSprite->ulTimeStamp = NtGetTickCount();

    }
}

/******************************Public*Routine******************************\
* ULONG cSpSubtract
*
* Simple little routine that returns back the list of rectangles that
* make up the area defined by 'prclA' minus 'prclB'.
*
* Returns the number and values of the resulting rectangles, which will
* be no more than four.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL cSpSubtract(
CONST RECTL*    prclA,      // Computes A - B
CONST RECTL*    prclB,
RECTL*          arcl)
{
    RECTL   rcl;
    RECTL*  prcl;

    prcl = arcl;

    rcl.left   = LONG_MIN;
    rcl.top    = LONG_MIN;
    rcl.right  = LONG_MAX;
    rcl.bottom = prclB->top;

    if (bIntersect(&rcl, prclA, prcl))
        prcl++;

    rcl.top    = prclB->top;
    rcl.right  = prclB->left;
    rcl.bottom = prclB->bottom;

    if (bIntersect(&rcl, prclA, prcl))
        prcl++;

    rcl.left  = prclB->right;
    rcl.right = LONG_MAX;

    if (bIntersect(&rcl, prclA, prcl))
        prcl++;

    rcl.left   = LONG_MIN;
    rcl.top    = prclB->bottom;
    rcl.bottom = LONG_MAX;

    if (bIntersect(&rcl, prclA, prcl))
        prcl++;

    return((ULONG) (prcl - arcl));
}

/******************************Public*Routine******************************\
* VOID vSpRedrawUncoveredArea
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpRedrawUncoveredArea(
SPRITE*     pSprite,
RECTL*      prclNew)
{
    SPRITESTATE*    pState;
    RECTL           arclUncovered[4];
    RECTL           rclTmp;
    ULONG           crclUncovered;
    SURFOBJ*        psoComposite;
    POINTL          OffComposite;
    SPRITE*         pTmp;
    BOOL            bHit;
    ULONG           i;
    ULONG           j;

    pState = pSprite->pState;

    // There's nothing to redraw if we're full-screen:

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    crclUncovered = cSpSubtract(&pSprite->rclSprite, prclNew, &arclUncovered[0]);
    if (crclUncovered)
    {
        bHit = FALSE;

        psoComposite = psoSpGetComposite(pState, &pSprite->rclSprite);
        if (psoComposite == NULL)
            return;

        // Set the composite buffer's origin for ease of use:

        OffComposite.x = -pSprite->rclSprite.left;
        OffComposite.y = -pSprite->rclSprite.top;

        pTmp = pSpFindInZ(pState->pListZ, &pSprite->rclSprite);
        while (pTmp != NULL)
        {
            if (pTmp != pSprite)
            {
                for (i = 0; i < crclUncovered; i++)
                {
                    if (bIntersect(&arclUncovered[i], &pTmp->rclSprite, &rclTmp))
                    {
                        if (!bHit)
                        {
                            for (j = 0; j < crclUncovered; j++)
                            {
                                OFFCOPYBITS(&OffComposite,
                                            psoComposite,
                                            &pSprite->OffUnderlay,
                                            pSprite->psoUnderlay,
                                            NULL,
                                            NULL,
                                            &arclUncovered[j],
                                            (POINTL*) &arclUncovered[j]);
                            }

                            bHit = TRUE;
                        }

                        vSpComposite(pTmp,
                                     &OffComposite,
                                     psoComposite,
                                     &rclTmp);
                    }
                }
            }

            pTmp = pSpFindInZ(pTmp->pNextZ, &pSprite->rclSprite);
        }

        for (i = 0; i < crclUncovered; i++)
        {
            if (bHit)
            {
                vSpWriteToScreen(pState,
                                 &OffComposite,
                                 psoComposite,
                                 &arclUncovered[i]);
            }
            else
            {
                vSpWriteToScreen(pState,
                                 &pSprite->OffUnderlay,
                                 pSprite->psoUnderlay,
                                 &arclUncovered[i]);
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vSpSmallUnderlayCopy
*
* Updates the underlay bits of a sprite without forcing a re-compute
* of the sprite-range data structure.
*
* Copies a rectangle from the screen to the specified underlay surface.
* We update the underlay surface by first copying the entire rectangle
* straight from the frame buffer (which may include bits of other sprites),
* and then looping through the sprite list copying their underlays whereever
* they intersect.
*
* Note that if multiple sprites overlap, we'll be overwriting portions of
* the sprite many times.  Overdrawing pixels like this is always inefficient,
* but if the sprite size is small it won't be too bad.  On the other hand,
* if there are many sprites, the computation of the sprite range structure
* will be *very* expensive.
*
* So for small sprites, it's often faster to over-draw pixels than to
* re-compute the sprite range structure.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

// The 'SMALL_SPRITE_DIMENSION' is the maximum pixel dimension for which
// a sprite move will be done without recomputing the sprite ranges.

#define SMALL_SPRITE_DIMENSION  128

VOID vSpSmallUnderlayCopy(
SPRITE*     pSprite,
POINTL*     pOffDst,
SURFOBJ*    psoDst,
POINTL*     pOffSrc,
SURFOBJ*    psoSrc,
LONG        dx,
LONG        dy,
RECTL*      prclNew,
RECTL*      prclOld)
{
    SPRITESTATE*    pState;
    RECTL           rclSrc;
    RECTL           rclDst;
    ULONG           crcl;
    RECTL           arcl[4];
    ULONG           i;
    SPRITE*         pTmp;
    RECTL           rclTmp;

    pState = pSprite->pState;

    // There's nothing to redraw if we're full-screen:

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    if (bIntersect(prclOld, prclNew, &rclDst))
    {
        rclSrc.left   = dx + rclDst.left;
        rclSrc.right  = dx + rclDst.right;
        rclSrc.top    = dy + rclDst.top;
        rclSrc.bottom = dy + rclDst.bottom;

        OFFCOPYBITS(pOffDst,
                    psoDst,
                    pOffSrc,
                    psoSrc,
                    NULL,
                    NULL,
                    &rclDst,
                    (POINTL*) &rclSrc);
    }

    crcl = cSpSubtract(prclNew, prclOld, arcl);

    ASSERTGDI(crcl != 0, "Shouldn't have an empty source");

    i = 0;
    do {
        vSpReadFromScreen(pState, pOffDst, psoDst, &arcl[i]);

    } while (++i != crcl);

    pTmp = pSpFindInZ(pState->pListZ, prclNew);
    while (pTmp != NULL)
    {
        if (pTmp != pSprite)
        {
            i = 0;
            do {
                if (bIntersect(&arcl[i], &pTmp->rclSprite, &rclTmp))
                {
                    OFFCOPYBITS(pOffDst,
                                psoDst,
                                &pTmp->OffUnderlay,
                                pTmp->psoUnderlay,
                                NULL,
                                NULL,
                                &rclTmp,
                                (POINTL*) &rclTmp);
                }
            } while (++i != crcl);
        }

        pTmp = pSpFindInZ(pTmp->pNextZ, prclNew);
    }
}

/******************************Public*Routine******************************\
* VOID vSpBigUnderlayCopy
*
* Reads a (future underlay) buffer from the screen, automatically excluding
* any sprites that may be in the way.
*
* This routine will be slow if the area is small, there are a large number
* of sprites, and  ENUMAREAS forces the sprite ranges to be re-calculated;
* it will be fast if the buffer to be read is large.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpBigUnderlayCopy(
SPRITESTATE*    pState,
POINTL*         pOffUnderlay,
SURFOBJ*        psoUnderlay,
RECTL*          prcl)
{
    SPRITE* pSprite;
    RECTL   rclEnum;
    BOOL    bMore;

    // There's nothing to redraw if we're full-screen:

    PDEVOBJ po(pState->hdev);
    if (po.bDisabled())
        return;

    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    ENUMAREAS Enum(pState, prcl);

    do {
        bMore = Enum.bEnum(&pSprite, &rclEnum);

        if (pSprite == NULL)
        {
            vSpReadFromScreen(pState, pOffUnderlay, psoUnderlay, &rclEnum);
        }
        else
        {
            OFFCOPYBITS(pOffUnderlay,
                        psoUnderlay,
                        &pSprite->OffUnderlay,
                        pSprite->psoUnderlay,
                        NULL,
                        NULL,
                        &rclEnum,
                        (POINTL*) &rclEnum);
        }
    } while (bMore);
}

/******************************Public*Routine******************************\
* VOID vSpUpdateLockedScreenAreas
*
* When a screen-to-screen blt occurs, the screen-to-screen blt may occur
* under an area of the screen that is both locked by DirectDraw and covered
* by a sprite.  Normally, we never update the locked area under the sprite,
* but in this case we do, to reflect the moved contents.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpUpdateLockedScreenAreas(
SPRITESTATE*    pState,
POINTL*         pOffDst,
RECTL*          prclDst,
CLIPOBJ*        pco,
BOOL            bReadFromScreen)
{
    SPRITE*         pSprite;
    BOOL            bMore;
    RECTL           rclEnum;
    RECTL           rclArea;
    REGION*         prgnIntersect;
    ECLIPOBJ        ecoIntersect;
    RGNOBJ*         proClip;
    RGNMEMOBJTMP    rmoIntersect;
    RGNMEMOBJTMP    rmoScreen;

    ASSERTGDI(pState->prgnUnlocked != NULL,
        "Should really be called only when a DirectDraw lock is extant");

    PDEVOBJ po(pState->hdev);
    SPRITELOCK slock(po);

    prgnIntersect = NULL;

    if (rmoIntersect.bValid() &&
        rmoScreen.bValid() &&
        bIntersect(prclDst, &pState->rclScreen, &rclArea))
    {
        ENUMAREAS Enum(pState, &rclArea);

        do {
            bMore = Enum.bEnum(&pSprite, &rclEnum);

            if (pSprite != NULL)
            {
                if (prgnIntersect == NULL)
                {
                    proClip = (ECLIPOBJ*) pco;
                    if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
                    {
                        rmoScreen.vSet(&pState->rclScreen);
                        proClip = &rmoScreen;
                    }

                    // Intersect the clip object supplied by the drawing
                    // routine with the not of region representing the
                    // 'unlocked' portions of the screen.

                    RGNOBJ roUnlocked(pState->prgnUnlocked);
                    if (!rmoIntersect.bMerge(*proClip,
                                        roUnlocked,
                                        gafjRgnOp[RGN_DIFF]))
                    {
                        rmoIntersect.vSet();
                    }
                    prgnIntersect = rmoIntersect.prgnGet();
                }

                ecoIntersect.vSetup(prgnIntersect, *(ERECTL*) &rclEnum);
                if (!ecoIntersect.erclExclude().bEmpty())
                {
                    do {
                        if (bReadFromScreen)
                        {
                            OFFCOPYBITS(&pSprite->OffUnderlay,
                                        pSprite->psoUnderlay,
                                        pOffDst,
                                        pState->psoScreen,
                                        &ecoIntersect,
                                        NULL,
                                        &rclEnum,
                                        (POINTL*) &rclEnum);
                        }
                        else
                        {
                            OFFCOPYBITS(pOffDst,
                                        pState->psoScreen,
                                        &pSprite->OffUnderlay,
                                        pSprite->psoUnderlay,
                                        &ecoIntersect,
                                        NULL,
                                        &rclEnum,
                                        (POINTL*) &rclEnum);
                        }
                    } while ((bReadFromScreen) && (Enum.bEnumLayers(&pSprite)));
                }
            }
        } while (bMore);
    }
}



/******************************Public*Routine******************************\
* ENUMUNDERLAYS::ENUMUNDERLAYS
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ENUMUNDERLAYS::ENUMUNDERLAYS(
SURFOBJ*    pso,
CLIPOBJ*    pco,
RECTL*      prclDraw)
{
    PDEVOBJ po(pso->hdev);
    BOOL    bRclNotEmpty = TRUE;

    bDone           = FALSE;
    bSpriteTouched  = FALSE;
    bResetSurfFlag  = FALSE;
    pCurrentSprite  = NULL;
    pcoOriginal     = pco;
    psoOriginal     = pso;

    // This extra 'if' was added for GetPixel:

    if (po.bValid())
    {
        pState = po.pSpriteState();

        if ((pso == pState->psoScreen) && !(pState->bInsideDriverCall))
        {
            ASSERTGDI(!po.bDisabled(),
                "Mustn't be called when PDEV disabled");
            ASSERTGDI((pState->flOriginalSurfFlags & ~HOOK_FLAGS)
                == (SURFOBJ_TO_SURFACE(pso)->SurfFlags & ~HOOK_FLAGS),
                "SurfFlags was modified, but we're about to save over it!");

            SURFOBJ_TO_SURFACE_NOT_NULL(pso)->flags(pState->flOriginalSurfFlags);
            SURFOBJ_TO_SURFACE_NOT_NULL(pso)->iType(pState->iOriginalType);
            pState->bInsideDriverCall = TRUE;
            bResetSurfFlag = TRUE;

            if ((pco == NULL) || (pco->iDComplexity == DC_TRIVIAL))
            {
                rclBounds = *prclDraw;
                pcoClip   = &pState->coRectangular;
            }
            else
            {
                rclSaveBounds = pco->rclBounds;
                bRclNotEmpty = bIntersect(prclDraw, &pco->rclBounds, &rclBounds);
                pcoClip = pco;
            }

            // Find intersecting sprite if we have non-empty bounds;
            // otherwise, leave pCurrentSprite = NULL.
            if (bRclNotEmpty)
            {
                pCurrentSprite = pSpFindInZ(pState->pListZ, &rclBounds);
            }
        }
    }
}

/******************************Public*Routine******************************\
* ENUMUNDERLAYS::bEnum
*
* This routine is a helper function for drawing primitives that handles
* the drawing of the primitive to various sprite underlay and screen
* surfaces.  It takes the form of an enumeration function in order to
* return back the appropriate surface and clip objects that should be
* drawn on by the caller.
*
* Returns: TRUE if the caller should draw using the returned values;
*          FALSE if no more drawing needs to be done.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL ENUMUNDERLAYS::bEnum(
SURFOBJ**   ppso,
POINTL*     pOff,
CLIPOBJ**   ppco)
{
    RECTL   rclTmp;

    // We first draw to the underlay surfaces of any sprites that
    // intersect with our area of interest.  See if there is
    // another sprite that intersects, and if so return that:

    while (pCurrentSprite != NULL)
    {
        if (bIntersect(&pCurrentSprite->rclSprite, &rclBounds, &rclTmp))
        {
            ASSERTGDI(pcoClip->iDComplexity != DC_TRIVIAL,
                "Expected non-trivial clipping when drawing to sprite");

            bSpriteTouched = TRUE;
            pcoClip->rclBounds = rclTmp;

            *ppco = pcoClip;
            *ppso = pCurrentSprite->psoUnderlay;
            *pOff = pCurrentSprite->OffUnderlay;

            pCurrentSprite = pCurrentSprite->pNextZ;
            return(TRUE);
        }

        pCurrentSprite = pSpFindInZ(pCurrentSprite->pNextZ, &rclBounds);
    }

    if (!bDone)
    {
        if (!bSpriteTouched)
        {
            // No sprites intersected with the region of drawing, so we
            // can simply return back the original clipping and surface
            // object:

            bDone   = TRUE;
            *ppco   = pcoOriginal;
            *ppso   = psoOriginal;
            pOff->x = 0;
            pOff->y = 0;
            return(TRUE);
        }

        // Okay, at this point we have work to do.  We have to 'cut out'
        // of the original clip objects any areas that were covered
        // by the sprites.

        if (!pState->bValidRange)
        {
            vSpComputeSpriteRanges(pState);
        }

        if (pcoClip->iDComplexity != DC_COMPLEX)
        {
            // Oh good, we can use our already-constructed complex region
            // describing the uncovered parts of the screen.
            //
            // Use CLIP_FORCE to ensure that 'rclBounds' is always respected
            // as the bounds, so that we don't revert to DC_TRIVIAL clipping
            // when in fact the original call came in clipped:

            pState->coTmp.vSetup(pState->prgnUncovered,
                                 *((ERECTL*)&rclBounds),
                                 CLIP_FORCE);
        }
        else
        {
            // Okay, we've got some work to do.  We have to subtract each of
            // the sprite rectangles from the drawing call's clip object.

            RGNOBJ roUncovered(pState->prgnUncovered);
            RGNOBJ roTmp(pState->prgnTmp);

            // Find the intersection of the two regions. If the bMerge fails,
            // we'll draw wrong, but we won't crash.

            if (!roTmp.bMerge(*((XCLIPOBJ*)pcoClip), roUncovered, gafjRgnOp[RGN_AND]))
            {
                roTmp.vSet();
            }

            // Compute the resulting clip object:

            pState->prgnTmp = roTmp.prgnGet();
            pState->coTmp.vSetup(pState->prgnTmp,
                                 *((ERECTL*)&rclBounds),
                                 CLIP_FORCE);
        }

        // Note that this 'bIntersect' test handles the empty case for
        // 'coTmp.rclBounds':

        if (bIntersect(&pState->coTmp.rclBounds, &rclBounds))
        {
            ASSERTGDI((pState->prgnUnlocked != NULL) ||
                      (pState->coTmp.iDComplexity != DC_TRIVIAL),
                "If sprite was touched, expect clipping on uncovered portion!");

            bDone   = TRUE;
            *ppco   = &pState->coTmp;
            *ppso   = psoOriginal;
            pOff->x = 0;
            pOff->y = 0;
            return(TRUE);
        }
    }

    // We're all done, update the screen underneath the sprites if need be:

    if (bResetSurfFlag)
    {
        if (bSpriteTouched)
        {
            // One problem that is visible with sprites, particularly when
            // using a software cursor, is that when drawing a single
            // primitive, there is sometimes a noticeable temporal gap between
            // the time that the area around the sprite is drawn, and the area
            // underneath the sprite is updated.
            //
            // I used to update the area underneath the sprite before
            // doing the drawing that occurs around the sprite, reasoning that
            // people tend to be looking exactly at the cursor sprite and would
            // benefit most from that area being updated as soon as possible,
            // before the surrounding area.
            //
            // But I've changed my mind, and think the opposite is better.
            // This is partly because drawing operations with complex clipping
            // often need longer setup time than it does to update the sprite,
            // so the time difference between the two is lessened if the
            // sprite is updated *after* the complex clipped drawing is done.
            //
            // (I'll add that I also tried updating in chunks from top to
            // bottom, but the resulting tearing was far worse.)

            vSpRedrawArea(pState, &rclBounds);
        }

        ASSERTGDI((pState->flOriginalSurfFlags & ~HOOK_FLAGS)
            == (SURFOBJ_TO_SURFACE(psoOriginal)->SurfFlags & ~HOOK_FLAGS),
            "SurfFlags was modified, but we're about to restore over it!");

        SURFOBJ_TO_SURFACE_NOT_NULL(psoOriginal)->flags(pState->flSpriteSurfFlags);
        SURFOBJ_TO_SURFACE_NOT_NULL(psoOriginal)->iType(pState->iSpriteType);
        pState->bInsideDriverCall = FALSE;

        // This restores the original clip object's bounds if need be (or it
        // overwrites 'coRectangular.rclBounds', which is also fine):

        pcoClip->rclBounds = rclSaveBounds;
    }

    return(FALSE);
}

/******************************Public*Routine******************************\
* BOOL SpStrokePath
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpStrokePath(
SURFOBJ*   pso,
PATHOBJ*   ppo,
CLIPOBJ*   pco,
XFORMOBJ*  pxlo,
BRUSHOBJ*  pbo,
POINTL*    pptlBrush,
LINEATTRS* pla,
MIX        mix)
{
    BOOL        bRet = TRUE;
    BOOL        bThis;
    FLOAT_LONG  elStyleState;
    POINTL      Offset;

    ASSERTGDI(pco != NULL, "Drivers always expect non-NULL pco's for this call");

    elStyleState = pla->elStyleState;

    ENUMUNDERLAYS Enum(pso, pco, &pco->rclBounds);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        // We have to reset the style state every time we call StrokePath,
        // otherwise it incorrectly accumulates.  Also reset the path enumeration.

        pla->elStyleState = elStyleState;
        PATHOBJ_vEnumStart(ppo);

        bThis = OffStrokePath(PPFNDIRECT(pso, StrokePath), &Offset, pso,
                              ppo, pco, pxlo, pbo, pptlBrush, pla, mix);

        // Drivers can return TRUE, FALSE, or DDI_ERROR from this call.  We
        // should have caught any FALSE cases lower down, so permute them
        // to failures should they have actually occurred:

        if (!bThis)
            bRet = DDI_ERROR;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpFillPath
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpFillPath(
SURFOBJ*  pso,
PATHOBJ*  ppo,
CLIPOBJ*  pco,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
MIX       mix,
FLONG     flOptions)
{
    BOOL    bRet = TRUE;
    BOOL    bThis;
    POINTL  Offset;

    ASSERTGDI(pco != NULL, "Drivers always expect non-NULL pco's for this call");

    ENUMUNDERLAYS Enum(pso, pco, &pco->rclBounds);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        // Reset the path enumeration
        PATHOBJ_vEnumStart(ppo);

        bThis = OffFillPath(PPFNDIRECT(pso, FillPath), &Offset, pso, ppo, pco,
                            pbo, pptlBrush, mix, flOptions);

        // Drivers can return TRUE, FALSE, or DDI_ERROR from this call.  We
        // should have caught any FALSE cases lower down, so permute them
        // to failures should they have actually occurred:

        if (!bThis)
            bRet = DDI_ERROR;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bSpBltScreenToScreen
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpBltScreenToScreen(
SURFOBJ*    pso,
SURFOBJ*    psoIgnore,
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    SPRITESTATE*    pState;
    LONG            dx;
    LONG            dy;
    ULONG           iDirection;
    POINTL          Offset;
    RECTL           rclIntersect;
    RECTL           rclSrc;
    RECTL           rclDst;
    RECTL           rclSubSrc;
    RECTL           rclSubDst;
    POINTL          ptlSubMsk;
    POINTL          ptlPreviousDst;
    SPRITE*         pSpriteDst;
    SPRITE*         pSpriteSrc;
    SPRITE*         pSpriteTmp;
    SURFOBJ*        psoSrc;
    SURFOBJ*        psoDst;
    RECTL           rclBounds;
    BOOL            bMore;
    BOOL            bSubMore;
    POINTL*         pOffDst;
    POINTL*         pOffSrc;

    PDEVOBJ po(pso->hdev);

    pState = po.pSpriteState();

    // Restore the surface's original attributes.

    SPRITELOCK slock(po);

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    if (dx > 0)
        iDirection = (dy > 0) ? CD_LEFTUP : CD_LEFTDOWN;
    else
        iDirection = (dy > 0) ? CD_RIGHTUP : CD_RIGHTDOWN;

    if (pco != NULL)
    {
        if (pco->iDComplexity == DC_TRIVIAL)
            pco = NULL;
        else
            rclBounds = pco->rclBounds;
    }

    // If parts of the screen are locked by DirectDraw, update our underlay
    // buffers for the portions covered by both the source rectangle and
    // the destination rectangle and intersect with the locked portion of
    // of the screen.  (This case handles a screen-to-screen blt where
    // a DirectDraw lock sits right in the middle of both.)

    if (pState->prgnUnlocked != NULL)
    {
        rclSrc.left   = prclDst->left   - dx;
        rclSrc.right  = prclDst->right  - dx;
        rclSrc.top    = prclDst->top    - dy;
        rclSrc.bottom = prclDst->bottom - dy;

        if (bIntersect(prclDst, &rclSrc, &rclIntersect))
        {
            vSpUpdateLockedScreenAreas(pState, &gptlZero, &rclIntersect, pco, TRUE);
        }
    }

    ENUMAREAS Enum(pState, prclDst, iDirection);

    // Only check ENUMAREAS::bValid because of the nested ENUMAREAS call below
    // (in the failure case, proceeding is bad because the nested call might
    // succeed in recomputing the sprite ranges and leave us with bad
    // pointers).

    if (Enum.bValid())
    {
        do {
            bMore = Enum.bEnum(&pSpriteDst, &rclDst);

            rclSrc.left   = rclDst.left   - dx;
            rclSrc.right  = rclDst.right  - dx;
            rclSrc.top    = rclDst.top    - dy;
            rclSrc.bottom = rclDst.bottom - dy;

            // For rectangles that intersect multiple sprites, I had thought
            // about simply composing the one overlay for that rectangle, and
            // then copying that to the others.  The problem I saw with that
            // was that if that 'master' underlay is in video memory, but the
            // rest are in system memory, that will actually be slower.

            do {
                if (pSpriteDst == NULL)
                {
                    psoDst  = pso;
                    pOffDst = &gptlZero;
                }
                else
                {
                    psoDst  = pSpriteDst->psoUnderlay;
                    pOffDst = &pSpriteDst->OffUnderlay;
                }

                ENUMAREAS SubEnum(pState, &rclSrc, iDirection);

                do {
                    bSubMore = SubEnum.bEnum(&pSpriteSrc, &rclSubSrc);

                    // We have to be sure to use as the source the last layered
                    // underlay in the list, because we may be traversing
                    // through the same list to find the destination surfaces --
                    // and we don't want to modify our source before we've copied
                    // it to all the other surfaces!  This bug took me an
                    // embarrassingly long time to fix, because it would only
                    // mis-draw when screen-to-screen blts occurred under
                    // actively moving sprites that overlayed each other.

                    while (SubEnum.bEnumLayers(&pSpriteTmp))
                    {
                        pSpriteSrc = pSpriteTmp;
                    }

                    if (pSpriteSrc == NULL)
                    {
                        psoSrc  = pso;
                        pOffSrc = &gptlZero;
                    }
                    else
                    {
                        psoSrc  = pSpriteSrc->psoUnderlay;
                        pOffSrc = &pSpriteSrc->OffUnderlay;
                    }

                    rclSubDst.left   = rclSubSrc.left   + dx;
                    rclSubDst.right  = rclSubSrc.right  + dx;
                    rclSubDst.top    = rclSubSrc.top    + dy;
                    rclSubDst.bottom = rclSubSrc.bottom + dy;

                    ASSERTGDI((rclSubDst.left   >= pState->rclScreen.left) &&
                              (rclSubDst.top    >= pState->rclScreen.top) &&
                              (rclSubDst.right  <= pState->rclScreen.right) &&
                              (rclSubDst.bottom <= pState->rclScreen.bottom),
                        "Enumerated area out of bounds");

                    // We must ensure that for DrvBitBlt, pco->rclBounds intersects
                    // with prclDst, otherwise drivers like the VGA will crash in
                    // their DC_COMPLEX code because they don't check for
                    // intersection:

                    if ((pco == NULL) ||
                        bIntersect(&rclSubDst, &rclBounds, &pco->rclBounds))
                    {
                        if (rop4 == 0xcccc)
                        {
                            OFFCOPYBITS(pOffDst, psoDst, pOffSrc, psoSrc,
                                        pco, pxlo, &rclSubDst, (POINTL*) &rclSubSrc);
                        }
                        else
                        {
                            if (pptlMsk)
                            {
                                ptlSubMsk.x
                                    = pptlMsk->x + (rclSubDst.left - prclDst->left);
                                ptlSubMsk.y
                                    = pptlMsk->y + (rclSubDst.top - prclDst->top);
                            }

                            OFFBITBLT(pOffDst, psoDst, pOffSrc, psoSrc,
                                      psoMsk, pco, pxlo, &rclSubDst,
                                      (POINTL*) &rclSubSrc, &ptlSubMsk, pbo,
                                      pptlBrush, rop4);
                        }
                    }
                } while (bSubMore);
            } while (Enum.bEnumLayers(&pSpriteDst));

            // We recomposite here as we do every sprite, instead of one big
            // 'vSpRedrawArea(pState, prclDst)' at the end, to reduce the visible
            // tearing:

            if (pSpriteDst != NULL)
                vSpRedrawArea(pState, &rclDst);

        } while (bMore);
    }

    // Restore the clip object's original bounds, which we mucked with:

    if (pco != NULL)
        pco->rclBounds = rclBounds;

    // If parts of the screen are locked by DirectDraw, we may also have to
    // update the area in the locked area, which we didn't do above:

    if (pState->prgnUnlocked != NULL)
        vSpUpdateLockedScreenAreas(pState, &gptlZero, prclDst, pco, FALSE);

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSpBltFromScreen
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpBltFromScreen(
SURFOBJ*    psoDst,         // Might be a sprite underlay surface, used
                            //   by vSpUpdate for moving a sprite
SURFOBJ*    psoSrc,         // Always the primary screen
SURFOBJ*    psoMsk,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
RECTL*      prclDst,
POINTL*     pptlSrc,
POINTL*     pptlMsk,
BRUSHOBJ*   pbo,
POINTL*     pptlBrush,
ROP4        rop4)
{
    SPRITESTATE*    pState;
    LONG            dx;
    LONG            dy;
    POINTL          Offset;
    ULONG           iDirection;
    RECTL           rclSrc;
    RECTL           rclDst;
    POINTL          ptlMsk;
    SPRITE*         pSpriteSrc;
    RECTL*          prclBounds;
    BYTE            iDComplexity;
    RECTL           rclBounds;
    BOOL            bMore;
    POINTL*         pOffSrc;

    PDEVOBJ po(psoSrc->hdev);

    pState = po.pSpriteState();

    // To allow software cursors to work, we have to respect the
    // 'bInsideDriverCall' flag to allow the simulations to read
    // directly from the screen.  We also have to be sure that
    // CopyBits calls get sent to CopyBits, otherwise the VGA
    // driver (and possibly others) will crash.

    // Also, if the 'IncludeSprites' flag is set in the destination surface,
    // this is a signal GreStretchBltInternal that we should do a direct blt.
    // (i.e. the ROP passed to StretchBlt/BitBlt had the CAPTUREBLT flag
    // set.) [Bug #278291]

    if ((pState->bInsideDriverCall) ||
        (SURFOBJ_TO_SURFACE(psoDst)->bIncludeSprites()))
    {
        // Grab the sprite lock (needed for the CAPTUREBLT case).

        SPRITELOCK slock(po);

        if (rop4 == 0xcccc)
        {
            return(OFFCOPYBITS(&gptlZero, psoDst, &gptlZero, psoSrc, pco,
                               pxlo, prclDst, pptlSrc));
        }
        else
        {
            return(OFFBITBLT(&gptlZero, psoDst, &gptlZero, psoSrc, psoMsk,
                             pco, pxlo, prclDst, pptlSrc, pptlMsk, pbo,
                             pptlBrush, rop4));
        }
    }

    // Restore the surface's original attributes.

    SPRITELOCK slock(po);

    dx = prclDst->left - pptlSrc->x;
    dy = prclDst->top  - pptlSrc->y;

    rclSrc.left   = pptlSrc->x;
    rclSrc.top    = pptlSrc->y;
    rclSrc.right  = prclDst->right  - dx;
    rclSrc.bottom = prclDst->bottom - dy;

    // If parts of the screen are locked by DirectDraw, update our underlay
    // buffers for the portion read by the blt:

    if (pState->prgnUnlocked != NULL)
    {
        Offset.x = -dx;
        Offset.y = -dy;

        vSpUpdateLockedScreenAreas(pState, &Offset, prclDst, pco, TRUE);
    }

    // We have to enumerate the rectangles according to the blt direction
    // because vSpUpdate may call us with a sprite underlay surface as
    // 'psoDst' in order to move a sprite.

    if (dx > 0)
        iDirection = (dy > 0) ? CD_LEFTUP : CD_LEFTDOWN;
    else
        iDirection = (dy > 0) ? CD_RIGHTUP : CD_RIGHTDOWN;

    iDComplexity = (pco == NULL) ? DC_TRIVIAL : pco->iDComplexity;
    if (iDComplexity != DC_TRIVIAL)
        rclBounds = pco->rclBounds;

    ENUMAREAS Enum(pState, &rclSrc, iDirection);

    do {
        bMore = Enum.bEnum(&pSpriteSrc, &rclSrc);

        rclDst.left   = rclSrc.left   + dx;
        rclDst.right  = rclSrc.right  + dx;
        rclDst.top    = rclSrc.top    + dy;
        rclDst.bottom = rclSrc.bottom + dy;

        // We must ensure that for DrvBitBlt, pco->rclBounds intersects
        // with prclDst, otherwise drivers like the VGA will crash in
        // their DC_COMPLEX code because they don't check for
        // intersection:

        if ((iDComplexity == DC_TRIVIAL) ||
            bIntersect(&rclDst, &rclBounds, &pco->rclBounds))
        {
            if (pSpriteSrc == NULL)
            {
                psoSrc  = pState->psoScreen;
                pOffSrc = &gptlZero;
            }
            else
            {
                psoSrc  = pSpriteSrc->psoUnderlay;
                pOffSrc = &pSpriteSrc->OffUnderlay;
            }

            if (rop4 == 0xcccc)
            {
                OFFCOPYBITS(&gptlZero, psoDst, pOffSrc, psoSrc, pco,
                            pxlo, &rclDst, (POINTL*) &rclSrc);
            }
            else
            {
                if (pptlMsk)
                {
                    ptlMsk.x = pptlMsk->x + (rclDst.left - prclDst->left);
                    ptlMsk.y = pptlMsk->y + (rclDst.top - prclDst->top);
                }

                OFFBITBLT(&gptlZero, psoDst, pOffSrc, psoSrc, psoMsk,
                          pco, pxlo, &rclDst, (POINTL*) &rclSrc, &ptlMsk, pbo,
                          pptlBrush, rop4);
            }
        }
    } while (bMore);

    // Restore the clip object's original bounds, which we mucked with:

    if (iDComplexity != DC_TRIVIAL)
        pco->rclBounds = rclBounds;

    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL SpBitBlt
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpBitBlt(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
SURFOBJ*  psoMsk,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc,
POINTL*   pptlMsk,
BRUSHOBJ* pbo,
POINTL*   pptlBrush,
ROP4      rop4)
{
    SPRITESTATE*    pState;
    PFN_DrvBitBlt   pfnBitBlt;
    RECTL           rclDstOriginal;
    POINTL          OffDst;
    RECTL           rclDst;
    POINTL          ptlSrc;
    POINTL          ptlMsk;
    LONG            dx;
    LONG            dy;
    BOOL            bRet = TRUE;

    PDEVOBJ poSrc((psoSrc != NULL) ? psoSrc->hdev : NULL);

    // Handle the hard cases with specific routines:

    if ((poSrc.bValid()) && (psoSrc == poSrc.pSpriteState()->psoScreen))
    {
        pfnBitBlt = (psoDst == psoSrc) ? bSpBltScreenToScreen : bSpBltFromScreen;

        bRet = pfnBitBlt(psoDst, psoSrc, psoMsk, pco, pxlo, prclDst, pptlSrc,
                         pptlMsk, pbo, pptlBrush, rop4);
    }
    else
    {
        // Watch out for calls that point 'prclDst' to 'pco->rclBounds', which
        // we'll be modifying:

        rclDstOriginal = *prclDst;

        ENUMUNDERLAYS Enum(psoDst, pco, prclDst);
        while (Enum.bEnum(&psoDst, &OffDst, &pco))
        {
            if (rop4 == 0xcccc)
            {
                bRet &= OFFCOPYBITS(&OffDst, psoDst, &gptlZero, psoSrc,
                                    pco, pxlo, &rclDstOriginal, pptlSrc);
            }
            else if ((rop4 & 0xff) == (rop4 >> 8))
            {
                bRet &= OFFBITBLT(&OffDst, psoDst, &gptlZero, psoSrc,
                                  psoMsk, pco, pxlo, &rclDstOriginal, pptlSrc,
                                  pptlMsk, pbo, pptlBrush, rop4);
            }
            else
            {
                // A lot of drivers don't properly handle adjusting 'pptlMsk'
                // in their DrvBitBlt 'punt' code when *prclDst is larger than
                // pco->rclBounds.  So what we'll do here is muck with the
                // parameters to ensure that *prclDst is not larger than
                // pco->rclBounds.
                //
                // Note that this problem does not typically appear without
                // sprites, as NtGdiMaskBlt automatically does this before
                // calling DrvBitBlt.  It's only our ENUMUNDERLAYS code above
                // which generates this sort of clipping.

                rclDst = rclDstOriginal;
                if ((!pco) ||   // If pco is NULL, don't call bIntersect
                    bIntersect(&pco->rclBounds, &rclDstOriginal, &rclDst))
                {
                    dx = rclDst.left - rclDstOriginal.left;
                    dy = rclDst.top - rclDstOriginal.top;

                    POINTL* ptlSrcAdjusted = NULL;

                    if (pptlSrc)
                    {
                        ptlSrc.x = pptlSrc->x + dx;
                        ptlSrc.y = pptlSrc->y + dy;
                        ptlSrcAdjusted = &ptlSrc;
                    }

                    POINTL* ptlMskAdjusted = NULL;

                    if (pptlMsk)
                    {
                        ptlMsk.x = pptlMsk->x + dx;
                        ptlMsk.y = pptlMsk->y + dy;
                        ptlMskAdjusted = &ptlMsk;
                    }

                    bRet &= OFFBITBLT(&OffDst, psoDst, &gptlZero, psoSrc,
                                      psoMsk, pco, pxlo, &rclDst, ptlSrcAdjusted,
                                      ptlMskAdjusted, pbo, pptlBrush, rop4);
                }
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpCopyBits
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpCopyBits(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
RECTL*    prclDst,
POINTL*   pptlSrc)
{
    return(SpBitBlt(psoDst, psoSrc, NULL, pco, pxlo, prclDst, pptlSrc, NULL,
                    NULL, NULL, 0xcccc));
}

/******************************Public*Routine******************************\
* BOOL SpStretchBlt
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpStretchBlt(              // Is this call really needed?
SURFOBJ*         psoDst,
SURFOBJ*         psoSrc,
SURFOBJ*         psoMsk,
CLIPOBJ*         pco,
XLATEOBJ*        pxlo,
COLORADJUSTMENT* pca,
POINTL*          pptlHTOrg,
RECTL*           prclDst,
RECTL*           prclSrc,
POINTL*          pptlMsk,
ULONG            iMode)
{
    BOOL    bRet = TRUE;
    ERECTL  erclDraw;
    POINTL  Offset;

    // The source rectangle should not exceed the bounds
    // of the surface - that should have been handled by GDI.
    // (bug 77102 - see EngStretchBlt)

    ASSERTGDI((prclSrc->left >= 0) &&
              (prclSrc->top  >= 0) &&
              (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
              (prclSrc->bottom <= psoSrc->sizlBitmap.cy),
              "Source rectangle exceeds source surface");

    // I can't be bothered to handle the code that Stretchblt's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngStretchBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                             pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode));
    }

    // The destination rectangle on a stretch will be poorly ordered when
    // inverting or mirroring:

    erclDraw = *prclDst;
    erclDraw.vOrder();

    ENUMUNDERLAYS Enum(psoDst, pco, &erclDraw);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffStretchBlt(PPFNDIRECT(psoDst, StretchBlt), &Offset, psoDst,
                              &gptlZero, psoSrc, psoMsk, pco, pxlo, pca, pptlHTOrg,
                              prclDst, prclSrc, pptlMsk, iMode);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpStretchBltROP
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpStretchBltROP(
SURFOBJ*         psoDst,
SURFOBJ*         psoSrc,
SURFOBJ*         psoMsk,
CLIPOBJ*         pco,
XLATEOBJ*        pxlo,
COLORADJUSTMENT* pca,
POINTL*          pptlHTOrg,
RECTL*           prclDst,
RECTL*           prclSrc,
POINTL*          pptlMsk,
ULONG            iMode,
BRUSHOBJ*        pbo,
DWORD            rop4)
{
    BOOL    bRet = TRUE;
    ERECTL  erclDraw;
    POINTL  Offset;

    // The source rectangle should not exceed the bounds
    // of the surface - that should have been handled by GDI.
    // (bug 77102 - see EngStretchBlt)

    ASSERTGDI((prclSrc->left >= 0) &&
              (prclSrc->top  >= 0) &&
              (prclSrc->right  <= psoSrc->sizlBitmap.cx) &&
              (prclSrc->bottom <= psoSrc->sizlBitmap.cy),
              "Source rectangle exceeds source surface");

    // I can't be bothered to handle the code that Stretchblt's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngStretchBltROP(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                                pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode,
                                pbo, rop4));
    }
    // The destination rectangle on a stretch will be poorly ordered when
    // inverting or mirroring:

    erclDraw = *prclDst;
    erclDraw.vOrder();

    ENUMUNDERLAYS Enum(psoDst, pco, &erclDraw);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffStretchBltROP(PPFNDIRECT(psoDst, StretchBltROP), &Offset,
                                 psoDst, &gptlZero, psoSrc, psoMsk, pco, pxlo, pca,
                                 pptlHTOrg, prclDst, prclSrc, pptlMsk, iMode,
                                 pbo, rop4);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpTextOut
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpTextOut(
SURFOBJ*    pso,
STROBJ*     pstro,
FONTOBJ*    pfo,
CLIPOBJ*    pco,
RECTL*      prclExtra,
RECTL*      prclOpaque,
BRUSHOBJ*   pboFore,
BRUSHOBJ*   pboOpaque,
POINTL*     pptlOrg,
MIX         mix)
{
    BOOL            bRet = TRUE;
    RECTL*          prclBounds;
    POINTL          Offset;
    ULONG           cgposCopied;
    BOOL            bEngTextOutOnly;
    PFN_DrvTextOut  pfnTextOut;

    // Some drivers can't handle antialiased text, so in those cases don't
    // try to call the driver.  Note that we are calling 'SpTextOut' in the
    // first place for these cases to allow 'EngTextOut' to draw directly on 
    // the bits if the surface is an STYPE_BITMAP surface, even if a sprite
    // is on the screen.

    bEngTextOutOnly = FALSE;
    if (pfo->flFontType & FO_GRAY16)
    {
        PDEVOBJ po(pso->hdev);
        if (!(po.flGraphicsCapsNotDynamic() & GCAPS_GRAY16) || (pfo->flFontType & FO_CLEARTYPE_X))
        {
            bEngTextOutOnly = TRUE;
        }
    }

    cgposCopied = ((ESTROBJ*)pstro)->cgposCopied;

    prclBounds = (prclOpaque != NULL) ? prclOpaque : &pstro->rclBkGround;

    ENUMUNDERLAYS Enum(pso, pco, prclBounds);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        ((ESTROBJ*)pstro)->cgposCopied = cgposCopied;

        pfnTextOut = (bEngTextOutOnly) ? EngTextOut : PPFNDIRECT(pso, TextOut);

        bRet &= OffTextOut(pfnTextOut, &Offset, pso, pstro, pfo,
                           pco, prclExtra, prclOpaque, pboFore, pboOpaque,
                           pptlOrg, mix);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpLineTo
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpLineTo(
SURFOBJ   *pso,
CLIPOBJ   *pco,
BRUSHOBJ  *pbo,
LONG       x1,
LONG       y1,
LONG       x2,
LONG       y2,
RECTL     *prclBounds,
MIX        mix)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

    ENUMUNDERLAYS Enum(pso, pco, prclBounds);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        bRet &= OffLineTo(PPFNDIRECT(pso, LineTo), &Offset, pso, pco, pbo,
                          x1, y1, x2, y2, prclBounds, mix);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpDrawStream
*
*  1-27-2001 bhouse
* Wrote it.
\**************************************************************************/

BOOL SpDrawStream(
SURFOBJ*  psoDst,
SURFOBJ*  psoSrc,
CLIPOBJ*  pco,
XLATEOBJ* pxlo,
PRECTL    prclDstBounds,
PPOINTL   pptlDstOffset,
ULONG     ulIn,
PVOID     pvIn,
DSSTATE*  pdss)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

//    DbgPrint("SpDrawStream entered\n");

    // source can't be the screen

    PDEVOBJ poSrc(psoSrc->hdev);
    
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        DbgPrint("SpDrawStream: source is the screen, this should never happen\n");
        return bRet;
    }

    // The source is not the screen.  Only need to worry about enumerating
    // the sprites overlaying the destination.

    ENUMUNDERLAYS Enum(psoDst, pco, prclDstBounds);

    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffDrawStream(PPFNDIRECTENG(psoDst, DrawStream), &Offset,
                                  psoDst, psoSrc, pco, pxlo, prclDstBounds,
                                  pptlDstOffset,
                                  ulIn, pvIn, pdss);
    }

//    DbgPrint("SpDrawStream returning\n");
    
    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpTransparentBlt
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpTransparentBlt(
SURFOBJ         *psoDst,
SURFOBJ         *psoSrc,
CLIPOBJ         *pco,
XLATEOBJ        *pxlo,
RECTL           *prclDst,
RECTL           *prclSrc,
ULONG           iTransColor,
ULONG           ulReserved)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

    // I can't be bothered to handle the code that TransparentBlt's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngTransparentBlt(psoDst, psoSrc, pco, pxlo, prclDst,
                                 prclSrc, iTransColor, ulReserved));
    }

    // The source is not the screen.  Only need to worry about enumerating
    // the sprites overlaying the destination.

    ENUMUNDERLAYS Enum(psoDst, pco, prclDst);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffTransparentBlt(PPFNDIRECT(psoDst, TransparentBlt), &Offset,
                                  psoDst, &gptlZero, psoSrc, pco, pxlo, prclDst,
                                  prclSrc, iTransColor, ulReserved);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpAlphaBlend
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpAlphaBlend(
SURFOBJ       *psoDst,
SURFOBJ       *psoSrc,
CLIPOBJ       *pco,
XLATEOBJ      *pxlo,
RECTL         *prclDst,
RECTL         *prclSrc,
BLENDOBJ      *pBlendObj)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

    // I can't be bothered to handle the code that AlphaBlend's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngAlphaBlend(psoDst, psoSrc, pco, pxlo, prclDst,
                             prclSrc, pBlendObj));
    }

    // The source is not the screen.  Only need to worry about enumerating
    // the sprites overlaying the destination.

    ENUMUNDERLAYS Enum(psoDst, pco, prclDst);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffAlphaBlend(PPFNDIRECT(psoDst, AlphaBlend), &Offset, psoDst,
                              &gptlZero, psoSrc, pco, pxlo,
                              prclDst, prclSrc, pBlendObj);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpPlgBlt
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpPlgBlt(
SURFOBJ*            psoDst,
SURFOBJ*            psoSrc,
SURFOBJ*            psoMsk,
CLIPOBJ*            pco,
XLATEOBJ*           pxlo,
COLORADJUSTMENT*    pca,
POINTL*             pptlBrush,
POINTFIX*           pptfx,
RECTL*              prcl,
POINTL*             pptl,
ULONG               iMode)
{
    RECTL   rclDraw;
    BOOL    bRet = TRUE;
    LONG    iLeft = (pptfx[1].x > pptfx[0].x) == (pptfx[1].x > pptfx[3].x);
    LONG    iTop  = (pptfx[1].y > pptfx[0].y) == (pptfx[1].y > pptfx[3].y);
    POINTL  Offset;

    // I can't be bothered to handle the code that PlgBlt's when the
    // source is the screen.  To handle those cases, we would have to
    // exclude all the sprites on the read, just as bSpBltFromScreen does.
    // Fortunately, we've marked the screen surface as STYPE_DEVICE and
    // so the Eng function will punt via SpCopyBits, which does do the
    // right thing:

    PDEVOBJ poSrc(psoSrc->hdev);
    if ((poSrc.bValid()) && (poSrc.pSpriteState()->psoScreen == psoSrc))
    {
        return(EngPlgBlt(psoDst, psoSrc, psoMsk, pco, pxlo, pca,
                         pptlBrush, pptfx, prcl, pptl, iMode));
    }

    if (pptfx[iLeft].x > pptfx[iLeft ^ 3].x)
    {
        iLeft ^= 3;
    }

    if (pptfx[iTop].y > pptfx[iTop ^ 3].y)
    {
        iTop ^= 3;
    }

    rclDraw.left   = LONG_FLOOR_OF_FIX(pptfx[iLeft].x) - 1;
    rclDraw.top    = LONG_FLOOR_OF_FIX(pptfx[iTop].y) - 1;
    rclDraw.right  = LONG_CEIL_OF_FIX(pptfx[iLeft ^ 3].x) + 1;
    rclDraw.bottom = LONG_CEIL_OF_FIX(pptfx[iTop ^ 3].y) + 1;

    ASSERTGDI((rclDraw.left < rclDraw.right) && (rclDraw.top < rclDraw.bottom),
        "Messed up bound calculation");

    ENUMUNDERLAYS Enum(psoDst, pco, &rclDraw);
    while (Enum.bEnum(&psoDst, &Offset, &pco))
    {
        bRet &= OffPlgBlt(PPFNDIRECT(psoDst, PlgBlt), &Offset, psoDst,
                          &gptlZero, psoSrc, psoMsk, pco, pxlo, pca, pptlBrush,
                          pptfx, prcl, pptl, iMode);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpGradientFill
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL SpGradientFill(
SURFOBJ*    pso,
CLIPOBJ*    pco,
XLATEOBJ*   pxlo,
TRIVERTEX*  pVertex,
ULONG       nVertex,
PVOID       pMesh,
ULONG       nMesh,
RECTL*      prclExtents,
POINTL*     pptlDitherOrg,
ULONG       ulMode)
{
    BOOL    bRet = TRUE;
    POINTL  Offset;

    ENUMUNDERLAYS Enum(pso, pco, prclExtents);
    while (Enum.bEnum(&pso, &Offset, &pco))
    {
        bRet &= OffGradientFill(PPFNDIRECT(pso, GradientFill), &Offset, pso,
                                pco, pxlo, pVertex, nVertex, pMesh, nMesh,
                                prclExtents, pptlDitherOrg, ulMode);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL SpSaveScreenBits
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

ULONG_PTR SpSaveScreenBits(
SURFOBJ*    pso,
ULONG       iMode,
ULONG_PTR   ident,
RECTL*      prclSave)
{
    SPRITESTATE*    pState;
    SURFACE*        pSurface;
    PTRACKOBJ       pto;
    PEWNDOBJ        pwo;
    BOOL            bIntersectsFunkyFormat;
    BOOL            bUnTearDown;
    DEVEXCLUDERECT  dxo;

    PDEVOBJ po(pso->hdev);
    po.vAssertDevLock();

    pState = po.pSpriteState();
    pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen);

    // For the most part, SaveScreenBits is completely redundant and
    // handled perfectly fine by USER creating a compatible bitmap to
    // hold the backing bits.  However, there is one useful scenario
    // for SaveScreenBits: when it occurs on top of a funky pixel-format
    // window as used by some OpenGL hardware.  In that case, the window
    // format is not the same as the display, so information would be
    // lost if the bits weren't saved in the original format, which is
    // handled by the driver in DrvSaveScreenBits.
    //
    // So...  We expect funky pixel format WNDOBJs to have the NOSPRITES
    // attribute set, meaning we're not supposed to draw any sprites on
    // them.

    if ((pState->pfnSaveScreenBits == NULL) || (gpto == NULL))
        return(0);

    if (iMode == SS_SAVE)
    {
        // We must be holding the WNDOBJ semaphore before mucking
        // with any WNDOBJs.

        SEMOBJ so(ghsemWndobj);

        // See if any funky format WNDOBJ intersects with the requested
        // rectangle.

        bIntersectsFunkyFormat = FALSE;

        for (pto = gpto;
             (pto != NULL) && !bIntersectsFunkyFormat;
             pto = pto->ptoNext)
        {
            for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
            {
                // The WNDOBJ coordinates must be device-relative so
                // use UNDO:

                UNDODESKTOPCOORD udc(pwo, pState);

                if ((pwo->fl & WO_NOSPRITES) &&
                    bIntersect(&pwo->rclBounds, prclSave) &&
                    pwo->bInside(prclSave) == REGION_RECT_INTERSECT)
                {
                    bIntersectsFunkyFormat = TRUE;
                    break;
                }
            }
        }

        // If the requested save rectangle doesn't intersect with any
        // funky WNDOBJ, we can tell USER to revert to the sprite-friendly
        // comaptible-bitmap save-bits method by returning 0.

        if (!bIntersectsFunkyFormat)
            return(0);
    }

    // Tear down any sprites that may overlap the area.  This handles the
    // case where the requested save rectangle isn't entirely contained
    // within the WNDOBJ.

    if (iMode != SS_FREE)
        dxo.vExclude(pso->hdev, prclSave);

    return(pState->pfnSaveScreenBits(pso, iMode, ident, prclSave));
}

/******************************Public*Routine******************************\
* BOOL vSpHook
*
* Hooks into the DDI between GDI and the display driver to add an
* additional layer.  This only needs to be done when a sprite is
* visible on the screen (and we take advantage of this to unhook
* whenever possible, for better performance).
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpHook(
SPRITESTATE*    pState)
{
    PDEVOBJ     po(pState->hdev);
    PDEV*       ppdev = po.ppdev;
    SURFACE*    psurf = po.pSurface();

    ASSERTGDI(!pState->bHooked,
        "Should hook only if already unhooked");
    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    // Note that the surface's 'iType' and 'flSurfFlags' fields won't
    // be modified to reflect the new state until the SPRITELOCK destructor.

    pState->iSpriteType = STYPE_DEVICE;

    // First, remove all HOOK_ flags for any drawing calls.  We do this
    // by removing all HOOK_FLAGS except HOOK_MOVEPANNING and HOOK_SYNCHRONIZE,
    // which aren't really drawing calls:

    pState->flSpriteSurfFlags = psurf->flags() & (~HOOK_FLAGS      |
                                                  HOOK_MOVEPANNING |
                                                  HOOK_SYNCHRONIZE);

    // Now add in all the flags for those drawing functions hooked by the
    // sprite layer.  Note that for performance reasons HOOK_STROKEANDFILLPATH
    // is not one of these (since no drivers hook DrvStrokeAndFillPath,
    // and EngStrokeAndFillPath isn't smart enough to call DrvStrokePath
    // and DrvFillPath separately, and so we would get no accelerated drawing):

    pState->flSpriteSurfFlags  |= (HOOK_BITBLT           |
                                   HOOK_STRETCHBLT       |
                                   HOOK_PLGBLT           |
                                   HOOK_TEXTOUT          |
                                   HOOK_STROKEPATH       |
                                   HOOK_FILLPATH         |
                                   HOOK_LINETO           |
                                   HOOK_COPYBITS         |
                                   HOOK_STRETCHBLTROP    |
                                   HOOK_TRANSPARENTBLT   |
                                   HOOK_ALPHABLEND       |
                                   HOOK_GRADIENTFILL);

    ppdev->apfn[INDEX_DrvStrokePath]        = (PFN) SpStrokePath;
    ppdev->apfn[INDEX_DrvFillPath]          = (PFN) SpFillPath;
    ppdev->apfn[INDEX_DrvBitBlt]            = (PFN) SpBitBlt;
    ppdev->apfn[INDEX_DrvCopyBits]          = (PFN) SpCopyBits;
    ppdev->apfn[INDEX_DrvStretchBlt]        = (PFN) SpStretchBlt;
    ppdev->apfn[INDEX_DrvTextOut]           = (PFN) SpTextOut;
    ppdev->apfn[INDEX_DrvLineTo]            = (PFN) SpLineTo;
    ppdev->apfn[INDEX_DrvTransparentBlt]    = (PFN) SpTransparentBlt;
    ppdev->apfn[INDEX_DrvAlphaBlend]        = (PFN) SpAlphaBlend;
    ppdev->apfn[INDEX_DrvPlgBlt]            = (PFN) SpPlgBlt;
    ppdev->apfn[INDEX_DrvGradientFill]      = (PFN) SpGradientFill;
    ppdev->apfn[INDEX_DrvDrawStream]        = (PFN) SpDrawStream;
    ppdev->apfn[INDEX_DrvStretchBltROP]     = (PFN) SpStretchBltROP;
    ppdev->apfn[INDEX_DrvSaveScreenBits]    = (PFN) SpSaveScreenBits;

    pState->bHooked = TRUE;

    // Calculate the regions of the screen that shouldn't be drawn upon:

    vSpComputeUnlockedRegion(pState);
}

/******************************Public*Routine******************************\
* BOOL vSpUnhook
*
* If there are no visible sprites, unhook from the DDI for better
* performance.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpUnhook(
SPRITESTATE*    pState)
{
    PDEVOBJ     po(pState->hdev);
    PDEV*       ppdev = po.ppdev;
    SURFACE*    psurf = po.pSurface();

    ASSERTGDI(pState->bHooked,
        "Should unhook only if already hooked");
    ASSERTGDI(pState->bInsideDriverCall,
        "SPRITELOCK should be held");

    // Note that the surface's 'iType' and 'flSurfFlags' fields won't
    // be modified to reflect the new state until the SPRITELOCK destructor.

    pState->iSpriteType       = pState->iOriginalType;
    pState->flSpriteSurfFlags = pState->flOriginalSurfFlags;

    ppdev->apfn[INDEX_DrvStrokePath]        = (PFN) pState->pfnStrokePath;
    ppdev->apfn[INDEX_DrvFillPath]          = (PFN) pState->pfnFillPath;
    ppdev->apfn[INDEX_DrvBitBlt]            = (PFN) pState->pfnBitBlt;
    ppdev->apfn[INDEX_DrvCopyBits]          = (PFN) pState->pfnCopyBits;
    ppdev->apfn[INDEX_DrvStretchBlt]        = (PFN) pState->pfnStretchBlt;
    ppdev->apfn[INDEX_DrvTextOut]           = (PFN) pState->pfnTextOut;
    ppdev->apfn[INDEX_DrvLineTo]            = (PFN) pState->pfnLineTo;
    ppdev->apfn[INDEX_DrvTransparentBlt]    = (PFN) pState->pfnTransparentBlt;
    ppdev->apfn[INDEX_DrvAlphaBlend]        = (PFN) pState->pfnAlphaBlend;
    ppdev->apfn[INDEX_DrvPlgBlt]            = (PFN) pState->pfnPlgBlt;
    ppdev->apfn[INDEX_DrvGradientFill]      = (PFN) pState->pfnGradientFill;
    ppdev->apfn[INDEX_DrvStretchBltROP]     = (PFN) pState->pfnStretchBltROP;
    ppdev->apfn[INDEX_DrvSaveScreenBits]    = (PFN) pState->pfnSaveScreenBits;
    ppdev->apfn[INDEX_DrvDrawStream]        = (PFN) pState->pfnDrawStream;

    pState->bHooked = FALSE;
}

/******************************Public*Routine******************************\
* BOOL bSpIsSystemMemory
*
* Simple little routine that returns TRUE if the surface is definitely
* in system memory; FALSE if it's likely in video memory.  (Video memory
* is slow when we have to read the surface, because reads over the bus
* are very painful.)
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

inline BOOL bSpIsSystemMemory(
SURFOBJ* pso)
{
    return((pso->iType == STYPE_BITMAP) && !(pso->fjBitmap & BMF_NOTSYSMEM));
}

/******************************Public*Routine******************************\
* VOID vSpCreateShape
*
* Allocates (if necessary) a new bitmap for the sprite, and copies it.
*
* Note: pSprite->psoShape will be NULL if this function fails!
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpCreateShape(
SPRITE*     pSprite,
POINTL*     pOffSrc,    // Offset associated with 'psoSrc'
SURFOBJ*    psoSrc,
XLATEOBJ*   pxlo,
RECTL*      prcl,
PALETTE*    ppalSrc,
ULONG       iFormat = 0,// May be '0' to select current screen format
ULONG       bWantSystemMemory = TRUE,
RECTL*      prclDirty = NULL)
                        // Requested type, STYPE_DEVBITMAP or STYPE_BITMAP.
{
    SURFOBJ*        psoShape;
    LONG            cxSrc;
    LONG            cySrc;
    POINTL          ptlSrc;
    PFN_DrvCopyBits pfnCopyBits;

    // First, handle the palette references:

    XEPALOBJ palNew(ppalSrc);
    XEPALOBJ palOld(pSprite->ppalShape);

    palNew.vRefPalette();
    palOld.vUnrefPalette();

    pSprite->ppalShape = ppalSrc;

    // Now, handle the bitmap:

    cxSrc = prcl->right - prcl->left;
    cySrc = prcl->bottom - prcl->top;

    if (iFormat == 0)
        iFormat = pSprite->pState->psoScreen->iBitmapFormat;

    // Note that we don't try to create a bitmap of type STYPE_DEVBITMAP
    // if we already have a perfectly satisfactory STYPE_BITMAP sitting
    // around.  We do this for the case where we might be low on video
    // memory, so that we don't keep re-allocating on every shape change.

    psoShape = pSprite->psoShape;
    if ((psoShape == NULL)                                    ||
        (!bSpIsSystemMemory(psoShape) && (bWantSystemMemory)) ||
        (psoShape->iBitmapFormat != iFormat)                  ||
        (psoShape->sizlBitmap.cx < cxSrc)                     ||
        (psoShape->sizlBitmap.cy < cySrc))
    {
        // Max thing again?  Or maybe hint?

        vSpDeleteSurface(psoShape);

        psoShape = psoSpCreateSurface(pSprite->pState,
                                      iFormat,
                                      cxSrc,
                                      cySrc,
                                      bWantSystemMemory);

        pSprite->psoShape = psoShape;
    }

    if (psoShape != NULL)
    {
        pSprite->OffShape.x  = -prcl->left;
        pSprite->OffShape.y  = -prcl->top;
        pSprite->iModeFormat = iFormat;
        pSprite->flModeMasks = palNew.flRed() | palNew.flBlu();

        // If they passed us a dirty rectangle, only copy bits on that rectangle
        ERECTL erclDirty = (ERECTL) *prcl;
        if (prclDirty)
        {
            erclDirty *= (*prclDirty);
        }

        if (!erclDirty.bEmpty())
        {
            // Calculate required source rectangle
            ERECTL erclSrc(erclDirty);
            erclSrc += *pOffSrc;
    
            MULTISURF   mSrc(psoSrc, &erclSrc);
    
            // Be sure to go through the DDI hooks and not directly to the Offset
            // functions so that we can read the surface from the multi-mon screen
            // and the like:
    
            if (SURFOBJ_TO_SURFACE_NOT_NULL(psoShape)->flags() & HOOK_CopyBits)
            {
                PDEVOBJ     poShape(psoShape->hdev);

                // WINBUG #415010 06-12-2001 jasonha  Properly fail shape update
                // If bLoadSource fails, we can not guarentee a cross-device
                // copy will succeed. Return failure by setting psoShape = NULL.

                if (!mSrc.bLoadSource(poShape.hdev()))
                {
                    vSpDeleteSurface(pSprite->psoShape);
                    pSprite->psoShape = NULL;
                    return;
                }
                else
                {
                    pfnCopyBits = PPFNDRV(poShape,CopyBits);
                }
            }
            else
            {
                PDEVOBJ poSrc(psoSrc->hdev);
                pfnCopyBits = PPFNGET(poSrc,
                                      CopyBits,
                                      SURFOBJ_TO_SURFACE_NOT_NULL(psoSrc)->flags());
            }

            OffCopyBits(pfnCopyBits, &pSprite->OffShape, psoShape, &gptlZero, mSrc.pso,
                        NULL, pxlo, (RECTL*) &erclDirty, mSrc.pptl());
        }
    }
}

/******************************Public*Routine******************************\
* VOID vSpDeleteShape
*
* Deletes any shape surfaces associated with the sprite.  Note that this
* does NOT delete the sprite itself.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDeleteShape(
SPRITE* pSprite)
{
    if (pSprite->ppalShape != NULL)
    {
        XEPALOBJ palShape(pSprite->ppalShape);
        palShape.vUnrefPalette();
        pSprite->ppalShape = NULL;
    }
    if (pSprite->psoShape != NULL)
    {
        vSpDeleteSurface(pSprite->psoShape);
        pSprite->psoShape = NULL;
    }
}

/******************************Public*Routine******************************\
* BOOL bSpUpdateAlpha
*
* Parses the BLENDFUNCTION parameter passed in, to ensure that it is
* consistent with the type that the sprite originally was created as.
*
* Returns FALSE if the specified BLENDFUNCTION cannot be allowed, because
* of an improper flag or because it's not consistent with the sprite type.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdateAlpha(
SPRITE*         pSprite,
BLENDFUNCTION*  pblend,
BOOL            bUpdateOnlyAlpha)
{
    BOOL bRet = FALSE;

    // Note that we don't allow the AC_SRC_ALPHA status to be different
    // from the previous AC_SRC_ALPHA status.

    if ((pblend->BlendOp != AC_SRC_OVER)                  ||
             (pblend->BlendFlags != 0)                    ||
             ((pblend->AlphaFormat & ~AC_SRC_ALPHA) != 0))
    {
        WARNING("bSpUpdateAlpha: Invalid alpha");
    }
    else if (((pSprite->dwShape & ULW_ALPHA) == 0) &&
             (pSprite->psoShape != NULL))
    {
        WARNING("bSpUpdateAlpha:  dwShape must be ULW_ALPHA");
    }
    else
    {
        bRet = TRUE;

        if (bUpdateOnlyAlpha)
            pSprite->BlendFunction.SourceConstantAlpha =
                pblend->SourceConstantAlpha;
        else
            pSprite->BlendFunction = *pblend;

        pSprite->dwShape &= ~ULW_OPAQUE;
        pSprite->dwShape |= ULW_ALPHA;

        // When trying to display a sprite at 8bpp, always render
        // it opaque.  It beats displaying a crappy image slowly.

        if ((pSprite->pState->iModeFormat <= BMF_8BPP) ||
            (!(pblend->AlphaFormat & AC_SRC_ALPHA) &&
             (pblend->SourceConstantAlpha == 0xff)))
        {
            pSprite->fl |= SPRITE_FLAG_EFFECTIVELY_OPAQUE;
        }
        else
        {
            pSprite->fl &= ~SPRITE_FLAG_EFFECTIVELY_OPAQUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* VOID vSpUpdatePerPixelAlphaFromColorKey
*
* Given a 32bpp surface, turns every pixel matching the transparent
* color transparent, and turns every pixel not matching the transparent
* color opaque.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpUpdatePerPixelAlphaFromColorKey(
SURFOBJ*    pso,
ULONG       rgbTransparent,
RECTL*      prclDirty)
{
    LONG    i;
    LONG    j;
    BYTE*   pScan;
    ULONG*  pul;
    ULONG   ulTransparent;
    LONG    lDelta;
    LONG    cx, cy;

    ASSERTGDI((pso->iBitmapFormat == BMF_32BPP) && (pso->iType == STYPE_BITMAP),
        "Expected readable 32bpp ARGB surface only");

    ulTransparent = ((rgbTransparent & 0xff0000) >> 16)
                  | ((rgbTransparent & 0x00ff00))
                  | ((rgbTransparent & 0x0000ff) << 16);

    ERECTL erectlDirty(0, 0, pso->sizlBitmap.cx, pso->sizlBitmap.cy);

    if (prclDirty)
    {
        // If the caller gives us a dirty rectangle, intersect it with the
        // surface rectangle.

        erectlDirty *= (*prclDirty);
    }

    lDelta = pso->lDelta;
    cx = erectlDirty.right  - erectlDirty.left;
    cy = erectlDirty.bottom - erectlDirty.top;

    for (j = cy, pScan = ((BYTE*) pso->pvScan0) + erectlDirty.top * lDelta +
                                                + erectlDirty.left * sizeof(ULONG);
         j != 0;
         j--, pScan += lDelta)
    {
        for (i = cx, pul = (ULONG*) pScan;
             i != 0;
             i--, pul++)
        {
            if (*pul == ulTransparent)
            {
                // Write a pre-multiplied value of 0:

                *pul = 0;
            }
            else
            {
                // Where the bitmap is not the transparent color, change
                // the alpha value to opaque:

                ((RGBQUAD*) pul)->rgbReserved = 0xff;
            }
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bSpUpdateShape
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdateShape(
SPRITE*         pSprite,
DWORD           dwShape,
HDC             hdcDst,
HDC             hdcSrc,
COLORREF        crKey,
BLENDFUNCTION*  pblend,
POINTL*         pptlSrc,
SIZEL*          psizl,
RECTL*          prclDirty)
{
    BOOL            bStatus = FALSE;        // Assume failure
    SPRITESTATE*    pState;
    SURFACE*        psurfSrc;
    RECTL           rclSrc;
    PALETTE*        ppalDst;
    PALETTE*        ppalDstDC;
    ULONG           iFormat;
    ULONG           crTextClr;
    ULONG           crBackClr;
    LONG            lIcmMode;
    BOOL            bWantVideoMemory;
    BOOL            bColorKeyAlpha;
    ULONG           iSrcTransparent;
    BLENDFUNCTION   blend;

    pState = pSprite->pState;
    PDEVOBJ po(pState->hdev);

    // Note that only kerne-mode callers can specify ULW_DRAGRECT, so we
    // don't have to be as paranoid about checking parameters for this
    // case.

    if (dwShape == ULW_DRAGRECT)
    {
        // Note that there's not really a source surface, so this is a
        // little faked.

        pSprite->dwShape       = dwShape;
        pSprite->rclSrc.left   = 0;
        pSprite->rclSrc.right  = psizl->cx;
        pSprite->rclSrc.top    = 0;
        pSprite->rclSrc.bottom = psizl->cy;
        pSprite->iModeFormat   = pState->iModeFormat;
        pSprite->flModeMasks   = pState->flModeMasks;

        return(TRUE);
    }

    if (dwShape == 0)
    {
       dwShape = pSprite->dwShape;
       pblend = &pSprite->BlendFunction;
    }

    if ((pptlSrc == NULL) ||
        (psizl == NULL)   ||
        ((pblend == NULL) && (dwShape & ULW_ALPHA)))
    {
        WARNING("bSpUpdateShape: Invalid NULL parameter");
        return(bStatus);
    }

    // The supplied source DC has to either belong to the same PDEV as the
    // sprite, or it has to belong to the multi-monitor meta-PDEV.  This is
    // because we do not support the S3 driver reading a device bitmap owned
    // by the MGA driver, for example.

    DCOBJ dcoSrc(hdcSrc);
    if (!dcoSrc.bValid() ||
        dcoSrc.bFullScreen() ||
        ((dcoSrc.hdev() != pState->hdev) && (dcoSrc.hdev() != po.hdevParent())))
    {
        WARNING("bSpUpdateShape: Invalid source DC");
        return(bStatus);
    }

    if (hdcDst == 0)
    {
        // Supply some default information for the palette:

        ppalDstDC = ppalDefault;
        crTextClr = 0x00ffffff;
        crBackClr = 0;
        lIcmMode  = 0;
    }
    else
    {
        // Note that with multi-mon, the destination DC may be for a separate
        // PDEV than our own PDEV.  That is, the destination DC may be
        // associated with the meta-PDEV while we're drawing to a specific
        // PDEV.  This is okay.  All we'll be pulling out of the source DC
        // is some palette information.

        DCOBJ dcoDst(hdcDst);
        if (!dcoDst.bValid()                 ||
            (dcoDst.hdev() != dcoSrc.hdev()) ||
            ((dcoDst.hdev() != pState->hdev) && (dcoDst.hdev() != po.hdevParent())))
        {
            WARNING("bSpUpdateShape: Invalid destination DC");
            return(bStatus);
        }

        ppalDstDC = dcoDst.ppal();
        crTextClr = dcoDst.pdc->crTextClr();
        crBackClr = dcoDst.pdc->crBackClr();
        lIcmMode  = dcoDst.pdc->lIcmMode();
    }

    rclSrc.left   = pptlSrc->x;
    rclSrc.right  = pptlSrc->x + psizl->cx;
    rclSrc.top    = pptlSrc->y;
    rclSrc.bottom = pptlSrc->y + psizl->cy;

    psurfSrc = dcoSrc.pSurface();
    if ((psurfSrc != NULL)                     &&
        (rclSrc.left   >= 0)                   &&
        (rclSrc.top    >= 0)                   &&
        (rclSrc.left    < rclSrc.right)        &&
        (rclSrc.top     < rclSrc.bottom)       &&
        (rclSrc.right  <= psurfSrc->sizl().cx) &&
        (rclSrc.bottom <= psurfSrc->sizl().cy))
    {
        // Clip prclDirty to the source surface
        if (prclDirty)
        {
            (*((ERECTL *) prclDirty)) *=
                ERECTL(0, 0, psurfSrc->sizl().cx, psurfSrc->sizl().cy);
        }

        EXLATEOBJ   xlo;
        XEPALOBJ    palSrcDC(dcoSrc.ppal());
        XEPALOBJ    palSrc(psurfSrc->ppal());
        XEPALOBJ    palRGB(gppalRGB);

        // If both ULW_ALPHA and ULW_COLORKEY are specified, then any
        // pixels that match the color-key are completely transparent,
        // and all other pixels have an alpha value of the global alpha
        // specified.
        //
        // Since we don't have any low-level color-keyed-alpha-code, we
        // simply convert this case to using per-pixel alpha.

        bColorKeyAlpha = ((dwShape == (ULW_ALPHA | ULW_COLORKEY)) &&
                          (pblend->AlphaFormat == 0));

        if (bColorKeyAlpha)
        {
            blend = *pblend;
            blend.AlphaFormat = AC_SRC_ALPHA;
            pblend = &blend;
            dwShape = ULW_ALPHA;

            bColorKeyAlpha = TRUE;

            iSrcTransparent = rgbFromColorref(palRGB,
                                              palSrcDC,
                                              crKey);
        }

        // See whether we should make the sprite 32bpp, or convert it to
        // being the same format as the screen:

        if ((dwShape == ULW_ALPHA) && (pblend->AlphaFormat & AC_SRC_ALPHA))
        {
            iFormat   = BMF_32BPP;
            ppalDst   = gppalRGB;
            ppalDstDC = ppalDefault;
        }
        else
        {
            iFormat = 0;
            ppalDst = po.ppalSurf();    // Don't use dcoDst.ppal() because
                                        //   with multimon, this may be the
        }                               //   wrong PDEV

        XEPALOBJ palDstDC(ppalDstDC);
        XEPALOBJ palDst(ppalDst);

        if (xlo.bInitXlateObj(NULL,
                              lIcmMode,
                              palSrc,
                              palDst,
                              palSrcDC,
                              palDstDC,
                              crTextClr,
                              crBackClr,
                              0))
        {
            bStatus = TRUE;

            pSprite->dwShape = dwShape;
            pSprite->rclSrc  = rclSrc;

            if (dwShape == ULW_OPAQUE)
            {
                pSprite->fl   |= SPRITE_FLAG_EFFECTIVELY_OPAQUE;
                bWantVideoMemory = TRUE;
            }
            else if (dwShape == ULW_COLORKEY)
            {
                // Transparency is of course specified using the
                // source DC palette.

                iSrcTransparent = ulGetNearestIndexFromColorref(
                                        palSrc,
                                        palSrcDC,
                                        crKey);

                // ...but we're about to copy the source bitmap to a
                // format that is the same as the screen.  So we have
                // to pipe the transparency color through the same
                // conversion that the pixels on the blt go through.
                //
                // Note that this is NOT equivalent to doing:
                //
                //     iTransparent = ulGetNearestIndexFromColorref(
                //                          palDst,
                //                          palDstDC,
                //                          crKey)
                //
                // Converting to a compatible bitmap may cause us to
                // increase the transparency color gamut (think of a
                // 24bpp color wash being blt'd with a transparency
                // key to 4bpp).  But we do this for two reasons:
                //
                // 1. The shape bitmap is always stored in the same
                //    format as the screen, and so may be kept by the
                //    driver in off-screen memory and thus be accelerated;
                // 2. On dynamic mode changes, we don't have to keep
                //    the source DC palette and source surface palette
                //    around to re-compute the proper translate.

                pSprite->iTransparent = XLATEOBJ_iXlate(xlo.pxlo(),
                                                        iSrcTransparent);

                pSprite->fl &= ~SPRITE_FLAG_EFFECTIVELY_OPAQUE;

                bWantVideoMemory
                    = (po.flAccelerated() & ACCELERATED_TRANSPARENT_BLT);
            }
            else if (dwShape == ULW_ALPHA)
            {
                if (!bSpUpdateAlpha(pSprite, pblend, FALSE))
                {
                    bStatus = FALSE;
                }
                else if ((pblend->AlphaFormat & AC_SRC_ALPHA) &&
                         !bIsSourceBGRA(psurfSrc) &&
                         !bColorKeyAlpha)
                {
                    bStatus = FALSE;
                }
                else if (bColorKeyAlpha)
                {
                    // We need to be able to directly muck on the bits,
                    // so we don't want video memory:

                    bWantVideoMemory = FALSE;
                }
                else if (pblend->AlphaFormat & AC_SRC_ALPHA)
                {
                    bWantVideoMemory
                        = (po.flAccelerated() & ACCELERATED_PIXEL_ALPHA);
                }
                else
                {
                    // There's no per-pixel alpha, so we should convert the
                    // bitmap to the video card's preferred format (namely,
                    // whatever the format of the primary is).

                    bWantVideoMemory
                        = (po.flAccelerated() & ACCELERATED_CONSTANT_ALPHA);
                }
            }
            else
            {
                WARNING("bSpUpdateShape: Bad shape");
                bStatus = FALSE;
            }

            if (bStatus)
            {
                // For multi-mon, if the source is the meta-screen, we
                // can't blt to a device surface because the two surfaces
                // would belong to different PDEVs.  Since I'm lazy, I'll
                // simply enforce that one of the surfaces is not a device
                // surface, when multi-mon:

#if 0           // WINBUG 315863/320834: We are leaving this old code till fixes for these bugs bake. We will remove these once the new code has baked,
                if ((psurfSrc->iType() == STYPE_DEVICE) &&
                    (po.hdevParent() != po.hdev()))   // Child PDEV
                {
                    bWantVideoMemory = FALSE;
                }
                else if ((psurfSrc->iType() == STYPE_DEVBITMAP) &&
                         (po.hdevParent() != po.hdev()) &&
                         (po.flGraphicsCaps() & GCAPS_LAYERED))
                {
                    // We are given a meta dfb as source and want to update
                    // the shape for a mirrored device sprite. Use the meta
                    // dfb's corresponding mirror dev bitmap as source.
                   
                    PSURFACE psurfSrcTmp;
                    psurfSrcTmp = MulGetDevBitmapFromMasterDFB(psurfSrc,po.hdev());
                    if (psurfSrcTmp)
                        psurfSrc = psurfSrcTmp;
                    else
                    {
                        // We dont have a mirror dev bitmap. Use the master meta
                        // dfb after uncloaking it:

                        mSrc.vUnCloak(psurfSrc->pSurfobj());
                    }
                }
#endif

                // If the requested operation isn't accelerated, we convert
                // the source bitmap to a true DIB.  We do this on the
                // assumption that the application is animating, and will
                // soon call us again with the same bitmap:

                if ((!bWantVideoMemory) && !bSpIsSystemMemory(psurfSrc->pSurfobj()))
                {
                    // We don't care if the operation fails, as it was only a
                    // performance hint:

                    bConvertDfbDcToDib(&dcoSrc);

                    psurfSrc = dcoSrc.pSurface();
                }

                if (bStatus)
                {
                    // We temporarily reset the 'bInsideDriverCall' flag for the
                    // duration of 'vSpCreateShape' so that the read from the source
                    // will be correctly handled if the source is actually the
                    // screen.  We do this so that we don't capture the contents of
                    // other sprites when this happens.

                    ASSERTGDI(pState->bInsideDriverCall, "Expected sprite lock held");

                    vSpDirectDriverAccess(pState, FALSE);

                    vSpCreateShape(pSprite,
                                   &gptlZero,
                                   psurfSrc->pSurfobj(),
                                   xlo.pxlo(),
                                   &rclSrc,
                                   ppalDst,
                                   iFormat,
                                   !bWantVideoMemory,
                                   prclDirty);

                    // Restore the direct driver access state:

                    vSpDirectDriverAccess(pState, TRUE);
                }
            }

            if ((bStatus) && (pSprite->psoShape != NULL))
            {
                // Oh happy times, we succeeded.

                if (bColorKeyAlpha)
                {
                    // Anywhere the color-key is, convert it to transparent.
                    // Anywhere the color-key isn't, make it opaque:

                    vSpUpdatePerPixelAlphaFromColorKey(pSprite->psoShape,
                                                       iSrcTransparent,
                                                       prclDirty);
                }
            }
            else
            {
                // Uh oh, something failed.  We have to delete the sprite
                // now because we may have partially wacked some of our
                // pSprite state.

                vSpDeleteShape(pSprite);
                pSprite->dwShape = ULW_OPAQUE; // reset dwShape to
                                               // something innocuous
                bStatus = FALSE;
            }
        }
    }
    else
    {
        WARNING("bSpUpdateShape: Bad DCs or rectangles");
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* VOID vSpTransferShape
*
* Creates a shape for a new sprite that is a copy of the old.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpTransferShape(
SPRITE* pSpriteNew,
SPRITE* pSpriteOld)
{
    ASSERTGDI(pSpriteNew->psoShape == NULL,
        "Expected new sprite to have no resources");

    // Transfer HIDDEN state to the new sprite
    pSpriteNew->fl |= pSpriteOld->fl & SPRITE_FLAG_HIDDEN;

    if (pSpriteOld->psoShape != NULL)
    {
        // This will allocate a new sprite bitmap and copy it.  Why not
        // simply transfer 'psoShape' from the old sprite to the new?
        // Because it may be a device bitmap!

        vSpCreateShape(pSpriteNew,
                       &pSpriteOld->OffShape,
                       pSpriteOld->psoShape,
                       NULL,
                       &pSpriteOld->rclSrc,
                       pSpriteOld->ppalShape,
                       pSpriteOld->psoShape->iBitmapFormat,
                       TRUE);   // TRUE because by storing the sprite in
                                // system memory, we avoid the 'Both surfaces
                                // are unreadable and owned by different
                                // PDEVs" assert in vSpCreateShape

        pSpriteNew->dwShape       = pSpriteOld->dwShape;
        pSpriteNew->rclSrc        = pSpriteOld->rclSrc;
        pSpriteNew->iTransparent  = pSpriteOld->iTransparent;
        pSpriteNew->BlendFunction = pSpriteOld->BlendFunction;
    }

    // Transfer the cached attributes to the new sprite
    pSpriteNew->cachedAttributes  = pSpriteOld->cachedAttributes;
}

/******************************Public*Routine******************************\
* BOOL SpUpdatePosition
*
* NOTE: pSprite->psoShape may very well be NULL when entering this
*       function!
*
* NOTE: This function must never fail when hiding the sprite (because
*       that's used for cleanup and error handling)
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdatePosition(
SPRITE*         pSprite,
POINTL*         pptlDst,                        // May be NULL
BOOL            bLeaveBits = FALSE)
{
    GDIFunctionID(bSpUpdatePosition);

    BOOL            bStatus = TRUE;             // Assume success
    SPRITESTATE*    pState;
    ERECTL          rclSprite;
    RECTL*          prcl;
    ULONG           crcl;
    LONG            cxSprite;
    LONG            cySprite;
    SURFOBJ*        psoUnderlay;
    SURFOBJ*        psoShape;
    LONG            dx;
    LONG            dy;
    RECTL           rclExclude;
    POINTL          OffUnderlay;
    BOOL            bWantSystemMemory;
    RECTL           rclOldSprite;
    POINTL          lastDst;
    FLONG           flNewVisibility;
     
    pState = pSprite->pState;

    lastDst = pSprite->ptlDst;

    if (pptlDst == NULL)
    {
        rclSprite.bottom = LONG_MIN;
    }
    else
    {
        // Remember the original position for later.

        pSprite->ptlDst.x = pptlDst->x;
        pSprite->ptlDst.y = pptlDst->y;

        // Note that our handy 'bIntersect' routine will handle the
        // cases where 'pptlDst' is too big, causing these adds to
        // overflow.

        rclSprite.left   = pptlDst->x;
        rclSprite.top    = pptlDst->y;
        rclSprite.right  = pptlDst->x
                         + (pSprite->rclSrc.right - pSprite->rclSrc.left);
        rclSprite.bottom = pptlDst->y
                         + (pSprite->rclSrc.bottom - pSprite->rclSrc.top);
    }

    // Non-visible sprites have a sprite rectangle of (LONG_MIN, LONG_MIN,
    // LONG_MIN, LONG_MIN), which  is depended upon by
    // vSpComputeSpriteRanges:

    if ((pSprite->fl & (SPRITE_FLAG_CLIPPING_OBSCURED | SPRITE_FLAG_HIDDEN)) ||
        !bIntersect(&pState->rclScreen, &rclSprite, &rclSprite)
        )
    {
        rclSprite.left   = LONG_MIN;
        rclSprite.top    = LONG_MIN;
        rclSprite.right  = LONG_MIN;
        rclSprite.bottom = LONG_MIN;
        flNewVisibility    = 0;
    }
    else
    {
        flNewVisibility    = SPRITE_FLAG_VISIBLE;
    }

    // WINBUG #368282 05-12-2001 jasonha  Correctly maintain cVisible count
    //   If an invisible sprite was to be made visible, but the creation
    //   of the underlay failed, then it would be included in the cVisible
    //   count during the first bSpUpdatePosition call, but not removed
    //   during the recursive call to hide the sprite since
    //   pSprite->rclSprite would still be empty at all LONG_MIN's.
    //  SPRITE_FLAG_VISIBLE is used to represent inclusion in cVisible.

    // If the uncovered region has changed, handle the underlay buffer:

    if ((flNewVisibility  != (pSprite->fl & SPRITE_FLAG_VISIBLE)) ||
        (rclSprite.left   != pSprite->rclSprite.left  ) ||
        (rclSprite.top    != pSprite->rclSprite.top   ) ||
        (rclSprite.right  != pSprite->rclSprite.right ) ||
        (rclSprite.bottom != pSprite->rclSprite.bottom))
    {
        // If the old sprite was visible, decrement the visible sprite
        // count:

        if (pSprite->fl & SPRITE_FLAG_VISIBLE)
        {
            ASSERTGDI(pState->cVisible != 0, "Messed up cVisible count");
            pState->cVisible--;
            pSprite->fl &= ~SPRITE_FLAG_VISIBLE;
#if DEBUG_SPRITES
            {
                ASSERTGDI(pState->pListVisible != NULL, "Invalid visible sprite list: pState->pListVisible == NULL when removing sprite.\n");

                if (pState->cVisible == 0)
                {
                    ASSERTGDI(pState->pListVisible == pSprite, "Invalid visible sprite list: pState->pListVisible != pSprite when removing last sprite.\n");
                    ASSERTGDI(pSprite->pNextVisible == NULL, "Invalid visible sprite list: pSprite->pNextVisible != NULL when removing last sprite.\n");
                    pState->pListVisible = pSprite->pNextVisible;
                }
                else
                {
                    if (pState->pListVisible == pSprite)
                    {
                        pState->pListVisible = pSprite->pNextVisible;
                    }
                    else
                    {
                        SPRITE *pPrevSprite = pState->pListVisible;

                        while (pPrevSprite->pNextVisible != pSprite)
                        {
                            ASSERTGDI(pPrevSprite->pNextVisible != NULL, "Invalid visible sprite list: didn't find sprite in list.\n");
                            pPrevSprite = pPrevSprite->pNextVisible;
                        }

                        pPrevSprite->pNextVisible = pSprite->pNextVisible;
                    }

                    ASSERTGDI(pState->pListVisible != NULL, "Invalid visible sprite list: pState->pListVisible == NULL after removing non-last sprite.\n");

                    pSprite->pNextVisible = NULL;
                }
            }
#endif
        }

        // If we're shrinking this sprite in any dimension, redraw the newly
        // unobscured portions.  Be sure to watch for the failure case where
        // 'psoUnderlay' might not have been allocated:

        if ((pSprite->psoUnderlay) && (!bLeaveBits))
        {
            vSpRedrawUncoveredArea(pSprite, &rclSprite);
        }
        else if (bLeaveBits)
        {
            // Otherwise we should blit the sprite bits onto its position
            // which will have the effect of updating the underlay bits
            // for the overlapping sprites.  See bug #252464.

            CLIPOBJ* pco;
            ECLIPOBJ eco;

            if (pSprite->prgnClip)
            {
                eco.vSetup(pSprite->prgnClip, *((ERECTL *) &pSprite->rclSprite));
                pco = &eco;
            }
            else
            {
                pco = NULL;
            }

            // Disable direct driver access for the duration of the
            // SpCopyBits call so that we will be able to enumerate
            // the sprites (see ENUMUNDERLAYS constructor).

            ASSERTGDI(pState->bInsideDriverCall, "Expected sprite lock held");
            vSpDirectDriverAccess(pState, FALSE);

            if((!pco || (!eco.erclExclude().bEmpty())) &&
               (pSprite->psoShape))
            {
                // Let's not worry about setting up a color translation because
                // the format of the sprite and the screen should be the same
                // (only exception is for per pixel alpha sprites, but these
                // shouldn't be using the ULW_NOREPAINT flag).  However,
                // it won't hurt to check here anyway and if not true no big deal
                // if we don't update the underlay bits.

                if(pState->psoScreen->iBitmapFormat ==
                   pSprite->psoShape->iBitmapFormat)
                {
                    POINTL   pt;

                    // WINFIX #96696 bhouse 4-14-2000
                    // Use the correct source point, rclSprite may have been
                    // clipped.

                    pt.x = pSprite->rclSprite.left - lastDst.x;
                    pt.y = pSprite->rclSprite.top - lastDst.y;

                    SpCopyBits(pState->psoScreen,
                               pSprite->psoShape,
                               pco,
                               NULL,
                               &pSprite->rclSprite,
                               &pt);
                }
                else
                {
                    WARNING("bSpUpdatePosition: not updating underlay bits");
                }
            }

            // Restore direct driver access

            vSpDirectDriverAccess(pState, TRUE);
        }

        cxSprite = rclSprite.right - rclSprite.left;
        cySprite = rclSprite.bottom - rclSprite.top;

        if (cxSprite == 0)
        {
            // The sprite is not visible, which may have been caused by
            // disabling the sprite.  Check to see if there are no other
            // sprites on the screen, which would allow us to unhook the
            // DDI:

            if ((pState->cVisible == 0) && (pState->bHooked))
                vSpUnhook(pState);
        }
        else
        {
            ASSERTGDI(cySprite != 0, "If cxSprite is 0, expected cySprite is 0");

            // Since the new sprite is visible, increment the visible sprite
            // count:

            ASSERTGDI(!(pSprite->fl & SPRITE_FLAG_VISIBLE), "Invalid sprite visible state: making visible again.\n");
            pSprite->fl |= SPRITE_FLAG_VISIBLE;
            pState->cVisible++;
#if DEBUG_SPRITES
            {
                ASSERTGDI(pSprite->pNextVisible == NULL, "Invalid visible sprite list: pSprite->pNextVisible != NULL when adding to visible list.\n");

                if (pState->cVisible == 1)
                {
                    ASSERTGDI(pState->pListVisible == NULL, "Invalid visible sprite list: pState->pListVisible != NULL when adding first sprite.\n");
                }
                else
                {
                    ASSERTGDI(pState->pListVisible != NULL, "Invalid visible sprite list: pState->pListVisible == NULL when adding non-first sprite.\n");
                }

                pSprite->pNextVisible = pState->pListVisible;
                pState->pListVisible = pSprite;
            }
#endif

            // If the DDI isn't already hooked, do it now.  This has to
            // occur before we update the shape on the screen, because
            // it recalculates prgnUnlocked, which must be respected
            // whenever we write to the screen.

            if (!pState->bHooked)
                vSpHook(pState);

            // Check to see if the old underlay buffer will do.

            psoUnderlay = pSprite->psoUnderlay;
            if ((psoUnderlay == NULL)                   ||
                (cxSprite > psoUnderlay->sizlBitmap.cx) ||
                (cySprite > psoUnderlay->sizlBitmap.cy))
            {
                // There is no old underlay surface, or it's not large
                // enough, so allocate a new underlay structure.
                //
                // Note that we don't free the old underlay surface yet,
                // because we need it for the 'bSpBltFromScreen' we're
                // about to do!

            #if DEBUG_SPRITES

                if (psoUnderlay != NULL)
                    KdPrint(("Growing psoUnderlay: %p  Old: (%li, %li)  New: (%li, %li)\n",
                         psoUnderlay, psoUnderlay->sizlBitmap.cx, psoUnderlay->sizlBitmap.cy,
                         cxSprite, cySprite));

            #endif

                // Because alphablends require read-modify-write operations
                // on the destination, it's a horrible performance penalty
                // if we create the compositing surface in video memory and
                // the device doesn't support accelerated alpha.  Similarly,
                // we don't want to have the underlay surface in video memory
                // if the compositing surface is in system memory.  So check
                // here if alpha isn't accelerated, and simply create the
                // underlay in system memory.

                bWantSystemMemory = FALSE;
                if (pSprite->dwShape == ULW_ALPHA)
                {
                    PDEVOBJ po(pState->hdev);

                    if (pSprite->BlendFunction.AlphaFormat & AC_SRC_ALPHA)
                    {
                        if (!(po.flAccelerated() & ACCELERATED_PIXEL_ALPHA))
                        {
                            bWantSystemMemory = TRUE;
                        }
                    }
                    else
                    {
                        if (!(po.flAccelerated() & ACCELERATED_CONSTANT_ALPHA))
                        {
                            bWantSystemMemory = TRUE;
                        }
                    }
                }

                {
                    PDEVOBJ po(pState->hdev);
                    if (po.flGraphicsCaps() & GCAPS_LAYERED)
                        bWantSystemMemory = TRUE;
                }

                psoUnderlay = psoSpCreateSurface(
                                    pState,
                                    0,
                                    max(cxSprite, pSprite->sizlHint.cx),
                                    max(cySprite, pSprite->sizlHint.cy),
                                    bWantSystemMemory);
                if (!psoUnderlay)
                {
                    // Uh oh, we couldn't allocate the underlay buffer, so
                    // we won't be able to show the sprite.  We'll handle this
                    // by simply marking the sprite as invisible later on:

                    bStatus = FALSE;
                }
                else
                {
                    psoUnderlay->fjBitmap |= BMF_DONTCACHE;

                    // We have turned off BMF_SPRITE support (it appears to
                    // be unused)
                    // psoUnderlay->fjBitmap |= BMF_SPRITE;


                    OffUnderlay.x = -rclSprite.left;
                    OffUnderlay.y = -rclSprite.top;

                    // Get the bits underneath where the sprite will appear:

                    if (((cxSprite <= SMALL_SPRITE_DIMENSION) &&
                         (cySprite <= SMALL_SPRITE_DIMENSION)))
                    {
                        vSpSmallUnderlayCopy(pSprite,
                                             &OffUnderlay,
                                             psoUnderlay,
                                             &pSprite->OffUnderlay,
                                             pSprite->psoUnderlay,
                                             0,
                                             0,
                                             &rclSprite,
                                             &pSprite->rclSprite);
                   }
                    else
                    {
                        vSpBigUnderlayCopy(pState,
                                           &OffUnderlay,
                                           psoUnderlay,
                                           &rclSprite);
                    }

                    // Okay, we can now safely delete the old underlay:

                    vSpDeleteSurface(pSprite->psoUnderlay);
                    pSprite->psoUnderlay = psoUnderlay;
                    pSprite->OffUnderlay = OffUnderlay;

                    pSprite->rclUnderlay.left   = rclSprite.left;
                    pSprite->rclUnderlay.top    = rclSprite.top;
                    pSprite->rclUnderlay.right  = rclSprite.left
                                                + psoUnderlay->sizlBitmap.cx;
                    pSprite->rclUnderlay.bottom = rclSprite.top
                                                + psoUnderlay->sizlBitmap.cy;
                }
            }
            else
            {
                // Okay, we know the old underlay surface was already big
                // enough.  See if we have to read some bits from the screen
                // to update the underlay, either because the sprite moved
                // or because it got larger:

                if ((rclSprite.left   < pSprite->rclSprite.left  ) ||
                    (rclSprite.top    < pSprite->rclSprite.top   ) ||
                    (rclSprite.right  > pSprite->rclSprite.right ) ||
                    (rclSprite.bottom > pSprite->rclSprite.bottom))
                {
                    dx = 0;
                    dy = 0;

                    if (rclSprite.left < pSprite->rclUnderlay.left)
                        dx = rclSprite.left - pSprite->rclUnderlay.left;
                    else if (rclSprite.right > pSprite->rclUnderlay.right)
                        dx = rclSprite.right - pSprite->rclUnderlay.right;

                    if (rclSprite.top < pSprite->rclUnderlay.top)
                        dy = rclSprite.top - pSprite->rclUnderlay.top;
                    else if (rclSprite.bottom > pSprite->rclUnderlay.bottom)
                        dy = rclSprite.bottom - pSprite->rclUnderlay.bottom;

                    // Note that 'dx' and 'dy' may still both be zero.

                    pSprite->rclUnderlay.left   += dx;
                    pSprite->rclUnderlay.right  += dx;
                    pSprite->rclUnderlay.top    += dy;
                    pSprite->rclUnderlay.bottom += dy;

                    ASSERTGDI(
                        (pSprite->rclUnderlay.left   <= rclSprite.left) &&
                        (pSprite->rclUnderlay.top    <= rclSprite.top) &&
                        (pSprite->rclUnderlay.right  >= rclSprite.right) &&
                        (pSprite->rclUnderlay.bottom >= rclSprite.bottom),
                            "Improper rclUnderlay");

                    // I figure that on a move, the delta will typically be
                    // fairly small, so we'll always call 'vSpSmallUnderlayCopy'
                    // instead of 'bSpBltFromScreen' for this case.

                    pSprite->OffUnderlay.x = -pSprite->rclUnderlay.left;
                    pSprite->OffUnderlay.y = -pSprite->rclUnderlay.top;

                    vSpSmallUnderlayCopy(pSprite,
                                         &pSprite->OffUnderlay,
                                         pSprite->psoUnderlay,
                                         &pSprite->OffUnderlay,
                                         pSprite->psoUnderlay,
                                         dx,
                                         dy,
                                         &rclSprite,
                                         &pSprite->rclSprite);
                }
            }
        }

        if (bStatus)
        {
            rclOldSprite = pSprite->rclSprite;

            // Finally, update the sprite rectangle and mark the range cache
            // as being invalid.  Note that we do this only in the case when we
            // can display the sprite.

            pSprite->rclSprite = rclSprite;
            pState->bValidRange = FALSE;

            vSpOrderInY(pSprite);

            // If either a DirectDraw Lock is active, or there are any active
            // WNDOBJs, we have to do some more work to handle repercussions:

            if (gpto != NULL)
            {
                vSpCheckForWndobjOverlap(pState, &rclSprite, &rclOldSprite);
            }
        }
        else
        {
            // If we couldn't display the sprite, then hide it.  Note that
            // there's no chance that this will infinitely recurse.

            ASSERTGDI(pptlDst != NULL,
                      "bSpUpdatePosition: Must never fail a hide");
            bSpUpdatePosition(pSprite, NULL);
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* VOID vSpFreeClipResources
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpFreeClipResources(
SPRITE* pSprite)
{
    RGNOBJ ro(pSprite->prgnClip);
    ro.vDeleteRGNOBJ();
    pSprite->prgnClip = NULL;
}

/******************************Public*Routine******************************\
* BOOL bSpUpdateSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdateSprite(
SPRITE*         pSprite,
HDC             hdcDst,
POINTL*         pptlDst,
SIZEL*          psizl,
HDC             hdcSrc,
POINTL*         pptlSrc,
COLORREF        crKey,
BLENDFUNCTION*  pblend,
DWORD           dwShape,
RECTL*          prclDirty)
{
    BOOL            bStatus;
    SPRITESTATE*    pState;
    BLENDFUNCTION   blend;

    if (!pSprite)
    {
        return FALSE;
    }

    bStatus = FALSE;                     // Assume failure

    pState = pSprite->pState;

    PDEVOBJ po(pState->hdev);

    DEVLOCKOBJ dlo(po);
    SPRITELOCK slock(po);

    if (dwShape & ULW_NEW_ATTRIBUTES)
    {
        // Take out this instructions flag to avoid future confusion

        dwShape &= ~ULW_NEW_ATTRIBUTES;

        // Cache new attributes in the sprite

        pSprite->cachedAttributes.dwShape =  dwShape;
        pSprite->cachedAttributes.bf      =  *pblend;
        pSprite->cachedAttributes.crKey   =  (ULONG) crKey;

        // If sprite hasn't been created yet, don't proceed so that a black
        // sprite won't get painted on the screen.  This is the case where
        // we're called for the first time from _UpdateLayeredWindow, where
        // user chooses to not pass us hdcSrc yet.

        if (!hdcSrc)
        {
            return TRUE;
        }
    }
    else if (dwShape == ULW_DEFAULT_ATTRIBUTES)
    {
        // Retrieve arguments from cached values

        dwShape = pSprite->cachedAttributes.dwShape;
        crKey   = pSprite->cachedAttributes.crKey;
        blend   = pSprite->cachedAttributes.bf; // Better to point to a local
                                                // variable in case this gets
                                                // changed later.
        pblend  = &blend;
    }

    if ((hdcDst) || (psizl) || (hdcSrc) || (pptlSrc) || (crKey))
    {
        bStatus = bSpUpdateShape(pSprite, dwShape, hdcDst, hdcSrc,
                                 crKey, pblend, pptlSrc, psizl, prclDirty);
        if (bStatus)
        {
            // Use the last position we were given if no position was specified on
            // this call.

            bStatus &= bSpUpdatePosition(
                            pSprite,
                            (pptlDst != NULL) ? pptlDst : &pSprite->ptlDst);
        }
    }
    else if (((dwShape == ULW_ALPHA) || (dwShape == (ULW_ALPHA | ULW_COLORKEY))) &&
             (pblend != NULL) &&
             (pptlDst == NULL))
    {
        bStatus = bSpUpdateAlpha(pSprite, pblend, TRUE);
    }
    else if (((dwShape == 0) || (dwShape == ULW_NOREPAINT)) && (pblend == NULL))
    {
        // Note that pptlDst may be either NULL or non-NULL.

        bStatus = bSpUpdatePosition(pSprite, pptlDst, dwShape & ULW_NOREPAINT);
    }
    else
    {
        WARNING("bSpUpdateSprite: Unexpected argument");
    }

    // Finally, redraw the sprite:

    if (prclDirty)
    {
        // Only redraw the dirty rectangle

        ERECTL erclDirty(*prclDirty);
        erclDirty += pSprite->ptlDst; // Offset by origin of sprite window
                                      // because the rectangle needs to
                                      // be in screen coordinates
        erclDirty *= pSprite->rclSprite; // To be safe, intersect with sprite
                                         // rectangle

        if (!erclDirty.bEmpty())
        {
            // Only redraw if intersection is not empty

            vSpRedrawArea(pSprite->pState, (RECTL*) &erclDirty);
        }
    }
    else
    {
        // Must redraw the whole sprite

        vSpRedrawSprite(pSprite);

        // synchrnize on output surface to ensure frame is rendered

        if (!po.bDisabled())
        {
            po.vSync(po.pSurface()->pSurfobj(), NULL, 0);
        }
    }

    return(bStatus);
}

/******************************Public*Routine******************************\
* VOID vSpRenumberZOrder
*
* Renumbers the sprites according to z-order, after the z-order is changed.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpRenumberZOrder(
SPRITESTATE* pState)
{
    SPRITE* pSprite;
    ULONG   z = 0;

    // The sprite numbers are assigned starting at 0 with the back-most sprite:

    for (pSprite = pState->pListZ; pSprite != NULL; pSprite = pSprite->pNextZ)
    {
        pSprite->z = z++;
    }

}

/******************************Public*Routine******************************\
* VOID vSpDeleteSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDeleteSprite(
SPRITE* pSprite)
{
    SPRITESTATE*    pState;
    BOOL            bRet;
    SPRITE*         pTmp;
    SPRITE*         pNext;
    SPRITE*         pPrevious;

    if (pSprite == NULL)
        return;

    pState = pSprite->pState;

    PDEVOBJ po(pState->hdev);

    DEVLOCKOBJ dlo(po);
    SPRITELOCK slock(po);

    // Hide the sprite:

    bRet = bSpUpdatePosition(pSprite, NULL);

    ASSERTGDI(bRet, "vSpDeleteSprite: hide failed");

#if DEBUG_SPRITES
    vSpValidateVisibleSprites(pState);
#endif

    // Remove the sprite from the z-sorted linked list:

    if (pState->pListZ == pSprite)
    {
        pState->pListZ = pSprite->pNextZ;
    }
    else
    {
        for (pTmp = pState->pListZ; pTmp != NULL; pTmp = pTmp->pNextZ)
        {
            if (pTmp->pNextZ == pSprite)
            {
                pTmp->pNextZ = pSprite->pNextZ;
                break;
            }
        }
    }

    // Delete the sprite from the Y-sorted linked list:

    pPrevious = pSprite->pPreviousY;
    pNext = pSprite->pNextY;

    if (pNext)
        pNext->pPreviousY = pPrevious;

    if (pPrevious)
        pPrevious->pNextY = pNext;
    else
    {
        ASSERTGDI(pState->pListY == pSprite, "Expected top of list");
        pState->pListY = pNext;
    }

    // Free all allocated data associated with this sprite:

    vSpFreeClipResources(pSprite);
    vSpDeleteShape(pSprite);
    vSpDeleteSurface(pSprite->psoUnderlay);

    if (pSprite->psoMask != NULL)
    {
        bDeleteSurface(pSprite->psoMask->hsurf);
        pSprite->psoMask = NULL;
    }

    // Take this as an opportunity to free the compositing surface:

    vSpDeleteSurface(pState->psoComposite);
    pState->psoComposite = NULL;

    // We're all done with this object, so free the memory and
    // leave:

    VFREEMEM(pSprite);
}

/******************************Public*Routine******************************\
* SPRITE* pSpCreateSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SPRITE* pSpCreateSprite(
HDEV    hdev,
RECTL*  prcl,
HWND    hwnd,
POINTL* pptlDstInit=NULL)
{
    SPRITE* pSprite;
    SPRITE* pPrevious;
    SPRITE* pNext;
    SPRITE* pTarget;

    pSprite = NULL;         // Assume failure

    PDEVOBJ po(hdev);

    if (po.bDisplayPDEV())
    {
        DEVLOCKOBJ dlo(po);
        SPRITELOCK slock(po);

        SPRITESTATE* pState = po.pSpriteState();

        pSprite = (SPRITE*) PALLOCMEM(sizeof(SPRITE), ' psG');
        if (pSprite != NULL)
        {
            if (prcl != NULL)
            {
                pSprite->sizlHint.cx  = prcl->right - prcl->left;
                pSprite->sizlHint.cy  = prcl->bottom - prcl->top;
                pSprite->ptlDst.x     =
                    pptlDstInit ? pptlDstInit->x : prcl->left;
                pSprite->ptlDst.y     =
                    pptlDstInit ? pptlDstInit->y : prcl->top;
            }
            else
            {
                pSprite->sizlHint.cx  = 0;
                pSprite->sizlHint.cy  = 0;
                pSprite->ptlDst.x     = LONG_MIN;
                pSprite->ptlDst.y     = LONG_MIN;
            }

            pSprite->fl               = 0;
            pSprite->pState           = pState;
            pSprite->dwShape          = ULW_OPAQUE;
            pSprite->rclSprite.top    = LONG_MIN;
            pSprite->rclSprite.left   = LONG_MIN;
            pSprite->rclSprite.bottom = LONG_MIN;
            pSprite->rclSprite.right  = LONG_MIN;
#if DEBUG_SPRITES
            pSprite->pNextVisible     = NULL;
#endif

            // Add this sprite to the end of the z-list, meaning that
            // it will be top-most.  Well, top-most except for the
            // cursor sprites:

            pTarget = pState->pBottomCursor;
            
            if (pState->pListZ == pTarget)
            {
                pSprite->pNextZ = pTarget;
                pState->pListZ = pSprite;
            }
            else
            {
                for (pPrevious = pState->pListZ;
                     pPrevious->pNextZ != pTarget;
                     pPrevious = pPrevious->pNextZ)
                    ;

                pSprite->pNextZ = pTarget;
                pPrevious->pNextZ = pSprite;
            }

            vSpRenumberZOrder(pState);

            // Add this sprite to the front of the y-list.
            // pSprite->pPreviousY was already zero-initialized:

            pNext = pState->pListY;
            pState->pListY = pSprite;
            pSprite->pNextY = pNext;
            if (pNext)
                pNext->pPreviousY = pSprite;
            pSprite->hwnd = hwnd;

            vSpOrderInY(pSprite);
        }
    }

    return(pSprite);
}

/******************************Public*Routine******************************\
* BOOL bSpEnableSprites
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpEnableSprites(
HDEV hdev)
{
    SPRITESTATE*    pState;
    CLIPOBJ*        pco;
    SPRITESCAN*     pRange;
    SIZEL           sizl;
    HSURF           hsurf;
    SURFACE*        psurfScreen;
    SURFOBJ*        psoHitTest;

    PDEVOBJ po(hdev);
    if (!po.bDisplayPDEV())
        return(TRUE);

    psurfScreen = SURFOBJ_TO_SURFACE_NOT_NULL(po.pSurface()->pSurfobj());

    pState = po.pSpriteState();

    // Remember some information about the current mode:

    pState->hdev                = hdev;
    pState->psoScreen           = psurfScreen->pSurfobj();
    pState->iModeFormat         = psurfScreen->iFormat();
    pState->iOriginalType       = psurfScreen->iType();
    pState->flOriginalSurfFlags = psurfScreen->flags();

    pState->iSpriteType         = pState->iOriginalType;
    pState->flSpriteSurfFlags   = pState->flOriginalSurfFlags;

    XEPALOBJ pal(psurfScreen->ppal());
    pState->flModeMasks = pal.flRed() | pal.flBlu();

    // Initialize the screen size:

    pState->rclScreen.left   = 0;
    pState->rclScreen.right  = psurfScreen->sizl().cx;
    pState->rclScreen.top    = 0;
    pState->rclScreen.bottom = psurfScreen->sizl().cy;

    // Now allocate some regions that we'll use later:

    RGNMEMOBJ rmoUncovered;
    RGNMEMOBJ rmoTmp;
    RGNMEMOBJ rmoRectangular;

    if (rmoUncovered.bValid() && rmoTmp.bValid() && rmoRectangular.bValid())
    {
        pRange = (SPRITESCAN*) PALLOCMEM(sizeof(SPRITESCAN), 'rpsG');
        if (pRange)
        {
            // TRUE to denote that we want an STYPE_BITMAP surface, because
            // we have to be able to access the bits directly for hit testing:

            psoHitTest = psoSpCreateSurface(pState, 0, 1, 1, TRUE);
            if (psoHitTest)
            {
                // Mark the surface, so that it can be special-cased by
                // the dynamic mode change code:

                vSpSetNullRange(pState, pRange);

                pState->psoHitTest = psoHitTest;

                // We need a DC_RECT clip object:

                rmoRectangular.vSet(&pState->rclScreen);

                pState->prgnRectangular = rmoRectangular.prgnGet();
                pState->coRectangular.vSetup(rmoRectangular.prgnGet(),
                                             *((ERECTL*) &pState->rclScreen),
                                             CLIP_FORCE);

                pState->prgnUncovered  = rmoUncovered.prgnGet();
                pState->prgnUncovered->vStamp();
                pState->prgnTmp        = rmoTmp.prgnGet();
                pState->hrgn           = GreCreateRectRgn(0, 0, 0, 0);

                // Save some hook state:

                pState->pfnStrokePath        = PPFNDRV(po, StrokePath);
                pState->pfnFillPath          = PPFNDRV(po, FillPath);
                pState->pfnBitBlt            = PPFNDRV(po, BitBlt);
                pState->pfnCopyBits          = PPFNDRV(po, CopyBits);
                pState->pfnStretchBlt        = PPFNDRV(po, StretchBlt);
                pState->pfnTextOut           = PPFNDRV(po, TextOut);
                pState->pfnLineTo            = PPFNDRV(po, LineTo);
                pState->pfnTransparentBlt    = PPFNDRV(po, TransparentBlt);
                pState->pfnAlphaBlend        = PPFNDRV(po, AlphaBlend);
                pState->pfnPlgBlt            = PPFNDRV(po, PlgBlt);
                pState->pfnGradientFill      = PPFNDRV(po, GradientFill);
                pState->pfnStretchBltROP     = PPFNDRV(po, StretchBltROP);
                pState->pfnSaveScreenBits    = PPFNDRV(po, SaveScreenBits);
                pState->pfnDrawStream        = PPFNDRV(po, DrawStream);

                return(TRUE);
            }

            VFREEMEM(pRange);
        }
    }

    WARNING("bSpEnableSprites: Failed!");

    rmoUncovered.vDeleteRGNOBJ();
    rmoTmp.vDeleteRGNOBJ();
    rmoRectangular.vDeleteRGNOBJ();

    return(FALSE);
}

/******************************Public*Routine******************************\
* VOID vSpDisableSprites
*
* Called when the device's surface is about to be destroyed.
*
* Note: This function may be called without bDdEnableSprites having
*       first been called!
*
* Note that this may be called for printers and the like.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDisableSprites(
HDEV        hdev,
CLEANUPTYPE cutype)
{
    SPRITESTATE* pState;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();

    SPRITE* pSprite = pState->pBottomCursor;

    while(pSprite != NULL)
    {
        SPRITE* pNextSprite = pSprite->pNextZ;
        vSpDeleteSprite(pSprite);
        pSprite = pNextSprite;
    }

    pState->pTopCursor = NULL;
    pState->pBottomCursor = NULL;
    pState->ulNumCursors = 0;

    ASSERTGDI(pState->pListZ == NULL, "Expected to have 0 sprites");
    ASSERTGDI(pState->psoComposite == NULL, "Expected no composite surface");

    // During session cleanup (i.e., hydra shutdown), surfaces are
    // deleted as part of the HMGR object cleanup.  So we can skip
    // this for CLEANUP_SESSION:

    if (cutype != CLEANUP_SESSION)
    {
        vSpDeleteSurface(pState->psoHitTest);
    }

    // These regions, on the other hand, are not in the HMGR so
    // must be cleaned up always:

    RGNOBJ roUncovered(pState->prgnUncovered);
    RGNOBJ roTmp(pState->prgnTmp);
    RGNOBJ roRectangular(pState->prgnRectangular);

    roUncovered.vDeleteRGNOBJ();
    roTmp.vDeleteRGNOBJ();
    roRectangular.vDeleteRGNOBJ();

    // Since we are referencing this region by handle, it is safe
    // to do even during session cleanup:

    GreDeleteObject(pState->hrgn);

    if (pState->pRange)
    {
        VFREEMEM(pState->pRange);
    }

    if (pState->ahdevMultiMon)
    {
        EngFreeMem(pState->ahdevMultiMon);
    }

    if (pState->prgnUnlocked != NULL)
    {
        pState->prgnUnlocked->vDeleteREGION();
    }

    // Leave the sprite state in the PDEV in a newly initialized state:

    RtlZeroMemory(pState, sizeof(*pState));
}

/******************************Public*Routine******************************\
* VOID vSpEnableMultiMon
*
* This routine is called by the multi-mon code to let us know the children
* of a multi-mon meta PDEV.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpEnableMultiMon(
HDEV    hdev,
ULONG   c,
HDEV*   ahdev)          // Must be allocated by the caller and freed
{                       //   by calling vSpDisableMultiMon
    SPRITESTATE*    pState;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    pState->cMultiMon = c;
    pState->ahdevMultiMon = ahdev;
}

/******************************Public*Routine******************************\
* VOID vSpDisableMultiMon
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDisableMultiMon(
HDEV    hdev)
{
    SPRITESTATE*    pState;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    if (pState->ahdevMultiMon)
    {
        VFREEMEM(pState->ahdevMultiMon);
    }

    pState->cMultiMon = 0;
    pState->ahdevMultiMon = NULL;

    ASSERTGDI(pState->pListMeta == NULL, "Expected no meta-sprites");
}

/******************************Public*Routine******************************\
* VOID vSpHideSprites
*
* Hides or unhides all sprites on a PDEV and all of its child PDEVs.
*
*  1-Mar-2001 -by- Jason Hartman [jasonha]
* Wrote it.
\**************************************************************************/

VOID
vSpHideSprites(
    HDEV hdev,
    BOOL bHide
    )
{
    GDIFunctionID(vSpHideSprites);

    PDEVOBJ     po(hdev);
    SPRITELOCK  slock(po);
    SPRITESTATE* pState;

    pState = po.pSpriteState();

    if (pState->cMultiMon)
    {
        ULONG   i;

        for (i = 0; i < pState->cMultiMon; i++)
        {
            vSpHideSprites(pState->ahdevMultiMon[i], bHide);
        }
    }
    else
    {
        SPRITE* pSprite = pState->pListZ;

        while (pSprite != NULL)
        {
            SPRITE* pNextSprite = pSprite->pNextZ;

            if (bHide)
            {
                ASSERTGDI((pSprite->fl & SPRITE_FLAG_HIDDEN) == 0, "Sprite is already hidden.");

                pSprite->fl |= SPRITE_FLAG_HIDDEN;
            }
            else
            {
                ASSERTGDI((pSprite->fl & SPRITE_FLAG_HIDDEN) != 0, "Sprite is not hidden.");

                pSprite->fl &= ~SPRITE_FLAG_HIDDEN;
            }

            bSpUpdatePosition(pSprite, &pSprite->ptlDst);

            pSprite = pNextSprite;
        }

    }

    if (bHide)
    {
        ASSERTGDI(pState->cVisible == 0, "Sprites remain visible after we hid them all.");
        ASSERTGDI(!pState->bHooked, "Sprite layer remains hooked after we hid all sprites.");
    }
}

/******************************Public*Routine******************************\
* SPRITE* pSpTransferSprite
*
* Transfers a sprite to a new PDEV by creating a new sprite that copies
* the contents of the old, and then deleting the old sprite.
*
* NOTE: pSpriteOld is freed by this function, so it must not be accessed
*       after calling!
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

SPRITE* pSpTransferSprite(
HDEV    hdevNew,
SPRITE* pSpriteOld)
{
    SPRITE* pSpriteNew;
    POINTL  ptlZero;

    pSpriteNew = NULL;

    if (pSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpTransferSprite:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        pSpriteNew = pSpCreateSprite(hdevNew,
                                     NULL,
                                     pSpriteOld->hwnd);
        if (pSpriteNew)
        {
            vSpTransferShape(pSpriteNew, pSpriteOld);
            if (!bSpUpdatePosition(pSpriteNew,
                                   &pSpriteOld->ptlDst))
            {
                vSpDeleteSprite(pSpriteNew);
                pSpriteNew = NULL;
            }
            else
            {
                // If this sprite is a part of Meta Sprite,
                // update Meta Sprite, too.

                if (pSpriteOld->pMetaSprite != NULL)
                {
                    METASPRITE *pMetaSprite = pSpriteOld->pMetaSprite;
                    BOOL bSpriteInMeta = FALSE;

                    for (ULONG i = 0; i < pMetaSprite->chSprite; i++)
                    {
                        if (pMetaSprite->apSprite[i] == pSpriteOld)
                        {
                            pMetaSprite->apSprite[i] = pSpriteNew;
                            pSpriteNew->pMetaSprite = pMetaSprite;

                            if (bSpriteInMeta)
                            {
                                WARNING("pSpTransferSprite: Sprite in meta multiple times!");
                            }
                            bSpriteInMeta = TRUE;
                        }
                    }

                    if (!bSpriteInMeta)
                    {
                        WARNING("pSpTransferSprite: No sprite in meta!");
                    }
                }
            }
        }
    }

    // If new sprite could not be created, the metasprite is still pointing
    // to the old sprite which we are about to delete.

    if (!pSpriteNew && (pSpriteOld->pMetaSprite != NULL))
    {
        METASPRITE *pMetaSprite = pSpriteOld->pMetaSprite;

        // Mark the meta sprite for deletion.  This is because the call to
        // UserRemoveRedirectionBitmap will unset the layered flag on the
        // window and so user will not attempt to delete the sprite in the
        // futue (i.e. if we don't do this we will leak memory).  The actual
        // deletion will happen in pSpTransferMetaSprite.

        pMetaSprite->fl |= SPRITE_FLAG_NO_WINDOW;

        for (ULONG i = 0; i < pMetaSprite->chSprite; i++)
        {
            if (pMetaSprite->apSprite[i] == pSpriteOld)
            {
                pMetaSprite->apSprite[i] = NULL;
            }
        }
    }

    vSpDeleteSprite(pSpriteOld);

    return(pSpriteNew);
}

/******************************Public*Routine******************************\
* VOID vSpCorrectHdevReferences
*
* On a dynamic mode change, sprite state is transferred between the two
* PDEVs along with the rest of the driver state.  As such, we have to
* go back through and correct any references to the old HDEV.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpCorrectHdevReferences(
SPRITESTATE*    pState,
HDEV            hdev)
{
    SPRITE*     pSprite;

    pState->hdev = hdev;

    // Note that any surfaces created by psoSpCreateSurface are tagged
    // as sprite surfaces, and left alone by bDynamicModeChange, so that
    // we can handle them here.

    if (pState->psoComposite != NULL)
        pState->psoComposite->hdev = hdev;

    if (pState->psoHitTest != NULL)
        pState->psoHitTest->hdev = hdev;

    for (pSprite = pState->pListZ;
         pSprite != NULL;
         pSprite = pSprite->pNextZ)
    {
        pSprite->pState = pState;

        if (pSprite->psoShape != NULL)
        {
            ASSERTGDI(pSprite->psoShape->hdev != 0,
                "Didn't expect NULL shape hdev");

            pSprite->psoShape->hdev = hdev;
        }
        if (pSprite->psoUnderlay != NULL)
        {
            ASSERTGDI(pSprite->psoUnderlay->hdev != 0,
                "Didn't expect NULL shape hdev");

            pSprite->psoUnderlay->hdev = hdev;
        }
    }
}

/******************************Public*Routine******************************\
* METASPRITE* pSpConvertSpriteToMeta
*
* On a dynamic mode change, sprite state is transferred between the meta-PDEV
* and device PDEV along with the rest of the driver state.  As such, we have
* to convert "sprite" to "meta sprite" when 1 monitor to multi-monitors mode
* change
*
*  2-Jul-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

METASPRITE* pSpConvertSpriteToMeta(
HDEV    hdevMetaNew,
HDEV    hdevDevOld,
SPRITE* pSpriteOld)
{
    METASPRITE  *pMetaSpriteNew;
    SPRITE      *pSpriteNew;
    SPRITESTATE *pState;
    BOOL         bError = FALSE;

    pMetaSpriteNew = NULL;

    if (pSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpConvertSpriteToMeta:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        PDEVOBJ poMeta(hdevMetaNew);

        // When running multi-mon, handle the creation of the meta sprite:

        pState = poMeta.pSpriteState();

        if (pState->cMultiMon)
        {
            // Create MetaSprites and 'real' sprites for children.

            ULONG cjAlloc = sizeof(METASPRITE)
                          + pState->cMultiMon
                          * sizeof(pMetaSpriteNew->apSprite[0]);

            pMetaSpriteNew = (METASPRITE*) PALLOCNOZ(cjAlloc, 'mpsG');
            if (pMetaSpriteNew)
            {
                for (ULONG i = 0; i < pState->cMultiMon; i++)
                {
                    PDEVOBJ    poDevice(pState->ahdevMultiMon[i]);
                    SPRITELOCK slock(poDevice);

                    pSpriteNew = pSpCreateSprite(poDevice.hdev(),
                                                 NULL,
                                                 pSpriteOld->hwnd);
                    if (pSpriteNew)
                    {
                        POINTL ptlDst;

                        PDEVOBJ poDevOld(hdevDevOld);

                        // Transfer the information from old sprite
                        // to new sprite.

                        vSpTransferShape(pSpriteNew, pSpriteOld);

                        // The sprite position need to be adjusted based on
                        // poDevice origin, since we switch to multi-monitor
                        // system, and then poDevice origion might not be equal
                        // poDevOld.

                        // poDevOld coordinate to meta coordinate

                        ptlDst.x =
                            pSpriteOld->ptlDst.x + poDevOld.pptlOrigin()->x;
                        ptlDst.y =
                            pSpriteOld->ptlDst.y + poDevOld.pptlOrigin()->y;

                        // meta coordinate to poDevice coordinate

                        ptlDst.x -= poDevice.pptlOrigin()->x;
                        ptlDst.y -= poDevice.pptlOrigin()->y;

                        if (bSpUpdatePosition(pSpriteNew, &ptlDst))
                        {
                            pMetaSpriteNew->apSprite[i] = pSpriteNew;
                            pSpriteNew->pMetaSprite     = pMetaSpriteNew;
                        }
                        else
                        {
                            vSpDeleteSprite(pSpriteNew);
                            bError = TRUE;
                            break;
                        }
                    }
                    else
                    {
                        bError = TRUE;
                        break;
                    }
                }

                if (bError)
                {
                    for (; i > 0; i--)
                    {
                        vSpDeleteSprite(pMetaSpriteNew->apSprite[i - 1]);
                    }

                    VFREEMEM(pMetaSpriteNew);
                    // Set this to NULL so we don't write on it later.
                    // This fixes the logic below
                    pMetaSpriteNew = NULL;
                }
                else
                {
                    pMetaSpriteNew->hwnd     = pSpriteOld->hwnd;
                    pMetaSpriteNew->chSprite = pState->cMultiMon;
                    pMetaSpriteNew->fl       = 0;

                    // Add this node to the head of the meta-sprite list:

                    pMetaSpriteNew->pNext    = pState->pListMeta;
                    pState->pListMeta        = pMetaSpriteNew;
                }
            }
        }
        else
        {
            WARNING("pSpConvertSpriteToMeta(): cMultiMon is 0\n");
        }
    }

    // Delete old sprite

    vSpDeleteSprite(pSpriteOld);

    return(pMetaSpriteNew);
}

/******************************Public*Routine******************************\
* SPRITE* pSpConvertSpriteFromMeta
*
* On a dynamic mode change, sprite state is transferred between the meta-PDEV
* and device PDEV along with the rest of the driver state.  As such, we have
* to convert "meta sprite" to "sprite" when multi-monitors to 1 monitor mode
* change
*
*  2-Jul-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

SPRITE* pSpConvertSpriteFromMeta(
HDEV        hdevDevNew,
HDEV        hdevMetaOld,
METASPRITE* pMetaSpriteOld)
{
    SPRITE*      pSpriteNew;
    SPRITE*      pSpriteOld;
    SPRITESTATE *pStateMeta;
    ULONG        i;

    PDEVOBJ poMeta(hdevMetaOld);

    pSpriteNew = NULL;

    pStateMeta = poMeta.pSpriteState();

    if (pMetaSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpConvertSpriteFromMeta:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        pSpriteOld = NULL;

        // Find a the sprite lives in PDEV which has highest color
        // depth, remember this for transfering shape for new
        // sprite.

        ULONG iDitherHighest = 0;

        for (i = 0; i < pMetaSpriteOld->chSprite; i++)
        {
            SPRITE* pSpriteTmp = pMetaSpriteOld->apSprite[i];

            if (pSpriteTmp)
            {
                PDEVOBJ poTmp(pSpriteTmp->pState->hdev);

                if (iDitherHighest < poTmp.iDitherFormat())
                {
                    pSpriteOld = pSpriteTmp;
                    iDitherHighest = poTmp.iDitherFormat();
                }
            }
        }

        // Convert sprite on old hdev to new hdev.

        if (pSpriteOld)
        {
            pSpriteNew = pSpCreateSprite(hdevDevNew,
                                         NULL,
                                         pMetaSpriteOld->hwnd);
            if (pSpriteNew)
            {
                vSpTransferShape(pSpriteNew, pSpriteOld);

                // The sprite position needs to be adjusted based on
                // origin of the old PDEV

                PDEVOBJ poOld(pSpriteOld->pState->hdev);
                EPOINTL ptlSpritePos = pSpriteOld->ptlDst;
                ptlSpritePos += *(poOld.pptlOrigin());

                if (!bSpUpdatePosition(pSpriteNew,
                                       &ptlSpritePos))
                {
                    vSpDeleteSprite(pSpriteNew);
                    pSpriteNew = NULL;
                }
            }
        }
    }

    // Delete old sprites on meta sprite.

    for (i = 0; i < pMetaSpriteOld->chSprite; i++)
    {
        vSpDeleteSprite(pMetaSpriteOld->apSprite[i]);
    }

    // Remove this meta sprite from the linked list :

    if (pStateMeta->pListMeta == pMetaSpriteOld)
    {
        pStateMeta->pListMeta = pMetaSpriteOld->pNext;
    }
    else
    {
        for (METASPRITE *pTmp = pStateMeta->pListMeta;
                         pTmp->pNext != pMetaSpriteOld;
                         pTmp = pTmp->pNext)
            ;

        pTmp->pNext = pMetaSpriteOld->pNext;
    }

    // Delete meta sprite.

    VFREEMEM(pMetaSpriteOld);

    return(pSpriteNew);
}

/******************************Public*Routine******************************\
* METASPRITE* pSpMoveSpriteFromMeta
*
*  1-Sep-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

SPRITE* pSpMoveSpriteFromMeta(
HDEV        hdevDevNew,
HDEV        hdevMetaOld,
METASPRITE* pMetaSpriteOld,
ULONG       ulIndex)
{
    ULONG        i;
    SPRITE*      pSpriteOrg;
    SPRITE*      pSpriteNew = NULL;
    SPRITESTATE* pStateMeta;

    PDEVOBJ poDev(hdevDevNew);
    PDEVOBJ poMeta(hdevMetaOld);

    pStateMeta = poMeta.pSpriteState();

    // Pick up the sprite we may reuse.

    pSpriteOrg = pMetaSpriteOld->apSprite[ulIndex];

    if (pSpriteOrg)
    {
        // Make sure the sprite belonging to device specific HDEV,
        // actually under DDI. the sprite already lives this DHPDEV.

        ASSERTGDI(pSpriteOrg->pState == poDev.pSpriteState(),
                  "ERROR: pState does not points device PDEV");

        // And this sprite no longer has meta sprite, the meta sprite
        // will be deleted in below.

        pSpriteOrg->pMetaSprite = NULL;
    }

    if (pMetaSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpMoveSpriteFromMeta:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        pSpriteNew = pSpriteOrg;
    }

    // Delete old sprites on meta sprite.

    for (i = 0; i < pMetaSpriteOld->chSprite; i++)
    {
        if ((i != ulIndex) || (pSpriteNew == NULL))
        {
            vSpDeleteSprite(pMetaSpriteOld->apSprite[i]);
        }
    }

    // Remove this meta sprite from the linked list :

    if (pStateMeta->pListMeta == pMetaSpriteOld)
    {
        pStateMeta->pListMeta = pMetaSpriteOld->pNext;
    }
    else
    {
        for (METASPRITE *pTmp = pStateMeta->pListMeta;
                         pTmp->pNext != pMetaSpriteOld;
                         pTmp = pTmp->pNext)
            ;

        pTmp->pNext = pMetaSpriteOld->pNext;
    }

    // Delete meta sprite.

    VFREEMEM(pMetaSpriteOld);

    return(pSpriteNew);
}

/******************************Public*Routine******************************\
* METASPRITE* pSpTransferMetaSprite
*
*  30-Aug-1998 -by- Hideyuki Nagase [hideyukn]
* Wrote it.
\**************************************************************************/

METASPRITE* pSpTransferMetaSprite(
HDEV        hdevNew,
HDEV        hdevOld,
METASPRITE* pMetaSpriteOld)
{
    SPRITESTATE* pStateNew;
    SPRITESTATE* pStateOld;
    METASPRITE*  pMetaSpriteNew;
    SPRITE*      pSprite;
    ULONG        i, j;
    BOOL         bError = FALSE;

    PDEVOBJ poNew(hdevNew);
    PDEVOBJ poOld(hdevOld);

    pStateNew = poNew.pSpriteState();
    pStateOld = poOld.pSpriteState();

    if (pMetaSpriteOld->hwnd == NULL)
    {
        // There shouldn't be any non-hwnd associated sprites at this point.

        ASSERTGDI(FALSE,
                  "pSpTransferMetaSprite:  pSpriteOld is not hwnd associated!");
    }
    else
    {
        // Create METASPRITE on new hdev.

        ULONG cjAlloc = sizeof(METASPRITE)
                      + pStateNew->cMultiMon
                      * sizeof(pMetaSpriteNew->apSprite[0]);

        if (pMetaSpriteOld->fl & SPRITE_FLAG_NO_WINDOW)
        {
            // If the metasprite is marked for deletion, don't reallocate a new
            // metasprite.  The cleanup code below will make sure the old
            // metasprite and its child sprites are deleted.

            pMetaSpriteNew = NULL;
        }
        else
        {
            pMetaSpriteNew = (METASPRITE*) PALLOCMEM(cjAlloc, 'mpsG');
        }

        if (pMetaSpriteNew)
        {
            SPRITE *pSpriteBest = NULL;
            HDEV    hdevBest = NULL;
            ULONG   iFormatBest = 0;

            // Transfer sprite from old meta to new as much as possible.

            for (i = 0 ; i < pStateNew->cMultiMon ; i++)
            {
                for (j = 0; j < pMetaSpriteOld->chSprite ; j++)
                {
                    pSprite = pMetaSpriteOld->apSprite[j];

                    if (pSprite)
                    {
                        PDEVOBJ poTmp(pSprite->pState->hdev);

                        // if pointer to pState is same, we can transfer
                        // to new pdev.

                        if (pStateNew == pSprite->pState)
                        {
                            // move this sprite to new meta sprite from old.

                            pMetaSpriteNew->apSprite[i] = pSprite;
                            pMetaSpriteOld->apSprite[j] = NULL;

                            pSprite->pMetaSprite = pMetaSpriteNew;
                        }

                        // if the sprite lives in PDEV which has higher color
                        // depth, remember this for transfering shape for new
                        // sprite

                        if (iFormatBest < poTmp.iDitherFormat())
                        {
                            pSpriteBest = pSprite;
                            hdevBest    = poTmp.hdev();
                            iFormatBest = poTmp.iDitherFormat();
                        }
                    }
                }
            }

            // fill up other meta sprite fields

            pMetaSpriteNew->hwnd     = pMetaSpriteOld->hwnd;
            pMetaSpriteNew->chSprite = pStateNew->cMultiMon;
            pMetaSpriteNew->fl       = 0;

            // if there is any sprite which can not be trasnferred from old,
            // create them

            for (i = 0 ; i < pMetaSpriteNew->chSprite ; i++)
            {
                if (pMetaSpriteNew->apSprite[i] == NULL)
                {
                    PDEVOBJ poDevice(pStateNew->ahdevMultiMon[i]);
                    SPRITELOCK slockDevice(poDevice);

                    pSprite= pSpCreateSprite(poDevice.hdev(),
                                             NULL,
                                             pMetaSpriteOld->hwnd);

                    if (pSprite)
                    {
                        PDEVOBJ poBestHdev(hdevBest);
                        SPRITELOCK slockBest(poBestHdev);
                        POINTL  ptlDst;

                        // copy sprite shape from best existing sprite.

                        vSpTransferShape(pSprite, pSpriteBest);

                        // The sprite position need to be adjusted based on
                        // poDevice origin. need to convert from hdevBest
                        // coordinate.

                        // poBestHdev coordinate to meta coordinate

                        ptlDst.x =
                            pSpriteBest->ptlDst.x + poBestHdev.pptlOrigin()->x;
                        ptlDst.y =
                            pSpriteBest->ptlDst.y + poBestHdev.pptlOrigin()->y;

                        // meta coordinate to poDevice coordinate

                        ptlDst.x -= poDevice.pptlOrigin()->x;
                        ptlDst.y -= poDevice.pptlOrigin()->y;

                        if (bSpUpdatePosition(pSprite, &ptlDst))
                        {
                            // Put the sprite into meta sprite.

                            pMetaSpriteNew->apSprite[i] = pSprite;
                            pSprite->pMetaSprite = pMetaSpriteNew;
                        }
                        else
                        {
                            vSpDeleteSprite(pSprite);
                            bError = TRUE;
                        }
                    }
                    else
                    {
                        bError = TRUE;
                    }
                }

                if (bError)
                {
                    // if there is any error, stop looping, no more creation.

                    break;
                }
            }

            if (!bError)
            {
                // Add this node to the head of the meta-sprite list:

                pMetaSpriteNew->pNext    = pStateNew->pListMeta;
                pStateNew->pListMeta     = pMetaSpriteNew;
            }
        }
    }

    // check any sprite left in old meta, if so delete them.

    for (i = 0; i < pMetaSpriteOld->chSprite ; i++)
    {
        if (pMetaSpriteOld->apSprite[i] != NULL)
        {
            vSpDeleteSprite(pMetaSpriteOld->apSprite[i]);
        }
    }

    // Remove old meta sprite from the linked list :

    if (pStateOld->pListMeta == pMetaSpriteOld)
    {
        pStateOld->pListMeta = pMetaSpriteOld->pNext;
    }
    else
    {
        for (METASPRITE *pTmp = pStateOld->pListMeta;
                         pTmp->pNext != pMetaSpriteOld;
                         pTmp = pTmp->pNext)
            ;

        pTmp->pNext = pMetaSpriteOld->pNext;
    }

    if (bError)
    {
        // Delete new meta sprite.

        for (i = 0; i < pMetaSpriteNew->chSprite ; i++)
        {
            if (pMetaSpriteNew->apSprite[i] != NULL)
            {
                vSpDeleteSprite(pMetaSpriteNew->apSprite[i]);
            }
        }

        VFREEMEM(pMetaSpriteNew);

        pMetaSpriteNew = NULL;
    }

    // Delete meta sprite.

    VFREEMEM(pMetaSpriteOld);

    return(pMetaSpriteNew);
}


/******************************Public*Routine******************************\
* VOID vSpDynamicModeChange
*
* This function transfers all layered-window sprites from one PDEV to the
* other.
*
* Note that it transfers only layered-window sprites.  Sprites that don't
* have an associated hwnd are left with the old PDEV.
*
*   2-Jul-1998 -by- Hideyuki Nagase [hideyukn]
* DDML (meta) mode change support.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDynamicModeChange(
HDEV    hdevA,
HDEV    hdevB)
{
    SPRITESTATE     StateTmp;
    SPRITESTATE*    pStateA;
    SPRITESTATE*    pStateB;
    ULONG           ulTmp;
    SPRITE*         pSprite;
    SPRITE*         pSpriteNext;
    SPRITE*         pSpriteNew;
    METASPRITE*     pMetaSprite;
    METASPRITE*     pMetaSpriteNew;
    METASPRITE*     pMetaSpriteNext;
    UINT            i, j;

    PDEVOBJ poA(hdevA);
    PDEVOBJ poB(hdevB);

    // Sprite state, being 'below the DDI level', is device specific.
    // As such, it is tranferred along with the rest of the device
    // specific state on the dynamic mode change.
    //
    // Do that now:

    pStateA = poA.pSpriteState();
    pStateB = poB.pSpriteState();

    StateTmp = *pStateA;
    *pStateA = *pStateB;
    *pStateB = StateTmp;

    // Swap back the drag-rect width:

    ulTmp = pStateA->ulDragDimension;
    pStateA->ulDragDimension = pStateB->ulDragDimension;
    pStateB->ulDragDimension = ulTmp;

    // Now find any 'hdev' references and correct them:

    vSpCorrectHdevReferences(pStateA, hdevA);
    vSpCorrectHdevReferences(pStateB, hdevB);

    // Now that we've transferred the state, grab the locks:

    SPRITELOCK slockA(poA);
    SPRITELOCK slockB(poB);

    pSprite = pStateA->pBottomCursor;

    while(pSprite != NULL)
    {
        SPRITE* pNextSprite = pSprite->pNextZ;
        vSpDeleteSprite(pSprite);
        pSprite = pNextSprite;
    }

    pStateA->pTopCursor = NULL;
    pStateA->pBottomCursor = NULL;
    pStateA->ulNumCursors = 0;
    
    pSprite = pStateB->pBottomCursor;

    while(pSprite != NULL)
    {
        SPRITE* pNextSprite = pSprite->pNextZ;
        vSpDeleteSprite(pSprite);
        pSprite = pNextSprite;
    }

    pStateB->pTopCursor = NULL;
    pStateB->pBottomCursor = NULL;
    pStateB->ulNumCursors = 0;
    
    // But the sprites themselves logically stay with the old PDEV
    // and shouldn't be transferred in the first place.  So
    // now that we've transferred the broad state, we have to go
    // back through and individually transfer every sprites back
    // to their original PDEV, accounting for the new display
    // format at the same time.

    if (poA.bMetaDriver() && poB.bMetaDriver())
    {
        // Exchange all Meta sprites between meta PDEVs.

        pMetaSprite = pStateA->pListMeta;
        while (pMetaSprite != NULL)
        {
            // Grab the 'next' pointer while we can, because we're about
            // to delete 'pMetaSprite'!

            pMetaSpriteNext = pMetaSprite->pNext;

            pMetaSpriteNew = pSpTransferMetaSprite(hdevB, hdevA, pMetaSprite);
            if (pMetaSpriteNew != NULL)
            {
                // Mark the new sprites in 'B's list as being just
                // of transferring:

                pMetaSpriteNew->fl |= SPRITE_FLAG_JUST_TRANSFERRED;
            }

            pMetaSprite = pMetaSpriteNext;
        }

        // Transfer all the sprites that now live in 'B' back to 'A',
        // skipping the ones we just transferred:

        pMetaSprite = pStateB->pListMeta;
        while (pMetaSprite != NULL)
        {
            // Grab the 'next' pointer while we can, because we're about
            // to delete 'pMetaSprite'!

            pMetaSpriteNext = pMetaSprite->pNext;

            // The 'just-transferred' flag is so that we don't transfer
            // back to A sprites we just transferred to B:

            if (!(pMetaSprite->fl & SPRITE_FLAG_JUST_TRANSFERRED))
            {
                pMetaSpriteNew = pSpTransferMetaSprite(hdevA, hdevB, pMetaSprite);
            }
            else
            {
                pMetaSprite->fl &= ~SPRITE_FLAG_JUST_TRANSFERRED;
            }

            pMetaSprite = pMetaSpriteNext;
        }
    }
    else if (!poA.bMetaDriver() && !poB.bMetaDriver())
    {
        pSprite = pStateA->pListZ;
        while (pSprite != NULL)
        {
            // Grab the 'next' pointer while we can, because we're about
            // to delete 'pSprite'!

            pSpriteNext = pSprite->pNextZ;

            pSpriteNew = pSpTransferSprite(hdevB, pSprite);
            if (pSpriteNew != NULL)
            {
                // Mark the new sprites in 'B's list as being just
                // of transferring:

                pSpriteNew->fl |= SPRITE_FLAG_JUST_TRANSFERRED;
            }

            pSprite = pSpriteNext;
        }

        // Transfer all the sprites that now live in 'B' back to 'A',
        // skipping the ones we just transferred:

        pSprite = pStateB->pListZ;
        while (pSprite != NULL)
        {
            // Grab the 'next' pointer while we can, because we're about
            // to delete 'pSprite'!

            pSpriteNext = pSprite->pNextZ;

            // The 'just-transferred' flag is so that we don't transfer
            // back to A sprites we just transferred to B:

            if (!(pSprite->fl & SPRITE_FLAG_JUST_TRANSFERRED))
            {
                pSpriteNew = pSpTransferSprite(hdevA, pSprite);
            }
            else
            {
                pSprite->fl &= ~SPRITE_FLAG_JUST_TRANSFERRED;
            }

            pSprite = pSpriteNext;
        }
    }
    else
    {
        PDEVOBJ poMeta(poA.bMetaDriver() ? hdevA : hdevB);
        PDEVOBJ poDev(poA.bMetaDriver()  ? hdevB : hdevA);

        SPRITESTATE* pStateMeta = poMeta.pSpriteState();
        SPRITESTATE* pStateDev  = poDev.pSpriteState();

        BOOL bModeChgBtwnChildAndParent = FALSE;

        for (ULONG iIndex = 0; iIndex < pStateMeta->cMultiMon; iIndex++)
        {
            // Find poMeta.hdev() (= originally this hdev *WAS* child device)

            if (pStateMeta->ahdevMultiMon[iIndex] == poMeta.hdev())
            {
                bModeChgBtwnChildAndParent = TRUE;

                // Put a device PDEV.

                pStateMeta->ahdevMultiMon[iIndex] = poDev.hdev();
                break;
            }
        }

        if (bModeChgBtwnChildAndParent)
        {
            // This must be only happened when 2 to 1 mode change occured.

            ASSERTGDI(poA.hdev() == poDev.hdev(),"hdevA must be device PDEV");
            ASSERTGDI(poB.hdev() == poMeta.hdev(),"hdevB must be meta PDEV");

            // Only scan meta sprite to delete meta sprite and delete it's
            // child sprites which we will not use anymore.

            pMetaSprite = pStateMeta->pListMeta;
            while (pMetaSprite != NULL)
            {
                // Grab the 'next' pointer while we can, because we're about
                // to delete 'pMetaSprite'!

                pMetaSpriteNext = pMetaSprite->pNext;

                // Get sprite from MetaSprite.

                pSpMoveSpriteFromMeta(poDev.hdev(), poMeta.hdev(),
                                     pMetaSprite, iIndex);

                pMetaSprite = pMetaSpriteNext;
            }
        }
        else
        {
            // First, convert sprites in poDev to meta sprites into poMeta

            pSprite = pStateDev->pListZ;
            while (pSprite != NULL)
            {
                // Grab the 'next' pointer while we can, because we're about
                // to delete 'pSprite'!

                pSpriteNext = pSprite->pNextZ;

                // Convert to meta sprite. "pSprite" in parameter, will be
                // deleted inside pSpConvertSpriteToMeta().

                pMetaSpriteNew = pSpConvertSpriteToMeta(poMeta.hdev(),
                                                        poDev.hdev(),
                                                        pSprite);

                if (pMetaSpriteNew != NULL)
                {
                    // Mark the new sprites in 'B's list as being just
                    // of transferring:

                    pMetaSpriteNew->fl |= SPRITE_FLAG_JUST_TRANSFERRED;
                }

                pSprite = pSpriteNext;
            }

            // Second, convert sprites in poMeta to regular sprites into poDev.

            pMetaSprite = pStateMeta->pListMeta;
            while (pMetaSprite != NULL)
            {
                // Grab the 'next' pointer while we can, because we're about
                // to delete 'pMetaSprite'!

                pMetaSpriteNext = pMetaSprite->pNext;

                // The 'just-transferred' flag is so that we don't convert
                // back to regular sprites we just converted to meta.

                if (!(pMetaSprite->fl & SPRITE_FLAG_JUST_TRANSFERRED))
                {
                    // Convert from meta sprite. "pMetaSprite" in parameter, will
                    // be deleted inside pSpConvertSpriteFromMeta().

                    pSpriteNew = pSpConvertSpriteFromMeta(poDev.hdev(),
                                                          poMeta.hdev(),
                                                          pMetaSprite);
                }
                else
                {
                    pMetaSprite->fl &= ~SPRITE_FLAG_JUST_TRANSFERRED;
                }

                pMetaSprite = pMetaSpriteNext;
            }
        }
    }
}

/***************************************************************************\
* pSpGetSprite
*
* Returns the pointer to the associated sprite, given either a sprite
* handle or a window handle.
*
*  8-Oct-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\***************************************************************************/

SPRITE* pSpGetSprite(
SPRITESTATE*    pState,
HWND            hwnd,
HANDLE          hSprite = NULL)
{
    SPRITE* pSprite;

    pSprite = (SPRITE*) hSprite;
    if ((pSprite == NULL) && (hwnd != NULL))
    {
        for (pSprite = pState->pListZ;
             pSprite != NULL;
             pSprite = pSprite->pNextZ)
        {
            if (pSprite->hwnd == hwnd)
                break;
        }
    }

    return(pSprite);
}

/***************************************************************************\
* pSpGetMetaSprite
*
* Returns the pointer to the associated meta-sprite, given either a
* meta-sprite handle or a window handle.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

METASPRITE* pSpGetMetaSprite(
SPRITESTATE*    pState,
HWND            hwnd,
HANDLE          hSprite = NULL)
{
    METASPRITE* pMetaSprite;

    ASSERTGDI((hwnd != NULL) || (hSprite != NULL),
        "Expected a non-NULL handle");

    pMetaSprite = (METASPRITE*) hSprite;
    if ((pMetaSprite == NULL) && (hwnd != NULL))
    {
        for (pMetaSprite = pState->pListMeta;
             pMetaSprite != NULL;
             pMetaSprite = pMetaSprite->pNext)
        {
            if (pMetaSprite->hwnd == hwnd)
                break;
        }
    }

    return(pMetaSprite);
}

/***************************************************************************\
* VOID vSpZorderSprite
*
* Re-arranges the sprite z-order, which goes from bottom-most to top-most.
*
*  8-Oct-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\***************************************************************************/

VOID vSpZorderSprite(
HDEV    hdev,
SPRITE* pSprite,                // May be NULL
SPRITE* pSpriteInsertAfter)     // May be NULL to make sprite bottom-most
{
    SPRITESTATE*    pState;
    SPRITE*         pTmp;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();

    DEVLOCKOBJ dlo(po);
    SPRITELOCK slock(po);

    pTmp = pState->pListZ;
    if ((pSprite == NULL) || (pTmp == NULL))
    {
        return;
    }

    // First, unlink pSprite from the list.  Setting pSprite->pNextZ
    // to NULL is mostly for debug purposes.

    if (pTmp == pSprite)
    {
        pState->pListZ = pTmp->pNextZ;
        pTmp->pNextZ = NULL;
    }
    else
    {
        SPRITE* pSpritePrev;

        do {

            if (pTmp == pSprite)
            {
                pSpritePrev->pNextZ = pTmp->pNextZ;
                pTmp->pNextZ = NULL;
                break;
            }

            pSpritePrev = pTmp;
            pTmp = pTmp->pNextZ;

        } while (pTmp != NULL);
    }

    // This would be bad, we probably didn't find it in the list:

    if (pSprite->pNextZ != NULL)
    {
        WARNING("vSpZorderSprite: sprite not unlinked!");
        return;
    }

    if (pSpriteInsertAfter == NULL)
    {
        // Insert pSprite as the bottom-most one, i.e. first in the list:

        pSprite->pNextZ = pState->pListZ;
        pState->pListZ = pSprite;
    }
    else
    {
        pSprite->pNextZ = pSpriteInsertAfter->pNextZ;
        pSpriteInsertAfter->pNextZ = pSprite;
    }

    vSpRenumberZOrder(pState);

    pState->bValidRange = FALSE;

    vSpRedrawSprite(pSprite);
}

/***************************************************************************\
* BOOL bSpPtInSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

BOOL bSpPtInSprite(
SPRITE* pSprite,
int     x,
int     y)
{
    BOOL            bRet = FALSE;           // Assume failure
    SPRITESTATE*    pState;
    SURFOBJ*        psoHitTest;
    POINTL          OffHitTest;
    RECTL           rclPoint;
    ULONG*          pulPixel;
    FLONG           flModeMasks;

    if (!pSprite)
    {
        return FALSE;
    }

    pState = pSprite->pState;

    PDEVOBJ po(pState->hdev);

    DEVLOCKOBJ dlo(po);                     // Needed to access 'pState'
    SPRITELOCK slock(po);

    psoHitTest = pState->psoHitTest;

    rclPoint.left   = x;
    rclPoint.top    = y;
    rclPoint.right  = x + 1;
    rclPoint.bottom = y + 1;

    // Compute the mode masks.  Hit surface has same format as the screen.

    XEPALOBJ palHitTest(
        SURFOBJ_TO_SURFACE_NOT_NULL(pSprite->pState->psoScreen)->ppal());

    if (palHitTest.bIsBitfields())
    {
        // Bug 280033: Make sure we only check to see if bits contained in
        // one of bitfields below have been modified.  If we don't do this,
        // then we would get the wrong answer in some cases, such as 16bpp
        // at 5-5-5 where the alphablend code would zero out the 16th bit,
        // which doesn't mean that the sprite is visible because the value
        // of that bit is undefined in this particular color resolution.

        flModeMasks = palHitTest.flRed() |
                      palHitTest.flGre() |
                      palHitTest.flBlu();
    }
    else
    {
        // Doesn't matter what we put here because bits that don't belong to
        // the color won't be modified by the alphablend code.

        flModeMasks = 0xffffffff;
    }


    // First, see if the point intersects the sprite's bounds.
    // If not, we're done.

    if (bIntersect(&pSprite->rclSprite, &rclPoint))
    {
        OffHitTest.x = -x;
        OffHitTest.y = -y;

        pulPixel = (ULONG*) psoHitTest->pvScan0;

        ASSERTGDI(psoHitTest->iType == STYPE_BITMAP,
            "Hit-test surface must be STYPE_BITMAP!");

        // Okay, now let's narrow it down.  To deal with
        // alpha, transparency, and funky transforms, we
        // accomplish the hit testing by setting a pixel to
        // a specific value, asking the sprite to redraw that
        // pixel, and then checking to see if the value
        // changed.
        //
        // We actually don't have to do this for rectangular,
        // non-rotated opaque sprites...

        *pulPixel = 0L;
        vSpComposite(pSprite, &OffHitTest, psoHitTest, &rclPoint);
        if (((*pulPixel) & flModeMasks) != 0)
        {
            bRet = TRUE;
        }
        else
        {
            // Unfortunately, the sprite may have chosen to draw in
            // the colour that we used to do the check.  So to make
            // sure, try again using a different colour:

            *pulPixel = ~0L;
            vSpComposite(pSprite, &OffHitTest, psoHitTest, &rclPoint);

            bRet = (((*pulPixel) & flModeMasks) != flModeMasks);
        }
    }

    return(bRet);
}

/***************************************************************************\
* VOID vSpUpdateSpriteVisRgn
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

VOID vSpUpdateSpriteVisRgn(
HDEV    hdev)
{
    SPRITESTATE*    pState;
    SPRITE*         pSprite;
    POINTL          Offset;
    BOOL            bMore;
    BOOL            bEqual;
    REGION*         prgnOld;
    REGION*         prgnNew;
    CLIPENUMRECT    ClipOld;
    CLIPENUMRECT    ClipNew;
    BOOL            bOldMore;
    BOOL            bNewMore;
    ULONG           i;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    pSprite = pState->pListZ;
    if (pSprite == NULL)
        return;

    for (pSprite = pState->pListZ;
         pSprite != NULL;
         pSprite = pSprite->pNextZ)
    {
        if (pSprite->hwnd != NULL)
        {
            UserVisrgnFromHwnd(&pState->hrgn, pSprite->hwnd);

            RGNMEMOBJ rmoNew;
            RGNOBJAPI roClip(pState->hrgn, FALSE);

            if (!roClip.bValid() || !rmoNew.bValid() || !rmoNew.bCopy(roClip))
            {
                rmoNew.vDeleteRGNOBJ();
            }
            else
            {
                // Adjust for this device's multi-mon offset:

                Offset.x = -po.pptlOrigin()->x;
                Offset.y = -po.pptlOrigin()->y;

                rmoNew.bOffset(&Offset);

                // Assume that the two regions will be equal:

                bEqual = TRUE;

                // Now check to see if the two clip regions really are equal:

                prgnNew = rmoNew.prgnGet();
                prgnOld = pSprite->prgnClip;

                if (prgnOld == NULL)
                {
                    // There was no old region.  Let's assume the new one
                    // doesn't have trivial clipping:

                    bEqual = FALSE;
                }
                else
                {
                    ECLIPOBJ ecoOld;
                    ECLIPOBJ ecoNew;
                    ERECTL   erclUnclipped;

                    // If the sprite was not visible due to clipping,
                    // bSpUpdatePosition leaves 'rclSprite' as empty.
                    // Consequently, we can't use 'rclSprite' to determine
                    // the clip object complexity.  Re-derive the
                    // unclipped sprite bounds:

                    erclUnclipped.left   = pSprite->ptlDst.x;
                    erclUnclipped.top    = pSprite->ptlDst.y;
                    erclUnclipped.right  = erclUnclipped.left
                        + (pSprite->rclSrc.right - pSprite->rclSrc.left);
                    erclUnclipped.bottom = erclUnclipped.top
                        + (pSprite->rclSrc.bottom - pSprite->rclSrc.top);

                    ecoOld.vSetup(prgnOld, erclUnclipped);
                    ecoNew.vSetup(prgnNew, erclUnclipped);

                    if (ecoOld.erclExclude().bEmpty() ^
                        ecoNew.erclExclude().bEmpty())
                    {
                        // One or the other (but not both) are empty, so are
                        // unequal:

                        bEqual = FALSE;
                    }
                    else if ((ecoOld.iDComplexity == DC_TRIVIAL) &&
                             (ecoNew.iDComplexity == DC_TRIVIAL))
                    {
                        // Both are trivially clipped, so are equal.
                    }
                    else if (ecoOld.iDComplexity != ecoNew.iDComplexity)
                    {
                        // The clipping complexity is different, so the regions are
                        // unequal:

                        bEqual = FALSE;
                    }
                    else
                    {
                        // Okay, we've got work to do.  We want to see if the
                        // regions are any different where it intersects with the
                        // sprite.  We do this by constructing and enumerating
                        // corresponding clip objects:

                        ecoOld.cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);
                        ecoNew.cEnumStart(FALSE, CT_RECTANGLES, CD_ANY, 100);

                        bOldMore = TRUE;
                        bNewMore = TRUE;

                        do {
                            ClipOld.c = 0;
                            ClipNew.c = 0;

                            if (bOldMore)
                                bOldMore = ecoOld.bEnum(sizeof(ClipOld), &ClipOld);
                            if (bNewMore)
                                bNewMore = ecoNew.bEnum(sizeof(ClipNew), &ClipNew);

                            if (ClipOld.c != ClipNew.c)
                            {
                                bEqual = FALSE;
                                break;
                            }

                            for (i = 0; i < ClipOld.c; i++)
                            {
                                if ((ClipNew.arcl[i].left
                                        != ClipOld.arcl[i].left)  ||
                                    (ClipNew.arcl[i].top
                                        != ClipOld.arcl[i].top)   ||
                                    (ClipNew.arcl[i].right
                                        != ClipOld.arcl[i].right) ||
                                    (ClipNew.arcl[i].bottom
                                        != ClipOld.arcl[i].bottom))
                                {
                                    bEqual   = FALSE;
                                    bOldMore = FALSE;
                                    bNewMore = FALSE;
                                    break;
                                }
                            }
                        } while (bOldMore || bNewMore);
                    }
                }

                // Free the old region (if any) and set the new one:

                vSpFreeClipResources(pSprite);
                pSprite->prgnClip = prgnNew;
                pSprite->prgnClip->vStamp();

                // Grab some locks we need for drawing.

                PDEVOBJ po(pState->hdev);

                DEVLOCKOBJ dlo(po);
                SPRITELOCK slock(po);

                // We detect the case when the sprite has an empty VisRgn
                // primarily for DirectDraw, so that we can unhook sprites
                // and get out of its way when it goes full-screen.
                //
                // Note that we have to do this obscured check even if 'bEqual'
                // is true because 'bEqual' applies only to the intersection
                // with the current sprite rectangle, and the obscuring flag is
                // independent of the sprite size or location.

                pSprite->fl &= ~SPRITE_FLAG_CLIPPING_OBSCURED;
                if (rmoNew.bInside(&pState->rclScreen) != REGION_RECT_INTERSECT)
                    pSprite->fl |= SPRITE_FLAG_CLIPPING_OBSCURED;

                bSpUpdatePosition(pSprite, &pSprite->ptlDst);

                if (gpto != NULL)
                {
                    vSpCheckForWndobjOverlap(pState,
                                             &pSprite->rclSprite,
                                             &pSprite->rclSprite);
                }

                // Only if the regions, intersected with the sprite, are unequal
                // do we do the repaint.  We do this because we get called
                // constantly when any window is moving, even if none of the
                // movement intersects with the sprite.

                if (!bEqual)
                {
                    // Note that we could go further and just redraw the
                    // difference in the regions.  At this point, I can't
                    // be bothered.  We'll redraw the whole thing.

                    vSpRedrawSprite(pSprite);
                }
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
// Window Manager callable functions
/////////////////////////////////////////////////////////////////////////////

/***************************************************************************\
* BOOL GreCreateSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

HANDLE GreCreateSprite(
HDEV    hdev,
HWND    hwnd,
RECT*   prc)
{
    SPRITESTATE*    pState;
    METASPRITE*     pMetaSprite;
    SPRITE*         pSprite;
    ULONG           cjAlloc;
    ULONG           i;
    HANDLE          pRet = NULL;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();

    // When running multi-mon, handle the creation of the meta sprite:

    if (pState->cMultiMon)
    {
        cjAlloc = sizeof(METASPRITE)
                + pState->cMultiMon * sizeof(pMetaSprite->apSprite[0]);

        pMetaSprite = (METASPRITE*) PALLOCNOZ(cjAlloc, 'mpsG');
        if (pMetaSprite)
        {
            for (i = 0; i < pState->cMultiMon; i++)
            {
                PDEVOBJ poMon(pState->ahdevMultiMon[i]);

                POINTL *pptlDstInit = NULL;
                POINTL ptlDstInit;

                if (prc)
                {
                    ptlDstInit.x = prc->left - poMon.pptlOrigin()->x;
                    ptlDstInit.y = prc->top  - poMon.pptlOrigin()->y;
                    pptlDstInit = &ptlDstInit;
                }

                pSprite = pSpCreateSprite(pState->ahdevMultiMon[i],
                                          (RECTL*) prc,
                                          hwnd,
                                          pptlDstInit);
                if (pSprite == NULL)
                {
                    for (; i > 0; i--)
                    {
                        vSpDeleteSprite(pMetaSprite->apSprite[i - 1]);
                    }

                    VFREEMEM(pMetaSprite);
                    return(pRet);
                }

                pMetaSprite->apSprite[i] = pSprite;
                pSprite->pMetaSprite = pMetaSprite;
            }

            pMetaSprite->hwnd     = hwnd;
            pMetaSprite->chSprite = pState->cMultiMon;
            pMetaSprite->fl       = 0;

            // Add this node to the head of the meta-sprite list:

            pMetaSprite->pNext = pState->pListMeta;
            pState->pListMeta  = pMetaSprite;

            pRet = pMetaSprite;
        }
    }
    else
    {
        // Note that USER doesn't actually need the pointer to the sprite
        // since it uses pSpGetSprite to reference the sprite.

        pRet = pSpCreateSprite(hdev, (RECTL*) prc, hwnd);
    }

    return(pRet);
}

/***************************************************************************\
* BOOL GreDeleteSprite
*
*  8-Oct-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\***************************************************************************/

BOOL GreDeleteSprite(
HDEV    hdev,
HWND    hwnd,
HANDLE  hSprite)
{
    SPRITESTATE*    pState;
    METASPRITE*     pMetaSprite;
    METASPRITE*     pTmp;
    SPRITE*         pSprite;
    ULONG           i;
    BOOL            bRet = FALSE;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();
    if (pState->cMultiMon)
    {
        pMetaSprite = pSpGetMetaSprite(pState, hwnd, hSprite);
        if (pMetaSprite)
        {
            for (i = 0; i < pState->cMultiMon; i++)
            {
                vSpDeleteSprite(pMetaSprite->apSprite[i]);
            }

            // Remove this sprite from the linked list:

            if (pState->pListMeta == pMetaSprite)
            {
                pState->pListMeta = pMetaSprite->pNext;
            }
            else
            {
                for (pTmp = pState->pListMeta;
                     pTmp->pNext != pMetaSprite;
                     pTmp = pTmp->pNext)
                    ;

                pTmp->pNext = pMetaSprite->pNext;
            }

            VFREEMEM(pMetaSprite);

            bRet = TRUE;
        }
    }
    else
    {
        pSprite = pSpGetSprite(pState, hwnd, hSprite);
        if (pSprite)
        {
            vSpDeleteSprite(pSprite);
            bRet = TRUE;
        }
    }

    return(bRet);
}

/***************************************************************************\
* BOOL GreGetSpriteAttributes
*
*  14-Mar-2000 -by- Jeff Stall [jstall]
* Wrote it.
\***************************************************************************/

BOOL GreGetSpriteAttributes(
HDEV            hdev,
HWND            hwnd,
HANDLE          hSprite,
COLORREF*       lpcrKey,
BLENDFUNCTION*  pblend,
DWORD*          pdwFlags)
{
    SPRITESTATE*    pState;
    SPRITE*         pSprite = NULL;
    BOOL            bRet = FALSE;
    PDEVOBJ po(hdev);

    ASSERTGDI(lpcrKey != NULL, "Ensure valid pointer");
    ASSERTGDI(pblend != NULL, "Ensure valid pointer");
    ASSERTGDI(pdwFlags != NULL, "Ensure valid pointer");

    //
    // Get the sprite object.
    //

    pState = po.pSpriteState();
    if (pState->cMultiMon)
    {
        //
        // On a multimon system, query the values from the first sprite.
        //

        METASPRITE * pMetaSprite = pSpGetMetaSprite(pState, hwnd, hSprite);
        if (pMetaSprite != NULL)
        {
            pSprite = pMetaSprite->apSprite[0];
            ASSERTGDI(pSprite != NULL, "Sprite should exist");
        }
    }
    else
    {
        pSprite = pSpGetSprite(pState, hwnd, hSprite);
    }


    //
    // Query the data from the sprite.
    //

    if (pSprite != NULL)
    {
        bRet = TRUE;

        *lpcrKey = pSprite->cachedAttributes.crKey;
        *pblend = pSprite->cachedAttributes.bf;
        *pdwFlags = pSprite->cachedAttributes.dwShape;
    }

    return(bRet);
}


/***************************************************************************\
* BOOL GreUpdateSprite
*
*  8-Oct-1997 -by- Vadim Gorokhovsky [vadimg]
* Wrote it.
\***************************************************************************/

BOOL GreUpdateSprite(
HDEV            hdev,
HWND            hwnd,
HANDLE          hSprite,
HDC             hdcDst,
POINT*          pptDst,
SIZE*           psize,
HDC             hdcSrc,
POINT*          pptSrc,
COLORREF        crKey,
BLENDFUNCTION*  pblend,
DWORD           dwShape,
RECT*           prcDirty)
{
    SPRITESTATE*    pState;
    METASPRITE*     pMetaSprite;
    SPRITE*         pSprite;
    ULONG           i;
    POINTL*         pptlDstTmp;
    POINTL          ptlDstTmp;
    BOOL            bRet = FALSE;
    ERECTL          erclDirty;

    if (prcDirty)
    {
        // Let's make sure we don't modify the caller memory pointed to by
        // prcldirty

        erclDirty = *((ERECTL *) prcDirty);
        prcDirty = (RECT *) &erclDirty;
    }

    PDEVOBJ po(hdev);

    if (po.bDisabled())
        return bRet;

    pState = po.pSpriteState();
    if (pState->cMultiMon)
    {
        pMetaSprite = pSpGetMetaSprite(pState, hwnd, hSprite);
        if (pMetaSprite)
        {
            bRet = TRUE; // This allows us to record single monitor
                         // failures by ANDing bRet with the return
                         // value from bSpUpdateSprite

            for (i = 0; i < pState->cMultiMon; i++)
            {
                PDEVOBJ po(pState->ahdevMultiMon[i]);

                pptlDstTmp = NULL;
                if (pptDst != NULL)
                {
                    ptlDstTmp.x = pptDst->x - po.pptlOrigin()->x;
                    ptlDstTmp.y = pptDst->y - po.pptlOrigin()->y;
                    pptlDstTmp = &ptlDstTmp;
                }

                bRet &= bSpUpdateSprite(pMetaSprite->apSprite[i],
                                        hdcDst,
                                        pptlDstTmp,
                                        psize,
                                        hdcSrc,
                                        (POINTL*) pptSrc,
                                        crKey,
                                        pblend,
                                        dwShape,
                                        (RECTL*)prcDirty);
            }
        }
    }
    else
    {
        pSprite = pSpGetSprite(pState, hwnd, hSprite);
        if (pSprite)
        {
            bRet = bSpUpdateSprite(pSprite,
                                   hdcDst,
                                   (POINTL*) pptDst,
                                   psize,
                                   hdcSrc,
                                   (POINTL*) pptSrc,
                                   crKey,
                                   pblend,
                                   dwShape,
                                   (RECTL*) prcDirty);
        }
    }

    return(bRet);
}

/***************************************************************************\
* BOOL GrePtInSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

BOOL APIENTRY GrePtInSprite(
HDEV    hdev,
HWND    hwnd,
int     x,
int     y)
{
    SPRITESTATE*    pState;
    METASPRITE*     pMetaSprite;
    SPRITE*         pSprite;
    ULONG           i;
    BOOL            bRet = FALSE;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();
    if (pState->cMultiMon)
    {
        pMetaSprite = pSpGetMetaSprite(pState, hwnd);
        if (pMetaSprite)
        {
            for (i = 0; i < pState->cMultiMon; i++)
            {
                PDEVOBJ po(pState->ahdevMultiMon[i]);

                if (bSpPtInSprite(pMetaSprite->apSprite[i],
                                  x - po.pptlOrigin()->x,
                                  y - po.pptlOrigin()->y))
                {
                    bRet = TRUE;
                    break;
                }
            }
        }
    }
    else
    {
        pSprite = pSpGetSprite(pState, hwnd);
        if (pSprite)
        {
            bRet = bSpPtInSprite(pSprite, x, y);
        }
    }

    return(bRet);
}

/***************************************************************************\
* BOOL GreUpdateSpriteVisRgn
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

VOID APIENTRY GreUpdateSpriteVisRgn(
HDEV    hdev)
{
    ULONG           i;
    SPRITESTATE*    pState;
    BOOL            bRet = TRUE;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    if (pState->cMultiMon)
    {
        for (i = 0; i < pState->cMultiMon; i++)
        {
            vSpUpdateSpriteVisRgn(pState->ahdevMultiMon[i]);
        }
    }
    else
    {
        vSpUpdateSpriteVisRgn(pState->hdev);
    }
}

/***************************************************************************\
* BOOL GreZorderSprite
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

VOID APIENTRY GreZorderSprite(
HDEV    hdev,
HWND    hwnd,
HWND    hwndInsertAfter)
{
    SPRITESTATE*    pState;
    ULONG           i;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    if (pState->cMultiMon)
    {
        for (i = 0; i < pState->cMultiMon; i++)
        {
            HDEV hdevSingle = pState->ahdevMultiMon[i];
            PDEVOBJ poSingle(hdevSingle);
            SPRITESTATE *pSpriteStateSingle = poSingle.pSpriteState();

            vSpZorderSprite(hdevSingle,
                            pSpGetSprite(pSpriteStateSingle, hwnd),
                            pSpGetSprite(pSpriteStateSingle, hwndInsertAfter));
        }
    }
    else
    {
        vSpZorderSprite(pState->hdev,
                        pSpGetSprite(pState, hwnd),
                        pSpGetSprite(pState, hwndInsertAfter));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Software Cursors
/////////////////////////////////////////////////////////////////////////////

/******************************Public*Routine******************************\
* BOOL SpUpdateCursor
*
* Updates the shape for a cursor.
*
* Returns FALSE if the function fails, and sets both 'pSprite->psoMask'
* and 'pSprite->psoShape' to NULL.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpUpdateCursor(
SPRITE*         pSprite,
SURFOBJ*        psoMono,
SURFOBJ*        psoColor,
XLATEOBJ*       pxlo,
RECTL*          prclBounds)         // Defines the parts of 'psoMono' and
                                    //   'psoColor' to be used
{
    BOOL            bRet = FALSE;   // Assume failure
    SPRITESTATE*    pState;
    RECTL           rclSrc;
    SURFOBJ*        psoMask;
    DEVBITMAPINFO   dbmi;
    SURFMEM         SurfDimo;

    pState = pSprite->pState;

    PDEVOBJ po(pState->hdev);

    // Initialize some state for the sprite:

    pSprite->rclSrc = *prclBounds;

    if (psoMono == NULL)
    {
        // Handle the alpha cursor case:

        ASSERTGDI((psoColor != NULL) &&  (psoColor->iBitmapFormat == BMF_32BPP),
            "Expected BGRA surface");
        ASSERTGDI((prclBounds->right  <= (psoColor->sizlBitmap.cx)) &&
                  (prclBounds->bottom <= (psoColor->sizlBitmap.cy)),
            "Bounds out of bounds");

        // Mark this as an 'alpha' sprite:

        pSprite->dwShape                           = ULW_ALPHA;
        pSprite->BlendFunction.AlphaFormat         = AC_SRC_ALPHA;
        pSprite->BlendFunction.BlendOp             = AC_SRC_OVER;
        pSprite->BlendFunction.BlendFlags          = 0;
        pSprite->BlendFunction.SourceConstantAlpha = 0xff;

        vSpCreateShape(pSprite,
                       &gptlZero,
                       psoColor,
                       NULL,
                       prclBounds,
                       gppalRGB,
                       BMF_32BPP,
                       TRUE);    // Allocate from system memory because the
                                 // Alpha Blending will most likely be done by
                                 // the CPU, and it's expensive to transfer the
                                 // cursor bitmap across the bus every time

        bRet = (pSprite->psoShape != NULL);
    }
    else
    {
        // Handle the non-alpha cursor case:

        ASSERTGDI((prclBounds->right  <= (psoMono->sizlBitmap.cx)) &&
                  (prclBounds->bottom <= (psoMono->sizlBitmap.cy >> 1)),
            "Bounds out of bounds");

        psoMask = pSprite->psoMask;
        if (psoMask != NULL)
        {
            // If the new mask is different sized than the old cached mask,
            // free up the old cached mask:

            if ((psoMask->sizlBitmap.cx != psoMono->sizlBitmap.cx) ||
                (psoMask->sizlBitmap.cy != psoMono->sizlBitmap.cy))
            {
                bDeleteSurface(psoMask->hsurf);
                psoMask = NULL;
            }
        }

        // Create a surface to hold a copy of the mask:

        if (psoMask == NULL)
        {
            dbmi.iFormat  = BMF_1BPP;
            dbmi.cxBitmap = psoMono->sizlBitmap.cx;
            dbmi.cyBitmap = psoMono->sizlBitmap.cy;
            dbmi.fl       = BMF_TOPDOWN;
            dbmi.hpal     = NULL;

            if (SurfDimo.bCreateDIB(&dbmi, NULL))
            {
                psoMask = SurfDimo.pSurfobj();
                SurfDimo.vKeepIt();
                SurfDimo.vSetPID(OBJECT_OWNER_PUBLIC);
            }
        }

        // Copy the mask:

        pSprite->psoMask = psoMask;
        if (psoMask != NULL)
        {
            // Use the given bounds for the copy, adjusting 'bottom' so that
            // we can copy both the 'AND' parts and the 'OR' parts in one blt:

            rclSrc = *prclBounds;
            rclSrc.bottom += (psoMask->sizlBitmap.cy >> 1);

            EngCopyBits(psoMask, psoMono, NULL, NULL, &rclSrc, (POINTL*) &rclSrc);
        }

        // Now account for the color surface, if there is one:

        if (psoColor == NULL)
        {
            vSpDeleteShape(pSprite);

            bRet = TRUE;
        }
        else
        {
            vSpCreateShape(pSprite,
                           &gptlZero,
                           psoColor,
                           pxlo,
                           prclBounds,
                           po.ppalSurf(),
                           0,
                           FALSE);    // Allocate from video memory if
                                      // possible, because the blit can be
                                      // done entirely on the video card, and
                                      // it's faster when the cursor bitmap is
                                      // already there.

            bRet = (pSprite->psoShape != NULL);
        }

        // Finally, mark this as a non-alpha 'cursor' sprite, and update some of
        // the sprite fields that would normally be updated by vSpCreateShape:

        pSprite->dwShape     = ULW_CURSOR;
        pSprite->flModeMasks = pState->flModeMasks;
        pSprite->iModeFormat = pState->iModeFormat;
    }

    return(bRet);
}

/***************************************************************************\
* ULONG EngMovePointer
*
* Move the engine managed pointer on the device.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

VOID EngMovePointer(
SURFOBJ*    pso,
LONG        x,
LONG        y,
RECTL*      prcl)       // Ignored
{
    GDIFunctionID(EngMovePointer);

    SPRITESTATE*    pState;
    SPRITE*         pSprite;
    POINTL          ptlDst;

    PDEVOBJ po(pso->hdev);

    pState = po.pSpriteState();

    if (pState->pTopCursor != NULL)
    {
        SPRITELOCK slock(po);

        if(pState->pBottomCursor != pState->pTopCursor)
        {
            // rotate cursors if enough time has past

            ULONG tickCount = NtGetTickCount();
            ULONG elapsedTicks = tickCount - pState->ulTrailTimeStamp;

            if(elapsedTicks >= pState->ulTrailPeriod)
            {
                // trial maintenance time ... either spawn off a new trail cursor
                // or hide the oldest

                // find the first trail cursor (cursor before top)

                pSprite = pState->pBottomCursor;
                while(pSprite->pNextZ != pState->pTopCursor) pSprite = pSprite->pNextZ;

                // if it does not coincide with top cursor then spawn off another

                if(pSprite->rclSprite.left != pState->pTopCursor->rclSprite.left ||
                   pSprite->rclSprite.top != pState->pTopCursor->rclSprite.top)
                {
                    // hide the bottom most cursor

                    pSprite = pState->pBottomCursor;
        
                    bSpUpdatePosition(pSprite, NULL);
                    // rotate hidden cursor to front most
                    pState->pBottomCursor = pSprite->pNextZ;
        
                    // Reorder sprites
        
                    vSpZorderSprite(pso->hdev, pSprite, pState->pTopCursor);
        
                    pState->pTopCursor = pSprite;
        
                }
                else
                {
                    // otherwise hide oldest visible trail
                    
                    pSprite = pState->pBottomCursor;
                    while(pSprite != pState->pTopCursor)
                    {
                        if (pSprite->fl & SPRITE_FLAG_VISIBLE)
                        {
                            ASSERTGDI(pSprite->rclSprite.left != pSprite->rclSprite.right, "Invalid rclSprite for visible sprite.\n");
                            bSpUpdatePosition(pSprite, NULL);
                            break;
                        }
                        pSprite = pSprite->pNextZ;
                    }

                }

                // update time stamp
                pState->ulTrailTimeStamp = tickCount;

            }


        }
        
        if (x == -1)
        {
            // hide all cursors

            ptlDst.x = LONG_MAX;
            ptlDst.y = LONG_MAX;

            pSprite = pState->pBottomCursor;
            
            while(pSprite != NULL)
            {
                bSpUpdatePosition(pSprite, &ptlDst, FALSE);

                pSprite = pSprite->pNextZ;
            }
        }
        else
        {
            ptlDst.x = x - pState->xHotCursor;
            ptlDst.y = y - pState->yHotCursor;

            // update the position of the top most cursor

            pSprite = pState->pTopCursor;

            bSpUpdatePosition(pSprite, &ptlDst);
            vSpRedrawSprite(pSprite);
        }

        // Nothing is more irritating than having a cursor that 'lags'.  If
        // the driver is a DDI batching driver (meaning that it updates the
        // screen only occassionally unless we explicitly call DrvSynchronize),
        // let's force it to update the screen now:

        if (po.flGraphicsCaps2() & GCAPS2_SYNCTIMER)
        {
            po.vSync(po.pSurface()->pSurfobj(), NULL, DSS_TIMER_EVENT);
        }
    }
}

/***************************************************************************\
* ULONG EngSetPointerShape
*
* Sets the pointer shape for the GDI pointer simulations.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\***************************************************************************/

ULONG EngSetPointerShape(
SURFOBJ*    pso,
SURFOBJ*    psoMask,
SURFOBJ*    psoColor,
XLATEOBJ*   pxlo,
LONG        xHot,
LONG        yHot,
LONG        x,
LONG        y,
RECTL*      prclBounds,
FLONG       fl)
{
    HDEV            hdev;
    SPRITESTATE*    pState;
    SPRITE*         pSprite;
    ULONG           ulRet = SPS_ACCEPT_NOEXCLUDE;
    ULONG           numCursors = ((fl & SPS_LENGTHMASK) >> 8) + 1;
    ULONG           ulFreq = (fl & SPS_FREQMASK) >> 12;
    ULONG           ulTrailPeriod = (ulFreq == 0 ? 0 : 1000 / ulFreq);

    hdev = pso->hdev;

    PDEVOBJ po(hdev);

    pState = po.pSpriteState();

    // Handle the hide case.  We take the opportunity to delete the sprite,
    // so that we can start out fresh the next time.

    if ((psoMask == NULL) && (psoColor == NULL))
    {

        pSprite = pState->pBottomCursor;

        while(pSprite != NULL)
        {
            SPRITE*         pNextSprite = pSprite->pNextZ;
            vSpDeleteSprite(pSprite);
            pSprite = pNextSprite;
        }

        pState->pTopCursor = NULL;
        pState->pBottomCursor = NULL;
        pState->ulNumCursors = 0;

        return(SPS_ACCEPT_NOEXCLUDE);
    }

    // adjust the number of cursors

    while (pState->ulNumCursors < numCursors)
    {
        pSprite = pSpCreateSprite(hdev, NULL, 0);

        if(pSprite == NULL)
            break;
         
        if(pState->pTopCursor == NULL)
        {
            pState->pTopCursor = pSprite;
        }

        pState->pBottomCursor = pSprite;

        pState->ulNumCursors++;
    }

    while(pState->ulNumCursors > numCursors)
    {
        pSprite = pState->pBottomCursor;
        pState->pBottomCursor = pSprite->pNextZ;
        vSpDeleteSprite(pSprite);
        pState->ulNumCursors--;
    }

    pState->ulTrailPeriod = ulTrailPeriod;

    // Handle the show case.
    if (pState->pTopCursor != NULL)
    {
        // hide and update the shape of all cursors

        pSprite = pState->pBottomCursor;

        // hide cursors
        {
            SPRITELOCK slock(po);
    
            while(pSprite != NULL)
            {
    
                bSpUpdatePosition(pSprite, NULL, FALSE);
                vSpRedrawSprite(pSprite);
    
    
                pSprite = pSprite->pNextZ;
            }
        }

        // update the shapes

        pSprite = pState->pBottomCursor;

        while(pSprite != NULL)
        {

            if (!bSpUpdateCursor(pSprite, psoMask, psoColor, pxlo, prclBounds))
            {
                ulRet = SPS_ERROR;
                break;
            }

            pSprite = pSprite->pNextZ;
        }

        // Remember the hot spot and force EngMovePointer to redraw:

        pState->xHotCursor = xHot - prclBounds->left;
        pState->yHotCursor = yHot - prclBounds->top;
    }

    // Draw the cursor.  Note that it's okay if 'pSpriteCursor' is NULL:

    EngMovePointer(pso, x, y, NULL);

    return(ulRet);
}

/******************************Public*Routine******************************\
* ULONG cIntersect
*
* This routine takes a list of rectangles from 'prclIn' and clips them
* in-place to the rectangle 'prclClip'.  The input rectangles don't
* have to intersect 'prclClip'; the return value will reflect the
* number of input rectangles that did intersect, and the intersecting
* rectangles will be densely packed.
*
* History:
*  3-Apr-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

ULONG cIntersect(
RECTL*  prclClip,
RECTL*  prclIn,         // List of rectangles
LONG    c)              // Can be zero
{
    ULONG   cIntersections;
    RECTL*  prclOut;

    cIntersections = 0;
    prclOut        = prclIn;

    for (; c != 0; prclIn++, c--)
    {
        prclOut->left  = max(prclIn->left,  prclClip->left);
        prclOut->right = min(prclIn->right, prclClip->right);

        if (prclOut->left < prclOut->right)
        {
            prclOut->top    = max(prclIn->top,    prclClip->top);
            prclOut->bottom = min(prclIn->bottom, prclClip->bottom);

            if (prclOut->top < prclOut->bottom)
            {
                prclOut++;
                cIntersections++;
            }
        }
    }

    return(cIntersections);
}

/******************************Public*Routine******************************\
* BOOL bMoveDevDragRect
*
* Called by USER to move the drag rect on the screen.
*
* Note: Devlock must already have been acquired.
*
* History:
*  3-Apr-1996 -by- J. Andrew Goossen andrewgo
* Wrote it.
\**************************************************************************/

BOOL bMoveDevDragRect(
HDEV   hdev,                // Note that this may be a multi-mon meta-PDEV
RECTL *prclNew)
{
    SPRITESTATE*    pState;
    ULONG           ulDimension;
    ULONG           crclTemp;
    ULONG           i;
    RECTL           arclTemp[4];
    SIZE            siz;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    po.vAssertDevLock();

    ulDimension = pState->ulDragDimension;

    arclTemp[0].left   = prclNew->left;
    arclTemp[0].right  = prclNew->left   + ulDimension;
    arclTemp[0].top    = prclNew->top;
    arclTemp[0].bottom = prclNew->bottom;

    arclTemp[1].left   = prclNew->right  - ulDimension;
    arclTemp[1].right  = prclNew->right;
    arclTemp[1].top    = prclNew->top;
    arclTemp[1].bottom = prclNew->bottom;

    arclTemp[2].left   = prclNew->left   + ulDimension;
    arclTemp[2].right  = prclNew->right  - ulDimension;
    arclTemp[2].top    = prclNew->top;
    arclTemp[2].bottom = prclNew->top    + ulDimension;

    arclTemp[3].left   = prclNew->left   + ulDimension;
    arclTemp[3].right  = prclNew->right  - ulDimension;
    arclTemp[3].top    = prclNew->bottom - ulDimension;
    arclTemp[3].bottom = prclNew->bottom;

    // We have to clip to the specified rectangle in order to handle
    // chip-window drag-rects for MDI applications.

    crclTemp = cIntersect(&pState->rclDragClip, &arclTemp[0], 4);

    for (i = 0; i < crclTemp; i++)
    {
        siz.cx = arclTemp[i].right - arclTemp[i].left;
        siz.cy = arclTemp[i].bottom - arclTemp[i].top;

        if (pState->ahDragSprite[i])
        {
            GreUpdateSprite(hdev,
                            NULL,
                            pState->ahDragSprite[i],
                            NULL,
                            (POINT*) &arclTemp[i],
                            &siz,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            ULW_DRAGRECT,
                            NULL);
        }
    }

    for (; i < 4; i++)
    {
        if (pState->ahDragSprite[i])
        {
            GreUpdateSprite(hdev, NULL, pState->ahDragSprite[i], NULL, NULL,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BOOL bSetDevDragRect
*
* Called by USER to slap the drag rect on the screen, or to tear it back
* down.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
* Converted drag rects to use sprites.
\**************************************************************************/

BOOL bSetDevDragRect(
HDEV   hdev,                    // Note that this may be a multi-mon meta-PDEV
RECTL* prclDrag,
RECTL* prclClip)
{
    SPRITESTATE*    pState;
    RECTL           rclScreen;
    RECTL           arclDrag[4];
    ULONG           crclDrag;
    HANDLE          hSprite;
    ULONG           i;
    BOOL            bRet = TRUE;        // Assume success

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    DEVLOCKOBJ dlo(po);

    pState->bHaveDragRect = FALSE;

    // Create 4 sprites to handle each of the sides of the drag rectangle.

    if (prclDrag != NULL)
    {
        ASSERTGDI(!pState->bHaveDragRect, "Expected not to have a drag rectangle");
        ASSERTGDI(prclClip != NULL, "Expected to have a clip rectangle");

        bRet = TRUE;
        for (i = 0; i < 4; i++)
        {
            hSprite = GreCreateSprite(hdev, NULL, NULL);
            pState->ahDragSprite[i] = hSprite;

            if (!hSprite)
                bRet = FALSE;
        }

        if (bRet)
        {
            pState->bHaveDragRect = TRUE;
            pState->rclDragClip = *prclClip;

            bMoveDevDragRect(hdev, prclDrag);
        }
    }

    // If we don't have a drag rectangle, delete any drag rectangle
    // sprites we may have laying around.

    if (!pState->bHaveDragRect)
    {
        for (i = 0; i < 4; i++)
        {
            if (pState->ahDragSprite[i] != NULL)
            {
                GreDeleteSprite(hdev, NULL, pState->ahDragSprite[i]);
                pState->ahDragSprite[i] = NULL;
            }
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* BOOL bSetDevDragWidth
*
* Called by USER to tell us how wide the drag rectangle should be.
*
*  24-Aug-1992 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

BOOL bSetDevDragWidth(
HDEV    hdev,
ULONG   ulWidth)
{
    PDEVOBJ po(hdev);

    DEVLOCKOBJ dlo(po);

    SPRITESTATE* pState = po.pSpriteState();

    pState->ulDragDimension = ulWidth;

    return(TRUE);
}

/******************************Public*Routine******************************\
* UNDODESKTOPCOORD
*
* Temporariliy convert the WNDOBJ from desktop coordinates to device-
* relative coordinates.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

UNDODESKTOPCOORD::UNDODESKTOPCOORD(
EWNDOBJ*     pwo,
SPRITESTATE* pState)
{
    pwoUndo = NULL;
    if ((pwo != NULL) && (pwo->fl & WO_RGN_DESKTOP_COORD))
    {
        PDEVOBJ po(pState->hdev);
        po.vAssertDevLock();

        pwoUndo = pwo;
        xUndo = po.pptlOrigin()->x;
        yUndo = po.pptlOrigin()->y;

        pwo->vOffset(-xUndo, -yUndo);
        pwo->fl &= ~WO_RGN_DESKTOP_COORD;
    }
}

/******************************Public*Routine******************************\
* VOID vSpDeviceControlSprites
*
* Undo our temporary conversion of a WNDOBJ to device-relative coordinates.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

UNDODESKTOPCOORD::~UNDODESKTOPCOORD()
{
    if (pwoUndo)
    {
        pwoUndo->vOffset(xUndo, yUndo);
        pwoUndo->fl |= WO_RGN_DESKTOP_COORD;
    }
}

/******************************Public*Routine******************************\
* VOID vSpDeviceControlSprites
*
* Function callable from the driver to control the exclusion of sprites
* from on top of a WNDOBJ window.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

VOID vSpDeviceControlSprites(
HDEV     hdev,
EWNDOBJ* pwo,
FLONG    fl)
{
    SPRITESTATE*    pState;
    BOOL            bMore;
    SPRITE*         pSprite;
    RECTL           rclEnum;
    RECTL           rclBounds;

    PDEVOBJ po(hdev);

    po.vAssertDevLock();
    SPRITELOCK slock(po);

    pState = po.pSpriteState();

    // The WNDOBJ coordinates must be device-relative, so
    // use UNDO:

    UNDODESKTOPCOORD udc(pwo, pState);

    if (fl == ECS_TEARDOWN)
    {
        pwo->fl |= WO_NOSPRITES;

        // We only have to do some work if a sprite overlaps the
        // window:

        if ((pwo->fl & WO_SPRITE_OVERLAP) &&
            bIntersect(&pwo->rclBounds, &pState->rclScreen, &rclBounds))
        {
            // Tear down all sprites:

            ENUMAREAS Enum(pState, &rclBounds);

            do {
                bMore = Enum.bEnum(&pSprite, &rclEnum);

                if (pSprite != NULL)
                {
                    OFFCOPYBITS(&gptlZero,
                                pState->psoScreen,
                                &pSprite->OffUnderlay,
                                pSprite->psoUnderlay,
                                pwo,
                                NULL,
                                &rclEnum,
                                (POINTL*) &rclEnum);
                }
            } while (bMore);
        }

        // Now that we're done tearing down, re-compute the
        // unlocked region, to account for the newly locked
        // area.

        vSpComputeUnlockedRegion(pState);
    }
    else
    {
        // Note that it's perfectly fine to call 'redraw' without having
        // first done 'teardown' (this is useful for OpenGL windows when
        // hardware double buffering, in order to prevent the cursor from
        // flickering).

        pwo->fl &= ~WO_NOSPRITES;

        // Re-compute the unlocked region, to account for the changed
        // state.

        vSpComputeUnlockedRegion(pState);

        if ((pwo->fl & WO_SPRITE_OVERLAP) &&
            bIntersect(&pwo->rclBounds, &pState->rclScreen, &rclBounds))
        {
            // First, get the new underlay bits:

            ENUMAREAS Enum(pState, &rclBounds);

            do {
                bMore = Enum.bEnum(&pSprite, &rclEnum);

                if (pSprite != NULL)
                {
                    // All underlays which overlap with this area must be
                    // updated, which explains the following 'bEnumLayers':

                    do {
                        OFFCOPYBITS(&pSprite->OffUnderlay,
                                    pSprite->psoUnderlay,
                                    &gptlZero,
                                    pState->psoScreen,
                                    pwo,
                                    NULL,
                                    &rclEnum,
                                    (POINTL*) &rclEnum);

                    } while (Enum.bEnumLayers(&pSprite));
                }
            } while (bMore);

            // Now draw the sprites:

            vSpRedrawArea(pState, &rclBounds, TRUE);
        }
    }
}

/******************************Public*Routine******************************\
* BOOL EngControlSprites
*
* Multi-mon aware function that's callable from the driver to control the
* exclusion of sprites from on top of a WNDOBJ window.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

BOOL EngControlSprites(
WNDOBJ* pwo,
FLONG   fl)
{
    SPRITESTATE*    pState;
    ULONG           i;

    if ((fl != ECS_TEARDOWN) && (fl != ECS_REDRAW))
        return(FALSE);

    PDEVOBJ po(((EWNDOBJ*) pwo)->pto->pSurface->hdev());
    PDEVOBJ poParent(po.hdevParent());

    DEVLOCKOBJ dlo(po);

    pState = poParent.pSpriteState();

    if (pState->cMultiMon)
    {
        for (i = 0; i < pState->cMultiMon; i++)
        {
            vSpDeviceControlSprites(pState->ahdevMultiMon[i], (EWNDOBJ*) pwo, fl);
        }
    }
    else
    {
        vSpDeviceControlSprites(po.hdev(), (EWNDOBJ*) pwo, fl);
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* VOID vSpComputeUnlockedRegion
*
* Compute the region that describes the area on which sprites are free
* to draw (which does not include DirectDraw locked areas, or WNDOBJ
* areas that have the WO_NOSPRITES flag set).
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

VOID vSpComputeUnlockedRegion(
SPRITESTATE*    pState)
{
    RECTL                   rcl;
    SURFACE*                pSurface;
    TRACKOBJ*               pto;
    EWNDOBJ*                pwo;

    PDEVOBJ po(pState->hdev);
    po.vAssertDevLock();

    // Get rid of the old region:

    if (pState->prgnUnlocked != NULL)
    {
        pState->prgnUnlocked->vDeleteREGION();
        pState->prgnUnlocked = NULL;
    }

    pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen);

    // We have to to work if either a DirectDraw lock is active, or if a
    // WNDOBJ is active.

    if ((DxDdGetSurfaceLock(po.hdev()) || gpto != NULL))
    {
        // Calculate the new region:

        RGNMEMOBJ rmoUnlocked((BOOL) FALSE);
        if (rmoUnlocked.bValid())
        {
            rcl.left   = 0;
            rcl.top    = 0;
            rcl.right  = po.sizl().cx;
            rcl.bottom = po.sizl().cy;

            rmoUnlocked.vSet(&rcl);

            RGNMEMOBJTMP rmoRect((BOOL) FALSE);
            RGNMEMOBJTMP rmoTmp((BOOL) FALSE);

            if (rmoRect.bValid() && rmoTmp.bValid())
            {
                // Loop through the list of DirectDraw locked surfaces and
                // remove their locked rectangles from the inclusion region:
 
                RECTL rclDdLocked;

                PVOID pvDdSurface = DxDdEnumLockedSurfaceRect(po.hdev(),NULL,&rclDdLocked);

                while (pvDdSurface)
                {
                    // We don't check the return code on 'bCopy' because it
                    // guarantees that it will maintain valid region constructs
                    // -- even if the contents are incorrect.  And if we fail
                    // here because we're low on memory, it's guaranteed that
                    // there will already be plenty of incorrect drawing,
                    // so we don't care if our inclusion region is
                    // invalid:

                    rmoRect.vSet(&rclDdLocked);
                    rmoTmp.bCopy(rmoUnlocked);
                    if (!rmoUnlocked.bMerge(rmoTmp, rmoRect, gafjRgnOp[RGN_DIFF]))
                    {
                        rmoUnlocked.vSet();
                    }

                    // Move on to next surface.

                    pvDdSurface = DxDdEnumLockedSurfaceRect(po.hdev(),pvDdSurface,&rclDdLocked);
                }

                // We must be holding the WNDOBJ semaphore before mucking
                // with any WNDOBJs.

                SEMOBJ so(ghsemWndobj);

                // Now loop through the list of WNDOBJs, and subtract their
                // regions.

                for (pto = gpto; pto; pto = pto->ptoNext)
                {
                    for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
                    {
                        // The WNDOBJ coordinates must be device-relative, so
                        // use UNDO:

                        UNDODESKTOPCOORD udc(pwo, pState);

                        if (pwo->fl & WO_NOSPRITES)
                        {
                            rmoTmp.bCopy(rmoUnlocked);
                            if (!rmoUnlocked.bMerge(rmoTmp,
                                               *pwo,
                                               gafjRgnOp[RGN_DIFF]))
                            {
                                rmoUnlocked.vSet();
                            }
                        }
                    }
                }
            }

            rmoUnlocked.vStamp();
            pState->prgnUnlocked = rmoUnlocked.prgnGet();
        }
    }

    // Finally, mark the range cache as invalid so that 'prgnUncovered'
    // gets recomputed to incorporate 'prgnUnlocked':

    pState->bValidRange = FALSE;
}

/******************************Public*Routine******************************\
* VOID vSpUpdateWndobjOverlap
*
* Recalculate whether any sprites overlap a WNDOBJ area, and notify the
* driver if that state has changed.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

VOID vSpUpdateWndobjOverlap(
SPRITESTATE*    pState,
EWNDOBJ*        pwo)
{
    BOOL    bSpriteOverlap;
    SPRITE* pSprite;

    PDEVOBJ po(pState->hdev);

    po.vAssertDevLock();

    ASSERTGDI(!(pwo->fl & WO_RGN_DESKTOP_COORD), "Use UNDODESKTOPCOORD");

    // Ah ha.  Recalculate total number of intersections for
    // this WNDOBJ.

    bSpriteOverlap = FALSE;

    for (pSprite = pState->pListZ;
         pSprite != NULL;
         pSprite = pSprite->pNextZ)
    {
        if (bIntersect(&pwo->rclBounds, &pSprite->rclSprite))
        {
            if (pwo->bInside(&pSprite->rclSprite) == REGION_RECT_INTERSECT)
            {
                RGNOBJ roClip(pSprite->prgnClip);

                if (!roClip.bValid() ||
                    (roClip.bInside(&pwo->rclBounds) == REGION_RECT_INTERSECT))
                {
                    bSpriteOverlap = TRUE;

                    break;
                }
            }
        }
    }

    // Inform the driver if the overlap state for this window
    // has changed.

    if ((bSpriteOverlap) && !(pwo->fl & WO_SPRITE_OVERLAP))
    {
        pwo->fl |= WO_SPRITE_OVERLAP;

        if (pwo->fl & WO_SPRITE_NOTIFY)
            pwo->pto->vUpdateDrv(pwo, WOC_SPRITE_OVERLAP);
    }
    else if ((!bSpriteOverlap) && (pwo->fl & WO_SPRITE_OVERLAP))
    {
        pwo->fl &= ~WO_SPRITE_OVERLAP;

        if (pwo->fl & WO_SPRITE_NOTIFY)
            pwo->pto->vUpdateDrv(pwo, WOC_SPRITE_NO_OVERLAP);
    }
}

/******************************Public*Routine******************************\
* VOID vSpCheckForWndobjOverlap
*
* Go through all the WNDOBJs and see if either the old or the new sprite
* position may have changed the sprite overlap state.
*
* History:
*  4-Apr-1998 -by- J. Andrew Goossen andrewgo
\**************************************************************************/

VOID vSpCheckForWndobjOverlap(
SPRITESTATE*    pState,
RECTL*          prclNew,
RECTL*          prclOld)
{
    SURFACE*    pSurface;
    TRACKOBJ*   pto;
    EWNDOBJ*    pwo;

    PDEVOBJ po(pState->hdev);

    po.vAssertDevLock();

    pSurface = SURFOBJ_TO_SURFACE_NOT_NULL(pState->psoScreen);

    // Hold the WNDOBJ semaphore before mucking with any WNDOBJs.

    SEMOBJ so(ghsemWndobj);

    for (pto = gpto; pto; pto = pto->ptoNext)
    {
        for (pwo = pto->pwo; pwo; pwo = pwo->pwoNext)
        {
            // The WNDOBJ coordinates must be device-relative, so use UNDO:

            UNDODESKTOPCOORD udc(pwo, pState);

            // Note that this cannot be an 'XOR' test, because we're
            // only testing the bounds at this point.

            if (bIntersect(&pwo->rclBounds, prclNew) ||
                bIntersect(&pwo->rclBounds, prclOld))
            {
                vSpUpdateWndobjOverlap(pState, pwo);
            }
        }
    }
}

/******************************Public*Routine******************************\
* VOID vSpDeviceWndobjChange
*
* Routine to inform the sprite code when a WNDOBJ has changed.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpDeviceWndobjChange(
HDEV        hdev,
EWNDOBJ*    pwo)
{
    SPRITESTATE*    pState;

    PDEVOBJ po(hdev);
    pState = po.pSpriteState();

    // The WNDOBJ coordinates must be device-relative, so use UNDO:

    UNDODESKTOPCOORD udc(pwo, pState);

    po.vAssertDevLock();

    if (pwo != NULL)
    {
        vSpUpdateWndobjOverlap(pState, pwo);
    }

    // Technically, we only have to recompute the regions when a WO_NOSPRITE
    // WNDOBJ has been created, destroyed, or moved.  But it won't hurt
    // anything if we do it for any WNDOBJ.

    vSpComputeUnlockedRegion(pState);
}

/******************************Public*Routine******************************\
* VOID vSpWndobjChange
*
* Routine to inform the sprite code when a WNDOBJ has changed.  This
* routine is multi-mon aware.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpWndobjChange(
HDEV        hdev,
EWNDOBJ*    pwo)
{
    SPRITESTATE*    pState;
    ULONG           i;

    PDEVOBJ po(hdev);

    DEVLOCKOBJ dlo(po);

    pState = po.pSpriteState();

    if (pState->cMultiMon)
    {
        for (i = 0; i < pState->cMultiMon; i++)
        {
            vSpDeviceWndobjChange(pState->ahdevMultiMon[i], pwo);
        }
    }
    else
    {
        vSpDeviceWndobjChange(hdev, pwo);
    }
}

/******************************Public*Routine******************************\
* BOOL bSpTearDownSprites
*
* This routine tears-down any sprites in the specified rectangle.
*
* Returns: TRUE if any sprites were torn down (and so need to be re-drawn
*          later), FALSE if no sprites were torn down.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpTearDownSprites(
HDEV    hdev,
RECTL*  prclExclude,
BOOL    bDirectDrawLock)        // TRUE if we're being called by the DirectDraw
                                //   Lock function.  FALSE if we're being called
                                //   from a routine which wants to just
                                //   momentarily tear down the sprite
{
    SPRITESTATE*    pState;
    RECTL           rclEnum;
    BOOL            bTearDown;
    BOOL            bMore;
    SPRITE*         pSprite;
    RECTL           rclExclude;

    PDEVOBJ po(hdev);

    // No sprites to tear down on printers

    if (!po.bDisplayPDEV())
    {
        return FALSE;
    }

    po.vAssertDevLock();
    pState = po.pSpriteState();

    SPRITELOCK slock(po);

    bTearDown = FALSE;

    // We only need to do any actual work if any sprites are up on
    // the screen:

    if (pState->cVisible != 0)
    {
        if (bIntersect(prclExclude, &pState->rclScreen, &rclExclude))
        {
            // Tear down all sprites:

            ENUMAREAS Enum(pState, &rclExclude);

            do {
                bMore = Enum.bEnum(&pSprite, &rclEnum);

                if (pSprite != NULL)
                {
                    bTearDown = TRUE;

                    vSpWriteToScreen(pState,
                                     &pSprite->OffUnderlay,
                                     pSprite->psoUnderlay,
                                     &rclEnum);
                }
            } while (bMore);

            if (bDirectDrawLock)
            {
                // Now compute the new unlocked region:

                vSpComputeUnlockedRegion(pState);
            }
        }
    }

    return(bTearDown);
}

/******************************Public*Routine******************************\
* VOID vSpUnTearDownSprites
*
* This routine redraws any sprites in the specified rectangle.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

VOID vSpUnTearDownSprites(
HDEV    hdev,
RECTL*  prclExclude,
BOOL    bDirectDrawUnlock)
{
    SPRITESTATE*    pState;
    RECTL           rclEnum;
    BOOL            bMore;
    SPRITE*         pSprite;
    RECTL           rclExclude;

    PDEVOBJ po(hdev);

    ASSERTGDI(po.bDisplayPDEV(), "vSpUnTearDownSprites:  not a display pdev");

    po.vAssertDevLock();
    pState = po.pSpriteState();

    // We only need to do any actual work if any sprites are up on
    // the screen:

    if (pState->cVisible != 0)
    {
        if (bIntersect(prclExclude, &pState->rclScreen, &rclExclude))
        {
            SPRITELOCK slock(po);

            if (bDirectDrawUnlock)
            {
                // Now compute the new unlocked region:

                vSpComputeUnlockedRegion(pState);
            }

            // Reload the underlays:

            ENUMAREAS Enum(pState, &rclExclude);

            do {
                // We know that we already excluded any sprites from the
                // 'prclExclude' area, so it's safe to update the underlays
                // directly from the screen since we know we won't pick up
                // any sprite images.

                bMore = Enum.bEnum(&pSprite, &rclEnum);

                if (pSprite != NULL)
                {
                    do {
                        vSpReadFromScreen(pState,
                                          &pSprite->OffUnderlay,
                                          pSprite->psoUnderlay,
                                          &rclEnum);

                    } while (Enum.bEnumLayers(&pSprite));
                }
            } while (bMore);

            // Redraw the affected area:

            vSpRedrawArea(pState, &rclExclude, TRUE);
        }
    }
}

/******************************Public*Routine******************************\
* BOOL bSpSpritesVisible
*
* Returns TRUE if any emulated sprites are currently visible.
*
*  16-Sep-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL bSpSpritesVisible(
HDEV    hdev)
{
    SPRITESTATE* pState;

    PDEVOBJ po(hdev);
    po.vAssertDevLock();
    pState = po.pSpriteState();

    return(pState->cVisible != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\srcblt24.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt24.cxx
*
* This contains the bitmap simulation functions that blt to a 24 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

// Turn off validations
#if 1

    // On free builds, don't call any verification code:

    #define VERIFYS16D24(psb)
    #define VERIFYS32D24(psb)

#else

    // On checked builds, verify the RGB conversions:

    VOID VERIFYS16D24(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D24 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D24 - direction not up to down");

    // These are our holding variables

        ULONG ulDst;
        PUSHORT pusSrcTemp;
        PBYTE pjDstTemp;
        ULONG  cxTemp;
        PUSHORT pusSrc  = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
        PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {
            pusSrcTemp  = pusSrc;
            pjDstTemp  = pjDst;
            cxTemp     = cx;

            while(cxTemp--)
            {
                ulDst = pxlo->ulTranslate((ULONG) *(pusSrcTemp++));

                if (*(pjDstTemp++) != (BYTE) ulDst)
                    RIP("RGB mis-match");
                if (*(pjDstTemp++) != (BYTE) (ulDst >> 8))
                    RIP("RGB mis-match");
                if (*(pjDstTemp++) != (BYTE) (ulDst >> 16))
                    RIP("RGB mis-match");
            }

            if (--cy)
            {
                pusSrc = (PUSHORT) (((PBYTE) pusSrc) + psb->lDeltaSrc);
                pjDst += psb->lDeltaDst;
            }
            else
                break;
        }
    }

    VOID VERIFYS32D24(PBLTINFO psb)
    {
    // We assume we are doing left to right top to bottom blting

        ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D24 - direction not left to right");
        ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D24 - direction not up to down");

    // These are our holding variables

        ULONG ulDst;
        PULONG pulSrcTemp;
        PBYTE pjDstTemp;
        ULONG  cxTemp;
        PULONG pulSrc  = (PULONG) (psb->pjSrc + (4 * psb->xSrcStart));
        PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
        ULONG cx     = psb->cx;
        ULONG cy     = psb->cy;
        XLATE *pxlo = psb->pxlo;

        ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

        while(1)
        {

            pulSrcTemp  = pulSrc;
            pjDstTemp  = pjDst;
            cxTemp     = cx;

            if ((pxlo == NULL) || (pxlo->flXlate & XO_TRIVIAL))
            {
                while(cxTemp--)
                {
                    ulDst = *(pulSrcTemp++);

                    if (*(pjDstTemp++) != (BYTE) ulDst)
                        RIP("RGB mis-match");
                    if (*(pjDstTemp++) != (BYTE) (ulDst >> 8))
                        RIP("RGB mis-match");
                    if (*(pjDstTemp++) != (BYTE) (ulDst >> 16))
                        RIP("RGB mis-match");
                }
            }
            else
            {
                while(cxTemp--)
                {
                    ulDst = pxlo->ulTranslate(*(pulSrcTemp++));

                    if (*(pjDstTemp++) != (BYTE) ulDst)
                        RIP("RGB mis-match");
                    if (*(pjDstTemp++) != (BYTE) (ulDst >> 8))
                        RIP("RGB mis-match");
                    if (*(pjDstTemp++) != (BYTE) (ulDst >> 16))
                        RIP("RGB mis-match");
                }
            }

            if (--cy)
            {
                pulSrc = (PULONG) (((PBYTE) pulSrc) + psb->lDeltaSrc);
                pjDst += psb->lDeltaDst;
            }
            else
                break;
        }
    }



#endif

/*******************Public*Routine*****************\
* vSrcCopyS1D24
*
* There are three main loops in this function.
*
* The first loop deals with the full byte part mapping
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the left starting
* pixels.
*
* The third loop deals with the ending pixels.
*
* For the full bytes, we walk thru Src one byte at a time
* and expand to Dst.
*
* We expand the starting/ending pixels one bit
* at a time.
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************/

VOID vSrcCopyS1D24(PBLTINFO psb)
{
    // We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D24 - direction not up to down");

    BYTE  jSrc;    // holds a source byte
    INT   iDst;    // Position in the first 8 Dst units
    INT   iSrc;    // bit position in the first Src byte
    PBYTE pjDst;
    PBYTE pjSrc;   // pointer to the Dst bytes
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;      // number of rows
    LONG  cx;      // number of pixels
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    LONG  cFullBytes;  //number of full 8 bytes dealed with
    BOOL  bNextByte;
    LONG  xDstEnd = psb->xDstStart+psb->cx;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    ULONG ulB = (ULONG)(psb->pxlo->pulXlate[0]);
    ULONG ulF = (ULONG)(psb->pxlo->pulXlate[1]);
    UCHAR aucTable[8];
    INT   count;
    PBYTE pjTable;
    BOOL  bNextSrc=TRUE;

    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d24\n");

    // Generate ulTable. 2 entries.
    ULONG ulValB = ulB;
    ULONG ulValF = ulF;

    *(PULONG) aucTable = ulValB;
    *(PULONG) (aucTable+4) = ulValF;

    //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    if (iSrc < iDst)
        jAlignL = 8 - (iDst - iSrc);
    // If Dst starting point is ahead of Src
    else
        jAlignL = iSrc - iDst;

    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    // if there is a next 8 dwords
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // if Src and Dst are aligned, use a separete loop
    // to obtain better performance;
    // If not, we shift the Src bytes to match with
    // the Dst - 1 bit expand to 3 bytes

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;

        // Get first Dst full 8 dwords
        pjDst = psb->pjDst + 3*((psb->xDstStart+7)&~0x07);

        // Get the Src byte that matches the first Dst
        // full 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get the number of full bytes to expand
        cFullBytes = (xDstEnd>>3)-((psb->xDstStart+7)>>3);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst - cFullBytes*8*3;
        iStrideSrc = lDeltaSrc - cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL)
        {
            while (cy--)
            {
                pjSrcEnd = pjSrc + cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = *pjSrc++;

                    pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                    *(pjDst + 0) = *pjTable;
                    *(pjDst + 1) = *(pjTable+1);
                    *(pjDst + 2) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x40) >> (6-2));

                    *(pjDst + 3) = *pjTable;
                    *(pjDst + 4) = *(pjTable+1);
                    *(pjDst + 5) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x20) >> (5-2));

                    *(pjDst + 6) = *pjTable;
                    *(pjDst + 7) = *(pjTable+1);
                    *(pjDst + 8) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x10) >> (4-2));

                    *(pjDst + 9) = *pjTable;
                    *(pjDst + 10) = *(pjTable+1);
                    *(pjDst + 11) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x08) >> (3-2));

                    *(pjDst + 12) = *pjTable;
                    *(pjDst + 13) = *(pjTable+1);
                    *(pjDst + 14) = *(pjTable+2);

                    pjTable = aucTable + (jSrc & 0x04);

                    *(pjDst + 15) = *pjTable;
                    *(pjDst + 16) = *(pjTable+1);
                    *(pjDst + 17) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x02) << 1);

                    *(pjDst + 18) = *pjTable;
                    *(pjDst + 19) = *(pjTable+1);
                    *(pjDst + 20) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x01) << 2);

                    *(pjDst + 21) = *pjTable;
                    *(pjDst + 22) = *(pjTable+1);
                    *(pjDst + 23) = *(pjTable+2);

                    pjDst +=3*8;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }

        }   //end of if (!jAlignL)

        else  // if not aligned
        // Here comes our general case for the main full
        // bytes part
        {
            BYTE jRem; //remainder

            while (cy--)
            {
                jRem = *pjSrc << jAlignL;

                pjSrcEnd = pjSrc + cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = ((*(++pjSrc))>>jAlignR) | jRem;

                    pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                    *(pjDst + 0) = *pjTable;
                    *(pjDst + 1) = *(pjTable+1);
                    *(pjDst + 2) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x40) >> (6-2));

                    *(pjDst + 3) = *pjTable;
                    *(pjDst + 4) = *(pjTable+1);
                    *(pjDst + 5) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x20) >> (5-2));

                    *(pjDst + 6) = *pjTable;
                    *(pjDst + 7) = *(pjTable+1);
                    *(pjDst + 8) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x10) >> (4-2));

                    *(pjDst + 9) = *pjTable;
                    *(pjDst + 10) = *(pjTable+1);
                    *(pjDst + 11) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x08) >> (3-2));

                    *(pjDst + 12) = *pjTable;
                    *(pjDst + 13) = *(pjTable+1);
                    *(pjDst + 14) = *(pjTable+2);

                    pjTable = aucTable + (jSrc & 0x04);

                    *(pjDst + 15) = *pjTable;
                    *(pjDst + 16) = *(pjTable+1);
                    *(pjDst + 17) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x02) << 1);

                    *(pjDst + 18) = *pjTable;
                    *(pjDst + 19) = *(pjTable+1);
                    *(pjDst + 20) = *(pjTable+2);

                    pjTable = aucTable + ((jSrc & 0x01) << 2);

                    *(pjDst + 21) = *pjTable;
                    *(pjDst + 22) = *(pjTable+1);
                    *(pjDst + 23) = *(pjTable+2);

                    pjDst +=3*8;

                    //next remainder
                    jRem = *pjSrc << jAlignL;
                }

                // go to the beginging full byte of
                // next scan line
                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }
        } //else
    } //if
    // End of our dealing with the full bytes

    // Begin dealing with the left strip of the
    // starting pixels

    if (!bNextByte)
    {
        count = cx;
        bNextSrc = ((iSrc+cx) > 8);
    }
    else
        count = 8-iDst;

    if (iDst | !bNextByte)
    {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        pjDst = psb->pjDst + 3*psb->xDstStart;
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc > iDst)
        {
            if (bNextSrc)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;
                    jSrc |= *(pjSrc+1) >> jAlignR;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;
                    pjDstEnd = pjDst + 3*count;

                    while (pjDstTemp != pjDstEnd)
                    {
                        pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                        *(pjDstTemp + 0) = *pjTable;
                        *(pjDstTemp + 1) = *(pjTable+1);
                        *(pjDstTemp + 2) = *(pjTable+2);

                        jSrc <<= 1;
                        pjDstTemp += 3;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }
            else
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;
                    pjDstEnd = pjDst + 3*count;

                    while (pjDstTemp != pjDstEnd)
                    {
                        pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                        *(pjDstTemp + 0) = *pjTable;
                        *(pjDstTemp + 1) = *(pjTable+1);
                        *(pjDstTemp + 2) = *(pjTable+2);

                        jSrc <<= 1;
                        pjDstTemp += 3;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;
                }
            }

        }
        else //if (iSrc <= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << iSrc;

                pjDstTemp = pjDst;
                pjDstEnd = pjDst + 3*count;

                while (pjDstTemp != pjDstEnd)
                {
                    pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                    *(pjDstTemp + 0) = *pjTable;
                    *(pjDstTemp + 1) = *(pjTable+1);
                    *(pjDstTemp + 2) = *(pjTable+2);

                    jSrc <<= 1;
                    pjDstTemp += 3;

                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }

        }

   } //if

   // Begin dealing with the right edge
   // of partial 8 bytes
   // first check if there is any partial
   // byte left
   // and has next 8 bytes

   if ((xDstEnd & 0x0007)
       && bNextByte)
   {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        // Get the last partial bytes on the
        // scan line
        pjDst = psb->pjDst+ 3*(xDstEnd&~0x07);

        // Get the Src byte that matches the
        // right partial Dst 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        count = iDst+1;

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;

                pjDstTemp = pjDst;
                pjDstEnd = pjDst + 3*count;

                while (pjDstTemp != pjDstEnd)
                {
                    pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                    *(pjDstTemp + 0) = *pjTable;
                    *(pjDstTemp + 1) = *(pjTable+1);
                    *(pjDstTemp + 2) = *(pjTable+2);

                    jSrc <<= 1;
                    pjDstTemp += 3;

                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                 jSrc = *(pjSrc-1) << jAlignL;

                 jSrc |= *pjSrc >> jAlignR;

                 pjDstTemp = pjDst;
                 pjDstEnd = pjDst + 3*count;

                 while (pjDstTemp != pjDstEnd)
                 {
                     pjTable = aucTable + ((jSrc & 0x80) >> (7-2));

                     *(pjDstTemp + 0) = *pjTable;
                     *(pjDstTemp + 1) = *(pjTable+1);
                     *(pjDstTemp + 2) = *(pjTable+2);

                     jSrc <<= 1;
                     pjDstTemp += 3;

                 }

                 pjDst += lDeltaDst;
                 pjSrc += lDeltaSrc;
            }
        }
    } //if
}


/******************************Public*Routine******************************\
* vSrcCopyS4D24
*
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.
// If it was on the same surface we would be doing the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D24 - direction not up to down");

// These are our holding variables

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS8D24\n");
#endif

    PBYTE pjSrc  = psb->pjSrc + (psb->xSrcStart >> 1);
    PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;
    PBYTE pjDstTemp;
    PBYTE pjSrcTemp;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG i,j;
    ULONG ul;
    ULONG ul0, ul1,ul2,ul3;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while(1)
    {
        // Write pixels a byte at a time until we're 'dword' aligned on
        // the destination:

        j = psb->xSrcStart;

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;

        for (i = cStartPixels; i != 0; i--)
        {
            if (j & 0x00000001)
            {
                ul = pulXlate[*pjSrcTemp & 0x0F];
                pjSrcTemp++;
            }
            else
            {
               ul = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
            }

            *(pjDstTemp)     = (BYTE) ul;
            *(pjDstTemp + 1) = (BYTE) (ul >> 8);
            *(pjDstTemp + 2) = (BYTE) (ul >> 16);

            j++;
            pjDstTemp += 3;
        }

        //
        // grab 4 pixles at a time
        //

        for (i = cMiddlePixels; i != 0; i--)
        {
            if (j & 0x00000001)
            {
                ul0 = pulXlate[(*pjSrcTemp & 0x0F)];
                pjSrcTemp++;
                ul1 = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
                ul2 = pulXlate[((ULONG) (*pjSrcTemp & 0x0F))];
                pjSrcTemp++;
                ul3 = pulXlate[((ULONG) (*pjSrcTemp & 0xF0)) >> 4];
            }
            else
            {
                ul0 = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
                ul1 = pulXlate[((ULONG) (*pjSrcTemp & 0x0F))];
                pjSrcTemp++;
                ul2 = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
                ul3 = pulXlate[((ULONG) (*pjSrcTemp & 0x0F))];
                pjSrcTemp++;

            }

            *((ULONG*) (pjDstTemp)) = ul0 | (ul1 << 24);
            *((ULONG*) (pjDstTemp + 4)) = (ul1 >> 8) | (ul2 << 16);
            *((ULONG*) (pjDstTemp + 8)) = (ul3 << 8) | (ul2 >> 16);

            j += 4;
            pjDstTemp += 12;
        }

        // Take care of the end alignment:

        for (i = cEndPixels; i != 0; i--)
        {
            if (j & 0x00000001)
            {
                ul = pulXlate[*pjSrcTemp & 0x0F];
                pjSrcTemp++;
            }
            else
            {
                ul = pulXlate[(((ULONG) (*pjSrcTemp & 0xF0)) >> 4)];
            }

            *(pjDstTemp)     = (BYTE) ul;
            *(pjDstTemp + 1) = (BYTE) (ul >> 8);
            *(pjDstTemp + 2) = (BYTE) (ul >> 16);

            j++;
            pjDstTemp += 3;
        }

        if (--cy == 0)
            break;

        pjSrc += psb->lDeltaSrc;
        pjDst += psb->lDeltaDst;
    }
}


/******************************Public*Routine******************************\
* vSrcCopyS8D24
*
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.
// If it was on the same surface we would be doing the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D24 - direction not up to down");

// These are our holding variables

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS8D24\n");
#endif

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;
    LONG lSrcSkip = psb->lDeltaSrc - cx;
    LONG lDstSkip = psb->lDeltaDst - (cx * 3);
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG i;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while(1)
    {
        // Write pixels a byte at a time until we're 'dword' aligned on
        // the destination:

        for (i = cStartPixels; i != 0; i--)
        {
            ul = pulXlate[*pjSrc];

            *(pjDst)     = (BYTE) ul;
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 1;
            pjDst += 3;
        }

        // Now write pixels a dword at a time.  This is almost a 4x win
        // over doing byte writes if we're writing to frame buffer memory
        // over the PCI bus on Pentium class systems, because the PCI
        // write throughput is so slow:

        for (i = cMiddlePixels; i != 0; i--)
        {
            ul0  = (pulXlate[*(pjSrc)]);
            ul1  = (pulXlate[*(pjSrc + 1)]);

            *((ULONG*) (pjDst)) = ul0 | (ul1 << 24);

            ul0  = (pulXlate[*(pjSrc + 2)]);

            *((ULONG*) (pjDst + 4)) = (ul1 >> 8) | (ul0 << 16);

            ul1  = (pulXlate[*(pjSrc + 3)]);

            *((ULONG*) (pjDst + 8)) = (ul1 << 8) | (ul0 >> 16);

            pjSrc += 4;
            pjDst += 12;
        }

        // Take care of the end alignment:

        for (i = cEndPixels; i != 0; i--)
        {
            ul = pulXlate[*pjSrc];

            *(pjDst)     = (BYTE) ul;
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 1;
            pjDst += 3;
        }

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS16D24
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS16D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D24 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (2 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (3 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 2);
    LONG lDstSkip = psb->lDeltaDst - (cx * 3);
    PFN_pfnXlate pfnXlate = pxlo->pfnXlateBetweenBitfields();
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while (1)
    {
        for (i = cStartPixels; i != 0; i--)
        {
            ul = pfnXlate(pxlo, *((USHORT*) pjSrc));

            *(pjDst)     = (BYTE) (ul);
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 2;
            pjDst += 3;
        }

        for (i = cMiddlePixels; i != 0; i--)
        {
            ul0 = pfnXlate(pxlo, *((USHORT*) (pjSrc)));
            ul1 = pfnXlate(pxlo, *((USHORT*) (pjSrc + 2)));

            *((ULONG*) (pjDst)) = ul0 | (ul1 << 24);

            ul0 = pfnXlate(pxlo, *((USHORT*) (pjSrc + 4)));

            *((ULONG*) (pjDst + 4)) = (ul1 >> 8) | (ul0 << 16);

            ul1 = pfnXlate(pxlo, *((USHORT*) (pjSrc + 6)));

            *((ULONG*) (pjDst + 8)) = (ul1 << 8) | (ul0 >> 16);

            pjSrc += 8;
            pjDst += 12;
        }

        for (i = cEndPixels; i != 0; i--)
        {
            ul = pfnXlate(pxlo, *((USHORT*) pjSrc));

            *(pjDst)     = (BYTE) (ul);
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 2;
            pjDst += 3;
        }

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS16D24(psb);
}

/******************************Public*Routine******************************\
* vSrcCopyS24D24
*
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS24D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS24D24 - direction not up to down");

// These are our holding variables

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS8D24\n");
#endif

    PBYTE pjSrcTemp;
    PBYTE pjDstTemp;
    PBYTE pjSrc  = psb->pjSrc + (psb->xSrcStart * 3);
    PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG i,j;
    ULONG ul;
    ULONG ul0,ul1,ul2,ul3;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while(1)
    {
        // Write pixels a byte at a time until we're 'dword' aligned on
        // the destination:

        j = psb->xSrcStart;

        pjDstTemp  = pjDst;
        pjSrcTemp  = pjSrc;

        for (i = cStartPixels; i != 0; i--)
        {
            ul = (ULONG) *(pjSrcTemp + 2);
            ul = ul << 8;
            ul |= (ULONG) *(pjSrcTemp + 1);
            ul = ul << 8;
            ul |= (ULONG) *pjSrcTemp;

            ul = pxlo->ulTranslate(ul);

            *(pjDstTemp++) = (BYTE) ul;
            *(pjDstTemp++) = (BYTE) (ul >> 8);
            *(pjDstTemp++) = (BYTE) (ul >> 16);

            pjSrcTemp += 3;
        }

        //
        // grab 4 pixles at a time
        //
        for (i = cMiddlePixels; i != 0; i--)
        {
            ul0 = (ULONG) *(pjSrcTemp + 2);
            ul0 = ul0 << 8;
            ul0 |= (ULONG) *(pjSrcTemp + 1);
            ul0 = ul0 << 8;
            ul0 |= (ULONG) *pjSrcTemp;
            ul0 = pxlo->ulTranslate(ul0);

            pjSrcTemp += 3;

            ul1 = (ULONG) *(pjSrcTemp + 2);
            ul1 = ul1 << 8;
            ul1 |= (ULONG) *(pjSrcTemp + 1);
            ul1 = ul1 << 8;
            ul1 |= (ULONG) *pjSrcTemp;
            ul1 = pxlo->ulTranslate(ul1);

            pjSrcTemp += 3;

            ul2 = (ULONG) *(pjSrcTemp + 2);
            ul2 = ul2 << 8;
            ul2 |= (ULONG) *(pjSrcTemp + 1);
            ul2 = ul2 << 8;
            ul2 |= (ULONG) *pjSrcTemp;
            ul2 = pxlo->ulTranslate(ul2);

            pjSrcTemp += 3;

            ul3 = (ULONG) *(pjSrcTemp + 2);
            ul3 = ul3 << 8;
            ul3 |= (ULONG) *(pjSrcTemp + 1);
            ul3 = ul3 << 8;
            ul3 |= (ULONG) *pjSrcTemp;
            ul3 = pxlo->ulTranslate(ul3);

            pjSrcTemp += 3;

            *((ULONG*) (pjDstTemp)) = ul0 | (ul1 << 24);
            *((ULONG*) (pjDstTemp + 4)) = (ul1 >> 8) | (ul2 << 16);
            *((ULONG*) (pjDstTemp + 8)) = (ul3 << 8) | (ul2 >> 16);

            pjDstTemp += 12;
        }

        // Take care of the end alignment:

        for (i = cEndPixels; i != 0; i--)
        {
            ul = (ULONG) *(pjSrcTemp + 2);
            ul = ul << 8;
            ul |= (ULONG) *(pjSrcTemp + 1);
            ul = ul << 8;
            ul |= (ULONG) *pjSrcTemp;

            ul = pxlo->ulTranslate(ul);

            *(pjDstTemp++) = (BYTE) ul;
            *(pjDstTemp++) = (BYTE) (ul >> 8);
            *(pjDstTemp++) = (BYTE) (ul >> 16);

            pjSrcTemp += 3;

        }

        if (--cy == 0)
            break;

        pjSrc += psb->lDeltaSrc;
        pjDst += psb->lDeltaDst;
    }
}
/******************************Public*Routine******************************\
* vSrcCopyS24D24Identity
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps
* and screens.
*
* History:
*  18-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS24D24Identity(PBLTINFO psb)
{
    PBYTE pjSrc  = psb->pjSrc + (psb->xSrcStart * 3);
    PBYTE pjDst  = psb->pjDst + (psb->xDstStart * 3);
    ULONG cx     = psb->cx * 3;
    ULONG cy     = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

#if MESSAGE_BLT
    DbgPrint("xdir: %ld  cy: %lu  xSrcStart %lu  xDstStart %lu xSrcEnd %lu cx %lu\n",
             psb->xDir, cy, psb->xSrcStart, psb->xDstStart, psb->xSrcEnd, cx);
#endif

    if (psb->xDir < 0)
    {
        pjSrc -= (cx - 3);
        pjDst -= (cx - 3);
    }

    while(1)
    {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory(pjDst, pjSrc, cx);
        else
            RtlMoveMemory((PVOID)pjDst, (PVOID)pjSrc, cx);

        if (--cy)
        {
            pjSrc += psb->lDeltaSrc;
            pjDst += psb->lDeltaDst;
        }
        else
            break;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS32D24
*
*
* History:
*  07-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/
VOID vSrcCopyS32D24(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS32D24 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS32D24 - direction not up to down");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + (4 * psb->xSrcStart);
    PBYTE pjDst  = psb->pjDst + (3 * psb->xDstStart);
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    XLATE *pxlo = psb->pxlo;
    XEPALOBJ palSrc(pxlo->ppalSrc);
    XEPALOBJ palDst(pxlo->ppalDst);
    LONG lSrcSkip = psb->lDeltaSrc - (cx * 4);
    LONG lDstSkip = psb->lDeltaDst - (cx * 3);
    PFN_pfnXlate pfnXlate;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG ul;
    ULONG ul0;
    ULONG ul1;
    LONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    if (palSrc.bIsBGR() && palDst.bIsBGR())
    {
        // 'cStartPixels' is the minimum number of 3-byte pixels we'll have to
        // write before we have dword alignment on the destination:

        cStartPixels = (ULONG)((ULONG_PTR) pjDst) & 3;

        if (cStartPixels > cx)
        {
            cStartPixels = cx;
        }
        cx -= cStartPixels;

        cMiddlePixels = cx >> 2;
        cEndPixels = cx & 3;

        while (1)
        {
            for (i = cStartPixels; i != 0; i--)
            {
                *(pjDst)     = *(pjSrc);
                *(pjDst + 1) = *(pjSrc + 1);
                *(pjDst + 2) = *(pjSrc + 2);

                pjSrc += 4;
                pjDst += 3;
            }

            for (i = cMiddlePixels; i != 0; i--)
            {
                ul0 = *((ULONG *) (pjSrc));
                ul1 = *((ULONG *) (pjSrc + 4));

                *((ULONG*) (pjDst)) = (ul0 & 0xffffff) | (ul1 << 24);

                ul0 = *((ULONG *) (pjSrc + 8));

                *((ULONG*) (pjDst + 4)) = ((ul1 >> 8) & 0xffff) | (ul0 << 16);

                ul1 = *((ULONG *) (pjSrc + 12));

                *((ULONG*) (pjDst + 8)) = (ul1 << 8) | ((ul0 >> 16) & 0xff);

                pjSrc += 16;
                pjDst += 12;
            }

            for (i = cEndPixels; i != 0; i--)
            {
                *(pjDst)     = *(pjSrc);
                *(pjDst + 1) = *(pjSrc + 1);
                *(pjDst + 2) = *(pjSrc + 2);

                pjSrc += 4;
                pjDst += 3;
            }

            if (--cy == 0)
                break;

            pjSrc += lSrcSkip;
            pjDst += lDstSkip;
        }

        VERIFYS32D24(psb);
        return;
    }

    pfnXlate = pxlo->pfnXlateBetweenBitfields();

    while (1)
    {
        i = cx;
        do {
            ul = pfnXlate(pxlo, *((ULONG*) pjSrc));

            *(pjDst)     = (BYTE) (ul);
            *(pjDst + 1) = (BYTE) (ul >> 8);
            *(pjDst + 2) = (BYTE) (ul >> 16);

            pjSrc += 4;
            pjDst += 3;

        } while (--i != 0);

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }

    VERIFYS32D24(psb);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\gre\srcblt8.cxx ===
/******************************Module*Header*******************************\
* Module Name: srcblt8.cxx
*
* This contains the bitmap simulation functions that blt to a 8 bit/pel
* DIB surface.
*
* Created: 07-Feb-1991 19:27:49
* Author: Patrick Haluptzok patrickh
*
* NB:  The function <vSrcCopySRLE8D8()> was removed from here on 22 Jan 1992
*      and placed in the module <rle8blt.cxx>.  - Andrew Milton (w-andym)
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.hxx"

/*******************Public*Routine*****************\
* vSrcCopyS1D8
*
* There are three main loops in this function.
*
* The first loop deals with the full two dwords part of
* the Dst while fetching/shifting the matching 8 bits
* from the Src.
*
* The second loop deals with the left most strip
* of the partial two dwords in Dst.
*
* The third loop deals with the right most strip
* of the partial two dwords in Dst.
*
* We use a 16 entry dword table to expand the
* Src bits.  We walk thru Src one byte at a time
* and expand to Dst two Dwords at a time.  Dst Dword
* is aligned.
*
* History:
* 17-Oct-1994 -by- Lingyun Wang [lingyunw]
* Wrote it.
*
\**************************************************/

VOID vSrcCopyS1D8(PBLTINFO psb)
{
    BYTE  jSrc;    // holds a source byte
    BYTE  jDst;    // holds a dest byte
    INT   iSrc;    // bit position in the first Src byte
    INT   iDst;    // bit position in the first 8 Dst bytes
    PBYTE pjDst;   // pointer to the Src bytes
    PBYTE pjSrc;   // pointer to the Dst bytes
    LONG  xSrcEnd = psb->xSrcEnd;
    LONG  cy;      // number of rows
    LONG  cx;      // number of pixels
    BYTE  jAlignL;  // alignment bits to the left
    BYTE  jAlignR;  // alignment bits to the right
    LONG  cFullBytes;  //number of full 8 bytes dealed with
    BOOL  bNextByte;
    LONG  xDstEnd;
    LONG  lDeltaDst;
    LONG  lDeltaSrc;
    BYTE  jB = (BYTE) (psb->pxlo->pulXlate[0]);
    BYTE  jF = (BYTE) (psb->pxlo->pulXlate[1]);
    ULONG ulB = (ULONG)(psb->pxlo->pulXlate[0]);
    ULONG ulF = (ULONG)(psb->pxlo->pulXlate[1]);
    ULONG aulTable[16];
    UCHAR aucTable[2];
    INT   count;
    INT   i;
    BOOL  bNextSrc=TRUE;

    // We assume we are doing left to right top to bottom blting
    ASSERTGDI(psb->xDir == 1, "vSrcCopyS1D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS1D8 - direction not up to down");

    ASSERTGDI(psb->cy != 0, "ERROR: Src Move cy == 0");

    //DbgPrint ("vsrccopys1d8\n");

    // Generate aucTable
    aucTable[0] = jB;
    aucTable[1] = jF;

    // Generate ulTable
    ULONG ulVal = ulB;

    ulVal = ulVal | (ulVal << 8);
    ulVal = ulVal | (ulVal << 16);
    aulTable[0] = ulVal;            // 0 0 0 0
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[8] = ulVal;            // 0 0 0 1
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[4] = ulVal;            // 0 0 1 0
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[10] = ulVal;            // 0 1 0 1
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[5] = ulVal;           // 1 0 1 0
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[ 2] = ulVal;           // 0 1 0 0
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[ 9] = ulVal;           // 1 0 0 1
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[12] = ulVal;           // 0 0 1 1
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[14] = ulVal;           // 0 1 1 1
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[15] = ulVal;           // 1 1 1 1
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[ 7] = ulVal;           // 1 1 1 0
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[11] = ulVal;           // 1 1 0 1
    ulVal <<= 8;
    ulVal |=  ulF;
    aulTable[13] = ulVal;           // 1 0 1 1
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[06] = ulVal;           // 0 1 1 0
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[ 3] = ulVal;           // 1 1 0 0
    ulVal <<= 8;
    ulVal |=  ulB;
    aulTable[ 1] = ulVal;           // 1 0 0 0

     //Get Src and Dst start positions
    iSrc = psb->xSrcStart & 0x0007;
    iDst = psb->xDstStart & 0x0007;

    // Checking alignment
    // If Src starting point is ahead of Dst
    if (iSrc < iDst)
        jAlignL = 8 - (iDst - iSrc);
    // If Dst starting point is ahead of Src
    else
        jAlignL = iSrc - iDst;

    jAlignR = 8 - jAlignL;

    cx=psb->cx;

    xDstEnd = psb->xDstStart + cx;

    lDeltaDst = psb->lDeltaDst;
    lDeltaSrc = psb->lDeltaSrc;

    // check if there is a next 8 bytes
    bNextByte = !((xDstEnd>>3) ==
                 (psb->xDstStart>>3));

    // if Src and Dst are aligned, use a separete loop
    // to obtain better performance;
    // If not, we shift the Src bytes to match with
    // the Dst 8 bytes (2 dwords) one at a time

    if (bNextByte)
    {
        long iStrideSrc;
        long iStrideDst;
        PBYTE pjSrcEnd;  //pointer to the Last full Src byte

        // Get first Dst full 8 bytes (2 dwords expanding from
        // 1 Src byte)
        pjDst = psb->pjDst + ((psb->xDstStart+7)&~0x07);

        // Get the Src byte that matches the first Dst
        // full 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcStart+((8-iDst)&0x07)) >> 3);

        //Get the number of full bytes
        cFullBytes = (xDstEnd>>3)-((psb->xDstStart+7)>>3);

        //the increment to the full byte on the next scan line
        iStrideDst = lDeltaDst - cFullBytes*8;
        iStrideSrc = lDeltaSrc - cFullBytes;

        // deal with our special case
        cy = psb->cy;

        if (!jAlignL)
        {
            while (cy--)
            {
                pjSrcEnd = pjSrc+cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = *pjSrc++;

                    *(PULONG) (pjDst + 0) = aulTable[jSrc >> 4];
                    *(PULONG) (pjDst + 4) = aulTable[jSrc & 0X0F];

                    pjDst +=8;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }

        }   //end of if (!jAlignL)


        else  // if not aligned
        {
            BYTE jRem;     //remainder

            while (cy--)
            {
                jRem = *pjSrc << jAlignL;

                pjSrcEnd = pjSrc+cFullBytes;

                while (pjSrc != pjSrcEnd)
                {
                    jSrc = ((*(++pjSrc))>>jAlignR) | jRem;

                    *(PULONG) (pjDst + 0) = aulTable[jSrc >> 4];
                    *(PULONG) (pjDst + 4) = aulTable[jSrc & 0X0F];

                    pjDst +=8;

                    //next remainder
                    jRem = *pjSrc << jAlignL;
                }

                pjDst += iStrideDst;
                pjSrc += iStrideSrc;
            }
        } //else
    } //if
    // End of our dealing with the full bytes

    //Deal with the starting pixels
    if (!bNextByte)
    {
        count = cx;
        bNextSrc = ((iSrc + cx) > 8);
    }
    else
        count = 8-iDst;

    if (iDst | !bNextByte)
    {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        pjDst = psb->pjDst + psb->xDstStart;
        pjSrc = psb->pjSrc + (psb->xSrcStart>>3);

        cy = psb->cy;

        if (iSrc > iDst)
        {
            if (bNextSrc)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;
                    jSrc |= *(pjSrc+1) >> jAlignR;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;

                    pjDstEnd = pjDst + count;

                    while (pjDstTemp != pjDstEnd)
                    {
                        * (pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                        jSrc <<= 1;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }
            else // if (!bNextSrc)
            {
                while (cy--)
                {
                    jSrc = *pjSrc << jAlignL;

                    jSrc <<= iDst;

                    pjDstTemp = pjDst;

                    pjDstEnd = pjDst + count;

                    while (pjDstTemp != pjDstEnd)
                    {
                        * (pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                        jSrc <<= 1;
                    }

                    pjDst += lDeltaDst;
                    pjSrc += lDeltaSrc;

                }
            }    //else
        }  // if
        else //if (iSrc <= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << iSrc;

                pjDstTemp = pjDst;

                pjDstEnd = pjDst + count;

                while (pjDstTemp != pjDstEnd)
                {
                    *(pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }

        }

   } //if

   // Deal with the ending pixels
   if ((xDstEnd & 0x0007)
       && bNextByte)
   {
        PBYTE pjDstTemp;
        PBYTE pjDstEnd;

        // Get the last partial bytes on the
        // scan line
        pjDst = psb->pjDst+(xDstEnd&~0x07);

        // Get the Src byte that matches the
        // right partial Dst 8 bytes
        pjSrc = psb->pjSrc + ((psb->xSrcEnd-1) >>3);

        // Get the ending position in the last
        // Src and Dst bytes
        iSrc = (psb->xSrcEnd-1) & 0x0007;
        iDst = (xDstEnd-1) & 0x0007;

        count = iDst+1;

        cy = psb->cy;

        if (iSrc >= iDst)
        {
            while (cy--)
            {
                jSrc = *pjSrc << jAlignL;

                pjDstTemp = pjDst;

                pjDstEnd = pjDst + count;

                while (pjDstTemp != pjDstEnd)
                {
                    * (pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                }

                pjDst += lDeltaDst;
                pjSrc += lDeltaSrc;
            }
        }
        else //if (iSrc < iDst)
        {
            while (cy--)
            {
                 jSrc = *(pjSrc-1) << jAlignL;

                 ASSERTGDI(pjSrc <= (psb->pjSrc+lDeltaSrc*(psb->cy-cy-1)+((psb->xSrcEnd-1)>>3)),
                           "vSrcCopyS1D8 - pjSrc passed the last byte");

                 jSrc |= *pjSrc >> jAlignR;

                 pjDstTemp = pjDst;

                 pjDstEnd = pjDst + count;

                 while (pjDstTemp != pjDstEnd)
                 {
                    *(pjDstTemp++) = aucTable[(jSrc&0x80)>>7];

                    jSrc <<= 1;
                 }

                 pjDst += lDeltaDst;
                 pjSrc += lDeltaSrc;
            }
        }
    } //if

}

/******************************Public*Routine******************************\
* vSrcCopyS4D8
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS4D8(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS4D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS4D8 - direction not up to down");

    BYTE  jSrc;
    LONG  i;
    PBYTE pjDst;
    PBYTE pjSrc;
    PBYTE pjDstHolder = psb->pjDst + psb->xDstStart;
    PBYTE pjSrcHolder  = psb->pjSrc + (psb->xSrcStart >> 1);
    ULONG cx = psb->xSrcEnd - psb->xSrcStart;
    ULONG cy = psb->cy;
    PULONG pulTranslate = psb->pxlo->pulXlate;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    do {
        pjDst = pjDstHolder;
	pjSrc = pjSrcHolder;

	if ((psb->xSrcStart & 0x1) != 0)
	{
            jSrc = *(pjSrc++);
        }

	for (i = psb->xSrcStart; i < psb->xSrcEnd; i += 1)
	{
	    if ((i & 0x1) != 0)
	    {
		*(pjDst++) = (BYTE) pulTranslate[jSrc & 0x0F];
	    }
	    else
	    {
                jSrc = *(pjSrc++);
		*(pjDst++) = (BYTE) pulTranslate[((ULONG) (jSrc & 0xF0)) >> 4];
            }
        }

        pjSrcHolder += psb->lDeltaSrc;
        pjDstHolder += psb->lDeltaDst;
	cy -= 1;

    } while(cy > 0);
}

/******************************Public*Routine******************************\
* vSrcCopyS8D8
*
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D8(PBLTINFO psb)
{
// We assume we are doing left to right top to bottom blting.
// If it was on the same surface we would be doing the identity case.

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS8D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS8D8 - direction not up to down");

// These are our holding variables

#if MESSAGE_BLT
    DbgPrint("Now entering vSrcCopyS8D8\n");
#endif

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + psb->xDstStart;
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;
    PULONG pulXlate = psb->pxlo->pulXlate;
    LONG lSrcSkip = psb->lDeltaSrc - cx;
    LONG lDstSkip = psb->lDeltaDst - cx;
    ULONG cStartPixels;
    ULONG cMiddlePixels;
    ULONG cEndPixels;
    ULONG i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 1-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((-((LONG_PTR) pjDst)) & 3);

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    while(1)
    {
        // Write pixels a byte at a time until we're 'dword' aligned on
        // the destination:

        for (i = cStartPixels; i != 0; i--)
        {
            *pjDst++ = (BYTE) pulXlate[*pjSrc++];
        }

        // Now write pixels a dword at a time.  This is almost a 4x win
        // over doing byte writes if we're writing to frame buffer memory
        // over the PCI bus on Pentium class systems, because the PCI
        // write throughput is so slow:

        for (i = cMiddlePixels; i != 0; i--)
        {
            *((ULONG*) (pjDst)) = (pulXlate[*(pjSrc)])
                                | (pulXlate[*(pjSrc + 1)] << 8)
                                | (pulXlate[*(pjSrc + 2)] << 16)
                                | (pulXlate[*(pjSrc + 3)] << 24);
            pjDst += 4;
            pjSrc += 4;
        }

        // Take care of the end alignment:

        for (i = cEndPixels; i != 0; i--)
        {
            *pjDst++ = (BYTE) pulXlate[*pjSrc++];
        }

        if (--cy == 0)
            break;

        pjSrc += lSrcSkip;
        pjDst += lDstSkip;
    }
}

/******************************Public*Routine******************************\
* vSrcCopyS8D8IdentityLtoR
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps
* and screens.
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D8IdentityLtoR(PBLTINFO psb)
{
#if MESSAGE_BLT
    DbgPrint("Now entering s8d8 identity L to R\n");
#endif

    ASSERTGDI(psb->xDir == 1, "S8D8identLtoR has wrong value xDir");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + psb->xDstStart;
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

#if MESSAGE_BLT
    DbgPrint("xdir: %ld  cy: %lu  xSrcStart %lu  xDstStart %lu xSrcEnd %lu cx %lu\n",
             psb->xDir, cy, psb->xSrcStart, psb->xDstStart, psb->xSrcEnd, cx);
#endif

    do {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory(pjDst,pjSrc,cx);
        else
            RtlMoveMemory((PVOID)pjDst, (PVOID)pjSrc, cx);
        pjSrc += psb->lDeltaSrc;
        pjDst += psb->lDeltaDst;
        cy -= 1;
    } while(cy > 0);
}

/******************************Public*Routine******************************\
* vSrcCopyS8D8IdentityRtoL
*
* This is the special case no translate blting.  All the SmDn should have
* them if m==n.  Identity xlates only occur amoung matching format bitmaps
* and screens.
*
* History:
*  06-Feb-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

VOID vSrcCopyS8D8IdentityRtoL(PBLTINFO psb)
{
#if MESSAGE_BLT
    DbgPrint("Now entering s8d8 identity R to L\n");
#endif

    ASSERTGDI(psb->xDir == -1, "S8D8identR to L has wrong value xDir");

// These are our holding variables

    PBYTE pjSrc  = psb->pjSrc + psb->xSrcStart;
    PBYTE pjDst  = psb->pjDst + psb->xDstStart;
    ULONG cx     = psb->cx;
    ULONG cy     = psb->cy;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

#if MESSAGE_BLT
    DbgPrint("xdir: %ld  cy: %lu  xSrcStart %lu  xDstStart %lu xSrcEnd %lu cx %lu\n",
             psb->xDir, cy, psb->xSrcStart, psb->xDstStart, psb->xSrcEnd, cx);
#endif

    pjSrc = pjSrc - cx + 1;
    pjDst = pjDst - cx + 1;

    do {
        if(psb->fSrcAlignedRd)
            vSrcAlignCopyMemory(pjDst,pjSrc,cx);
        else
            RtlMoveMemory((PVOID)pjDst, (PVOID)pjSrc, cx);
        pjSrc += psb->lDeltaSrc;
        pjDst += psb->lDeltaDst;
        cy -= 1;
    } while(cy > 0);
}

/**************************************************************************\
* vSrcCopyS16D8
*   Use translation table from 555RGB to surface palette. Not as accurare
*   as full nearest search but much faster.
*
* Arguments:
*
*   psb - bitblt info
*
* Return Value:
*
*   none
*
* History:
*
*    2/24/1997 Mark Enstrom [marke]
*
\**************************************************************************/

VOID vSrcCopyS16D8(PBLTINFO psb)
{
    // We assume we are doing left to right top to bottom blting

    ASSERTGDI(psb->xDir == 1, "vSrcCopyS16D8 - direction not left to right");
    ASSERTGDI(psb->yDir == 1, "vSrcCopyS16D8 - direction not up to down");

    // These are our holding variables

    ULONG   cx          = psb->cx;
    ULONG   cy	        = psb->cy;
    XLATE  *pxlo        = psb->pxlo;
    PUSHORT pusSrc = (PUSHORT) (psb->pjSrc + (2 * psb->xSrcStart));
    PBYTE   pjDst       = psb->pjDst + psb->xDstStart;
    PBYTE   pxlate555   = NULL;
    PUSHORT pusSrcTemp;
    PBYTE   pjDstTemp;
    ULONG   cStartPixels;
    ULONG   cMiddlePixels;
    ULONG   cEndPixels;
    INT     i;

    ASSERTGDI(cy != 0, "ERROR: Src Move cy == 0");

    // 'cStartPixels' is the minimum number of 1-byte pixels we'll have to
    // write before we have dword alignment on the destination:

    cStartPixels = (ULONG)((-((LONG_PTR) pjDst)) & 3);

    if (cStartPixels > cx)
    {
        cStartPixels = cx;
    }
    cx -= cStartPixels;

    cMiddlePixels = cx >> 2;
    cEndPixels = cx & 3;

    PFN_XLATE_RGB_TO_PALETTE pfnXlate = XLATEOBJ_ulIndex