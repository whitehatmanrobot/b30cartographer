**) &spISTUpdateAdvanced);
	if (FAILED (hr))
	{
		TRACE (L"Updateable store does not support IID_ISimpleTableAdvanced interface. Unable to handle detailed errors");
		return hr;
	}

	ULONG cNrErrs;

	hr = spISTUpdateAdvanced->GetDetailedErrorCount (&cNrErrs);
	if (FAILED (hr))
	{
		TRACE (L"GetDetailedErrorCount on Updateable store failed");
		return hr;
	}

	STErr errDetailed;
	for (ULONG idx=0; idx < cNrErrs; ++idx)
	{
		hr = spISTUpdateAdvanced->GetDetailedError (idx, &errDetailed);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get detailed error %ld in Updateable store", idx);
			return hr;
		}

		hr = spISTController->AddDetailedError (&errDetailed);
		if (FAILED (hr))
		{
			TRACE (L"Unable to add detailed error to Merge Coordinator cache");
			return hr;
		}
	}

	return E_ST_DETAILEDERRS;
}

//=================================================================================
// Function: CMergeCoordinator::GetTransformer
//
// Synopsis: This function creates a transformer by using the protocol name.
//
// Return Value: S_OK, valid transformer in m_spTranformer
//=================================================================================
HRESULT
CMergeCoordinator::GetTransformer ()
{
	CTransformerFactory transformerFactory;

	return transformerFactory.GetTransformer (m_spSTDisp, m_wszProtocol, &m_spTransformer);
}

//=================================================================================
// Function: CMergeCoordinator::IsValidSelector
//
// Synopsis: This function checks if a selector string contains /../ or /./ If it contains
//           this, the selector is considered invalid, and false is returned. Note that / and \
//           are considered the same character. Actually anything that is of /...../ will be seen
//           as invalid
//
// Arguments: [wszSelector] - selector to check for /../ and /./ 
//=================================================================================
bool
CMergeCoordinator::IsValidSelector (LPCWSTR wszSelector) const
{
	ASSERT (wszSelector != 0);

	enum {STATE_START, 
		  STATE_BEGINSLASH_FOUND, 
		  STATE_FIRSTDOT_FOUND} iState = STATE_START;

	SIZE_T iLen = wcslen (wszSelector);
	for (ULONG idx=0; idx <iLen; ++idx)
	{
		switch (iState)
		{
		case STATE_START:
			if (wszSelector[idx] == L'/' || wszSelector[idx] == L'\\')
			{
				iState = STATE_BEGINSLASH_FOUND;
			}
			break;
		case STATE_BEGINSLASH_FOUND:
			if (wszSelector[idx] == L'.')
			{
				iState = STATE_FIRSTDOT_FOUND;
			}
			else
			{
				iState = STATE_START;
			}
			break;
		case STATE_FIRSTDOT_FOUND:
			if (wszSelector[idx] == L'.')
			{
				iState = STATE_FIRSTDOT_FOUND;
			}
			else if (wszSelector[idx] == L'/' || wszSelector[idx] == L'\\')
			{
				return false;
			}
			else
			{
				iState = STATE_START;
			}
			break;
		}
	}

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\interceptor\stconfigstorewrap.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    stconfigstorewrap.cpp

$Header: $

Abstract:

Author:
    marcelv 	2/27/2001		Initial Release

Revision History:

--**************************************************************************/

#include "stconfigstorewrap.h"

CSTConfigStoreWrap::CSTConfigStoreWrap ()
{
	wszLogicalPath	= 0;
	aQueryCells		= 0;
	cNrQueryCells	= 0;
	fAllowOverride	= true;
}

CSTConfigStoreWrap::~CSTConfigStoreWrap ()
{
	delete [] wszLogicalPath;
	wszLogicalPath = 0;

	for (ULONG jdx=0; jdx < cNrQueryCells; ++jdx)
	{
		delete [] aQueryCells[jdx].pData;
		aQueryCells[jdx].pData = 0;
	}
		
	delete [] aQueryCells;
	aQueryCells = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\interceptor\mergeinterceptor.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    mergeinterceptor.h

$Header: $

Abstract:
	Implements the merge interceptor

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __MERGEINTERCEPTOR_H__
#define __MERGEINTERCEPTOR_H__

#pragma once

#include "catalog.h"
#include "catmacros.h"

/**************************************************************************++
Class Name:
    CMergeInterceptor

Class Description:
    The Merge interceptor is responsible for intercepting merge requests for a 
	particular table. The interceptor checks the query cells for TRANSFORMER
	cells. When it finds a transformer cell it will invoke the merge coordinator, 
	and forward all the work to it. When there is no transformer cell, the merge
	interceptor returns E_OMIT_DISPENSER to indicate that it couldn't handle the
	request. The Merge interceptor always needs to be the first interceptor defined
	for a particular table.

Constraints:
	The Merge Interceptor is a singleton and should be thread-safe
--*************************************************************************/
class CMergeInterceptor : public ISimpleTableInterceptor
{
public:
	CMergeInterceptor ();
	~CMergeInterceptor ();

	//IUnknown
    STDMETHOD (QueryInterface)      (REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();

	//ISimpleTableInterceptor
    STDMETHOD(Intercept) (
                        LPCWSTR                 i_wszDatabase,
                        LPCWSTR                 i_wszTable, 
                        ULONG                   i_TableID,
                        LPVOID                  i_QueryData,
                        LPVOID                  i_QueryMeta,
                        DWORD                   i_eQueryFormat,
                        DWORD                   i_fTable,
                        IAdvancedTableDispenser* i_pISTDisp,
                        LPCWSTR                 i_wszLocator,
                        LPVOID                  i_pSimpleTable,
                        LPVOID*                 o_ppv
                        );
private:
	// we're not intending to make copies, because merge interceptor is singleton
	CMergeInterceptor (const CMergeInterceptor& );
	CMergeInterceptor& operator=(const CMergeInterceptor& );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\interceptor\stconfigstorewrap.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    stconfigstorewrap.h

$Header: $

Abstract:

Author:
    marcelv 	2/27/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __STCONFIGSTOREWRAP_H__
#define __STCONFIGSTOREWRAP_H__

#pragma once

#include "catalog.h"

class CSTConfigStoreWrap : public STConfigStore
{
public:
	CSTConfigStoreWrap ();
	~CSTConfigStoreWrap ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\mergers\listappend.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    listappend.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "listappend.h"
#include "smartpointer.h"

//=================================================================================
// Function: CListAppend::CListAppend
//
// Synopsis: Default constructor
//=================================================================================
CListAppend::CListAppend ()
{
}

//=================================================================================
// Function: CListAppend::~CListAppend
//
// Synopsis: Default Destructor
//=================================================================================
CListAppend::~CListAppend ()
{
}


STDMETHODIMP
CListAppend::Initialize (ULONG i_cNrColumns, ULONG i_cNrPKColumns, ULONG *i_aPKColumns)
{
	ASSERT (i_aPKColumns != 0);

	HRESULT hr = InternalInitialize (i_cNrColumns, i_cNrPKColumns, i_aPKColumns);
	if (FAILED (hr))
	{
		TRACE (L"InternalInitialize failed");
		return hr;
	}
	return hr;
}

STDMETHODIMP
CListAppend::Merge (ISimpleTableRead2 * i_pSTRead, ISimpleTableWrite2 * io_pCache, STMergeContext *i_pContext)
{
	ASSERT (i_pSTRead != 0);
	ASSERT (io_pCache != 0);
	ASSERT (i_pContext != 0);

	HRESULT hr = S_OK;

	ASSERT (m_apvValues != 0);
	ASSERT (m_cNrColumns != 0);

	TSmartPointerArray<LPVOID> saPKValues = new LPVOID[m_cNrPKColumns];
	if (saPKValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	// need to handle primary key values
	for (ULONG iRow=0; ;++iRow)
	{
		hr = i_pSTRead->GetColumnValues (iRow, m_cNrColumns, 0, 0, m_apvValues);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}
		if (FAILED (hr))
		{
			TRACE (L"GetColumnValues failed");
			return hr;
		}

		// we have a new row. See if we are allowed to override
		if (!i_pContext->fAllowOverride)
		{
			TRACE (L"Row found while AllowOverride is false");
			return E_ST_DISALLOWOVERRIDE;
		}


		// Find out if the row already exists. If not, create a new row instead
		for (ULONG idx = 0; idx < m_cNrPKColumns; ++idx)
		{
			saPKValues[idx] = m_apvValues[m_aPKColumns[idx]];
		}
		
		ULONG iWriteRow;
		hr = io_pCache->GetWriteRowIndexByIdentity (0, saPKValues, &iWriteRow);
		if (hr == E_ST_NOMOREROWS)
		{
			// create a new row and use that row to update everything
			hr = io_pCache->AddRowForInsert (&iWriteRow);
		}

		if (FAILED (hr))
		{
			TRACE (L"Unable to add a new row in parent cache during POM");
			return hr;
		}

		// and write the values
		hr = io_pCache->SetWriteColumnValues (iWriteRow, m_cNrColumns, 0, 0, m_apvValues);
		if (FAILED (hr))
		{
			return hr;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\mergers\listappend.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    listappend.h

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __LISTAPPEND_H__
#define __LISTAPPEND_H__

#pragma once

#include "mergerbase.h"

/**************************************************************************++
Class Name:
    CListAppend

Class Description:
    Merges items by appending them in a list. In case of two items with the
	same primary key, the last item wins.

Constraints:

--*************************************************************************/
class CListAppend: public CMergerBase
{
public:
	CListAppend  ();
	virtual ~CListAppend ();

	STDMETHOD (Initialize) (ULONG i_cNrColumns, ULONG i_cNrPKColumns, ULONG *i_aPKColumns);
	STDMETHOD (Merge) (ISimpleTableRead2 * i_pSTRead, ISimpleTableWrite2 * io_pCache, STMergeContext *i_pContext);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\mergers\listmerge.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    listmerge.cpp

$Header: $

Abstract:
	ListMerge merger implementation
Author:
    marcelv 	10/24/2000		Initial Release

Revision History:

--**************************************************************************/

#include "listmerge.h"
#include "smartpointer.h"

typedef enum DIRECTIVES
{
    eDIRECTIVE_ADD		= 0,  // <add .../>
    eDIRECTIVE_REMOVE	= 1,  // <remove .../>
    eDIRECTIVE_CLEAR	= 2   // <clear .../>
};


//=================================================================================
// Function: CListMerge::CListMerge
//
// Synopsis: Default constructor
//=================================================================================
CListMerge::CListMerge ()
{
}

//=================================================================================
// Function: CListAppend::~CListAppend
//
// Synopsis: Default Destructor
//=================================================================================
CListMerge::~CListMerge ()
{
}

//=================================================================================
// Function: CListMerge::Initialize
//
// Synopsis: Initializes the list merger
//
// Arguments: [i_cNrColumns] - nr of columns in table that gets merged
//            [i_cNrPKColumns] - nr of primary key columns
//            [i_aPKColumns] - indexes of primary key columns
//=================================================================================
STDMETHODIMP
CListMerge::Initialize (ULONG i_cNrColumns, ULONG i_cNrPKColumns, ULONG *i_aPKColumns)
{
	ASSERT (i_aPKColumns != 0);

	HRESULT hr = InternalInitialize (i_cNrColumns, i_cNrPKColumns, i_aPKColumns);
	if (FAILED (hr))
	{
		TRACE (L"InternalInitialize failed for ListMerge merger");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CListMerge::Merge
//
// Synopsis: Does ListMerge Merge. The assumption is that column 0 contains a directive
//           column of the following format:
//           <add  ... >	add a new row to the MC write cache
//           <remove ...>	remove a row from the MC write cache
//           <clear ...>	remove all rows from the MC write cache
//			It is assumed that:
//				add == 0
//				remove == 1
//              clear == 2
//
// Arguments: [i_pSTRead] - Table that needs to be merged into the cache
//            [io_pCache] - Merge Coordinator Cache
//=================================================================================
STDMETHODIMP
CListMerge::Merge (ISimpleTableRead2 * i_pSTRead, ISimpleTableWrite2 * io_pCache, STMergeContext *i_pContext)
{
	ASSERT (i_pSTRead != 0);
	ASSERT (io_pCache != 0);
	ASSERT (i_pContext != 0);

	// do we have a merge directive column, and is it the zero's column

	m_pCache	= io_pCache;
 
	// find out in the first column has DIRECTIVE flags specified. If not, we
	// error out immediately, because we assume in the rest of the List Merge Merger
	// that this is going to be the case
	SimpleColumnMeta zeroColMeta;
	HRESULT hr = io_pCache->GetColumnMetas (1, 0, &zeroColMeta);
	if (FAILED (hr))
	{
		TRACE (L"Unable to retrieve column meta for column 0");
		return hr;
	}

	if (!(zeroColMeta.fMeta & fCOLUMNMETA_DIRECTIVE))
	{
		TRACE(L"Column 0 does not have DIRECTIVE metaflag specified.");
		return E_ST_NEEDDIRECTIVE;
	}

	// Get all rows and take the appropriate action depending on the directive
	for (ULONG iRow=0; ;++iRow)
	{
		hr = i_pSTRead->GetColumnValues (iRow, m_cNrColumns, 0, 0, m_apvValues);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}
		if (FAILED (hr))
		{
			TRACE (L"GetColumnValues failed in Merge of ListMerge Merger");
			return hr;
		}

		// found at least a row. If we don't allow override, we bail out here
		if (!i_pContext->fAllowOverride)
		{
			TRACE (L"Row found while AllowOverride is false");
			return E_ST_DISALLOWOVERRIDE;
		}

		ULONG iDirective = *((ULONG *)m_apvValues[0]);

		switch (iDirective)
		{
		case  eDIRECTIVE_ADD:
			hr = AddRow ();
			break;
		case eDIRECTIVE_REMOVE:
			hr = RemoveRow ();
			break;
		case eDIRECTIVE_CLEAR:
			hr = Clear ();
			break;
		default:
			TRACE(L"Unknown directive specified: %d", iDirective);
			hr = E_ST_UNKNOWNDIRECTIVE;
			break;
		}

		if (FAILED (hr))
		{
			TRACE(L"Failed to process row in list merge merger");
			return hr;
		}
	}
	
	return hr;
}

//=================================================================================
// Function: CListMerge::AddRow
//
// Synopsis: Adds a new row to the MC write cache. First it searches for an existing
//           row. When we find an existing row, it could be marked as either INSERT
//           or DELETE, so we always have to set it to INSERT. Also, all old values
//           will be overwritten, even when the row was marked as INSERT
//=================================================================================
HRESULT
CListMerge::AddRow ()
{
	ASSERT (m_apvValues != 0);
	ASSERT (m_pCache != 0);

	// Check if the row exists in the write cache. Note that we are searching by PK
	// columns without the directive, so we always should find only one entry at most
	ULONG iWriteRow = 0;
	HRESULT hr = m_pCache->GetWriteRowIndexBySearch (0, m_cNrPKColumns - 1, 
													 m_aPKColumns + 1, 0,
		                                             m_apvValues, &iWriteRow);

	if (hr == E_ST_NOMOREROWS)
	{
		hr = m_pCache->AddRowForInsert (&iWriteRow);
	}

	if (FAILED (hr))
	{
		TRACE(L"GetWriteRowIndexBySearch failed in AddRow of CListMerge");
		return hr;
	}

	// write the actual values to the cache
	hr = m_pCache->SetWriteColumnValues (iWriteRow, m_cNrColumns, 0, 0, m_apvValues);
	if (FAILED (hr))
	{
		TRACE (L"SetWriteColumnValues failed in CListMerge");
		return hr;
	}

	CComPtr<ISimpleTableController> spController;
	hr = m_pCache->QueryInterface (IID_ISimpleTableController, (void **) &spController);
	if (FAILED (hr))
	{
		TRACE(L"Unable to get ISimpleTableController interface");
		return hr;
	}

	// always mark the row as insert, because it could be an old row that was marked
	// as DELETED
	hr = spController->SetWriteRowAction (iWriteRow, eST_ROW_INSERT);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set write row action to INSERT");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CListMerge::RemoveRow
//
// Synopsis: Removes a single row from the merge coordinator cache. It does this by
//           marking the row as deleted.
//=================================================================================
HRESULT
CListMerge::RemoveRow ()
{
	ASSERT (m_apvValues != 0);
	ASSERT (m_pCache != 0);
	HRESULT hr = S_OK;

	ULONG iWriteRow = 0;
	hr = m_pCache->GetWriteRowIndexBySearch (0, m_cNrPKColumns - 1, m_aPKColumns + 1,
		                                         0, m_apvValues, &iWriteRow);

	if (hr == E_ST_NOMOREROWS)
	{
		// no rows found, so nothing to do
		return S_OK;
	}

	if (FAILED (hr))
	{
		TRACE (L"GetWriteRowIndexBySearch failed if CListMerge::RemoveRow");
		return hr;
	}

	CComPtr<ISimpleTableController> spController;
	hr = m_pCache->QueryInterface (IID_ISimpleTableController, (void **) &spController);
	if (FAILED (hr))
	{
		TRACE(L"Unable to get ISimpleTableController interface");
		return hr;
	}

	// always set row as insert
	hr = spController->SetWriteRowAction (iWriteRow, eST_ROW_DELETE);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set write row action to DELETE");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CListMerge::Clear
//
// Synopsis: Deletes all rows from the merge coordinator cache by marking all the
//           rows in the write cache as deleted
//=================================================================================
HRESULT
CListMerge::Clear ()
{
	ASSERT (m_apvValues != 0);
	ASSERT (m_pCache != 0);

	// need to get the controller interface to call SetWriteRowAction
	CComPtr<ISimpleTableController> spController;
	HRESULT hr = m_pCache->QueryInterface (IID_ISimpleTableController, (void **) &spController);
	if (FAILED (hr))
	{
		TRACE(L"Unable to get ISimpleTableController interface");
		return hr;
	}
	
	// mark all rows as deleted
	
	for (ULONG idx=0; ; ++idx)
	{
		hr = spController->SetWriteRowAction (idx, eST_ROW_DELETE);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}
	
		if (FAILED (hr))
		{
			TRACE (L"Unable to set write row action to DELETE");
			return hr;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\mergers\mergerbase.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    mergerbase.h

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __MERGERBASE_H__
#define __MERGERBASE_H__

#pragma once

#include "catalog.h"
#include "catmacros.h"

/**************************************************************************++
Class Name:
    CMergerBase

Class Description:
    Base class for mergers. Implements the IUnknown interface, and keeps variables
	that are used by almost all mergers. It is recommended that mergers derive from
	this base class

Constraints:
	When a merger inherits from this class, it cannot implement any other interface
	then ISimpleTableMerge. If it needs to implement this as well, it needs to implement
	it's own QI method
--*************************************************************************/
class CMergerBase: public ISimpleTableMerge
{
public:
	CMergerBase  ();
	virtual ~CMergerBase ();

	// IUnknown
	STDMETHOD (QueryInterface)      (REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();

protected:
	HRESULT InternalInitialize (ULONG i_cNrColumns, ULONG i_cNrPKColumns, ULONG *i_aPKColumns);

	ULONG    m_cRef;			// reference count
	ULONG    m_cNrColumns;		// number of columns
	ULONG    m_cNrPKColumns;	// number of primary key columns
	ULONG  * m_aPKColumns;		// primary key column indexes
	LPVOID * m_apvValues;		// values
	ULONG  * m_acbSizes;		// ?? needed
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\mergers\listmerge.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    listmerge.h

$Header: $

Abstract:
	ListMerge merger header file
Author:
    marcelv 	10/26/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __LISTMERGE_H__
#define __LISTMERGE_H__

#pragma once

#include "mergerbase.h"

/**************************************************************************++
Class Name:
    CListMerge

Class Description:
    List Merge Merger
	Recognizes the following directives as column 0:
		<add .../>
		<remove .../>
		<clear />
	Whenever an add is found, an new item is inserted, or existing item overwritten
	Whenever a remove is found, the item is removed from the merge cache
	Whenever a clear is found, all items are removed from the merge cache

Constraints:

--*************************************************************************/
class CListMerge : public CMergerBase
{
public:
	CListMerge  ();
	virtual ~CListMerge ();

	STDMETHOD (Initialize) (ULONG i_cNrColumns, ULONG i_cNrPKColumns, ULONG *i_aPKColumns);
	STDMETHOD (Merge) (ISimpleTableRead2 * i_pSTRead, ISimpleTableWrite2 * io_pCache, STMergeContext *i_pContext);
private:
	HRESULT AddRow ();
	HRESULT RemoveRow ();
	HRESULT Clear ();

	CComPtr<ISimpleTableWrite2> m_pCache;   // cache
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\mergers\propertyoverride.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    propertyoverride.h

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __PROPERTYOVERRIDE_H__
#define __PROPERTYOVERRIDE_H__

#pragma once
#include "mergerbase.h"
#include "atlbase.h"

class CPropertyOverride: public CMergerBase 
{
public:
	CPropertyOverride ();
	virtual ~CPropertyOverride ();

	// ISimpleTableMerger
	STDMETHOD (Initialize) (ULONG i_cNrColumns, ULONG i_cNrPKColumns, ULONG *i_aPKColumns);
	STDMETHOD (Merge) (ISimpleTableRead2 * i_pSTRead, ISimpleTableWrite2 * io_pCache, STMergeContext *i_pContext);
private:
	HRESULT MergeSingleRow ();

	LPVOID * m_aPKValues;   // array to hold primary key column values (perf improvement)
	ULONG * m_aiColumns;    // indexes of columns that need to be merged

	CComPtr<ISimpleTableWrite2> m_spParent; // pointer to parent
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\mergers\mergerbase.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    mergerbase.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "mergerbase.h"

//=================================================================================
// Function: CMergerBase::CMergerBase
//
// Synopsis: Default constructor
//=================================================================================
CMergerBase::CMergerBase ()
{
	m_cRef			= 0;
	m_cNrColumns	= 0;
	m_cNrPKColumns	= 0;
	m_apvValues		= 0;
	m_aPKColumns	= 0;
}

//=================================================================================
// Function: CMergerBase::~CMergerBase
//
// Synopsis: Default Destructor
//=================================================================================
CMergerBase::~CMergerBase ()
{
	delete [] m_apvValues;
	m_apvValues = 0;

	delete [] m_aPKColumns;
	m_aPKColumns = 0;
}

//=================================================================================
// Function: CMergerBase::AddRef
//
// Synopsis: Default AddRef implementation
//=================================================================================
ULONG
CMergerBase::AddRef ()
{
	return InterlockedIncrement((LONG*) &m_cRef);
}

//=================================================================================
// Function: CMergerBase::Release
//
// Synopsis: Default Release implemenation
//=================================================================================
ULONG
CMergerBase::Release () 
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

//=================================================================================
// Function: CMergerBase::QueryInterface
//
// Synopsis: Default QueryInterface implementation. We support IUnknown and ISimpleTableMerge
//
// Arguments: [riid] - CLSID
//            [ppv] - pointer to valid interface of pointer to null in case interface not found
//=================================================================================
STDMETHODIMP 
CMergerBase::QueryInterface (REFIID riid, void **ppv)
{
	if (0 == ppv) 
	{
		return E_INVALIDARG;
	}

	*ppv = 0;

	if ((riid == IID_ISimpleTableMerge ) || (riid == IID_IUnknown))
	{
		*ppv = (ISimpleTableMerge*) this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	((ISimpleTableMerge*)this)->AddRef ();

	return S_OK;
}

//=================================================================================
// Function: CMergerBase::InternalInitialize
//
// Synopsis: Initialize the merger base class
//
// Arguments: [i_cNrColumns] - number of columns for the merged table
//            [i_cNrPKColumns] - number of primary key columns
//            [i_aPKColumns] - primary key column indexes
//=================================================================================
HRESULT
CMergerBase::InternalInitialize (ULONG i_cNrColumns, ULONG i_cNrPKColumns, ULONG *i_aPKColumns)
{
	ASSERT (i_aPKColumns != 0);

	m_cNrColumns	= i_cNrColumns;
	m_cNrPKColumns	= i_cNrPKColumns;
	m_aPKColumns	= new ULONG[i_cNrPKColumns];
	if (m_aPKColumns == 0)
	{
		return E_OUTOFMEMORY;
	}

	memcpy (m_aPKColumns, i_aPKColumns, sizeof (ULONG) * i_cNrPKColumns);

	m_apvValues = new LPVOID [m_cNrColumns];
	if (m_apvValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\appdomaintransformer.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    appdomaintransformer.h

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __APPDOMAINTRANSFORMER_H__
#define __APPDOMAINTRANSFORMER_H__

#pragma once

#include "transformerbase.h"

/**************************************************************************++
Class Name:
    CAppDomainTransformer

Class Description:
    

Constraints:

--*************************************************************************/
class CAppDomainTransformer : public CTransformerBase
{
public:
	CAppDomainTransformer ();
	virtual ~CAppDomainTransformer ();

    STDMETHOD (Initialize)      (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores);
private:
	// no copies
	CAppDomainTransformer  (const CAppDomainTransformer&);
	CAppDomainTransformer& operator= (const CAppDomainTransformer&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\mergers\propertyoverride.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    propertyoverride.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "propertyoverride.h"
#include "catmacros.h"
#include "smartpointer.h"

//=================================================================================
// Function: CPropertyOverride::CPropertyOverride
//
// Synopsis: Default constructor
//=================================================================================
CPropertyOverride::CPropertyOverride ()
{
	m_aiColumns = 0;
	m_aPKValues = 0;
}

//=================================================================================
// Function: CPropertyOverride::~CPropertyOverride
//
// Synopsis: Default Destructor
//=================================================================================
CPropertyOverride::~CPropertyOverride ()
{
	delete [] m_aiColumns;
	m_aiColumns = 0;

	delete [] m_aPKValues;
	m_aPKValues = 0;
}


//=================================================================================
// Function: CPropertyOverride::Initialize
//
// Synopsis: Initializes the object, and allocates memory for often used structures
//
// Arguments: [i_cNrColumns] - Nr of columns in the table
//            [i_cNrPKColumns] - Nr of primary key columns
//            [i_aPKColumns] - indexes of primary key columns
//=================================================================================
STDMETHODIMP
CPropertyOverride::Initialize (ULONG i_cNrColumns, ULONG i_cNrPKColumns, ULONG *i_aPKColumns)
{
	ASSERT (i_aPKColumns != 0);

	HRESULT hr = InternalInitialize (i_cNrColumns, i_cNrPKColumns, i_aPKColumns);
	if (FAILED (hr))
	{
		TRACE (L"InternalInitialize failed for Property Override Merger");
		return hr;
	}

	m_aPKValues = new LPVOID[m_cNrPKColumns];
	if (m_aPKValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_aiColumns = new ULONG[m_cNrColumns];
	if (m_aiColumns == 0)
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

//=================================================================================
// Function: CPropertyOverride::Merge
//
// Synopsis: Retreives all rows from i_pSTRead and merges them will the rows in io_pCache.
//
// Arguments: [i_pSTRead] - Child table that gets merged
//            [io_pCache] - Parent table that gets merged
//            
// Return Value: 
//=================================================================================
STDMETHODIMP
CPropertyOverride::Merge (ISimpleTableRead2 * i_pSTRead, ISimpleTableWrite2 * io_pCache, STMergeContext *i_pContext)
{
	ASSERT (i_pSTRead != 0);
	ASSERT (io_pCache != 0);
	ASSERT (i_pContext != 0);
	ASSERT (m_apvValues != 0);

	m_spParent = io_pCache;

	HRESULT hr = S_OK;
	for (ULONG iRow = 0; ; ++iRow)
	{
		hr = i_pSTRead->GetColumnValues(iRow, m_cNrColumns, 0, 0, m_apvValues);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}
	
		if (FAILED (hr))
		{
			TRACE(L"GetColumnValues failed in CPropertyOverride::Merge");
			return hr;
		}

		// we have a row. Check if we can override or not
		if (!i_pContext->fAllowOverride)
		{
			TRACE (L"Row found while AllowOverride is false");
			return E_ST_DISALLOWOVERRIDE;
		}


		hr = MergeSingleRow ();
		if (FAILED (hr))
		{
			TRACE (L"Error while trying to merge single row in Property Override Merger");
			return hr;
		}
	}
 	return hr;
};

//=================================================================================
// Function: CPropertyOverride::MergeSingleRow
//
// Synopsis: Merges a single row with the parent. If figures out if the parent already
//           contains a row with the same primary key. If this is the case, it will merge
//           with that row. If it is not the case, the new row will simply be added to
//           the parent row
//
// Arguments: [io_pCache] - poin 
//            
// Return Value: 
//=================================================================================
HRESULT
CPropertyOverride::MergeSingleRow ()
{
	ASSERT (m_apvValues != 0);
	ASSERT (m_aPKValues != 0);
	ASSERT (m_spParent  != 0);

	HRESULT hr = S_OK;
	ULONG idx  = 0;

	// Find out if the row already exists. If not, create a new row instead
	for (idx = 0; idx < m_cNrPKColumns; ++idx)
	{
		m_aPKValues[idx] = m_apvValues[m_aPKColumns[idx]];
	}
	
	ULONG iWriteRow;
	hr = m_spParent->GetWriteRowIndexByIdentity (0, m_aPKValues, &iWriteRow);
	if (hr == E_ST_NOMOREROWS)
	{
		// create a new row and use that row to update everything
		hr = m_spParent->AddRowForInsert (&iWriteRow);
	}

	if (FAILED (hr))
	{
		TRACE (L"Unable to add a new row in parent cache during POM");
		return hr;
	}

	// we found a row (either new one or existing one). Let's update it.
	// First, find the columns that need to be updated.
	
	ULONG cNrColumnsToUpdate = 0;
	memset (m_aiColumns, 0x00, m_cNrColumns * sizeof (m_aiColumns));
	
	for (idx = 0; idx < m_cNrColumns; ++idx)
	{
		if (m_apvValues[idx] != 0)
		{
			m_aiColumns[cNrColumnsToUpdate] = idx;
			cNrColumnsToUpdate++;
		}
	}

	// Only update if we actually have any columns
	if (cNrColumnsToUpdate != 0)
	{
		hr = m_spParent->SetWriteColumnValues (iWriteRow, cNrColumnsToUpdate, m_aiColumns, 0, m_apvValues );
		if (FAILED(hr))
		{
			TRACE (L"SetWriteColumnValues failed in POM");
			return hr;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\configtransformer.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    configtransformer.cpp

$Header: $

Abstract:

Author:
    marcelv 	1/15/2001		Initial Release

Revision History:

--**************************************************************************/

#include "configtransformer.h"

#include "localmachinetransformer.h"
#include "localsecuritytransformer.h"
#include "usersecuritytransformer.h"

//=================================================================================
// Function: CConfigTransformer::CConfigTransformer
//
// Synopsis: Default Constructor
//=================================================================================
CConfigTransformer::CConfigTransformer ()
{
	m_fInitialized = false;
}

//=================================================================================
// Function: CConfigTransformer::~CConfigTransformer
//
// Synopsis: Default destructor
//=================================================================================
CConfigTransformer::~CConfigTransformer ()
{
}

//=================================================================================
// Function: CConfigTransformer::Initialize
//
// Synopsis: The configTransformer itself is just a proxy to the correct transformer
//           that is accessed via the config:// protocol. It initializes itself, and
//           next finds out what the real transformer is that should be invoked. The real
//           transformer is kept in m_spInnerTransformer, and all calls for the transfomer
//           are forwarded to this innner tranformer
//
// Arguments: [i_wszProtocol] - protocol. Should be config://
//            [i_wszSelector] - 
//            [o_pcConfigStores] - 
//            [o_pcPossibleStores] - 
//            
// Return Value: 
//=================================================================================
STDMETHODIMP 
CConfigTransformer::Initialize (ISimpleTableDispenser2 * i_pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores)
{
	ASSERT (i_pDispenser != 0);
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);
	ASSERT (o_pcPossibleStores != 0);

	ASSERT (wcscmp (i_wszProtocol, L"config") == 0);

	HRESULT hr = InternalInitialize (i_pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED(hr))
	{
		TRACE (L"InternalInitialize failed in File Transformer");
		return hr;
	}

	// Get the inner transformer, and initialize it. All calls are forwarded to this 
	// transformer
	hr = GetInnerTransformer ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get innerTransformer in config transformer");
		return hr;
	}

	hr = m_spInnerTransformer->Initialize (i_pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED (hr))
	{
		TRACE (L"Initialize of inner transformer failed");
		return hr;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CConfigTransformer::GetConfigStores
//
// Synopsis: Get configuration stores. Forwarded to the inner transformer
//
// Arguments: [i_cConfigStores] - number of config stores
//            [o_paConfigStores] - array with config store information
//=================================================================================
STDMETHODIMP
CConfigTransformer::GetRealConfigStores (ULONG i_cConfigStores, STConfigStore * o_paConfigStores)
{
	ASSERT (m_fInitialized);
	return m_spInnerTransformer->GetRealConfigStores (i_cConfigStores, o_paConfigStores);
}

STDMETHODIMP
CConfigTransformer::GetPossibleConfigStores (ULONG i_cPossibleConfigStores, STConfigStore * o_paPossibleConfigStores)
{
	ASSERT (m_fInitialized);
	return m_spInnerTransformer->GetPossibleConfigStores (i_cPossibleConfigStores, o_paPossibleConfigStores);
}

//=================================================================================
// Function: CConfigTransformer::GetInnerTransformer
//
// Synopsis: At the moment we support the following transformers:
//           "localhost/security/user" -> UserSecurityTransformer
//           "localhost/security"	   -> LocalSecurityTransformer
//           "localhost"			   -> LocalMachineTransformer
//=================================================================================
HRESULT
CConfigTransformer::GetInnerTransformer ()
{
	ISimpleTableTransform *pSTTransform;

	// order is important. In case of same starting points, longer string needs to
	// be listed first
	static LPCWSTR wszUserSecurity		= L"localhost/security/user";
	static LPCWSTR wszMachineSecurity	= L"localhost/security";
	static LPCWSTR wszLocalMachine		= L"localhost";

	if (_wcsicmp (m_wszSelector, wszUserSecurity) == 0)
	{
		pSTTransform = new CUserSecurityTransformer;
	}
	else if (_wcsicmp (m_wszSelector, wszMachineSecurity) == 0)
	{
		pSTTransform = new CLocalSecurityTransformer;
	}
	else if (_wcsicmp (m_wszSelector, wszLocalMachine) == 0)
	{
		pSTTransform = new CLocalMachineTransformer;
	}
	else
	{
		TRACE (L"Unknown config selector: %s", m_wszSelector);
		return E_ST_INVALIDSELECTOR;
	}

	if (pSTTransform == 0)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = pSTTransform->QueryInterface (IID_ISimpleTableTransform, (void **) &m_spInnerTransformer);
	if (FAILED (hr))
	{
		TRACE (L"QI failed for inner transformer");
		// need to delete to avoid mem leak
		delete pSTTransform;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\appdomaintransformer.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    appdomaintransformer.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "appdomaintransformer.h"
#include "catmeta.h"

//=================================================================================
// Function: CAppDomainTransformer::CAppDomainTransformer
//
// Synopsis: Default constructor
//=================================================================================
CAppDomainTransformer::CAppDomainTransformer () 
{
}

//=================================================================================
// Function: CAppDomainTransformer::~CAppDomainTransformer
//
// Synopsis: Default destructor
//=================================================================================
CAppDomainTransformer::~CAppDomainTransformer  ()
{
}

//=================================================================================
// Function: CWebHierarchyTransformer::Initialize
//
// Synopsis: Initializes the transformer. This function retrieves the names of the 
//           configuration stores that need to be merged. It walks a web hierarchy.
//
// Arguments: [i_wszProtocol] - protocol name
//            [i_wszSelector] - selector string without protocol name
//            [o_pcConfigStores] - number of configuration stores found
//            [o_pcPossibleStores] - number of possible configuration stores (non-existing included)
//=================================================================================
STDMETHODIMP 
CAppDomainTransformer::Initialize (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores)
{
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);
	ASSERT (o_pcPossibleStores != 0);

	static LPCWSTR wszExeExtension = L"exe";
	static LPCWSTR wszCfgExtension = L"config";
	static LPCWSTR wszAppDomainLogicPath = L"appdomain";

	HRESULT hr = InternalInitialize (pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED (hr))
	{
		TRACE (L"InternalInitialize failed for AppDomain Transformer");
		return hr;
	}

	hr = AddMachineConfigFile(true);
	if (FAILED (hr))
	{
		TRACE (L"Unable to add machine config directory");
		return hr;
	}

		// get application configuration file
	HMODULE hModule = GetModuleHandle (0);
	if (hModule == 0)
	{
		TRACE (L"Unable to get module handle in AppDomain Transformer");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// get directory and exe name

	WCHAR wszAppDir[MAX_PATH];
	DWORD dwRes = GetModuleFileName  (hModule, wszAppDir, sizeof(wszAppDir)/sizeof(WCHAR));
	if (dwRes == 0)
	{
		TRACE (L"GetModuleFileName failed in AppDomain Transformer");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	SIZE_T iExtensionStart = wcslen (wszAppDir) - wcslen (wszExeExtension);
	ASSERT (wcscmp(wszAppDir + iExtensionStart, wszExeExtension) == 0);
	wcscpy (wszAppDir + iExtensionStart, wszCfgExtension);

	// split of exe name, and replace with config.cfg

	// wszAppDir already contains full path
	hr = AddSingleConfigStore (L"", wszAppDir, wszAppDomainLogicPath, L"", false);
	if (FAILED (hr))
	{
		TRACE (L"Adding Configuration Store failed");
		return hr;
	}

	SetNrConfigStores (o_pcConfigStores, o_pcPossibleStores);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\configtransformer.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    configtransformer.h

$Header: $

Abstract:

Author:
    marcelv 	1/15/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CONFIGTRANSFORMER_H__
#define __CONFIGTRANSFORMER_H__

#pragma once


#include "transformerbase.h"

class CConfigTransformer : public CTransformerBase 
{
public:
	CConfigTransformer ();
	virtual ~CConfigTransformer ();

	//ISimpleTableTransform
    STDMETHOD (GetRealConfigStores) (ULONG i_cConfigStores, STConfigStore * o_paConfigStores);
    STDMETHOD (GetPossibleConfigStores) (ULONG i_cPossibleConfigStores, STConfigStore * o_paPossibleConfigStores);

    STDMETHOD (Initialize)      (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG *o_pcPossibleStores);
private:
	// no copies
	CConfigTransformer  (const CConfigTransformer&);
	CConfigTransformer& operator= (const CConfigTransformer &);

	HRESULT GetInnerTransformer ();

	CComPtr<ISimpleTableTransform> m_spInnerTransformer; // real transformer to forward to
	bool m_fInitialized;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\filetransformer.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    filetransformer.cpp

$Header: $

Abstract:
	File Transformer class

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "filetransformer.h"
#include "smartpointer.h"

//=================================================================================
// Function: CFileTransformer::CFileTransformer
//
// Synopsis: Default Constructor
//=================================================================================
CFileTransformer::CFileTransformer ()
{
}

//=================================================================================
// Function: CFileTransformer::~CFileTransformer
//
// Synopsis: Default Destructor
//=================================================================================
CFileTransformer::~CFileTransformer ()
{
}

//=================================================================================
// Function: CFileTransformer::Initialize
//
// Synopsis: Simply stores i_wszSelector as file name (in case it exists). For this
//           transformer the selector is the file name
//
// Arguments: [i_wszProtocol] - protocol
//            [i_wszSelector] - selector (aka file name)
//            [o_pcConfigStores] - number of configuration stores 
//            [o_pcPossibleStores] - number of possible stores (non-existing included)
//=================================================================================
STDMETHODIMP 
CFileTransformer::Initialize (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores)
{
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);

	HRESULT hr = InternalInitialize (pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED(hr))
	{
		TRACE (L"InternalInitialize failed in File Transformer");
		return hr;
	}

	// i_wszSelector contains the file name, always add it, eventhough the file does not exist
	// use empty dir for first param because i_wszSelector already contains full path

	hr = UrlUnescapeInPlace (m_wszSelector, 0);
	if (FAILED (hr))
	{
		TRACE (L"URLUnescapeInPlace failed");
		return hr;
	}

	hr = AddSingleConfigStore ( L"", 
								m_wszSelector, 
								i_wszSelector, 
								m_wszLocation, 
								false);
	if (FAILED (hr))
	{
		TRACE (L"Adding configuration store failed");
		return hr;
	}

	SetNrConfigStores (o_pcConfigStores, o_pcPossibleStores);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\filetransformer.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    filetransformer.h

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __FILETRANSFORMER_H__
#define __FILETRANSFORMER_H__

#pragma once

#include "transformerbase.h"

/**************************************************************************++
Class Name:
    CFileTransformer

Class Description:
    Transforms file://<filename> to a query cell with <filename> as pData member

Constraints:
	None
--*************************************************************************/
class CFileTransformer : public CTransformerBase 
{
public:
	CFileTransformer ();
	virtual ~CFileTransformer ();

	//ISimpleTableAdvanced
    STDMETHOD (Initialize)      (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG *o_pcPossibleStores);
private:
	// no copies
	CFileTransformer (const CFileTransformer&);
	CFileTransformer& operator= (const CFileTransformer &);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\localmachinetransformer.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    localmachinetransformer.h

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __LOCALMACHINETRANSFORMER_H__
#define __LOCALMACHINETRANSFORMER_H__

#pragma once

#include "transformerbase.h"

class CLocalMachineTransformer : public CTransformerBase
{
public:
	CLocalMachineTransformer ();
	virtual ~CLocalMachineTransformer ();

    STDMETHOD (Initialize) (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores);
private:
	// no copies
	CLocalMachineTransformer  (const CLocalMachineTransformer&);
	CLocalMachineTransformer& operator= (const CLocalMachineTransformer&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\localsecuritytransformer.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    localsecuritytransformer.h

$Header: $

Abstract:

Author:
    marcelv 	1/15/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __LOCALSECURITYTRANSFORMER_H__
#define __LOCALSECURITYTRANSFORMER_H__

#pragma once

#include "transformerbase.h"

class CLocalSecurityTransformer : public CTransformerBase
{
public:
	CLocalSecurityTransformer ();
	virtual ~CLocalSecurityTransformer ();

    STDMETHOD (Initialize) (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores);
private:
	// no copies
	CLocalSecurityTransformer  (const CLocalSecurityTransformer&);
	CLocalSecurityTransformer& operator= (const CLocalSecurityTransformer&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\localmachinetransformer.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    localmachinetransformer.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "localmachinetransformer.h"
#include "catmeta.h"

//=================================================================================
// Function: CLocalMachineTransformer::CLocalMachineTransformer
//
// Synopsis: Default constructor
//=================================================================================
CLocalMachineTransformer::CLocalMachineTransformer () 
{
}

//=================================================================================
// Function: CLocalMachineTransformer::~CLocalMachineTransformer
//
// Synopsis: Default destructor
//=================================================================================
CLocalMachineTransformer::~CLocalMachineTransformer ()
{
}

//=================================================================================
// Function: CLocalMachineTransformer::Initialize
//
// Synopsis: Initializes the transformer. This function retrieves the names of the 
//           configuration stores that need to be merged. It walks a web hierarchy.
//
// Arguments: [i_wszProtocol] - protocol name
//            [i_wszSelector] - selector string without protocol name
//            [o_pcConfigStores] - number of configuration stores found
//            [o_pcPossibleStores] - number of possible stores (non-existing included)
//=================================================================================
STDMETHODIMP 
CLocalMachineTransformer::Initialize (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, ULONG * o_pcConfigStores, ULONG *o_pcPossibleStores)
{
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);
	ASSERT (o_pcPossibleStores != 0);

	HRESULT hr = InternalInitialize (pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED (hr))
	{
		TRACE (L"InternalInitialize failed for Local Machine Transformer");
		return hr;
	}

	hr = AddMachineConfigFile (false, m_wszLocation);
	if (FAILED (hr))
	{
		TRACE (L"Error adding machine configuration file");
		return hr;
	}

	SetNrConfigStores (o_pcConfigStores, o_pcPossibleStores);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\shelltransformer.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    shelltransformer.h

$Header: $

Abstract:

Author:
    marcelv 	1/16/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __SHELLTRANSFORMER_H__
#define __SHELLTRANSFORMER_H__

#pragma once

#include "transformerbase.h"

class CShellTransformer : public CTransformerBase
{
public:
	CShellTransformer ();
	virtual ~CShellTransformer ();

    STDMETHOD (Initialize) (ISimpleTableDispenser2 * i_pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores);
private:
	// no copies
	CShellTransformer  (const CShellTransformer&);
	CShellTransformer& operator= (const CShellTransformer&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\shelltransformer.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    shelltransformer.cpp

$Header: $

Abstract:

Author:
    marcelv 	1/16/2001		Initial Release

Revision History:

--**************************************************************************/

#include "shelltransformer.h"
#include "smartpointer.h"

//=================================================================================
// Function: CShellTransformer::CShellTransformer
//
// Synopsis: Default constructor
//=================================================================================
CShellTransformer::CShellTransformer () 
{
}

//=================================================================================
// Function: CShellTransformer::~CShellTransformer
//
// Synopsis: Default destructor
//=================================================================================
CShellTransformer::~CShellTransformer ()
{
}

//=================================================================================
// Function: CShellTransformer::Initialize
//
// Synopsis: Initializes the transformer. This function retrieves the names of the 
//           configuration stores that need to be merged. The shell transformer
//           simply converts a full path exe name (c:\foo\app.exe) to (c:\foo\app.config)
//
// Arguments: [i_wszProtocol] - protocol name
//            [i_wszSelector] - selector string without protocol name
//            [o_pcConfigStores] - number of configuration stores found
//            [o_pcPossibleStores] - number of possible stores (non-existing included)
//=================================================================================
STDMETHODIMP 
CShellTransformer::Initialize (ISimpleTableDispenser2 * i_pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, ULONG * o_pcConfigStores, ULONG *o_pcPossibleStores)
{
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);
	ASSERT (o_pcPossibleStores != 0);

	HRESULT hr = InternalInitialize (i_pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED (hr))
	{
		TRACE (L"InternalInitialize failed for Local Machine Transformer");
		return hr;
	}

	// m_wszSelector contains the executable file name

	static LPCWSTR wszExeExtension = L".exe";
	static SIZE_T iLenExeExtenstion = wcslen (wszExeExtension);
	static LPCWSTR wszCfgExtension = L".config";
	static SIZE_T iLenCfgExtenstion = wcslen (wszCfgExtension);
	SIZE_T cLen = wcslen (m_wszSelector);
	if (_wcsicmp (m_wszSelector + cLen - iLenExeExtenstion, wszExeExtension) != 0)
	{
		return E_ST_INVALIDSELECTOR;
	}

	// replace .exe with .config
	TSmartPointerArray<WCHAR> wszCfgFileName = new WCHAR [cLen - iLenExeExtenstion + iLenCfgExtenstion + 1];
	if (wszCfgFileName == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	wcscpy (wszCfgFileName, m_wszSelector);
	wcscpy (wszCfgFileName + cLen - iLenExeExtenstion, wszCfgExtension);

	hr = AddSingleConfigStore (L"", wszCfgFileName, wszCfgFileName, L"", false);
	if (FAILED (hr))
	{
		TRACE (L"Adding Configuration Store failed");
		return hr;
	}

	SetNrConfigStores (o_pcConfigStores, o_pcPossibleStores);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\localsecuritytransformer.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    localsecuritytransformer.cpp

$Header: $

Abstract:

Author:
    marcelv 	1/15/2001		Initial Release

Revision History:

--**************************************************************************/

#include "localsecuritytransformer.h"

static LPWSTR g_wszSecurityConfigFile = L"security.config";

//=================================================================================
// Function: CLocalSecurityTransformer::CLocalSecurityTransformer
//
// Synopsis: Default constructor
//=================================================================================
CLocalSecurityTransformer::CLocalSecurityTransformer () 
{
}

//=================================================================================
// Function: CLocalSecurityTransformer::~CLocalSecurityTransformer
//
// Synopsis: Default destructor
//=================================================================================
CLocalSecurityTransformer::~CLocalSecurityTransformer ()
{
}

//=================================================================================
// Function: CLocalSecurityTransformer::Initialize
//
// Synopsis: Initializes the transformer. 
//
// Arguments: [i_wszProtocol] - protocol name
//            [i_wszSelector] - selector string without protocol name
//            [o_pcConfigStores] - number of configuration stores found
//            [o_pcPossibleStores] - number of possible stores (non-existing included)
//=================================================================================
STDMETHODIMP 
CLocalSecurityTransformer::Initialize (ISimpleTableDispenser2 * pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, ULONG * o_pcConfigStores, ULONG *o_pcPossibleStores)
{
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);
	ASSERT (o_pcPossibleStores != 0);
	ASSERT (pDispenser != 0);

	HRESULT hr = InternalInitialize (pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED (hr))
	{
		TRACE (L"InternalInitialize failed");
		return hr;
	}

	if (m_wszLocation[0] != L'\0')
	{
		TRACE (L"Local Security Transformer does not support location element");
		return E_ST_INVALIDSELECTOR;
	}

	WCHAR wszMachineCfgDir[MAX_PATH];
	hr = GetMachineConfigDir (wszMachineCfgDir, sizeof (wszMachineCfgDir) / sizeof (WCHAR));
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Machine Config Directory in CLocalSecurityTransformer");
		return hr;
	}

	hr = AddSingleConfigStore (wszMachineCfgDir, g_wszSecurityConfigFile, m_wszSelector, L"", false);
	if (FAILED (hr))
	{
		TRACE (L"Unable to add single configstore in localsecurity transformer\n");
		return hr;
	}

	SetNrConfigStores (o_pcConfigStores, o_pcPossibleStores);

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\transformerbase.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    transformerbase.h

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __TRANSFORMERBASE_H__
#define __TRANSFORMERBASE_H__

#pragma once

#include "catalog.h"
#include "catmacros.h"
#include "array_t.h"
#include "wstring.h"

struct CFileInformation
{
	wstring wszFileName;	  // file names
	wstring wszLogicalPath;   // logical path name
	wstring wszLocation;      // location part
	bool    fRealConfigStore; // Does the config store exist or not, and thus is part of merging
	BOOL    fAllowOverride;
};

/**************************************************************************++
Class Name:
    CTransformerBase

Class Description:
    Base class for Transformers. Implements IUnknown and part of ISimpleTableTransform.
	The configuration store names are stored in an array, and GetConfigurationStores
	converts the configuration store names to the correct querycell.
	It is recommended that transformers inherit from this baseclass.

Constraints:
	When a tranformer inherits from this class, it cannot implement any other interface
	then ISimpleTableTransform. If it needs to implement this as well, it needs to implement
	it's own QI method
--*************************************************************************/
class CTransformerBase : public ISimpleTableTransform
{
public:
	CTransformerBase ();
	virtual ~CTransformerBase ();

	// IUnknown
	STDMETHOD (QueryInterface)      (REFIID riid, void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();

	//ISimpleTableTransform
    STDMETHOD (GetRealConfigStores) (ULONG i_cRealConfigStores, STConfigStore * o_paRealConfigStores);
    STDMETHOD (GetPossibleConfigStores) (ULONG i_cPossibleConfigStores, STConfigStore * o_paPossibleConfigStores);
	HRESULT AddSingleConfigStore (LPCWSTR i_wszCfgStoreDir, LPCWSTR i_wszCfgFileName, LPCWSTR i_wszLogicalPath,	LPCWSTR i_wszLocation, bool i_fCheckForExistance, BOOL i_fAllowOverride = TRUE);

private:
	// no copies, so make copy constructor and assigment operator private
	CTransformerBase  (const CTransformerBase &);
	CTransformerBase& operator= (const CTransformerBase  &);

protected:
	HRESULT InternalInitialize (ISimpleTableDispenser2 * i_pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG *o_pcPossibleStores);
	void SetNrConfigStores (ULONG *o_pcNrRealConfigStores, ULONG *o_pcNrPossibleConfigStores);
	HRESULT AddMachineConfigFile (bool fCheckForExistance, LPWSTR wszLocation = L"");	HRESULT GetMachineConfigDir (LPWSTR io_wszConfigDir, ULONG i_cNrChars);

	ULONG m_cRef;				      // reference count
	LPWSTR m_wszSelector;		   	  // selector string
	LPWSTR m_wszProtocol;			  // protocol string
	LPWSTR m_wszLocation;
	bool   m_fInitialized;			  // are we initialized or not
	CComPtr<ISimpleTableDispenser2> m_spDispenser;

private:
	HRESULT GetConfigStores (bool i_fRealConfigStores, ULONG i_cConfigStores, STConfigStore * o_paConfigStores);
	ULONG GetNrRealConfigStores () const;
	ULONG GetNrPossibleStores () const;

	Array<CFileInformation> m_aFileInfo;	  // array with file names
	ULONG m_cNrRealStores;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\transformerbase.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    transformerbase.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "transformerbase.h"

static LPCWSTR wszMachineCfgFile = L"machine.config";

//=================================================================================
// Function: CTransformerBase::CTransformerBase
//
// Synopsis: Default constructor
//=================================================================================
CTransformerBase::CTransformerBase () 
{
	m_cRef				= 0;
	m_wszSelector		= 0;
	m_wszProtocol		= 0;
	m_cNrRealStores     = 0;
	m_wszLocation		= 0;
	m_fInitialized		= false;
}

//=================================================================================
// Function: CTransformerBase::~CTransformerBase
//
// Synopsis: Default destructor
//=================================================================================
CTransformerBase::~CTransformerBase ()
{
	delete [] m_wszSelector;
	m_wszSelector = 0;

	delete [] m_wszProtocol;
	m_wszProtocol = 0;

	delete [] m_wszLocation;
	m_wszLocation = 0;
}

//=================================================================================
// Function: CTransformerBase::AddRef
//
// Synopsis: Default reference count implementation
//=================================================================================
ULONG
CTransformerBase::AddRef ()
{
	return InterlockedIncrement((LONG*) &m_cRef);
}

//=================================================================================
// Function: CTransformerBase::Release
//
// Synopsis: Default reference count implementation
//=================================================================================
ULONG
CTransformerBase::Release () 
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

//=================================================================================
// Function: CTransformerBase::QueryInterface
//
// Synopsis: Default QI implementation
//
// Arguments: [riid] - requested interface
//            [ppv] - pointer to requested interface in case it exists
//=================================================================================
STDMETHODIMP 
CTransformerBase::QueryInterface (REFIID riid, void **ppv)
{
	if (0 == ppv) 
	{
		return E_INVALIDARG;
	}

	// initialize output parameters
	*ppv = 0;

	if (riid == IID_ISimpleTableTransform || riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableTransform*) this;
	}
	else
	{
		return E_NOINTERFACE;
	}

	((ISimpleTableTransform*)this)->AddRef ();

	return S_OK;
}

//=================================================================================
// Function: CTransformerBase::InternalInitialize
//
// Synopsis: Initializes the transformer. 
//
// Arguments: [i_wszProtocol] - protocol name
//            [i_wszSelector] - selector string without protocol name
//            [o_pcConfigStores] - number of configuration stores found
//            [o_pcPossibleStores] - number of possible stores (non-existing included)
//=================================================================================
HRESULT 
CTransformerBase::InternalInitialize (ISimpleTableDispenser2 * i_pDispenser,
									  LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, 
									  ULONG * o_pcConfigStores, ULONG *o_pcPossibleStores)
{
	ASSERT (i_pDispenser != 0);
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);
	ASSERT (o_pcPossibleStores != 0);

	// initialize output variable
	*o_pcConfigStores	= 0;
	*o_pcPossibleStores = 0;

	m_spDispenser		= i_pDispenser;
	
	m_wszProtocol = new WCHAR[wcslen(i_wszProtocol) + 1];
	if (m_wszProtocol == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszProtocol, i_wszProtocol);

	// do we have a has
	LPWSTR pHash = wcsrchr (i_wszSelector, L'#');
	if (pHash != 0)
	{
		pHash++;
	}
	else
	{
		pHash = L"";
	}

	SIZE_T iHashLen = wcslen (pHash);
	m_wszLocation = new WCHAR [wcslen (pHash) + 1];
	if (m_wszLocation == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszLocation, pHash);

	
	SIZE_T iSelectorLen;
	if (iHashLen == 0)
	{
		iSelectorLen = wcslen (i_wszSelector);
	}
	else
	{
		iSelectorLen = wcslen (i_wszSelector) - iHashLen -1;
	}

	m_wszSelector= new WCHAR [iSelectorLen + 1];
	if (m_wszSelector == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcsncpy (m_wszSelector, i_wszSelector, iSelectorLen);
	m_wszSelector[iSelectorLen] = L'\0';

	m_fInitialized = true;

	return S_OK;
}

//=================================================================================
// Function: CWebHierarchyTransformer::GetRealConfigStores
//
// Synopsis: Copy the configuration store file names stored in m_awszFileNames as query
//           cells. These are only the file names that are part of the merging, not all 
//           files that could be part but don't exist
//
// Arguments: [i_cConfigStores] - Number of congiruation stores that we are interested in
//            [o_paConfigStores] - Configuration store information array.
//            
// Return Value: 
//=================================================================================
STDMETHODIMP 
CTransformerBase::GetRealConfigStores (ULONG i_cConfigStores, STConfigStore * o_paConfigStores)
{
	ASSERT (i_cConfigStores > 0);
	ASSERT (i_cConfigStores <= m_cNrRealStores);
	ASSERT (o_paConfigStores != 0);
	ASSERT (m_fInitialized);

	return GetConfigStores (true, i_cConfigStores, o_paConfigStores);
}

//=================================================================================
// Function: CTransformerBase::GetPossibleConfigStores
//
// Synopsis: Get all possible configuration stores, including stores that do not exist
//
// Arguments: [i_cPossibleConfigStores] - number of stores to retrieve
//            [o_paPossibleConfigStores] - array to store config store information
//=================================================================================
STDMETHODIMP 
CTransformerBase::GetPossibleConfigStores (ULONG i_cPossibleConfigStores, STConfigStore * o_paPossibleConfigStores)
{
	ASSERT (i_cPossibleConfigStores > 0);
	ASSERT (o_paPossibleConfigStores != 0);
	ASSERT (i_cPossibleConfigStores <= GetNrPossibleStores());
	ASSERT (m_fInitialized);

	return GetConfigStores (false, i_cPossibleConfigStores, o_paPossibleConfigStores);
}

//=================================================================================
// Function: CTransformerBase::GetConfigStores
//
// Synopsis: Get configuration store information
//
// Arguments: [i_fRealConfigStores] - do we want the real config stores, or all config stores.
//                                    true->real config stores, false->all config stores
//            [i_cConfigStores] - number of configu stores to retrieve
//            [o_paConfigStores] - 
//            
// Return Value: 
//=================================================================================
HRESULT
CTransformerBase::GetConfigStores (bool i_fRealConfigStores, ULONG i_cConfigStores, STConfigStore * o_paConfigStores)
{
	ASSERT (i_cConfigStores > 0);
	ASSERT (o_paConfigStores != 0);
	ASSERT (i_cConfigStores <= GetNrPossibleStores ());
	ASSERT (m_fInitialized);

	ULONG idxOutputStore = 0;
	for (ULONG idxStore=0; idxStore < GetNrPossibleStores(); ++idxStore)
	{
		// not a real configuration store, so ignore this one
		if (i_fRealConfigStores && !m_aFileInfo[idxStore].fRealConfigStore)
		{
			continue;
		}

		CFileInformation *pFileInfo = &m_aFileInfo[idxStore];

		LPWSTR wszFileName = new WCHAR[pFileInfo->wszFileName.length() + 1];
		if (wszFileName == 0)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy (wszFileName, pFileInfo->wszFileName.c_str());

		LPWSTR wszLogicalName = new WCHAR[pFileInfo->wszLogicalPath.length () + 1];
		if (wszLogicalName == 0)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy (wszLogicalName, pFileInfo->wszLogicalPath.c_str());
		
		STConfigStore *pOutConfigStore = &o_paConfigStores[idxOutputStore++];

		pOutConfigStore->wszLogicalPath	= wszLogicalName;
		pOutConfigStore->fAllowOverride = pFileInfo->fAllowOverride;

		// if we have a location qualifier, we need to add two query cells. Without
		// location qualifier, a single query cells is sufficient
		
		pOutConfigStore->cNrQueryCells = 1;
		if (pFileInfo->wszLocation[0] != L'\0')
		{
			pOutConfigStore->cNrQueryCells = 2;
		}
		STQueryCell * aQueryCells = new STQueryCell[pOutConfigStore->cNrQueryCells];
		if (aQueryCells == 0)
		{
			return E_OUTOFMEMORY;
		}
		
		aQueryCells[0].pData		= (void *) wszFileName;
		aQueryCells[0].eOperator	= eST_OP_EQUAL;
		aQueryCells[0].iCell		= iST_CELL_FILE;
		aQueryCells[0].dbType		= DBTYPE_WSTR;
		aQueryCells[0].cbSize		= 0;

		if (pFileInfo->wszLocation[0] != L'\0')
		{
			ASSERT (pOutConfigStore->cNrQueryCells > 1);
			LPWSTR wszLocation = new WCHAR[pFileInfo->wszLocation.length () + 1];
			if (wszLocation == 0)
			{
				return E_OUTOFMEMORY;
			}
			wcscpy (wszLocation, pFileInfo->wszLocation.c_str());

			// location info
			aQueryCells[1].pData		= (void *) wszLocation;
			aQueryCells[1].eOperator	= eST_OP_EQUAL;
			aQueryCells[1].iCell		= iST_CELL_LOCATION;
			aQueryCells[1].dbType		= DBTYPE_WSTR;
			aQueryCells[1].cbSize		= 0;
		}
			
		pOutConfigStore->aQueryCells = aQueryCells;

		// if we copied all information that was requested, return immediately
		if (idxOutputStore == i_cConfigStores)
		{
			break;
		}
	}

	return S_OK;
}

//=================================================================================
// Function: CTransformerBase::AddSingleConfigStore
//
// Synopsis: Adds a single configuration store to the list of configuration stores that
//           need to be returned by the transformer. Configuration stores are only added
//           when the file actually exists.
//
// Arguments: [wszCfgStoreDir] - Configuration store directory
//			  [wszCfgFileName] - Configuration store file name
//            [wszLocation]    - Configuration store location information, empty string if not needed
//=================================================================================
HRESULT
CTransformerBase::AddSingleConfigStore (LPCWSTR i_wszCfgStoreDir, 
										LPCWSTR i_wszCfgFileName,
										LPCWSTR i_wszLogicalPath,
										LPCWSTR i_wszLocation,
										bool i_fCheckForExistance,
										BOOL i_fAllowOverride)
{
	ASSERT (i_wszCfgStoreDir != 0);
	ASSERT (i_wszCfgFileName != 0);
	ASSERT (i_wszLogicalPath != 0);
	ASSERT (i_wszLocation != 0);
	ASSERT (m_fInitialized);

	WCHAR wszFinalPath[MAX_PATH];
	WCHAR *wszLongFinalPath = 0;
	WCHAR *pRealFinalPath	= 0;

	SIZE_T cLenCfgStoreDir = wcslen (i_wszCfgStoreDir);
	SIZE_T iLen = cLenCfgStoreDir + wcslen (i_wszCfgFileName);

	bool fRemovePathBackSlash = false;
	// if both the directory end with backslash and path starts with backslash, remove one of them
	if ((i_wszCfgStoreDir[cLenCfgStoreDir -1] == L'\\' || i_wszCfgStoreDir[cLenCfgStoreDir -1] == L'/') &&
		(i_wszCfgFileName[0] == L'\\' || i_wszCfgFileName[0] == L'/'))
	{
		fRemovePathBackSlash = true;
	}


	// if we don't have a backslash or slash as the end of the path, and the filename doesn't start
	// with slash or backslash, we need to add a backslash ourselves
	bool fNeedBackSlash = false;
	if (cLenCfgStoreDir > 0 && 
		i_wszCfgStoreDir[cLenCfgStoreDir -1] != L'\\' && i_wszCfgStoreDir[cLenCfgStoreDir -1] != L'/' &&
		i_wszCfgFileName[0] != L'\\' &&	i_wszCfgFileName[0] != L'/')
	{
		fNeedBackSlash = true;
		iLen++; // add one char for the backslash
	}

	if (iLen >= MAX_PATH)
	{
		wszLongFinalPath = new WCHAR[iLen + 1];
		if (wszLongFinalPath == 0)
		{
			return E_OUTOFMEMORY;
		}
		pRealFinalPath = wszLongFinalPath;
	}
	else
	{
		pRealFinalPath = wszFinalPath;
	}

	wsprintf (pRealFinalPath, 
		      L"%s%s%s", 
			  i_wszCfgStoreDir, 
			  fNeedBackSlash? L"\\" : L"",
			  fRemovePathBackSlash? i_wszCfgFileName+1 : i_wszCfgFileName);


	CFileInformation fileInfo;
	fileInfo.wszFileName	= pRealFinalPath;
	fileInfo.wszLogicalPath = i_wszLogicalPath;
	fileInfo.wszLocation	= i_wszLocation;
	fileInfo.fAllowOverride = i_fAllowOverride;

	// if we need to check if file exist, and it doesn't, then it is not a real configstore
	if (i_fCheckForExistance && GetFileAttributes (pRealFinalPath) == -1)
	{
		fileInfo.fRealConfigStore = false;
	}
	else 
	{
		fileInfo.fRealConfigStore = true;
		m_cNrRealStores++;
	}

	TRACE (L"Possible config store: %s, location: %s (file exists:%s)", 
		   pRealFinalPath, i_wszLocation, fileInfo.fRealConfigStore?L"yes":L"no");


	m_aFileInfo.append (fileInfo);

	delete [] wszLongFinalPath;

	return S_OK;
}

//=================================================================================
// Function: CTransformerBase::GetNrConfigStores
//
// Synopsis: Returns the number of configuration stores that were found
//=================================================================================
ULONG 
CTransformerBase::GetNrRealConfigStores () const
{
	ASSERT (m_fInitialized);
	return m_cNrRealStores;
}

//=================================================================================
// Function: CTransformerBase::GetNrPossibleStores
//
// Synopsis: Returns number of all possible configuration stores, including ones that
//           do not exist
//=================================================================================
ULONG 
CTransformerBase::GetNrPossibleStores () const
{
	ASSERT (m_fInitialized);
	return m_aFileInfo.size();
}

//=================================================================================
// Function: CTransformerBase::SetNrConfigStores
//
// Synopsis: Sets the number of real and possible configuration stores
//
// Arguments: [o_pcNrRealConfigStores] - number of real config stores
//            [o_pcNrPossibleConfigStores] - number of possible config stores
//            
//=================================================================================
void 
CTransformerBase::SetNrConfigStores (ULONG *o_pcNrRealConfigStores, ULONG *o_pcNrPossibleConfigStores)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pcNrRealConfigStores != 0);
	ASSERT (o_pcNrPossibleConfigStores != 0);

	*o_pcNrRealConfigStores		= GetNrRealConfigStores ();
	*o_pcNrPossibleConfigStores = GetNrPossibleStores ();
}

//=================================================================================
// Function: CTransformerBase::GetMachineConfigDir
//
// Synopsis: Gets the machine config directory for the currect product
//
// Arguments: [io_wszMachineConfigDir] - result will be stored in here
//            [i_cNrChars] - number of characters that can be stored in io_wszMachineConfigDir
//=================================================================================
HRESULT 
CTransformerBase::GetMachineConfigDir (LPWSTR io_wszMachineConfigDir, ULONG i_cNrChars)
{
	ASSERT (m_fInitialized);
	ASSERT (io_wszMachineConfigDir != 0);

	CComPtr<IAdvancedTableDispenser> spAdvDisp;
	HRESULT hr = m_spDispenser->QueryInterface (IID_IAdvancedTableDispenser, (void **)&spAdvDisp);
	if (FAILED (hr))
	{
		TRACE (L"QI for IAdvancedTableDispenser failed");
		return hr;
	}

	WCHAR wszProductID[64];
	ULONG cProductIDLen = sizeof (wszProductID) / sizeof (WCHAR);
	hr = spAdvDisp->GetProductID (wszProductID, &cProductIDLen);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get product ID from dispenser");
		return hr;
	}
	
	UINT iRes = GetMachineConfigDirectory (wszProductID, io_wszMachineConfigDir, i_cNrChars);
	if (!iRes)
	{
		TRACE (L"GetMachineConfigDirectory failed for Local Machine Transformer");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;
}

//=================================================================================
// Function: CTransformerBase::AddMachineConfigFile
//
// Synopsis: Add Machine Config file to list of configuration stores
//
// Arguments: [fCheckForExistance] - check if machine config file exist or not
//=================================================================================
HRESULT
CTransformerBase::AddMachineConfigFile (bool fCheckForExistance, LPWSTR wszLocation)
{
	ASSERT (m_fInitialized);
	WCHAR wszMachineDir[MAX_PATH];
	HRESULT hr = GetMachineConfigDir (wszMachineDir, sizeof(wszMachineDir)/sizeof(WCHAR));
	if (FAILED(hr))
	{
		TRACE (L"GetMachineConfigDir failed");
		return hr;
	}

	hr = AddSingleConfigStore (wszMachineDir, wszMachineCfgFile, wszMachineCfgFile, wszLocation, fCheckForExistance);
	if (FAILED (hr))
	{
		TRACE (L"Adding Configuration Store failed");
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\transformerfactory.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    transformerfactory.cpp

$Header: $

Abstract:

Author:
    marcelv 	2/12/2001		Initial Release

Revision History:

--**************************************************************************/

#include "transformerfactory.h"

#include "filetransformer.h"
#include "webhierarchytransformer.h"
#include "appdomaintransformer.h"
#include "localmachinetransformer.h"
#include "configtransformer.h"
#include "shelltransformer.h"

// Pointer to DllGetSimpleObject kind of functions
typedef HRESULT( __stdcall *PFNDllGetSimpleObjectByID)( ULONG, REFIID, LPVOID);

//=================================================================================
// Function: CTransformerFactory::CTransformerFactory
//
// Synopsis: Default constructor
//=================================================================================
CTransformerFactory::CTransformerFactory  ()
{
}

//=================================================================================
// Function: CTransformerFactory::~CTransformerFactory
//
// Synopsis: Default destructor
//=================================================================================
CTransformerFactory::~CTransformerFactory ()
{
}

//=================================================================================
// Function: CTransformerFactory::GetTransformer
//
// Synopsis: Gets a transformer by using the information in the protocol
//
// Arguments: [i_pDispenser] - dispenser
//            [i_wszProtocol] - protocol string
//            [o_ppTransformer] - pointer to transformer will be stored here
//=================================================================================
HRESULT
CTransformerFactory::GetTransformer (ISimpleTableDispenser2 *i_pDispenser,
									 LPCWSTR i_wszProtocol, 
									 ISimpleTableTransform **o_ppTransformer)
{
	ASSERT (i_pDispenser != 0);
	ASSERT (i_wszProtocol != 0);
	ASSERT (o_ppTransformer != 0);

	m_spDispenser = i_pDispenser;
	// initialize output variable
	*o_ppTransformer = 0;

	CComPtr<ISimpleTableRead2> spTransformerWiring;
	HRESULT hr = m_spDispenser->GetTable (wszDATABASE_FIXED, 
										  wszTABLE_TRANSFORMER_META, 0, 0, eST_QUERYFORMAT_CELLS, 
									       0, (void **) &spTransformerWiring);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get TRANSFORMER_META table");
		return hr;
	}

	ULONG iRow;
	ULONG * pk[1];
	pk[0] = (ULONG *) i_wszProtocol;

	hr = spTransformerWiring->GetRowIndexByIdentity (0, (void **)pk, &iRow);
	if (hr == E_ST_NOMOREROWS)
	{
		TRACE (L"Unknown protocol string specified");
		return E_ST_UNKNOWNPROTOCOL;
	}

	if (FAILED (hr))
	{
		TRACE (L"Error while getting tranformer from wiring");
		return hr;
	}

	tTRANSFORMER_METARow TFColumns;
	hr = spTransformerWiring->GetColumnValues(iRow, cTRANSFORMER_META_NumberOfColumns, 0, 0, (LPVOID *)&TFColumns);
	if (FAILED (hr))
	{
		TRACE (L"Error while getting column values for tranformer: hr = 0x%x", hr);
		return hr;
	}

	if ((TFColumns.pDllName == 0) || (_wcsicmp ((WCHAR *)TFColumns.pDllName, L"catalog.dll") == 0))
	{
		return CreateLocalDllTransformer (*TFColumns.pTF_Type, o_ppTransformer);
	}
	else
	{
		return CreateForeignDllTransformer (*TFColumns.pTF_Type, (WCHAR *) TFColumns.pDllName, o_ppTransformer);
	}
	return S_OK;
}


//=================================================================================
// Function: CTransformerFactory::CreateLocalDllTransformer
//
// Synopsis: Gets one of the transformers that is defined in the current DLL
//
// Arguments: [i_iTransformerID] - Transformer ID
//            [ppTransformer] - transformer interface will be stored here
//=================================================================================
HRESULT
CTransformerFactory::CreateLocalDllTransformer (ULONG i_iTransformerID, ISimpleTableTransform **o_ppTransformer)
{
	ASSERT (o_ppTransformer != 0);
	*o_ppTransformer = 0;

	ISimpleTableTransform * p = 0;
	switch (i_iTransformerID)
	{
		case eTRANSFORMER_META_FileTransformer:
			p = new CFileTransformer ();
			break;
		case eTRANSFORMER_META_WebHierarchyTransformer:
			p = new CWebHierarchyTransformer ();
			break;
		case eTRANSFORMER_META_AppDomainTransformer:
			p = new CAppDomainTransformer ();
			break;
		case eTRANSFORMER_META_LocalMachineTransformer:
			p = new CLocalMachineTransformer ();
			break;
		case eTRANSFORMER_META_ConfigTransformer:
			p = new CConfigTransformer ();
			break;
		case eTRANSFORMER_META_ShellTransformer:
			p = new CShellTransformer ();
			break;

		default:
			return E_ST_INVALIDWIRING;
	}

	if (p == 0)
	{
		return E_OUTOFMEMORY;
	}

	return p->QueryInterface (IID_ISimpleTableTransform, (void **) o_ppTransformer);
}

//=================================================================================
// Function: CTransformerFactory::CreateForeignDllTransformer
//
// Synopsis: Create a transformer defined in a separate DLL
//
// Arguments: [i_iTransformerID] - Transformer id
//            [i_wszDllName] - dll name
//            [ppTransformer] - transformer interface will be stored here
//=================================================================================
HRESULT
CTransformerFactory::CreateForeignDllTransformer (ULONG i_iTransformerID, LPCWSTR i_wszDllName, ISimpleTableTransform **o_ppTransformer)
{
	ASSERT (i_wszDllName != 0);
	ASSERT (o_ppTransformer != 0);

	PFNDllGetSimpleObjectByID pfnDllGetSimpleObjectByID;

	// Load the library 
	HINSTANCE handle = LoadLibrary (i_wszDllName);
	if(0 == handle)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// get the address of DllGetSimpleObject procedure
	pfnDllGetSimpleObjectByID = (PFNDllGetSimpleObjectByID) ::GetProcAddress (handle, "DllGetSimpleObjectByID");
	if(0 == pfnDllGetSimpleObjectByID)
	{
		FreeLibrary(handle);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return (*pfnDllGetSimpleObjectByID)(i_iTransformerID, IID_ISimpleTableTransform, o_ppTransformer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\transformerfactory.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    transformerfactory.h

$Header: $

Abstract:

Author:
    marcelv 	2/12/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __TRANSFORMERFACTORY_H__
#define __TRANSFORMERFACTORY_H__

#pragma once

#include <atlbase.h>
#include "catalog.h"
#include "catmacros.h"


class CTransformerFactory
{
public:
	CTransformerFactory ();
	~CTransformerFactory ();

	HRESULT GetTransformer ( ISimpleTableDispenser2 *pDispenser,
							 LPCWSTR i_wszProtocol, 
							 ISimpleTableTransform **ppTransformer);

private:
	CTransformerFactory (CTransformerFactory& );
	CTransformerFactory& operator= (CTransformerFactory& );

	HRESULT CreateLocalDllTransformer (ULONG i_iTransformerID, ISimpleTableTransform **ppTransformer);
	HRESULT CreateForeignDllTransformer (ULONG i_iTransformerID, LPCWSTR i_wszDllName,ISimpleTableTransform **ppTransformer);

	CComPtr<ISimpleTableDispenser2> m_spDispenser;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\usersecuritytransformer.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    usersecuritytransformer.cpp

$Header: $

Abstract:

Author:
    marcelv 	1/15/2001		Initial Release

Revision History:

--**************************************************************************/
#include "usersecuritytransformer.h"
#include "smartpointer.h"
#include <userenv.h>

static bool g_fOnNT		= false; // are we on NT or not
static bool g_fChecked	= false; // did we already check if we are on NT?



static LPCWSTR g_wszSecurityCfgFile = L"security.config";
//=================================================================================
// Function: CUserSecurityTransformer::CUserSecurityTransformer
//
// Synopsis: Default constructor
//=================================================================================
CUserSecurityTransformer::CUserSecurityTransformer () 
{
	m_wszLastVersion[0] = L'\0';
}

//=================================================================================
// Function: CUserSecurityTransformer::~CUserSecurityTransformer
//
// Synopsis: Default destructor
//=================================================================================
CUserSecurityTransformer::~CUserSecurityTransformer ()
{
}

//=================================================================================
// Function: CUserSecurityTransformer::Initialize
//
// Synopsis: Initializes the transformer. 
//
// Arguments: [i_wszProtocol] - protocol name
//            [i_wszSelector] - selector string without protocol name
//            [o_pcConfigStores] - number of configuration stores found
//            [o_pcPossibleStores] - number of possible stores (non-existing included)
//=================================================================================
STDMETHODIMP 
CUserSecurityTransformer::Initialize (ISimpleTableDispenser2 * i_pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, ULONG * o_pcConfigStores, ULONG *o_pcPossibleStores)
{
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);
	ASSERT (o_pcPossibleStores != 0);
	ASSERT (i_pDispenser != 0);

	HRESULT hr = InternalInitialize (i_pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED (hr))
	{
		TRACE (L"Unable to internal initialize CUserSecurityTransformer");
		return hr;
	}

	
	if (m_wszLocation[0] != L'\0')
	{
		TRACE (L"User Security Transformer does not support location element");
		return E_ST_INVALIDSELECTOR;
	}

	// check if we are on NT. We only do this once, because if we know if we are on NT, we
	// don't have to check all the time. 
	if (!g_fChecked)
	{
		OSVERSIONINFO versionInfo;
		versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);

		BOOL fSuccess = GetVersionEx (&versionInfo);
		if (!fSuccess)
		{
			TRACE (L"GetVersionEx failed");
			hr = HRESULT_FROM_WIN32(GetLastError());
			return hr;
		}

		if (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			g_fOnNT = true;
		}

		g_fChecked = true;
	}
	
	// the directories where the security files exist are different between NT and Win9X.
	if (g_fOnNT)
	{
		hr = GetUserSecOnNT ();
	}
	else
	{
		hr = GetUserSecOn9X ();
	}

	if (FAILED (hr))
	{
		TRACE (L"Unable to get user security file");
		return hr;
	}

	SetNrConfigStores (o_pcConfigStores, o_pcPossibleStores);

	return hr;
}

//=================================================================================
// Function: CUserSecurityTransformer::GetUserSecOnNT
//
// Synopsis: On NT, the file resides in 
//			%USERPROFILE%\application data\Microsoft\CLR security config\vxx.xx\security.config
//
// Return Value: 
//=================================================================================
HRESULT
CUserSecurityTransformer::GetUserSecOnNT ()
{
	// Find out where %USERPROFILE% points to
	HRESULT hr = GetCurrentUserProfileDir ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Current User Profile Directory");
		return hr;
	}

	// Get the latest urt install version (vxx.xx)
	hr = GetLastURTInstall ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get version of last URT install");
		return hr;
	}

	static LPCWSTR wszUserPath = L"application data\\Microsoft\\CLR security config\\";

	TSmartPointerArray<WCHAR> wszPath = new WCHAR [wcslen (m_wszProfileDir) + wcslen (wszUserPath) + wcslen (m_wszLastVersion) + 2 + 1]; // +2 for two backslashes
	if (wszPath == 0)
	{
		return E_OUTOFMEMORY;
	}
	wsprintf (wszPath, L"%s\\%s%s", m_wszProfileDir, wszUserPath, m_wszLastVersion);

	hr = AddSingleConfigStore (wszPath, g_wszSecurityCfgFile, m_wszSelector, L"", false);
	if (FAILED (hr))
	{
		TRACE (L"Unable to add single configuration store");
		return hr;
	}
	return hr;
}

//=================================================================================
// Function: CUserSecurityTransformer::GetCurrentUserProfileDir
//
// Synopsis: Use GetUserProfileDir to the the user profile directory. Need to get trheadtoken
//           to get this fucntion to work
//=================================================================================
HRESULT
CUserSecurityTransformer::GetCurrentUserProfileDir ()
{

	HANDLE hThreadToken;
	BOOL fOk = OpenThreadToken (GetCurrentThread (), TOKEN_READ, FALSE, &hThreadToken);
	if (!fOk)
	{
		TRACE (L"OpenThreadToken failed");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	HMODULE hModule = LoadLibrary (L"userenv");
	if (hModule == 0)
	{
		TRACE (L"LoadLibrary of 'userenv.dll' failed");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	BOOL (STDAPICALLTYPE *pfnGetUserProfileDirectory) (HANDLE, LPWSTR, LPDWORD) = NULL;
	(FARPROC &) pfnGetUserProfileDirectory = GetProcAddress (hModule, "GetUserProfileDirectoryW");
	if (pfnGetUserProfileDirectory == 0)
	{
		FreeLibrary (hModule);
		hModule = 0;
		TRACE (L"Unable to GetProcAddress of GetUserProfileDirectory");
		return HRESULT_FROM_WIN32(GetLastError());
	}


	DWORD dwSize = sizeof(m_wszProfileDir) / sizeof (WCHAR);
	fOk = pfnGetUserProfileDirectory (hThreadToken, m_wszProfileDir, &dwSize);

	VERIFY (CloseHandle (hThreadToken));
	FreeLibrary (hModule);
	hModule = 0;

	if (!fOk)
	{
		TRACE (L"GetUserProfileDirectory failed");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	return S_OK;
}

HRESULT
CUserSecurityTransformer::GetUserProfileDir (LPCWSTR i_wszUserName,
											 LPWSTR i_wszDomainName,
											 DWORD i_dwLenDomainName)
{
	const ULONG cSidSize = 100;
	TSmartPointerArray<WCHAR> spSid = new WCHAR[cSidSize];
	if (spSid == 0)
	{
		return E_OUTOFMEMORY;
	}

	DWORD dwSid = cSidSize * sizeof (WCHAR);
	SID_NAME_USE use;
	
	BOOL fOk = LookupAccountNameW (0, i_wszUserName, spSid, &dwSid, i_wszDomainName, &i_dwLenDomainName, &use);
	if (!fOk)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	
	WCHAR wszTextSid[256];
	DWORD dwTextSidSize = sizeof(wszTextSid);
	fOk = GetTextualSid (spSid, wszTextSid, &dwTextSidSize);
	if (!fOk)
	{
		TRACE (L"GetTextualSid failed");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	WCHAR wszProfileKey[256];
	wcscpy (wszProfileKey, L"Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList\\");
	wcscat (wszProfileKey, wszTextSid);

	HKEY hKey;
	LONG lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE, wszProfileKey, 0, KEY_READ, &hKey);
	if (lResult != ERROR_SUCCESS)
	{
		TRACE (L"Unable to open registry key: %s", wszProfileKey);
		return HRESULT_FROM_WIN32(lResult);
	}

	WCHAR wszProfilePath[MAX_PATH] = L"";
	DWORD dwSize = sizeof (wszProfilePath);
	DWORD dwType = REG_EXPAND_SZ;

	lResult = RegQueryValueEx (hKey, L"ProfileImagePath", 0, &dwType, (BYTE *)wszProfilePath, &dwSize);

	// first close the key to avoid possible handle leak
	VERIFY (RegCloseKey (hKey));

	if (lResult != ERROR_SUCCESS)
	{
		TRACE (L"RegQueryValueEx failed for \"ProfileImagePath\" subkey of %s", wszProfileKey);
		return HRESULT_FROM_WIN32(lResult);
	}

	fOk = ExpandEnvironmentStrings (wszProfilePath, m_wszProfileDir, sizeof(m_wszProfileDir) / sizeof(WCHAR));
	if (!fOk)
	{
		TRACE (L"ExpandEnvironmentStrings failed for %s", wszProfilePath);
		return HRESULT_FROM_WIN32(GetLastError ());
	}

	return S_OK;
}

BOOL
CUserSecurityTransformer::GetTextualSid(PSID pSid, LPWSTR szTextualSid, LPDWORD dwBufferLen) 
{
	   // Test if SID passed in is valid.
   if(!IsValidSid(pSid)) 
   {
      return FALSE;
   }

   // Obtain SidIdentifierAuthority.
   PSID_IDENTIFIER_AUTHORITY psia = GetSidIdentifierAuthority(pSid);

   // Obtain sidsubauthority count.
   DWORD dwSubAuthorities = *GetSidSubAuthorityCount(pSid);

   // Compute buffer length.
   // S-SID_REVISION- + identifierauthority- + subauthorities- + NULL
   DWORD dwSidSize = (15 + 12 + (12 * dwSubAuthorities) + 1) * sizeof(TCHAR);

   // Check provided buffer length.
   // If not large enough, indicate proper size and setlasterror
   if (*dwBufferLen < dwSidSize) 
   {
     *dwBufferLen = dwSidSize;
     SetLastError(ERROR_INSUFFICIENT_BUFFER);
	 TRACE (L"Insufficient buffer length");
     return FALSE;
   }

   DWORD dwSidRev = SID_REVISION;
   // Prepare S-SID_REVISION-.
   dwSidSize = wsprintf(szTextualSid, TEXT("S-%lu-"), dwSidRev);

   // Prepare SidIdentifierAuthority.
   if ((psia->Value[0] != 0) || (psia->Value[1] != 0)) 
   {
      dwSidSize += wsprintf(szTextualSid + lstrlen(szTextualSid),
            TEXT("0x%02hx%02hx%02hx%02hx%02hx%02hx"),
            (USHORT) psia->Value[0],
            (USHORT) psia->Value[1],
            (USHORT) psia->Value[2],
            (USHORT) psia->Value[3],
            (USHORT) psia->Value[4],
            (USHORT) psia->Value[5]);
   
   } 
   else 
   {
      dwSidSize += wsprintf(szTextualSid + lstrlen(szTextualSid),
            TEXT("%lu"),
            (ULONG) (psia->Value[5]      ) +
            (ULONG) (psia->Value[4] <<  8) +
            (ULONG) (psia->Value[3] << 16) +
            (ULONG) (psia->Value[2] << 24));
   }

   // Loop through SidSubAuthorities.
   for (DWORD dwCounter = 0; dwCounter < dwSubAuthorities; dwCounter++) 
   {
      dwSidSize += wsprintf(szTextualSid + dwSidSize, TEXT("-%lu"), *GetSidSubAuthority(pSid, dwCounter));
   }

   return TRUE;
} 


HRESULT
CUserSecurityTransformer::GetLastURTInstall ()
{
	WCHAR wszConfigDir[MAX_PATH];
	HRESULT hr = GetMachineConfigDir (wszConfigDir, sizeof (wszConfigDir) / sizeof(WCHAR));
	if (FAILED (hr))
	{
		TRACE (L"Unable to get machine config directory");
		return hr;
	}

	static LPWSTR wszConfig = L"\\Config\\";
	static SIZE_T cLenConfig = wcslen (wszConfig);
	SIZE_T cLenConfigDir = wcslen (wszConfigDir);

	if (_wcsicmp (wszConfigDir + cLenConfigDir - cLenConfig, wszConfig) != 0)
	{
		TRACE (L"Machine config directory doesn't end with '\\Config'");
		return E_INVALIDARG;
	}

	wszConfigDir[cLenConfigDir - cLenConfig] = L'\0'; 

	LPWSTR pVersionStart = wcsrchr (wszConfigDir, L'\\');
	if (pVersionStart == 0)
	{
		TRACE (L"No slash found for machine config directory");
		return E_INVALIDARG;
	}

	pVersionStart++; // skip the backslash

	if (*pVersionStart == L'v' || *pVersionStart == L'V')
	{
		wcscpy (m_wszLastVersion, pVersionStart);
	}

	if (m_wszLastVersion[0] == L'\0')
	{
		TRACE (L"Unable to retrieve version information for URT version");
		return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	}
	     

	return S_OK;
}

HRESULT
CUserSecurityTransformer::GetUserSecOn9X ()
{
	HRESULT hr = S_OK;

	WCHAR wszUserName[256];
	ULONG dwSize = sizeof(wszUserName) / sizeof (WCHAR);
	BOOL fOk = GetUserName (wszUserName, &dwSize);
	if (!fOk)
	{
		TRACE (L"Unable to get user name");
		return HRESULT_FROM_WIN32(GetLastError());
	}

	hr = GetLastURTInstall ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get version of last URT install");
		return hr;
	}

	static LPCWSTR wszWinDir = L"%WINDIR%\\";
	static LPCWSTR wszCLRSecurity = L"\\CLR security config\\";

	WCHAR wszUnexpandedPath[MAX_PATH];
	WCHAR wszPath[MAX_PATH];

	wsprintf (wszUnexpandedPath, L"%s%s%s%s", wszWinDir, wszUserName, wszCLRSecurity, m_wszLastVersion);

	fOk = ExpandEnvironmentStrings (wszUnexpandedPath, wszPath, sizeof(wszPath) / sizeof(WCHAR));
	if (!fOk)
	{
		TRACE (L"ExpandEnvironmentStrings failed for %s", wszUnexpandedPath);
		return HRESULT_FROM_WIN32(GetLastError ());
	}

	hr = AddSingleConfigStore (wszPath, g_wszSecurityCfgFile, m_wszSelector, L"", false);
	if (FAILED (hr))
	{
		TRACE (L"Unable to add single configuration store");
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbshared.h ===
//*****************************************************************************
// RegDBShared.h
//
// Helper macros and the like for shared RegDB projects.
//
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
#ifndef __regdbshared_h__
#define __regdbshared_h__

#define USE_NONCRTNEW
#define USE_ADMINASSERT
#include "catmacros.h"


inline HRESULT OutOfMemory()
{
	ASSERT(0 && "Out of memory error");
	return (E_OUTOFMEMORY);
}

#ifndef NumItems
#define NumItems(s) (sizeof(s) / sizeof(s[0]))
#endif


#ifndef __PLACEMENT_NEW_INLINE
#define __PLACEMENT_NEW_INLINE
inline void *__cdecl operator new(size_t, void *_P)
{
	return (_P);
}
#endif __PLACEMENT_NEW_INLINE


#endif // __regdbshared_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\usersecuritytransformer.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    usersecuritytransformer.h

$Header: $

Abstract:

Author:
    marcelv 	1/15/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __USERSECURITYTRANSFORMER_H__
#define __USERSECURITYTRANSFORMER_H__

#pragma once

#include "transformerbase.h"

class CUserSecurityTransformer : public CTransformerBase
{
public:
	CUserSecurityTransformer ();
	virtual ~CUserSecurityTransformer ();

    STDMETHOD (Initialize) (ISimpleTableDispenser2 * i_pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores);


private:
	// no copies
	CUserSecurityTransformer  (const CUserSecurityTransformer&);
	CUserSecurityTransformer& operator= (const CUserSecurityTransformer&);
	
	HRESULT GetUserSecOnNT ();
	HRESULT GetUserProfileDir (LPCWSTR i_wszUserName, LPWSTR i_wszDomainName, DWORD i_dwLenDomainName);
	HRESULT GetCurrentUserProfileDir ();
	HRESULT GetLastURTInstall ();

	HRESULT GetUserSecOn9X ();

	BOOL GetTextualSid(PSID pSid, LPWSTR szTextualSid, LPDWORD dwBufferLen);

	WCHAR m_wszProfileDir[MAX_PATH];
	WCHAR m_wszLastVersion[MAX_PATH];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\clbwrite.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// clbwrite.cpp
// Implements APIs for reading versioned clb file.
// Changes are always written to a temporary file. In CLBCommitWrite, a new
// version is created.
//*****************************************************************************
#include "stdafx.h"	
#include "clbread.h"
#include "catmacros.h"
#include "catalog.h"
#include "WasSec.h"
#include "aclapi.h"
#include "SvcMsg.h"

CMapICR		g_mapWriteICR;
BOOL		RunningOnWinNT();

HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);

//*****************************************************************************
// Get the ICR of the temporary file used for writing. Creating the temp file 
// first if it doesn't exist yet.
//*****************************************************************************

HRESULT CLBGetWriteICR(const WCHAR* wszFileName,			//clb file name
					   IComponentRecords** ppICR,			//return ICR pointer
					   COMPLIBSCHEMA* pComplibSchema,		//Complib schema structure
					   COMPLIBSCHEMABLOB* pSchemaBlob)		//Complib schema blob
{

	HRESULT hr;
	ULONG cchFileName;
	CLB_VERINFO clbInfo;
	LPWSTR wszTmpFileName = NULL;
    SECURITY_ATTRIBUTES saStorage;
    PSECURITY_ATTRIBUTES psaStorage = NULL;
	PACL		pDACL = NULL;
	PSECURITY_DESCRIPTOR pSD = NULL;


	*ppICR = NULL;


	//check the write map first, if a matching temporary file is found, AddRef and return
	if ( g_mapWriteICR.Find ( (LPWSTR)wszFileName, ppICR, NULL ) )
	{
		(*ppICR)->AddRef();
		return S_OK;
	}

	memset( &clbInfo, 0, sizeof( CLB_VERINFO ) );

	// Get security attributes.
	hr = g_WASSecurity.Init();
	if (FAILED(hr))
	{
		ASSERT(0);
		goto ErrExit;
	}

    if (g_WASSecurity.GetSecurityDescriptor() != NULL) 
	{
        saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
        saStorage.lpSecurityDescriptor = g_WASSecurity.GetSecurityDescriptor();
        saStorage.bInheritHandle = FALSE;
        psaStorage = &saStorage;
    }

	//Get the latest version number.
	cchFileName = (ULONG)wcslen( wszFileName );

	// Need \\?\FileName.[12digit version] for FindFirstFile if 
	// FileName.[12digit version] exceeds _MAX_PATH

	clbInfo.cchBuf = cchFileName + 21;
	clbInfo.pwszFileName = new WCHAR[cchFileName + 21];
	if ( !clbInfo.pwszFileName ) return E_OUTOFMEMORY;
	hr = _CLBGetLatestVersion( wszFileName, cchFileName + 13 >= _MAX_PATH, &clbInfo, TRUE );
	

	if ( FAILED(hr) && hr != HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )
		goto ErrExit;
	
	//Allocate a buffer for the temporary file name
	wszTmpFileName = new WCHAR[cchFileName + 5];		//FileName.tmp
	if ( wszTmpFileName == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto ErrExit;
	}
		
	wcscpy( wszTmpFileName, wszFileName );
	wcscat( wszTmpFileName, L".tmp");

MakeTemp:

	//Create the temporary file.
	if ( SUCCEEDED(hr) )
	{
		//Copy the latest verson to the temp file.
		if (!CopyFile(clbInfo.pwszFileName, wszTmpFileName, false))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_CLB_INTERNAL_ERROR, NULL));
			goto ErrExit;
		}

		// Get the DACL of the original file.
		hr = GetNamedSecurityInfo(clbInfo.pwszFileName,
									   SE_FILE_OBJECT,
									   DACL_SECURITY_INFORMATION,
									   NULL,
									   NULL,
									   &pDACL,
									   NULL,
									   &pSD);
		if (hr != ERROR_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(hr);
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_CLB_INTERNAL_ERROR, clbInfo.pwszFileName));
			hr = S_OK;
		}		
		// Set the DACL of the original file to the copy.
		else 
		{
			hr = SetNamedSecurityInfo(wszTmpFileName,
										   SE_FILE_OBJECT,
										   DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
										   NULL,
										   NULL,
										   pDACL,
										   NULL); 
			if (hr != ERROR_SUCCESS)
			{
				hr = HRESULT_FROM_WIN32(hr);
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_CLB_INTERNAL_ERROR, wszTmpFileName));
				hr = S_OK;
			}
		}

		// Cleanup the security descriptor.
		if (NULL != pSD)
		{
			LocalFree(pSD);
		}
	}
	else	//There's no old version to copy from, create a new file
	{
		IComponentRecords *pICR = NULL;
		
		// Create a new database file of this version.
		if (SUCCEEDED(hr = CreateComponentLibraryEx(wszTmpFileName,
					DBPROP_TMODEF_DFTWRITEMASK | DBPROP_TMODEF_ALIGNBLOBS, &pICR, psaStorage)))
		{
			// Save the changes to disk.
			hr = pICR->Save(NULL);
		}
	
		// Free up the new database.
		if (pICR)
			pICR->Release();

		if ( FAILED(hr) ) goto ErrExit;
	}

	//Create the ICR from the temp file
	hr = OpenComponentLibraryEx(wszTmpFileName, DBPROP_TMODEF_DFTREADWRITEMASK | DBPROP_TMODEF_ALIGNBLOBS | DBPROP_TMODEF_NOTXNBACKUPFILE, ppICR, psaStorage);
	if ( FAILED(hr) ) goto ErrExit;

	//Add schema
	hr = (*ppICR)->SchemaAdd(pSchemaBlob);
	if ( FAILED (hr) ) 
	{
		if ( hr == CLDB_E_SCHEMA_VERMISMATCH )
		{	
			//When schema version mismatch happens, delete the temporary file and the original
			//clb file, create an empty one with the current schema version.
			(*ppICR)->Release();
			*ppICR = NULL;

			if ( !DeleteFile( wszTmpFileName ) )
			{
				hr = HRESULT_FROM_WIN32( GetLastError() );
				goto ErrExit;
			}
			DeleteFile( clbInfo.pwszFileName );

			goto MakeTemp;
		}

		else
			goto ErrExit;
	}

	//Add the ICR to the map
	hr =  g_mapWriteICR.Add( (LPWSTR)wszFileName, ppICR, clbInfo.i64VersionNum );

ErrExit:

	if ( clbInfo.pwszFileName )
		delete [] clbInfo.pwszFileName;

	if ( wszTmpFileName )
		delete [] wszTmpFileName;

	if ( FAILED (hr) && *ppICR )
	{
		(*ppICR)->Release();
		*ppICR = NULL;
	}

	return hr;

}


//*****************************************************************************
// Save and rename the temporary file to the new version. Delete its entry in write ICR
// map.
//*****************************************************************************
HRESULT CLBCommitWrite( LPCWSTR wszDatabase, const WCHAR* wszInFileName )
{
	__int64 i64PreVersion;
	LPWSTR pwszFileName = NULL;		//points to either wszFileNameBuf or dynamicly allocated.
	WCHAR wszFileNameBuf[_MAX_PATH];
	LPWSTR wszTmpFileName = NULL;
	ULONG cchFileName;
	HRESULT hr;
	BOOL bRenamed;
	WCHAR wszVersionBuf[14];
	IComponentRecords* pICR;
	ISimpleTableEventMgr *pISTEventMgr = NULL;

	ASSERT( wszInFileName );
	
	//Copy the passed in name
	cchFileName = (ULONG)wcslen(wszInFileName);
	if ( cchFileName + 13 >= _MAX_PATH )
	{
		pwszFileName = new WCHAR[ cchFileName + 14 ];
		if ( !pwszFileName ) return E_OUTOFMEMORY;
	}
	else
		pwszFileName = wszFileNameBuf;
	wcscpy( pwszFileName, wszInFileName );

	//Find the ICR and version for this file in the write map
	if ( !g_mapWriteICR.Find ( pwszFileName, &pICR, &i64PreVersion ) )
	{
		hr = E_FAIL;
		goto ErrExit;
	}
	//Save the changes to disk
	hr = pICR->Save( NULL );
	if ( FAILED(hr) ) goto ErrExit;
	pICR = NULL;	//the reference of the ICR owned by the map will be released when the entry
					//is deleted from the map, i.e. g_mapWriteICR.Delete( pwszFileName );
	wszTmpFileName = new WCHAR[ cchFileName + 5 ];			//FileName.tmp
	if ( wszTmpFileName == NULL )
	{
		hr = E_OUTOFMEMORY;
		goto ErrExit;
	}
	wcscpy( wszTmpFileName, pwszFileName );
	wcscat( wszTmpFileName, L".tmp" );

	//Clean up the entry from the write map and read map.
	g_mapWriteICR.Delete( pwszFileName );
	_GetCLBReadState()->mapReadICR.Delete( pwszFileName );

	swprintf(wszVersionBuf, L".%012I64x", i64PreVersion+1);
	wcscat ( pwszFileName, wszVersionBuf );
	
	//Rename file
	bRenamed = MoveFile(wszTmpFileName, pwszFileName);

	if (!bRenamed)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		ASSERT(0);
		return hr;
	}

	//Try to delete the previous version
	pwszFileName[cchFileName] = '\0';
	swprintf(wszVersionBuf, L".%012I64x", i64PreVersion);
	wcscat ( pwszFileName, wszVersionBuf );

	DeleteFile( pwszFileName );

	// After the commit succeeds, tell the event manager to fire the relevant events.
	hr = ReallyGetSimpleTableDispenser(IID_ISimpleTableEventMgr, (LPVOID*)&pISTEventMgr, 0);
	if (FAILED(hr)) goto ErrExit;

	hr = pISTEventMgr->FireEvents((ULONG)i64PreVersion);
	if (FAILED(hr)) goto ErrExit;

ErrExit:

	if ( pwszFileName && pwszFileName != wszFileNameBuf )
		delete [] pwszFileName;

	if ( wszTmpFileName )
		delete [] wszTmpFileName;

	if (pISTEventMgr)
		pISTEventMgr->Release();
	return hr;

}

//*****************************************************************************
//Delete the temporary file
//*****************************************************************************
HRESULT CLBAbortWrite( LPCWSTR wszDatabase, LPCWSTR wszInFileName )
{
	WCHAR wszFileNameBuf[_MAX_PATH];
	LPWSTR pwszFileName = NULL;
	ULONG cchFileName;
	ISimpleTableEventMgr *pISTEventMgr = NULL;
	HRESULT hr;

	if ( wszInFileName )	//Cookdown code requires I tolerate the case wszInFileName == NULL
	{	
	//Copy the passed in name
		cchFileName = (ULONG)wcslen(wszInFileName);
		if ( cchFileName + 4 >= _MAX_PATH )
		{
			pwszFileName = new WCHAR[ cchFileName + 5 ];
			if ( !pwszFileName ) return E_OUTOFMEMORY;
		}
		else
			pwszFileName = wszFileNameBuf;
		wcscpy( pwszFileName, wszInFileName );

		g_mapWriteICR.Delete( pwszFileName );

		wcscat( pwszFileName, L".tmp" );

		DeleteFile( pwszFileName );
	}

	// If the txn has aborted, tell the event manager to cancel events it was planning to fire.
	hr = ReallyGetSimpleTableDispenser(IID_ISimpleTableEventMgr, (LPVOID*)&pISTEventMgr, 0);
	if (FAILED(hr)) goto ErrExit;

	hr = pISTEventMgr->CancelEvents();
	if (FAILED(hr)) goto ErrExit;

ErrExit:

	if ( pwszFileName && pwszFileName != wszFileNameBuf )
		delete [] pwszFileName;

	if (pISTEventMgr)
		pISTEventMgr->Release();

	return hr;
}


//*****************************************************************************
//Grab the mutex for serialize writing to the file
//*****************************************************************************
HRESULT GetWriteLock( LPCWSTR wszDatabase, LPCWSTR wszInFileName, HANDLE* phLock )
{
	WCHAR wszNameBuf[ MAX_PATH ];
	LPWSTR wszMutex = NULL;
	LPWSTR pwsz;
	HRESULT hr = S_OK;

	ASSERT( wszDatabase || wszInFileName );

	//if wszInFileName passed into CLBAbortWrite is NULL, the entry in the write map won't 
	//be cleaned up. Delete again here to make sure it's gone.
	g_mapWriteICR.Delete( (LPWSTR)wszInFileName );

	if ( wszInFileName && wcslen( wszInFileName ) >= MAX_PATH )
	{
		wszMutex = new WCHAR[ wcslen( wszInFileName ) + 1 ];
		if ( NULL == wszMutex )
			return E_OUTOFMEMORY;
	}
	else
		wszMutex = wszNameBuf;

//	wcscpy( wszMutex, L"Global\\" );
//	@todo: An appropriate ACL should be added to the named mutex. If we are sure only one process is
//	going to do cookdown, then the mutex doesn't need a name. 
	if ( wszInFileName )
	{
		wcscpy( wszMutex, wszInFileName );

		for ( pwsz = &wszMutex[0]; *pwsz != '\0'; pwsz++ )
		{
			if ( *pwsz == '\\' )
					*pwsz = '_';
		}
	}
	else
		wcscpy(&wszMutex[0], wszDatabase);

	wcscat( wszMutex, L"_CLBMUTEX" );

	*phLock = CreateMutex( NULL, FALSE, wszMutex );

	if ( 0 == *phLock )
	{
		hr =  HRESULT_FROM_WIN32( GetLastError() );
	}
	else 
	{
		WaitForSingleObject( *phLock, INFINITE );
	}

	if ( wszMutex != wszNameBuf )
		delete [] wszMutex;

	return hr;
}


//*****************************************************************************
//Release the mutex for serialize writing to the file
//*****************************************************************************
HRESULT ReleaseWriteLock( HANDLE hLock )
{
	ReleaseMutex( hLock );
	CloseHandle( hLock );

	return S_OK;
}


//*****************************************************************************
//Create a new oid from the temporary write file
//*****************************************************************************
HRESULT GetNewOIDFromWriteICR( const WCHAR* wszFileName, ULONG* pulOID )
{
	IComponentRecords* pICR = NULL;

	//Find the file in the write map, fail if not found
	if ( g_mapWriteICR.Find ( (LPWSTR)wszFileName, &pICR, NULL ) == FALSE )
		return E_FAIL;

	return ( pICR->NewOid( (OID*)pulOID ) );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\webhierarchytransformer.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    webhierarchytransformer.h

$Header: $

Abstract:
	Web Hierarchy Transformer

Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WEBHIERARCHYTRANSFORMER_H__
#define __WEBHIERARCHYTRANSFORMER_H__

#pragma once

#include "transformerbase.h"

#include <iadmw.h>
#include <iiscnfg.h>
#include <atlbase.h>
#include "tlist.h"

class CConfigNode; // forward decl

//TODO(marcelv) logical path for query strings is incorrect

/**************************************************************************++
Class Name:
    CWebHierarchyTransformer

Class Description:
    Web Hierarchy Transformer definition

Constraints:
	None.
--*************************************************************************/
class CWebHierarchyTransformer : public CTransformerBase 
{
public:
	CWebHierarchyTransformer ();
	virtual ~CWebHierarchyTransformer ();

		//ISimpleTableTransform Initialize function
    STDMETHOD (Initialize) (ISimpleTableDispenser2 * i_pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelectorString, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores);
private:
	// no copies
	CWebHierarchyTransformer  (const CWebHierarchyTransformer&);
	CWebHierarchyTransformer & operator= (const CWebHierarchyTransformer &);

	HRESULT WalkVDirs ();
	HRESULT CreateConfigStores ();

	HRESULT GetVirtualDir (LPCWSTR i_wszRelPath, LPWSTR io_wszVDir, DWORD i_dwSize);
	HRESULT GetWebServer (LPWSTR *io_pwszResult);
	HRESULT GetIISWebServer (LPWSTR *io_pwszResult);
	HRESULT AddConfigNode (LPCWSTR i_wszPath, LPCWSTR i_wszFileName, LPCWSTR i_wszLogicalDir, bool fAddLinkToParent);
	HRESULT CreateParentConfigStore (CConfigNode *pLocation, TList<LPCWSTR>& subdirList);
	HRESULT GetServerComment (LPWSTR io_wszServerComment, DWORD i_dwLenServerComment);

	LPWSTR m_wszPathHelper;					// performaance optimization. Instead of allocating memory
											// all the time, we allocate memory once
	CComPtr<IMSAdminBase> m_spAdminBase;	// Pointer to get metabase inforamtion
	LPWSTR m_wszServerPath;					// Metabase Path to the server information

	TList<CConfigNode *> m_configNodeList;
	CConfigNode * m_pLastInList;
};

class CLocation
{
public:
	CLocation ();
	~CLocation ();

	LPCWSTR Path () const;
	BOOL    AllowOverride () const;
	HRESULT Set (LPCWSTR i_wszPath, BOOL i_fAllowOverride);
	
private:
	LPWSTR m_wszPath;			// path attribute
	BOOL    m_fAllowOverride;	// allowoverride attribute
};

class CConfigNode
{
public:
	CConfigNode ();
	~CConfigNode ();

	LPCWSTR Path () const;
	LPCWSTR LogicalDir () const;
	LPCWSTR FileName () const;
	CConfigNode * Parent ();

	HRESULT Init (LPCWSTR i_wszParentDir, LPCWSTR i_wszFileName, LPCWSTR wszLogicalDir);
	void SetParent (CConfigNode *pParent);
	BOOL AllowOverrideForLocation (LPCWSTR i_wszLocation);
	HRESULT GetLocations (ISimpleTableDispenser2 * i_pDispenser);

private:
	LPWSTR m_wszFullPath;
	LPWSTR m_wszLogicalDir; // logical directory
	LPWSTR m_wszFileName;
	CConfigNode *m_pParent; // set to direct parent, or 0 if no direct parent

	TList<CLocation *> m_locations;  // locations for this element
	bool m_fInitialized;             // are we initialized
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\clbread.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// clbread.cpp
// Implements APIs for reading versioned clb file.
//*****************************************************************************
#include "stdafx.h"	
#include "clbread.h"
#include "array_t.h"
#include "catmeta.h"

typedef Array<__int64> INT64ARRAY;

CLBREAD_STATE g_CLBReadState;
CSNMap g_snapshotMap;

extern ULONG g_aFixedTableHeap[];

HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);
UINT InternalGetSystemWindowsDirectory(LPTSTR lpBuffer, UINT uSize);
BOOL RunningOnWinNT();

//*****************************************************************************
//Return g_CLBReadState
//*****************************************************************************
CLBREAD_STATE* _GetCLBReadState()
{
	return &g_CLBReadState;
}

//*****************************************************************************
//Get the windows directory for later use in creating default database names
//Get the global Fixup structure for later use in getting schema info
//*****************************************************************************
HRESULT CLBReadInit()
{
	HRESULT hr = S_OK;
	CComPtr<IAdvancedTableDispenser> pISTDisp;


	UTSemRWMgrWrite lockMgr( &g_CLBReadState.lockInit );

	if ( !g_CLBReadState.bInitialized )
	{

		ULONG cch = InternalGetSystemWindowsDirectory(g_CLBReadState.wszWINDIR, _MAX_PATH);
		if ( cch == 0 || cch >=  _MAX_PATH )
		{
			ASSERT(0);
			return E_FAIL;
		}

		if ( g_CLBReadState.wszWINDIR[cch-1] != L'\\' )
		{
			if ( cch + 1 >= _MAX_PATH )
				return FALSE;

			g_CLBReadState.wszWINDIR[cch] = L'\\';
			g_CLBReadState.wszWINDIR[cch+1] = L'\0';
		}

		hr = ReallyGetSimpleTableDispenser( IID_IAdvancedTableDispenser, (LPVOID*)&pISTDisp, 0);
		if ( FAILED ( hr ) )
			return hr;

		hr = pISTDisp->GetTable (wszDATABASE_META, wszTABLE_DATABASEMETA, NULL, NULL, eST_QUERYFORMAT_CELLS, 
								 0, (LPVOID*) &(g_CLBReadState.pISTReadDatabaseMeta) );

		if ( FAILED ( hr ) )
			return hr;

		hr = pISTDisp->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, NULL, NULL, eST_QUERYFORMAT_CELLS, 
								 0, (LPVOID*) &(g_CLBReadState.pISTReadColumnMeta) );

		if ( FAILED ( hr ) )
			return hr;

        g_CLBReadState.pFixedTableHeap = reinterpret_cast<const FixedTableHeap *>(g_aFixedTableHeap);

		//Initialize the security attributes for the shared file mapping.
		//The following code is copied from regdbapi.cpp in Viper tree.
		if (RunningOnWinNT())
		{
			if (!InitializeSecurityDescriptor(&g_CLBReadState.sdRead, SECURITY_DESCRIPTOR_REVISION))
			{
				return HRESULT_FROM_WIN32( GetLastError() );
			}
			
			
			//we will grant EVERYONE all rights except for WRITE_DAC | WRITE_OWNER.

			PACL  pAcl                            = NULL;
			DWORD cbAcl                           = 0;
			SID_IDENTIFIER_AUTHORITY SidAuthority = SECURITY_WORLD_SID_AUTHORITY;
			PSID  pSidEveryone                    = NULL;

			if ( !AllocateAndInitializeSid(&SidAuthority, 1, SECURITY_WORLD_RID,
				0, 0, 0, 0, 0, 0, 0, &pSidEveryone) )
			{
				return HRESULT_FROM_WIN32( GetLastError() );
			}

			if(pSidEveryone)
			{
				cbAcl = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + GetLengthSid(pSidEveryone);
				pAcl  = (PACL) new char[cbAcl];
				if (!pAcl)
					return E_OUTOFMEMORY;
				g_CLBReadState.pAcl  = pAcl;

				
				DWORD dwDeniedAccess = WRITE_DAC | WRITE_OWNER;
                
				InitializeAcl(pAcl, cbAcl, ACL_REVISION);
				AddAccessAllowedAce(pAcl, ACL_REVISION, ~dwDeniedAccess, pSidEveryone);

    			FreeSid(pSidEveryone);
			}
			else
				return E_OUTOFMEMORY;

			// Set the access control list on the security descriptor.
			if (!SetSecurityDescriptorDacl(&g_CLBReadState.sdRead, TRUE, (PACL) pAcl, FALSE))
			{
				return HRESULT_FROM_WIN32( GetLastError() );
			}

			// Fill in the security attributes.
			g_CLBReadState.sa.nLength              = sizeof(g_CLBReadState.sa);
			g_CLBReadState.sa.lpSecurityDescriptor = &g_CLBReadState.sdRead;
			g_CLBReadState.sa.bInheritHandle       = FALSE;
			g_CLBReadState.psa                     = &(g_CLBReadState.sa);

		}
	
		g_CLBReadState.bInitialized = TRUE;
	}

	return S_OK;


}


//*****************************************************************************
// Do the real work:
// Open the latest clb file for read 
// psnid == NULL: don't care about snapshot
// *psnid == 0. Get the latest version and return snid. In this case, ICR is 
// always created if it's not in the map yet.
// *psnid > 0. Get ICR for this snapshot
//*****************************************************************************
HRESULT InternalCLBGetReadICR(const WCHAR* wszFileName,			//clb file name, null means using default
							  IComponentRecords** ppICR,			//return ICR pointer
							  COMPLIBSCHEMA* pComplibSchema,		//Complib schema structure
							  COMPLIBSCHEMABLOB* pSchemaBlob,		//Complib schema blob
							  ULONG *psnid	 						//snap shot id, which is the lower 4 bytes of the version number
							 )
{
	HRESULT hr;
	ULONG cchFileName;
	WCHAR wszVersionedFileName[_MAX_PATH];
	CLB_VERINFO clbInfo;
	__int64 i64CachedVersion;
	unsigned __int64 i64LastWriteTime;
	IComponentRecords *pICRLocal = NULL;

	memset( &clbInfo, 0, sizeof( CLB_VERINFO ) );

	if ( psnid )
	{	
		if ( *psnid > 0 && ppICR )
		{	//Called from Intercept(), Find the matching ICR instance for a snapshot,
			//Fail if not in the map
			if ( g_snapshotMap.Find( (LPWSTR)wszFileName, *psnid, ppICR ) )
			{
				(*ppICR)->AddRef();
				return S_OK;
			}
			else
			{
				ASSERT(0 && "ICR for this snapshot not found!");
				return E_ST_INVALIDSNID;
			}
		}
		else
		{	//Called from InternalGetLatestSnid() or InternalAddRefSnid()
			ASSERT( ppICR == NULL );
			clbInfo.i64VersionNum = (__int64)(*psnid);
		}
	}


	//check for long file name, get the latest version number.
	cchFileName = (ULONG)wcslen( wszFileName );

	if ( cchFileName + 13 >= _MAX_PATH ) //cchFileName.[12digit version] exceeds _MAX_PATH
	{
		clbInfo.cchBuf = cchFileName + 18;	
		clbInfo.pwszFileName = new WCHAR[cchFileName + 18];
		if ( !clbInfo.pwszFileName ) return E_OUTOFMEMORY;
		hr = _CLBGetLatestVersion( wszFileName, TRUE, &clbInfo );
	}
	else
	{	
		clbInfo.cchBuf = _MAX_PATH;
		clbInfo.pwszFileName = wszVersionedFileName;
		hr = _CLBGetLatestVersion( wszFileName, FALSE, &clbInfo );
	}

	if ( FAILED(hr) ) goto ErrExit;

	if ( psnid )
	{
		//If the latest snapshot is requested, find it in the snapshot map.
		if ( *psnid == 0 )
		{
			//called from InternalGetLatestSnid()
			*psnid = (ULONG)(clbInfo.i64VersionNum);
			if ( g_snapshotMap.AddRefSnid( (LPWSTR)wszFileName, *psnid ) )
			{
				hr = S_OK;
				goto ErrExit;
			}
		}
	}
	else 
	{	//Don't care about the snapshot
		//Look for this file in the read map. If found, compare the version number
		ASSERT( ppICR );
		if ( g_CLBReadState.mapReadICR.Find ( (LPWSTR)wszFileName, ppICR, &i64CachedVersion, &i64LastWriteTime ) )
		{
			//If we already have the latest version cached, AddRef() and return,
			if ( i64CachedVersion == clbInfo.i64VersionNum && i64LastWriteTime == clbInfo.i64LastWriteTime )
			{
				(*ppICR)->AddRef();
				hr = S_OK;
				goto ErrExit;
			}
			else
				*ppICR = NULL;
		}
	}


	//Create a new icr instance. If the file size is bigger than 64K, open it as shared
	//memory mapped file. ICR for a snapshot is always memory mapped.
	if ( clbInfo.cbFileSize >= MIN_MAP_SIZE || psnid )
	{
		WCHAR wszMap[_MAX_PATH];
		LPWSTR pwszMapName = NULL;

		if ( cchFileName + 13 >= _MAX_PATH )
		{
			pwszMapName = new WCHAR[cchFileName + 14];
			if ( pwszMapName == NULL )
			{
				hr = E_OUTOFMEMORY;
				goto ErrExit;
			}
		}
		else
			pwszMapName = wszMap;

		
		//If the map name is greater than or equal to MAXSHMEM, truncate the head.
		int len = (int)wcslen( clbInfo.pwszFileName );
		if ( len < MAXSHMEM )
			wcscpy ( pwszMapName, clbInfo.pwszFileName );
		else
			wcscpy ( pwszMapName, clbInfo.pwszFileName + len + 1 - MAXSHMEM );


		LPWSTR pwsz;

		for ( pwsz = pwszMapName; *pwsz != '\0'; pwsz++ )
		{
			if ( *pwsz == '\\' )
				*pwsz = '_';
		}

		hr = OpenComponentLibrarySharedTS(clbInfo.pwszFileName, pwszMapName, 
				0, g_CLBReadState.psa,
				DBPROP_TMODEF_READ | DBPROP_TMODEF_SMEMOPEN | DBPROP_TMODEF_SMEMCREATE, 
				&pICRLocal);


		if ( pwszMapName && pwszMapName != wszMap )
			delete [] pwszMapName;

	}
	else
		hr = OpenComponentLibraryTS( clbInfo.pwszFileName, DBPROP_TMODEF_READ, &pICRLocal );


	if ( FAILED(hr) )
	{
		ASSERT(0 &&"OpenComponentLibrary failed!");
		goto ErrExit;
	}

	//Add schema
	hr = pICRLocal->SchemaAdd(pSchemaBlob);
	if ( FAILED (hr) ) goto ErrExit;

	//Add the ICR to the map
	if ( psnid )
	{
		hr =  g_snapshotMap.Add( (LPWSTR)wszFileName, pICRLocal, clbInfo.i64VersionNum );
		ASSERT( ppICR == NULL );
	}
	else
	{
		hr =  g_CLBReadState.mapReadICR.Add( (LPWSTR)wszFileName, &pICRLocal, clbInfo.i64VersionNum, clbInfo.i64LastWriteTime );
		*ppICR = pICRLocal;
	}
	
ErrExit:

	if ( clbInfo.pwszFileName && clbInfo.pwszFileName != wszVersionedFileName )
		delete [] clbInfo.pwszFileName;

	if ( FAILED (hr) && ppICR && *ppICR )
	{
		(*ppICR)->Release();
		*ppICR = NULL;
	}

	return hr;


}


//*****************************************************************************
//Retry for the expected errors under stress
//*****************************************************************************
HRESULT CLBGetReadICR(const WCHAR* wszFileName,			//clb file name, null means using default
					  IComponentRecords** ppICR,			//return ICR pointer
					  COMPLIBSCHEMA* pComplibSchema,		//Complib schema structure
					  COMPLIBSCHEMABLOB* pSchemaBlob,		//Complib schema blob
					  ULONG *psnid	 						//snap shot id, which is the lower 4 bytes of the version number
					 )
{
	HRESULT		hr = S_OK;

	for ( int iRetry=0;  iRetry<10;  iRetry++)
	{
		if (iRetry == 5)
			Sleep(1000);

		hr = InternalCLBGetReadICR( wszFileName,
									ppICR,
									pComplibSchema,
									pSchemaBlob,
									psnid
									);

		if ( SUCCEEDED(hr) )
		{
			if ( ppICR && (*ppICR == NULL) ) return E_UNEXPECTED;	
		
			return hr;
		}

		switch ( hr )
		{
			case CLDB_E_SMDUPLICATE:
			case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
				break;
			default:
				return hr;
		}
	}

	return (hr);
}


//*****************************************************************************
//Get the database and schema info from the database meta
//*****************************************************************************
HRESULT _CLBGetSchema(LPCWSTR wszDatabase,						//database ID
					  COMPLIBSCHEMA* pComplibSchema,	//return the schema structure
					  COMPLIBSCHEMABLOB* pSchemaBlob,   //return the schema blob structure
					  LPWSTR* pwszDefaultName)			//return the default clb file name
{
	const DatabaseMeta* pDataBaseMeta = NULL;
	ULONG i;	//index into the database meta table

	LPVOID apv[1] = { (LPVOID)wszDatabase };

	if ( !(g_CLBReadState.bInitialized) )
	{
		HRESULT hr = CLBReadInit();
		if ( FAILED( hr ) )
			return hr;
	}

	ASSERT( g_CLBReadState.pISTReadDatabaseMeta );
	HRESULT hr = g_CLBReadState.pISTReadDatabaseMeta->GetRowIndexByIdentity( NULL, apv, &i );
	if ( FAILED(hr) ) 
		return hr;

    pDataBaseMeta = g_CLBReadState.pFixedTableHeap->Get_aDatabaseMeta(i);
    ASSERT(pDataBaseMeta);

	//Fill in the schema structure
	if ( pComplibSchema )
	{
		pComplibSchema->psid = g_CLBReadState.pFixedTableHeap->GuidFromIndex(pDataBaseMeta->iGuidDid);
		pComplibSchema->Version = g_CLBReadState.pFixedTableHeap->UI4FromIndex(pDataBaseMeta->BaseVersion);
	}

	//Get the default file name
	if ( pwszDefaultName )
	{
		*pwszDefaultName = new WCHAR[ wcslen( g_CLBReadState.wszWINDIR ) + wcslen( wszDatabase ) + 5 ];
		if ( NULL == *pwszDefaultName )
			return E_OUTOFMEMORY;
	
		wcscpy ( *pwszDefaultName, g_CLBReadState.wszWINDIR );
		wcscat ( *pwszDefaultName, wszDatabase );
		wcscat ( *pwszDefaultName, L".clb" );
	}

	//Fill in the schema blob structure
	if ( pSchemaBlob )
	{
		ASSERT( pComplibSchema );
		pSchemaBlob->pSchemaID = pComplibSchema;
		pSchemaBlob->iTables = static_cast<USHORT>(g_CLBReadState.pFixedTableHeap->UI4FromIndex(pDataBaseMeta->CountOfTables)),
		pSchemaBlob->fFlags = 0;
		pSchemaBlob->pbReadWrite = pSchemaBlob->pbReadOnly = g_CLBReadState.pFixedTableHeap->BytesFromIndex(pDataBaseMeta->iSchemaBlob);
		pSchemaBlob->cbReadWrite = pSchemaBlob->cbReadOnly = pDataBaseMeta->cbSchemaBlob;
		pSchemaBlob->pbNames = g_CLBReadState.pFixedTableHeap->BytesFromIndex(pDataBaseMeta->iNameHeapBlob);
		pSchemaBlob->cbNames = pDataBaseMeta->cbNameHeapBlob;
	}

	return S_OK;
}


//*****************************************************************************
//Finding the latest version of a complib file given the path of the file
//*****************************************************************************

HRESULT	_CLBGetLatestVersion(					
	LPCWSTR		wszCLBFilePath,			// Path of the complib file
	BOOL		bLongPath,				// Path + version exceeds MAX_PATH
	CLB_VERINFO *pdbInfo,				// Return current version.
	BOOL		bDeleteOldVersions)		// Indicates whether we want to delete the old versions of this file
{
	HANDLE		hFind=INVALID_HANDLE_VALUE;	// Find handle.
	WIN32_FIND_DATA FileData;			// For each found file.
	__int64		iVersion;				// Version number conversion.
	INT64ARRAY	aOldVersions;

	ASSERT(pdbInfo->pwszFileName);
	pdbInfo->pwszFileName[0] = 0;
	
	if ( bLongPath )
		wcscat( pdbInfo->pwszFileName,L"\\\\?\\" );

	wcscat( pdbInfo->pwszFileName, wszCLBFilePath );
	if ( pdbInfo->i64VersionNum > 0 )
	{	//If a snapshot id is specified, search file based on it.
		WCHAR wszSnid[9];
		_i64tow(pdbInfo->i64VersionNum, wszSnid, 16);
		wcscat( pdbInfo->pwszFileName, L".????00000000");
		wcscpy( pdbInfo->pwszFileName+wcslen(pdbInfo->pwszFileName)-wcslen(wszSnid), wszSnid );
			
		pdbInfo->i64VersionNum = 0;

	}
	else
		wcscat( pdbInfo->pwszFileName, L".????????????");


	hFind = FindFirstFile(pdbInfo->pwszFileName, &FileData);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		// Get error code.
		DWORD dwError = GetLastError();
		if ( ERROR_SUCCESS == dwError )
		{	//Bug 8261: 0 is returned on Win95 if the file does not exist.
			return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		}
	
		return HRESULT_FROM_WIN32( dwError );
	}

	// Loop through every file we can find.
	do
	{
		ULONG	iNameLen = (ULONG)wcslen ( FileData.cFileName );
		if ( FileData.cFileName[iNameLen-13] != '.' )
			continue;
		swscanf( &FileData.cFileName[iNameLen-12], L"%012I64x",&iVersion);

		if ( iVersion > pdbInfo->i64VersionNum )
		{
			pdbInfo->i64VersionNum = iVersion;
			pdbInfo->cbFileSize = FileData.nFileSizeLow;
			ASSERT(FileData.nFileSizeHigh == 0);
			pdbInfo->i64LastWriteTime = *(unsigned __int64 *) &FileData.ftLastWriteTime;
		}
		
		if ( bDeleteOldVersions )
		{
			try {aOldVersions.append(iVersion);}
			catch(HRESULT e) { return e;/*can only throw E_OUTOFMEMORY*/ }
		}

	}while (FindNextFile(hFind, &FileData));

	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);

	if ( bDeleteOldVersions )
	{
		//Delete the old files
		for ( ULONG i = 0; i < aOldVersions.size(); i ++ )
		{
			if ( aOldVersions[i] == pdbInfo->i64VersionNum )
				continue;

			VERIFY( _snwprintf(pdbInfo->pwszFileName, pdbInfo->cchBuf, L"%s.%012I64x", 
					wszCLBFilePath, aOldVersions[i] ) > 0 );

			DeleteFile( pdbInfo->pwszFileName);
		}
	}

	//Generate the real file name with the full path
	//@todo: sprintf and sscanf use lots of stack space, easy to cause stack overflow, better call some other API.
	VERIFY (_snwprintf(pdbInfo->pwszFileName, pdbInfo->cchBuf, L"%s.%012I64x", wszCLBFilePath, pdbInfo->i64VersionNum) > 0 );

	if ( pdbInfo->i64VersionNum == 0 )
		return HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
	else
		return S_OK;
}


//***************************************************************************
//Internal methods to handle snapshot ids
//***************************************************************************
HRESULT InternalGetLatestSnid( LPCWSTR	wszDatabase,
							   LPCWSTR	wszFileName,
							   ULONG	*psnid
							   )
{
	COMPLIBSCHEMA complibSchema;
	COMPLIBSCHEMABLOB sSchemaBlob;
	HRESULT hr = S_OK;

	ASSERT( wszDatabase && wszFileName && psnid);

	*psnid = 0;

	hr = _CLBGetSchema( wszDatabase, &complibSchema, &sSchemaBlob, NULL );
	if ( FAILED(hr) ) return hr;

	hr = CLBGetReadICR( wszFileName, NULL, &complibSchema, &sSchemaBlob, psnid );

	return hr;
}


HRESULT InternalAddRefSnid(LPCWSTR	wszDatabase,
						   LPCWSTR	wszFileName,
						   ULONG	snid,
						   BOOL		bCreate
						   )
{
	HRESULT hr = S_OK;

	ASSERT( wszDatabase && wszFileName );

	if ( g_snapshotMap.AddRefSnid ( (LPWSTR)wszFileName, snid ) )
		return S_OK;
	else if ( bCreate )
	{
		COMPLIBSCHEMA complibSchema;
		COMPLIBSCHEMABLOB sSchemaBlob;

		hr = _CLBGetSchema( wszDatabase, &complibSchema, &sSchemaBlob, NULL );
		if ( FAILED(hr) ) return hr;

		hr = CLBGetReadICR( wszFileName, NULL, &complibSchema, &sSchemaBlob, &snid );

		return hr;
	}
	else
		return E_ST_INVALIDSNID;

}

HRESULT InternalReleaseSnid( LPCWSTR wszFileName,
							 ULONG	snid )
{
	if ( g_snapshotMap.ReleaseSnid ( (LPWSTR)wszFileName, snid ) )
		return S_OK;
	else
		return E_ST_INVALIDSNID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\mergeinterceptor\transformers\webhierarchytransformer.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    webhierarchytransformer.cpp

$Header: $

Abstract:
	Web Hierarchy Transformer implementation
Author:
    marcelv 	10/19/2000		Initial Release

Revision History:

--**************************************************************************/

#include "webhierarchytransformer.h"
#include "smartpointer.h"
#include <string.h>

static LPCWSTR wszIISProtocol		= L"iis";
static LPCWSTR wszHTTPProtocol		= L"http";
static LPCWSTR wszConfigFileName	= L"\\web.config";
static LPCWSTR wszMachineCfgFile	= L"\\machine.config";
static SIZE_T	cLenMachineCfgFile  = wcslen(wszMachineCfgFile);
static SIZE_T   cLenConfigFileName	= wcslen (wszConfigFileName);
static LPCWSTR wszLocationCurDir    = L".";


//=================================================================================
// Function: CWebHierarchyTransformer::CWebHierarchyTransformer
//
// Synopsis: Default constructor
//=================================================================================
CWebHierarchyTransformer::CWebHierarchyTransformer () 
{
	m_wszServerPath = 0;
	m_wszPathHelper = 0;
	m_pLastInList	= 0;
}

//=================================================================================
// Function: CWebHierarchyTransformer::~CWebHierarchyTransformer
//
// Synopsis: Default destructor
//=================================================================================
CWebHierarchyTransformer::~CWebHierarchyTransformer ()
{
	delete [] m_wszServerPath;
	m_wszServerPath = 0;

	delete [] m_wszPathHelper;
	m_wszPathHelper = 0;

	while (!m_configNodeList.IsEmpty ())
	{
		CConfigNode * pConfigNode = m_configNodeList.PopFront ();
		delete pConfigNode;
		pConfigNode = 0;
	}
}

//=================================================================================
// Function: CWebHierarchyTransformer::Initialize
//
// Synopsis: Initializes the transformer. This function retrieves the names of the 
//           configuration stores that need to be merged. It walks a web hierarchy.
//
// Arguments: [i_wszProtocol] - protocol name
//            [i_wszSelector] - selector string without protocol name
//            [o_pcConfigStores] - number of configuration stores found
//            [o_pcPossibleStores] - number of possible stores (non-existing included)
//=================================================================================
STDMETHODIMP 
CWebHierarchyTransformer::Initialize (ISimpleTableDispenser2 * i_pDispenser, LPCWSTR i_wszProtocol, LPCWSTR i_wszSelector, ULONG * o_pcConfigStores, ULONG * o_pcPossibleStores)
{
	ASSERT (i_pDispenser != 0);
	ASSERT (i_wszProtocol != 0);
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pcConfigStores != 0);

	HRESULT hr = InternalInitialize (i_pDispenser, i_wszProtocol, i_wszSelector, o_pcConfigStores, o_pcPossibleStores);
	if (FAILED (hr))
	{
		TRACE (L"InternalInitialize failed for Web Hierarchy Transformer");
		return hr;
	}

	if (m_wszLocation[0] != L'\0')
	{
		TRACE (L"Location specifier is not supported for webhierarchytransformer");
		return E_ST_INVALIDSELECTOR;
	}

	
	SIZE_T cLenSelector = wcslen(m_wszSelector);

	if (m_wszSelector[cLenSelector-1] == L'/')
	{
		TRACE (L"IIS selector cannot end with slash");
		return E_ST_INVALIDSELECTOR;
	}

	for (ULONG idx=0; idx<cLenSelector; ++idx)
	{
		if (m_wszSelector[idx] == L'\\')
		{
			TRACE (L"IIS selector has backslashes: %s", m_wszSelector);
			return E_ST_INVALIDSELECTOR;
		}
	}

	ASSERT (m_wszPathHelper == 0);

	// initialize output variable

	m_wszPathHelper = new WCHAR [cLenSelector + 1];
	if (m_wszPathHelper == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	hr = WalkVDirs ();
	if (FAILED (hr))
	{
		TRACE (L"Error occurred while walking VDIRS in Web Hierarchy Interceptor");
		return hr;
	}

	hr = CreateConfigStores ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to create config stores");
		return hr;
	}

	SetNrConfigStores (o_pcConfigStores, o_pcPossibleStores);

	return hr;
}

//=================================================================================
// Function: CWebHierarchyTransformer::WalkVDirs
//
// Synopsis: Recursively walk the virtual directory for a particular webserver.
//           The function first finds the correct webserver from the selector string.
//           Then it starts walking the virtual directories that are part of the 
//           selector string, and tries to add these directories to the configuration
//           stores that need to be retrieved
//
// Return Value: 
//=================================================================================
HRESULT 
CWebHierarchyTransformer::WalkVDirs ()
{
	ASSERT (m_spAdminBase == 0);

	// add the machine config dir

	WCHAR wszMachineConfigDir[MAX_PATH];
	HRESULT hr = GetMachineConfigDir (wszMachineConfigDir, sizeof(wszMachineConfigDir) / sizeof (WCHAR));
	if (FAILED (hr))
	{
		TRACE (L"Unable to Get MachineConfigDir");
		return hr;
	}

	// strip the last backslash. This is to ensure that the rest of the framework works fine
	SIZE_T cLenMachineCfgDir = wcslen (wszMachineConfigDir);
	if (cLenMachineCfgDir > 0 && wszMachineConfigDir[cLenMachineCfgDir-1] == L'\\')
	{
		wszMachineConfigDir[cLenMachineCfgDir-1] = L'\0';
		cLenMachineCfgDir--;
	}

	WCHAR wszMachineCfgFullPath[MAX_PATH];

	if (cLenMachineCfgDir + cLenMachineCfgFile >= MAX_PATH)
	{
		TRACE (L"MachineCfgFullPath is larger than MAX_PATH");
		return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
	}
	
	wcscpy (wszMachineCfgFullPath, wszMachineConfigDir);
	wcscpy (wszMachineCfgFullPath + cLenMachineCfgDir, wszMachineCfgFile);

	if (GetFileAttributes (wszMachineCfgFullPath) == -1)
	{
		TRACE (L"Machine config file (%s) does not exist", wszMachineCfgFullPath);
		return HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND);
	}



	hr = AddConfigNode (wszMachineConfigDir, wszMachineCfgFile, wszMachineCfgFile, false);
	if (FAILED (hr))
	{
		TRACE (L"Unable to add machine configdir");
		return hr;
	}

	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
						  IID_IMSAdminBase, (void **) &m_spAdminBase);
	if (FAILED (hr))
	{
		TRACE (L"CoCreateInstance failed for CLSID_MSAdminBase, IID_IMSAdminBase");
		return hr;
	}

	WCHAR wszParentVDir[MAX_PATH] = L"";
	WCHAR wszVDir[MAX_PATH];

	SIZE_T iLen = wcslen (m_wszSelector);
	if (iLen == 0)
	{
		TRACE (L"Selector length is zero in Web Hierarchy Transformer");
		return E_ST_INVALIDSELECTOR;
	}

	if (m_wszSelector[iLen - 1] != L'/')
	{
		iLen++;
	}
	
	TSmartPointerArray<WCHAR> wszResult = new WCHAR [iLen + 1];
	if (wszResult == 0)
	{
		return E_OUTOFMEMORY;
	}

	// copy everything to wszResult. We convert all characters to lowercase, and
	// we convert back slashes to forward slashes
	for (SIZE_T idx=0; idx<iLen; ++idx)
	{
		if (m_wszSelector[idx] == L'\\')
		{
			wszResult[idx] = L'/';
		}
		else
		{
			wszResult[idx] = towlower (m_wszSelector[idx]);
		}
	}

	wszResult[iLen] = L'\0';
	wszResult[iLen - 1] = L'/';

	if (wcsstr(wszResult, L"//") != 0)
	{
		TRACE (L"Error: Selector string contains two forward slashes");
		return E_ST_INVALIDSELECTOR;
	}

	// pwszResult is used to indicate where we are in the selector string. The pointer
	// makes it easy to chop off things without necessarily making copies. So it is a
	// pointer inside a string, but the string is still owned by wszResult. pwszResult
	// will be used to walk over the selector string (i.e. URL).
	WCHAR *pwszResult = wszResult;

	hr = GetWebServer (&pwszResult);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get web server in Web Hierarchy Transformer");
		return hr;
	}

	// Get the virtual directory for the web server. When this fails, we bail out, because
	// without web server we cannot traverse the web hierarchy succesfully

	hr = GetVirtualDir (L"", wszParentVDir, sizeof(wszParentVDir));
	if (FAILED (hr) || wszParentVDir[0] == L'\0')
	{
		TRACE (L"Unable to get VDIR of WebServer");
		return E_ST_INVALIDSELECTOR;
	}

	// need servercomment here

	WCHAR wszServerComment[256];
	hr = GetServerComment (wszServerComment, sizeof (wszServerComment));
	if (FAILED (hr))
	{
		TRACE (L"Unable to get server comment");
		return hr;
	}

	hr = AddConfigNode (wszParentVDir, wszConfigFileName, wszServerComment, true);
	if (FAILED (hr))
	{
		TRACE (L"AddConfigNode failed");
		return hr;
	}

	// we have a string of the format foo/bar/zee/. Note that the last slash is always
	// available because it is added above if not there. This makes parsing much easier.
	// We simply search for the next slash, replace it with a null terminator, and ask the
	// vdir for the particular directory. After this is done, the null terminator is replaced
	// by a slash again. For instance, in the above example, we would as vdirs for
	// foo, foo/bar, and foo/bar/zee.
	// We keep track of the parent virtual directory in case no vdir is found. In this case
	// we simple add the new part (pLastStart) to the parent virtual directory. In case
	// we find a new virtual directory, we use that for the next time in the loop.

	WCHAR *pSlash = (WCHAR *) pwszResult;
	WCHAR *pLastStart = pSlash;
	while ((pSlash = wcschr (pSlash , L'/')) != 0)
	{
		*pSlash = L'\0';
		hr =  GetVirtualDir (pwszResult, wszVDir, sizeof(wszVDir));
		if (FAILED (hr))
		{
			TRACE (L"Unable to get virtual directory for %s", pwszResult);
			return hr;
		}

		if (wszVDir[0] != '\0')
		{
			// found a new vdir, lets use that as the next parent dir
			wcscpy (wszParentVDir, wszVDir);
		}
		else
		{
			if (wcslen(wszParentVDir) + wcslen (pLastStart) >= MAX_PATH - 1)
			{
				TRACE (L"Not enough memory for ParentVDIR");
				return E_INVALIDARG;
			}
			// didn't find a new vdir. At the last directory item (i.e. foo/bar/zee, last
			// directory item is zee) to the parent directory
			wcscat (wszParentVDir, L"\\");
			wcscat (wszParentVDir, pLastStart);
		}

		// found a new dir. Add it to the list of configuration stores
		hr = AddConfigNode (wszParentVDir, wszConfigFileName, pLastStart, true);
		if (FAILED (hr))
		{
			TRACE (L"AddConfigNode failed");
			return hr;
		}


		*pSlash = L'/';
		pSlash++; // skip over the /
		pLastStart = pSlash;
	}

	return hr;
}

//=================================================================================
// Function: CWebHierarchyTransformer::GetVirtualDir
//
// Synopsis: Get a virtual directory from IIS. the function simply queries the IIS
//           Metabase. When the function succeeds wszVDIR contains the virtual directory.
//           When the metabase returns either VDIR_PATH_NOT_FOUND or MD_ERROR_PATH_NOT_FOUND
//           then we do not have a virtual directory for that particular url. We return 
//           S_OK in that case, because this is still ok
//
// Arguments: [wszRelPath] - relative URL path without server path
//            [wszVDir] - result will be stored in here
//            [dwSize] - size of wszVDIR
//            
// Return Value: S_OK if valid VDIR/unknown VDIR found, non-S_OK in case of error
//=================================================================================
HRESULT
CWebHierarchyTransformer::GetVirtualDir (LPCWSTR i_wszRelPath, LPWSTR io_wszVDir, DWORD i_dwSize)
{
	ASSERT (i_wszRelPath != 0);
	ASSERT (io_wszVDir != 0);

	io_wszVDir[0] = L'\0';

	DWORD dwRealSize;

	wcscpy (m_wszPathHelper, m_wszServerPath);
	wcscat (m_wszPathHelper, i_wszRelPath);

	METADATA_RECORD resRec;

	resRec.dwMDIdentifier	= MD_VR_PATH;
	resRec.dwMDDataLen		= i_dwSize;
	resRec.pbMDData			= (BYTE *)io_wszVDir;
	resRec.dwMDAttributes	= METADATA_NO_ATTRIBUTES; // not METADATA_INHERIT, because then we get wrong information
	resRec.dwMDDataType		= STRING_METADATA;

	HRESULT hr = m_spAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, m_wszPathHelper, &resRec, &dwRealSize);
	if (hr == HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) || hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND))
	{
		hr = S_OK;
	}

	return hr;
}

//=================================================================================
// Function: CWebHierarchyTransformer::CreateConfigStores
//
// Synopsis: We have a list of CConfigNodes. For each config node, we have to create possible
//           configuration stores in the following order:
//			 Suppose:
//			 ROOT			-> c:/inetpub/wwwroot/web.config	(parent of ROOT/foo)
//           ROOT/foo		-> c:/foo/web.config				(parent of ROOT/foo/bar)
//           ROOT/foo/bar	-> c:/foo/bar/web.config
//
//           The algorithm starts at the first file, create a config store for the file. Next it goes to the
//           next file. From their, it backtracks through all the parents, and creates configuration stores for 
//           the parents with location tags. Next it prints the configuration store for the file, and continues with the
//           next file.
//           For the above example, this results in:
//			 1) c:\inetpub\wwwroot\web.config
//           2) c:\inetpub\wwwroot\web.config#foo
//           3) c:\foo\web.config
//           4) c:\inetpub\wwwroot\web.config#foo/bar
//           5) c:\foo\web.config#bar
//           6) c:\foo\bar\web.config
//			 
//=================================================================================
HRESULT
CWebHierarchyTransformer::CreateConfigStores ()
{
	// walk through the list and add them

	HRESULT hr = S_OK;

	ULONG idx=0;
	m_configNodeList.Reset ();
	for (CConfigNode *pConfigNode = m_configNodeList.Next (); 
	     pConfigNode != 0; 
		 pConfigNode = m_configNodeList.Next ())
		 {
			 if (pConfigNode->Parent () != 0)
			 {
				 // we have parents, so we have to backtrack through all parents and add the location config stores
				 // We use subdirList to push the logical directory names, which is used in CreateParentConfigStore to
				 // recreate the location part of the config store
				 TList<LPCWSTR> subdirList;
				 hr = subdirList.PushFront (pConfigNode->LogicalDir ());
				 if (FAILED (hr))
				 {
					 TRACE (L"PushFront failed for subdirList");
					 return hr;
				 }

				 hr = CreateParentConfigStore (pConfigNode->Parent (), subdirList); 
				 if (FAILED (hr))
				 {
					 TRACE (L"CreateParentConfigStore failed");
					 return hr;
				 }

				 subdirList.PopFront ();
				 ASSERT (subdirList.IsEmpty ());
			  }

			 // add at the file itself (without location tag)
			 idx++;
			
			 hr = AddSingleConfigStore (pConfigNode->Path (), 
				                        pConfigNode->FileName (), 
										L"", 
										L"",
										true,
										pConfigNode->AllowOverrideForLocation (wszLocationCurDir));
			 if (FAILED (hr))
			 {
				 TRACE (L"AddSingleConfigStore failed");
				 return hr;
			 }
		 }

	return hr;
}

//=================================================================================
// Function: CWebHierarchyTransformer::CreateParentConfigStore
//
// Synopsis: Add a location config store. First check if we have parents, because if so, 
//           we have to add location config stores for them first (by calling this function 
//           recursively
//
// Arguments: [pLocation] - ConfigNode for which to create Location configuration store
//            [subDirList] - List with Logical names that is used to recreate the location name
//=================================================================================
HRESULT
CWebHierarchyTransformer::CreateParentConfigStore (CConfigNode *pLocation, 
												TList<LPCWSTR>& subDirList)
{
	ASSERT (pLocation != 0);

	HRESULT hr = S_OK;
	if (pLocation->Parent () != 0)
	{
		// add parent first, by adding the logical subdir to the list and calling ourselves recursively
		CConfigNode *pParent = pLocation->Parent ();
		hr = subDirList.PushFront (pLocation->LogicalDir ());
		if (FAILED (hr))
		{
			TRACE (L"Unable to call TList::PushFront");
			return hr;
		}

		hr = CreateParentConfigStore (pParent, subDirList);
		if (FAILED (hr))
		{
			TRACE (L"Failed to call CreateParentConfigStore recursively");
			return hr;
		}

		ASSERT (!subDirList.IsEmpty());
		subDirList.PopFront ();
	}

	subDirList.Reset ();

	// Recreate the location name by walking through the subdirlist
	SIZE_T cTotalLen = 0;
	for (LPCWSTR subDir = subDirList.Next(); subDir != 0; subDir = subDirList.Next())
	{
		 cTotalLen += wcslen (subDir) + 1; // +1 for additional backslash
	 }

	TSmartPointerArray<WCHAR> saLocation = new WCHAR[cTotalLen + 1];
	if (saLocation == 0)
	{
		return E_OUTOFMEMORY;
	}
	saLocation[0] = L'\0';

	subDirList.Reset();
	for (subDir = subDirList.Next(); subDir != 0; subDir = subDirList.Next())
	{
		 //This is slow, needs improvement
		 wcscat (saLocation, subDir);
		 wcscat (saLocation, L"/");
	}

	saLocation[cTotalLen - 1] = L'\0';

	// need to get Location Info (allowOverride stuff)
	hr = AddSingleConfigStore (pLocation->Path (),
							   pLocation->FileName(),
							   L"",
							   saLocation,
							   true,
							   pLocation->AllowOverrideForLocation (saLocation));

	if (FAILED (hr))
	{
		TRACE (L"AddSingleConfigStore failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CWebHierarchyTransformer::GetWebServer
//
// Synopsis: The web hierarchy tranformer supports two protocols:
//			 - iis
//           - http
//           This function figures out which function to call to determine the web
//           server we are talking to
//
// Arguments: [io_pwszResult] - input: pointer to full selector string, output: pointer
//                              to non-server path of the selector string.
//=================================================================================
HRESULT
CWebHierarchyTransformer::GetWebServer (LPWSTR * io_pwszResult)
{
	HRESULT hr = S_OK;
	if (_wcsnicmp(m_wszProtocol, wszIISProtocol, wcslen (wszIISProtocol)) == 0)
	{
		hr = GetIISWebServer (io_pwszResult);
	}
	else
	{
		TRACE (L"Unknown protocol specified: %s", *io_pwszResult);
		hr = E_ST_UNKNOWNPROTOCOL;
	}

	return hr;
}

HRESULT
CWebHierarchyTransformer::GetServerComment (LPWSTR io_wszServerComment, DWORD i_dwLenServerComment)
{
	ASSERT (m_wszServerPath != 0);
	ASSERT (io_wszServerComment != 0);

	METADATA_RECORD serverCommentRec;
	DWORD dwRealSize;
	
	serverCommentRec.dwMDIdentifier	= MD_SERVER_COMMENT;
	serverCommentRec.dwMDDataLen	= i_dwLenServerComment;
	serverCommentRec.pbMDData		= (BYTE *)io_wszServerComment;
	serverCommentRec.dwMDAttributes	= METADATA_INHERIT;
	serverCommentRec.dwMDDataType	= STRING_METADATA;

	HRESULT hr = m_spAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, 
										 m_wszServerPath, 
										 &serverCommentRec, 
										 &dwRealSize);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get servercomment for %s", m_wszServerPath);
		return hr;
	}

	return hr;
}


//=================================================================================
// Function: CWebHierarchyTransformer::GetIISWebServer
//
// Synopsis: Converts an IIS adsi string to the correct webserver. The format of the
//           ADSI string is something like:
//				iis://localhost/W3SVC/1/ROOT/VDIR/dir
//           The function checks if localhost and ROOT/ is present, and if so, it will
//           replace localhost by LM and query IIS to find the correct webserver virtual
//           directory
//
// Arguments: [io_pwszResult] - contains a pointer to the full string on input, and a pointer
//                              to the beginning of the non-server part after the string.
//                              This means we have to pass a pointer to a string (pointer to pointer)
//                              to chane this
//=================================================================================
HRESULT
CWebHierarchyTransformer::GetIISWebServer (LPWSTR *io_pwszResult)
{
	HRESULT hr = S_OK;

	// Check for localhost, ROOT
	// everything is lower case
	static LPCWSTR wszRoot = L"root/";
	static SIZE_T iRootLen = wcslen (wszRoot);
	static LPCWSTR wszLocalHost = L"localhost";
	static SIZE_T iLocalHostLen = wcslen (wszLocalHost);
	static LPCWSTR wszLM = L"lm";
	static SIZE_T iLMLen = wcslen (wszLM);

	// we should start with localhost:

	if (wcsncmp (*io_pwszResult, wszLocalHost, iLocalHostLen) != 0)
	{
		TRACE (L"Localhost not specified at beginning of IIS path");
		// need to change error variable here
		return E_ST_INVALIDSELECTOR;
	}

	//chop off the localhost part
	*io_pwszResult += iLocalHostLen;

	WCHAR * pRootStart = wcsstr(*io_pwszResult, wszRoot);
	if (pRootStart == 0)
	{
		TRACE (L"ROOT not specified in IIS path");
		return E_ST_INVALIDSELECTOR;
	}

	SIZE_T iNrCharsToCopy = (pRootStart - *io_pwszResult) + iRootLen + iLMLen;
	m_wszServerPath = new WCHAR [iNrCharsToCopy + 1];
	if (m_wszServerPath == 0)
	{
		return E_OUTOFMEMORY;
	}

	wcscpy (m_wszServerPath, wszLM);
	wcsncat (m_wszServerPath, *io_pwszResult, iNrCharsToCopy - iLMLen);
	m_wszServerPath[iNrCharsToCopy] = L'\0';

	// chop off server part
	*io_pwszResult = pRootStart + iRootLen;

	return hr;
}

HRESULT
CWebHierarchyTransformer::AddConfigNode (LPCWSTR i_wszPath, 
										  LPCWSTR i_wszFileName, 
										  LPCWSTR i_wszLogicalDir,
										  bool fAddLinkToParent)
{
	ASSERT (i_wszPath != 0);
	ASSERT (i_wszFileName != 0);

	CConfigNode *pConfigNode = new CConfigNode;
	if (pConfigNode == 0)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = m_configNodeList.PushBack (pConfigNode);
	if (FAILED (hr))
	{
		delete pConfigNode;
		TRACE (L"PushBack failed");
		return hr;
	}

	hr = pConfigNode->Init (i_wszPath, i_wszFileName, i_wszLogicalDir);
	if (FAILED (hr))
	{
		TRACE (L"CLocation::Init failed");
		return hr;
	}

	if (fAddLinkToParent && m_pLastInList != 0)
	{
		hr = m_pLastInList->GetLocations (m_spDispenser);
		if (FAILED (hr))
		{
			TRACE (L"GetLocations failed");
			return hr;
		}
		
		pConfigNode->SetParent (m_pLastInList);
	}

	m_pLastInList = pConfigNode;

	return hr;
}

//=================================================================================
// Function: CLocation::CLocation
//
// Synopsis: Constructor
//=================================================================================
CLocation::CLocation ()
{
	m_wszPath			= 0;
	m_fAllowOverride	= true; // default for allowoverride is true
}

//=================================================================================
// Function: CLocation::~CLocation
//
// Synopsis: Destructor
//=================================================================================
CLocation::~CLocation ()
{
	delete [] m_wszPath;
	m_wszPath = 0;
}

//=================================================================================
// Function: CLocation::Path
//
// Synopsis: returns the path
//=================================================================================
LPCWSTR
CLocation::Path () const
{
	return m_wszPath;
}

//=================================================================================
// Function: CLocation::AllowOverride
//
// Synopsis: returns allowoverride
//=================================================================================
BOOL
CLocation::AllowOverride () const
{
	return m_fAllowOverride;
}

//=================================================================================
// Function: CLocation::Set
//
// Synopsis: Sets the allowoverride and path properties
//
// Arguments: [i_wszPath] - path 
//            [i_fAllowOverride] - allowoverride
//=================================================================================
HRESULT
CLocation::Set (LPCWSTR i_wszPath, BOOL i_fAllowOverride)
{
	ASSERT (i_wszPath != 0);

	SIZE_T cLenPath = wcslen (i_wszPath);
	m_wszPath = new WCHAR [cLenPath + 1];
	if (m_wszPath == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszPath, i_wszPath);

	m_fAllowOverride = i_fAllowOverride;

	return S_OK;
}

//=================================================================================
// Function: CConfigNode::CConfigNode
//
// Synopsis: Constructor
//=================================================================================
CConfigNode::CConfigNode ()
{
	m_fInitialized			= false;
	m_wszFullPath			= 0;
	m_wszLogicalDir			= 0;
	m_wszFileName			= 0;
	m_pParent				= 0;
}

//=================================================================================
// Function: CConfigNode::~CConfigNode
//
// Synopsis: Destructor
//=================================================================================
CConfigNode::~CConfigNode ()
{
	delete [] m_wszFileName;
	m_wszFileName = 0;

	delete [] m_wszFullPath;
	m_wszFullPath = 0;

	delete [] m_wszLogicalDir;
	m_wszLogicalDir = 0;

	while (!m_locations.IsEmpty ())
	{
		CLocation * pLocation = m_locations.PopFront ();
		delete pLocation;
		pLocation = 0;
	}
}

//=================================================================================
// Function: CConfigNode::Path
//
// Synopsis: Returns the full physical path of the config node
//=================================================================================
LPCWSTR
CConfigNode::Path () const
{
	return m_wszFullPath;
}

//=================================================================================
// Function: CConfigNode::FileName
//
// Synopsis: Returns the filename of the config node
//=================================================================================
LPCWSTR
CConfigNode::FileName () const
{
	return m_wszFileName;
}

//=================================================================================
// Function: CConfigNode::LogicalDir
//
// Synopsis: Returns the logical directory of the config node
//=================================================================================
LPCWSTR
CConfigNode::LogicalDir () const
{
	return m_wszLogicalDir;
}

//=================================================================================
// Function: CConfigNode::Parent
//
// Synopsis: Returns the parent config node. A parent is a confignode that is created
//           directly before the config node (i.e. has the virtual directory above the current
//           virtual directory)
//=================================================================================
CConfigNode *
CConfigNode::Parent ()
{
	return m_pParent;
}

//=================================================================================
// Function: CConfigNode::SetParent
//
// Synopsis: Sets the parent config node
//=================================================================================
void
CConfigNode::SetParent (CConfigNode *pParent)
{
	ASSERT (pParent != 0);
	m_pParent = pParent;
}

//=================================================================================
// Function: CConfigNode::GetLocations
//
// Synopsis: Queries the catalog for all locations in the current file. Each location is
//           stored, so that the information can be used to figure out if AllowOverride is
//           available or not
//
// Arguments: [i_pDispenser] - dispenser
//=================================================================================
HRESULT
CConfigNode::GetLocations (ISimpleTableDispenser2 *i_pDispenser)
{
	ASSERT (i_pDispenser != 0);
	ASSERT (m_fInitialized);

	static LPCWSTR wszLocationDatabase = WSZ_PRODUCT_NETFRAMEWORKV1;
	static LPCWSTR wszLocationTable	= wszTABLE_location; 

	TSmartPointerArray<WCHAR> saFileName = new WCHAR [wcslen (m_wszFullPath) + wcslen(m_wszFileName) + 1];
	if (saFileName == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (saFileName, m_wszFullPath);
	wcscat (saFileName, m_wszFileName);

	ULONG cTotalCells = 1;
	STQueryCell aQueryData[1];

	aQueryData[0].pData			= (void *) saFileName;
	aQueryData[0].eOperator		= eST_OP_EQUAL;
	aQueryData[0].iCell			= iST_CELL_FILE;
	aQueryData[0].dbType		= DBTYPE_WSTR;
	aQueryData[0].cbSize		= 0;

	// Retrieve all locations
	CComPtr<ISimpleTableRead2> spISTRead;
	HRESULT hr = i_pDispenser->GetTable (wszLocationDatabase, wszLocationTable, 
										(void *) aQueryData, (void *) &cTotalCells,
										eST_QUERYFORMAT_CELLS, 	fST_LOS_READWRITE, 
										(void **) &spISTRead);

	if (FAILED (hr))
	{
		TRACE (L"Unable to retrieve location info (db:%s, table:%s)", wszLocationDatabase, wszLocationTable);
		return hr;
	}

	// For each location, create a new Location object, and store it in the linked list
	tlocationRow locationInfo;
	for (ULONG idx=0; ;++idx)
	{
		hr = spISTRead->GetColumnValues (idx, clocation_NumberOfColumns, 0, 0, (void **)&locationInfo);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}

		if (FAILED (hr))
		{
			TRACE (L"GetColumnValues failed in CConfigNode");
			return hr;
		}

		CLocation *pLocation = new CLocation;
		if (pLocation == 0)
		{
			return E_OUTOFMEMORY;
		}

		hr = m_locations.PushBack (pLocation); 
		if (FAILED (hr))
		{
			delete pLocation;
			pLocation = 0;
			TRACE (L"PushBack failed for locations list");
			return hr;
		}

		BOOL fAllowOverride = true;
		if (locationInfo.pallowOverride != 0)
		{
			fAllowOverride = *locationInfo.pallowOverride;
		}

		hr = pLocation->Set (locationInfo.ppath, fAllowOverride);
		if (FAILED (hr))
		{
			TRACE (L"Set failed for location");
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CConfigNode::Init
//
// Synopsis: Initializes the config node
//
// Arguments: [i_wszFullPath] - full path of this node
//            [i_wszFileName] - file name
//            [i_wszLogicalDir] - logical directory of this node
//=================================================================================
HRESULT
CConfigNode::Init (LPCWSTR i_wszFullPath, LPCWSTR i_wszFileName, LPCWSTR i_wszLogicalDir)
{
	ASSERT (i_wszFullPath != 0);
	ASSERT (i_wszFileName != 0);
	ASSERT (i_wszLogicalDir != 0);

	m_wszFullPath = new WCHAR [wcslen(i_wszFullPath) + 1];
	if (m_wszFullPath == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszFullPath, i_wszFullPath);

	m_wszFileName = new WCHAR[wcslen(i_wszFileName) + 1];
	if (m_wszFileName == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszFileName, i_wszFileName);

	m_wszLogicalDir = new WCHAR[wcslen(i_wszLogicalDir) + 1];
	if (m_wszLogicalDir == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszLogicalDir, i_wszLogicalDir);

	m_fInitialized = true;

	return S_OK;
}

//=================================================================================
// Function: CConfigNode::AllowOverrideForLocation
//
// Synopsis: Walks through all locations and finds the one specified in i_wszLocation. If
//           found, it will return the AllowOverride property of this object. If not found, the
//           fucntion returns true (which is default for AllowOverride)
//
// Arguments: [i_wszLocation] - Location element to look for
//=================================================================================
BOOL
CConfigNode::AllowOverrideForLocation (LPCWSTR i_wszLocation)
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszLocation != 0);
	
	BOOL fAllowOverride = true; // true is default
	m_locations.Reset ();
	for (CLocation *pLocation = m_locations.Next (); pLocation != 0; pLocation = m_locations.Next ())
	 {
		 if (wcscmp (i_wszLocation, pLocation->Path ()) == 0)
		 {
			 fAllowOverride = pLocation->AllowOverride();
			 break;
		 }
	 }

	return fAllowOverride;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\clbread.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
//clbread.h
//
//This header file contains the structures and functions used to read the 
//latest version of a complib file
//*****************************************************************************
#pragma once

#include "icrmap.h"
#include "SNMap.h"
#include "catalog.h"
#ifndef __FIXEDTABLEHEAP_H__
    #include "FixedTableHeap.h"
#endif

#define MIN_MAP_SIZE (64 * 1024) // 64 kb is the minimum size of virtual
								// memory you can allocate, so anything
								// less is a waste of Virtual Memory resources.

struct CLB_VERINFO
{
	__int64		i64VersionNum;			//Logical file version.
	LPWSTR		pwszFileName;			//Return name of the clb file with the version number attached. 
										//Caller should be reponsible for allocating enough size.
	ULONG		cchBuf;					//Size of pwszFileName 
	ULONG		cbFileSize;				//Size of the file.
	unsigned __int64 i64LastWriteTime;	//Last write time of the file. Since clb files can be deleted 
	//and recreated in the case of a clean cookdown. I may end up caching an old ICR instance even though 
	//its logical version is the same or newer than the latest file on the disk. I need this extra piece of 
	//information to invalidate the mapReadICR cache.
};

struct CLBREAD_STATE
{
	WCHAR		wszWINDIR [_MAX_PATH];	//Windows directory
    const FixedTableHeap * pFixedTableHeap;
	CMapICR		mapReadICR;				//a Map from file name to ICR
	ISimpleTableRead2*	pISTReadDatabaseMeta;
	ISimpleTableRead2*	pISTReadColumnMeta;
	BOOL		bInitialized;
	UTSemReadWrite lockInit;
	PACL  pAcl;
	SECURITY_DESCRIPTOR sdRead;		// Security for memory mapped stuff.
	SECURITY_ATTRIBUTES  *psa;
	SECURITY_ATTRIBUTES  sa;
};


HRESULT CLBReadInit();

HRESULT CLBGetReadICR(const WCHAR* wszFileName,				//clb file name
					  IComponentRecords** ppICR,			//return ICR pointer
					  COMPLIBSCHEMA* pComplibSchema,		//Complib schema structure
					  COMPLIBSCHEMABLOB* pSchemaBlob,		//Complib schema blob
					  ULONG *psnid=NULL		 				//snap shot id, which is the lower 4 bytes of the version number
					 );

HRESULT _CLBGetSchema(LPCWSTR wszDatabase,					//database
					  COMPLIBSCHEMA* pComplibSchema,	//return the schema structure
					  COMPLIBSCHEMABLOB* pSchemaBlob,   //return the schema blob structure
					  LPWSTR* pwszDefaultName);			//return the default clb file name

HRESULT	_CLBGetLatestVersion(					
	LPCWSTR		wszCLBFilePath,			// Path of the complib file
	BOOL		bLongPath,				// Path + version exceeds MAX_PATH
	CLB_VERINFO *pdbInfo,				// Return current version.
	BOOL		bDeleteOldVersions = FALSE );	

CLBREAD_STATE* _GetCLBReadState();


//Find the latest snapshot, add to the map, and AddRef snid
HRESULT InternalGetLatestSnid( LPCWSTR	wszDatabase,
							   LPCWSTR	wszFileName,
							   ULONG	*psnid
							   );

//Add Ref for the specified snid. Create ICR for the snapshot if it's not in the map yet. 
HRESULT InternalAddRefSnid(LPCWSTR	wszDatabase,
						   LPCWSTR	wszFileName,
						   ULONG	snid,
						   BOOL		bCreate
						   );

//Release Ref for the specified snid. Clean up the entry in the map if snid becomes 0.
HRESULT InternalReleaseSnid( LPCWSTR wszFileName,
							 ULONG	snid );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\regdbapi.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// RegControl.h
//
// This header file contains the structures used to share memory between
// the RegDB process and the clients which read the data.
//
//*****************************************************************************
#pragma once

#include "complib.h"					// Complib defines.
#include "icmprecsts.h"					// ICR defines.

#include "utsem.h"						// Lock code.


// Forward.
struct REGISTRATION_PROCESS;


typedef unsigned __int64 FILEVERSION;

struct REGAPI_DBINFO
{
	FILEVERSION FileVersion;			// Version of the database we have open.
	__int64		VersionNum;				// Logical file version.
	DWORD		dwLastChecked;			// Timestamp of last version lookup.
	TCHAR		rcMapName[32];			// Name of shared data segment.
	ULONG		cbFileSize;				// Size of the file.
	TCHAR		rcDBName[_MAX_PATH];	// Name of latest db.
};

struct REGAPI_STATE : REGAPI_DBINFO
{
	// Handle locking of this data in the client.  Don't rely on global
	// ctor to init, must be done manually.
	CRITICAL_SECTION	g_csRegAPI;

	// These values are used to track the globally shared reg table.
	HANDLE		hProcessMem;			// Handle to mapping object.
	REGISTRATION_PROCESS *pRegProcess;	// The global table of opened db's.

	// Location of the registration data.
	TCHAR		rcRegDir[_MAX_PATH];	// Where does registration data live.

	// The following is the current instance of the complib we are using.
	IComponentRecords *pICR;			// Global instance of database.

	SECURITY_DESCRIPTOR sdRead;		// Security for memory mapped stuff.
	SECURITY_ATTRIBUTES  *psa;
	SECURITY_ATTRIBUTES  sa;

};


inline int GetDBName(LPTSTR szName, int iMax, LPCTSTR szDir, __int64 iVersion)
{
	return (_sntprintf(szName, iMax, _T("%s\\R%012I64x.clb"), 
			szDir, iVersion));
}

inline int GetSharedName(LPTSTR szName, int iMax, __int64 VersionNum, FILEVERSION FileVersion)
{
	return (_sntprintf(szName, iMax, _T("__R_%012I64x_SMem__"), VersionNum));
}


REGAPI_STATE *_RegGetProcessAPIState();
HRESULT _RegGetLatestVersion(LPCTSTR szRegDir, REGAPI_DBINFO *pdbInfo, BOOL bForceCheckDisk = FALSE, BOOL bFromSysApp = FALSE);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\icmprecsts.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// ICmpRecsTS.cpp
//
// Thread safe wrappers for ICR pointer interface.
//
//*****************************************************************************
#include "stdafx.h"
#include <icmprecsts.h>



HRESULT STDMETHODCALLTYPE CreateComponentLibraryTS(
	LPCWSTR szName,
	long fFlags,
	ITSComponentRecords **ppIComponentRecords)
{
	IComponentRecords *pICR = NULL;
	HRESULT		hr;
	hr = CreateComponentLibraryEx(szName, fFlags, &pICR, NULL);
	if (SUCCEEDED(hr))
	{
		hr = pICR->QueryInterface(IID_ITSComponentRecords, (PVOID *) ppIComponentRecords);
	}
	if (pICR)
		pICR->Release();
	return (hr);
}

HRESULT STDMETHODCALLTYPE OpenComponentLibraryTS(
	LPCWSTR szName,
	long fFlags,
	ITSComponentRecords **ppIComponentRecords)
{
	IComponentRecords *pICR = NULL;
	HRESULT		hr;
	hr = OpenComponentLibraryEx(szName, fFlags, &pICR, NULL);
	if (SUCCEEDED(hr))
	{
		hr = pICR->QueryInterface(IID_ITSComponentRecords, (PVOID *) ppIComponentRecords);
	}
	if (pICR)
		pICR->Release();
	return (hr);
}

HRESULT STDMETHODCALLTYPE OpenComponentLibrarySharedTS(
	LPCWSTR		szName,
	LPCWSTR		szSharedMemory,
	ULONG		cbSize,
	LPSECURITY_ATTRIBUTES pAttributes,
	long		fFlags,
	ITSComponentRecords **ppIComponentRecords)
{
	IComponentRecords *pICR = NULL;
	HRESULT		hr;
	hr = OpenComponentLibrarySharedEx(szName, szSharedMemory, cbSize, pAttributes,
			fFlags, &pICR);
	if (SUCCEEDED(hr))
	{
		hr = pICR->QueryInterface(IID_ITSComponentRecords, (PVOID *) ppIComponentRecords);
	}
	if (pICR)
		pICR->Release();
	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\icrmap.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
//icrmap.cpp
//Implementation of CMapICR class.
//*****************************************************************************
#include "stdafx.h"
#include "icrmap.h"

CMapICR::~CMapICR()
{
//	ResetMap();
}

//**************************************************************************************
//Find a match for wszFileName, return true if found
//**************************************************************************************
BOOL CMapICR::Find( LPWSTR wszFileName, IComponentRecords** ppICR, __int64 *pi64Version, unsigned __int64 * pi64LastWriteTime )
{
	ICRREF* pICRRef = NULL;

	UTSemRWMgrRead rdLock( &m_lockRW );

	if ( m_mapFileToICR.map( wszFileName, &pICRRef ) )
	{
		if ( ppICR )
			*ppICR = pICRRef->pICR;
		if ( pi64Version )
			*pi64Version = pICRRef->i64Version;
		if ( pi64LastWriteTime )
			*pi64LastWriteTime = pICRRef->i64LastWriteTime;
		return TRUE;
	}
	else
		return FALSE;
}

//**************************************************************************************
//Add a entry in the map, three cases:
//1. the map cached a different version, which is older in most cases
//2. the map cached the same version.
//3. not found in the map.
//**************************************************************************************
HRESULT CMapICR::Add( LPWSTR wszFileName, IComponentRecords** ppICR, __int64 i64Version ,unsigned __int64  i64LastWriteTime )
{
	HRESULT hr = S_OK;
	ICRREF* pICRRef = NULL;

	UTSemRWMgrWrite wtLock( &m_lockRW );
	//Found in the map
	if ( m_mapFileToICR.map( wszFileName, &pICRRef ) )
	{	
		if ( pICRRef->i64Version != i64Version || pICRRef->i64LastWriteTime != i64LastWriteTime )
		{	//The map cached a different version, update the entry in the map. 
			(pICRRef->pICR)->Release();
			pICRRef->pICR = *ppICR;
			(*ppICR)->AddRef();
			pICRRef->i64Version = i64Version;
			pICRRef->i64LastWriteTime = i64LastWriteTime;
		}
		else
		{	// the map has the same version, release *ppICR, hand out what's kept in the map
			(*ppICR)->Release();
			*ppICR = pICRRef->pICR;
			( pICRRef->pICR )->AddRef();
		}
		
		return S_OK;
	}

	//Not found, need to create a new entry
	DWORD cch = ::lstrlen( wszFileName ) + 1;
	LPWSTR pwsz = new WCHAR[cch];
	if ( pwsz == NULL )
		return E_OUTOFMEMORY;

	memcpy( pwsz, wszFileName, cch*sizeof(WCHAR) );

	pICRRef = new ICRREF;
	if ( pICRRef == NULL )
	{
		delete [] pwsz;
		return E_OUTOFMEMORY;
	}

	pICRRef->pICR = *ppICR;
	(*ppICR)->AddRef();
	pICRRef->i64Version = i64Version;
	pICRRef->i64LastWriteTime = i64LastWriteTime;

	try{
		m_mapFileToICR.add( pwsz, pICRRef );
	}
	catch(HRESULT e)
	{
		//Map should only throw E_OUTOFMEMORY;
		ASSERT(E_OUTOFMEMORY == e);
		(*ppICR)->Release();
		delete [] pwsz;
		delete pICRRef;
		hr = e;
	}

	return hr;
}

//**************************************************************************************
//Remove an entry in the map. Release the memory and ICR refrecence.
//**************************************************************************************	
void CMapICR::Delete ( LPWSTR wszFileName )
{
	ICRREF* pICRRef = NULL;
	LPWSTR  pwsz = NULL;

	UTSemRWMgrWrite wtLock( &m_lockRW );
	
	if ( !m_mapFileToICR.map( wszFileName, &pICRRef ) )
		return;

	m_mapFileToICR.contains ( wszFileName, &pwsz );
	
	m_mapFileToICR.remove( pwsz );

	delete [] pwsz;

	(pICRRef->pICR)->Release();
	delete pICRRef;


}

//**************************************************************************************
//Clean up all the entries in the map. 
//**************************************************************************************
void CMapICR::ResetMap()
{
	EnumMap<WCHAR*,ICRREF*,HashWSTR> itor (m_mapFileToICR);
	LPWSTR pwsz;
	ICRREF* pICRRef;


	UTSemRWMgrWrite wtLock( &m_lockRW );

	while (itor.next())
	{
		itor.get(&pwsz, &pICRRef);
		delete [] pwsz;
		(pICRRef->pICR)->Release();
		delete pICRRef;
	}
		
	m_mapFileToICR.reset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\clbwrite.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// clbwrite.h
//*****************************************************************************
#pragma once

HRESULT CLBGetWriteICR(const WCHAR* wszFileName,			//clb file name
					   IComponentRecords** ppICR,			//return ICR pointer
					   COMPLIBSCHEMA* pComplibSchema,		//Complib schema structure
					   COMPLIBSCHEMABLOB* pSchemaBlob);		//Complib schema blob


HRESULT CLBCommitWrite( LPCWSTR wszDatabase, const WCHAR* wszInFileName );

HRESULT CLBAbortWrite( LPCWSTR wszDatabase, const WCHAR* wszInFileName );

HRESULT GetWriteLock( LPCWSTR wszDatabase, const WCHAR* wszInFileName, HANDLE* phLock );

HRESULT ReleaseWriteLock( HANDLE hLock );

HRESULT GetNewOIDFromWriteICR( const WCHAR* wszFileName, ULONG* pulOID );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\regdbhelper.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// RegDBHelper.cpp
//
// Helper code for working with shared table entries.
//
//*****************************************************************************
#include "stdafx.h"						// OLE controls.

//********** Code. ************************************************************

//*****************************************************************************
// Returns true if running on an NT machine.  Returns false on Win 9x and CE.
//*****************************************************************************
BOOL RunningOnWinNT()
{
	OSVERSIONINFOA	sVer;
	sVer.dwOSVersionInfoSize = sizeof(sVer);
	VERIFY(GetVersionExA(&sVer));
	return (sVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
}

//******************************************************************************
// Get %windir%. Use GetSystemWindowsDirectory to fix the bug on Terminal Server 
//******************************************************************************
UINT InternalGetSystemWindowsDirectory(LPTSTR lpBuffer, UINT uSize)
{
    HINSTANCE hLib = NULL;
    UINT (CALLBACK *lpfGetSystemWindowsDirectory)(LPTSTR lpBuffer, UINT uSize) = NULL;
    UINT nRetVal;

    if(!lpBuffer) return 0;

    *lpBuffer = '\0';
    
    hLib = LoadLibrary(_T("kernel32.dll")); 

    if(hLib){

        lpfGetSystemWindowsDirectory = (UINT(CALLBACK*)(LPTSTR,UINT))
            #if defined UNICODE || defined _UNICODE
            GetProcAddress(hLib, "GetSystemWindowsDirectoryW");
            #else
            GetProcAddress(hLib, "GetSystemWindowsDirectoryA");
            #endif

        if(lpfGetSystemWindowsDirectory){

            nRetVal = (*lpfGetSystemWindowsDirectory)(lpBuffer, uSize);
            FreeLibrary(hLib);
            return nRetVal;
        }

    }
    if(hLib) FreeLibrary(hLib);
    return GetWindowsDirectory(lpBuffer, uSize);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\icrmap.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
//icrmap.h
//
//This map is a cache of the ICR instances.
//In the read case, file name maps to the ICR of its latest version
//In the write case, file name maps to the ICR of its temporary file.
//*****************************************************************************
#pragma once

#include <oledb.h>
#include "complib.h"
#include "icmprecsts.h"

#include <map_t.h>
#include "utsem.h"

struct ICRREF
{
	IComponentRecords* pICR;
	__int64	i64Version;	
	unsigned __int64 i64LastWriteTime;
	
};


typedef Map<WCHAR*,ICRREF*,HashWSTR> MapFileToICR;

class CMapICR
{
public:
	CMapICR() {};
	~CMapICR();
	BOOL Find( LPWSTR wszFileName, IComponentRecords** ppICR, __int64 *pi64Version, unsigned __int64 * pi64LastWriteTime = NULL);
	HRESULT Add( LPWSTR wszFileName, IComponentRecords** ppICR, __int64 i64Version, unsigned __int64  i64LastWriteTime = 0); 	
	void Delete ( LPWSTR wszFileName );
	void ResetMap();

private:
	UTSemReadWrite m_lockRW;
	MapFileToICR m_mapFileToICR;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\regdbapi.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// RegDBApi.cpp
//
// This code contains the implementation for the registration database shared
// memory manager.  The code is meant to be linked into the server process
// which owns the permanent copies of the data and handles all writers.  It is
// also linked into a client process to access shared data structures.
//
//*****************************************************************************
#include "stdafx.h"						// OLE controls.
#include <process.h>					// System command.
#include "RegControl.h"					// Shared API's and data structures.
#include "RegDBApi.h"					// Local defines.
#include "catmacros.h"
//#include "comacros.h"
//#include "csecutil.h"
BOOL RunningOnWinNT();

//********** Types. ***********************************************************
#define COMREGSRVR_EXE	"regservice.exe"


//********** Globals. *********************************************************
static long		g_Initialized = -1;		// # of times client was initialized.
static REGAPI_STATE	g_RegState;			// Registration data for this process.

//********** Locals. **********************************************************

STDMETHODIMP _RegGetICR(IComponentRecords **ppICR, BOOL bForceCheckDisk);
void _RegReleaseReference(REGAPI_STATE *pdbInfo);


//********** Code *************************************************************

//*****************************************************************************
// Provide access to the global data.
//*****************************************************************************
REGAPI_STATE *_RegGetProcessAPIState()
{		
	ASSERT(*g_RegState.rcRegDir);
	return (&g_RegState);
}


//*****************************************************************************
// This method initializes this client process to work with the registration
// database.
//*****************************************************************************
STDMETHODIMP CoRegInitialize()			// Return code.
{
	SYSTEM_INFO	sInfo;					// Info on this system.
	HRESULT hr = S_OK;

	// It it has already been initialized, skip that part.
	if (InterlockedIncrement(&g_Initialized) == 0)
	{
		// Zero out data.
		memset(&g_RegState, 0, sizeof(REGAPI_STATE));

		// Init the locking objects on our memory.
		InitializeCriticalSection( &g_RegState.g_csRegAPI );

		g_RegState.hProcessMem = OpenFileMappingA(FILE_MAP_READ, true, 
					REGISTRATION_TABLE_NAME);

		if ( g_RegState.hProcessMem )
		{
			// We need the system page size.
			GetSystemInfo(&sInfo);

			// Map the view so we can get a pointer to the data.
			g_RegState.pRegProcess = (REGISTRATION_PROCESS *) MapViewOfFile(
					g_RegState.hProcessMem,
					FILE_MAP_READ,
					0,
					0,
					sInfo.dwPageSize);
			if (!g_RegState.pRegProcess)
			{
				hr = HRESULT_FROM_WIN32( GetLastError() );
			//	LOG_ERROR(HR,(hr, ID_CAT_CAT, ID_COMCAT_REGDBAPI_INITFAILED));
				goto ErrExit;
			}

			
		}

		// Get the registration path.
		if ( _GetRegistrationDirectory( g_RegState.rcRegDir ) == FALSE )
		{
			hr = E_UNEXPECTED;
			goto ErrExit;
		}
	
		if (RunningOnWinNT())
		{
			if (!InitializeSecurityDescriptor(&g_RegState.sdRead, SECURITY_DESCRIPTOR_REVISION))
			{
				hr = HRESULT_FROM_WIN32( GetLastError() );
			//	LOG_ERROR(HR,(hr, ID_CAT_CAT, ID_COMCAT_REGDB_INITSECURITYDESC));
				goto ErrExit;
			}
			
			// Set the access control list on the security descriptor.
			if (!SetSecurityDescriptorDacl(&g_RegState.sdRead, TRUE, (PACL) NULL, FALSE))
			{
				hr = HRESULT_FROM_WIN32( GetLastError() );
			//	LOG_ERROR(HR,(hr, ID_CAT_CAT, ID_COMCAT_REGDB_INITSECURITYDESC));
				goto ErrExit;
			}

			// Fill in the security attributes.
			g_RegState.sa.nLength = sizeof(g_RegState.sa);
			g_RegState.sa.lpSecurityDescriptor = &g_RegState.sdRead;
			g_RegState.sa.bInheritHandle = FALSE;
			g_RegState.psa = &(g_RegState.sa);
		}
	
	}


ErrExit:
	if (FAILED(hr))
	{
		CoRegUnInitialize();
	}
	return (hr);

}


//*****************************************************************************
// This method will clean up any allocated resources during the life time of
// this process, including throwing away state for any databases opened.
//*****************************************************************************
STDMETHODIMP_(void) CoRegUnInitialize()
{
	// Last one out, turn off the lights.
	if (InterlockedDecrement(&g_Initialized) < 0)
	{
		// If there is any allocated data, free it now.

		_RegReleaseReference(&g_RegState);

		// Run the dtor for the global objects.
		DeleteCriticalSection(&g_RegState.g_csRegAPI);

		// Unmap the shared table if we obtained one.
		if (g_RegState.pRegProcess)
		{
			VERIFY(UnmapViewOfFile(g_RegState.pRegProcess));
			g_RegState.pRegProcess = NULL;
		}

		// Free the file mapping handle if we got one.
		if (g_RegState.hProcessMem)
		{
			CloseHandle(g_RegState.hProcessMem);
			g_RegState.hProcessMem = NULL;
		}

	}
}


//*****************************************************************************
// Get a reference to an ICR for the client.  If we already have cached a good
// one (either the current version of the database or one that has already been
// retrieved with this function and not released with CoRegReleaseICR yet) just
// return it.  Otherwise, close the old version if there is one and open the
// latest version and return it.
//*****************************************************************************
STDMETHODIMP CoRegGetICR(				// Return status.
	IComponentRecords **ppICR)			// Returned ICR
{
	int			iRetry;					// Retry loop control.
	HRESULT		hr = S_OK;
	BOOL		bForceCheckDisk = FALSE;
	
	// There are windows which would allow an aggresive writer to update the
	// current version between when we look for it and then try to access it.
	// Therefore, make a best effort to retry getting the handle to avoid such
	// a problem.
	for (iRetry=0;  iRetry<10;  iRetry++)
	{
		if (iRetry == 5)
			Sleep(1000);

		hr = _RegGetICR(ppICR, bForceCheckDisk );

		//Jump out of this retry loop only if we succeed or get an unexpected error back.
		if ( SUCCEEDED(hr) )
		{
			if ( *ppICR == NULL ) return E_UNEXPECTED;	
			return hr;
		}

		switch ( hr )
		{
			case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
			{
				if ( iRetry == 3 )
					bForceCheckDisk = TRUE;
			}
			break;
			
			case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
			case CLDB_E_FILE_CORRUPT:
				bForceCheckDisk = TRUE;
			break;

			case CLDB_E_SMDUPLICATE:
			case HRESULT_FROM_WIN32(E_ACCESSDENIED):
				break;

			case HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION):
				Sleep(500);
			break;

			default:
				return hr;
		}

	}
	return (hr);
}


//*****************************************************************************
// The real worker function for CoRegGetICR.  See the documentation for
// CoRegGetICR for the details.
//*****************************************************************************
STDMETHODIMP _RegGetICR(				// Return status.
	IComponentRecords **ppICR,			// Returned ICR
	BOOL bForceCheckDisk)			
{
	int			iRetry;					// Retry loop control.
	HRESULT		hr = S_OK;
	IComponentRecords *pTempICR = NULL;
	BOOL		bHasLock = FALSE;
	REGAPI_DBINFO dbInfo;				// For new version if applicable.

	// Validate the init state.
	ASSERT(g_Initialized >= 0);
	if (g_Initialized < 0)
		return (E_REGDB_NOTINITIALIZED);

	// Lock the global table to avoid overlapped access.
	EnterCriticalSection(&g_RegState.g_csRegAPI);
	bHasLock = TRUE;

	// If there is an existing pointer and it isn't too old, use it.
/*	if (g_RegState.pICR && 
		GetTickCount() - g_RegState.dwLastChecked <= VERSION_CHECK_INTERVAL)
	{
		hr = S_OK;
		goto ErrExit;
	}
*/
	// Make up to two passes before quiting.  This handles the case where
	// the file gets faulted in the first time, as well as the race condition
	// of two processes trying to fault in the first version simultaneously.
	__try{
	for (iRetry=0;  iRetry<2;  iRetry++)
	{
		// Do a lookup for the latest version we can find.
		hr = _RegGetLatestVersion(g_RegState.rcRegDir, &dbInfo, bForceCheckDisk);
		if ( FAILED(hr) ) goto ErrExit;


		// If no version was found, then we have to create an empty one.
		if (hr == S_FALSE)
		{

			if ( bForceCheckDisk )
			{
				//If all the REGDB files are corrupt, revert to emptyregdb.bat if it exists
				TCHAR tszEmpty[_MAX_PATH];
				ULONG	uiSize	= 0;	 // Size of the Windows Directory
				uiSize = GetSystemDirectory(tszEmpty, _MAX_PATH);
				if ( uiSize == 0 || uiSize >=  _MAX_PATH )
				{
					hr = E_UNEXPECTED;
					goto ErrExit;
				}

				LPTSTR	ptszCurPos = tszEmpty;
				
				while (*ptszCurPos != '\0')
				{
					ptszCurPos ++;
				}

				ptszCurPos --;
				if (*ptszCurPos == '\\')
				{
					// If we had a back slash we remove it.
					*ptszCurPos = '\0';
				}

				_tcscat( tszEmpty, SZEMPTYREGDB_NAME );

				CopyFile( tszEmpty, dbInfo.rcDBName, true);
				continue;
			}
	

			IComponentRecords *pICR = NULL;
			
			// Create a new database file of this version.
			if (SUCCEEDED(hr = CreateComponentLibraryTS(dbInfo.rcDBName, 
						DBPROP_TMODEF_DFTWRITEMASK | DBPROP_TMODEF_ALIGNBLOBS, &pICR)))
			{
				// Add our schema to the new file.
				if (SUCCEEDED(hr = pICR->SchemaAdd(&COMRegSchemaBlob)))
				{
					// Save the changes to disk.
					hr = pICR->Save(NULL);
				}
			}

			// Free up the new database.
			if (pICR)
				pICR->Release();

			// Check for error and let a retry occur in case someone
			// else beat us to creating a new version.
			continue;
		}
		// If the newest version found is no newer than what we have, don't change.
		else if (g_RegState.pICR && g_RegState.VersionNum >= dbInfo.VersionNum)
		{
			// Save the timestamp when we got this data.
			g_RegState.dwLastChecked = GetTickCount();
			hr = S_OK;
			goto ErrExit;
		}

		break;
		
	}
	
	
	//Release the lock to prevent loaderLock deadlock
	LeaveCriticalSection(&g_RegState.g_csRegAPI);
	bHasLock = FALSE;
	
	// Verify we have everything required to proceed.
	ASSERT(dbInfo.rcMapName[0]);
	ASSERT(dbInfo.rcDBName[0]);
	
	if (!dbInfo.rcMapName[0] || !dbInfo.rcDBName[0])
	{
		hr = E_UNEXPECTED;
	}
	else
	{
		// Open the component library on this shared data file, and
		// then on success add the schema to the instance.
		hr = OpenComponentLibrarySharedTS(dbInfo.rcDBName, dbInfo.rcMapName, 
				0, g_RegState.psa,
				DBPROP_TMODEF_READ | DBPROP_TMODEF_SMEMOPEN | DBPROP_TMODEF_SMEMCREATE, 
				&pTempICR);
	}

	//Get the lock again since we are about to access g_RegState 
	EnterCriticalSection(&g_RegState.g_csRegAPI);
	bHasLock = TRUE;
	
	if (SUCCEEDED(hr))
	{
		// Free up any old references we once had.
		if ( !g_RegState.pICR || g_RegState.VersionNum < dbInfo.VersionNum )		
		{
			_RegReleaseReference(&g_RegState);

				
			memcpy(&g_RegState, &dbInfo, sizeof(REGAPI_DBINFO));
		
			g_RegState.pICR = pTempICR;
		
			hr = g_RegState.pICR->SchemaAdd(&COMRegSchemaBlob);
		}
		else if ( pTempICR )
		{ 	pTempICR->Release(); pTempICR = NULL; }
		
	}
	else if ( hr == CLDB_E_FILE_CORRUPT )
	{
		TCHAR	rcdb2[_MAX_PATH];
		_tcscpy(rcdb2, g_RegState.rcDBName);
		_tcscat(rcdb2, _T(".corrupt"));
		ASSERT(0 && "REGDB is corrupt, we are reverting to a previous version");
		VERIFY(MoveFileEx(g_RegState.rcDBName, rcdb2, MOVEFILE_REPLACE_EXISTING));
	//	LOG_ERROR(HR,
	//		(CLDB_E_FILE_CORRUPT, ID_CAT_CAT, ID_COMCAT_REGDB_FOUNDCORRUPT));
	}

		

ErrExit:
	// If we got a pointer, addref it.
	if (SUCCEEDED(hr))
	{
		*ppICR = g_RegState.pICR;
		(*ppICR)->AddRef();

	}
	else
	{
		// Free up anything allocated.
		_RegReleaseReference(&g_RegState);
	}
	} //try
	__finally
	{

		// Release lock on reg state.
		if ( bHasLock )
			LeaveCriticalSection(&g_RegState.g_csRegAPI);

		return (hr);
	}
}


//*****************************************************************************
// Simply decrement the use count on this ICR reference.
//*****************************************************************************
STDMETHODIMP_(void) CoRegReleaseICR(IComponentRecords **ppICR)
{
	HRESULT		hr = S_OK;

	// Validate the init state.
	ASSERT(g_Initialized >= 0);
	if (g_Initialized < 0)
		return;


	ASSERT(*ppICR);
	(*ppICR)->Release();
	*ppICR = NULL;

}


//*****************************************************************************
// Free any cached client state.
//*****************************************************************************
STDMETHODIMP_(void) CoRegReleaseCache()
{
	EnterCriticalSection(&g_RegState.g_csRegAPI);
	_RegReleaseReference(&g_RegState);
	LeaveCriticalSection(&g_RegState.g_csRegAPI);
}


//********** Internal Helpers. ************************************************

//*****************************************************************************
// Look for the latest version number of the database in the 
// %windir%\registration directory using the file naming schema and last
// modified date.  When found, return the full name to the file along with
// othe relevant version information to the caller.  There is no guarantee
// that another update won't be made, or that the file won't get deleted after
// this function returns.
//*****************************************************************************
HRESULT _RegGetLatestVersion(			// Return code.
	LPCTSTR		szRegDir,				// Location of registration data.
	REGAPI_DBINFO *pdbInfo,				// Return current version.
	BOOL	bForceCheckDisk,			// If it's true, we don't trust the version number in shared mem or registry
	BOOL	bFromSysApp	)				// If calling from system app, we always trust the version number in shared mem		
										// and never trust the registry key value.
{
	TCHAR		rcRegDir[_MAX_PATH];	// Location of registration databases.
	TCHAR		rcVer[16];				// For conversion of name.
	__int64		iVersion;				// Version number conversion.
	WIN32_FIND_DATA FileData;			// For each found file.
	HANDLE		hFind=INVALID_HANDLE_VALUE;	// Find handle.
	DWORD		dwError=0;				// System error.
	int			bCreateDir=true;		// Flag for directory creation.
	HRESULT		hr = S_OK;
	HKEY		hCOM3Key;
	DWORD		dwcbBuf = sizeof(pdbInfo->VersionNum);
	BOOL		bSetREGDBVersion = FALSE;

	ASSERT(pdbInfo);

	// Clear the output data up front.
	pdbInfo->FileVersion = 0;
	pdbInfo->VersionNum = 0;
	pdbInfo->dwLastChecked = 0;
	pdbInfo->rcMapName[0] = 0;
	pdbInfo->rcDBName[0] = 0;
	pdbInfo->cbFileSize = 0;

	// And add the registration directory path to it.
	ASSERT(szRegDir && *szRegDir);
	_tcscpy(rcRegDir, szRegDir);
	_tcscat(rcRegDir, _T("\\R????????????.clb"));

	//Try to open shared memory
	if ( g_RegState.hProcessMem == NULL )
	{
		g_RegState.hProcessMem = OpenFileMappingA(FILE_MAP_READ, true, 
												  REGISTRATION_TABLE_NAME);

		if ( g_RegState.hProcessMem )
		{
			SYSTEM_INFO	sInfo;					// Info on this system.

			GetSystemInfo(&sInfo);
			// Map the view so we can get a pointer to the data.
			g_RegState.pRegProcess = (REGISTRATION_PROCESS *) MapViewOfFile(
					g_RegState.hProcessMem,
					FILE_MAP_READ,
					0,
					0,
					sInfo.dwPageSize);

			
		}
	}

	//Get the latest version info from shared memory if it exists
	if ( g_RegState.pRegProcess )
	{
		DWORD		dwServerLive;

		pdbInfo->VersionNum = (g_RegState.pRegProcess)->LatestVersion;
		dwServerLive = (g_RegState.pRegProcess)->dwLastLive;
	
		if ( GetTickCount() - dwServerLive >= SHAREDMEMORY_STALE_CHECK && !bFromSysApp )
		{
	//		ASSERT(0);
			//The timestamp set by the server process is more than 2 minutes old
			//release my reference on the shared memory

			// Unmap the shared table if we obtained one.			
			VERIFY(UnmapViewOfFile(g_RegState.pRegProcess));
			g_RegState.pRegProcess = NULL;

			// Free the file mapping handle if we got one.			
			CloseHandle(g_RegState.hProcessMem);
			g_RegState.hProcessMem = NULL;
	
		}
		else if ( pdbInfo->VersionNum > 1 )
		{
			if ( bForceCheckDisk )			
				goto Retry;

			goto ErrExit;
		}
		//special case for versionnum == 1, file may not be created yet.
	}


	//At this point, we know system app is not running. Try to get the current REGDB version
	//from the Registry.
	if ( !bFromSysApp )
	{
		dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, COM3_KEY, 0, KEY_READ, &hCOM3Key);
		if ( dwError == ERROR_SUCCESS )
		{
			dwError = RegQueryValueEx(hCOM3Key, REGDBVER, 0, NULL, (BYTE*)&(pdbInfo->VersionNum), &dwcbBuf);
			RegCloseKey(hCOM3Key);

			if ( dwError != ERROR_SUCCESS || bForceCheckDisk )		
				bSetREGDBVersion = TRUE;
			else 
				goto ErrExit;
		}
	}


	// Start the find loop by looking for files.
Retry:
	pdbInfo->VersionNum = 0;

	hFind = FindFirstFile(rcRegDir, &FileData);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		// Get error code.
		dwError = GetLastError();

		// Check for file not found.
		if (dwError == ERROR_FILE_NOT_FOUND)
		{
			hr = S_OK;
			goto ErrExit;
		}

		// If the problem is the directory does not exist, try to create.
		if (bCreateDir && GetFileAttributes(szRegDir) == 0xffffffff && 
					CreateDirectory(szRegDir, 0))
		{
			bCreateDir = false;
			hr = S_OK;
			goto Retry;
		}

		// If still errors, return this generic error.
		hr = E_REGDB_SYSTEMERR;
		goto ErrExit;
	}

	// Loop through every file we can find.
	do
	{
		// Parse off the version number of this file.
		// Check for working file and skip.
		if (_tcsicmp(SZWORKING_NAME, FileData.cFileName) == 0)
			continue;

		_stscanf(FileData.cFileName, _T("R%012I64x.clb"),&iVersion);
		
		// Is this version bigger than our current max? Handle roll over.
		__int64 diff = iVersion - pdbInfo->VersionNum;
		if ((diff > 0 && diff < MAX_VERSION_NUMBER/2) || diff < -MAX_VERSION_NUMBER/2 || pdbInfo->VersionNum == 0 )
		{
			// Validate the higher versioned file has higher last write time.
//@todo: Turns out that last write time is not very reliable on FAT.  You can
// write file 1 and then file 2 and the latter can come before the former.
//			ASSERT(CompareFileTime(&FileData.ftLastWriteTime, (const FILETIME *) &pdbInfo->FileVersion) >= 1);

			// This is the new max.
			pdbInfo->VersionNum = iVersion;
			pdbInfo->FileVersion = *(FILEVERSION *) &FileData.ftLastWriteTime;
			pdbInfo->cbFileSize = FileData.nFileSizeLow;
			ASSERT(FileData.nFileSizeHigh == 0);
		}

	// Check for next file in list.
	} while (FindNextFile(hFind, &FileData));

ErrExit:
	// Close the search if one was opened.
	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);

	// If there were no errors, then proceed.
	if (SUCCEEDED(hr))
	{
		// If no file was found, tell caller.
		if (pdbInfo->VersionNum == 0)
		{
			hr = S_FALSE;
			pdbInfo->VersionNum = 1;
		}

		// Figure out the rest of the data.
		VERIFY(GetDBName(pdbInfo->rcDBName, _MAX_PATH, szRegDir, pdbInfo->VersionNum));
		VERIFY(GetSharedName(pdbInfo->rcMapName, sizeof(pdbInfo->rcMapName), 
					pdbInfo->VersionNum, pdbInfo->FileVersion));

		//Set REGDB version in the registry
		if ( bSetREGDBVersion && hr == S_OK )
		{
			dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, COM3_KEY, 0, KEY_WRITE, &hCOM3Key);
			if ( dwError == ERROR_SUCCESS )
			{
				dwError = RegSetValueEx(hCOM3Key, REGDBVER, 0, REG_BINARY, (BYTE*)&(pdbInfo->VersionNum), sizeof(pdbInfo->VersionNum) );
				RegCloseKey(hCOM3Key);	
			}
		}

	}
	return (hr);
}


//*****************************************************************************
// Free up a reference to a version of the database.
//*****************************************************************************
void _RegReleaseReference(
	REGAPI_STATE *pdbInfo)				// Return current version.
{
	// Safely clean up the pointer and state data.
	if (pdbInfo->pICR)
		pdbInfo->pICR->Release();
	pdbInfo->pICR = NULL;
	pdbInfo->VersionNum = 0;
	pdbInfo->rcMapName[0] = pdbInfo->rcDBName[0] = 0;
}


//**********************************************************************************
// Free up all the memory I allocated. This method will be called by CoUninitilize() 
//**********************************************************************************
STDMETHODIMP_(void) CoRegCleanup()
{
	EnterCriticalSection(&g_RegState.g_csRegAPI);
	__try{

		_RegReleaseReference(&g_RegState);

		// Unmap the shared table if we obtained one.
		if (g_RegState.pRegProcess)
		{
			VERIFY(UnmapViewOfFile(g_RegState.pRegProcess));
			g_RegState.pRegProcess = NULL;
		}

		// Free the file mapping handle if we got one.
		if (g_RegState.hProcessMem)
		{
			CloseHandle(g_RegState.hProcessMem);
			g_RegState.hProcessMem = NULL;
		}
	}
	__finally
	{
		LeaveCriticalSection(&g_RegState.g_csRegAPI);

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\regdbquery.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// RegDBQuery.cpp
//
// This module contains the code to query data from the database.  The public
// api's, such as CoReg* obtain connections and then pass them into these
// worker functions to actually get the data back.
//
//*****************************************************************************
#include "stdafx.h"						// OLE controls.
#include "RegDBApi.h"					// Local defines.
#include "RegControl.h"					// Shared API's and data structures.



//********** Code *************************************************************


#if _QRY_CS_CODE

//*****************************************************************************
// Post a query to the registration server process which will run the query
// in that process and place the results in the shared memory section which
// can then be read here.
//*****************************************************************************
HRESULT _RegPostRequest(				// Return code.
	REGAPI_STATE *pState,				// Handles
	REGISTRATION_QRY *pQuery,			// Query value to post to server process.
	REGISTRATION_COCLASS *pCoClass)		// Return data here.
{
	//@todo: None of this is thread/process safe.  The idea is that you define
	// a suballocation scheme in the shared memory that either does locking an
	// is compact, or allocates room to each process so only process local
	// locking is required.  The exercise is left to the reader.

	// Copy the query request to the server.
	memcpy(pState->pRegProcess->rgQuery, pQuery, pQuery->cbSize);

	// Send the request to the server process.
	if (::SendMessage(pState->pRegProcess->hWndIPC, WM_USER, 0, 0))
	{
		REGISTRATION_COCLASS *p = (REGISTRATION_COCLASS *) pState->pRegProcess->rgBuff;
		pCoClass->clsid = p->clsid;
		pCoClass->ThreadingModel = p->ThreadingModel;
		strcpy(pCoClass->rcModule, p->rcModule);
	}
	else
		return (REG_E_SERVERERR);

#if 0
	COPYDATASTRUCT cds;

	// Fill out the copy data structure to remote the query.
	cds.dwData = sizeof(COPYDATASTRUCT);
	cds.cbData = pQuery->cbSize;
	cds.lpData = pQuery;

	// Send the data to the server, then get the results.
	if (::SendMessage(pState->pRegProcess->hWndIPC, WM_COPYDATA, 
			(WPARAM) (HWND) NULL, (LPARAM) (COPYDATASTRUCT *) &cds))
	{
		REGISTRATION_COCLASS *p = (REGISTRATION_COCLASS *) pState->pRegProcess->rgBuff;
		pCoClass->clsid = p->clsid;
		pCoClass->ThreadingModel = p->ThreadingModel;
		strcpy(pCoClass->rcModule, p->rcModule);
	}
	else
		return (REG_E_SERVERERR);
#endif
	return (S_OK);
}
#endif // _QRY_CS_CODE


//*****************************************************************************
// Lookup the given class for all of its registration data.  Return the data
// in the structure given.
//@todo: this version is kind of stupid, cause it fetches the data to a 
// full struct and copies it to the output struct.  Should direct bind and
// fetch that data.
//*****************************************************************************
HRESULT _RegGetClassInfo(				// Return code.
	REGAPI_STATE *pState,				// Current state.
	REFCLSID	clsid,					// Class to lookup.
	REGISTRATION_COCLASS *pCoClass)		// Return data here.
{
	RegDB_RegClass regRecord;			// A registration record.
	void		*rgRowPtr[1];			// For row fetches.
	LPCSTR		pszPath;				// The path.
	int			iFetched;				// How many rows fetched.
	int			i;
	HRESULT		hr;

	ASSERT(pState->pICR);

	// The following are constant data for various ICR calls.
	static const ULONG rgColumnClsid[] = { COLID_RegDB_RegClass_clsid };
	static const DBTYPE rgTypeClsid[] = { DBTYPE_GUID };
	static const ULONG rgcbType[] = { sizeof(CLSID) };
	static const ULONG fFields = 
			SetColumnBit(COLID_RegDB_RegClass_Version) |
			SetColumnBit(COLID_RegDB_RegClass_Module) |
			SetColumnBit(COLID_RegDB_RegClass_BehaviorFlags) |
			SetColumnBit(COLID_RegDB_RegClass_ThreadingModel);

	// This query hint allows for queries of RegClass.clsid by index.
	QUERYHINT	sQryHint;
	sQryHint.iType = QH_INDEX;
	sQryHint.szIndex = "RegDB.RegClsid";

	const void *rgClsid[] = { &clsid };

	// First fetch the class using the GUID.
	hr = pState->pICR->QueryByColumns(pState->tblRegClass, &sQryHint, 
			1, rgColumnClsid, NULL, rgClsid, rgcbType, rgTypeClsid, 
			rgRowPtr, 1, NULL, &iFetched);
	if (hr != S_OK)
	{
		if (hr == CLDB_E_RECORD_NOTFOUND)
			wprintf(L"Failed to find clsid #%d!\n");
		goto ErrExit;
	}

	// Get the module ID and threading model.
	hr = pState->pICR->GetOid(pState->tblRegClass, COLID_RegDB_RegClass_Module,
			rgRowPtr[0], &regRecord.Module);
	if (FAILED(hr))
		goto ErrExit;

	// Now fetch the module path.
	hr = pState->pICR->GetRowByOid(pState->tblRegModule, regRecord.Module, 
			COLID_RegDB_RegModule_oid, rgRowPtr);
	if (SUCCEEDED(hr))
	{
		pszPath = 0;
		hr = pState->pICR->GetStringA(pState->tblRegModule, COLID_RegDB_RegModule_Filename, 
				rgRowPtr[0], &pszPath);
	}

	// Copy the data out to the caller.
	if (hr == S_OK)
	{
		//@todo:
	}

ErrExit:
	return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\stdafx.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\stdafx.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// stdafx.h
//
// Header file for test app.
//*****************************************************************************
#include <ole2.h>
#include <tchar.h>
#include <oledb.h>
//#include <crtdbg.h>
#include <atlbase.h>
#include <complib.h>
#include <icmprecsts.h>
#include "RegDBShared.h"
#include "MetaErrors.h"					// Error codes for meta data.
#include "COMRegStructs.h"				// Structures for reg database.
#include "COMRegBlobs.h"				// Blob data.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\snmap.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************************
//SNMap.cpp
//
//This map is a cache of the ICR instances associated with a certain snapshot.
//It's for read only.  File name maps to a list of SNAPSHOTREF entries that keep
//the ICR for a certain snapshot and the ref count on the snap shot. 
//*****************************************************************************************
#include "stdafx.h"
#include "catmacros.h"
#include "SNMap.h"
#include "limits.h"

//*****************************************************************************************
//Helper function, returns the SNAPSHOTREF that matches both wszFileName and snid. If not
//match is found, return FALSE. If pSNRefFirst is non-null, set it to be the first entry 
//in the list that matches wszFileName. If ppSNRefPre is non-null, set it to be the entry 
//before ppSNRefMatch
//*****************************************************************************************
BOOL CSNMap::FindEntry( LPWSTR wszFileName, ULONG snid, SNAPSHOTREF** ppSNRefMatch, 
					    SNAPSHOTREF** ppSNRefFirst, SNAPSHOTREF** ppSNRefPre )
{
	SNAPSHOTREF* pSNRef = NULL;
	SNAPSHOTREF* pPre = NULL;

	ASSERT( ppSNRefMatch );
	*ppSNRefMatch = NULL;

	if ( ppSNRefFirst )
		*ppSNRefFirst = NULL;
	if ( ppSNRefPre )
		*ppSNRefPre = NULL;

	if ( m_mapFileToSnapShot.map( wszFileName, &pSNRef ) )
	{	
		if ( ppSNRefFirst )
			*ppSNRefFirst = pSNRef;
		//Walk through the list to find a match
		while ( pSNRef )
		{
			if ( (ULONG)(pSNRef->i64Version) == snid )
			{
				*ppSNRefMatch = pSNRef;
				if ( ppSNRefPre )
					*ppSNRefPre = pPre;
				return TRUE;
			}
		
			pPre = pSNRef;
			pSNRef = pSNRef->pNext;
		}
	}

	return FALSE;
}

//*****************************************************************************************
// Find the smallest snapshot id that is referenced.
//*****************************************************************************************
ULONG CSNMap::FindSmallestSnapshot( LPWSTR wszFileName)
{
	SNAPSHOTREF* pSNRef = NULL;
	ULONG		minSnid = ULONG_MAX;

	if ( m_mapFileToSnapShot.map( wszFileName, &pSNRef ) )
	{	
		//Walk through the list to find the smallest snid.
		while ( pSNRef )
		{
			if ( (ULONG)(pSNRef->i64Version) < minSnid )
			{
				minSnid = (ULONG)(pSNRef->i64Version);
			}
			pSNRef = pSNRef->pNext;
		}
	}

	return minSnid;
}


BOOL CSNMap::Find( LPWSTR wszFileName, ULONG snid, IComponentRecords** ppICR )
{
	SNAPSHOTREF* pSNRef = NULL;

	UTSemRWMgrRead rdLock( &m_lockRW );

	if ( FindEntry( wszFileName, snid, &pSNRef, NULL, NULL ) )
	{
		*ppICR = pSNRef->pICR;
		ASSERT( *ppICR );

		return TRUE;
	}
	else
	{
		return FALSE;
	}
	
}


HRESULT CSNMap::Add( LPWSTR wszFileName, IComponentRecords* pICR, __int64	i64Version )
{
	SNAPSHOTREF* pSNRef = NULL;
	SNAPSHOTREF* pSNRefFirst = NULL;

	UTSemRWMgrWrite wtLock( &m_lockRW );

	if ( FindEntry( wszFileName, (ULONG)i64Version, &pSNRef, &pSNRefFirst, NULL ) )
	{
		pICR->Release();
		InterlockedIncrement( (LONG*)&(pSNRef->cRef) );
		return S_OK;
	}

	//Not found, create a new entry
	DWORD cch = ::lstrlen( wszFileName ) + 1;
	LPWSTR pwsz = new WCHAR[cch];
	if ( pwsz == NULL )
		return E_OUTOFMEMORY;

	memcpy( pwsz, wszFileName, cch*sizeof(WCHAR) );

	pSNRef = new SNAPSHOTREF;
	if ( pSNRef == NULL )
	{
		delete [] pwsz;
		return E_OUTOFMEMORY;
	}

	pSNRef->pICR = pICR;
	pSNRef->i64Version = i64Version;
	pSNRef->cRef = 1;
	pSNRef->pNext = pSNRefFirst;


	try{
		m_mapFileToSnapShot.add( pwsz, pSNRef );
	}
	catch(...)
	{
		pICR->Release();
		delete [] pwsz;
		delete pSNRef;
		return E_OUTOFMEMORY;
	}

	return S_OK;
}


BOOL CSNMap::AddRefSnid ( LPWSTR wszFileName, ULONG snid )
{
	SNAPSHOTREF* pSNRef = NULL;

	UTSemRWMgrRead rdLock( &m_lockRW );

	if ( FindEntry( wszFileName, snid, &pSNRef, NULL, NULL ) )
	{
		InterlockedIncrement( (LONG*)&(pSNRef->cRef) );
		return TRUE;
	}

	return FALSE;
}

BOOL CSNMap::ReleaseSnid ( LPWSTR wszFileName, ULONG snid )
{
	SNAPSHOTREF* pSNRef = NULL;
	SNAPSHOTREF* pPre = NULL;

	UTSemRWMgrWrite wtLock( &m_lockRW );

	if ( FindEntry( wszFileName, snid, &pSNRef, NULL, &pPre ) )
	{
		if ( InterlockedDecrement( (LONG*)&(pSNRef->cRef) ) == 0 )
		{
			LPWSTR  pwsz = NULL;
			//Ref count on the snid comes down to zero, delete the entry in the map, and 
			//release the map's reference on the ICR
			(pSNRef->pICR)->Release();
			pSNRef->pICR = NULL;

			if ( pPre )
			{
				pPre->pNext = pSNRef->pNext;
			}
			else if ( pSNRef->pNext )
			{
				//pSNRef is the first but not the only one in the linked list
				m_mapFileToSnapShot.contains ( wszFileName, &pwsz );
				m_mapFileToSnapShot.add( pwsz, pSNRef->pNext );//this add is in fact an update. try...catch is not needed.
			}
			else
			{	//pSNRef is the only one in the linked list
				
				m_mapFileToSnapShot.contains ( wszFileName, &pwsz );
				m_mapFileToSnapShot.remove( pwsz );
				delete [] pwsz;
			}

			delete pSNRef;
		}	


		return TRUE;
	}

	return FALSE;
}


void CSNMap::ResetMap()
{
	EnumMap<WCHAR*,SNAPSHOTREF*,HashWSTR> itor (m_mapFileToSnapShot);
	LPWSTR pwsz;
	SNAPSHOTREF* pSNRef = NULL;


	UTSemRWMgrWrite wtLock( &m_lockRW );

	while (itor.next())
	{
		itor.get(&pwsz, &pSNRef);
		delete [] pwsz;

		while ( pSNRef )
		{
			SNAPSHOTREF* pSNTemp = NULL;
			pSNTemp = pSNRef;
			(pSNRef->pICR)->Release();
			pSNRef = pSNRef->pNext;
			delete pSNTemp;
		}
		
	}
		
	m_mapFileToSnapShot.reset();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi\snmap.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
//SNMap.h
//
//This map is a cache of the ICR instances associated with a certain snapshot.
//It's for read only. File name maps to a list of SNAPSHOTREF entries that keep
//the ICR for a certain snapshot and the ref count on the snap shot. 
//*****************************************************************************
#pragma once

#include <oledb.h>
#include "complib.h"
#include "icmprecsts.h"

#include <map_t.h>
#include "utsem.h"

struct SNAPSHOTREF
{
	IComponentRecords* pICR;
	__int64	i64Version;	
	ULONG cRef;	
	SNAPSHOTREF* pNext;
};

typedef Map<WCHAR*,SNAPSHOTREF*,HashWSTR> SNAPSHOTMAP;

class CSNMap
{
public:
	//Find match for wszFileName and snid in the map, return false if not found. 
	BOOL Find( LPWSTR wszFileName, ULONG snid, IComponentRecords** ppICR );
	//Add to the map. If the same snap shot already exists, just AddRef snid.
	HRESULT Add( LPWSTR wszFileName, IComponentRecords* pICR, __int64	i64Version );
	//Increment cRef for snid. Return false if not found.
	BOOL AddRefSnid ( LPWSTR wszFileName, ULONG snid );
	//Decrement cRef for snid. Return false if not found. 
	BOOL ReleaseSnid ( LPWSTR wszFileName, ULONG snid );
	void ResetMap();
	// Find the smallest snid given a filename.
	ULONG FindSmallestSnapshot( LPWSTR wszFileName);

private:
	BOOL FindEntry( LPWSTR wszFileName, ULONG snid, SNAPSHOTREF** ppSNRefMatch, SNAPSHOTREF** ppSNRefFirst, SNAPSHOTREF** ppSNRefPre );
	UTSemReadWrite m_lockRW;
	SNAPSHOTMAP m_mapFileToSnapShot;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbapi64\dummy64.cpp ===
#include "..\regdbapi\clbread.h"
#include "catmacros.h"

HRESULT STDAPICALLTYPE CreateComponentLibraryEx(
    LPCWSTR     szName,
    long        dwMode,
    IComponentRecords **ppIComponentRecords,
    LPSECURITY_ATTRIBUTES pAttributes)  // Security token.
{
	ASSERT(0);
	return E_UNEXPECTED;
}


HRESULT STDAPICALLTYPE OpenComponentLibraryEx(
    LPCWSTR     szName, 
    long        dwMode,
    IComponentRecords **ppIComponentRecords,
    LPSECURITY_ATTRIBUTES pAttributes)  // Security token.
{
	ASSERT(0);
	return E_UNEXPECTED;
}

HRESULT STDMETHODCALLTYPE OpenComponentLibrarySharedEx( 
    LPCWSTR     szName,                 // Name of file on create, NULL on open.
    LPCWSTR     szSharedMemory,         // Name of shared memory.
    ULONG       cbSize,                 // Size of shared memory, 0 on create.
    LPSECURITY_ATTRIBUTES pAttributes,  // Security token.
    long        fFlags,                 // Open modes, must be read only.
    IComponentRecords **ppIComponentRecords) // Return database on success.
{
    ASSERT(0);
	return E_UNEXPECTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\regdb\regdbbak\regdbbak.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
//*****************************************************************************
// RegDBBak.cpp
//
// This code contains the implementation for the registration database backup
// and restore.
//
//*****************************************************************************
#include <ole2.h>
#include <tchar.h>
#include "assert.h"
#include "comacros.h"
#include "RegControl.h"
#include <oledb.h>
#include <complib.h>
#include <icmprecsts.h>
#include <metaerrors.h>
#include "comregstructs.h"
#include "winwrap.h"

HRESULT _GetLatestVersion( LPCTSTR szRegDir, __int64 * pVersion );
UINT InternalGetSystemWindowsDirectory(LPTSTR lpBuffer, UINT uSize);
HRESULT SetLatestVersion( __int64 i64Version );

//*****************************************************************************
//Back up REGDB 
//*****************************************************************************
STDAPI RegDBBackup( BSTR bstrBackupFilePath )
{
	TCHAR szRegDir[_MAX_PATH];
	TCHAR szName[_MAX_PATH];
	__int64 iVersion;
	HRESULT hr = S_OK;
	int iRetry;

	if ( _GetRegistrationDirectory( szRegDir ) == FALSE )
		return E_UNEXPECTED;

	hr =_GetLatestVersion( szRegDir, &iVersion );
	agoto_on_bad_hr(hr, ErrExit);

	_stprintf(szName, _T("%s\\R%012I64x.clb"), szRegDir, iVersion);

	for ( iRetry = 0; iRetry < 5; iRetry ++ )
	{
		if (!CopyFile(szName, bstrBackupFilePath, false))
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			if ( hr == HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) && iRetry < 4 )
				Sleep(1000);
			else
				goto ErrExit;
		}
		else
			break;
	}


ErrExit:
	return hr;
}

//*****************************************************************************
//Restore REGDB 
//*****************************************************************************
typedef HRESULT( __stdcall *PFNOpenComponentLibraryEx)(LPCWSTR, long, IComponentRecords **, LPSECURITY_ATTRIBUTES);

STDAPI RegDBRestore( BSTR bstrBackupFilePath )
{
	TCHAR szRegDir[_MAX_PATH];
	TCHAR szName[_MAX_PATH];
	__int64 iVersion;
	__int64 iNewVersion;
	HRESULT hr = S_OK;
	
	DWORD	dwError;
	HKEY	hKey;
	HINSTANCE hLib = NULL;
	
	if ( _GetRegistrationDirectory( szRegDir ) == FALSE )
		return E_UNEXPECTED;

	hr =_GetLatestVersion( szRegDir, &iVersion );
	if ( FAILED(hr) )
	{
		if ( hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) )
			hr = S_OK;
		else
			goto ErrExit;
	}

	iNewVersion = (iVersion + 1 < MAX_VERSION_NUMBER) ? iVersion + 1 : 2;
	_stprintf(szName, _T("%s\\R%012I64x.clb"), szRegDir, iNewVersion);

	hLib = LoadLibrary(_T("clbcatq.dll")); 

	if ( !hLib )
		return ( HRESULT_FROM_WIN32(GetLastError()) );
	else
	{
		IComponentRecords* ptestICR = NULL;
		PFNOpenComponentLibraryEx pfn = NULL;

		pfn = (PFNOpenComponentLibraryEx)GetProcAddress (hLib, "OpenComponentLibraryEx");
		if ( !pfn )
			hr = HRESULT_FROM_WIN32(GetLastError());
		else
		{
			//verify it's a clb file
			hr = (*pfn)(bstrBackupFilePath, DBPROP_TMODEF_READ, &ptestICR);
			if (SUCCEEDED(hr))
			{
				//verify it has current REGDB schema in it.
				int ifetchedSchema = 0;
				COMPLIBSCHEMADESC rgSchema[5];
				BOOL bFound = FALSE;

				hr = ptestICR->SchemaGetList( 5
								 ,&ifetchedSchema
								 ,rgSchema
								);

				if (SUCCEEDED(hr))
				{

					for ( int i = 0; i < ifetchedSchema; i ++ )
					{
						if ( rgSchema[i].sid == SCHEMA_COMReg )
						{
							bFound = TRUE;
							break;
						}
					}
					
					//return error if COMReg schema is not found or version number is wrong.
					if ( !bFound || rgSchema[i].Version != COMRegSchema.Version )
						hr = E_FAIL;
				}

				ptestICR->Release();
			}
			//Bug 11500: We get CLDB_E_NO_DATA when trying to open a dll with no clb in it.
			//comadmin does not map this error, so I map it to CLDB_E_FILE_CORRUPT, which is
			//the error I get when opening other non-clb file.
			else if ( hr == CLDB_E_NO_DATA )
				hr = CLDB_E_FILE_CORRUPT;
		}

		FreeLibrary(hLib);
	}

	return_on_bad_hr( hr );


	if (!CopyFile(bstrBackupFilePath, szName, false))
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
	}

	hr = SetLatestVersion( iNewVersion );
	
	dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, COM3_KEY, 0, KEY_WRITE, &hKey);

	if ( dwError == ERROR_SUCCESS )
	{
		RegDeleteValue( hKey, REGDBVER );
		RegCloseKey(hKey) ;
	}


ErrExit:
	return hr;
}

//*****************************************************************************
// Get the latest version of REGDB file
//*****************************************************************************
HRESULT _GetLatestVersion( LPCTSTR szRegDir, __int64 * pVersion )
{
	WIN32_FIND_DATA FileData;			// For each found file.
	HANDLE			hFind=INVALID_HANDLE_VALUE;				// Find handle.
	TCHAR			rcRegDir[_MAX_PATH];	// Location of registration databases.
	DWORD			dwError=0;				// System error.
	__int64			iVersion=0;
	__int64			iLatest=0;
	HRESULT			hr = S_OK;
	HANDLE	hProcessMem = NULL;
	REGISTRATION_PROCESS *pRegProcess = NULL;
	SYSTEM_INFO	sInfo;					// Info on this system.

	*pVersion = 0;

	hProcessMem = OpenFileMappingA(FILE_MAP_READ, true, 
								  REGISTRATION_TABLE_NAME);

	if ( hProcessMem )
	{
		GetSystemInfo(&sInfo);
		pRegProcess = (REGISTRATION_PROCESS *) MapViewOfFile(
												hProcessMem,
												FILE_MAP_READ,
												0,
												0,
												sInfo.dwPageSize);

		if ( pRegProcess )
		{
			if ( GetTickCount() - pRegProcess->dwLastLive < SHAREDMEMORY_STALE_CHECK )
				*pVersion = pRegProcess->LatestVersion;
			UnmapViewOfFile(pRegProcess);
		}
		
		CloseHandle( hProcessMem );
	}

	if ( *pVersion > 0 )
		goto ErrExit;
		
	_tcscpy(rcRegDir, szRegDir);
	_tcscat(rcRegDir, _T("\\R????????????.clb"));

	hFind = FindFirstFile(rcRegDir, &FileData);
	if (hFind == INVALID_HANDLE_VALUE)
	{
		// Get error code.
		hr = HRESULT_FROM_WIN32(GetLastError());
		goto ErrExit;
	}

		
	do
	{
		// Check for working file and skip.
		if (_tcsicmp(SZWORKING_NAME, FileData.cFileName) == 0)
			continue;

		// Parse off the version number of this file.
		_stscanf(FileData.cFileName, _T("R%012I64x.clb"),&iVersion);	
		__int64 diff = iVersion - iLatest;
		if ((diff > 0 && diff < MAX_VERSION_NUMBER/2) || diff < -MAX_VERSION_NUMBER/2 || iLatest == 0 )
			iLatest = iVersion;
	}while (FindNextFile(hFind, &FileData));

	*pVersion = iLatest;

ErrExit:
	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);
	
	return hr;
}

//*****************************************************************************
// Get the path name of registration directory
//*****************************************************************************
BOOL _GetRegistrationDirectory( LPTSTR szRegDir )
{
	ULONG	uiSize	= 0;	 // Size of the Windows Directory
	uiSize = InternalGetSystemWindowsDirectory(szRegDir, _MAX_PATH);
	if ( uiSize == 0 || uiSize >=  _MAX_PATH )
		return FALSE;
	
	
	LPTSTR	ptszCurPos	= NULL;
	ptszCurPos = szRegDir;

	while (*ptszCurPos != '\0')
	{
		ptszCurPos ++;
	}

	ptszCurPos --;
	if (*ptszCurPos == '\\')
	{
		// If we had a back slash we remove it.
		*ptszCurPos = '\0';
	}

	_tcscat( szRegDir, SZREGDIR_NAME );

	return TRUE;
} 

//******************************************************************************
// Get %windir%. Use GetSystemWindowsDirectory to fix the bug on Terminal Server 
//******************************************************************************
UINT InternalGetSystemWindowsDirectory(LPTSTR lpBuffer, UINT uSize)
{
    HINSTANCE hLib = NULL;
    UINT (CALLBACK *lpfGetSystemWindowsDirectory)(LPTSTR lpBuffer, UINT uSize) = NULL;
    UINT nRetVal;

    if(!lpBuffer) return 0;

    *lpBuffer = '\0';
    
    hLib = LoadLibrary(_T("kernel32.dll")); 

    if(hLib){

        lpfGetSystemWindowsDirectory = (UINT(CALLBACK*)(LPTSTR,UINT))
            #if defined UNICODE || defined _UNICODE
            GetProcAddress(hLib, "GetSystemWindowsDirectoryW");
            #else
            GetProcAddress(hLib, "GetSystemWindowsDirectoryA");
            #endif

        if(lpfGetSystemWindowsDirectory){

            nRetVal = (*lpfGetSystemWindowsDirectory)(lpBuffer, uSize);
            FreeLibrary(hLib);
            return nRetVal;
        }

    }
    if(hLib) FreeLibrary(hLib);
    return GetWindowsDirectory(lpBuffer, uSize);
} 

//*******************************************************************************
// Set latest version number to shared memory control block
//*******************************************************************************
HRESULT SetLatestVersion( __int64 i64Version )
{
	HANDLE	hProcessMem = NULL;
	REGISTRATION_PROCESS *pRegProcess = NULL;
	SYSTEM_INFO	sInfo;			
	HRESULT hr = S_OK;

	hProcessMem = OpenFileMappingA(FILE_MAP_ALL_ACCESS, true, 
								  REGISTRATION_TABLE_NAME);

	if ( hProcessMem )
	{
		GetSystemInfo(&sInfo);
		pRegProcess = (REGISTRATION_PROCESS *) MapViewOfFile(
												hProcessMem,
												FILE_MAP_ALL_ACCESS,
												0,
												0,
												sInfo.dwPageSize);

		if ( pRegProcess )
		{	
			pRegProcess->LatestVersion = i64Version;
			pRegProcess->dwLastLive = GetTickCount();
			UnmapViewOfFile(pRegProcess);
		}
		else
			hr = HRESULT_FROM_WIN32(GetLastError());	
		
		CloseHandle( hProcessMem );
	}

	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\metabase_xmltable.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
//  SDTxml.cpp : Implementation of Metabase_XMLtable

//  This is a read/write data table that comes from an XML document.

#ifndef __METABASE_XMLTABLE_H__
    #include "Metabase_XMLtable.h"
#endif

#define USE_NONCRTNEW
#define USE_ADMINASSERT
#ifndef _CATALOGMACROS
    #include "catmacros.h"
#endif
#ifndef __catalog_h__
    #include "catalog.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __HASH_H__
    #include "Hash.h"
#endif
#ifndef __STRINGROUTINES_H__
    #include "StringRoutines.h"
#endif
#ifndef __TABLEINFO_H__
    #include "catmeta.h"
#endif

#include "SvcMsg.h"

#define LOG_WARNING1(x, str1)                   {if(m_cEventsReported<m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, x, str1,                   eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion, m_MinorVersion));} \
                                                                                                          else{LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, IDS_METABASE_TOO_MANY_WARNINGS, m_wszURLPath, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion, m_MinorVersion));}}
#define LOG_WARNING2(x, str1, str2)             {if(m_cEventsReported<m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, x, str1, str2,             eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion, m_MinorVersion));} \
                                                                                                          else{LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, IDS_METABASE_TOO_MANY_WARNINGS, m_wszURLPath, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion, m_MinorVersion));}}
#define LOG_WARNING3(x, str1, str2, str3)       {if(m_cEventsReported<m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, x, str1, str2, str3,       eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion, m_MinorVersion));} \
                                                                                                          else{LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, IDS_METABASE_TOO_MANY_WARNINGS, m_wszURLPath, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion, m_MinorVersion));}}
#define LOG_WARNING4(x, str1, str2, str3, str4) {if(m_cEventsReported<m_kMaxEventReported){m_cEventsReported++;LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, x, str1, str2, str3, str4, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion, m_MinorVersion));} \
                                                                                                          else{LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_SDTXML_LOGICAL_ERROR_IN_XML, ID_CAT_CAT, IDS_METABASE_TOO_MANY_WARNINGS, m_wszURLPath, eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_WARNING, 0, 0, m_MajorVersion, m_MinorVersion));}}

#define LOG_ERROR1(x, hr, str1)                 LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, hr, ID_CAT_CAT, x, str1,                   eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_ERROR,   0, 0, m_MajorVersion, m_MinorVersion))
#define S_IGNORE_THIS_PROPERTY                  S_FALSE

extern HMODULE g_hModule;

const VARIANT_BOOL  TMetabase_XMLtable::kvboolTrue              = -1;
const VARIANT_BOOL  TMetabase_XMLtable::kvboolFalse             =  0;
      ULONG         TMetabase_XMLtable::m_kLocationID           =  9989;
      ULONG         TMetabase_XMLtable::m_kZero                 =  0;
      ULONG         TMetabase_XMLtable::m_kOne                  =  1;
      ULONG         TMetabase_XMLtable::m_kTwo                  =  2;
      ULONG         TMetabase_XMLtable::m_kThree                =  3;
      ULONG         TMetabase_XMLtable::m_kSTRING_METADATA      =  eCOLUMNMETA_STRING_METADATA;
      ULONG         TMetabase_XMLtable::m_kMBProperty_Custom    = eMBProperty_Custom;
const WCHAR *       TMetabase_XMLtable::m_kwszBoolStrings[]     = {L"false", L"true", L"0", L"1", L"no", L"yes", L"off", L"on", 0};
      WCHAR         TMetabase_XMLtable::m_kKeyType[]            = L"KeyType";
      LONG          TMetabase_XMLtable::m_LocationID            = 0;

/////////////////////////////////////////////////////////////////////////////
// TMetabase_XMLtable
// Constructor and destructor
// ==================================================================
TMetabase_XMLtable::TMetabase_XMLtable() :    
                m_bEnumPublicRowName_NotContainedTable_ParentFound(false)
                ,m_bFirstPropertyOfThisLocationBeingAdded(true)
                ,m_bIISConfigObjectWithNoCustomProperties(false)
                ,m_bQueriedLocationFound(false)
                ,m_bUseIndexMapping(true)//Always map the indexes
                ,m_bValidating(true)
                ,m_cCacheHit(0)
                ,m_cCacheMiss(0)
                ,m_cEventsReported(0)
                ,m_cLocations(0)
                ,m_cMaxProertiesWithinALocation(0x20)
                ,m_cRef(0)
                ,m_cRows(0)
                ,m_dwGroupRemembered(-1)
                ,m_fCache(0)
                ,m_fLOS(0)
                ,m_iCollectionCommentRow(-1)
                ,m_iKeyTypeRow(-1)
                ,m_iPreviousLocation(-1)
                ,m_IsIntercepted(0)
                ,m_kPrime(97)
                ,m_kXMLSchemaName(L"ComCatMeta_v6")
                ,m_MajorVersion(-1)
                ,m_MinorVersion(-1)
                ,m_pISTDisp(0)
{
    m_wszURLPath[0] = 0x00;
    memset(m_acolmetas                  , 0x00, sizeof(m_acolmetas                  ));
    memset(m_aLevelOfColumnAttribute    , 0x00, sizeof(m_aLevelOfColumnAttribute    ));
    memset(m_aStatus                    , 0x00, sizeof(m_aStatus                    ));
    memset(m_aSize                      , 0x00, sizeof(m_aSize                      ));
    memset(m_awszColumnName             , 0x00, sizeof(m_awszColumnName             ));
    memset(m_acchColumnName             , 0x00, sizeof(m_acchColumnName             ));

    m_aiColumnMeta_IndexBySearch[0]    = iCOLUMNMETA_Table;
    m_aiColumnMeta_IndexBySearch[1]    = iCOLUMNMETA_InternalName;

    m_aiColumnMeta_IndexBySearchID[0]  = iCOLUMNMETA_Table;
    m_aiColumnMeta_IndexBySearchID[1]  = iCOLUMNMETA_ID;

    m_aiTagMeta_IndexBySearch[0]       = iTAGMETA_Table;
    m_aiTagMeta_IndexBySearch[1]       = iTAGMETA_InternalName;
}

// ==================================================================
TMetabase_XMLtable::~TMetabase_XMLtable()
{
    if(m_spMetabaseSchemaCompiler.p && m_saSchemaBinFileName.m_p)
        m_spMetabaseSchemaCompiler->ReleaseBinFileName(m_saSchemaBinFileName);
}


void TMetabase_XMLtable::AddPropertyToLocationMapping(LPCWSTR i_Location, ULONG i_iFastCacheRow)//can throw HRESULT
{
    //Is this the same location we just saw
    if(!m_bFirstPropertyOfThisLocationBeingAdded && m_cLocations > 0)
    {   //if it's not the first property, then the previous location should match
        ASSERT(0 == StringInsensitiveCompare(m_LocationMapping[m_iPreviousLocation].m_wszLocation, i_Location));
        ++m_LocationMapping[m_iPreviousLocation].m_cRows;
        if(m_LocationMapping[m_iPreviousLocation].m_cRows > m_cMaxProertiesWithinALocation)
            m_cMaxProertiesWithinALocation = m_LocationMapping[m_iPreviousLocation].m_cRows;//track the larest property count
    }
    else
    {   //If not we have a new location to add to the LocationMapping array
        TLocation   locationTemp(i_Location, i_iFastCacheRow);

        //Usually a new location means adding it to the end since the Metabase is already sorted
        if(0 == m_cLocations)
        {
            m_LocationMapping.append(locationTemp);//can throw HRESULT (E_OUTOFMEMORY)
            m_iPreviousLocation = m_cLocations;
        }
        else
        {   //Does this new location go at the end?  Usually it does.
#ifdef UNSORTED_METABASE
            if(true)
#else
            if(locationTemp > m_LocationMapping[m_cLocations-1])
#endif
            {
                m_LocationMapping.append(locationTemp);
                m_iPreviousLocation = m_cLocations;
            }
            else
            {   //But if, for some reason, the XML file is not properly sorted then we need to determine where in the list this element belongs.  So we do a binary search.
                TRACE2(L"Location %s is out of order.  The previous location was %s\r\n", locationTemp.m_wszLocation, m_LocationMapping[m_iPreviousLocation].m_wszLocation);

                m_LocationMapping.insertAt(m_iPreviousLocation = m_LocationMapping.binarySearch(locationTemp), locationTemp);
                m_bUseIndexMapping = true;//The first time we have to insert a location into middle (instead of just appending) we know we'll have to build a set of row indexes
            }
        }
        ++m_cLocations;
#ifdef VERBOSE_DEBUGOUTPUT
		if(pfnIsDebuggerPresent && pfnIsDebuggerPresent())
		{
            TRACE2(L"iFastCache       cRows    wszLocation\r\n");
            for(ULONG i=0;i<m_cLocations;++i)
            {
                TRACE2(L"  %8d    %8d    %s\r\n", m_LocationMapping[i].m_iFastCache, m_LocationMapping[i].m_cRows, m_LocationMapping[i].m_wszLocation); 
            }
        }
#endif
    }
}


HRESULT TMetabase_XMLtable::FillInColumn(ULONG iColumn, LPCWSTR pwcText, ULONG ulLen, ULONG dbType, ULONG MetaFlags, bool bSecure)
{
    HRESULT hr;

    //length of 0 on a string means a 0 length string, for every other type it means NULL
	if(0==ulLen && DBTYPE_WSTR!=GetColumnMetaType(dbType) && DBTYPE_BYTES!=GetColumnMetaType(dbType))//In the case of BYTES, we fall through so we might recursively call FillInColumn again
	{
        m_aSize[iColumn] = 0;
        m_apColumnValue[iColumn] = 0;
		return S_OK;
	}

    if(bSecure)          //GetColumnValue will realloc the GrowableBuffer if necessary
        return GetColumnValue_Bytes(iColumn, pwcText, ulLen);

    switch(GetColumnMetaType(dbType))
    {
    case DBTYPE_UI4:
        if(MetaFlags & fCOLUMNMETA_BOOL)
            return GetColumnValue_Bool(iColumn, pwcText, ulLen);
        else
            return GetColumnValue_UI4(iColumn, pwcText, ulLen);
    case DBTYPE_WSTR:
        if(MetaFlags & fCOLUMNMETA_MULTISTRING || eMBProperty_MULTISZ==dbType)
            return GetColumnValue_MultiSZ(iColumn, pwcText, ulLen);
        else
            return GetColumnValue_String(iColumn, pwcText, ulLen);
    case DBTYPE_GUID:
        {
            ASSERT(false && "There are no GUIDs in the Metabase!!  So what's going on here?");
            return E_FAIL;
        }

    case DBTYPE_BYTES:
        {//Some of the tables use this data type but the parser returns the BYTES as a string.  We'll have to convert the string to hex ourselves.
            if(iMBProperty_Value == iColumn && m_apColumnValue[iMBProperty_Type] && DBTYPE_BYTES != GetColumnMetaType(*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type])))
            {   //We know we've already found the Type column because we sorted them in InternalComplicatedInitialize
                //So we override the type and recursively call this function.
                return FillInColumn(iColumn, pwcText, ulLen, *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]), MetaFlags);
            }

            return GetColumnValue_Bytes(iColumn, pwcText, ulLen);
        }
    default:
        {
            ASSERT(false && "SDTXML - An Unsupported data type was specified\r\n");
            return E_SDTXML_NOTSUPPORTED;//An Unsupported data type was specified
        }
    }
    return S_OK;
}


HRESULT TMetabase_XMLtable::GetMetaTable(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, CComPtr<ISimpleTableRead2> &pMetaTable) const
{
    STQueryCell         qcellMeta[2];                  // Query cell for grabbing meta table.
    qcellMeta[0].pData     = (LPVOID)m_saSchemaBinFileName.m_p;
    qcellMeta[0].eOperator = eST_OP_EQUAL;
    qcellMeta[0].iCell     = iST_CELL_FILE;
    qcellMeta[0].dbType    = DBTYPE_WSTR;
    qcellMeta[0].cbSize    = 0;

    qcellMeta[1].pData     = (LPVOID)i_wszTable;
    qcellMeta[1].eOperator = eST_OP_EQUAL;
    qcellMeta[1].iCell     = iCOLUMNMETA_Table;
    qcellMeta[1].dbType    = DBTYPE_WSTR;
    qcellMeta[1].cbSize    = 0;

// Obtain our dispenser
#ifdef XML_WIRING
    CComPtr<ISimpleDataTableDispenser>     pSimpleDataTableDispenser;      // Dispenser for the Meta Table

    HRESULT hr;
    if(FAILED(hr = CoCreateInstance(clsidSDTXML, 0, CLSCTX_INPROC_SERVER, IID_ISimpleDataTableDispenser,  reinterpret_cast<void **>(&pSimpleDataTableDispenser))))
        return hr;

    return pSimpleDataTableDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qcellMeta, (LPVOID)&m_kTwo,
                        eST_QUERYFORMAT_CELLS, 0, 0, (LPVOID*) &pMetaTable);
#else
    return ((IAdvancedTableDispenser *)m_pISTDisp.p)->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qcellMeta, (LPVOID)&m_kTwo, eST_QUERYFORMAT_CELLS, 0, (LPVOID*) &pMetaTable);

#endif
}

//We take either a metabase type, or a columnmeta type and return the appropriate columnmeta type.
ULONG TMetabase_XMLtable::GetColumnMetaType(ULONG type) const
{
    if(type <= eMBProperty_MULTISZ)
    {
        ASSERT(0 != type);

        static ULONG TypeMapping[eMBProperty_MULTISZ+1]={0,eCOLUMNMETA_UI4,eCOLUMNMETA_WSTR,eCOLUMNMETA_BYTES,eCOLUMNMETA_WSTR,eCOLUMNMETA_WSTR};
        return TypeMapping[type];
    }
    return type;
}

//The following GetColumnValue_xxx functions, take the wszAttr and convert it to the appropriate type.  The results are placed
//into the column's Growable buffer; and the array pointer m_apColumnValue is set to point to the GrowableBuffer.  Also the size
//of the result (which is NOT the same as the size of the GrowableBuffer) is placed into the m_aSize array.
//
//WARNING!!! These functions should be called by FillInColumn ONLY.  Do NOT call these directly.  FillInColumn handles the NULL
//cases.
HRESULT TMetabase_XMLtable::GetColumnValue_Bool(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;
        return S_OK;
    }

    HRESULT hr;

    ASSERT(m_aGrowableBuffer[i_iColumn].Size()>=sizeof(ULONG));
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;
    m_aSize[i_iColumn] = sizeof(ULONG);

    if((wszAttr[0]>=L'0' && wszAttr[0]<=L'9') || (wszAttr[0]<=L'-'))//accept a numeric value for bools
    {
    	*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = static_cast<unsigned long>(wcstoul(wszAttr, 0, 10));
        return S_OK;
    }

    unsigned long iBoolString;
    if(i_Len)
    {
        for(iBoolString=0; m_kwszBoolStrings[iBoolString] &&
            (0 != _memicmp(m_kwszBoolStrings[iBoolString], wszAttr, i_Len*sizeof(WCHAR))); ++iBoolString);
    }
    else
    {
        for(iBoolString=0; m_kwszBoolStrings[iBoolString] &&
            (0 != StringInsensitiveCompare(m_kwszBoolStrings[iBoolString], wszAttr)); ++iBoolString);
    }

    if(0 == m_kwszBoolStrings[iBoolString])
    {
        TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
		if (wszTemp == 0)
			return E_OUTOFMEMORY;

        memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
        wszTemp[i_Len]=0x00;//NULL terminate it

        LOG_WARNING1(IDS_COMCAT_XML_ILLEGAL_BOOL_VALUE, wszTemp);
        return S_IGNORE_THIS_PROPERTY;
    }

    *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = (iBoolString & 0x01);

    return S_OK;
}


HRESULT TMetabase_XMLtable::GetColumnValue_Bytes(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    HRESULT     hr;

    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;
        return S_OK;
    }

    //If someone has an odd number of characters in this attribute then the odd one will be ignored
    if(i_Len & 1)
    {
        TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
		if (wszTemp == 0)
			return E_OUTOFMEMORY;

        memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
        wszTemp[i_Len]=0x00;//NULL terminate it

        LOG_WARNING1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_ODD_NUMBER_OF_CHARACTERS, wszTemp);
        return S_IGNORE_THIS_PROPERTY;
    }

    m_aSize[i_iColumn] = i_Len/sizeof(WCHAR);// L"FF" is 2 characters, so i_Len needs to be divisible by sizeof(WCHAR)

    if(0 == m_aSize[i_iColumn])//Special case "" so it's NULL
    {
        m_apColumnValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;
        return S_OK;
    }

    m_aGrowableBuffer[i_iColumn].Grow(m_aSize[i_iColumn]);
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;

    if(FAILED(hr = StringToByteArray(wszAttr, reinterpret_cast<unsigned char *>(m_apColumnValue[i_iColumn]), i_Len)))
    {
        TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
		if (wszTemp == 0)
			return E_OUTOFMEMORY;

        memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
        wszTemp[i_Len]=0x00;//NULL terminate it

        LOG_WARNING1(IDS_COMCAT_XML_BINARY_STRING_CONTAINS_A_NON_HEX_CHARACTER, wszTemp);
        return S_IGNORE_THIS_PROPERTY;
    }

    return S_OK;
}

//See comment above GetColumnValue_Bytes
HRESULT TMetabase_XMLtable::GetColumnValue_MultiSZ(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = &m_kZero;
        m_aSize[i_iColumn] = 2*sizeof(WCHAR);//Double NULLs
        return S_OK;
    }

	//We know that i_Len+2 is enough space because the MULTISZ representation is always shorter than the '|' or '\n' delimited form (with the exception of the double NULL)
    m_aGrowableBuffer[i_iColumn].Grow((i_Len+2) * sizeof(WCHAR));//i_Len does NOT include the terminating NULL, and we need 2 NULLs for a MultiSZ
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;

    LPWSTR pMultiSZ = reinterpret_cast<LPWSTR>(m_apColumnValue[i_iColumn]);
    ULONG  cChars = 0;

	//Scan the string for the '\n' character.  This is the MultiSZ delimiter.  Then walk backwards to the first non white space.  This is the end of the string.
	//Now move back up to the '\n' and ignore the white spaces.
	bool bIgnoringLeadingWhiteSpaces=true;
	bool bIgnoringDelimiters=false;//this is set to true after we've seen a delimiter since we don't want to treat two "\n" as two separate delimiters.
	for(ULONG iMultiSZ=0; iMultiSZ<i_Len; ++iMultiSZ)
	{
		switch(wszAttr[iMultiSZ])
		{
		case L'\n':
		case L'\r':
			if(bIgnoringDelimiters)
				break;
			while(--pMultiSZ > reinterpret_cast<LPWSTR>(m_apColumnValue[i_iColumn]))
			{
				if(*pMultiSZ != L' ' && *pMultiSZ != L'\t')
					break;
			}
			++pMultiSZ;
			*pMultiSZ++ = 0x00;
			bIgnoringLeadingWhiteSpaces = true;
            bIgnoringDelimiters = true;
			break;
		case L' ':
		case L'\t':
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			if(!bIgnoringLeadingWhiteSpaces)
				*pMultiSZ++ = wszAttr[iMultiSZ];
			break;
        case 0xD836:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
            *pMultiSZ = wszAttr[++iMultiSZ] & 0xFBFF;break;
        case 0xD837:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
            *pMultiSZ = wszAttr[++iMultiSZ];
            break;
        case 0xD83F:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
            *pMultiSZ = wszAttr[++iMultiSZ] | 0x2000;break;
        case 0xD800:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
            *pMultiSZ = wszAttr[++iMultiSZ] - 0xDC00;break;
		default:
			bIgnoringDelimiters = false;//once we've found a non delimiter we can chage state
			bIgnoringLeadingWhiteSpaces = false;//we've found a nonwhitespace, so any whitespaces following are part of the string.
			*pMultiSZ++ = wszAttr[iMultiSZ];
			break;
		}
	}
    *pMultiSZ++ = 0x00;
    *pMultiSZ++ = 0x00;

    m_aSize[i_iColumn] = (ULONG)((reinterpret_cast<unsigned char *>(pMultiSZ) - reinterpret_cast<unsigned char *>(m_apColumnValue[i_iColumn])));
    return S_OK;
}


//See comment above GetColumnValue_Bytes
HRESULT TMetabase_XMLtable::GetColumnValue_String(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = &m_kZero;
        m_aSize[i_iColumn] = sizeof(WCHAR);
        return S_OK;
    }

    m_aGrowableBuffer[i_iColumn].Grow((i_Len + 1) * sizeof(WCHAR));//ulLen does NOT include the terminating NULL
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;

    WCHAR *pDest = reinterpret_cast<WCHAR *>(m_aGrowableBuffer[i_iColumn].m_p);
    for(; i_Len; ++wszAttr, --i_Len, ++pDest)
    {
        if((*wszAttr & 0xD800) == 0xD800)
        {
            switch(*wszAttr) 
            {
            case 0xD836:
                *pDest = *(++wszAttr) & 0xFBFF;
                --i_Len;
                break;
            case 0xD837:
                *pDest = *(++wszAttr);
                --i_Len;
                break;
            case 0xD83F:
                *pDest = *(++wszAttr) | 0x2000;
                --i_Len;
                break;
            case 0xD800:
                *pDest = *(++wszAttr) - 0xDC00;
                --i_Len;
                break;
            default:
                *pDest = *wszAttr;             break;//No special escaping was done
            }
        }
        else
        {
            *pDest = *wszAttr;//No special escaping was done
        }
    }
    *pDest++ = 0x00;//NULL terminate it
    m_aSize[i_iColumn] = static_cast<ULONG>(reinterpret_cast<char *>(pDest) - reinterpret_cast<char *>(m_apColumnValue[i_iColumn]));
    return S_OK;
}


//See comment above GetColumnValue_Bytes
HRESULT TMetabase_XMLtable::GetColumnValue_UI4(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len)
{
    if(0==wszAttr || 0==i_Len)
    {
        m_apColumnValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;
        return S_OK;
    }

    HRESULT hr;

    ASSERT(m_aGrowableBuffer[i_iColumn].Size()>=sizeof(ULONG));
    m_apColumnValue[i_iColumn] = m_aGrowableBuffer[i_iColumn].m_p;
    m_aSize[i_iColumn] = sizeof(ULONG);

    if(i_iColumn == iMBProperty_Value)//Value column is NOT described by m_acolmetas.  A DWORD Value will either be interpreted by a number or string flags
    {
        if((wszAttr[0]>=L'0' && wszAttr[0]<=L'9') || (wszAttr[0]<=L'-'))
    		*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = static_cast<unsigned long>(wcstoul(wszAttr, 0, 10));
        else
        {
            TSmartPointerArray<WCHAR> szAttr = new WCHAR [i_Len+1];
            if(0 == szAttr.m_p)
                return E_OUTOFMEMORY;
            memcpy(szAttr, wszAttr, i_Len*sizeof(WCHAR));
            szAttr[i_Len] = 0x00;//NULL terminate the flag string
            LPWSTR wszTag = wcstok(szAttr, L" ,|\n\t\r");

            *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = 0;//flags start as zero

            m_TagMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//setup the first part of the Search
            ULONG iRowTagMeta;
            
            //NOTE!!! There is a hole here.  It is possible (but illegal in the metabase) to have two Tag with the same name but different values.
            //We are looking up tags by name, so if there is a conflict we won't know about it.  We would need to look up by column index as well,
            //thus a full PK lookup.
		    while(wszTag)
		    {
                m_TagMeta_IndexBySearch_Values.pInternalName = wszTag;
                if(FAILED(hr = m_pTagMeta_IISConfigObject->GetRowIndexBySearch(0, ciTagMeta_IndexBySearch, m_aiTagMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_TagMeta_IndexBySearch_Values), &iRowTagMeta)))
                {
                    //FLAG_xx where xx is a value between 00 and 31
                    //Note: FLAG_32 thru FLAG_39 will be considered legal; but have a value of 0 (since 1<<32 is zero)
                    if(0 == wcsncmp(wszTag, L"FLAG_", 5) && wszTag[5]>=L'0' && wszTag[5]<=L'3' && wszTag[6]>=L'0' && wszTag[6]<=L'9' &&  wszTag[7]==0x00)
                    {
        				*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) |= 1<<static_cast<unsigned long>(wcstoul(wszTag+5, 0, 10));
                    }
                    else
                    {
                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, wszAttr, 0xFF);//copy up to 0xFF characters
                        wszOffendingXml[0xFF]=0x00;

                        LOG_WARNING2(IDS_COMCAT_XML_ILLEGAL_FLAG_VALUE, wszTag, wszOffendingXml);
                        return S_IGNORE_THIS_PROPERTY;
                    }
                }
                else
                {
                    ULONG * pValue;
                    ULONG   iValueColumn = iTAGMETA_Value;
                    if(FAILED(hr = m_pTagMeta_IISConfigObject->GetColumnValues(iRowTagMeta, 1, &iValueColumn, 0, reinterpret_cast<void **>(&pValue))))
                        return hr;

    				*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) |= *pValue;
                }
                wszTag = wcstok(NULL, L" ,|\n\t\r");//next flag
		    }
        }
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_BOOL)
    {
        unsigned long iBoolString;
        if(i_Len)
        {
            for(iBoolString=0; m_kwszBoolStrings[iBoolString] &&
                (0 != _memicmp(m_kwszBoolStrings[iBoolString], wszAttr, i_Len*sizeof(WCHAR))); ++iBoolString);
        }
        else
        {
            for(iBoolString=0; m_kwszBoolStrings[iBoolString] &&
                (0 != StringInsensitiveCompare(m_kwszBoolStrings[iBoolString], wszAttr)); ++iBoolString);
        }

        if(0 == m_kwszBoolStrings[iBoolString])
        {
            TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
			if (wszTemp == 0)
				return E_OUTOFMEMORY;

            memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
            wszTemp[i_Len]=0x00;//NULL terminate it

            LOG_WARNING1(IDS_COMCAT_XML_ILLEGAL_BOOL_VALUE, wszTemp);
            return S_IGNORE_THIS_PROPERTY;
        }

        *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = (iBoolString & 0x01);
    }
	else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_ENUM  && !IsNumber(wszAttr, i_Len))
	{       //If the first and last characters are numeric, then treat as a regular ui4
		ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.

		for(unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta, cTag = m_aTagMetaIndex[i_iColumn].m_cTagMeta; cTag;++iTag, --cTag)//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
		{
			ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
            if(i_Len)
            {
			    if(0 == _memicmp(m_aTagMetaRow[iTag].pPublicName, wszAttr, i_Len*sizeof(WCHAR)) && i_Len==wcslen(m_aTagMetaRow[iTag].pPublicName))
			    {
				    *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = *m_aTagMetaRow[iTag].pValue;
				    return S_OK;
			    }
            }
            else
            {
			    if(0 == StringInsensitiveCompare(m_aTagMetaRow[iTag].pPublicName, wszAttr))
			    {
				    *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = *m_aTagMetaRow[iTag].pValue;
				    return S_OK;
			    }
            }
		}
        {
            TSmartPointerArray<WCHAR> wszTemp = new WCHAR [i_Len+1];
			if (wszTemp == 0)
				return E_OUTOFMEMORY;

            memcpy(wszTemp, wszAttr, i_Len*sizeof(WCHAR));
            wszTemp[i_Len]=0x00;//NULL terminate it

            LOG_WARNING1(IDS_COMCAT_XML_ILLEGAL_ENUM_VALUE, wszTemp);
            return S_IGNORE_THIS_PROPERTY;
        }
        return E_ST_VALUEINVALID;
	}
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_FLAG  && (wszAttr[0]<L'0' || wszAttr[0]>L'9') && wszAttr[0]!=L'-')//If the first character is a numeric, then treat as a regular ui4
    {
		ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.

        TSmartPointerArray<WCHAR> szAttr = new WCHAR [i_Len+1];
        if(0 == szAttr.m_p)
            return E_OUTOFMEMORY;
        memcpy(szAttr, wszAttr, i_Len*sizeof(WCHAR));
        szAttr[i_Len]=0x00;//NULL terminate it
        LPWSTR wszTag = wcstok(szAttr, L" ,|\n\t\r");

        *reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = 0;//flags start as zero
        unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;

		while(wszTag && iTag<(m_aTagMetaIndex[i_iColumn].m_iTagMeta + m_aTagMetaIndex[i_iColumn].m_cTagMeta))//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
		{
			ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
			if(0 == StringInsensitiveCompare(m_aTagMetaRow[iTag].pPublicName, wszTag))
			{
				*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) |= *m_aTagMetaRow[iTag].pValue;
                wszTag = wcstok(NULL, L" ,|\n\t\r");//next flag
                iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;//reset the loop
			}
            else//if they're not equal then move on to the next TagMeta
                ++iTag;
		}
        if(wszTag)
        {
            WCHAR wszOffendingXml[0x100];
            wcsncpy(wszOffendingXml, wszAttr, 0xFF);//copy up to 0xFF characters
            wszOffendingXml[0xFF]=0x00;

            LOG_WARNING2(IDS_COMCAT_XML_ILLEGAL_FLAG_VALUE, wszTag, wszOffendingXml);
            return S_IGNORE_THIS_PROPERTY;
        }
    }
	else
    {
        //TODO: We could do better validation of the UI4 value to verify that there are no alpha chars.  wcstoul weill return zero if wszAttr==L"xyz".
        //TODO: Also we could support hex, binary, octal.
        LPCWSTR pAttr=wszAttr;
        for(;i_Len>0 && *pAttr;--i_Len, ++pAttr)
        {
            if((*pAttr<L'0' || *pAttr>L'9') && *pAttr!=L'-')//we don't tolerate white spaces; but we do accept negative sign
            {
                WCHAR wszOffendingXml[0x100];
                wcsncpy(wszOffendingXml, wszAttr, 0xFF);//copy up to 0xFF characters
                wszOffendingXml[0xFF]=0x00;

                LOG_WARNING1(IDS_COMCAT_XML_ILLEGAL_NUMERIC_VALUE, wszOffendingXml);
                return S_IGNORE_THIS_PROPERTY;
            }
        }
		*reinterpret_cast<ULONG *>(m_apColumnValue[i_iColumn]) = static_cast<unsigned long>(wcstoul(wszAttr, 0, 10));
    }
    return S_OK;
}

bool TMetabase_XMLtable::IsNumber(LPCWSTR i_awch, ULONG i_Len) const
{
    if((*i_awch>=L'0' && *i_awch<=L'9') || *i_awch==L'-')
    {   //if the string is L"-" then it is NOT a number.
        if(1==i_Len && *i_awch==L'-')
            return false;

        //if the first char is a negative sign or a number, then scan the rest
        while(--i_Len)
        {
            ++i_awch;
            if(*i_awch<L'0' || *i_awch>L'9')//if not a numeric then we're done, NOT a number
                return false;
        }
        return true;//we made it through all the chars and they were all numerics, so it IS a number
    }
    return false;
}

//This is a wrapper for InternalSimpleInitialize (thus the name), it just gets the meta information THEN calls InternalSimpleInitialize.
HRESULT TMetabase_XMLtable::InternalComplicatedInitialize()
{
    m_LocationMapping.setSize(0x80);//Lets start with 128 locations.  This size will grow by %50 each time we reach an overflow
    m_LocationMapping.setSize(0);//The Array is still pre allocated at size 0x80; but the current number of elements is set to 0.

    HRESULT hr;

    //Preallocate the growable buffers
    m_aGrowableBuffer[iMBProperty_Name      ].Grow(256);
    m_aGrowableBuffer[iMBProperty_Value     ].Grow(256);
    m_aGrowableBuffer[iMBProperty_Location  ].Grow(256);

    //If the user passed in the Bin filename as part of the query, then we already have this filled in
    if(0 == m_saSchemaBinFileName.m_p)
    {   //if it wasn't passed in as part of the query then get it from the IMetabaseSchemaCompiler
        m_spMetabaseSchemaCompiler = m_pISTDisp;
        if(0 == m_spMetabaseSchemaCompiler.p)
        {
            ASSERT(false && L"Dispenser without a MetabaseSchemaCompiler shouldn't be calling Intercept on the Metabase interceptor");
            return E_FAIL;
        }
        ULONG cchSchemaBinFileName;
        if(FAILED(hr = m_spMetabaseSchemaCompiler->GetBinFileName(0, &cchSchemaBinFileName)))
            return hr;
    
        m_saSchemaBinFileName = new WCHAR [cchSchemaBinFileName];
        if(0 == m_saSchemaBinFileName.m_p)
            return E_OUTOFMEMORY;

        if(FAILED(hr = m_spMetabaseSchemaCompiler->GetBinFileName(m_saSchemaBinFileName, &cchSchemaBinFileName)))
            return hr;
    }


    ULONG   iColumn;
    for(iColumn=0;iColumn<m_kColumns;++iColumn)//The above three columns are sized larger, the rest are set to sizeof(ULONG) to start with
        m_aGrowableBuffer[iColumn].Grow(sizeof(ULONG));

    if(FAILED(hr = ObtainPertinentTableMetaInfo()))return hr;

    m_fCache             |= *m_TableMetaRow.pMetaFlags;

    if(FAILED(hr = GetMetaTable(wszDATABASE_METABASE, wszTABLE_MBProperty, m_pColumnMeta)))return hr;

    tCOLUMNMETARow          ColumnMetaRow;

    for (iColumn = 0;; iColumn++)   
    {
        if(E_ST_NOMOREROWS == (hr = m_pColumnMeta->GetColumnValues(iColumn, cCOLUMNMETA_NumberOfColumns, 0, 0, reinterpret_cast<void **>(&ColumnMetaRow))))// Next row:
        {
            ASSERT(m_kColumns == iColumn);
            if(m_kColumns != iColumn)return E_SDTXML_UNEXPECTED; // Assert expected column count.
            break;
        }
        else
        {
            if(FAILED(hr))
            {
                TRACE2(L"GetColumnValues FAILED with something other than E_ST_NOMOREROWS");
                return hr;
            }
        }

        m_acolmetas[iColumn].dbType = *ColumnMetaRow.pType;
        m_acolmetas[iColumn].cbSize = *ColumnMetaRow.pSize;
        m_acolmetas[iColumn].fMeta  = *ColumnMetaRow.pMetaFlags;

        m_awszColumnName[iColumn]   =  ColumnMetaRow.pPublicColumnName;
        m_acchColumnName[iColumn]   =  (ULONG)wcslen(ColumnMetaRow.pPublicName);

        ASSERT(m_awszColumnName[iColumn]);//CatUtil should have already enforced this
        ASSERT(m_acchColumnName[iColumn]>0);
    }

    //After we have the ColumnMeta info, get the TagMeta
    if(FAILED(hr = ObtainPertinentTagMetaInfo()))return hr;
    if(FAILED(hr = m_aPublicRowName.Init(&m_aTagMetaRow[m_aTagMetaIndex[iMBProperty_Group].m_iTagMeta], m_aTagMetaIndex[iMBProperty_Group].m_cTagMeta)))return hr;

    //We need to make sure that NameValue tables list the Name column before the Type column, and the Type column before the Value column.
    ASSERT(iMBProperty_Name        < iMBProperty_Type); if(iMBProperty_Name      >= iMBProperty_Type) return E_FAIL;
    ASSERT(iMBProperty_Type        < iMBProperty_Value);if(iMBProperty_Type      >= iMBProperty_Value)return E_FAIL; 
    ASSERT(iMBProperty_Attributes  < iMBProperty_Value);if(iMBProperty_Attributes>= iMBProperty_Value)return E_FAIL;

    //Keep around an interface pointer to the NameValueMeta table
    WCHAR wszTableName[1024];

	STQueryCell Query[2];
	Query[0].pData		= (LPVOID)m_saSchemaBinFileName.m_p;
    Query[0].eOperator	= eST_OP_EQUAL;
    Query[0].iCell		= iST_CELL_FILE;
    Query[0].dbType	    = DBTYPE_WSTR;
    Query[0].cbSize	    = 0;

	Query[1].pData		= (void*)L"ByName";
    Query[1].eOperator	= eST_OP_EQUAL;
    Query[1].iCell		= iST_CELL_INDEXHINT;
    Query[1].dbType	    = DBTYPE_WSTR;
    Query[1].cbSize	    = 0;

    return Dispenser()->GetTable(wszDATABASE_META, wszTABLE_COLUMNMETA, &Query, &m_kTwo, eST_QUERYFORMAT_CELLS, 0, reinterpret_cast<void **>(&m_pColumnMetaAll));
}


HRESULT TMetabase_XMLtable::LoadDocumentFromURL(IXMLDOMDocument *pXMLDoc)
{
    HRESULT hr;

    ASSERT(pXMLDoc);

    VERIFY(SUCCEEDED(hr = pXMLDoc->put_async(kvboolFalse)));//We want the parse to be synchronous
    if(FAILED(hr))
        return hr;

    if(FAILED(hr = pXMLDoc->put_resolveExternals(kvboolTrue)))return hr;//we need all of the external references resolved

    VARIANT_BOOL    bSuccess;
    CComVariant     xml(m_wszURLPath);
    if(FAILED(hr = pXMLDoc->load(xml,&bSuccess)))return hr;

    return (bSuccess == kvboolTrue) ? S_OK : E_FAIL;
}


int TMetabase_XMLtable::Memicmp(LPCWSTR i_p0, LPCWSTR i_p1, ULONG i_cby) const
{
    ASSERT(0 == (i_cby & 1) && "Make sure you're passing in Count Of Bytes and not Count of WCHARs");
    i_cby /= 2;

    ULONG i;
    for(i=0; i<i_cby; ++i, ++i_p0, ++i_p1)
    {
        if(ToLower(*i_p0) != ToLower(*i_p1))
            return 1;//not equal
    }
    return 0;//they're equal
}


HRESULT TMetabase_XMLtable::ObtainPertinentTableMetaInfo()
{
    HRESULT hr;

	STQueryCell Query[2];
	Query[0].pData		= (LPVOID)m_saSchemaBinFileName.m_p;
    Query[0].eOperator	= eST_OP_EQUAL;
    Query[0].iCell		= iST_CELL_FILE;
    Query[0].dbType	    = DBTYPE_WSTR;
    Query[0].cbSize	    = 0;

	Query[1].pData		= (void*) wszTABLE_MBProperty;
    Query[1].eOperator	= eST_OP_EQUAL;
    Query[1].iCell		= iTABLEMETA_InternalName;
    Query[1].dbType	    = DBTYPE_WSTR;
    Query[1].cbSize	    = 0;

	if(FAILED(hr = Dispenser()->GetTable(wszDATABASE_META, wszTABLE_TABLEMETA, &Query, &m_kTwo, eST_QUERYFORMAT_CELLS, 0, reinterpret_cast<void**>(&m_pTableMeta))))
		return hr;

	if(FAILED(hr = m_pTableMeta->GetColumnValues(0, cTABLEMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void**>(&m_TableMetaRow))))return hr;

    return S_OK;
}

HRESULT TMetabase_XMLtable::ObtainPertinentTagMetaInfo()
{
    HRESULT hr;

	//Now that we have the ColumnMeta setup, setup the TagMeta
	STQueryCell Query[3];
	Query[1].pData		= (LPVOID)m_saSchemaBinFileName.m_p;
    Query[1].eOperator	= eST_OP_EQUAL;
    Query[1].iCell		= iST_CELL_FILE;
    Query[1].dbType	    = DBTYPE_WSTR;
    Query[1].cbSize	    = 0;

	Query[2].pData		= (void*) wszTABLE_MBProperty;
    Query[2].eOperator	=eST_OP_EQUAL;
    Query[2].iCell		=iTAGMETA_Table;
    Query[2].dbType	=DBTYPE_WSTR;
    Query[2].cbSize	=0;

	//Optain the TagMeta table
	if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_TAGMETA, &Query[1], &m_kTwo, eST_QUERYFORMAT_CELLS, 0, (void**) &m_pTagMeta)))
		return hr;

    ULONG cRows;
    if(FAILED(hr = m_pTagMeta->GetTableMeta(0,0,&cRows,0)))return hr;
    m_aTagMetaRow = new tTAGMETARow[cRows];
    if(0 == m_aTagMetaRow.m_p)return E_OUTOFMEMORY;

// Build tag column indexes:
	ULONG iColumn, iRow;
	for(iRow = 0, iColumn = ~0;iRow<cRows; ++iRow)
	{
		if(FAILED(hr = m_pTagMeta->GetColumnValues (iRow, cTAGMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&m_aTagMetaRow[iRow]))))
            return hr;

		if(iColumn != *m_aTagMetaRow[iRow].pColumnIndex)
		{
			iColumn = *m_aTagMetaRow[iRow].pColumnIndex;
			m_aTagMetaIndex[iColumn].m_iTagMeta = iRow;
		}
        ++m_aTagMetaIndex[iColumn].m_cTagMeta;
	}

    
	Query[2].pData		= (void*) wszTABLE_IIsConfigObject;
	Query[0].pData		= (void*)L"ByTableAndTagNameOnly";
    Query[0].eOperator	=eST_OP_EQUAL;
    Query[0].iCell		=iST_CELL_INDEXHINT;
    Query[0].dbType	    =DBTYPE_WSTR;
    Query[0].cbSize	    =0;

    //Now get the TagMeta for the ISSConfigObject table.  This is where the global tags (for the metabase) are kept.
	if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_TAGMETA, Query, &m_kThree, eST_QUERYFORMAT_CELLS, 0, (void**) &m_pTagMeta_IISConfigObject)))
		return hr;

    return S_OK;
}


HRESULT TMetabase_XMLtable::ParseXMLFile(IXMLDOMDocument *pXMLDoc, bool bValidating)//defaults to validating against the DTD or XML schema
{
    HRESULT hr;

    ASSERT(pXMLDoc);
    
    if(FAILED(hr = pXMLDoc->put_preserveWhiteSpace(kvboolFalse)))
        return hr;
    if(FAILED(hr = pXMLDoc->put_validateOnParse(bValidating ? kvboolTrue : kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
        return hr;

    if(FAILED(LoadDocumentFromURL(pXMLDoc)))
    {   //If the load failed then let's spit out as much information as possible about what went wrong
        CComPtr<IXMLDOMParseError> pXMLParseError;
        long lErrorCode, lFilePosition, lLineNumber, lLinePosition;
        TComBSTR bstrReasonString, bstrSourceString, bstrURLString;     

        if(FAILED(hr = pXMLDoc->get_parseError(&pXMLParseError)))       return hr;
        if(FAILED(hr = pXMLParseError->get_errorCode(&lErrorCode)))     return hr;
        if(FAILED(hr = pXMLParseError->get_filepos(&lFilePosition)))    return hr;
        if(FAILED(hr = pXMLParseError->get_line(&lLineNumber)))         return hr;
        if(FAILED(hr = pXMLParseError->get_linepos(&lLinePosition)))    return hr;
        if(FAILED(hr = pXMLParseError->get_reason(&bstrReasonString)))  return hr;
        if(FAILED(hr = pXMLParseError->get_srcText(&bstrSourceString))) return hr;
        if(FAILED(hr = pXMLParseError->get_url(&bstrURLString)))        return hr;

		if((HRESULT_FROM_WIN32(ERROR_SHARING_VIOLATION) != lErrorCode) &&
		   (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != lErrorCode)    &&
		   (HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) != lErrorCode)
		  )
		{
			LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, lErrorCode, ID_CAT_CAT, IDS_COMCAT_XML_PARSE_ERROR,
							L"\n",
							(bstrReasonString.m_str ? bstrReasonString.m_str : L""),
							(bstrSourceString.m_str ? bstrSourceString.m_str : L""),
							eSERVERWIRINGMETA_Core_MetabaseInterceptor,
							wszTABLE_MBProperty,
							eDETAILEDERRORS_Populate,
							lLineNumber,
							lLinePosition,
							(bstrURLString.m_str ? bstrURLString.m_str : L"")));
		}

        return  E_ST_INVALIDTABLE;
    }
    //Not only does the XML file have to be Valid and Well formed, but its schema must match the one this C++ file was written to.
    return  S_OK;
}


HRESULT TMetabase_XMLtable::SetComment(LPCWSTR i_pComment, ULONG i_Len, bool i_bAppend)
{
    if(0 == m_saCollectionComment.m_p)
    {
        m_cchCommentBufferSize = ((i_Len+1) + 1023) & -1024;//+1 for the NULL, then round up to the nearest 1024 wchars
        m_saCollectionComment = new WCHAR [m_cchCommentBufferSize];
        if(0 == m_saCollectionComment.m_p)
            return E_OUTOFMEMORY;
        m_saCollectionComment[0] = 0x00;//the code below relys on this being initialized to L""
    }

    ULONG cchCurrentCommentSize=0;
    if(i_bAppend)
        cchCurrentCommentSize = (ULONG) wcslen(m_saCollectionComment);

    if(cchCurrentCommentSize + 1 + i_Len > m_cchCommentBufferSize)
    {
        m_cchCommentBufferSize = ((cchCurrentCommentSize + 1 + i_Len) + 1023) & -1024;
        m_saCollectionComment.m_p = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(m_saCollectionComment.m_p, m_cchCommentBufferSize*sizeof(WCHAR)));
        if(0 == m_saCollectionComment.m_p)
            return E_OUTOFMEMORY;
    }
    memcpy(m_saCollectionComment + cchCurrentCommentSize, i_pComment, i_Len * sizeof(WCHAR));
    cchCurrentCommentSize += i_Len;
    m_saCollectionComment[cchCurrentCommentSize] = 0x00;//NULL terminate it

    return S_OK;
}


// ISimpleTableRead2 (ISimpleTableWrite2 : ISimpleTableRead2)
STDMETHODIMP TMetabase_XMLtable::GetRowIndexByIdentity(ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
{
    HRESULT hr;
    if(FAILED(hr = m_SimpleTableWrite2_Memory->GetRowIndexByIdentity(i_acbSizes, i_apvValues, o_piRow)))return hr;
    if(m_bUseIndexMapping)
    {   //If we're mapping the row indexes, then find out which row index corresponds to the one just returned.
        for(ULONG iMappedRow=0;iMappedRow<m_cRows;++iMappedRow)//If this becomes a perf bottleneck we can build another index that maps 
        {                                                      //these indexes in the other direction; but for now we'll do a linear search.
            if(*o_piRow == m_aRowIndex[iMappedRow])
            {
                *o_piRow = iMappedRow;
                return S_OK;
            }
        }
        ASSERT(false && "This shouldn't happen.  All fast cache rows should map to an m_aRowIndex, the only exception is duplicate rows in which the first one should be found.");
        return E_ST_NOMOREROWS;
    }
    return S_OK;
}

// ------------------------------------
// ISimpleTableInterceptor
// ------------------------------------
STDMETHODIMP TMetabase_XMLtable::Intercept(    LPCWSTR i_wszDatabase,  LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat,
                                    DWORD i_fLOS,           IAdvancedTableDispenser* i_pISTDisp,    LPCWSTR /*i_wszLocator unused*/,
                                    LPVOID i_pSimpleTable,  LPVOID* o_ppvSimpleTable)
{
    try
    {
        HRESULT hr;

        //If we've already been called to Intercept, then fail
        if(0 != m_IsIntercepted)return E_UNEXPECTED;

        //Some basic parameter validation:
        if(i_pSimpleTable)return E_INVALIDARG;//We're at the bottom of the Table hierarchy.  A table under us is Chewbacca.  This is NOT a logic table.
        if(0 == i_pISTDisp)return E_INVALIDARG;
        if(0 == o_ppvSimpleTable)return E_INVALIDARG;

        ASSERT(0 == *o_ppvSimpleTable && "This should be NULL.  Possible memory leak or just an uninitialized variable.");
        *o_ppvSimpleTable = 0;

        if(eST_QUERYFORMAT_CELLS != i_eQueryFormat)return E_INVALIDARG;//Verify query type.  
	    // For the CookDown process we have a logic table that sits above this during PopulateCache time.
	    // Hence we should support fST_LOS_READWRITE 
        if((fST_LOS_MARSHALLABLE | fST_LOS_UNPOPULATED | fST_LOS_READWRITE) & i_fLOS)return E_ST_LOSNOTSUPPORTED;//check table flags
        if(0 != _wcsicmp(i_wszDatabase, wszDATABASE_METABASE))return E_ST_INVALIDTABLE;
        if(i_TableID!=TABLEID_MBProperty && (0==i_wszTable || (0 != _wcsicmp(i_wszTable, wszTABLE_MBProperty))))return E_ST_INVALIDTABLE;

        m_fLOS = i_fLOS;//Keep this around.  We use it to determine whether or not to log errors

        //Create this singleton for future use
	    m_pISTDisp = i_pISTDisp; 

        STQueryCell *   pQueryCell  = (STQueryCell*) i_QueryData;    // Query cell array from caller.
        int             nQueryCount = (i_QueryMeta && i_QueryData) ? *reinterpret_cast<ULONG *>(i_QueryMeta) : 0;

        while(nQueryCount--)//Get the only query cell we care about, and save the information.
        {
            if(pQueryCell[nQueryCount].iCell & iST_CELL_SPECIAL)
            {
                if(pQueryCell[nQueryCount].pData     != 0                  &&
                   pQueryCell[nQueryCount].eOperator == eST_OP_EQUAL       &&
                   pQueryCell[nQueryCount].iCell     == iST_CELL_FILE      &&
                   pQueryCell[nQueryCount].dbType    == DBTYPE_WSTR        /*&&
                   pQueryCell[nQueryCount].cbSize    == (wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))+1)*sizeof(WCHAR)*/)
                {
                    if(FAILED(hr = GetURLFromString(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))))
                        return hr;
                }
                else if(pQueryCell[nQueryCount].pData!= 0                   &&
                   pQueryCell[nQueryCount].eOperator == eST_OP_EQUAL        &&
                   pQueryCell[nQueryCount].iCell     == iST_CELL_SCHEMAFILE &&
                   pQueryCell[nQueryCount].dbType    == DBTYPE_WSTR        /*&&
                   pQueryCell[nQueryCount].cbSize    == (wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))+1)*sizeof(WCHAR)*/)
                {
                    m_saSchemaBinFileName = new WCHAR [wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))+1];
                    if(0 == m_saSchemaBinFileName.m_p)
                        return E_OUTOFMEMORY;
                    wcscpy(m_saSchemaBinFileName, reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
                }
            }
            else if(pQueryCell[nQueryCount].iCell == iMBProperty_Location)
            {//we only support querying by Location
                m_saQueriedLocation = new WCHAR [wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))+1];
                if(0 == m_saQueriedLocation.m_p)
                    return E_OUTOFMEMORY;
                wcscpy(m_saQueriedLocation, reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
            }
            else
                return E_ST_INVALIDQUERY;
        }
        if(0x00 == m_wszURLPath[0])//The user must supply a URLPath (which must be a filename for writeable tables).
            return E_SDTXML_FILE_NOT_SPECIFIED;

        //This has nothing to do with InternalSimpleInitialize.  This just gets the meta and saves some of it in a more accessible form.
        //This calls GetTable for the meta.  It should probably call the IST (that we get from GetMemoryTable).
        if(FAILED(hr = InternalComplicatedInitialize()))//This can throw an HRESULT
            return hr;

	// Determine minimum cache size:
		STQueryCell					qcellMinCache;
		ULONG						cbminCache = 1024;
		ULONG						cCells = 1;
		WIN32_FILE_ATTRIBUTE_DATA	filedata;

		qcellMinCache.iCell		= iST_CELL_cbminCACHE;
		qcellMinCache.eOperator	= eST_OP_EQUAL;
		qcellMinCache.dbType	= DBTYPE_UI4;
		qcellMinCache.cbSize	= sizeof (ULONG);


		if (0 != GetFileAttributesEx (m_wszURLPath, GetFileExInfoStandard, &filedata))
		{
			if (filedata.nFileSizeHigh != 0) return E_NOTIMPL; // TODO: verify low size isn't too big either!
			cbminCache = filedata.nFileSizeLow * 2;
		}
		qcellMinCache.pData = &cbminCache;


	// Get the memory table:
																			//Our memory table needs to be Read/Write even if the XML table is Read-Only
        if(FAILED(hr = i_pISTDisp->GetMemoryTable(wszDATABASE_METABASE, wszTABLE_MBProperty, TABLEID_MBProperty, &qcellMinCache, &cCells, i_eQueryFormat, i_fLOS,
                        reinterpret_cast<ISimpleTableWrite2 **>(&m_SimpleTableWrite2_Memory))))return hr;

        m_SimpleTableController_Memory = m_SimpleTableWrite2_Memory;
        ASSERT(0 != m_SimpleTableController_Memory.p);

        *o_ppvSimpleTable = (ISimpleTableWrite2 *)(this);
        AddRef ();
        InterlockedIncrement(&m_IsIntercepted);//We can only be called to Intercept once.
    }
    catch(HRESULT e)
    {
        return e;
    }
	return S_OK;
}


STDMETHODIMP TMetabase_XMLtable::PopulateCache()
{
    try
    {
        HRESULT hr;

	    if (FAILED(hr = PrePopulateCache (0))) return hr;

        if(-1 == GetFileAttributes(m_wszURLPath))//if GetFileAttributes fails then the file does not exist
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);

        hr = m_XmlParsedFile.Parse(*this, m_wszURLPath);
        if(S_OK != hr && E_SDTXML_DONE != hr)
        {
            HRESULT hrNodeFactory = hr;

            CComPtr<IXMLDOMDocument> pXMLDoc;
            if(FAILED(hr = CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&pXMLDoc)))return hr;//Instantiate the XMLParser
            //We use the DOM to parse the ReadWrite table.  This gives better validation and error reporting.
            if(FAILED(hr = ParseXMLFile(pXMLDoc, m_bValidating)))return hr;                                                                      //Validate the XML file

            LOG_ERROR1(IDS_COMCAT_XML_DOM_PARSE_SUCCEEDED_WHEN_NODE_FACTORY_PARSE_FAILED, hrNodeFactory, m_wszURLPath);
            return E_SDTXML_XML_FAILED_TO_PARSE;
        }

        //clean up (this is also done in the dtor so don't hassle cleaning up if an error occurs and we return prematurely.)
        for(unsigned long iColumn=0; iColumn<m_kColumns; ++iColumn)
            m_aGrowableBuffer[iColumn].Delete();

        //This usually goes at the end; but in our case we need to GetColumnValues, so PostPopulateCache before the sorting
	    if (FAILED(hr = PostPopulateCache ())) return hr;

        //Currently this is alwasy true.  But once we add smarts to the property sorting this might be able to be false (currently only Location sorting is acknowledged using this flag).
#ifdef UNSORTED_METABASE
        if(false)
#else
        if(m_bUseIndexMapping)
#endif
        {    //The cache has been populated but now we need to remap the row indexes.
            m_SimpleTableWrite2_Memory->GetTableMeta(0, 0, &m_cRows, 0);
            m_aRowIndex = new ULONG [m_cRows];
            if(0 == m_aRowIndex.m_p)return E_OUTOFMEMORY;

            //IMPORTANT!!!  CreateNode/case 3 defaults well-known IDs when given a Name AND defaults well-known Names when given an ID.
            //Because of this, we only have to consider duplicate IDs when the propertied are both Custom AND user-defined (not in
            //the IisConfigObject table).
            TSmartPointerArray<ULONG> spCustomIDs;
            ULONG                     cSizeOf_spCustomIDs=0;
            ULONG                     cCustomIDs=0;

            ULONG iRow=0;
            Array<TProperty>          PropertyMapping;
            PropertyMapping.setSize(m_cMaxProertiesWithinALocation);//pre allocate enough space so we never have to realloc

            for(ULONG iLocationMapping=0; iLocationMapping<m_LocationMapping.size(); ++iLocationMapping)
            {
                PropertyMapping.setSize(0);//The Array is still pre allocated at size m_cMaxProertiesWithinALocation; but the current number of elements is set to 0.

                if(iLocationMapping>0 && m_LocationMapping[iLocationMapping]==m_LocationMapping[iLocationMapping-1])
                {   //if the previous location matches the current, then ignore all the properties within this location
                    LOG_WARNING1(IDS_METABASE_DUPLICATE_LOCATION, m_LocationMapping[iLocationMapping].m_wszLocation);
                    m_cRows -= m_LocationMapping[iLocationMapping].m_cRows;
                    continue;
                }

                tMBPropertyRow mbpropertyRow;
                ULONG          acbSizes[cMBProperty_NumberOfColumns];

                //Get the 0th property outside the loop for efficiency
                if(FAILED(hr = m_SimpleTableWrite2_Memory->GetColumnValues(m_LocationMapping[iLocationMapping].m_iFastCache,
                                            cMBProperty_NumberOfColumns, 0, acbSizes, reinterpret_cast<void **>(&mbpropertyRow))))
                    return hr;

                PropertyMapping.append(TProperty(mbpropertyRow.pName, m_LocationMapping[iLocationMapping].m_iFastCache));
                if(cSizeOf_spCustomIDs<m_LocationMapping[iLocationMapping].m_cRows)//if the buffer isn't big enough
                {                                                                      //round up to nearest 256 bytes
                    cSizeOf_spCustomIDs = (m_LocationMapping[iLocationMapping].m_cRows +63 ) & -64;
                    spCustomIDs.m_p = reinterpret_cast<ULONG *>(CoTaskMemRealloc(spCustomIDs.m_p, sizeof(ULONG)*cSizeOf_spCustomIDs));
                    if(0 == spCustomIDs.m_p)
                        return E_OUTOFMEMORY;
                }
                cCustomIDs = 0;//start with 0 Custom properties
                if(*mbpropertyRow.pGroup == m_kMBProperty_Custom)//We only need to consider duplicate IDs of Custom properties
                    spCustomIDs[cCustomIDs++] = *mbpropertyRow.pID;//build an array of the Custom IDs

                ULONG i=1;
                for(ULONG iFastCache=1+m_LocationMapping[iLocationMapping].m_iFastCache; i<m_LocationMapping[iLocationMapping].m_cRows; ++i, ++iFastCache)
                {
                    if(FAILED(hr = m_SimpleTableWrite2_Memory->GetColumnValues(iFastCache, cMBProperty_NumberOfColumns, 0,
                                                acbSizes, reinterpret_cast<void **>(&mbpropertyRow))))
                        return hr;

                    if(*mbpropertyRow.pGroup == m_kMBProperty_Custom)//We only need to consider duplicate IDs of Custom properties
                    {                                                //This is because of the implementation of ::CreateNode/case 3
                        ULONG iID=0;
                        for(;iID<cCustomIDs;++iID)//linear scan of the previously seen Custom IDs
                        {
                            if(*mbpropertyRow.pID == spCustomIDs[iID])
                            {//Duplicate ID
                                break;
                            }
                        }
                        if(iID<cCustomIDs)
                        {   //if we didn't make it through the list, then we have a duplicate.  So log a warning.
                            WCHAR wszID[12];
                            wsprintf(wszID, L"%d", *mbpropertyRow.pID); 
                            LOG_WARNING2( IDS_METABASE_DUPLICATE_PROPERTY_ID
                                        , wszID
                                        , m_LocationMapping[iLocationMapping].m_wszLocation);
                            --m_cRows;//skipping the row so subtract one from the cRows.
                            continue;//duplicate ID, skip this property
                        }
                        spCustomIDs[cCustomIDs++] = *mbpropertyRow.pID;//build an array of the Custom IDs
                    }

                    TProperty propertyTemp(mbpropertyRow.pName, iFastCache);
                    if(propertyTemp > PropertyMapping[i-1])
                        PropertyMapping.append(propertyTemp);//either put it at the end of the list
                    else                                       //or do a binary search to determine where it goes
                    {
                        unsigned int iInsertionPoint = PropertyMapping.binarySearch(propertyTemp);
                        //NOTE: We need to insert even if it's a duplicate.  It's already added to the
                        //fast cache and we're just remapping the indexes.  We don't want to shorten
                        //the list, so add the duplicate.
                        PropertyMapping.insertAt(iInsertionPoint, propertyTemp);

                        //The implementation of the binarySearch results in iInsertionPoint being placed after
                        //a property matching the one being inserted.
                        if(iInsertionPoint > 0 && propertyTemp==PropertyMapping[iInsertionPoint-1])
                        {
                            LOG_WARNING2( IDS_METABASE_DUPLICATE_PROPERTY
                                        , propertyTemp.m_wszPropertyName
                                        , m_LocationMapping[iLocationMapping].m_wszLocation);

                            PropertyMapping[iInsertionPoint].m_iFastCache = -1;
                            --m_cRows;
                        }
                    }
                }

                //Now walk the sorted property list to remap the row indexes
                for(i=0; i<PropertyMapping.size(); ++i)
                {
                    if(-1 != PropertyMapping[i].m_iFastCache)
                        m_aRowIndex[iRow++] = PropertyMapping[i].m_iFastCache;
                }
            }
            ASSERT(iRow == m_cRows);//When we're done mapping the rows we should have completely filled m_aRowIndex.
        }
        m_LocationMapping.reset();

    }
    catch(HRESULT e)
    {
        return e;
    }

    return S_OK;
}

ULONG TMetabase_XMLtable::MetabaseTypeFromColumnMetaType(tCOLUMNMETARow &columnmetaRow) const
{
    switch(*columnmetaRow.pType)
    {
    case eCOLUMNMETA_UI4:
        return eMBProperty_DWORD;
    case eCOLUMNMETA_BYTES:
        return eMBProperty_BINARY;
    case eCOLUMNMETA_WSTR:
        if(*columnmetaRow.pMetaFlags & fCOLUMNMETA_EXPANDSTRING)
            return eMBProperty_EXPANDSZ;
        else if(*columnmetaRow.pMetaFlags & fCOLUMNMETA_MULTISTRING)
            return eMBProperty_MULTISZ;
        return eMBProperty_STRING;
    default:
        ASSERT(false && L"This type is not allow in the Metabase. MetaMigrate should not have create a column of this type");
    }
    return 0;
}


//TXmlParsedFileNodeFactory (callback interface) routine
HRESULT TMetabase_XMLtable::CreateNode(const TElement &Element)
{
    if(Element.m_NodeFlags&fEndTag && 1!=Element.m_LevelOfElement)//This is to catch KeyType with NO custom properties
        return S_OK;

    try
    {
        HRESULT         hr;
        switch(Element.m_LevelOfElement)
        {
        case 1://The only thing we need to do at this level, is check to see if the previous element was an IISConfigObject
            {
                if(m_bIISConfigObjectWithNoCustomProperties)
                {
                    AddKeyTypeRow(L"IIsConfigObject", 15, true);//We previously saw an IISConfigObject node.  If NO custom properties were found beneath it, we need to add a NULLKeyType row.
                    m_bIISConfigObjectWithNoCustomProperties = false;
                }
                for(ULONG iColumn = 0; iColumn<m_kColumns; ++iColumn)
                {
                    m_apColumnValue[iColumn] = 0;
                    m_aSize[iColumn] = 0;
                }
                return S_OK;
            }
        case 2://We're dealing with Well-Known properties
            {
                m_bFirstPropertyOfThisLocationBeingAdded = true;//This helps identify duplicate locations

                if(0 != m_saQueriedLocation.m_p && m_bQueriedLocationFound)
                    return E_SDTXML_DONE;

                if(XML_COMMENT == Element.m_ElementType)
                    return SetComment(Element.m_ElementName, Element.m_ElementNameLength, true);

                //Before we go NULLing out the m_apColumnValue array we need to check to see if we need to write a NULLKeyType row (ie. Location with no properties).
                if(m_bIISConfigObjectWithNoCustomProperties)
                {
                    AddKeyTypeRow(m_aPublicRowName.GetFirstPublicRowName(), (ULONG) wcslen(m_aPublicRowName.GetFirstPublicRowName()), true);//We previously saw an IISConfigObject node.  If NO custom properties were found beneath it, we need to add a NULLKeyType row.
                    m_bIISConfigObjectWithNoCustomProperties = false;
                }

                //Initialize m_apColumnValue to ALL NULLs, some code relies on this
                ULONG iColumn;
                for(iColumn = 0; iColumn<m_kColumns; ++iColumn)
                {
                    m_apColumnValue[iColumn] = 0;
                    m_aSize[iColumn] = 0;
                }

                //We need a NULL terminated version of this string in a few places
                if(Element.m_ElementNameLength>1023)
                {
                    WCHAR wszTemp[1024];
                    memcpy(wszTemp, Element.m_ElementName, 1023 * sizeof(WCHAR));
                    wszTemp[1023]=0x00;
                    LOG_WARNING1(IDS_COMCAT_XML_ELEMENT_NAME_TOO_LONG, wszTemp);
                    return S_OK;//If the element name is too long, just ignore it.
                }
                WCHAR wszElement[1024];
                memcpy(wszElement, Element.m_ElementName, Element.m_ElementNameLength * sizeof(WCHAR));
                wszElement[Element.m_ElementNameLength] = 0x00;//NULL terminate it

                if(!m_aPublicRowName.IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
                {
                    //By not filling in m_apColumnValue[iMBProperty_Group], we guarantee no child Custom elements get added to a bogus Group below.

                    //TODO: Log a Detailed Error
                    LOG_WARNING1(IDS_COMCAT_XML_METABASE_CLASS_NOT_FOUND, wszElement);
                    return S_OK;//If the tag name of this element doesn't match the PublicRowName of the Group column log an error and continue.
                }
                //We special case Custom.  Custom is a perfectly valid enum public row name; but not at the same level as the Group
                if(0 == StringInsensitiveCompare(L"Custom", Element.m_ElementName))
                {
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_ElementName, 0xFF);//copy up to 0xFF characters
                    wszOffendingXml[0xFF]=0x00;
                    LOG_WARNING1(IDS_COMCAT_XML_CUSTOM_ELEMENT_NOT_UNDER_PARENT, wszOffendingXml);
                    return S_OK;
                }

                if(S_OK != (hr = FillInColumn(iMBProperty_Group, Element.m_ElementName, Element.m_ElementNameLength, m_acolmetas[iMBProperty_Group].dbType, m_acolmetas[iMBProperty_Group].fMeta)))
                {//@@@ ToDo: We should probably log an error and continue processing.  Should we log the error at the lower layer?
                    m_apColumnValue[iMBProperty_Group] = 0;
                    return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                }

                //IIsConfigObject
                m_bIISConfigObjectWithNoCustomProperties = (0 == StringInsensitiveCompare(m_aPublicRowName.GetFirstPublicRowName(), Element.m_ElementName));
                //We don't add a keytype row for IISConfigObject unless it's a NULLKeyType (there is a location with NO properties)
                //Remember that this is IISConfigObject.  We don't yet know whether we need to write a NULLKeyType.
                //If the next element is at level 3, we do NOT write a NULLKeyType.  If the next element is at level 2 or 1, we DO write a NULLKeyType row


                ASSERT(m_acolmetas[iMBProperty_Group].fMeta & fCOLUMNMETA_PRIMARYKEY);
                ASSERT(iMBProperty_Group > iMBProperty_Name);

                //There is one attribute that does NOT correspond to a NameValue row.  That's the Path attribute.  We have to find it first
                //since all of the other attributes use its value as one of the columns within their row
                ULONG iAttrLocation;
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_Location], m_acchColumnName[iMBProperty_Location], iAttrLocation))
                {
                    if(S_OK != (hr = FillInColumn(iMBProperty_Location, Element.m_aAttribute[iAttrLocation].m_Value, Element.m_aAttribute[iAttrLocation].m_ValueLength, m_acolmetas[iMBProperty_Location].dbType, m_acolmetas[iMBProperty_Location].fMeta)))
                        return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

                    if(0 != m_saQueriedLocation.m_p && 0 != wcscmp(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), m_saQueriedLocation))
                    {
                        if(m_saCollectionComment.m_p)
                            m_saCollectionComment[0] = 0x00;//NULL out the comment row
                        m_bIISConfigObjectWithNoCustomProperties = false;
                        return S_OK;//ignore this element if querying by location and the location doesn't match
                    }

                    m_apColumnValue[iMBProperty_LocationID] = &m_LocationID;
                    m_aSize[iMBProperty_LocationID] = sizeof(ULONG);
                    InterlockedIncrement(&m_LocationID);
                    m_bQueriedLocationFound = true;
                }
                else
                {
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_ElementName, 0xFF);//copy up to 0xFF characters
                    wszOffendingXml[0xFF]=0x00;
                    LOG_WARNING2(IDS_COMCAT_XML_NO_METABASE_LOCATION_FOUND, wszElement, wszOffendingXml);
                    return S_OK;
                }

                //Add the comment property if there is one
                if(0!=m_saCollectionComment.m_p && 0!=m_saCollectionComment[0])
                {
                    if(FAILED(hr = AddCommentRow()))
                        return hr;
                    m_bFirstPropertyOfThisLocationBeingAdded = false;
                    if(m_bIISConfigObjectWithNoCustomProperties)//We don't need to go through the attributes, becuase, by definition, there can be NO Well-Known properties under IISConfigObject
                    {
                        m_bIISConfigObjectWithNoCustomProperties = false;
                        return S_OK;
                    }
                }

                if(m_bIISConfigObjectWithNoCustomProperties)//We don't need to go through the attributes, becuase, by definition, there can be NO Well-Known properties under IISConfigObject
                    return S_OK;

                AddKeyTypeRow(Element.m_ElementName, Element.m_ElementNameLength);
                m_bFirstPropertyOfThisLocationBeingAdded = false;
            
                //Every attribute represents a row, where the Value column is the attribute value and the other columns come from the NameValueMeta
                //Walk through the attributes and Query tha NameValueMeta for a property from this Group with a name matching the Attribute name

                //Now go through all of the attribute, each of which should map to a Well-Known Name, and add a row for each.
                for(ULONG iAttr = 0; iAttr<Element.m_NumberOfAttributes; ++iAttr)
                {
                    if(iAttrLocation == iAttr)
                        continue;//we already got the location attribute taken care of.

                    if(S_OK != (hr = FillInColumn(iMBProperty_Name, Element.m_aAttribute[iAttr].m_Name, Element.m_aAttribute[iAttr].m_NameLength, m_acolmetas[iMBProperty_Name].dbType, m_acolmetas[iMBProperty_Name].fMeta)))
                        return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                    ASSERT(m_apColumnValue[iMBProperty_Name] && "This is Chewbacca, we can't have an attribute of NULL");

                    m_ColumnMeta_IndexBySearch_Values.pTable           = wszElement;
                    m_ColumnMeta_IndexBySearch_Values.pInternalName    = reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]);

                    ULONG iColumnMetaRow=-1;
                    if(FAILED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                    {
                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[iAttr].m_Name, 0xFF);//copy up to 0xFF characters
                        wszOffendingXml[0xFF]=0x00;
                        LOG_WARNING2(IDS_COMCAT_XML_METABASE_NO_PROPERTYMETA_FOUND, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]), wszOffendingXml);
                        continue;//just ignore any attributes that we don't understand
                    }

                    //This gets all of the default values for the column that matches the well know property
                    tCOLUMNMETARow  columnmetaRow;
                    ULONG           acbColumnMeta[cCOLUMNMETA_NumberOfColumns];
                    if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(iColumnMetaRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))
                        return hr;

                    //Attributes MUST match CASE-SENSITIVELY, and GetRowIndexBySearch find case-insensatively since ColumnMeta::InternalName is case-insensatively according to the meta
                    if(0 != StringCompare(columnmetaRow.pInternalName, m_ColumnMeta_IndexBySearch_Values.pInternalName))
                    {
                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[iAttr].m_Name, 0xFF);//copy up to 0xFF characters
                        wszOffendingXml[0xFF]=0x00;
                        LOG_WARNING2(IDS_COMCAT_XML_METABASE_NO_PROPERTYMETA_FOUND, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]), wszOffendingXml);
                        continue;//just ignore any attributes that we don't understand
                    }

                    ULONG Type = MetabaseTypeFromColumnMetaType(columnmetaRow);
                    //m_apColumnValue[iMBProperty_Name]     = Already filled in
                    m_apColumnValue[iMBProperty_Type]       = &Type;                        m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
                    m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;    m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
                    //m_apColumnValue[iMBProperty_Value]    = Filled in below
                    //m_apColumnValue[iMBProperty_Group]    = Already filled in
                    //m_apColumnValue[iMBProperty_Location] = Already filled in
                    m_apColumnValue[iMBProperty_ID]         = columnmetaRow.pID;            m_aSize[iMBProperty_ID]         = acbColumnMeta[iMBProperty_ID];
                    m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;      m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
                    //m_apColumnValue[iMBProperty_LocationID] Already filled in


                    //FillInColumn relies on m_apColumnValue[iMBProperty_Type] being already filled in for Secure and iMBProperty_Value column
                    bool bSecure = (0!=m_apColumnValue[iMBProperty_Attributes] && 0!=(fMBProperty_SECURE & *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Attributes])));
                    if(S_OK != (hr = FillInColumn(
                        iMBProperty_Value, //ColumnIndex
                        Element.m_aAttribute[iAttr].m_Value,                   //Attribute value
                        Element.m_aAttribute[iAttr].m_ValueLength,             //Attribute Value length
                        *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]),     //Value's Column Type
                        *columnmetaRow.pMetaFlags,                                           //Fixed length is always true for Value columns (since they're treated as bytes).
                        bSecure
                        )))continue;//@@@ToDo: Are we absolutely sure we've logged all possible error?  We don't want to ignore any errors without logging them.

                    if(*columnmetaRow.pID == 9994 /*MajorVersion*/)
                    {
                        m_MajorVersion = *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Value]);
                    }
                    else if(*columnmetaRow.pID == 9993 /*MinorVersion*/)
                    {
                        m_MinorVersion = *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Value]);
                    }

                    //@@@ We need to finish defining flags so this doesn't happen, until then we'll NOT log this warning
                    /*
                    if((fCOLUMNMETA_FLAG & *columnmetaRow.pMetaFlags) && (*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Value]) & ~(*columnmetaRow.pFlagMask)))
                    {
                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[iAttr].m_Name, 0xFF);//copy up to 0xFF characters
                        wszOffendingXml[0xFF]=0x00;

                        WCHAR wszValue[11];
                        wsprintf(wszValue, L"0x%08X", *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Value]));

                        WCHAR wszFlagMask[11];
                        wsprintf(wszFlagMask, L"0x%08X", *columnmetaRow.pFlagMask);

                        LOG_WARNING4(IDS_COMCAT_XML_FLAG_BITS_DONT_MATCH_FLAG_MASK,
                                        reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name]),
                                        wszValue,
                                        wszFlagMask,
                                        wszOffendingXml);
                    }
                    */

                    unsigned long iRow;
                    if(FAILED(hr = AddRowForInsert(&iRow)))
                        return hr;
                    if(FAILED(hr = SetWriteColumnValues(iRow, m_kColumns, 0, m_aSize, reinterpret_cast<void **>(m_apColumnValue))))
                        return hr;

                    AddPropertyToLocationMapping(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), iRow);
                }
            }
            break;
        case 3://We're dealing with Custom properties
            {   //We can rely on the fact that 2 columns are already set: Location and LocationID
                if(XML_ELEMENT != Element.m_ElementType)
                    return S_OK;//ignore non Element nodes
                if(Element.m_ElementNameLength != 6/*wcslen(L"Custom")*/ || 0 != memcmp(L"Custom", Element.m_ElementName, sizeof(WCHAR)*Element.m_ElementNameLength))
                {   //The only Child element supported is "Custom"
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_ElementName, 0xFF);//copy up to 0xFF characters
                    wszOffendingXml[0xFF]=0x00;

                    LOG_WARNING1(IDS_COMCAT_METABASE_CUSTOM_ELEMENT_EXPECTED, wszOffendingXml);
                    return S_OK;
                }
                if(0 == m_apColumnValue[iMBProperty_Group])
                {
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_ElementName, 0xFF);//copy up to 0xFF characters
                    wszOffendingXml[0xFF]=0x00;

                    LOG_WARNING1(IDS_COMCAT_METABASE_CUSTOM_ELEMENT_FOUND_BUT_NO_KEY_TYPE_LOCATION, wszOffendingXml);
                    return S_OK;
                }

                if(0!=m_saQueriedLocation.m_p && 0==m_apColumnValue[iMBProperty_LocationID])
                    return S_OK;
                //Cover the case where Level 2 was bogus

                //If this is the first custom element, then the Group column will be set to the parent element group - we need to remember what group the
                //parent is because custom KeyTypes are allowed on IIsConfigObject only.
                //If this is the second or subsequent custom property then we will have already clobbered m_apColumnValue[iMBProperty_Group] with eMBProperty_Custom.
                if(*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Group]) != eMBProperty_Custom)
                {
                    m_dwGroupRemembered = *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Group]);
                }
                ASSERT(m_dwGroupRemembered != -1);

                m_bIISConfigObjectWithNoCustomProperties = false;//This indicates whether to write a NULLKeyType row.  The rules are described above where m_bIISConfigObjectWithNoCustomProperties is assigned.

                //Columns MUST be set to zero so they can be properly defaulted
                ULONG iColumn;
                for(iColumn=0;iColumn<m_kColumns; ++iColumn)
                {
                    switch(iColumn)
                    {
                    case iMBProperty_Group://This column is going to be overridden with eMBProperty_Custom; but we need to retain the original Group so we can query the NameValue meta
                    case iMBProperty_Location:
                    case iMBProperty_LocationID://We never get these columns from the Well-Known name table
                        ASSERT(0 != m_apColumnValue[iColumn] && L"Group, Location or LocationID is NULL.  This shouldn't happen");
                        break;
                    default:
                        m_aSize[iColumn]         = 0;
                        m_apColumnValue[iColumn] = 0;
                        break;
                    }
                }

                //We need for the Name column to be listed first so we don't require special handling of default
                //TODO: put this error check in CatUtil
                ASSERT(iMBProperty_Name == 0);

                //Find the Name attribute so we can look it up in the Well-Known name table and initialize all the columns to their default values
                ULONG iAttr;
                ULONG fMetaFlags=0;//if this is a well-know property, it will have MetaFlags that we'll need to capture for use below.
                ULONG Type = 0;//Zero is not a legal Type, so 0 means uninitialized
                bool  bWellKnownForThisKeyType  = false;
                bool  bWellKnown                = false;
                bool  bWellKnownForThisKeyTypeAndNoDifferenceEncountered = false;
                tCOLUMNMETARow  columnmetaRow;
                ULONG           acbColumnMeta[cCOLUMNMETA_NumberOfColumns];

                memset(&columnmetaRow, 0x00, sizeof(tCOLUMNMETARow));
                //Get the Name attribute first
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_Name], m_acchColumnName[iMBProperty_Name], iAttr))
                {   //If we found the Name attribute
                    //Setup the Identity for the NameValueMeta GetRowByIdentity
                    if(S_OK != (hr = FillInColumn(iMBProperty_Name, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength, m_acolmetas[iMBProperty_Name].dbType, m_acolmetas[iMBProperty_Name].fMeta)))
                        return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

                    //This next line might seem a bit confusing - m_aTagMetaIndex[iMBProperty_Group] indicates which element of the m_aTagMetaRow array starts the group enums.
                    //And we rely on MetaMigrate to put enums in sequential order.  So we just add the value of the Group column to the TagMetaIndex and we have the
                    //TagMeta for the Group, thus we know which KeyType (Table) we're dealing with since the Group names ARE the TableNames (KeyTypes).
                    m_ColumnMeta_IndexBySearch_Values.pTable        = m_aTagMetaRow[m_aTagMetaIndex[iMBProperty_Group].m_iTagMeta + m_dwGroupRemembered].pInternalName;
                    //ASSERT that the Nth TagMeta (for the Group column) has a value of N.
                    ASSERT(m_dwGroupRemembered == *m_aTagMetaRow[m_aTagMetaIndex[iMBProperty_Group].m_iTagMeta + m_dwGroupRemembered].pValue);
                    m_ColumnMeta_IndexBySearch_Values.pInternalName = reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]);

                    ULONG iColumnMetaRow=-1;
                    if(SUCCEEDED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                    {   //So we have a Well-Known property
                        bWellKnownForThisKeyType                            = true;
                        bWellKnown                                          = true;
                        bWellKnownForThisKeyTypeAndNoDifferenceEncountered  = true;
                    }
                    else
                    {
                        m_ColumnMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//The first one is always IISConfigObject; but we do this just in case we decide to change the name
                        if(SUCCEEDED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                        {
                            bWellKnownForThisKeyType                            = false;
                            bWellKnown                                          = true;
                            bWellKnownForThisKeyTypeAndNoDifferenceEncountered  = true;
                        }
                    }

                    if(iColumnMetaRow!=-1)
                    {
                        if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(iColumnMetaRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))
                            return hr;

                        Type = MetabaseTypeFromColumnMetaType(columnmetaRow);

                        //m_apColumnValue[iMBProperty_Name]     = Already filled in
                        m_apColumnValue[iMBProperty_Type]       = &Type ;                                   m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
                        m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;                m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
                        //m_apColumnValue[iMBProperty_Value]    = Filled in below
                        //m_apColumnValue[iMBProperty_Group]    = Filled in below with eMBProperty_Custom
                        //m_apColumnValue[iMBProperty_Location] = Already filled in via Parent element
                        m_apColumnValue[iMBProperty_ID]         = columnmetaRow.pID;                        m_aSize[iMBProperty_ID]         = acbColumnMeta[iMBProperty_ID];
                        m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;                  m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
                        //m_apColumnValue[iMBProperty_LocationID] Already filled in via Parent element

                        fMetaFlags = *columnmetaRow.pMetaFlags;
                    }
                }

                //Get the ID attribute second
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_ID], m_acchColumnName[iMBProperty_ID], iAttr))
                {   //There is no Name attribute in this element, so we can infer one from the ID
                    //First get the ID from the XML
                    if(S_OK != (hr = FillInColumn(iMBProperty_ID, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                m_acolmetas[iMBProperty_ID].dbType, m_acolmetas[iMBProperty_ID].fMeta)))
                                return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

                    if(bWellKnown && //if it's a well-known property and it doesn't fit the pID we looked up in the ColumnMeta, then log warning
                        *reinterpret_cast<ULONG *>(columnmetaRow.pID) != *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]))
                    {   //So we have a well-known ID but a user-defined Name - warn and reject the property
                        WCHAR wszID[12];
                        wsprintf(wszID, L"%d", *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]));

                        WCHAR wszOffendingXml[0x100];
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, 0xFF);//copy up to 0xFF characters
                        wszOffendingXml[0xFF]=0x00;
                        LOG_WARNING3(IDS_COMCAT_METABASE_CUSTOM_PROPERTY_NAME_ID_CONFLICT, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name])
                                            , wszID, wszOffendingXml);
                        return S_OK;
                    }

                    //If NO Name was supplied OR we have a Name but it's NOT well-know
                    if(!bWellKnown)
                    {   //We need to see if the ID is well-known
                        m_ColumnMeta_IndexBySearch_Values.pTable = m_aTagMetaRow[m_aTagMetaIndex[iMBProperty_Group].m_iTagMeta + m_dwGroupRemembered].pInternalName;
                        m_ColumnMeta_IndexBySearch_Values.pID    = reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]);

                        ULONG iColumnMetaRow=-1;
                        if(SUCCEEDED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearchID, m_aiColumnMeta_IndexBySearchID, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                        {   //So we have a Well-Known property
                            bWellKnownForThisKeyType                            = true;
                            bWellKnown                                          = true;
                            bWellKnownForThisKeyTypeAndNoDifferenceEncountered  = true;
                        }
                        else
                        {
                            m_ColumnMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//The first one is always IISConfigObject; but we do this just in case we decide to change the name
                            if(SUCCEEDED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearchID, m_aiColumnMeta_IndexBySearchID, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &iColumnMetaRow)))
                            {
                                bWellKnownForThisKeyType                            = false;
                                bWellKnown                                          = true;
                                bWellKnownForThisKeyTypeAndNoDifferenceEncountered  = true;
                            }
                        }

                        if(iColumnMetaRow!=-1)
                        {   //We HAVe a well-known ID (remember, we do NOT have a well-known Name, per if(!bWellKnwon) condition above
                            if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(iColumnMetaRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))
                                return hr;

                            if(0 != m_apColumnValue[iMBProperty_Name])
                            {   //So we have a well-known ID but a user-defined Name - warn and reject the property
                                WCHAR wszID[12];
                                wsprintf(wszID, L"%d", *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]));

                                WCHAR wszOffendingXml[0x100];
                                wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, 0xFF);//copy up to 0xFF characters
                                wszOffendingXml[0xFF]=0x00;
                                LOG_WARNING3(IDS_COMCAT_METABASE_CUSTOM_PROPERTY_NAME_ID_CONFLICT, reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Name])
                                                    , wszID, wszOffendingXml);
                                return S_OK;
                            }

                            Type = MetabaseTypeFromColumnMetaType(columnmetaRow);

                            m_apColumnValue[iMBProperty_Name]       = columnmetaRow.pInternalName;              m_aSize[iMBProperty_Name]       = acbColumnMeta[iCOLUMNMETA_InternalName];
                            m_apColumnValue[iMBProperty_Type]       = &Type ;                                   m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
                            m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;                m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
                            //m_apColumnValue[iMBProperty_Value]    = Filled in below
                            //m_apColumnValue[iMBProperty_Group]    = Filled in below with eMBProperty_Custom
                            //m_apColumnValue[iMBProperty_Location] = Already filled in via Parent element
                            //m_apColumnValue[iMBProperty_ID]       = Already filled in
                            m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;                  m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
                            //m_apColumnValue[iMBProperty_LocationID] Already filled in via Parent element

                            fMetaFlags = *columnmetaRow.pMetaFlags;
                        }
                        else//if we have an unknown ID and NO value for the Name, then infer the name from the ID
                        {
                            //Then create a string with "UknownName_" followed by the ID
                            ASSERT(m_aGrowableBuffer[iMBProperty_Name].Size()>=256);
                            m_apColumnValue[iMBProperty_Name] = m_aGrowableBuffer[iMBProperty_Name].m_p;
                            m_aSize[iMBProperty_Name] = sizeof(WCHAR) * (1+wsprintf(reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]), L"UnknownName_%d", *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID])));
                        }
                    }
                }
            
                //At this point we MUST have an ID
                if(0 == m_apColumnValue[iMBProperty_ID])
                {
                    WCHAR wszOffendingXml[0x100];
                    wszOffendingXml[0]= 0x00;
                    if(Element.m_NumberOfAttributes>0)
                    {
                        wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, 0xFF);//copy up to 0xFF characters
                        wszOffendingXml[0xFF]=0x00;
                    }

                    LOG_WARNING1(IDS_COMCAT_METABASE_CUSTOM_ELEMENT_CONTAINS_NO_ID, wszOffendingXml);
                    return S_OK;
                }

                //1002 is the KeyType property                                          0 is IIsConfigObject
                if(1002==*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_ID]) && eMBProperty_IIsConfigObject!=m_dwGroupRemembered)
                {
                    WCHAR wszOffendingXml[0x100];
                    wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, 0xFF);//copy up to 0xFF characters
                    wszOffendingXml[0xFF]=0x00;

                    LOG_WARNING2(IDS_COMCAT_XML_CUSTOM_KEYTYPE_NOT_ON_IISCONFIGOBJECT, m_aPublicRowName.GetFirstPublicRowName(), wszOffendingXml);
                }

                //We have to read the columns in order.  We can't just read the attributes since we need the Type and Attribute columns before we read the Value column.
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_Type], m_acchColumnName[iMBProperty_Type], iAttr))
                {
                    if(S_OK != (hr = FillInColumn(iMBProperty_Type, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                m_acolmetas[iMBProperty_Type].dbType, m_acolmetas[iMBProperty_Type].fMeta, false)))
                                return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

                    //If the Type was specified AND the type was different from ColumnMeta, then we have to invalidate
                    //the meta flags (that we may have gotten from ColumnMeta
                    if(Type != *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]))
                    {
                        bWellKnownForThisKeyTypeAndNoDifferenceEncountered = false;//The type is different
                        
                        switch(*reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]))
                        {
                        case eMBProperty_DWORD:
                            fMetaFlags = fCOLUMNMETA_FIXEDLENGTH;
                            break;
                        case eMBProperty_STRING:
                        case eMBProperty_BINARY:
                            fMetaFlags = 0;
                            break;
                        case eMBProperty_EXPANDSZ:
                            fMetaFlags = fCOLUMNMETA_EXPANDSTRING;
                            break;
                        case eMBProperty_MULTISZ:
                            fMetaFlags = fCOLUMNMETA_MULTISTRING;
                            break;
                        default:
                            ASSERT(false && "Unknown datatype: this can happen if a new type is added to the MBProperty meta but not handled here.");
                            break;
                        }
                    }
                }
                if(FindAttribute(Element, m_awszColumnName[iMBProperty_Attributes], m_acchColumnName[iMBProperty_Attributes], iAttr))
                {
                    if(S_OK != (hr = FillInColumn(iMBProperty_Attributes, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                m_acolmetas[iMBProperty_Attributes].dbType, m_acolmetas[iMBProperty_Attributes].fMeta, false)))
                                return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                    if(bWellKnown && *columnmetaRow.pAttributes != *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Attributes]))
                        bWellKnownForThisKeyTypeAndNoDifferenceEncountered = false;//The Attributes are different
                }
                if(0 == m_apColumnValue[iMBProperty_Type])
                {
                    WCHAR wszOffendingXml[0x100];//unlike above, we know there is at least one attribute, we've already read either the name or the ID
                    wcsncpy(wszOffendingXml, Element.m_aAttribute[0].m_Name, 0xFF);//copy up to 0xFF characters
                    wszOffendingXml[0xFF]=0x00;

                    LOG_WARNING2(IDS_COMCAT_METABASE_CUSTOM_ELEMENT_CONTAINS_NO_TYPE, reinterpret_cast<LPWSTR>(m_apColumnValue[iMBProperty_Name]), wszOffendingXml);
                
                    //We can't just default the Type like we do with other columns, since FillInColumnRelies on this being NOT NULL, so default it here.
                    m_apColumnValue[iMBProperty_Type] = &m_kSTRING_METADATA;
                    m_aSize[iMBProperty_Type] = sizeof(ULONG);
                }
                
                for(iColumn=0;iColumn<m_kColumns; ++iColumn)
                {
                    switch(iColumn)
                    {
                    case iMBProperty_Location:      //we pick up the path from the parent, which we should already have
                    case iMBProperty_LocationID:    //we infer this from the parent, which we should already have
                    case iMBProperty_Group:         //we just hard coded the Group to eMBProperty_Custom
                    case iMBProperty_ID:            //this either came from the Well-Known name table OR we read it from the attribute
                    case iMBProperty_Name:          //we got this first thing (or we may have inferred it from the name)
                    case iMBProperty_Type:
                        ASSERT(0 != m_apColumnValue[iColumn]);break;
                    case iMBProperty_Value:
                        {
                            if(FindAttribute(Element, m_awszColumnName[iColumn], m_acchColumnName[iColumn], iAttr))
                            {
                                bool bSecure = (0!=m_apColumnValue[iMBProperty_Attributes] && 0!=(4/*fNameValuePairTable_METADATA_SECURE*/ & *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Attributes])));
                                ULONG metaflags = fMetaFlags;//we need to OR in any Metaflags
                                if(S_OK != (hr = FillInColumn(iColumn, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                            m_acolmetas[iColumn].dbType, metaflags, bSecure)))
                                            return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                            }
                            //Otherwise leave it defaulted (either to the Well-Known default, or NULL if this isn't a Well-Known property).
                        }
                        break;
                    case iMBProperty_Attributes:
                    case iMBProperty_UserType:
                    default:
                        {
                            if(FindAttribute(Element, m_awszColumnName[iColumn], m_acchColumnName[iColumn], iAttr))
                            {
                                ULONG metaflags = m_acolmetas[iColumn].fMeta;
                                if(S_OK != (hr = FillInColumn(iColumn, Element.m_aAttribute[iAttr].m_Value, Element.m_aAttribute[iAttr].m_ValueLength,
                                                            m_acolmetas[iColumn].dbType, metaflags, false/*Not secure*/)))
                                            return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;
                                if(bWellKnown && iColumn==iMBProperty_UserType && bWellKnownForThisKeyTypeAndNoDifferenceEncountered)
                                {
                                    if(*columnmetaRow.pUserType != *reinterpret_cast<ULONG *>(m_apColumnValue[iColumn]))
                                        bWellKnownForThisKeyTypeAndNoDifferenceEncountered = false;
                                }
                            }
                            //Otherwise leave it defaulted (either to the Well-Known default, or NULL if this isn't a Well-Known property).
                        }
                        break;
                    }
                }

                //We can hard code the Group column to be Custom unless, everything matches the well-known value
                m_apColumnValue[iMBProperty_Group] = bWellKnownForThisKeyTypeAndNoDifferenceEncountered ? &m_dwGroupRemembered : &m_kMBProperty_Custom;
                m_aSize[iMBProperty_Group] = sizeof(ULONG);

                unsigned long iRow;
                if(FAILED(hr = AddRowForInsert(&iRow)))
                    return hr;
                if(FAILED(hr = SetWriteColumnValues(iRow, m_kColumns, 0, m_aSize, reinterpret_cast<void **>(m_apColumnValue))))
                    return hr;

                AddPropertyToLocationMapping(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), iRow);//Can throw HRESULT
                m_bFirstPropertyOfThisLocationBeingAdded = false;//This helps identify duplicate locations
            }
            break;
        default://Ignore everything at a level other than 1, 2 or 3
            return S_OK;
        }
    }
    catch(HRESULT e)
    {
        return e;
    }

    return S_OK;
}

bool TMetabase_XMLtable::FindAttribute(const TElement &i_Element, LPCWSTR i_wszAttr, ULONG i_cchAttr, ULONG &o_iAttr)
{
    for(o_iAttr=0; (o_iAttr<i_Element.m_NumberOfAttributes); ++o_iAttr)
    {
        //If this attribute doesn't match the Column's Public name, move on to the next attribute
        if( i_cchAttr == i_Element.m_aAttribute[o_iAttr].m_NameLength
            &&       0 == Memicmp(i_Element.m_aAttribute[o_iAttr].m_Name, i_wszAttr, sizeof(WCHAR)*i_Element.m_aAttribute[o_iAttr].m_NameLength))
            return true;
    }
    return false;
}

HRESULT TMetabase_XMLtable::AddKeyTypeRow(LPCWSTR i_KeyType, ULONG i_Len, bool bNULLKeyTypeRow)
{
    HRESULT hr;
    if(-1 == m_iKeyTypeRow)
    {   //Fill in the KeyType row
        m_ColumnMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//The first one is always IISConfigObject; but we do this just in case we decide to change the name
        m_ColumnMeta_IndexBySearch_Values.pInternalName = L"KeyType";

        if(FAILED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &m_iKeyTypeRow)))
        {
            LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_ST_INVALIDBINFILE, ID_CAT_CAT, IDS_COMCAT_METABASE_PROPERTY_NOT_FOUND, m_ColumnMeta_IndexBySearch_Values.pInternalName,
                eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_ERROR, 0, 0, m_MajorVersion, m_MinorVersion));
            return E_ST_INVALIDBINFILE;
        }

        ASSERT(-1 != m_iKeyTypeRow);
    }
    tCOLUMNMETARow  columnmetaRow;
    ULONG           acbColumnMeta[cCOLUMNMETA_NumberOfColumns];
    if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(m_iKeyTypeRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))return hr;

    ULONG Type = MetabaseTypeFromColumnMetaType(columnmetaRow);
    m_apColumnValue[iMBProperty_Name]       = columnmetaRow.pInternalName;          m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_InternalName];
    m_apColumnValue[iMBProperty_Type]       = &Type;                                m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
    m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;            m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
    //m_apColumnValue[iMBProperty_Value]    = Filled in below
    //m_apColumnValue[iMBProperty_Group]    = Filled in already
    //m_apColumnValue[iMBProperty_Location] = Already filled in via Parent element
    m_apColumnValue[iMBProperty_ID]         = columnmetaRow.pID;                    m_aSize[iMBProperty_ID]         = acbColumnMeta[iMBProperty_ID];
    m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;              m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
    //m_apColumnValue[iMBProperty_LocationID] Already filled in via Parent element

    //FillInColumn relies on m_apColumnValue[iMBProperty_Type] being already filled in for Secure and iMBProperty_Value column
    if(S_OK != (hr = FillInColumn(
        iMBProperty_Value, //ColumnIndex
        i_KeyType,
        i_Len,
        *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]),     //Value's Column Type
        0
        )))return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

    static ULONG zero = 0;
    if(bNULLKeyTypeRow)//A NULL KeyType row indicates that the KeyType is only property, there are no other proerties under this Location.
    {
        static WCHAR szNULLKeyTypeRow[]=L"#LocationWithNoProperties";
        m_apColumnValue[iMBProperty_Name] = szNULLKeyTypeRow;
        m_aSize[iMBProperty_Name] = (ULONG)(wcslen(szNULLKeyTypeRow)+1)*sizeof(WCHAR);
        m_apColumnValue[iMBProperty_ID] = &m_kLocationID;
        m_aSize[iMBProperty_ID] = 0;
        m_apColumnValue[iMBProperty_Value] = 0;//NULL
        m_aSize[iMBProperty_Value] = 0;
    }

    unsigned long iRow;
    if(FAILED(hr = AddRowForInsert(&iRow)))return hr;
    if(FAILED(hr = SetWriteColumnValues(iRow, m_kColumns, 0, m_aSize, reinterpret_cast<void **>(m_apColumnValue))))return hr;

    AddPropertyToLocationMapping(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), iRow);
    return S_OK;
}


HRESULT TMetabase_XMLtable::AddCommentRow()
{
    ASSERT(0!=m_saCollectionComment.m_p && 0!=m_saCollectionComment[0]);

    HRESULT hr;
    if(-1 == m_iCollectionCommentRow)
    {   //Fill in the KeyType row
        m_ColumnMeta_IndexBySearch_Values.pTable        = const_cast<LPWSTR>(m_aPublicRowName.GetFirstPublicRowName());//The first one is always IISConfigObject; but we do this just in case we decide to change the name
        m_ColumnMeta_IndexBySearch_Values.pInternalName = L"CollectionComment";

        if(FAILED(m_pColumnMetaAll->GetRowIndexBySearch(0, ciColumnMeta_IndexBySearch, m_aiColumnMeta_IndexBySearch, 0, reinterpret_cast<void **>(&m_ColumnMeta_IndexBySearch_Values), &m_iCollectionCommentRow)))
        {
            LOG_ERROR_LOS(m_fLOS, Interceptor, (&m_spISTError.p, m_pISTDisp, E_ST_INVALIDBINFILE, ID_CAT_CAT, IDS_COMCAT_METABASE_PROPERTY_NOT_FOUND, m_ColumnMeta_IndexBySearch_Values.pInternalName,
                eSERVERWIRINGMETA_Core_MetabaseInterceptor, wszTABLE_MBProperty, eDETAILEDERRORS_Populate, -1, -1, m_wszURLPath, eDETAILEDERRORS_ERROR, 0, 0, m_MajorVersion, m_MinorVersion));
            return E_ST_INVALIDBINFILE;
        }

        ASSERT(-1 != m_iCollectionCommentRow);
    }

    tCOLUMNMETARow  columnmetaRow;
    ULONG           acbColumnMeta[cCOLUMNMETA_NumberOfColumns];
    if(FAILED(hr = m_pColumnMetaAll->GetColumnValues(m_iCollectionCommentRow, cCOLUMNMETA_NumberOfColumns, NULL, acbColumnMeta, reinterpret_cast<void **>(&columnmetaRow))))
        return hr;

    ULONG Type = MetabaseTypeFromColumnMetaType(columnmetaRow);
    m_apColumnValue[iMBProperty_Name]       = columnmetaRow.pInternalName;          m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_InternalName];
    m_apColumnValue[iMBProperty_Type]       = &Type;                                m_aSize[iMBProperty_Type]       = acbColumnMeta[iCOLUMNMETA_Type];
    m_apColumnValue[iMBProperty_Attributes] = columnmetaRow.pAttributes;            m_aSize[iMBProperty_Attributes] = acbColumnMeta[iMBProperty_Attributes];
    //m_apColumnValue[iMBProperty_Value]    = Filled in below
    //m_apColumnValue[iMBProperty_Group]    = Filled in already
    //m_apColumnValue[iMBProperty_Location] = Already filled in via Parent element
    m_apColumnValue[iMBProperty_ID]         = columnmetaRow.pID;                    m_aSize[iMBProperty_ID]         = acbColumnMeta[iMBProperty_ID];
    m_apColumnValue[iMBProperty_UserType]   = columnmetaRow.pUserType;              m_aSize[iMBProperty_UserType]   = acbColumnMeta[iMBProperty_UserType];
    //m_apColumnValue[iMBProperty_LocationID] Already filled in via Parent element

    //FillInColumn relies on m_apColumnValue[iMBProperty_Type] being already filled in for Secure and iMBProperty_Value column
    if(S_OK != (hr = FillInColumn(
        iMBProperty_Value, //ColumnIndex
        m_saCollectionComment,
        (ULONG)wcslen(m_saCollectionComment),
        *reinterpret_cast<ULONG *>(m_apColumnValue[iMBProperty_Type]),     //Value's Column Type
        0
        )))return S_IGNORE_THIS_PROPERTY==hr ? S_OK : hr;

    unsigned long iRow;
    if(FAILED(hr = AddRowForInsert(&iRow)))
        return hr;
    if(FAILED(hr = SetWriteColumnValues(iRow, m_kColumns, 0, m_aSize, reinterpret_cast<void **>(m_apColumnValue))))
        return hr;

    AddPropertyToLocationMapping(reinterpret_cast<LPCWSTR>(m_apColumnValue[iMBProperty_Location]), iRow);

    m_saCollectionComment[0] = 0x00;//now that we've added the comment, set it to "" for the next time
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\metabase_xmltable.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __METABASE_XMLTABLE_H__
#define __METABASE_XMLTABLE_H__

#ifndef __SDTXML_H__
    #include "sdtxml.h"
#endif
#ifndef __ARRAY_INCLUDED__
    #include "array_t.h"
#endif

class TGrowableBuffer : public TSmartPointerArray<unsigned char>
{
public:
    TGrowableBuffer() : m_cb(0){}
    void Grow(size_t cb)
    {
        if(cb > m_cb)
        {
            delete [] m_p;
            m_p     = new unsigned char[cb];
            if(0 == m_p)
            {
                m_cb = 0;
                throw static_cast<HRESULT>(E_OUTOFMEMORY);
            }
            m_cb    = cb;
        }
    }
    size_t Size() const {return m_cb;}
    void Delete()//The parent doesn't set m_cb to zero
    {
        delete [] m_p;
        m_p = 0;
        m_cb = 0;
    }
private:
    size_t m_cb;
};


// ------------------------------------------------------------------
// class TMetabase_XMLtable:
// ------------------------------------------------------------------
class TMetabase_XMLtable : 
	public      ISimpleTableWrite2,
	public      ISimpleTableController,
	public      ISimpleTableInterceptor,
    public      TXmlParsedFileNodeFactory,
    public      TXmlSDTBase,
    public      TMSXMLBase
{
public:
    TMetabase_XMLtable ();
    virtual ~TMetabase_XMLtable ();

//IUnknown
public:
    STDMETHOD (QueryInterface)          (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)            ();
    STDMETHOD_(ULONG,Release)           ();


	// ISimpleTableRead2 (ISimpleTableWrite2 : ISimpleTableRead2)
    STDMETHOD (GetRowIndexByIdentity)   (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow);
    STDMETHOD (GetRowIndexBySearch)     (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow){return E_NOTIMPL;}
	STDMETHOD (GetColumnValues)         (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* o_acbSizes, LPVOID* o_apvValues)
                                        {
                                            if(m_bUseIndexMapping)
                                            {
                                                if(i_iRow>=m_cRows)
                                                    return E_ST_NOMOREROWS;
                                                i_iRow=m_aRowIndex[i_iRow];
                                            }
                                            return m_SimpleTableWrite2_Memory->GetColumnValues(i_iRow, i_cColumns, i_aiColumns, o_acbSizes, o_apvValues);
                                        }
	STDMETHOD (GetTableMeta)            (ULONG* o_pcVersion, DWORD* o_pfTable, ULONG* o_pcRows, ULONG* o_pcColumns )
                                        {
                                            if(o_pcRows)
                                                *o_pcRows = m_cRows;
                                            return m_SimpleTableWrite2_Memory->GetTableMeta(o_pcVersion, o_pfTable, 0, o_pcColumns);
                                        }
	STDMETHOD (GetColumnMetas)	        (ULONG i_cColumns, ULONG* i_aiColumns, SimpleColumnMeta* o_aColumnMetas )
                                        { return m_SimpleTableWrite2_Memory->GetColumnMetas(i_cColumns, i_aiColumns, o_aColumnMetas );}

	// ISimpleTableWrite2 
	STDMETHOD (AddRowForDelete)         (ULONG i_iReadRow)
                                        { return m_SimpleTableWrite2_Memory->AddRowForDelete(i_iReadRow);}
	STDMETHOD (AddRowForInsert)         (ULONG* o_piWriteRow)
                                        { return m_SimpleTableWrite2_Memory->AddRowForInsert(o_piWriteRow);}
	STDMETHOD (AddRowForUpdate)         (ULONG i_iReadRow, ULONG* o_piWriteRow)
                                        { return m_SimpleTableWrite2_Memory->AddRowForUpdate(i_iReadRow, o_piWriteRow);}
	STDMETHOD (SetWriteColumnValues)    (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues)
                                        { return m_SimpleTableWrite2_Memory->SetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns, i_acbSizes, i_apvValues);}
	STDMETHOD (GetWriteColumnValues)    (ULONG i_iRow, ULONG i_cColumns, ULONG* i_aiColumns, DWORD* o_afStatus, ULONG* o_acbSizes, LPVOID* o_apvValues)
                                        { return m_SimpleTableWrite2_Memory->GetWriteColumnValues(i_iRow, i_cColumns, i_aiColumns, o_afStatus, o_acbSizes, o_apvValues);}
	STDMETHOD (GetWriteRowIndexByIdentity) (ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow)
                                        { return m_SimpleTableWrite2_Memory->GetWriteRowIndexByIdentity(i_acbSizes, i_apvValues, o_piRow);}
	STDMETHOD (GetWriteRowIndexBySearch)     (ULONG i_iStartingRow, ULONG i_cColumns, ULONG* i_aiColumns, ULONG* i_acbSizes, LPVOID* i_apvValues, ULONG* o_piRow){return E_NOTIMPL;}
	STDMETHOD (GetErrorTable)           (DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
                                        {return E_NOTIMPL;}
	STDMETHOD (UpdateStore)             ()
                                        { return E_NOTIMPL;}
	
	// ISimpleTableAdvanced (ISimpleTableController : ISimpleTableAdvanced)
	STDMETHOD (PopulateCache)           ();
	STDMETHOD (GetDetailedErrorCount)   (ULONG* o_pcErrs)
                                        { return m_SimpleTableController_Memory->GetDetailedErrorCount(o_pcErrs);}
	STDMETHOD (GetDetailedError)        (ULONG i_iErr, STErr* o_pSTErr)
                                        { return m_SimpleTableController_Memory->GetDetailedError(i_iErr, o_pSTErr);}

	// ISimpleTableController:
	STDMETHOD (ShapeCache)              (DWORD i_fTable, ULONG i_cColumns, SimpleColumnMeta* i_acolmetas, LPVOID* i_apvDefaults, ULONG* i_acbSizes)
                                        { return m_SimpleTableController_Memory->ShapeCache(i_fTable, i_cColumns, i_acolmetas, i_apvDefaults, i_acbSizes);}
	STDMETHOD (PrePopulateCache)        (DWORD i_fControl)
                                        { return m_SimpleTableController_Memory->PrePopulateCache(i_fControl);}
	STDMETHOD (PostPopulateCache)	    ()
                                        { return m_SimpleTableController_Memory->PostPopulateCache();}
	STDMETHOD (DiscardPendingWrites)    ()
                                        { return m_SimpleTableController_Memory->DiscardPendingWrites();}
	STDMETHOD (GetWriteRowAction)	    (ULONG i_iRow, DWORD* o_peAction)
                                        { return m_SimpleTableController_Memory->GetWriteRowAction(i_iRow, o_peAction);}
	STDMETHOD (SetWriteRowAction)	    (ULONG i_iRow, DWORD i_eAction)
                                        { return m_SimpleTableController_Memory->SetWriteRowAction(i_iRow, i_eAction);}
	STDMETHOD (ChangeWriteColumnStatus) (ULONG i_iRow, ULONG i_iColumn, DWORD i_fStatus)
                                        { return m_SimpleTableController_Memory->ChangeWriteColumnStatus(i_iRow, i_iColumn, i_fStatus);}
	STDMETHOD (AddDetailedError)        (STErr* o_pSTErr)
                                        { return m_SimpleTableController_Memory->AddDetailedError(o_pSTErr);}
	STDMETHOD (GetMarshallingInterface) (IID * o_piid, LPVOID * o_ppItf)
                                        { return m_SimpleTableController_Memory->GetMarshallingInterface(o_piid, o_ppItf);}

//ISimpleTableInterceptor
    STDMETHOD (Intercept)               (LPCWSTR                    i_wszDatabase,
                                         LPCWSTR                    i_wszTable, 
										 ULONG						i_TableID,
                                         LPVOID                     i_QueryData,
                                         LPVOID                     i_QueryMeta,
                                         DWORD                      i_eQueryFormat,
                                         DWORD                      i_fLOS,
                                         IAdvancedTableDispenser*   i_pISTDisp,
                                         LPCWSTR                    i_wszLocator,
                                         LPVOID                     i_pSimpleTable,
                                         LPVOID*                    o_ppvSimpleTable
                                        );


//TXmlParsedFileNodeFactory (callback interface) routines
public:
    virtual HRESULT CoCreateInstance    (REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const {return TMSXMLBase::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);}
    virtual HRESULT CreateNode          (const TElement &Element);


    
// Helper functions
private:
    void        AddPropertyToLocationMapping(LPCWSTR i_Location, ULONG i_iFastCacheRow);
    HRESULT     AddKeyTypeRow(LPCWSTR i_KeyType, ULONG i_Len, bool bNULLKeyTypeRow=false);
    HRESULT     AddCommentRow();
    IAdvancedTableDispenser * Dispenser() {return m_pISTDisp;}
    HRESULT     FillInColumn(ULONG iColumn, LPCWSTR pwcText, ULONG ulLen, ULONG dbType, ULONG fMeta, bool bSecure=false);
    bool        FindAttribute(const TElement &i_Element, LPCWSTR i_wszAttr, ULONG i_cchAttr, ULONG &o_iAttr);
    ULONG       GetColumnMetaType(ULONG type) const;
    HRESULT     GetColumnValue_Bytes(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetColumnValue_MultiSZ(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetColumnValue_String(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetColumnValue_UI4(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetColumnValue_Bool(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long i_Len);
    HRESULT     GetMetaTable(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, CComPtr<ISimpleTableRead2> &pMetaTable) const;
    bool        IsNumber(LPCWSTR i_awch, ULONG i_Len) const;
    HRESULT     InternalComplicatedInitialize();
    inline HRESULT InternalSetWriteColumn(ISimpleTableWrite2 *pISTW2, ULONG i_iRow, ULONG i_iColumn, ULONG i_cbSize, LPVOID i_pvValue)
                    {return pISTW2->SetWriteColumnValues(i_iRow, 1, &i_iColumn, &i_cbSize, &i_pvValue);}
    HRESULT     LoadDocumentFromURL(IXMLDOMDocument *pXMLDoc);
    int         Memicmp(LPCWSTR i_p0, LPCWSTR i_p1, ULONG i_cby) const;
    ULONG       MetabaseTypeFromColumnMetaType(tCOLUMNMETARow &columnmetaRow) const;
    HRESULT     ObtainPertinentRelationMetaInfo();
    HRESULT     ObtainPertinentTableMetaInfo();
    HRESULT     ObtainPertinentTagMetaInfo();
    HRESULT     ParseXMLFile(IXMLDOMDocument *pXMLDoc, bool bValidating=true);
    HRESULT     SetComment(LPCWSTR i_pComment, ULONG i_Len, bool i_bAppend);
    int         SizeOf(LPCWSTR wsz) const {return (int)(wcslen(wsz)+1)*sizeof(WCHAR);}
    inline int  StringInsensitiveCompare(LPCWSTR sz1, LPCWSTR sz2) const {return _wcsicmp(sz1, sz2);}
    inline int  StringCompare(LPCWSTR sz1, LPCWSTR sz2) const {if(*sz1 != *sz2)return -1;return wcscmp(sz1, sz2);}

// Private member variables
private:
    static const VARIANT_BOOL   kvboolTrue;
    static const VARIANT_BOOL   kvboolFalse;
    static       ULONG          m_kLocationID;
    static       ULONG          m_kZero;
    static       ULONG          m_kOne;
    static       ULONG          m_kTwo;
    static       ULONG          m_kThree;
    static       ULONG          m_kSTRING_METADATA;
    static       ULONG          m_kMBProperty_Custom;
    static const WCHAR *        m_kwszBoolStrings[];
    static       WCHAR          m_kKeyType[];
    static       LONG           m_LocationID;

    bool        IsEnumPublicRowName() const {return (-1 != m_iPublicRowNameColumn);}

    //This class maps a Location to its first instance in the fast cache.  It also tracks how many instances of the location exist in the fast cache
    class TLocation
    {
    public:
        TLocation() : m_iFastCache(0), m_cRows(0)
        {
        }
        TLocation(LPCWSTR wszLocation, ULONG iFastCache) : m_iFastCache(iFastCache), m_cRows(1)
        {
            if(wszLocation)
            {
                m_wszLocation = new WCHAR[wcslen(wszLocation)+1];
                if(0 == m_wszLocation.m_p)
                    throw static_cast<HRESULT>(E_OUTOFMEMORY);
                wcscpy(m_wszLocation, wszLocation);
            }
        }

        TSmartPointerArray<WCHAR> m_wszLocation;
        ULONG   m_iFastCache;
        ULONG   m_cRows;

        bool        operator <  (const TLocation &location) const { return (_wcsicmp(m_wszLocation, location.m_wszLocation) < 0);}
        bool        operator >  (const TLocation &location) const { return (_wcsicmp(m_wszLocation, location.m_wszLocation) > 0);}
        bool        operator == (const TLocation &location) const { return (_wcsicmp(m_wszLocation, location.m_wszLocation) == 0);}
        TLocation & operator =  (const TLocation &location)
        {
            m_wszLocation.Delete();
            if(location.m_wszLocation)
            {
                m_wszLocation = new WCHAR[wcslen(location.m_wszLocation)+1];
                if(0 == m_wszLocation.m_p)
                    throw static_cast<HRESULT>(E_OUTOFMEMORY);
                wcscpy(m_wszLocation, location.m_wszLocation);
            }

            m_iFastCache    = location.m_iFastCache;
            m_cRows         = location.m_cRows;
            return *this;
        }
    };
    class TProperty
    {   //It's OK to track property names by pointer since, by the time we build the sorted list, all entries are already in the fast
        //cache (no opportunity for the fast cache to resize, thus pointers are always valid).  This is NOT the case for the Locations.
    public:
        TProperty() : m_iFastCache(0), m_wszPropertyName(0)
        {
        }
        TProperty(LPCWSTR wszProperty, ULONG iFastCache) : m_iFastCache(iFastCache), m_wszPropertyName(wszProperty)
        {
        }

        ULONG   m_iFastCache;
        LPCWSTR m_wszPropertyName;

        bool        operator <  (const TProperty &property) const { return (_wcsicmp(m_wszPropertyName, property.m_wszPropertyName) < 0);}
        bool        operator >  (const TProperty &property) const { return (_wcsicmp(m_wszPropertyName, property.m_wszPropertyName) > 0);}
        bool        operator == (const TProperty &property) const { return (_wcsicmp(m_wszPropertyName, property.m_wszPropertyName) == 0);}
        TProperty & operator =  (const TProperty &property)
        {
            m_wszPropertyName = property.m_wszPropertyName;
            m_iFastCache      = property.m_iFastCache;
            return *this;
        }
    };
    
    class TTagMetaIndex
    {
    public:
        TTagMetaIndex() : m_iTagMeta(-1), m_cTagMeta(0){}
        unsigned long m_iTagMeta;//Index into the TagMeta (for this table)
        unsigned long m_cTagMeta;//Number of tags for this column
    };
    //We list the const members first.
    TComBSTR                            m_bstr_name;
    const LPCWSTR                       m_kXMLSchemaName;           // This is the XML Schema name that is used to validate the XML document

    //We have this problem where we need a bunch of arrays, each of size m_cColumns.  To reduce the number of allocations we'll create these arrays as
    //fixed size and hope that most tables will have no more than m_kColumns.
    enum
    {
        m_kColumns          = cMBProperty_NumberOfColumns,
        m_kMaxEventReported = 50
    };
    //Here are the 'fixed' size arrays
    TComBSTR                                m_abstrColumnNames[m_kColumns];
    SimpleColumnMeta                        m_acolmetas[m_kColumns];
    unsigned int                            m_aLevelOfColumnAttribute[m_kColumns];
    LPVOID                                  m_apColumnValue[m_kColumns];
    STQueryCell                             m_aQuery[m_kColumns];
    ULONG                                   m_aStatus[m_kColumns];
    LPCWSTR                                 m_awszColumnName[m_kColumns];
    unsigned long                           m_acchColumnName[m_kColumns];
    unsigned int                            m_aColumnsIndexSortedByLevel[m_kColumns];//Node Factory variable (see below)
    unsigned long                           m_aSize[m_kColumns];                     //Node Factory variable (see below)
    TTagMetaIndex                           m_aTagMetaIndex[m_kColumns];
    TGrowableBuffer                         m_aGrowableBuffer[m_kColumns];

    TPublicRowName                      m_aPublicRowName;
    TSmartPointerArray<ULONG>           m_aRowIndex;                // When the XML file isn't sorted correctly, we have to map the fast cache row indexes into a Location sorted list.
    TSmartPointerArray<tTAGMETARow>     m_aTagMetaRow;              // This is a copy of the TagMeta for this table. m_aiTagMeta for each column points into this array if the column has tag meta
    bool                                m_bEnumPublicRowName_NotContainedTable_ParentFound;//This is to keep track of the parent of this special kind of table.  And when we reach a close tag for the parent we can bail.
    bool                                m_bFirstPropertyOfThisLocationBeingAdded;
    bool                                m_bIISConfigObjectWithNoCustomProperties;
    bool                                m_bQueriedLocationFound;
    TComBSTR                            m_bstrPublicTableName;      // These come from the table meta
    TComBSTR                            m_bstrPublicRowName;        // There is a need for the base PublicRowName aside from the array of PublicRowNames above
    bool                                m_bUseIndexMapping;         // This is true when the order of the Locations in the XML file are not correctly sorted, and the Metabase XML interceptor has to remap the row indexes
    bool                                m_bValidating;              // If we don't validate, then the parse should be a bit faster
    ULONG                               m_cchCommentBufferSize;
    ULONG                               m_cEventsReported;
    unsigned                            m_cLocations;               // Count of Metabase Locations (or Paths)
    ULONG                               m_cMaxProertiesWithinALocation;//This is the count of properties in the most populated location.
    ULONG                               m_cRef;                     // Interface reference count.
    ULONG                               m_cRows;                    // Number of Rows in the table, this is also the size of m_aRowIndex
    ULONG                               m_cTagMetaValues;           // Count Of TagMeta entries for the table
    DWORD                               m_fCache;                   // Cache flags.
    ULONG                               m_fLOS;                     // Level Of Service passed into ::Intercept
    ULONG                               m_iCollectionCommentRow;
    ULONG                               m_iKeyTypeRow;
    ULONG                               m_iPreviousLocation;
    unsigned int                        m_iPublicRowNameColumn;     // Some tables use an enum value as the public row name, this is an index to the column with the enum.  If this is not one of those types of tables, then this value is -1.
    LONG                                m_IsIntercepted;            // Table flags (from caller).
    Array<TLocation>                    m_LocationMapping;
    ULONG                               m_MajorVersion;
    ULONG                               m_MinorVersion;
    CComPtr<IAdvancedTableDispenser>    m_pISTDisp; 
    CComPtr<IXMLDOMNode>                m_pLastPrimaryTable;
    CComPtr<IXMLDOMNode>                m_pLastParent;
    CComPtr<ISimpleTableRead2>          m_pTableMeta;
    CComPtr<ISimpleTableRead2>          m_pTagMeta;
    CComPtr<ISimpleTableRead2>          m_pTagMeta_IISConfigObject;//This is how we look up Tags for the Value column
    TSmartPointerArray<WCHAR>           m_saCollectionComment;
    TSmartPointerArray<WCHAR>           m_saQueriedLocation;
    TSmartPointerArray<WCHAR>           m_saSchemaBinFileName;
    CComPtr<ISimpleTableWrite2>         m_SimpleTableWrite2_Memory;
    CComQIPtr<ISimpleTableController,
           &IID_ISimpleTableController> m_SimpleTableController_Memory;
    CComPtr<ISimpleTableWrite2>         m_spISTError;
    CComQIPtr<IMetabaseSchemaCompiler, &IID_IMetabaseSchemaCompiler> m_spMetabaseSchemaCompiler;
    tTABLEMETARow                       m_TableMetaRow;

    ULONG                               m_cCacheHit;
    ULONG                               m_cCacheMiss;

    const unsigned long                 m_kPrime;

    unsigned long                       m_LevelOfBasePublicRow;
    TXmlParsedFile_NoCache              m_XmlParsedFile;
//    CComPtr<ISimpleTableRead2>          m_pNameValueMeta;
    CComPtr<ISimpleTableRead2>          m_pColumnMetaAll;//This uses "ByName" indexing
    enum
    {
        ciColumnMeta_IndexBySearch      = 2,
        ciColumnMeta_IndexBySearchID    = 2,
        ciTagMeta_IndexBySearch         = 2
    };

    ULONG                               m_aiColumnMeta_IndexBySearch[ciColumnMeta_IndexBySearch];
    ULONG                               m_aiColumnMeta_IndexBySearchID[ciColumnMeta_IndexBySearchID];//We'll reuse m_ColumnMeta_IndexBySearch_Values for ByID
    tCOLUMNMETARow                      m_ColumnMeta_IndexBySearch_Values;//This is passed into GetRowIndexBySearch, the 0th element is the Table, the 1st element is the Column's InternalName
    ULONG                               m_aiTagMeta_IndexBySearch[ciTagMeta_IndexBySearch];
    tTAGMETARow                         m_TagMeta_IndexBySearch_Values;

    CComPtr<ISimpleTableRead2>          m_pTableMeta_Metabase;//These are the Tables belonging to the Metabase Database
    CComPtr<ISimpleTableRead2>          m_pColumnMeta;//The only reason we keep this guy around after initial meta setup, is so we don't have to make copies of the ColumnNames

    DWORD                               m_dwGroupRemembered;
};


#endif //__METABASE_XMLTABLE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\sdtxml_com.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#include <objbase.h>

#include "sdtxml.h"                             // SDTxml class definition.

// -----------------------------------------
// CXmlSDT: IUnknown 
// -----------------------------------------

// =======================================================================
STDMETHODIMP CXmlSDT::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableInterceptor)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	if (riid == IID_IInterceptorPlugin)
	{
		*ppv = (IInterceptorPlugin*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}

	if (NULL != *ppv)
	{
		((IInterceptorPlugin*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CXmlSDT::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

// =======================================================================
STDMETHODIMP_(ULONG) CXmlSDT::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\metabase_xmltable_com.cpp ===
//  Copyright (C) 2000-2001 Microsoft Corporation.  All rights reserved.
#include <objbase.h>

#include "Metabase_XMLtable.h"

// -----------------------------------------
// TMetabase_XMLtable: IUnknown 
// -----------------------------------------

// =======================================================================
STDMETHODIMP TMetabase_XMLtable::QueryInterface(REFIID riid, void **ppv)
{
    if (NULL == ppv) 
        return E_INVALIDARG;
    *ppv = NULL;

    
    if (riid == IID_ISimpleTableAdvanced)
    {
        *ppv = (ISimpleTableAdvanced*)(this);
    }
    else if (riid == IID_ISimpleTableRead2)
    {
        *ppv = (ISimpleTableRead2*)(this);
    }
    else if (riid == IID_ISimpleTableWrite2)
    {
        *ppv = (ISimpleTableWrite2*)(this);
    }
    else if (riid == IID_ISimpleTableController)
    {
        *ppv = (ISimpleTableController*)(this);
    }
    else if (riid == IID_ISimpleTableInterceptor)
    {
        *ppv = (ISimpleTableInterceptor*)(this);
    }
    else if (riid == IID_IUnknown)
    {
        *ppv = (ISimpleTableWrite2*)(this);
    }

    if (NULL != *ppv)
    {
        ((ISimpleTableWrite2*)this)->AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

// =======================================================================
STDMETHODIMP_(ULONG) TMetabase_XMLtable::AddRef()
{
    return InterlockedIncrement((LONG*) &m_cRef);
    
}

// =======================================================================
STDMETHODIMP_(ULONG) TMetabase_XMLtable::Release()
{
    long cref = InterlockedDecrement((LONG*) &m_cRef);
    if (cref == 0)
    {
        delete this;
    }
    return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\sdtxml.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __SDTXML_H__
#define __SDTXML_H__

#ifndef __catalog_h__
    #include "catalog.h"
#endif
#ifndef AFX_STBASE_H__14A33215_096C_11D1_965A_00C04FB9473F__INCLUDED_
    #include "sdtfst.h"
#endif
#ifndef __TABLEINFO_H__  
    #include "catmeta.h"
#endif
#ifndef __ATLBASE_H__
    #include <atlbase.h>
#endif
#ifndef __TCOMBSTR_H__
    #include "TComBSTR.h"
#endif
#ifndef __msxml_h__
    #include "msxml.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __WSTRING_H__
    #include "wstring.h"
#endif
#ifndef __TXMLPARSEDFILE_H__
    #include "TXmlParsedFile.h"
#endif
#ifndef __TPUBLICROWNAME_H__
    #include "TPublicRowName.h"
#endif
#ifndef __TLISTOFXMLDOMNODELISTS_H__
    #include "TListOfXMLDOMNodeLists.h"
#endif
#ifndef __TMSXMLBASE_H__
    #include "TMSXMLBase.h"
#endif

#include "safecs.h"


// class TXmlSDTBase
//
// This is a base class for sharing XML utility functions which are used by all XML interceptors.  It should
// NOT contain anything DOM specific or XML Node Factory specific.
class TXmlSDTBase
{
public:
    TXmlSDTBase(){}
protected:
    //const members
    enum
    {
        m_kcwchURLPath  = 7+MAX_PATH
    };

    //non-static members
    WCHAR       m_wszURLPath[m_kcwchURLPath];// Fully qualified URL path (can beof the type: file://c:/windows/system32/comcatmeta.xml)

    //protected methods
    HRESULT     GetURLFromString(LPCWSTR wsz);
};


// ------------------------------------------------------------------
// class CXmlSDT:
// ------------------------------------------------------------------
class CXmlSDT : 
    public      TXmlSDTBase ,
    public      TMSXMLBase ,
    public      IInterceptorPlugin  ,
    public      TXmlParsedFileNodeFactory
{
public:
    CXmlSDT ();
    virtual ~CXmlSDT ();

//IUnknown
public:
    STDMETHOD (QueryInterface)      (REFIID riid, OUT void **ppv);
    STDMETHOD_(ULONG,AddRef)        ();
    STDMETHOD_(ULONG,Release)       ();


//ISimpleTableInterceptor
public:
    STDMETHOD (Intercept)               (
                                         LPCWSTR                    i_wszDatabase,
                                         LPCWSTR                    i_wszTable, 
                                         ULONG                      i_TableID,
                                         LPVOID                     i_QueryData,
                                         LPVOID                     i_QueryMeta,
                                         DWORD                      i_eQueryFormat,
                                         DWORD                      i_fLOS,
                                         IAdvancedTableDispenser*   i_pISTDisp,
                                         LPCWSTR                    i_wszLocator,
                                         LPVOID                     i_pSimpleTable,
                                         LPVOID*                    o_ppvSimpleTable
                                        );

//public      IInterceptorPlugin : ISimpleTableInterceptor
public:
    STDMETHOD (OnPopulateCache)         (ISimpleTableWrite2* i_pISTW2);
    STDMETHOD (OnUpdateStore)           (ISimpleTableWrite2* i_pISTW2);


//TXmlParsedFileNodeFactory routines
public:
    virtual HRESULT  CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid,  LPVOID * ppv) const {return TMSXMLBase::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);}
    virtual HRESULT  CreateNode      (const TElement &Element);

//private data types
private:
    enum eESCAPE
    {
        eESCAPEillegalxml,
        eESCAPEnone,
        eESCAPEamp,
        eESCAPEapos,//Single quote
        eESCAPEquote,
        eESCAPElt,
        eESCAPEgt,
        eESCAPEashex,
    };
    
// Helper functions
private:
    IAdvancedTableDispenser * Dispenser() {return m_pISTDisp;}
    HRESULT     AppendNewLineWithTabs(ULONG cTabs, IXMLDOMDocument * pXMLDoc, IXMLDOMNode * pNodeToAppend, ULONG cNewlines=1);
    HRESULT     BuildXmlBlob(const TElement * i_pElement, WCHAR * &io_pBuffer, ULONG & io_cchBlobBufferSize, ULONG & io_cchInBlob) const;
    HRESULT     CreateNewNode(IXMLDOMDocument * i_pXMLDoc, IXMLDOMNode * i_pNode_Parent, IXMLDOMNode ** ppNode_New);
    HRESULT     CreateStringFromMultiString(LPCWSTR i_wszMulti, LPWSTR * o_pwszString) const;
    HRESULT     FillInColumn(ULONG iColumn, LPCWSTR pwcText, ULONG ulLen, ULONG dbType, ULONG fMeta, bool &bMatch);
    HRESULT     FillInPKDefaultValue(ULONG i_iColumn, bool & o_bMatch);
    HRESULT     FillInXMLBlobColumn(const TElement & i_Element, bool & o_bMatch);
    HRESULT     FindNodeFromGuidID(IXMLDOMDocument *pXMLDoc, LPCWSTR guidID, IXMLDOMNode **ppNode) const;
    HRESULT     FindSiblingParentNode(IXMLDOMElement * i_pElementRoot, IXMLDOMNode ** o_ppNode_SiblingParent);
    HRESULT     GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, GUID &o_guid);
    HRESULT     GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, unsigned char * &o_byArray, unsigned long &o_cbArray);
    HRESULT     GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, unsigned long &o_ui4);
    HRESULT     GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, GUID &o_guid, unsigned long i_cchLen=0);
    HRESULT     GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned char * &o_byArray, unsigned long &o_cbArray, unsigned long i_cchLen=0);
    HRESULT     GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long &o_ui4, unsigned long i_cchLen=0);
    eESCAPE     GetEscapeType(WCHAR i_wChar) const;
    HRESULT     GetMatchingNode(IXMLDOMNodeList *pNodeList_ExistingRows, CComPtr<IXMLDOMNode> &pNode_Matching);
    HRESULT     GetMetaTable(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, CComPtr<ISimpleTableRead2> &pMetaTable) const;
    HRESULT     GetResursiveColumnPublicName(tTABLEMETARow &i_TableMetaRow, tCOLUMNMETARow &i_ColumnMetaRow, ULONG i_iColumn, wstring &o_wstrColumnPublicName,  TPublicRowName &o_ColumnPublicRowName, unsigned int & o_nLevelOfColumnAttribute, wstring &o_wstrChildElementName);
    HRESULT     InsertNewLineWithTabs(ULONG i_cTabs, IXMLDOMDocument * i_pXMLDoc, IXMLDOMNode * i_pNodeInsertBefore, IXMLDOMNode * i_pNodeParent);
    HRESULT     InternalComplicatedInitialize(LPCWSTR i_wszDatabase);
    inline HRESULT InternalSetWriteColumn(ISimpleTableWrite2 *pISTW2, ULONG i_iRow, ULONG i_iColumn, ULONG i_cbSize, LPVOID i_pvValue)
                    {return pISTW2->SetWriteColumnValues(i_iRow, 1, &i_iColumn, &i_cbSize, &i_pvValue);}
    bool        IsBaseElementLevelNode(IXMLDOMNode * i_pNode);
    bool        IsContainedTable() const {return 0!=(*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_ISCONTAINED);}
    HRESULT     IsCorrectXMLSchema(IXMLDOMDocument *pXMLDoc) const;
    bool        IsEnumPublicRowNameTable() const {return (-1 != m_iPublicRowNameColumn);}
    HRESULT     IsMatchingColumnValue(ULONG i_iColumn, LPCWSTR i_wszColumnValue, bool & o_bMatch);
    bool        IsNameValueTable() const {return (*m_TableMetaRow.pMetaFlags & fTABLEMETA_NAMEVALUEPAIRTABLE) ? true : false;}
    bool        IsScopedByTableNameElement() const {return 0==(*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME);}
    HRESULT     LoadDocumentFromURL(IXMLDOMDocument *pXMLDoc);
    int         MemWcharCmp(ULONG i_iColumn, LPCWSTR i_str1, LPCWSTR i_str2, ULONG i_cch) const;
    HRESULT     MemCopyPlacingInEscapedChars(LPWSTR o_DestinationString, LPCWSTR i_SourceString, ULONG i_cchSourceString, ULONG & o_cchCopied) const;
    HRESULT     MyPopulateCache(ISimpleTableWrite2* i_pISTW2);
    HRESULT     MyUpdateStore(ISimpleTableWrite2* i_pISTW2);
    HRESULT     ObtainPertinentRelationMetaInfo();
    HRESULT     ObtainPertinentTableMetaInfo();
    HRESULT     ObtainPertinentTagMetaInfo();
    HRESULT     ParseXMLFile(IXMLDOMDocument *pXMLDoc, bool bValidating=true);
    HRESULT     ReduceNodeListToThoseNLevelsDeep(IXMLDOMNodeList * i_pNodeList, ULONG i_nLevel, IXMLDOMNodeList **o_ppNodeListReduced) const;
    HRESULT     RemoveElementAndWhiteSpace(IXMLDOMNode *pNode);
    HRESULT     ScanAttributesAndFillInColumn(const TElement &i_Element, ULONG i_iColumn, bool &o_bMatch);
    HRESULT     SetArraysToSize();
    HRESULT     SetColumnValue(unsigned long i_iColumn, IXMLDOMElement * i_pElement, unsigned long i_ui4);
    HRESULT     SetRowValues(IXMLDOMNode *pNode_Row, IXMLDOMNode *pNode_RowChild=0);
    int         SizeOf(LPCWSTR wsz) const {return (int)(wcslen(wsz)+1)*sizeof(WCHAR);}
    inline int  StringInsensitiveCompare(LPCWSTR sz1, LPCWSTR sz2) const
                {
                    return _wcsicmp(sz1, sz2);
                }
    inline int  StringCompare(LPCWSTR sz1, LPCWSTR sz2) const
                {
                    if(*sz1 != *sz2)
                        return -1;
                    return wcscmp(sz1, sz2);
                }
    inline int  StringCompare(ULONG i_iColumn, LPCWSTR sz1, LPCWSTR sz2) const
                {
                    if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_CASEINSENSITIVE)
                        return StringInsensitiveCompare(sz1, sz2);
                    return StringCompare(sz1, sz2);
                }
    HRESULT     ValidateWriteCache(ISimpleTableController* i_pISTController, ISimpleTableWrite2* i_pISTW2, bool & o_bDetailedError);
    HRESULT     XMLDelete(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows);
    HRESULT     XMLInsert(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows);
    HRESULT     XMLUpdate(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows);
// Private member variables
private:
    static const VARIANT_BOOL kvboolTrue, kvboolFalse;
    ULONG       CountOfColumns() const {ASSERT(m_TableMetaRow.pCountOfColumns);return m_TableMetaRow.pCountOfColumns ? *m_TableMetaRow.pCountOfColumns : 0;}

    class TTagMetaIndex
    {
    public:
        TTagMetaIndex() : m_iTagMeta(-1), m_cTagMeta(0){}
        unsigned long m_iTagMeta;//Index into the TagMeta (for this table)
        unsigned long m_cTagMeta;//Number of tags for this column
    };
    //We list the const members first.
    TComBSTR                            m_bstr_name;
    const LPCWSTR                       m_kXMLSchemaName;           // This is the XML Schema name that is used to validate the XML document

    //We have this problem where we need a bunch of arrays, each of size m_cColumns.  To reduce the number of allocations we'll create these arrays as
    //fixed size and hope that most tables will have no more than m_kColumns.
    enum
    {
        m_kColumns = 10
    };

    //Here are the 'fixed' size arrays
    bool                                    m_fixed_abSiblingContainedColumn[m_kColumns];
    TComBSTR                                m_fixed_abstrColumnNames[m_kColumns];
    TPublicRowName                          m_fixed_aPublicRowName[m_kColumns];
    SimpleColumnMeta                        m_fixed_acolmetas[m_kColumns];
    unsigned int                            m_fixed_aLevelOfColumnAttribute[m_kColumns];
    STQueryCell                             m_fixed_aQuery[m_kColumns];
    LPVOID                                  m_fixed_apvValues[m_kColumns];
    ULONG                                   m_fixed_aSizes[m_kColumns];
    ULONG                                   m_fixed_aStatus[m_kColumns];
    wstring                                 m_fixed_awstrColumnNames[m_kColumns];
    unsigned int                            m_fixed_aColumnsIndexSortedByLevel[m_kColumns];//Node Factory variable (see below)
    unsigned long                           m_fixed_aSize[m_kColumns];                     //Node Factory variable (see below)
    unsigned char *                         m_fixed_apValue[m_kColumns];                   //Node Factory variable (see below)
    TTagMetaIndex                           m_fixed_aTagMetaIndex[m_kColumns];
    unsigned char *                         m_fixed_aDefaultValue[m_kColumns];
    unsigned long                           m_fixed_acbDefaultValue[m_kColumns];
    wstring                                 m_fixed_awstrChildElementName[m_kColumns];       //Some columns are marked as VALUEINCHILDELEMENT, we need to get those attributes from the child element named wszChildElementName
    
    //Here are the 'alloc'd arrays.  These are used when the table has more than m_kColumns columns.
    TSmartPointerArray<bool>                m_alloc_abSiblingContainedColumn;   //This indicates which columns are marked as Sibling containment
    TSmartPointerArray<TComBSTR>            m_alloc_abstrColumnNames;           // Array of ColumnNames
    TSmartPointerArray<TPublicRowName>      m_alloc_aPublicRowName;             // Since some attributes come from higher level elements
    TSmartPointerArray<SimpleColumnMeta>    m_alloc_acolmetas;                  // Array of SimpleColumnMeta determined from Meta info
    TSmartPointerArray<unsigned int>        m_alloc_aLevelOfColumnAttribute;    // For FK columns, this indicates whether the attribute comes from the primary table.  If 1, the attribute exists in the parent.  If 2 it exists in the grand parent.  Currently 0,1 & 2 are the only legel values.
    TSmartPointerArray<STQueryCell>         m_alloc_aQuery;                     //@@@ We currently support one query cell per column.  This is bogus; but easier to implement for now.
    TSmartPointerArray<LPVOID>              m_alloc_apvValues;                  // Array of void pointers, this is useful getting all of the columns in a table.
    TSmartPointerArray<ULONG>               m_alloc_aSizes;                     // Array of sizes, useful when getting all of the columns
    TSmartPointerArray<ULONG>               m_alloc_aStatus;                    // Array of status, useful when getting all of the columns
    TSmartPointerArray<wstring>             m_alloc_awstrColumnNames;           // Same as the BSTR array above, except this doesn't require OleAut32.dll.  This makes for a smaller working set in the read only case.
    TSmartPointerArray<unsigned int>        m_alloc_aColumnsIndexSortedByLevel; // Node Factory variable (see below)
    TSmartPointerArray<unsigned long>       m_alloc_aSize;                      // Node Factory variable (see below)
    TSmartPointerArray<unsigned char *>     m_alloc_apValue;  //This is the row cache.  Each column has a growable buffer.  NOTICE! Only that array is a SmartPointer, so each column value buffer has to be deleted after the last row is populated.
    TSmartPointerArray<TTagMetaIndex>       m_alloc_aTagMetaIndex;
    TSmartPointerArray<unsigned char *>     m_alloc_aDefaultValue;
    TSmartPointerArray<unsigned long>       m_alloc_acbDefaultValue;
    TSmartPointerArray<wstring>             m_alloc_awstrChildElementName;       //Some columns are marked as VALUEINCHILDELEMENT, we need to get those attributes from the child element named wszChildElementName

    //These either point to the 'fixed' size arrays when the table has m_kColumns or less, or the 'alloc'd arrays when the talbe has more than m_kColumns
    bool             *                      m_abSiblingContainedColumn;      
    TComBSTR         *                      m_abstrColumnNames;      
    TPublicRowName   *                      m_aPublicRowName;    
    SimpleColumnMeta *                      m_acolmetas;             
    unsigned int     *                      m_aLevelOfColumnAttribute;
    STQueryCell      *                      m_aQuery;                
    LPVOID           *                      m_apvValues;             
    ULONG            *                      m_aSizes;                
    ULONG            *                      m_aStatus;               
    wstring          *                      m_awstrColumnNames;
    unsigned int     *                      m_aColumnsIndexSortedByLevel;       // Node Factory variable. This is needed so we get the ancestor tables first.
    unsigned long    *                      m_aSize;                            // Node Factory variable. This is the size of the m_apValue buffer.
    unsigned char    **                     m_apValue;                          // Node Factory variable. This is the row cache.  Each column has a growable buffer.  NOTICE! Only that array is a SmartPointer, so each column value buffer has to be deleted after the last row is populated.
    TTagMetaIndex    *                      m_aTagMetaIndex;                    // Array of indexes into the TagMeta each column that has TagMeta will have a non ~0 value
    unsigned char    **                     m_aDefaultValue;
    unsigned long    *                      m_acbDefaultValue;
    wstring          *                      m_awstrChildElementName;
    
    TSmartPointerArray<tTAGMETARow>     m_aTagMetaRow;              // This is a copy of the TagMeta for this table. m_aiTagMeta for each column points into this array if the column has tag meta
    TSmartPointerArray<ULONG>           m_saiPKColumns;
    ULONG                               m_BaseElementLevel;
    bool                                m_bAtCorrectLocation;       // If the query is for a table within a particular location, then this bool indicates whether we've found the correct location
    bool                                m_bEnumPublicRowName_ContainedTable_ParentFound;
    bool                                m_bEnumPublicRowName_NotContainedTable_ParentFound;//This is to keep track of the parent of this special kind of table.  And when we reach a close tag for the parent we can bail.
    bool                                m_bInsideLocationTag;
    bool                                m_bIsFirstPopulate;         //If m_bIsFirstPopulate and LOS_UNPOPULATED then create an empty cache.
    bool                                m_bMatchingParentOfBasePublicRowElement;// If the parent element isn't what it's supposed to be then we ignore all its children
    bool                                m_bSiblingContainedTable;   // This indicates whether this table is a SiblingContainedTable (its parent table is found in the sibling element instead of the parent element)
    TComBSTR                            m_bstrPublicTableName;      // These come from the table meta
    TComBSTR                            m_bstrPublicRowName;        // There is a need for the base PublicRowName aside from the array of PublicRowNames above
    bool                                m_bValidating;              // If we don't validate, then the parse should be a bit faster
    ULONG                               m_cCacheMiss;
    ULONG                               m_cCacheHit;
    ULONG                               m_cchLocation;              // If we're querying for a table within a particular location, this will be Non zero
    ULONG                               m_cchTablePublicName;       // This makes comparing the Table's PublicName a faster, becuase we can first compare the strlen
    ULONG                               m_cPKs;
    ULONG                               m_cRef;                     // Interface reference count.
    ULONG                               m_cTagMetaValues;           // Count Of TagMeta entries for the table
    DWORD                               m_fCache;                   // Cache flags.
    ULONG                               m_iCol_TableRequiresAdditionChildElement;//This is an index to a column that comes fromt the child.  Needed to Inserts.
    ULONG                               m_iCurrentUpdateRow;
    unsigned int                        m_iPublicRowNameColumn;     // Some tables use an enum value as the public row name, this is an index to the column with the enum.  If this is not one of those types of tables, then this value is -1.
    LONG                                m_IsIntercepted;            // Table flags (from caller).
    unsigned long                       m_iSortedColumn;//This indicates which column we're looking for.  We look for columns in order of
                                                        //their relative level to the base public row.  So the most ancestor attributes are
                                                        //matched first.
    ULONG                               m_iSortedFirstChildLevelColumn;   // For use with SiblingContainedTables.  This is an index to the first column that comes from the child most element
    ULONG                               m_iSortedFirstParentLevelColumn;  // For use with SiblingContainedTables.  This is an index to the first column that comes from the sibling parent
    ULONG                               m_iXMLBlobColumn;           // -1 if no XML Blob column exists
    ULONG                               m_fLOS;                     // Remember if READONLY and fail UpdateStore if it is.
    ULONG                               m_one;
    CComPtr<IAdvancedTableDispenser>    m_pISTDisp; 
    CComPtr<IXMLDOMNode>                m_pLastPrimaryTable;
    CComPtr<IXMLDOMNode>                m_pLastParent;
    CComPtr<ISimpleTableRead2>          m_pTableMeta;
    CComPtr<ISimpleTableRead2>          m_pTagMeta;
    TSmartPointerArray<WCHAR>           m_saLocation;
    CComPtr<ISimpleTableWrite2>         m_spISTError;
    tTABLEMETARow                       m_TableMetaRow;
    ULONG                               m_two;
    LPCWSTR                             m_wszTable;                 // The Table ID is given to us in the query (as a GUID pointer of course)


    const unsigned long                 m_kPrime;

    unsigned long                       m_LevelOfBasePublicRow;
    ISimpleTableWrite2 *                m_pISTW2;       //This is valid only during OnPopulate.  It is required since NodeFactory doesn't pass back user data.
    TXmlParsedFile     *                m_pXmlParsedFile;
    TXmlParsedFile                      m_XmlParsedFile;//This one is used if no caching is done

    static LONG                         m_InsertUnique;

    //This static member is guarded by a critical section.  The only time it needs to be guarded is when allocating.
    static TXmlParsedFileCache          m_XmlParsedFileCache;
    static CSafeAutoCriticalSection     m_SACriticalSection_XmlParsedFileCache;

};


#endif //__SDTREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\sdtxml.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
//  SDTxml.cpp : Implementation of CXmlSDT

//  This is a read/write data table that comes from an XML document.

#include "SDTxml.h"

#define USE_NONCRTNEW
#define USE_ADMINASSERT
#include "atlimpl.cpp"
#ifndef _CATALOGMACROS
    #include "catmacros.h"
#endif
#ifndef __catalog_h__
    #include "catalog.h"
#endif
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif
#ifndef __HASH_H__
    #include "Hash.h"
#endif
#ifndef __STRINGROUTINES_H__
    #include "StringRoutines.h"
#endif
#ifndef __TXMLDOMNODELIST_H__
    #include "TXMLDOMNodeList.h"
#endif

#include "SvcMsg.h"


extern HMODULE g_hModule;

TXmlParsedFileCache CXmlSDT::m_XmlParsedFileCache;
CSafeAutoCriticalSection  CXmlSDT::m_SACriticalSection_XmlParsedFileCache;
const VARIANT_BOOL  CXmlSDT::kvboolTrue = -1;
const VARIANT_BOOL  CXmlSDT::kvboolFalse=  0;

LONG                CXmlSDT::m_InsertUnique=0x00490056;

#define LOG_POPULATE_ERROR1(x, hr, str1)     LOG_ERROR(Interceptor,(&m_spISTError.p,                       /*ppErrInterceptor*/ \
                                                                    m_pISTDisp,                            /*pDisp           */ \
                                                                    hr,                                    /*hrErrorCode     */ \
                                                                    ID_CAT_CAT,                            /*ulCategory      */ \
                                                                    x,                                     /*ulEvent         */ \
                                                                    str1,                                  /*szString1       */ \
                                                                    eSERVERWIRINGMETA_Core_XMLInterceptor, /*ulInterceptor   */ \
                                                                    m_wszTable,                            /*szTable         */ \
                                                                    eDETAILEDERRORS_Populate,              /*OperationType   */ \
                                                                    -1,                                    /*ulRow           */ \
                                                                    -1,                                    /*ulColumn        */ \
                                                                    m_wszURLPath,                          /*szConfigSource  */ \
                                                                    eDETAILEDERRORS_ERROR,                 /*eType           */ \
                                                                    0,                                     /*pData           */ \
                                                                    0,                                     /*cbData          */ \
                                                                    0,                                     /*MajorVersion    */ \
                                                                    0))                                    /*MinorVersion    */
        
#define LOG_POPULATE_ERROR4(x, hr, str1, str2, str3, str4)  LOG_ERROR(Interceptor,                                              \
                                                                   (&m_spISTError.p,                       /*ppErrInterceptor*/ \
                                                                    m_pISTDisp,                            /*pDisp           */ \
                                                                    hr,                                    /*hrErrorCode     */ \
                                                                    ID_CAT_CAT,                            /*ulCategory      */ \
                                                                    x,                                     /*ulEvent         */ \
                                                                    str1,                                  /*szString1       */ \
                                                                    str2,                                  /*szString2       */ \
                                                                    str3,                                  /*szString3       */ \
                                                                    str4,                                  /*szString4       */ \
                                                                    eSERVERWIRINGMETA_Core_XMLInterceptor, /*ulInterceptor   */ \
                                                                    m_wszTable,                            /*szTable         */ \
                                                                    eDETAILEDERRORS_Populate,              /*OperationType   */ \
                                                                    -1,                                    /*ulRow           */ \
                                                                    -1,                                    /*ulColumn        */ \
                                                                    m_wszURLPath,                          /*szConfigSource  */ \
                                                                    eDETAILEDERRORS_ERROR,                 /*eType           */ \
                                                                    0,                                     /*pData           */ \
                                                                    0,                                     /*cbData          */ \
                                                                    -1,                                    /*MajorVersion    */ \
                                                                    -1))                                   /*MinorVersion    */

#define LOG_UPDATE_ERROR1(x, hr, col, str1)     LOG_ERROR(Interceptor,(&m_spISTError.p,                       /*ppErrInterceptor*/ \
                                                                    m_pISTDisp,                            /*pDisp           */ \
                                                                    hr,                                    /*hrErrorCode     */ \
                                                                    ID_CAT_CAT,                            /*ulCategory      */ \
                                                                    x,                                     /*ulEvent         */ \
                                                                    str1,                                  /*szString1       */ \
                                                                    eSERVERWIRINGMETA_Core_XMLInterceptor, /*ulInterceptor   */ \
                                                                    m_wszTable,                            /*szTable         */ \
                                                                    eDETAILEDERRORS_UpdateStore,           /*OperationType   */ \
                                                                    m_iCurrentUpdateRow,                   /*ulRow           */ \
                                                                    col,                                   /*ulColumn        */ \
                                                                    m_wszURLPath,                          /*szConfigSource  */ \
                                                                    eDETAILEDERRORS_ERROR,                 /*eType           */ \
                                                                    0,                                     /*pData           */ \
                                                                    0,                                     /*cbData          */ \
                                                                    -1,                                    /*MajorVersion    */ \
                                                                    -1))                                   /*MinorVersion    */
        
#define LOG_UPDATE_ERROR2(x, hr, col, str1, str2)   LOG_ERROR(Interceptor,(&m_spISTError.p,                       /*ppErrInterceptor*/ \
                                                                    m_pISTDisp,                            /*pDisp           */ \
                                                                    hr,                                    /*hrErrorCode     */ \
                                                                    ID_CAT_CAT,                            /*ulCategory      */ \
                                                                    x,                                     /*ulEvent         */ \
                                                                    str1,                                  /*szString1       */ \
                                                                    str2,                                  /*szString2       */ \
                                                                    eSERVERWIRINGMETA_Core_XMLInterceptor, /*ulInterceptor   */ \
                                                                    m_wszTable,                            /*szTable         */ \
                                                                    eDETAILEDERRORS_UpdateStore,           /*OperationType   */ \
                                                                    m_iCurrentUpdateRow,                   /*ulRow           */ \
                                                                    col,                                   /*ulColumn        */ \
                                                                    m_wszURLPath,                          /*szConfigSource  */ \
                                                                    eDETAILEDERRORS_ERROR,                 /*eType           */ \
                                                                    0,                                     /*pData           */ \
                                                                    0,                                     /*cbData          */ \
                                                                    -1,                                    /*MajorVersion    */ \
                                                                    -1))                                   /*MinorVersion    */
        
HRESULT TXmlSDTBase::GetURLFromString(LPCWSTR wsz)
{
    if(NULL == wsz)
        return E_ST_OMITDISPENSER;

    m_wszURLPath[m_kcwchURLPath-1] = 0x00;//make sure it's NULL terminated
    wcsncpy(m_wszURLPath, wsz, m_kcwchURLPath);

    if(m_wszURLPath[m_kcwchURLPath-1] != 0x00)
        return E_ST_OMITDISPENSER;

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// CXmlSDT
// Constructor and destructor
// ==================================================================
CXmlSDT::CXmlSDT() :    
                m_acolmetas(0)
                ,m_apValue(0)
                ,m_BaseElementLevel(0)
                ,m_bAtCorrectLocation(true)
                ,m_bEnumPublicRowName_ContainedTable_ParentFound(false)
                ,m_bEnumPublicRowName_NotContainedTable_ParentFound(false)
                ,m_bInsideLocationTag(false)
                ,m_bIsFirstPopulate(true)
                ,m_bMatchingParentOfBasePublicRowElement(true)
                ,m_bSiblingContainedTable(false)
                ,m_bValidating(true)
                ,m_cCacheHit(0)
                ,m_cCacheMiss(0)
                ,m_cchLocation(0)
                ,m_cchTablePublicName(0)
                ,m_cPKs(0)
                ,m_cRef(0)
                ,m_cTagMetaValues(0)
                ,m_fCache(0)
                ,m_iCurrentUpdateRow(-1)
                ,m_iPublicRowNameColumn(-1)
                ,m_IsIntercepted(0)
                ,m_iCol_TableRequiresAdditionChildElement(-1)
                ,m_iSortedColumn(0)
                ,m_iSortedFirstChildLevelColumn(-1)
                ,m_iSortedFirstParentLevelColumn(-1)
                ,m_iXMLBlobColumn(-1)
                ,m_LevelOfBasePublicRow(0)
                ,m_one(1)
                ,m_kPrime(97)
                ,m_kXMLSchemaName(L"ComCatMeta_v6")
                ,m_fLOS(0)
                ,m_pISTDisp(0)
                ,m_pISTW2(0)
                ,m_two(2)
                ,m_wszTable(0)
                ,m_pXmlParsedFile(0)
{
    m_wszURLPath[0] = 0x00;
    memset(&m_TableMetaRow, 0x00, sizeof(m_TableMetaRow));
}

// ==================================================================
CXmlSDT::~CXmlSDT()
{
    if(m_acolmetas && m_aQuery)
        for(unsigned long iColumn=0; iColumn<CountOfColumns(); ++iColumn)
        {
            switch(m_acolmetas[iColumn].dbType)
            {
            case DBTYPE_UI4:
                delete reinterpret_cast<ULONG *>(m_aQuery[iColumn].pData);
                break;
            case DBTYPE_WSTR:
                delete [] reinterpret_cast<LPWSTR>(m_aQuery[iColumn].pData);
                break;
            }
        }

    if(m_apValue)
        for(unsigned long iColumn=0; iColumn<CountOfColumns(); ++iColumn)
            delete [] m_apValue[iColumn];
}



HRESULT CXmlSDT::AppendNewLineWithTabs(ULONG cTabs, IXMLDOMDocument * pXMLDoc, IXMLDOMNode * pNodeToAppend, ULONG cNewlines)
{
    ASSERT(cTabs<200);
    ASSERT(cNewlines<25);

    HRESULT hr;

    WCHAR wszNewlineWithTabs[256];
    WCHAR *pwszCurrent = wszNewlineWithTabs;

    //This makes the table element tabbed in once.  The 0th sorted column tells how deep to additionally tab in.
    while(cNewlines--)
    {
        *pwszCurrent++ = L'\r';
        *pwszCurrent++ = L'\n';
    }

    while(cTabs--)
        *pwszCurrent++ = L'\t';

    *pwszCurrent = 0x00;//NULL terminate it

    CComPtr<IXMLDOMText>    pNode_Newline;
    TComBSTR                bstrNewline(wszNewlineWithTabs);
    if(FAILED(hr = pXMLDoc->createTextNode(bstrNewline, &pNode_Newline)))return hr;
    return pNodeToAppend->appendChild(pNode_Newline, 0);
}


//This is called recursively
HRESULT CXmlSDT::BuildXmlBlob(const TElement * i_pElement, WCHAR * &io_pBuffer, ULONG & io_cchBlobBufferSize, ULONG & io_cchInBlob) const
{
    HRESULT hr;
    ULONG   ulLevelOfBlobRoot = i_pElement->m_LevelOfElement;

    while(i_pElement && i_pElement->IsValid() && i_pElement->m_LevelOfElement>=ulLevelOfBlobRoot)
    {
        switch(i_pElement->m_ElementType)
        {
        case XML_COMMENT:
            {
                // ASSERT(i_pElement->m_LevelOfElement > pElementThis->m_LevelOfElement);//we can't have a comment at the same level

                ULONG cchSizeRequired = 7+io_cchInBlob+i_pElement->m_ElementNameLength;
                if(cchSizeRequired > io_cchBlobBufferSize)
                {
                    io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                    io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                    if(0 == io_pBuffer)
                        return E_OUTOFMEMORY;
                }
                io_pBuffer[io_cchInBlob++] = L'<';
                io_pBuffer[io_cchInBlob++] = L'!';
                io_pBuffer[io_cchInBlob++] = L'-';
                io_pBuffer[io_cchInBlob++] = L'-';

                memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength * sizeof(WCHAR));
                io_cchInBlob += i_pElement->m_ElementNameLength;
            
                io_pBuffer[io_cchInBlob++] = L'-';
                io_pBuffer[io_cchInBlob++] = L'-';
                io_pBuffer[io_cchInBlob++] = L'>';
            }
            break;
        case XML_ELEMENT:
            {
                if(fEndTag == (i_pElement->m_NodeFlags & fBeginEndTag))//if we found the end tag
                {
                    //Now fill out the closing tag for this element
                    ULONG cchSizeRequired = 3+io_cchInBlob+i_pElement->m_ElementNameLength;
                    if(cchSizeRequired > io_cchBlobBufferSize)
                    {
                        io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                        io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                        if(0 == io_pBuffer)
                            return E_OUTOFMEMORY;
                    }
                    //Full closing tag  (ie <Element attr="foo">x</Element>)
                    io_pBuffer[io_cchInBlob++] = L'<';
                    io_pBuffer[io_cchInBlob++] = L'/';

                    memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength * sizeof(WCHAR));
                    io_cchInBlob += i_pElement->m_ElementNameLength;

                    io_pBuffer[io_cchInBlob++] = L'>';
                    if(i_pElement->m_LevelOfElement==ulLevelOfBlobRoot)
                        goto exit;
                }
                else //begin tag (or maybe and begin/end tag)
                {
                    ULONG cchSizeRequired = io_cchInBlob+2+i_pElement->m_ElementNameLength;//+2 so we have room for the '/>'
                    if(cchSizeRequired > io_cchBlobBufferSize)
                    {
                        io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                        io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                        if(0 == io_pBuffer)
                            return E_OUTOFMEMORY;
                    }
                    //Start building the XML Blob from this element
                    io_pBuffer[io_cchInBlob++] = L'<';
                    memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength * sizeof(WCHAR));
                    io_cchInBlob += i_pElement->m_ElementNameLength;

                    for(ULONG iAttr=0;iAttr<i_pElement->m_NumberOfAttributes;++iAttr)
                    {
                        //Do we need to grow the buffer (the 5 is for the 4 chars inside the for loop, and one more for the L'>'). The 7 is to account for the
                        //possibility that ALL characters need to be escaped.
                        ULONG cchSizeRequired = 5+io_cchInBlob+i_pElement->m_aAttribute[iAttr].m_NameLength+7*(i_pElement->m_aAttribute[iAttr].m_ValueLength);
                        if(cchSizeRequired > io_cchBlobBufferSize)
                        {
                            io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                            io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                            if(0 == io_pBuffer)
                                return E_OUTOFMEMORY;
                        }

                        io_pBuffer[io_cchInBlob++] = L' ';
                        memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_aAttribute[iAttr].m_Name, i_pElement->m_aAttribute[iAttr].m_NameLength * sizeof(WCHAR));
                        io_cchInBlob += i_pElement->m_aAttribute[iAttr].m_NameLength;
                        io_pBuffer[io_cchInBlob++] = L'=';
                        io_pBuffer[io_cchInBlob++] = L'\"';
                        //if non of the characters are escaped chars then it's just a memcpy
                        ULONG cchCopied;
                        if(FAILED(hr = MemCopyPlacingInEscapedChars(io_pBuffer+io_cchInBlob, i_pElement->m_aAttribute[iAttr].m_Value, i_pElement->m_aAttribute[iAttr].m_ValueLength, cchCopied)))
                            return hr;
                        io_cchInBlob += cchCopied;
                        io_pBuffer[io_cchInBlob++] = L'\"';
                    }
                    if(fBeginEndTag == (i_pElement->m_NodeFlags & fBeginEndTag))
                        io_pBuffer[io_cchInBlob++] = L'/';
                    io_pBuffer[io_cchInBlob++] = L'>';
                }
            }
            break;
        case XML_WHITESPACE://and it's treated exactly like whitespaces
            {
                ULONG cchSizeRequired = io_cchInBlob+i_pElement->m_ElementNameLength;
                if(cchSizeRequired > io_cchBlobBufferSize)
                {
                    io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                    io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                    if(0 == io_pBuffer)
                        return E_OUTOFMEMORY;
                }
                memcpy(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength * sizeof(WCHAR));
                io_cchInBlob += i_pElement->m_ElementNameLength;
            }
            break;
        case XML_PCDATA:    //PCDATA in this context means Element Content
            {                                        //account for escaped characters so worst case is every character is escaped to 7 characters.
                ULONG cchSizeRequired = io_cchInBlob+7*(i_pElement->m_ElementNameLength);
                if(cchSizeRequired > io_cchBlobBufferSize)
                {
                    io_cchBlobBufferSize = ((cchSizeRequired *2) + 0xFFF) & -0x1000;//double and round up to the next page boundary
                    io_pBuffer = reinterpret_cast<WCHAR *>(CoTaskMemRealloc(io_pBuffer, io_cchBlobBufferSize*sizeof(WCHAR)));
                    if(0 == io_pBuffer)
                        return E_OUTOFMEMORY;
                }
                ULONG cchCopied;
                if(FAILED(hr = MemCopyPlacingInEscapedChars(io_pBuffer+io_cchInBlob, i_pElement->m_ElementName, i_pElement->m_ElementNameLength, cchCopied)))
                    return hr;
                io_cchInBlob += cchCopied;
            }
            break;
        default:
            break;//do nothing with node types that we know nothing about
        }
        i_pElement = i_pElement->Next();
    }
exit:
    return S_OK;
}//BuildXmlBlob


HRESULT CXmlSDT::CreateNewNode(IXMLDOMDocument * i_pXMLDoc, IXMLDOMNode * i_pNode_Parent, IXMLDOMNode ** o_ppNode_New)
{
    HRESULT hr;

    //If there is no XMLBlob column, OR the XMLBlob column is NULL, then create one from scratch
    if(-1 == m_iXMLBlobColumn || 0 == m_apvValues[m_iXMLBlobColumn])
    {
        CComVariant varElement(L"element");

        TComBSTR    bstr_NameSpace;
        if(FAILED(hr = i_pNode_Parent->get_namespaceURI(&bstr_NameSpace)))
            return hr;//Get the namespace of the table

        if(!IsEnumPublicRowNameTable())
        {
            if(FAILED(hr = i_pXMLDoc->createNode(varElement, m_bstrPublicRowName, bstr_NameSpace, o_ppNode_New)))
                return hr;//make the new element of that same namespace
        }
        else //If we're using an enum as the public row name
        {
            ULONG ui4 = *reinterpret_cast<ULONG *>(m_apvValues[m_iPublicRowNameColumn]);
            ASSERT(0 != m_aTagMetaIndex[m_iPublicRowNameColumn].m_cTagMeta && "fCOLUMNMETA_ENUM bit set and have no TagMeta");//Not all columns have tagmeta, those elements of the array are set to a count of 0.  Assert this isn't one of those.
                                                 //It is Chewbacca to have the fCOLUMNMETA_ENUM bit set and have no TagMeta.
            unsigned long iTag, cTag;
            for(iTag = m_aTagMetaIndex[m_iPublicRowNameColumn].m_iTagMeta, cTag = m_aTagMetaIndex[m_iPublicRowNameColumn].m_cTagMeta;cTag;++iTag,--cTag)//TagMeta was queried for ALL columns, m_aTagMetaIndex[iColumn].m_iTagMeta indicates which row to start with and m_cTagMeta indicates the count (for this column)
            {
                if(*m_aTagMetaRow[iTag].pValue == ui4)
                {
                    CComBSTR bstrPublicRowName = m_aTagMetaRow[iTag].pPublicName;
                    if(FAILED(hr = i_pXMLDoc->createNode(varElement, bstrPublicRowName, bstr_NameSpace, o_ppNode_New)))
                        return hr;//make the new element of that same namespace
                    break;
                }
            }
            if(0 == cTag)
            {
                WCHAR szUI4[12];
                szUI4[11] = 0x00;
                _ultow(ui4, szUI4, 10);
                LOG_UPDATE_ERROR2(IDS_COMCAT_XML_BOGUSENUMVALUEINWRITECACHE, E_SDTXML_INVALID_ENUM_OR_FLAG, m_iPublicRowNameColumn, m_abstrColumnNames[m_iPublicRowNameColumn].m_str, szUI4);
                return E_SDTXML_INVALID_ENUM_OR_FLAG;
            }
        }
    }
    else//Use the XMLBlob column value as the starting point to the new node
    {
        CComPtr<IXMLDOMDocument> spXmlDoc;
        if(FAILED(hr = CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&spXmlDoc)))
            return hr;

        CComBSTR                 bstrXmlBlob = reinterpret_cast<LPCWSTR>(m_apvValues[m_iXMLBlobColumn]);
        VARIANT_BOOL             bSuccess;
        if(FAILED(hr = spXmlDoc->loadXML(bstrXmlBlob, &bSuccess)))
            return hr;
        if(bSuccess != kvboolTrue)//If the XMLBlob fails to parse, then fail
            return E_SDTXML_XML_FAILED_TO_PARSE;

        CComPtr<IXMLDOMElement>             spElementDoc;
        if(FAILED(hr = spXmlDoc->get_documentElement(&spElementDoc)))
            return hr;

        CComBSTR bstrElementName;
        if(FAILED(hr = spElementDoc->get_tagName(&bstrElementName)))
            return hr;

        if(!m_aPublicRowName[m_iXMLBlobColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length()))
            return E_SDTXML_XML_FAILED_TO_PARSE;

        if(FAILED(hr = spElementDoc->QueryInterface(IID_IXMLDOMNode, reinterpret_cast<void **>(o_ppNode_New))))
            return hr;
    }
    return S_OK;
}


//=================================================================================
// Function: CXmlSDT::CreateStringFromMultiString
//
// Synopsis: Creates a string from a multistring. Every \0 is replaced with a pipe ('|')
//           symbol, and every '|' symbol is escaped with another '|' symbol
//
// Arguments: [i_wszMulti] - multi string to convert
//            [o_pwszString] - string that represents the multistring. Caller is 
//                             responsible for deleting the string
//            
//=================================================================================
HRESULT 
CXmlSDT::CreateStringFromMultiString(LPCWSTR i_wszMulti, LPWSTR * o_pwszString) const
{
    ASSERT (i_wszMulti != 0);
    ASSERT (o_pwszString != 0);

    // initialize the output variable
    *o_pwszString = 0;

    // get the length of the multistring
    SIZE_T iLen = 0;
    for (LPCWSTR pCur = i_wszMulti; *pCur != L'\0'; pCur = i_wszMulti + iLen)
    {
         iLen += wcslen (pCur) + 1;
    }

    if (iLen == 0)
        return S_OK;

    // because '|' is replace by '||', we need to allocate twice the amount of memory
    *o_pwszString = new WCHAR [iLen * 2];
    if (*o_pwszString == 0)
    {
        return E_OUTOFMEMORY;
    }

    ULONG insertIdx=0;
    for (ULONG idx = 0; idx < iLen; ++idx)
    {
        switch (i_wszMulti[idx])
        {
        case L'|':
            // add additional pipe character
            (*o_pwszString)[insertIdx++] = L'|';
            break;

        case L'\0':
            // pipe character is separator
            (*o_pwszString)[insertIdx++] = L'|';
            continue;
            
        default:
            // do nothing;
            break;
        }
        (*o_pwszString)[insertIdx++] = i_wszMulti[idx];
    }


    // replace last char with null terminator
    (*o_pwszString)[insertIdx-1] = L'\0';

    return S_OK;
}


HRESULT CXmlSDT::FillInColumn(ULONG iColumn, LPCWSTR pwcText, ULONG ulLen, ULONG dbType, ULONG MetaFlags, bool &bMatch)
{
    HRESULT hr;
    //length of 0 on a string means a 0 length string, for every other type it means NULL
    if(0==ulLen && DBTYPE_WSTR!=dbType)
    {
        delete [] m_apValue[iColumn];
        m_aSize[iColumn] = 0;
        m_apValue[iColumn] = 0;
        return S_OK;
    }

    switch(dbType)                          //This is to prevent string compare from AVing on NULL parameter.
    {
    case DBTYPE_UI4:
        {
            DWORD       ui4;
            if(FAILED(hr = GetColumnValue(iColumn, pwcText, ui4, ulLen)))return hr;
                        //If the Query's dbType is 0 then we're not querying this column, so consider it a match
            if(bMatch = (0 == m_aQuery[iColumn].dbType || *reinterpret_cast<ULONG *>(m_aQuery[iColumn].pData) == ui4))
            {
                delete [] m_apValue[iColumn];
                m_aSize[iColumn] = 0;
                m_apValue[iColumn] = new unsigned char [sizeof(ULONG)];
                if(0 == m_apValue[iColumn])
                    return E_OUTOFMEMORY;
                if(MetaFlags & fCOLUMNMETA_FIXEDLENGTH)
                    m_aSize[iColumn] = sizeof(ULONG);
                memcpy(m_apValue[iColumn], &ui4, sizeof(ULONG));
            }
            break;
        }
    case DBTYPE_WSTR:
        if(MetaFlags & fCOLUMNMETA_MULTISTRING)
        {
            if(bMatch = (0 == m_aQuery[iColumn].dbType || 0 == MemWcharCmp(iColumn, reinterpret_cast<LPWSTR>(m_aQuery[iColumn].pData), pwcText, ulLen)))
            {
                delete [] m_apValue[iColumn];
                m_aSize[iColumn] = 0;
                m_apValue[iColumn] = new unsigned char [(ulLen + 2) * sizeof(WCHAR)];//ulLen + 2.  Since this is a multisz we need two NULLs at the end (this is worst case, single string needing a second NULL)
                if(0 == m_apValue[iColumn])
                    return E_OUTOFMEMORY;

                LPWSTR pMultiSZ = reinterpret_cast<LPWSTR>(m_apValue[iColumn]);

                //Now convert the '|'s to NULLs and conver the "||"s to '|'
                for(ULONG iMultiSZ=0; iMultiSZ<ulLen; ++iMultiSZ)
                {
                    if(pwcText[iMultiSZ] != L'|')
                        *pMultiSZ++ = pwcText[iMultiSZ];
                    else if(pwcText[iMultiSZ+1] == L'|')
                    {
                        *pMultiSZ++ = L'|';//Bump the index again, this is the only double character that gets mapped to a single character
                        ++iMultiSZ;
                    }
                    else
                        *pMultiSZ++ = 0x00;
                }
                *pMultiSZ++ = 0x00;
                *pMultiSZ++ = 0x00;
                m_aSize[iColumn] = (ULONG) ((reinterpret_cast<unsigned char *>(pMultiSZ) - reinterpret_cast<unsigned char *>(m_apValue[iColumn])));
            }
            break;
        }
        else
        {
            bMatch = false;
            if (0 == m_aQuery[iColumn].dbType)
            {
                bMatch = true;
            }
            else
            {
                LPCWSTR wszData = reinterpret_cast<LPWSTR>(m_aQuery[iColumn].pData);
                if ((wcslen (wszData) == ulLen) &&
                    (0 == MemWcharCmp(iColumn, wszData, pwcText, ulLen)))
                {
                    bMatch = true;
                }
            }

            if (bMatch)
            {
                delete [] m_apValue[iColumn];
                m_aSize[iColumn] = 0;
                m_apValue[iColumn] = new unsigned char [(ulLen + 1) * sizeof(WCHAR)];
                if(0 == m_apValue[iColumn])
                    return E_OUTOFMEMORY;
                reinterpret_cast<LPWSTR>(m_apValue[iColumn])[ulLen] = 0;//NULL terminate the thing
                if(MetaFlags & fCOLUMNMETA_FIXEDLENGTH)
                    m_aSize[iColumn] = (ulLen + 1) * sizeof(WCHAR);
                memcpy(m_apValue[iColumn], pwcText, ulLen * sizeof(WCHAR));
            }
            break;
        }
    case DBTYPE_GUID:
        {
            GUID        guid;
            if(FAILED(hr = GetColumnValue(iColumn, pwcText, guid, ulLen)))return hr;
            if(bMatch = (0 == m_aQuery[iColumn].dbType || 0 == memcmp(m_aQuery[iColumn].pData, &guid, sizeof(GUID))))
            {
                delete [] m_apValue[iColumn];
                m_aSize[iColumn] = 0;
                m_apValue[iColumn] = new unsigned char [sizeof(GUID)];
                if(0 == m_apValue[iColumn])
                    return E_OUTOFMEMORY;
                if(MetaFlags & fCOLUMNMETA_FIXEDLENGTH)
                    m_aSize[iColumn] = sizeof(GUID);
                memcpy(m_apValue[iColumn], &guid, sizeof(GUID));
            }
            break;
        }

    case DBTYPE_BYTES:
        {//Some of the tables use this data type but the parser returns the BYTES as a string.  We'll have to convert the string to hex ourselves.
            delete [] m_apValue[iColumn];
            m_apValue[iColumn] = 0;
            m_aSize[iColumn] = 0;
            if(FAILED(hr = GetColumnValue(iColumn, pwcText, m_apValue[iColumn], m_aSize[iColumn], ulLen)))return hr;
            bMatch = (0 == m_aQuery[iColumn].dbType || (m_aQuery[iColumn].cbSize == m_aSize[iColumn] && 0 == memcmp(m_aQuery[iColumn].pData, m_apValue[iColumn], m_aSize[iColumn])));
            break;
        }
    default:
        {
            ASSERT(false && "SDTXML - An Unsupported data type was specified\r\n");
            return E_SDTXML_NOTSUPPORTED;//An Unsupported data type was specified
        }
    }
    return S_OK;
}


HRESULT CXmlSDT::FillInPKDefaultValue(ULONG i_iColumn, bool & o_bMatch)
{
    ASSERT(0 == m_apValue[i_iColumn]);

    o_bMatch = true;
    //Should the value be Defaulted
    if(     (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY)
        &&  0 == (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_MULTISTRING)//we don't deal with MultiSZ PK DefaultValues
        &&  (DBTYPE_BYTES != m_acolmetas[i_iColumn].dbType)//we don't want to deal with the acbSizes issue, so we don't support defaulting DBTYPE_BYTES PK columns
        &&  (0 != m_aDefaultValue[i_iColumn]))
    {
        ASSERT(0 != m_acbDefaultValue[i_iColumn]);//if we have a NON-NULL PK default value pointer, then we have to have a valid size
        m_apValue[i_iColumn] = new unsigned char [m_acbDefaultValue[i_iColumn]];
        if(0 == m_apValue[i_iColumn])
            return E_OUTOFMEMORY;
        memcpy(m_apValue[i_iColumn], m_aDefaultValue[i_iColumn], m_acbDefaultValue[i_iColumn]);
    }

    if(     fCOLUMNMETA_NOTNULLABLE == (m_acolmetas[i_iColumn].fMeta & (fCOLUMNMETA_NOTNULLABLE | fCOLUMNMETA_NOTPERSISTABLE))
        &&  (0 == m_apValue[i_iColumn]) && (0 == m_aDefaultValue[i_iColumn])) //NOTNULLABLE but the value is NULL and the DefaultValue is NULL, then error
    {
        LOG_POPULATE_ERROR1(IDS_COMCAT_XML_NOTNULLABLECOLUMNISNULL, E_ST_VALUENEEDED, m_awstrColumnNames[i_iColumn]);
        return E_ST_VALUENEEDED;
    }

    //The only way m_apValue[i_iColumn] can be NON NULL is for the above code to have filled it in.

    if(0 != m_aQuery[i_iColumn].dbType)//This indicates that there is a query to be considered
    {      
        if(0 != m_aQuery[i_iColumn].pData)//a non NULL value
        {
            if(0 == m_apValue[i_iColumn] && 0 == m_aDefaultValue[i_iColumn])
                o_bMatch = false;//if the query data is NOT NULL but the column IS NULL, then no match
            else
            {
                ASSERT(m_aDefaultValue[i_iColumn]);//We CAN'T have a NON NULL m_apValue and have a NULL DefaultValue.

                //if both the query and the value are NOT NULL, then we need to compare
                //PKs have their default value filled in here; but NON PKs are set to NULL and the fast cache defaults them
                //either way we'll comepare the default value with the query to see if it's a match

                //Now that we've defaulted the PK value, we need to check to see if it matches the Query (if one was given)
                switch(m_acolmetas[i_iColumn].dbType)
                {
                case DBTYPE_UI4:
                    o_bMatch = (*reinterpret_cast<ULONG *>(m_aQuery[i_iColumn].pData) == *reinterpret_cast<ULONG *>(m_aDefaultValue[i_iColumn]));
                    break;
                case DBTYPE_WSTR:
                    ASSERT(0 == (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_MULTISTRING));//We don't support query by MULTISZ
                    o_bMatch = (0==StringCompare(i_iColumn, reinterpret_cast<LPCWSTR>(m_aQuery[i_iColumn].pData), reinterpret_cast<LPCWSTR>(m_aDefaultValue[i_iColumn])));
                    break;
                case DBTYPE_BYTES:
                    o_bMatch =      (m_aQuery[i_iColumn].cbSize == m_acbDefaultValue[i_iColumn])
                                &&  (0 == memcmp(m_aQuery[i_iColumn].pData, m_aDefaultValue[i_iColumn], m_acbDefaultValue[i_iColumn]));
                    break;
                default:
                    ASSERT(false && "Query By unsupported type");//consider it a match
                    break;
                }
            }
        }
        else if(0 == m_aQuery[i_iColumn].pData && (0 != m_apValue[i_iColumn]) || (0 != m_aDefaultValue[i_iColumn]))
           o_bMatch = false;//if the query data is NULL but the column is NOT NULL, then no match
    }

    return S_OK;
}

HRESULT CXmlSDT::FillInXMLBlobColumn(const TElement & i_Element, bool & o_bMatch)
{
    //XML Blob column is this entire element, it's contents, it's children, and it's closing tag
    ULONG                       cchInBlob           = 0;
    ULONG                       cchBlobBufferSize   = 0x1000;//4k buffer to start with
    HRESULT                     hr;
    TSmartPointerArray<WCHAR>   saBlob = reinterpret_cast<WCHAR *>(CoTaskMemAlloc(cchBlobBufferSize * sizeof(WCHAR)));
    if(0 == saBlob.m_p)
        return E_OUTOFMEMORY;

    const TElement * pElement = &i_Element;
    if(FAILED(hr = BuildXmlBlob(pElement, saBlob.m_p, cchBlobBufferSize, cchInBlob)))
        return hr;

    return FillInColumn(m_iXMLBlobColumn, saBlob, cchInBlob, DBTYPE_WSTR, m_acolmetas[m_iXMLBlobColumn].fMeta, o_bMatch);
}


HRESULT CXmlSDT::FindSiblingParentNode(IXMLDOMElement * i_pElementRoot, IXMLDOMNode ** o_ppNode_SiblingParent)
{
    HRESULT hr;

    *o_ppNode_SiblingParent = 0;

    ASSERT(m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstParentLevelColumn]].GetFirstPublicRowName() ==
           m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstParentLevelColumn]].GetLastPublicRowName());//This parent element may not be EnumPublicRowName (for now)

    CComBSTR bstrSiblingParentRowName = m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstParentLevelColumn]].GetFirstPublicRowName();

    CComPtr<IXMLDOMNodeList> spNodeList_SiblingParent;
    //if the sibling parent doesn't exist then fail
    if(FAILED(i_pElementRoot->getElementsByTagName(bstrSiblingParentRowName, &spNodeList_SiblingParent))
                    || 0==spNodeList_SiblingParent.p)
    {                                                                                               /*-1 indicates 'no column'*/
        LOG_UPDATE_ERROR1(IDS_COMCAT_XML_PARENTTABLEDOESNOTEXIST, E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST, -1, bstrSiblingParentRowName);
        return E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST;
    }

    if(0 == m_cchLocation)//if there is no query by location, then we have to eliminate the tags by the correct
    {                     //name but at the wrong level
        CComPtr<IXMLDOMNodeList> spNodeListWithoutLocation;
        if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(spNodeList_SiblingParent, m_BaseElementLevel, &spNodeListWithoutLocation)))
            return hr;

        spNodeList_SiblingParent.Release();
        spNodeList_SiblingParent = spNodeListWithoutLocation;
    }

    while(true)//while we still have nodes in the list of SiblingParents.
    {
        CComPtr<IXMLDOMNode> spNode_SiblingParent;
        if(FAILED(hr = spNodeList_SiblingParent->nextNode(&spNode_SiblingParent)))
            return hr;
        if(0 == spNode_SiblingParent.p)//no locations
        {                                                                                           /*-1 indicates 'no column'*/
            LOG_UPDATE_ERROR1(IDS_COMCAT_XML_PARENTTABLEDOESNOTEXIST, E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST, -1, L"");
            return E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST;
        }

        ULONG iCurrentLevel=0;
        CComPtr<IXMLDOMNode> spNodeTemp = spNode_SiblingParent;
        //from this SiblingParent node, walk the ancestors, matching up the PKs
        bool bColumnMatch=true;
        ASSERT(-1 != m_iSortedFirstChildLevelColumn);
        for(int iSortedColumn=m_iSortedFirstChildLevelColumn-1; iSortedColumn!=-1 && bColumnMatch; --iSortedColumn)
        {
            ULONG iColumn   = m_aColumnsIndexSortedByLevel[iSortedColumn];

            while(iCurrentLevel < m_aLevelOfColumnAttribute[iColumn])
            {
                CComPtr<IXMLDOMNode> pNode_Parent;
                if(FAILED(hr = spNodeTemp->get_parentNode(&pNode_Parent)))
                    return hr;
                if(pNode_Parent==0)
                    return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                spNodeTemp.Release();
                spNodeTemp = pNode_Parent;
                ++iCurrentLevel;
            }
            
            //All columns from 0 to (m_iSortedFirstChildLevelColumn-1) MUST be PrimaryKeys
            ASSERT(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY);

            if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE)
                continue;//if this PK is NOT persistable, then consider it a match and keep going

            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElementTemp = spNodeTemp;
            if(0 == spElementTemp.p)
                return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

            CComVariant varColumnValue;
            if(FAILED(spElementTemp->getAttribute(m_abstrColumnNames[iColumn], &varColumnValue)))
                return hr;//this is a persistable PK so it must exist

            if(FAILED(hr = IsMatchingColumnValue(iColumn, varColumnValue.bstrVal, bColumnMatch)))
                return hr;
        }
        if(bColumnMatch)
        {
            *o_ppNode_SiblingParent = spNode_SiblingParent.p;
            spNode_SiblingParent.p = 0;//prevent the smart pointer from releasing the interface
            return S_OK;
        }
        spNode_SiblingParent.Release();
    }
    return S_OK;
}


HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, GUID &o_guid, unsigned long i_cchLen)
{
    return UuidFromString(const_cast<LPWSTR>(wszAttr), &o_guid);//Then convert it to a guid
}


HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned char * &o_byArray, unsigned long &o_cbArray, unsigned long i_cchLen)
{
    HRESULT     hr;

    o_cbArray = (ULONG)wcslen(wszAttr)/2;//If someone has an odd number of characters in this attribute then the odd one will be ignored
    o_byArray = new unsigned char[o_cbArray];

    if(0 == o_byArray)
        return E_OUTOFMEMORY;

    if(FAILED(hr = StringToByteArray(wszAttr, o_byArray)))
    {
        LOG_POPULATE_ERROR1(IDS_COMCAT_XML_BOGUSBYTECHARACTER, E_ST_VALUEINVALID, wszAttr);
        return E_ST_VALUEINVALID;//E_SDTXML_BOGUSATTRIBUTEVALUE;
    }

    return S_OK;
}

int CXmlSDT::MemWcharCmp(ULONG i_iColumn, LPCWSTR i_str1, LPCWSTR i_str2, ULONG i_cch) const
{
    //It is safe to do the memcmp without verifying that the mem blocks are valid since
    //this is really like a str compare where one of the strings may not be NULL terminated.
    //We know that non of the strings are at the end of a segment since one always comes from
    //the XML cache, and the other comes from a static string or the Fixed tables heap.

	// the documenation of _memicmp says that it compare char's, which is correct. However, when
	// you want to compare WCHARs, you need to multiply with sizeof(WCHAR)
    if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_CASEINSENSITIVE)
        return _memicmp(i_str1, i_str2, i_cch * sizeof(WCHAR));

    return memcmp(i_str1, i_str2, i_cch*sizeof(WCHAR));
}



HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, LPCWSTR wszAttr, unsigned long &o_ui4, unsigned long i_cchLen)
{
    HRESULT hr;

    if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_BOOL)
    {
        static WCHAR * kwszBoolStringsCaseInsensitive[] = {L"false", L"true", L"0", L"1", L"no", L"yes", L"off", L"on", 0};
        static WCHAR * kwszBoolStringsCaseSensitive[]   = {L"false", L"true", 0};

        WCHAR ** wszBoolStrings = kwszBoolStringsCaseSensitive;
        if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_CASEINSENSITIVE)
            wszBoolStrings = kwszBoolStringsCaseInsensitive;

        unsigned long iBoolString;
        if(i_cchLen)
        {
            for(iBoolString=0; wszBoolStrings[iBoolString] &&
                (0 != MemWcharCmp(i_iColumn, wszBoolStrings[iBoolString], wszAttr, i_cchLen)); ++iBoolString);
        }
        else
        {
            ULONG cchAttr = wcslen(wszAttr);//MemCmp needs a strlen
            for(iBoolString=0; wszBoolStrings[iBoolString] &&
                (0 != MemWcharCmp(i_iColumn, wszBoolStrings[iBoolString], wszAttr, cchAttr)); ++iBoolString);
        }

        if(0 == wszBoolStrings[iBoolString])
        {
            LOG_POPULATE_ERROR1(IDS_COMCAT_XML_BOGUSBOOLEANSTRING, E_ST_VALUEINVALID, wszAttr);
            return E_ST_VALUEINVALID;
        }

        o_ui4 = (iBoolString & 0x01);
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_ENUM)
    {
        ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.

        for(unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta, cTag = m_aTagMetaIndex[i_iColumn].m_cTagMeta; cTag;++iTag, --cTag)//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
        {
            ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
            if(i_cchLen)
            {
                if(0 == MemWcharCmp(i_iColumn, m_aTagMetaRow[iTag].pPublicName, wszAttr, i_cchLen))//NOTE: MemCmp 3rd param is cch NOT cb
                {  //As above, it's OK to memicmp since we'll stop at the terminating NULL, and we know that the string isn't located at the end of a segment
                    o_ui4 = *m_aTagMetaRow[iTag].pValue;
                    return S_OK;
                }
            }
            else
            {
                if(0 == StringCompare(i_iColumn, m_aTagMetaRow[iTag].pPublicName, wszAttr))
                {
                    o_ui4 = *m_aTagMetaRow[iTag].pValue;
                    return S_OK;
                }
            }
        }
#ifdef _DEBUG
        {
            WCHAR wszEnum[256];
            wcsncpy(wszEnum, wszAttr, (i_cchLen>0 && i_cchLen<256) ? i_cchLen : 255);
            wszEnum[255] = 0x00;//Make sure it's NULL terminated
            TRACE2(L"Enum (%s) was not found in the TagMeta for Column %d (%s).", wszEnum, i_iColumn, m_awstrColumnNames[i_iColumn]);
        }
#endif
        LOG_POPULATE_ERROR4(IDS_COMCAT_XML_BOGUSENUMVALUE, E_SDTXML_INVALID_ENUM_OR_FLAG,
                            wszAttr,
                            m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta].pPublicName,
                            m_aTagMetaIndex[i_iColumn].m_cTagMeta>1 ? m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta+1].pPublicName : 0,
                            m_aTagMetaIndex[i_iColumn].m_cTagMeta>1 ? m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta+2].pPublicName : 0);
        return  E_SDTXML_INVALID_ENUM_OR_FLAG;
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_FLAG)
    {
        ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.
        if(0==i_cchLen)
            i_cchLen = (ULONG) wcslen(wszAttr);

        TSmartPointerArray<wchar_t> szAttr = new wchar_t [i_cchLen+1];
        if (szAttr == 0)
            return E_OUTOFMEMORY;

        memcpy(szAttr, wszAttr, i_cchLen*sizeof(WCHAR));
        szAttr[i_cchLen]=0x00;
        LPWSTR wszTag = wcstok(szAttr, L" ,|\t\n\r");

        o_ui4 = 0;//flags start as zero
        unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;

        while(wszTag && iTag<(m_aTagMetaIndex[i_iColumn].m_iTagMeta + m_aTagMetaIndex[i_iColumn].m_cTagMeta))//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
        {
            ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
            if(0 == StringCompare(i_iColumn, m_aTagMetaRow[iTag].pPublicName, wszTag))
            {
                o_ui4 |= *m_aTagMetaRow[iTag].pValue;
                wszTag = wcstok(NULL, L" ,|\t\n\r");//next flag
                iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;//reset the loop
            }
            else//if they're not equal then move on to the next TagMeta
                ++iTag;
        }
        if(wszTag)
        {
            LOG_POPULATE_ERROR4(IDS_COMCAT_XML_BOGUSFLAGVALUE, E_SDTXML_INVALID_ENUM_OR_FLAG,
                                wszAttr,
                                m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta].pPublicName,
                                m_aTagMetaIndex[i_iColumn].m_cTagMeta>1 ? m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta+1].pPublicName : 0,
                                m_aTagMetaIndex[i_iColumn].m_cTagMeta>1 ? m_aTagMetaRow[m_aTagMetaIndex[i_iColumn].m_iTagMeta+2].pPublicName : 0);
            return E_SDTXML_INVALID_ENUM_OR_FLAG;
        }
    }
    else
    {
        o_ui4 = static_cast<unsigned long>(wcstoul(wszAttr, 0, 10));
    }
    return S_OK;
}

//Get the UI4 value whether it's an enum, flag or regular ui4
HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, GUID &o_guid)
{
    HRESULT hr;

    CComVariant var_Attr;
    if(FAILED(hr = i_pAttr->get_value(&var_Attr)))return hr;

    return GetColumnValue(i_iColumn, var_Attr.bstrVal, o_guid);
}


HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, unsigned char * &o_byArray, unsigned long &o_cbArray)
{
    HRESULT hr;

    CComVariant          var_Attr;
    if(FAILED(hr = i_pAttr->get_value(&var_Attr)))return hr;

    return GetColumnValue(i_iColumn, var_Attr.bstrVal, o_byArray, o_cbArray);
}


//Get the UI4 value whether it's an enum, flag or regular ui4
HRESULT CXmlSDT::GetColumnValue(unsigned long i_iColumn, IXMLDOMAttribute * i_pAttr, unsigned long &o_ui4)
{
    HRESULT hr;

    CComVariant var_Attr;
    if(FAILED(hr = i_pAttr->get_value(&var_Attr)))return hr;

    return GetColumnValue(i_iColumn, var_Attr.bstrVal, o_ui4);
}


CXmlSDT::eESCAPE CXmlSDT::GetEscapeType(WCHAR i_wChar) const
{
    static eESCAPE kWcharToEscape[0x80] = 
    {
      /* 00-0F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEnone,          eESCAPEnone,          eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEnone,          eESCAPEillegalxml,    eESCAPEillegalxml,
      /* 10-1F */ eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,    eESCAPEillegalxml,
      /* 20-2F */ eESCAPEnone,          eESCAPEnone,          eESCAPEquote,         eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEamp,           eESCAPEapos,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,
      /* 30-3F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPElt,            eESCAPEnone,          eESCAPEgt,            eESCAPEnone,
      /* 40-4F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,
      /* 50-5F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,
      /* 60-6F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,
      /* 70-7F */ eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone,          eESCAPEnone
    };

    if(i_wChar<=0x7F)
        return kWcharToEscape[i_wChar];

    if(i_wChar<=0xD7FF || (i_wChar>=0xE000 && i_wChar<=0xFFFD))
        return eESCAPEashex;

    return eESCAPEillegalxml;
}


HRESULT CXmlSDT::GetMatchingNode(IXMLDOMNodeList *pNodeList_ExistingRows, CComPtr<IXMLDOMNode> &pNode_Matching)
{
    if(*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS)
        return S_FALSE;//All of the rows in the table should have already been removed.

    HRESULT hr;

    pNode_Matching.Release();//make sure it's NULL

    if(FAILED(hr = pNodeList_ExistingRows->reset()))return hr;

    while(true)//search each row trying to match all PKs
    {
        CComPtr<IXMLDOMNode> pNode_Row;
        if(FAILED(hr = pNodeList_ExistingRows->nextNode(&pNode_Row)))return hr;

        if(0 == pNode_Row.p)
            return S_FALSE;//no matching node found

        //We have to ignore text nodes.
        DOMNodeType nodetype;
        if(FAILED(hr = pNode_Row->get_nodeType(&nodetype)))return hr;
        if(NODE_ELEMENT != nodetype)
            continue;

        bool bMatch = true;
        unsigned long iSortedColumn=0;
        for(; iSortedColumn<CountOfColumns() && bMatch; ++iSortedColumn)//if we find a PK column that doesn't match then bail to the next row
        {
            unsigned long iColumn=m_aColumnsIndexSortedByLevel[iSortedColumn];
            if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY)
            {
                CComPtr<IXMLDOMNode> pNode_RowTemp = pNode_Row;

                unsigned int nLevelOfColumnAttribute = m_aLevelOfColumnAttribute[iColumn];//Only (PK | FK) columns should have a non zero value here
                if(nLevelOfColumnAttribute>0)
                {
                    while(nLevelOfColumnAttribute--)
                    {
                        CComPtr<IXMLDOMNode> pNode_Parent;
                        if(FAILED(hr = pNode_RowTemp->get_parentNode(&pNode_Parent)))
                            return hr;
                        if(pNode_Parent==0)
                            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                        pNode_RowTemp.Release();
                        pNode_RowTemp = pNode_Parent;
                    }
                }
                else if(m_bSiblingContainedTable
                                    && iSortedColumn>=m_iSortedFirstParentLevelColumn
                                    && iSortedColumn<m_iSortedFirstChildLevelColumn)
                {
                    CComPtr<IXMLDOMNode> pNode_Parent;
                    if(FAILED(hr = pNode_RowTemp->get_parentNode(&pNode_Parent)))
                        return hr;
                    if(pNode_Parent==0)
                        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                    while(true)//find the previous sibling matching the public row name
                    {
                        CComPtr<IXMLDOMNode> pNode_Sibling;
                        if(FAILED(pNode_RowTemp->get_previousSibling(&pNode_Sibling)))
                            return S_OK;//if we run out of siblings then no matching node found
                        if(pNode_Sibling==0)
                            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                        pNode_RowTemp.Release();
                        pNode_RowTemp = pNode_Sibling;

                        CComBSTR bstrNodeName;
                        if(FAILED(pNode_RowTemp->get_baseName(&bstrNodeName)))//if it's some sort of node that
                            continue;// doesn't have a baseName then it's not the element we're looking for

                        if(m_aPublicRowName[iColumn].IsEqual(bstrNodeName.m_str, bstrNodeName.Length()))
                            break;//if this sibling matches the PublicRowName then, we've found the correct 'parent' node.
                    }
                }

                if(m_awstrChildElementName[iColumn].c_str())//This attribute comes from the child
                {
                    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Row = pNode_RowTemp;
                    CComPtr<IXMLDOMNodeList>                        spNodeList_Children;
                    CComBSTR                                        bstrChildElementName = m_awstrChildElementName[iColumn].c_str();
                    if(0 == bstrChildElementName.m_str)
                        return E_OUTOFMEMORY;
                    if(FAILED(hr = spElement_Row->getElementsByTagName(bstrChildElementName, &spNodeList_Children)))
                        return hr;

                    //It might be more appropriate to use getChildren, then walk the list and find the first node that's an Element.
                    CComPtr<IXMLDOMNode> spChild;
                    if(FAILED(hr = spNodeList_Children->nextNode(&spChild)))
                        return hr;
                    if(spChild == 0)//no children
                    {
                        bMatch = false;
                        continue;
                    }
                    pNode_RowTemp.Release();
                    pNode_RowTemp = spChild;//make this the node we examine
                }

                CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_Row = pNode_RowTemp;
                if(0 == pElement_Row.p)
                {
                    CComBSTR nodename;
                    if(SUCCEEDED(pNode_RowTemp->get_nodeName(&nodename)))
                    {
                        TRACE2(L"QueryInterface failed on Node %s.",nodename.m_str);
                    }

                    return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
                }

                if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE)
                {   //After we've located the correct level node, we can consider all PK NOTPERSITABLE columns as a match
                    CComBSTR bstrElementName;
                    if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                        return hr;
                    bMatch = m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length());
                    continue;
                }

                if(0 == m_apvValues[iColumn])//NULL primarykeys are not supported
                {
                    LOG_UPDATE_ERROR1(IDS_COMCAT_XML_PRIMARYKEYISNULL, E_ST_VALUENEEDED, iColumn, m_abstrColumnNames[iColumn].m_str);
                    return E_ST_VALUENEEDED;
                }

                CComVariant varColumnValue;
                if(m_iPublicRowNameColumn == iColumn)
                {
                    CComBSTR bstrColumnValue;
                    if(FAILED(hr = pElement_Row->get_baseName(&bstrColumnValue)))return hr;
                    varColumnValue = bstrColumnValue;

                    //Since this is an enum public row name - we need to check to see if it's one of the
                    //enums, or some other random element (if we don't do this we'll get an error "illegal
                    //enum value"
                    if(!m_aPublicRowName[iColumn].IsEqual(bstrColumnValue.m_str, bstrColumnValue.Length()))
                    {
                        bMatch = false;
                        continue;
                    }
                }
                else
                {
                    //If this column isn't an enum public row, then we need to make sure that the element name matches
                    CComBSTR bstrElementName;
                    if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                        return hr;
                    if(!m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length()))
                    {
                        bMatch = false;
                        continue;
                    }

                    CComPtr<IXMLDOMAttribute> pNode_Attr;
                    if(FAILED(hr = pElement_Row->getAttributeNode(m_abstrColumnNames[iColumn], &pNode_Attr)))return hr;

                    if(0 == pNode_Attr.p)//HACK:  We really need a flag defined that says whether the column was defaulted.
                    {
                        //This is to deal with PK DefaultedValues
                        switch(m_acolmetas[iColumn].dbType)
                        {
                        case DBTYPE_UI4:
                            {
                                if(     m_aDefaultValue[iColumn]
                                    &&  *reinterpret_cast<ULONG *>(m_apvValues[iColumn]) == *reinterpret_cast<ULONG *>(m_aDefaultValue[iColumn]))
                                {
                                    bMatch = true;
                                    continue;
                                }
                                break;
                            }
                        case DBTYPE_WSTR:
                            {
                                if(     m_aDefaultValue[iColumn]
                                    &&  0 == (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                                    &&  0 == StringCompare(iColumn, reinterpret_cast<LPCWSTR>(m_apvValues[iColumn]), reinterpret_cast<LPCWSTR>(m_aDefaultValue[iColumn])))
                                {
                                    bMatch = true;
                                    continue;
                                }
                                break;
                            }
                        }
                        bMatch = false;
                        continue;
                    }

                    if(FAILED(hr = pNode_Attr->get_value(&varColumnValue)))return hr;
                }

                switch(m_acolmetas[iColumn].dbType)
                {
                case DBTYPE_UI4:
                    {
                        DWORD       ui4;
                        if(FAILED(hr = GetColumnValue(iColumn, varColumnValue.bstrVal, ui4)))return hr;
                        bMatch = (ui4 == *reinterpret_cast<ULONG *>(m_apvValues[iColumn]));
                        break;
                    }
                case DBTYPE_WSTR:
                    {   
                        if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                        {
                            TSmartPointerArray<WCHAR> wszMS;
                            hr = CreateStringFromMultiString ((LPCWSTR) m_apvValues[iColumn], &wszMS);
                            if (FAILED (hr))
                            {
                                return hr;
                            }
                            bMatch = (0 == StringCompare(iColumn, varColumnValue.bstrVal, wszMS));
                        }
                        else
                        {
                            bMatch = (0 == StringCompare(iColumn, varColumnValue.bstrVal, reinterpret_cast<LPWSTR>(m_apvValues[iColumn])));
                        }
                    }
                    break;
                case DBTYPE_GUID:
                    {
                        GUID        guid;
                        if(FAILED(hr = GetColumnValue(iColumn, varColumnValue.bstrVal, guid)))return hr;

                        bMatch = (0 == memcmp(&guid, reinterpret_cast<GUID *>(m_apvValues[iColumn]), sizeof(guid)));
                        break;
                    }
                case DBTYPE_BYTES:
                    {
                        TSmartPointerArray<unsigned char> byArray;
                        unsigned long   cbArray;
                        if(FAILED(hr = GetColumnValue(iColumn, varColumnValue.bstrVal, byArray.m_p, cbArray)))return hr;

                        if(cbArray != m_aSizes[iColumn])//first match the sizes
                        {
                            bMatch = false;
                            break;
                        }

                        bMatch = (0 == memcmp(byArray, reinterpret_cast<unsigned char *>(m_apvValues[iColumn]), m_aSizes[iColumn]));
                        break;
                    }
                }//switch(dbType)
            }//if(fMeta & PK)
        }//for(iSortedColumn...)

        if(iSortedColumn == CountOfColumns() && bMatch)//if we made it through all of the columns without finding a mismatch then we found our row.
        {
            if(IsBaseElementLevelNode(pNode_Row))
            {
                pNode_Matching = pNode_Row;
                break;
            }
        }
    }
    return S_OK;
}//GetMatchingNode


HRESULT CXmlSDT::GetMetaTable(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, CComPtr<ISimpleTableRead2> &pMetaTable) const
{
    STQueryCell         qcellMeta;                  // Query cell for grabbing meta table.
    qcellMeta.pData     = (LPVOID)i_wszTable;
    qcellMeta.eOperator = eST_OP_EQUAL;
    qcellMeta.iCell     = iCOLUMNMETA_Table;
    qcellMeta.dbType    = DBTYPE_WSTR;
    qcellMeta.cbSize    = 0;

// Obtain our dispenser
#ifdef XML_WIRING
    CComPtr<ISimpleDataTableDispenser>     pSimpleDataTableDispenser;      // Dispenser for the Meta Table

    HRESULT hr;
    if(FAILED(hr = CoCreateInstance(clsidSDTXML, 0, CLSCTX_INPROC_SERVER, IID_ISimpleDataTableDispenser,  reinterpret_cast<void **>(&pSimpleDataTableDispenser))))
        return hr;

    return pSimpleDataTableDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qcellMeta, (LPVOID)&m_one,
                        eST_QUERYFORMAT_CELLS, 0, 0, (LPVOID*) &pMetaTable);
#else
    return ((IAdvancedTableDispenser *)m_pISTDisp.p)->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qcellMeta, (LPVOID)&m_one, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, (LPVOID*) &pMetaTable);
#endif
}//GetMetaTable


HRESULT CXmlSDT::GetResursiveColumnPublicName(tTABLEMETARow &i_TableMetaRow, tCOLUMNMETARow &i_ColumnMetaRow, ULONG i_iColumn, wstring &o_wstrColumnPublicName,  TPublicRowName &o_ColumnPublicRowName, unsigned int & o_nLevelOfColumnAttribute, wstring &o_wstrChildElementName)
{
    HRESULT hr;

    if(*i_ColumnMetaRow.pMetaFlags & fCOLUMNMETA_FOREIGNKEY && *i_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_ISCONTAINED)//If this column is a foreign key within a Contained table
    {
        // This is the relation required to determine containment
        CComPtr<ISimpleTableRead2>  pRelationMeta;
        if(FAILED(hr = Dispenser()->GetTable(wszDATABASE_META, wszTABLE_RELATIONMETA, NULL, NULL, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, reinterpret_cast<void **>(&pRelationMeta))))
            return hr;

        tRELATIONMETARow    RelationMetaRow;
        ULONG               aRelationMetaSizes[cRELATIONMETA_NumberOfColumns];
        ULONG               i;

        // initialize the relation meta
        memset (&RelationMetaRow, 0x00, sizeof(tRELATIONMETARow));
        
        for(i=0;true;++i)//Linear search for the RelationMetaRow whose ForeignTable matches this one AND has USE_CONTAINMENT flag set.
        {
            if(FAILED(hr = pRelationMeta->GetColumnValues(i, cRELATIONMETA_NumberOfColumns, NULL, aRelationMetaSizes, reinterpret_cast<void **>(&RelationMetaRow))))return hr;
            if((*RelationMetaRow.pMetaFlags & fRELATIONMETA_USECONTAINMENT) &&
                0 == StringInsensitiveCompare(RelationMetaRow.pForeignTable, i_TableMetaRow.pInternalName))//There should only be one matching foreign table that has USECONTAINMENT flag set.
                break;//leave the contents of the RelationMetaRow structure and exit
        }

        //Now walk the column indexes looking for the one that matches i_iColumn
        for(i=0; i<(aRelationMetaSizes[iRELATIONMETA_ForeignColumns]/4) && i_iColumn!=reinterpret_cast<ULONG *>(RelationMetaRow.pForeignColumns)[i];++i);
        if (i == (aRelationMetaSizes[iRELATIONMETA_ForeignColumns]/4))
        {
            o_wstrColumnPublicName      = i_ColumnMetaRow.pPublicColumnName;
            if(0 == o_wstrColumnPublicName.c_str())return E_OUTOFMEMORY;

            if(*i_ColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_VALUEINCHILDELEMENT)
            {
                o_wstrChildElementName = i_TableMetaRow.pChildElementName;
                if(0 == o_wstrChildElementName.c_str())return E_OUTOFMEMORY;
            }

            ASSERT(i_TableMetaRow.pPublicRowName);//Sice this is a primary table, it MUST have a static public row name
            return o_ColumnPublicRowName.Init(i_TableMetaRow.pPublicRowName);
        }

        //Only now do we really know that this FK is foreign to the primary table that this table is contained within.
        if(*RelationMetaRow.pMetaFlags & fRELATIONMETA_CONTAINASSIBLING)
        {
            if(0 == (*i_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
                return E_SDTXML_NOTSUPPORTED;
            if(o_nLevelOfColumnAttribute != 0)
                return E_SDTXML_NOTSUPPORTED;
            //The parent table is at the same level as the child.  Also, we only allow this at the child most level.
            m_abSiblingContainedColumn[i_iColumn] = true;
            m_bSiblingContainedTable = true;
        }
        else
        {
            ++o_nLevelOfColumnAttribute;//Since this attribute is contained within another table, it is another level above the base Table row element
            if(0 == (*i_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
                ++o_nLevelOfColumnAttribute;//If the table is SCOPEDBYTABLENAME element then it is another level above the base Table row element
        }

        STQueryCell             qcellMeta[2];                  // Query cell for grabbing meta table.
        qcellMeta[0].pData      = RelationMetaRow.pPrimaryTable;
        qcellMeta[0].eOperator  = eST_OP_EQUAL;
        qcellMeta[0].iCell      = iTABLEMETA_InternalName;
        qcellMeta[0].dbType     = DBTYPE_WSTR;
        qcellMeta[0].cbSize     = 0;

        //Get the TableMeta row
        CComPtr<ISimpleTableRead2> pTableMeta_PrimaryTable;
        if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA, qcellMeta, &m_one, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, reinterpret_cast<void **>(&pTableMeta_PrimaryTable))))return hr;

        tTABLEMETARow          TableMetaRow_PrimaryTable;
        if(FAILED(hr = pTableMeta_PrimaryTable->GetColumnValues(0, cTABLEMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&TableMetaRow_PrimaryTable))))return hr;

        //Reuse the query cells for the ColumnMeta
        qcellMeta[0].iCell      = iCOLUMNMETA_Table;

        ULONG iColumn_PrimaryTable = reinterpret_cast<ULONG *>(RelationMetaRow.pPrimaryColumns)[i];
        qcellMeta[1].pData      = &iColumn_PrimaryTable;
        qcellMeta[1].eOperator  = eST_OP_EQUAL;
        qcellMeta[1].iCell      = iCOLUMNMETA_Index;
        qcellMeta[1].dbType     = DBTYPE_UI4;
        qcellMeta[1].cbSize     = 0;

        CComPtr<ISimpleTableRead2> pColumnMeta_PrimaryTable;
        if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA, qcellMeta, &m_two, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, reinterpret_cast<void **>(&pColumnMeta_PrimaryTable))))return hr;

        tCOLUMNMETARow          ColumnMetaRow_PrimaryTable;
        if(FAILED(hr = pColumnMeta_PrimaryTable->GetColumnValues(0, cCOLUMNMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&ColumnMetaRow_PrimaryTable))))return hr;

        return GetResursiveColumnPublicName(TableMetaRow_PrimaryTable, ColumnMetaRow_PrimaryTable, iColumn_PrimaryTable, o_wstrColumnPublicName,  o_ColumnPublicRowName, o_nLevelOfColumnAttribute, o_wstrChildElementName);
    }
    else
    {
        o_wstrColumnPublicName      = i_ColumnMetaRow.pPublicColumnName;
        if(0 == o_wstrColumnPublicName.c_str())return E_OUTOFMEMORY;

        if(*i_ColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_VALUEINCHILDELEMENT)
        {
            o_wstrChildElementName = i_TableMetaRow.pChildElementName;
            if(0 == o_wstrChildElementName.c_str())return E_OUTOFMEMORY;
        }

        if(*i_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME)
        {
            if(o_nLevelOfColumnAttribute+1 > m_BaseElementLevel)
                m_BaseElementLevel = o_nLevelOfColumnAttribute+1;
        }
        else
        {
            if(o_nLevelOfColumnAttribute+2 > m_BaseElementLevel)
                m_BaseElementLevel = o_nLevelOfColumnAttribute+2;
        }

        if(i_TableMetaRow.pPublicRowName)
            return o_ColumnPublicRowName.Init(i_TableMetaRow.pPublicRowName);
        else
        {
            //Leave the o_ColumnPublicRowName uninitialized if we're using an enum as the public row name, we'll fill it in later
            if(*i_ColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_USEASPUBLICROWNAME)
            {
                //Leave o_ColumnPublicRowName uninitialized for this row, we'll set it up at the end
                ASSERT(!IsEnumPublicRowNameTable());//We can only have one column whose enum values indicate the possible public row names
                ASSERT(0 == o_nLevelOfColumnAttribute);//The level of the column attribute whose enum values indicate the possible public row names MUST be at the base level (the child-most level)
                ASSERT(*i_ColumnMetaRow.pMetaFlags & fCOLUMNMETA_ENUM);//This column MUST be an enum
                m_iPublicRowNameColumn = *i_ColumnMetaRow.pIndex;//Remember which column has the list of tags that idenitify the possible public row names
            }
        }
  
    }
    return S_OK;
}


HRESULT CXmlSDT::InsertNewLineWithTabs(ULONG cTabs, IXMLDOMDocument * pXMLDoc, IXMLDOMNode * pNodeInsertBefore, IXMLDOMNode * pNodeParent)
{
    HRESULT hr;

    WCHAR wszNewlineWithTabs[256];
    wcscpy(wszNewlineWithTabs, L"\r\n");//This makes the table element tabbed in once.  The 0th sorted column tells how deep to additionally tab in.

    wszNewlineWithTabs[2+cTabs] = 0x00;
    while(cTabs--)
        wszNewlineWithTabs[2+cTabs] = L'\t';

    CComPtr<IXMLDOMText>    pNode_Newline;
    TComBSTR                bstrNewline(wszNewlineWithTabs);
    if(FAILED(hr = pXMLDoc->createTextNode(bstrNewline, &pNode_Newline)))
        return hr;
    CComVariant varNode = pNodeInsertBefore;
    return pNodeParent->insertBefore(pNode_Newline, varNode, 0);
}

                          

//This is a wrapper for InternalSimpleInitialize (thus the name), it just gets the meta information THEN calls InternalSimpleInitialize.
HRESULT CXmlSDT::InternalComplicatedInitialize(LPCWSTR i_wszDatabase)
{
    ASSERT(m_wszTable);//We should have made a copy of the i_tid (passed into GetTable) already

    HRESULT hr;

    if(FAILED(hr = ObtainPertinentTableMetaInfo()))return hr;

    if(m_fLOS & fST_LOS_READWRITE)
    {
        m_bstr_name           =  L"name";
        m_bstrPublicTableName =  m_TableMetaRow.pPublicName;
        m_bstrPublicRowName   =  m_TableMetaRow.pPublicRowName ? m_TableMetaRow.pPublicRowName : L"";
    }
    // WARNING: Possible data loss on IA64
    m_cchTablePublicName = (ULONG)wcslen(m_TableMetaRow.pPublicName);

    m_fCache             |= *m_TableMetaRow.pMetaFlags;

    CComPtr<ISimpleTableRead2>   pColumnMeta;// Meta table.
    if(FAILED(hr = GetMetaTable(i_wszDatabase, m_wszTable, pColumnMeta)))return hr;

    m_BaseElementLevel = (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME) ? 1 : 2;

//    // Determine column count and allocate necessary meta structures:
//    VERIFY(SUCCEEDED(hr = pColumnMeta->GetTableMeta(0, 0, &CountOfColumns(), 0)));//The number of rows in the meta table Is the number of columns in the table itself.
//    if(FAILED(hr))
//        return hr;

    if(FAILED(hr = SetArraysToSize()))return hr;

    tCOLUMNMETARow          ColumnMetaRow;
    unsigned long           LargestLevelOfColumnAttribute = 0;
    unsigned long           iColumn;
    unsigned long           cbColumns[cCOLUMNMETA_NumberOfColumns];

    for (iColumn = 0;; iColumn++)   
    {
        if(E_ST_NOMOREROWS == (hr = pColumnMeta->GetColumnValues(iColumn, cCOLUMNMETA_NumberOfColumns, 0,
                            cbColumns, reinterpret_cast<void **>(&ColumnMetaRow))))// Next row:
        {
            ASSERT(CountOfColumns() == iColumn);
            if(CountOfColumns() != iColumn)return E_SDTXML_UNEXPECTED; // Assert expected column count.
            break;
        }
        else
        {
            if(FAILED(hr))
            {
                ASSERT(false && "GetColumnValues FAILED with something other than E_ST_NOMOREROWS");
                return hr;
            }
        }

        //Don't care about the iOrder column but we'll get it anyway since it's easier to do.
        m_acolmetas[iColumn].dbType = *ColumnMetaRow.pType;
        m_acolmetas[iColumn].cbSize = *ColumnMetaRow.pSize;
        m_acolmetas[iColumn].fMeta  = *ColumnMetaRow.pMetaFlags;

        if(0 == ColumnMetaRow.pPublicColumnName)return E_SDTXML_UNEXPECTED;//The meta should have failed to load in this case

        if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY)//This is to deal with Defaulting PKs (since the fast cache can't deal with it.)
        {
            ++m_cPKs;
        }
        //WARNING!! Just keeping track of the pointer itself, this could be dangerous if the meta were written info the fastcache, 
        m_aDefaultValue[iColumn]  =  ColumnMetaRow.pDefaultValue;//then went away when we released the ColumnMeta interface
        m_acbDefaultValue[iColumn]=  cbColumns[iCOLUMNMETA_DefaultValue];

        if(*ColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_XMLBLOB)
            m_iXMLBlobColumn = iColumn;

        if(FAILED(hr = GetResursiveColumnPublicName(m_TableMetaRow, ColumnMetaRow, iColumn, m_awstrColumnNames[iColumn], m_aPublicRowName[iColumn], m_aLevelOfColumnAttribute[iColumn], m_awstrChildElementName[iColumn])))
            return hr;

        //This is needed for Inserts, so we create the child node too.  More than one column is allowed to live in the child
        if(0==m_aLevelOfColumnAttribute[iColumn] && 0!=m_awstrChildElementName[iColumn].c_str())//node; but all must come from
            m_iCol_TableRequiresAdditionChildElement = iColumn;//the same child.  We don't support cols from different children.

        if(m_fLOS & fST_LOS_READWRITE)
        {   //These introduce oleaut32.dll so they are only used when we're going to use the DOM.  The read only case we use 
            m_abstrColumnNames[iColumn]     = m_awstrColumnNames[iColumn];//the Node Factory.
        }


        if(m_aLevelOfColumnAttribute[iColumn] > LargestLevelOfColumnAttribute)
            LargestLevelOfColumnAttribute = m_aLevelOfColumnAttribute[iColumn];
    }
    ++m_BaseElementLevel;//one more to account for the <configuration> element

    //These variables are needed to ValidateWriteCache and to validate on Populate as well
    m_saiPKColumns = new ULONG [m_cPKs];
    if(0 == m_saiPKColumns.m_p)
        return E_OUTOFMEMORY;

    ULONG iPK=0;
    for(iColumn=0; iPK<m_cPKs; ++iColumn)
    {
        ASSERT(iColumn<CountOfColumns());
        if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY)
            m_saiPKColumns[iPK++] = iColumn;
    }


    //After we have the ColumnMeta info, get the TagMeta
    if(FAILED(hr = ObtainPertinentTagMetaInfo()))
        return hr;
    if(IsEnumPublicRowNameTable())
        hr = m_aPublicRowName[m_iPublicRowNameColumn].Init(&m_aTagMetaRow[m_aTagMetaIndex[m_iPublicRowNameColumn].m_iTagMeta], m_aTagMetaIndex[m_iPublicRowNameColumn].m_cTagMeta);

    //Sort the column indexes by their level so we read the highest level atrributes first.
    unsigned long iSorted = 0;
    for(int Level=LargestLevelOfColumnAttribute; Level >= 0; --Level)
    {
        for(iColumn = 0; iColumn < CountOfColumns(); ++iColumn)
        {
            if(m_aLevelOfColumnAttribute[iColumn] == static_cast<unsigned long>(Level))
            {
                m_aColumnsIndexSortedByLevel[iSorted++] = iColumn;
                if(IsEnumPublicRowNameTable() && 0 == Level)//I'm not sure if this is necessary.  But we are now initializing the 0 level PublicRowName to be the list of enum values specified for column 'm_iPublicRowNameColumn'
                    m_aPublicRowName[iColumn].Init(&m_aTagMetaRow[m_aTagMetaIndex[m_iPublicRowNameColumn].m_iTagMeta], m_aTagMetaIndex[m_iPublicRowNameColumn].m_cTagMeta);
            }
        }
    }
    if(m_bSiblingContainedTable)//if this is a SiblingContainedTable, we need to verify that the SiblingContainedColumn are
    {                           //listed before the child most columns
        for(int iSortedColumn=CountOfColumns()-1;iSortedColumn>0 &&
                    0==m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]; --iSortedColumn)
        {
            if(false == m_abSiblingContainedColumn[m_aColumnsIndexSortedByLevel[iSortedColumn]])\
            {
                m_iSortedFirstChildLevelColumn = iSortedColumn;
                if(static_cast<int>(CountOfColumns()-1)!=iSortedColumn &&//if this isn't the last column, check to see if the next one is a Sibling
                    true == m_abSiblingContainedColumn[m_aColumnsIndexSortedByLevel[iSortedColumn+1]])//ContainedColumn
                {
                    ASSERT(false && "The columns must be sorted with the SiblingParent columns BEFORE the Child columns");
                    return E_SDTXML_NOTSUPPORTED;//if it is then we have a bogus table definition.  CatUtil doesn't currently
                }                                //validate this condition so we'll do it at run time.
            }                                    
            else
            {
                m_iSortedFirstParentLevelColumn = iSortedColumn;
                if(static_cast<int>(CountOfColumns()-1)==iSortedColumn)
                {
                    ASSERT(false && "The columns must be sorted with the SiblingParent columns BEFORE the Child columns");
                    return E_SDTXML_NOTSUPPORTED;//The last column can't be a SiblingContainedColumn
                }
            }

        }
    }
    ASSERT(iSorted == CountOfColumns());
    ASSERT(!IsNameValueTable());

    return hr;
}


bool CXmlSDT::IsBaseElementLevelNode(IXMLDOMNode * i_pNode)
{
    ASSERT(i_pNode && "Idiot passing NULL!!! CXmlSDT::IsBaseElementLevelNode(NULL)");
    CComPtr<IXMLDOMNode> spNode_Temp = i_pNode;

    unsigned int nLevelOfColumnAttribute = 0;//Only (PK | FK) columns should have a non zero value here
    while(true)
    {
        CComPtr<IXMLDOMNode> spNode_Parent;
        if(FAILED(spNode_Temp->get_parentNode(&spNode_Parent)) || spNode_Parent==0)
        {
            return (nLevelOfColumnAttribute == m_BaseElementLevel) ? true : false;
        }
        ++nLevelOfColumnAttribute;

        spNode_Temp.Release();
        spNode_Temp = spNode_Parent;
    }
    return false;
}


HRESULT CXmlSDT::IsCorrectXMLSchema(IXMLDOMDocument *pXMLDoc) const
{
    HRESULT hr;

    ASSERT(pXMLDoc);

    //This is kind of a long road to get to the XML Schema name but here goes...
    //Get the XML Root Node
    CComPtr<IXMLDOMElement>     pRootNodeOfXMLDocument;
    if(FAILED(hr = pXMLDoc->get_documentElement(&pRootNodeOfXMLDocument)))
        return hr;
    ASSERT(pRootNodeOfXMLDocument);

    //From that get the Definition node
    CComPtr<IXMLDOMNode>        pDefinitionNode;
    if(FAILED(hr = pRootNodeOfXMLDocument->get_definition(&pDefinitionNode)))
        return hr;
    ASSERT(pDefinitionNode);

    //From that we get the DOMDocument of the schema
    CComPtr<IXMLDOMDocument>    pSchemaDocument;
    if(FAILED(hr = pDefinitionNode->get_ownerDocument(&pSchemaDocument)))
        return hr;
    ASSERT(pSchemaDocument);

    //Get the schema's root element
    CComPtr<IXMLDOMElement>     pSchemaRootElement;
    if(FAILED(hr = pSchemaDocument->get_documentElement(&pSchemaRootElement)))
        return hr;
    ASSERT(pSchemaRootElement);

    //get the Name attribute
    CComVariant                 XMLSchemaName;
    if(FAILED(hr = pSchemaRootElement->getAttribute(m_bstr_name, &XMLSchemaName)))
        return hr;

    if(XMLSchemaName.vt != VT_BSTR)
        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

    return (0 == StringCompare(XMLSchemaName.bstrVal, m_kXMLSchemaName)) ? S_OK : E_SDTXML_WRONG_XMLSCHEMA;//If the XML Schema doesn't match then we can't continue
}


HRESULT CXmlSDT::IsMatchingColumnValue(ULONG i_iColumn, LPCWSTR i_wszColumnValue, bool & o_bMatch)
{
    HRESULT hr;
    switch(m_acolmetas[i_iColumn].dbType)
    {
    case DBTYPE_UI4:
        {
            if(0 == i_wszColumnValue)
            {              //This covers the NULL case
                o_bMatch = (m_aDefaultValue[i_iColumn]==m_apvValues[i_iColumn]) || 
                            (*reinterpret_cast<ULONG *>(m_aDefaultValue[i_iColumn]) ==
                             *reinterpret_cast<ULONG *>(m_apvValues[i_iColumn]));
            }
            else
            {
                DWORD       ui4;
                if(FAILED(hr = GetColumnValue(i_iColumn, i_wszColumnValue, ui4)))
                    return hr;
                o_bMatch = (ui4 == *reinterpret_cast<ULONG *>(m_apvValues[i_iColumn]));
            }
            break;
        }
    case DBTYPE_WSTR:
        {   
            if(0 == i_wszColumnValue)
            {
                if (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                {   //we don't default MULTISZ PKs
                    o_bMatch = false;
                    break;
                }

                o_bMatch = (m_aDefaultValue[i_iColumn]==m_apvValues[i_iColumn]) || 
                            (0 == StringCompare(i_iColumn, reinterpret_cast<LPWSTR>(m_aDefaultValue[i_iColumn]),
                                                           reinterpret_cast<LPWSTR>(m_apvValues[i_iColumn])));
            }
            else
            {
                if (m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                {
                    TSmartPointerArray<WCHAR> wszMS;
                    hr = CreateStringFromMultiString ((LPCWSTR) m_apvValues[i_iColumn], &wszMS);
                    if (FAILED (hr))
                    {
                        return hr;
                    }
                    o_bMatch = (0 == StringCompare(i_iColumn, i_wszColumnValue, wszMS));
                }
                else
                {
                    o_bMatch = (0 == StringCompare(i_iColumn, i_wszColumnValue, reinterpret_cast<LPWSTR>(m_apvValues[i_iColumn])));
                }
            }
        }
        break;
    case DBTYPE_GUID:
        {
            if(0 == i_wszColumnValue)
            {
                o_bMatch = (m_aDefaultValue[i_iColumn]==m_apvValues[i_iColumn]) || 
                            (0 == memcmp(m_aDefaultValue[i_iColumn], m_apvValues[i_iColumn], sizeof(GUID)));
            }
            else
            {
                GUID        guid;
                if(FAILED(hr = GetColumnValue(i_iColumn, i_wszColumnValue, guid)))
                    return hr;

                o_bMatch = (0 == memcmp(&guid, reinterpret_cast<GUID *>(m_apvValues[i_iColumn]), sizeof(guid)));
            }
            break;
        }
    case DBTYPE_BYTES:
        {
            if(0 == i_wszColumnValue)
            {
                o_bMatch = (m_aDefaultValue[i_iColumn]==m_apvValues[i_iColumn]) || 
                           (m_aSizes[i_iColumn] == m_acbDefaultValue[i_iColumn]
                            &&  0 == memcmp(m_aDefaultValue[i_iColumn], m_apvValues[i_iColumn], m_aSizes[i_iColumn]));
            }
            else
            {
                TSmartPointerArray<unsigned char> byArray;
                unsigned long   cbArray;
                if(FAILED(hr = GetColumnValue(i_iColumn, i_wszColumnValue, byArray.m_p, cbArray)))return hr;

                if(cbArray != m_aSizes[i_iColumn])//first match the sizes
                {
                    o_bMatch = false;
                    break;
                }

                o_bMatch = (0 == memcmp(byArray, reinterpret_cast<unsigned char *>(m_apvValues[i_iColumn]), m_aSizes[i_iColumn]));
            }
            break;
        }
    }//switch(dbType)
    return S_OK;
}


HRESULT CXmlSDT::LoadDocumentFromURL(IXMLDOMDocument *pXMLDoc)
{
    HRESULT hr;

    ASSERT(pXMLDoc);

    VERIFY(SUCCEEDED(hr = pXMLDoc->put_async(kvboolFalse)));//We want the parse to be synchronous
    if(FAILED(hr))
        return hr;

    if(FAILED(hr = pXMLDoc->put_resolveExternals(kvboolTrue)))
        return hr;//we need all of the external references resolved

    VARIANT_BOOL    bSuccess;
    CComVariant     xml(m_wszURLPath);

	// check for memory allocation error
	if (xml.vt == VT_ERROR)
		return xml.scode;

    if(FAILED(hr = pXMLDoc->load(xml,&bSuccess)))
        return hr;

    return (bSuccess == kvboolTrue) ? S_OK : E_SDTXML_UNEXPECTED;
}


HRESULT CXmlSDT::MemCopyPlacingInEscapedChars(LPWSTR o_DestinationString, LPCWSTR i_SourceString, ULONG i_cchSourceString, ULONG & o_cchCopied) const
{
    
    static LPWSTR   wszSingleQuote= L"&apos;";
    static LPWSTR   wszQuote      = L"&quot;";
    static LPWSTR   wszAmp        = L"&amp;";
    static LPWSTR   wszlt         = L"&lt;";
    static LPWSTR   wszgt         = L"&gt;";
    const  ULONG    cchSingleQuote= 6;
    const  ULONG    cchQuote      = 6;
    const  ULONG    cchAmp        = 5;
    const  ULONG    cchlt         = 4;
    const  ULONG    cchgt         = 4;

    LPWSTR  pDest = o_DestinationString;

    for(;i_cchSourceString--; ++i_SourceString)
    {
        switch(GetEscapeType(*i_SourceString))
        {
        case eESCAPEnone:
            *pDest++ = *i_SourceString;
            break;
        case eESCAPEgt:
            memcpy(pDest, wszgt, cchgt * sizeof(WCHAR));
            pDest += cchgt;
            break;
        case eESCAPElt:
            memcpy(pDest, wszlt, cchlt * sizeof(WCHAR));
            pDest += cchlt;
            break;
        case eESCAPEapos:
            memcpy(pDest, wszSingleQuote, cchSingleQuote * sizeof(WCHAR));
            pDest += cchSingleQuote;
            break;
        case eESCAPEquote:
            memcpy(pDest, wszQuote, cchQuote * sizeof(WCHAR));
            pDest += cchQuote;
            break;
        case eESCAPEamp:
            memcpy(pDest, wszAmp, cchAmp * sizeof(WCHAR));
            pDest += cchAmp;
            break;
        case eESCAPEashex:
            pDest += wsprintf(pDest, L"&#x%04hX;", *i_SourceString);
            break;
        case eESCAPEillegalxml:
            return E_ST_VALUEINVALID;
        default:
            ASSERT(false && "Invalid eESCAPE enum");
            return HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        }
    }
    // WARNING: Possible data loss on IA64
    o_cchCopied = (ULONG)(pDest-o_DestinationString);//return the count of WCHARs copied
    return S_OK;
}


HRESULT CXmlSDT::MyPopulateCache(ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;

    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> pISTController = i_pISTW2;
    if(0 == pISTController.p)return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

    if(0 == (m_fLOS & fST_LOS_REPOPULATE) && !m_bIsFirstPopulate)//If this is not the first Populate and Repopulate LOS was not requirested, return error
        return E_ST_LOSNOTSUPPORTED;

    if((m_fLOS & fST_LOS_UNPOPULATED) && m_bIsFirstPopulate)
    {   //Then populate an empty cache
        if (FAILED(hr = pISTController->PrePopulateCache (0)))
            return hr;
        if (FAILED(hr = pISTController->PostPopulateCache ()))
            return hr;
        m_bIsFirstPopulate = false;
        return S_OK;
    }
    m_bIsFirstPopulate = false;

    ASSERT(i_pISTW2);
    ASSERT(m_wszTable);

    if (FAILED(hr = pISTController->PrePopulateCache (0))) return hr;

    //We use Node Factory parsing for Read and ReadWrite tables.
    if(0==(m_fLOS & fST_LOS_NOCACHEING))
    {
        if(!m_XmlParsedFileCache.IsInitialized())
        {
            CSafeLock XmlParsedFileCache(m_SACriticalSection_XmlParsedFileCache);
            DWORD dwRes = XmlParsedFileCache.Lock();
            if(ERROR_SUCCESS != dwRes)
            {
                return HRESULT_FROM_WIN32(dwRes);
            }

            if(FAILED(hr = m_XmlParsedFileCache.Initialize(TXmlParsedFileCache::CacheSize_mini)))return hr;
            //Unlock the cache
        }
        m_pXmlParsedFile = m_XmlParsedFileCache.GetXmlParsedFile(m_wszURLPath);
    }
    else
    {
        m_pXmlParsedFile = &m_XmlParsedFile;
    }


    DWORD dwAttributes = GetFileAttributes(m_wszURLPath);
    
    if(-1 == dwAttributes)//if GetFileAttributes fails then the file does not exist
    {
        if(m_fLOS & fST_LOS_READWRITE)//if read write table, then we have an empty table
            return pISTController->PostPopulateCache ();
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            LOG_POPULATE_ERROR1(IDS_COMCAT_FILE_NOT_FOUND, hr, m_wszURLPath);
            return hr;
        }
    }
    else if(FILE_ATTRIBUTE_READONLY&dwAttributes && fST_LOS_READWRITE&m_fLOS)
    {
        LOG_POPULATE_ERROR1(IDS_COMCAT_XML_FILENOTWRITEABLE, E_SDTXML_FILE_NOT_WRITABLE, m_wszURLPath);
        return E_SDTXML_FILE_NOT_WRITABLE;//if the file is READONLY and the user wants a WRITABLE table, then error
    }

    m_pISTW2 = i_pISTW2;
    hr = m_pXmlParsedFile->Parse(*this, m_wszURLPath);

    //Reset these state variables, for the next time we parse. (No sense waiting 'til the next parse to reinitialize them).
    m_LevelOfBasePublicRow = 0;
    m_bAtCorrectLocation = (0 == m_cchLocation);
    m_bInsideLocationTag = false;
    m_pISTW2 = 0;

    //clean up (this is also done in the dtor so don't hassle cleaning up if an error occurs and we return prematurely.)
    for(unsigned long iColumn=0; iColumn<*m_TableMetaRow.pCountOfColumns; ++iColumn)
    {
        delete [] m_apValue[iColumn];
        m_apValue[iColumn] = 0;
    }
    if(E_ERROR_OPENING_FILE == hr)
        return E_ST_INVALIDQUERY;
    if(FAILED(hr) && E_SDTXML_DONE != hr)
    {
        HRESULT hrRtn = hr;

        //This will give us an event log entry
        CComPtr<IXMLDOMDocument> pXMLDoc;
        if(FAILED(hr = CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&pXMLDoc)))
            return hr;//Instantiate the XMLParser
        //We use the DOM to parse the ReadWrite table.  This gives better validation and error reporting.
        ParseXMLFile(pXMLDoc, m_bValidating);
        return hrRtn;//pass back the hr that was returned from the NodeFactory parse.
    }

    if (FAILED(hr = pISTController->PostPopulateCache ()))
        return hr;
    return S_OK;
}


HRESULT CXmlSDT::MyUpdateStore(ISimpleTableWrite2* i_pISTW2)
{
    HRESULT hr;

    ASSERT(i_pISTW2);

    if(!(m_fLOS & fST_LOS_READWRITE))
        return E_NOTIMPL;

    CComQIPtr<ISimpleTableController, &IID_ISimpleTableController> pISTController = i_pISTW2;ASSERT(pISTController.p);
    if(0 == pISTController.p)
        return E_SDTXML_UNEXPECTED;

    bool    bError = false;
    if(FAILED(hr = ValidateWriteCache(pISTController, i_pISTW2, bError)))
        return hr;

    if(bError)//if there is an error in validation then no need to continue
        return E_ST_DETAILEDERRS;



    CComPtr<IXMLDOMDocument> pXMLDoc;
    if(FAILED(hr = CoCreateInstance(_CLSID_DOMDocument, NULL, CLSCTX_INPROC_SERVER, _IID_IXMLDOMDocument, (void**)&pXMLDoc)))
        return hr;//Instantiate the XMLParser

    if(-1 == GetFileAttributes(m_wszURLPath))//if GetFileAttributes fails then the file does not exist
    {   //if the file does not exist, then we need to create a empty configuration XML string as a starting point.
        VARIANT_BOOL    bSuccess;
        TComBSTR        bstrBlankComCatDataXmlDocument = L"<?xml version =\"1.0\"?>\r\n<configuration>\r\n</configuration>";

        if(FAILED(hr = pXMLDoc->put_preserveWhiteSpace(kvboolTrue)))
            return hr;

        if(FAILED(hr = pXMLDoc->loadXML(bstrBlankComCatDataXmlDocument, &bSuccess)))
            return hr;
        if(bSuccess != kvboolTrue)//The above string IS valid XML so it should always parse successfully - but the parser may have problems (like out of memory)
            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
    }
    else
        if(FAILED(hr = ParseXMLFile(pXMLDoc, m_bValidating)))
            return hr;                                                                      //Validate the XML file

    //Turn off validation since technically newline text nodes are not permitted (since elements are supposed to be empty), and we use them to pretty up the XML.
    if(FAILED(hr = pXMLDoc->put_validateOnParse(kvboolFalse)))
        return hr;

    m_cCacheHit  = 0;
    m_cCacheMiss = 0;

    CComPtr<IXMLDOMElement> spElementRoot;//This is the element scoping the configuration.  It's either the <configuration> element OR the matching <Location> element.
    if(m_cchLocation)
    {
        CComBSTR bstrLocation = L"location";
        CComBSTR bstrPath     = L"path";

        CComPtr<IXMLDOMNodeList> spNodeList_Location;
        if(FAILED(hr = pXMLDoc->getElementsByTagName(bstrLocation, &spNodeList_Location)))return hr;

        while(true)//find the matching location
        {
            CComPtr<IXMLDOMNode> spNextLocation;
            if(FAILED(hr = spNodeList_Location->nextNode(&spNextLocation)))
                return hr;
            if(spNextLocation == 0)//no locations
                return E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST;

            CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElementLocation = spNextLocation;
            if(0 == spElementLocation.p)
                continue;//go to the next one

            CComVariant varLocation;
            if(FAILED(spElementLocation->getAttribute(bstrPath, &varLocation)))
                continue;

            if(0 != StringInsensitiveCompare(varLocation.bstrVal, m_saLocation))
                continue;

            spElementRoot = spElementLocation;//This location tag is like the root for this config table
            break;
        }
    }
    else
    {   //If no Location specified, the just use the root <configuration> element as the scoping root element.
        if(FAILED(hr = pXMLDoc->get_documentElement(&spElementRoot)))
            return hr;
    }

    //This is used only if IsEnumPublicRowName - because we can't getElementsByTagName on the row itself, we have to get it on the parent instead.
    TComBSTR    ParentPublicRowName;
    TComBSTR *  pParentTagName;
    if(IsEnumPublicRowNameTable() && (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
    {
        pParentTagName = reinterpret_cast<TComBSTR *>(&ParentPublicRowName);
        for(ULONG iColumn=0;iColumn<CountOfColumns();++iColumn)
            if(1 == m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iColumn]])
            {
                ParentPublicRowName = m_aPublicRowName[m_aColumnsIndexSortedByLevel[iColumn]].GetFirstPublicRowName();
                break;
            }
    }
    else
        pParentTagName = reinterpret_cast<TComBSTR *>(&m_bstrPublicTableName);


    CComPtr<IXMLDOMNodeList>        pNodeList;
    CComPtr<TListOfXMLDOMNodeLists> pListOfLists;//This is only used if we're using an enum as the public row name

    if(IsEnumPublicRowNameTable())
    {
        pListOfLists = new TListOfXMLDOMNodeLists;//This gives a ref count of zero
        if(0 == pListOfLists.p)
            return E_OUTOFMEMORY;

        CComPtr<IXMLDOMNodeList> pNodeListOfParentElements;
        if(SUCCEEDED(spElementRoot->getElementsByTagName(*pParentTagName, &pNodeListOfParentElements)))
        {
            if(0 == m_cchLocation)//if there is no query by location
            {
                CComPtr<IXMLDOMNodeList> pNodeListOfParentElementsWithoutLocation;
                if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(pNodeListOfParentElements, m_BaseElementLevel-1, &pNodeListOfParentElementsWithoutLocation)))
                    return hr;

                pNodeListOfParentElements.Release();
                pNodeListOfParentElements = pNodeListOfParentElementsWithoutLocation;
            }

            long cParentElements;
            if(FAILED(hr = pNodeListOfParentElements->get_length(&cParentElements)))
                return hr;
            if(FAILED(hr = pListOfLists->SetCountOfLists(cParentElements)))
                return hr;
            while(cParentElements--)
            {
                CComPtr<IXMLDOMNode>     pNode;
                if(FAILED(hr = pNodeListOfParentElements->nextNode(&pNode)))
                    return hr;

                CComPtr<IXMLDOMNodeList> pNodeListOfTablesChildren;//These should be the Table's rows
                if(FAILED(hr = pNode->get_childNodes(&pNodeListOfTablesChildren)))
                    return hr;

                if(FAILED(hr = pListOfLists->AddToList(pNodeListOfTablesChildren)))
                    return hr;
            }

            pNodeList = pListOfLists;//this bumps the ref count to one.
        }
    }
    else
    {
        if(FAILED(hr = spElementRoot->getElementsByTagName(m_bstrPublicRowName, &pNodeList)))
            return hr;

        if(0 == m_cchLocation)//if there is no query by location
        {
            CComPtr<IXMLDOMNodeList> pNodeListWithoutLocation;
            if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(pNodeList, m_BaseElementLevel, &pNodeListWithoutLocation)))
                return hr;

            pNodeList.Release();
            pNodeList = pNodeListWithoutLocation;
        }
    }

    // performance optimization. Use nextnode instead of get_length, because we only need to 
    // know if we have existing node or not. In case size is important, use get_length (but pay
    // the performance penalty).
    CComPtr<IXMLDOMNode> spNextItem;
    if(FAILED(hr = pNodeList->nextNode (&spNextItem)))
        return hr;

    long cExistingRows=(spNextItem != 0) ? 1 : 0;

    //This kind of table has all of its rows removed everytime UpdateStore is called.
    if(*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS)
    {
        while(spNextItem)
        {
            if(FAILED(hr = RemoveElementAndWhiteSpace(spNextItem)))
                return hr;
            spNextItem.Release();

            if(FAILED(hr = pNodeList->nextNode (&spNextItem)))
                return hr;
        }
        cExistingRows = 0;
    }


    bool    bSomethingToFlush   = false;
    DWORD   eAction;
    ULONG   iRow;

    for(iRow = 0; ; iRow++)
    {
        // Get the ro action
        if(FAILED(hr = pISTController->GetWriteRowAction(iRow, &eAction)))
        {
            if(hr == E_ST_NOMOREROWS)
                hr = S_OK;
            break;
        }

        m_iCurrentUpdateRow = iRow;//This is for error logging purposes only

        switch(eAction)
        {   
        // call the appropriate plugin function
        case eST_ROW_INSERT:
            hr = XMLInsert(i_pISTW2, pXMLDoc, spElementRoot, iRow, pNodeList, cExistingRows);
            break;
        case eST_ROW_UPDATE:
            if(*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS)
                hr = E_SDTXML_UPDATES_NOT_ALLOWED_ON_THIS_KIND_OF_TABLE;
            else
                hr = XMLUpdate(i_pISTW2, pXMLDoc, spElementRoot, iRow, pNodeList, cExistingRows);
            break;
        case eST_ROW_DELETE:
            if(*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS)
                hr = S_OK;//Al rows are implicitly deleted for these tables.
            else
                hr = XMLDelete(i_pISTW2, pXMLDoc, spElementRoot, iRow, pNodeList, cExistingRows);
            break;
        case eST_ROW_IGNORE:
            continue;
        default:
            ASSERT(false && "Invalid Action returned from InternalGetWriteRowAction");
            continue;
        }

        if(E_OUTOFMEMORY == hr)
        {
            m_pLastPrimaryTable.Release();//Release the caching temporary variables.
            m_pLastParent.Release();      //Release the caching temporary variables.
            return E_OUTOFMEMORY;//No need to continue if we get this kind of error.
        }
        else if (FAILED (hr))
        {   // Add detailed error
            STErr ste;

            ste.iColumn = iST_ERROR_ALLCOLUMNS;
            ste.iRow = iRow;
            ste.hr = hr;

            TRACE (L"Detailed error: hr = 0x%x", hr);

            hr = pISTController->AddDetailedError(&ste);
            ASSERT(SUCCEEDED(hr));//Not sure what to do if this fails.
            bError = true;
        }
        else
            bSomethingToFlush = true;//Flush only if OnInsert, OnUpdate or OnDelete succeeded.
    }

    m_pLastPrimaryTable.Release();//Release the caching temporary variables.
    m_pLastParent.Release();      //Release the caching temporary variables.
    if(0 != m_cCacheMiss)//Prevent a divide by 0
        TRACE2(L"UpdateStore    Cache Hits-%8d       Cache Misses-%8d       Hit Ratio- %f %%", m_cCacheHit, m_cCacheMiss, (100.0 * m_cCacheHit)/(m_cCacheHit+m_cCacheMiss));

    if(bSomethingToFlush && !bError)//Only save if there's something to save AND no errors occurred.
    {
        CComVariant varFileName(m_wszURLPath);
        hr = pXMLDoc->save(varFileName);

        if(0==(m_fLOS & fST_LOS_NOCACHEING) && m_pXmlParsedFile)//This keeps us from having to force a flush of the disk write cache.  If the user asks for this table
            m_pXmlParsedFile->Unload();//again, but the write cache hasn't been flushed, then we need to repopulate from disk (NOT from our ParsedFile cache).
    }

    return bError ? E_ST_DETAILEDERRS : hr;//hr may NOT be S_OK.  It's possible to have an error but no Detailed Errors (in which case bError is false but hr it NOT S_OK).
}


HRESULT CXmlSDT::ObtainPertinentTableMetaInfo()
{
    HRESULT hr;

    STQueryCell Query;
    Query.pData     = (void*) m_wszTable;
    Query.eOperator =eST_OP_EQUAL;
    Query.iCell     =iTABLEMETA_InternalName;
    Query.dbType    =DBTYPE_WSTR;
    Query.cbSize    =0;

    if(FAILED(hr = Dispenser()->GetTable(wszDATABASE_META, wszTABLE_TABLEMETA, &Query, &m_one, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, reinterpret_cast<void**>(&m_pTableMeta))))
        return hr;

    if(FAILED(hr = m_pTableMeta->GetColumnValues(0, cTABLEMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void**>(&m_TableMetaRow))))return hr;
    m_iPublicRowNameColumn = *m_TableMetaRow.pPublicRowNameColumn;

    return S_OK;
}

HRESULT CXmlSDT::ObtainPertinentTagMetaInfo()
{
    HRESULT hr;

    //Now that we have the ColumnMeta setup, setup the TagMeta
    STQueryCell Query;
    Query.pData     = (void*) m_wszTable;
    Query.eOperator =eST_OP_EQUAL;
    Query.iCell     =iTAGMETA_Table;
    Query.dbType    =DBTYPE_WSTR;
    Query.cbSize    =0;

    //Optain the TagMeta table
    if(FAILED(hr = Dispenser()->GetTable (wszDATABASE_META, wszTABLE_TAGMETA, &Query, &m_one, eST_QUERYFORMAT_CELLS, m_fLOS & fST_LOS_EXTENDEDSCHEMA, (void**) &m_pTagMeta)))
        return hr;

    ULONG cRows;
    if(FAILED(hr = m_pTagMeta->GetTableMeta(0,0,&cRows,0)))return hr;

    if (cRows != 0)
    {
        m_aTagMetaRow = new tTAGMETARow[cRows];
        if(0 == m_aTagMetaRow.m_p)
            return E_OUTOFMEMORY;
    }

// Build tag column indexes:
    ULONG iColumn, iRow;
    for(iRow = 0, iColumn = ~0;iRow<cRows; ++iRow)
    {
        if(FAILED(hr = m_pTagMeta->GetColumnValues (iRow, cTAGMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&m_aTagMetaRow[iRow]))))
            return hr;

        if(iColumn != *m_aTagMetaRow[iRow].pColumnIndex)
        {
            iColumn = *m_aTagMetaRow[iRow].pColumnIndex;
            m_aTagMetaIndex[iColumn].m_iTagMeta = iRow;
        }
        ++m_aTagMetaIndex[iColumn].m_cTagMeta;
    }

    return S_OK;
}


HRESULT CXmlSDT::ParseXMLFile(IXMLDOMDocument *pXMLDoc, bool bValidating)//defaults to validating against the DTD or XML schema
{
    HRESULT hr;

    ASSERT(pXMLDoc);
    
    if(FAILED(hr = pXMLDoc->put_preserveWhiteSpace(kvboolTrue)))//kvboolFalse)))
        return hr;
    if(FAILED(hr = pXMLDoc->put_validateOnParse(bValidating ? kvboolTrue : kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
        return hr;

    if(FAILED(LoadDocumentFromURL(pXMLDoc)))
    {   //If the load failed then let's spit out as much information as possible about what went wrong
        CComPtr<IXMLDOMParseError> pXMLParseError;
        long lErrorCode, lFilePosition, lLineNumber, lLinePosition;
        TComBSTR bstrReasonString, bstrSourceString, bstrURLString;     

        if(FAILED(hr = pXMLDoc->get_parseError(&pXMLParseError)))       return hr;
        if(FAILED(hr = pXMLParseError->get_errorCode(&lErrorCode)))     return hr;
        if(FAILED(hr = pXMLParseError->get_filepos(&lFilePosition)))    return hr;
        if(FAILED(hr = pXMLParseError->get_line(&lLineNumber)))         return hr;
        if(FAILED(hr = pXMLParseError->get_linepos(&lLinePosition)))    return hr;
        if(FAILED(hr = pXMLParseError->get_reason(&bstrReasonString)))  return hr;
        if(FAILED(hr = pXMLParseError->get_srcText(&bstrSourceString))) return hr;
        if(FAILED(hr = pXMLParseError->get_url(&bstrURLString)))        return hr;

        LOG_ERROR(Interceptor, (&m_spISTError, m_pISTDisp, lErrorCode, ID_CAT_CAT, IDS_COMCAT_XML_PARSE_ERROR,
                        L"\n",
                        (bstrReasonString.m_str ? bstrReasonString.m_str : L""),
                        (bstrSourceString.m_str ? bstrSourceString.m_str : L""),
                        eSERVERWIRINGMETA_Core_XMLInterceptor,
                        m_wszTable,
                        eDETAILEDERRORS_Populate,
                        lLineNumber,
                        lLinePosition,
                        (bstrURLString.m_str ? bstrURLString.m_str : L"")));

        ASSERT(S_OK != lErrorCode);
        return  lErrorCode;
    }
    //Not only does the XML file have to be Valid and Well formed, but its schema must match the one this C++ file was written to.
    return  S_OK;
}


HRESULT CXmlSDT::ReduceNodeListToThoseNLevelsDeep(IXMLDOMNodeList * i_pNodeList, ULONG i_nLevel, IXMLDOMNodeList **o_ppNodeListReduced) const
{
    HRESULT                 hr;

    TXMLDOMNodeList * pNodeListReduced = new TXMLDOMNodeList;
    if(0 == pNodeListReduced)
        return E_OUTOFMEMORY;

    CComPtr<IXMLDOMNode>    spNextItem;
    if(FAILED(hr = i_pNodeList->nextNode(&spNextItem)))
        return hr;

    while(spNextItem)
    {
        ULONG                cLevels = 0;

        CComPtr<IXMLDOMNode> spNodeParent;
        if(FAILED(hr = spNextItem->get_parentNode(&spNodeParent)))
            return hr;
        while(spNodeParent)
        {
            ++cLevels;
            CComPtr<IXMLDOMNode> spNodeTemp = spNodeParent;
            spNodeParent.Release();
            if(FAILED(hr = spNodeTemp->get_parentNode(&spNodeParent)))
                return hr;
        }
        if(cLevels == i_nLevel)
            if(FAILED(hr = pNodeListReduced->AddToList(spNextItem)))
                return hr;

        spNextItem.Release();
        if(FAILED(hr = i_pNodeList->nextNode(&spNextItem)))
            return hr;
    }

    *o_ppNodeListReduced = reinterpret_cast<IXMLDOMNodeList *>(pNodeListReduced);

    return S_OK;
}


HRESULT CXmlSDT::RemoveElementAndWhiteSpace(IXMLDOMNode *pNode)
{
    HRESULT hr;
    CComPtr<IXMLDOMNode> pNode_Parent;
    if(FAILED(hr = pNode->get_parentNode(&pNode_Parent)))
        return hr;
    if(pNode_Parent==0)
        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

    CComPtr<IXMLDOMNode> spSibling;
    pNode->get_previousSibling(&spSibling);

    pNode_Parent->removeChild(pNode, 0);

    while(spSibling)
    {
        DOMNodeType type;
        if(FAILED(hr = spSibling->get_nodeType(&type)))
            return hr;

        CComPtr<IXMLDOMNode> spSibling0;
        spSibling->get_previousSibling(&spSibling0);

        if(NODE_TEXT != type)
            break;

        pNode_Parent->removeChild(spSibling, 0);

        spSibling.Release();
        spSibling = spSibling0;
    }
    return S_OK;
}


HRESULT CXmlSDT::ScanAttributesAndFillInColumn(const TElement &i_Element, ULONG i_iColumn, bool &o_bMatch)
{
    HRESULT hr;
    ULONG   iAttribute=0;

    o_bMatch  = false;//We'll either find the matching attr and compare to the Query, OR we'll find NO attr and compare it with the query
    for(; iAttribute<i_Element.m_NumberOfAttributes; ++iAttribute)
    {
        LPCWSTR pwcText;
        ULONG   ulLen;

        ASSERT( m_iPublicRowNameColumn != i_iColumn );

        if( m_awstrColumnNames[i_iColumn].length()      != i_Element.m_aAttribute[iAttribute].m_NameLength                                                      ||
                0                                       != memcmp(i_Element.m_aAttribute[iAttribute].m_Name, m_awstrColumnNames[i_iColumn], sizeof(WCHAR)*i_Element.m_aAttribute[iAttribute].m_NameLength))
                continue;

        //We matched the column name to the attribute name
        pwcText = i_Element.m_aAttribute[iAttribute].m_Value;
        ulLen   = i_Element.m_aAttribute[iAttribute].m_ValueLength;

        if(0 == m_aQuery[i_iColumn].dbType || 0 != m_aQuery[i_iColumn].pData)//If no query OR the query data is NOT NULL then proceed.
        {
            if(FAILED(hr = FillInColumn(i_iColumn, pwcText, ulLen, m_acolmetas[i_iColumn].dbType, m_acolmetas[i_iColumn].fMeta, o_bMatch)))
                return hr;
            if(!o_bMatch)//If not a match then we're done with this element and this level.
                return S_OK;
        }
        break;//we found the node that matches the column so bail.
    }
    if(iAttribute == i_Element.m_NumberOfAttributes && !o_bMatch)//if we made it through the list without finding a match then the column is NULL
    {
        delete [] m_apValue[i_iColumn];
        m_apValue[i_iColumn] = 0;
        m_aSize[i_iColumn] = 0;

        if(FAILED(hr = FillInPKDefaultValue(i_iColumn, o_bMatch)))//If this column is a PK with a DefaultValue, then fill it in.
            return hr;                                            //if it's not a PK then compare with the query
        if(!o_bMatch)//If not a match then we're done with this element and this level.
            return S_OK;
    }
    return S_OK;
}//ScanAttributesAndFillInColumn


HRESULT CXmlSDT::SetArraysToSize()
{
    if(CountOfColumns()<=m_kColumns)//We only need to do allocations when the number of columns exceeds m_kColumns.
    {
        m_abSiblingContainedColumn          = m_fixed_abSiblingContainedColumn;
        m_abstrColumnNames                  = m_fixed_abstrColumnNames;
        m_aPublicRowName                    = m_fixed_aPublicRowName;
        m_acolmetas                         = m_fixed_acolmetas;
        m_aLevelOfColumnAttribute           = m_fixed_aLevelOfColumnAttribute;
        m_aQuery                            = m_fixed_aQuery;
        m_apvValues                         = m_fixed_apvValues;
        m_aSizes                            = m_fixed_aSizes;
        m_aStatus                           = m_fixed_aStatus;
        m_awstrColumnNames                  = m_fixed_awstrColumnNames;
        m_aColumnsIndexSortedByLevel        = m_fixed_aColumnsIndexSortedByLevel;
        m_aSize                             = m_fixed_aSize;                     
        m_apValue                           = m_fixed_apValue;
        m_aTagMetaIndex                     = m_fixed_aTagMetaIndex;
        m_aDefaultValue                     = m_fixed_aDefaultValue;
        m_acbDefaultValue                   = m_fixed_acbDefaultValue;
        m_awstrChildElementName             = m_fixed_awstrChildElementName;
    }
    else
    {
        m_alloc_abSiblingContainedColumn    = new bool            [CountOfColumns()];
        m_alloc_abstrColumnNames            = new TComBSTR        [CountOfColumns()];
        m_alloc_aPublicRowName              = new TPublicRowName  [CountOfColumns()];
        m_alloc_acolmetas                   = new SimpleColumnMeta[CountOfColumns()]; 
        m_alloc_aLevelOfColumnAttribute     = new unsigned int    [CountOfColumns()];
        m_alloc_aQuery                      = new STQueryCell     [CountOfColumns()];
        m_alloc_apvValues                   = new LPVOID          [CountOfColumns()];
        m_alloc_aSizes                      = new ULONG           [CountOfColumns()];
        m_alloc_aStatus                     = new ULONG           [CountOfColumns()];
        m_alloc_awstrColumnNames            = new wstring         [CountOfColumns()];
        m_alloc_aColumnsIndexSortedByLevel  = new unsigned int    [CountOfColumns()];
        m_alloc_aSize                       = new unsigned long   [CountOfColumns()];
        m_alloc_apValue                     = new unsigned char * [CountOfColumns()];
        m_alloc_aTagMetaIndex               = new TTagMetaIndex   [CountOfColumns()];
        m_alloc_aDefaultValue               = new unsigned char * [CountOfColumns()];
        m_alloc_acbDefaultValue             = new unsigned long   [CountOfColumns()];
        m_alloc_awstrChildElementName       = new wstring         [CountOfColumns()];

        if(!m_alloc_abSiblingContainedColumn      ||
           !m_alloc_abstrColumnNames              ||
           !m_alloc_aPublicRowName                ||
           !m_alloc_acolmetas                     ||
           !m_alloc_aLevelOfColumnAttribute       ||
           !m_alloc_aQuery                        ||
           !m_alloc_apvValues                     ||
           !m_alloc_aSizes                        ||
           !m_alloc_aStatus                       ||
           !m_alloc_awstrColumnNames              ||
           !m_alloc_aColumnsIndexSortedByLevel    ||
           !m_alloc_aSize                         ||
           !m_alloc_apValue                       ||
           !m_alloc_aTagMetaIndex                 ||
           !m_alloc_aDefaultValue                 ||
           !m_alloc_acbDefaultValue               ||
           !m_alloc_awstrChildElementName)
           return E_OUTOFMEMORY;

        m_abSiblingContainedColumn          = m_alloc_abSiblingContainedColumn;
        m_abstrColumnNames                  = m_alloc_abstrColumnNames;
        m_aPublicRowName                    = m_alloc_aPublicRowName;
        m_acolmetas                         = m_alloc_acolmetas;
        m_aLevelOfColumnAttribute           = m_alloc_aLevelOfColumnAttribute;
        m_aQuery                            = m_alloc_aQuery;
        m_apvValues                         = m_alloc_apvValues;
        m_aSizes                            = m_alloc_aSizes;
        m_aStatus                           = m_alloc_aStatus;
        m_awstrColumnNames                  = m_alloc_awstrColumnNames;
        m_aColumnsIndexSortedByLevel        = m_alloc_aColumnsIndexSortedByLevel;
        m_aSize                             = m_alloc_aSize;                     
        m_apValue                           = m_alloc_apValue;                     
        m_aTagMetaIndex                     = m_alloc_aTagMetaIndex;
        m_aDefaultValue                     = m_alloc_aDefaultValue;
        m_acbDefaultValue                   = m_alloc_acbDefaultValue;
        m_awstrChildElementName             = m_alloc_awstrChildElementName;
    }

    memset(m_abSiblingContainedColumn  ,0x00, CountOfColumns() * sizeof(bool              ));
    memset(m_acolmetas                 ,0x00, CountOfColumns() * sizeof(SimpleColumnMeta  ));
    memset(m_aLevelOfColumnAttribute   ,0x00, CountOfColumns() * sizeof(unsigned int      ));
    memset(m_aQuery                    ,0x00, CountOfColumns() * sizeof(STQueryCell       ));
    memset(m_apvValues                 ,0x00, CountOfColumns() * sizeof(LPVOID            ));
    memset(m_aSizes                    ,0x00, CountOfColumns() * sizeof(ULONG             ));
    memset(m_aStatus                   ,0x00, CountOfColumns() * sizeof(ULONG             ));
    memset(m_aColumnsIndexSortedByLevel,0x00, CountOfColumns() * sizeof(unsigned int      ));
    memset(m_aSize                     ,0x00, CountOfColumns() * sizeof(unsigned long     ));
    memset(m_apValue                   ,0x00, CountOfColumns() * sizeof(unsigned char *   ));
    memset(m_aDefaultValue             ,0x00, CountOfColumns() * sizeof(unsigned char *   ));
    memset(m_acbDefaultValue           ,0x00, CountOfColumns() * sizeof(unsigned long     ));
    
    return S_OK;
}//SetArraysToSize


//Get the UI4 value whether it's an enum, flag or regular ui4
HRESULT CXmlSDT::SetColumnValue(unsigned long i_iColumn, IXMLDOMElement * i_pElement, unsigned long i_ui4)
{
    if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_BOOL)
    {
        CComVariant varValue(i_ui4 == 0 ? L"false" : L"true");
        return i_pElement->setAttribute(m_abstrColumnNames[i_iColumn], varValue);
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_ENUM)
    {
        ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.
        for(unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta, cTag = m_aTagMetaIndex[i_iColumn].m_cTagMeta; cTag; ++iTag, --cTag)//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
        {
            ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

            //string compare the tag to the PublicName of the Tag in the meta.
            if(*m_aTagMetaRow[iTag].pValue == i_ui4)
            {
                CComVariant varValue(m_aTagMetaRow[iTag].pPublicName);
                return i_pElement->setAttribute(m_abstrColumnNames[i_iColumn], varValue);
            }
        }

        WCHAR szUI4[12];
        szUI4[11] = 0x00;
        _ultow(i_ui4, szUI4, 10);
        LOG_UPDATE_ERROR2(IDS_COMCAT_XML_BOGUSENUMVALUEINWRITECACHE, E_SDTXML_INVALID_ENUM_OR_FLAG, i_iColumn, m_abstrColumnNames[i_iColumn].m_str, szUI4)
        return E_SDTXML_INVALID_ENUM_OR_FLAG;
    }
    else if(m_acolmetas[i_iColumn].fMeta & fCOLUMNMETA_FLAG)
    {
        ASSERT(0 != m_aTagMetaIndex[i_iColumn].m_cTagMeta);//Not all columns have tagmeta, those elements of the array are set to 0.  Assert this isn't one of those.

        WCHAR wszValue[1024];
        wszValue[0] = 0x00;

        unsigned long iTag = m_aTagMetaIndex[i_iColumn].m_iTagMeta;
        unsigned long cTag = m_aTagMetaIndex[i_iColumn].m_cTagMeta;

        if(0==*m_aTagMetaRow[0].pValue && 0==i_ui4)
        {   //I'm assuming that if a flag value of zero is defined that it must be first
            wcscpy(wszValue, m_aTagMetaRow[0].pPublicName);
        }
        else
        {
            for(; cTag && 0!=i_ui4; ++iTag, --cTag)//m_pTagMeta was queried for ALL columns, m_aiTagMeta[iColumn] indicates which row to start with
            {
                ASSERT(*m_aTagMetaRow[iTag].pColumnIndex == i_iColumn);

                //A flag value may have more than one bit set (that's why I don't just have if(*m_aTagMetaRow[iTag].pValue & i_ui4)
                if(*m_aTagMetaRow[iTag].pValue && (*m_aTagMetaRow[iTag].pValue == (*m_aTagMetaRow[iTag].pValue & i_ui4)))
                {
                    if(wszValue[0] != 0x00)
                        wcscat(wszValue, L" | ");
                    wcscat(wszValue, m_aTagMetaRow[iTag].pPublicName);
                }
                i_ui4 ^= *m_aTagMetaRow[iTag].pValue;//This prevents us from walking the tags that aren't used.  This means, most used flags should be
            }                                        //the lower order bits
            if(0!=i_ui4)
            {
                TRACE2(L"Flag bits (%d) for Column (%d) are undefined in TagMeta.", i_iColumn, i_ui4);
            }
        }
        if(0 == wszValue[0])//if the resulting string is L"" then remove the attribute
        {   //this happens when no tag value of zero is defined but the flag value is zero
            return i_pElement->removeAttribute(m_abstrColumnNames[i_iColumn]);
        }

        CComVariant varValue(wszValue);
        return i_pElement->setAttribute(m_abstrColumnNames[i_iColumn], varValue);
    }
    //otherwise just write the number
    WCHAR wszUI4[34];
    _ultow(i_ui4, wszUI4, 10);

    CComVariant varValue(wszUI4);
    return i_pElement->setAttribute(m_abstrColumnNames[i_iColumn], varValue);
}

HRESULT CXmlSDT::SetRowValues(IXMLDOMNode *pNode_Row, IXMLDOMNode *pNode_RowChild)
{
    HRESULT hr;

    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Child;//NULL unless there is a column that comes from the child
    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Row = pNode_Row;
    if(0 == spElement_Row.p)
        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

    if(0 != pNode_RowChild)
    {
        spElement_Child = pNode_RowChild;
        if(0 == spElement_Child.p)
            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
    }
    else if(-1 != m_iCol_TableRequiresAdditionChildElement)
    {
        CComBSTR                    bstrChildElementName = m_awstrChildElementName[m_iCol_TableRequiresAdditionChildElement].c_str();
        CComPtr<IXMLDOMNodeList>    spNodeList_Children;

        if(FAILED(hr = spElement_Row->getElementsByTagName(bstrChildElementName, &spNodeList_Children)))
            return hr;

        CComPtr<IXMLDOMNode> spChild;
        if(FAILED(hr = spNodeList_Children->nextNode(&spChild)))
            return hr;
        ASSERT(spChild != 0);//no children

        spElement_Child = spChild;
        if(0 == spElement_Child.p)
            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
    }

    ULONG iSortedColumn = m_bSiblingContainedTable ? m_iSortedFirstChildLevelColumn : 0;
    for(; iSortedColumn<CountOfColumns(); ++iSortedColumn)
    {
        ULONG iColumn = m_aColumnsIndexSortedByLevel[iSortedColumn];
        if(0 != m_aLevelOfColumnAttribute[iColumn])//We're only setting attributes that belong in this element
            continue;
        if(m_iPublicRowNameColumn == iColumn)
            continue;//This column is already taken care of if it is the element name

        IXMLDOMElement *pElement_Row = 0==m_awstrChildElementName[iColumn].c_str() ? spElement_Row.p : spElement_Child.p;
        ASSERT(pElement_Row);

        //Validate against the column's meta - if the column is PERSISTABLE and NOTNULLABLE
        if(     0 == m_apvValues[iColumn]
            &&  fCOLUMNMETA_NOTNULLABLE == (m_acolmetas[iColumn].fMeta & (fCOLUMNMETA_NOTPERSISTABLE | fCOLUMNMETA_NOTNULLABLE)))
        {
            if((m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY) && m_aDefaultValue[iColumn])
            {
                //The user inserted a Row with a NULL PK; BUT the PK has a DefaultValue, so everything is OK
            }
            else
            {
                LOG_UPDATE_ERROR1(IDS_COMCAT_XML_NOTNULLABLECOLUMNISNULL, E_ST_VALUENEEDED, -1, m_abstrColumnNames[iColumn].m_str);
                return E_ST_VALUENEEDED;
            }
        }

        if( m_iXMLBlobColumn == iColumn                                         ||
                    0 == m_apvValues[iColumn]                                   ||
                    (m_aStatus[iColumn] & fST_COLUMNSTATUS_DEFAULTED)           ||
                    (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE))
        {
            pElement_Row->removeAttribute(m_abstrColumnNames[iColumn]);
        }
        else
        {
            switch(m_acolmetas[iColumn].dbType)
            {
            case DBTYPE_UI4:
                {
                    if(     m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY  //If we (the XML Interceptor) defaulted the PK value, then don't write it out.
                        &&  m_aDefaultValue[iColumn]
                        &&  *reinterpret_cast<ULONG *>(m_apvValues[iColumn]) == *reinterpret_cast<ULONG *>(m_aDefaultValue[iColumn]))
                    {
                        pElement_Row->removeAttribute(m_abstrColumnNames[iColumn]);
                        break;
                    }
                    if(FAILED(hr = SetColumnValue(iColumn, pElement_Row, *reinterpret_cast<ULONG *>(m_apvValues[iColumn]))))
                        return hr;
                    break;
                }
            case DBTYPE_WSTR:
                {
                    CComVariant varValue;

                    if(     m_acolmetas[iColumn].fMeta & fCOLUMNMETA_PRIMARYKEY  //If we (the XML Interceptor) defaulted the PK value, then don't write it out.
                        &&  0 == (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                        &&  m_aDefaultValue[iColumn]
                        &&  0 == StringCompare(iColumn, reinterpret_cast<LPWSTR>(m_apvValues[iColumn]), reinterpret_cast<LPCWSTR>(m_aDefaultValue[iColumn])))
                    {
                        pElement_Row->removeAttribute(m_abstrColumnNames[iColumn]);
                        break;
                    }

                    if (m_acolmetas[iColumn].fMeta & fCOLUMNMETA_MULTISTRING)
                    {
                        TSmartPointerArray<WCHAR> wszMS;
                        hr = CreateStringFromMultiString ((LPCWSTR) m_apvValues[iColumn], &wszMS);
                        if (FAILED (hr))
                        {
                            return hr;
                        }
                        varValue = wszMS;
                    }
                    else
                    {
                        varValue = reinterpret_cast<LPCWSTR>(m_apvValues[iColumn]);
                    }
                    if(FAILED(hr = pElement_Row->setAttribute(m_abstrColumnNames[iColumn], varValue)))
                            return hr;
                }
                break;
            case DBTYPE_GUID:
                {
                    LPWSTR wszGuid = 0;
                    if(FAILED(hr = UuidToString(reinterpret_cast<UUID *>(m_apvValues[iColumn]), &wszGuid)))
                        return hr;

                    CComVariant varValue(wszGuid);
                    if(FAILED(hr = RpcStringFree(&wszGuid)))
                        return hr;
                    if(FAILED(hr = pElement_Row->setAttribute(m_abstrColumnNames[iColumn], varValue)))
                        return hr;
                    break;
                }
            case DBTYPE_BYTES:
                {
                    TSmartPointerArray<WCHAR> wszArray = new WCHAR[(m_aSizes[iColumn]*2)+1];//allow two WCHARs for each byte and one for the NULL
                    if(0 == wszArray.m_p)
                        return E_OUTOFMEMORY;

                    ByteArrayToString(reinterpret_cast<unsigned char *>(m_apvValues[iColumn]), m_aSizes[iColumn], wszArray); 

                    CComVariant     varValue(wszArray);
                    hr = pElement_Row->setAttribute(m_abstrColumnNames[iColumn], varValue);
                    if(FAILED(hr))return hr;
                    break;
                }
            default:
                ASSERT(false && "Unknown dbType");
            }//switch(dbType)
        }//else m_apvValues[iColumn]
    }
    return S_OK;
}


HRESULT CXmlSDT::ValidateWriteCache(ISimpleTableController* i_pISTController, ISimpleTableWrite2* i_pISTW2, bool & o_bDetailedError)
{
    //The following information is NOT spec'd in SimpleTableV2.doc.  So this
    //constitutes the spec for XML's validation of the WriteCache.
    
    //There are several possibilities:
    //1.1   A row is has a WriteRowAction of eST_ROW_INSERT
    //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
    //      Result:
    //      Detailed Error - (All rows matching the PK have a Detailed Error
    //                        added and no further validation of these rows
    //                        is done).
    //
    //1.2   A row is has a WriteRowAction of eST_ROW_INSERT
    //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE
    //      2nd row marked as eST_ROW_INSERT
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //1.3   A row is has a WriteRowAction of eST_ROW_INSERT
    //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE.
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //      
    //1.4   A row is has a WriteRowAction of eST_ROW_INSERT
    //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
    //      Result:
    //      None action, continue validating against 1st row
    //
    //      
    //2.1   A row is has a WriteRowAction of eST_ROW_UPDATE
    //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
    //      Result:
    //      Detailed Error - (All rows matching the PK have a Detailed Error
    //                        added and no further validation of these rows
    //                        is done).
    //
    //2.2   A row is has a WriteRowAction of eST_ROW_UPDATE
    //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE.
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //2.3   A row is has a WriteRowAction of eST_ROW_UPDATE
    //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //2.4   A row is has a WriteRowAction of eST_ROW_UPDATE
    //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
    //      Result:
    //      None action, continue validating against 1st row
    //      
    //      
    //
    //3.1   A row is has a WriteRowAction of eST_ROW_DELETE
    //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
    //      Result:
    //      1st row marked as eST_ROW_IGNORE
    //      2nd row marked as eST_ROW_UPDATE
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //3.2   A row is has a WriteRowAction of eST_ROW_DELETE
    //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
    //      Result:
    //      Detailed Error - (All rows matching the PK have a Detailed Error
    //                        added and no further validation of these rows
    //                        is done).
    //
    //3.3   A row is has a WriteRowAction of eST_ROW_DELETE
    //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
    //      Result:
    //      1st row marked as eST_ROW_IGNORE.
    //      Stop processing 1st row (processing of the 2nd row will handle
    //                      additional conflicting PKs).
    //
    //3.4   A row is has a WriteRowAction of eST_ROW_DELETE
    //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
    //      Result:
    //      None action, continue validating against 1st row
    //      
    //      
    //

    ULONG                       cRowsInWriteCache;
    DWORD                       eRowAction, eMatchingRowAction;
    HRESULT                     hr;
    //Each row in the WriteCache has an Action.  If there is a conflict (ie. two row having
    //the same PK are marked as eST_ROW_INSERT), then a detailed error is logged and the
    //rows in conflict should be ignored in further validation.  So we build an array of
    //bools to indicate whether to ignore the row.  We don't want to actually change the
    //Action because the user will need this information to correct the error.
    TSmartPointerArray<bool>    saRowHasDetailedErrorLogged;

    //Just counting the rows in the WriteCache, so we can alloc the saRowHasDetailedErrorLogged.
    for(cRowsInWriteCache=0; ; ++cRowsInWriteCache)
    {
        if(FAILED(hr = i_pISTController->GetWriteRowAction(cRowsInWriteCache, &eRowAction)))
        {
            if(hr != E_ST_NOMOREROWS)
                return hr;
            break;//we found the last row
        }
    }

    if(1 == cRowsInWriteCache || 0 == cRowsInWriteCache)//if there's only one row then there's no possibility for a conflict
        return S_OK;

    //We could defer this allocation 'til we actually have an error; but the logic is easier to
    saRowHasDetailedErrorLogged = new bool [cRowsInWriteCache];//follow if we just do it up front.
    if(0 == saRowHasDetailedErrorLogged.m_p)
        return E_OUTOFMEMORY;

    //Start with all columns NULL.
    memset(m_apvValues, 0x00, CountOfColumns() * sizeof(void *));
    memset(m_aSizes,    0x00, CountOfColumns() * sizeof(ULONG));
    memset(saRowHasDetailedErrorLogged, 0x00, cRowsInWriteCache * sizeof(bool));

    //If we go to the last row, there'll be nothing to compare it to, so end as the second last row in the WriteCache
    for(ULONG iRow = 0; iRow<(cRowsInWriteCache-1); ++iRow)
    {
        if(saRowHasDetailedErrorLogged[iRow])
            continue;//If this row has already been added to the DetailedError list, then there's nothing to validate

        // Get the action
        if(FAILED(hr = i_pISTController->GetWriteRowAction(iRow, &eRowAction)))
        {
            ASSERT(false && "We already counted the rows in the WriteCache, we should never fail GetWriteRowAction");
            return hr;
        }

        STErr ste;
        ULONG iMatchingRow = iRow;//We start at one past the last matching row (starting one past the row we're comparing to).

        //ste.hr determines whether we log an error
        memset(&ste, 0x00, sizeof(STErr));

        //Get the PK columns to pass to GetWriteRowIndexBySearch
        if(m_cPKs>1)
        {
            if(FAILED(hr = i_pISTW2->GetWriteColumnValues(iRow, m_cPKs, m_saiPKColumns, 0, m_aSizes, m_apvValues)))
                return hr;
        }
        else
        {
            if(FAILED(hr = i_pISTW2->GetWriteColumnValues(iRow, m_cPKs, m_saiPKColumns, 0, &m_aSizes[m_saiPKColumns[0]], &m_apvValues[m_saiPKColumns[0]])))
                return hr;
        }

        //If there's something wrong with iRow we log a detailed error by setting ste with a failed ste.hr.
        //This indicates that all rows matching the PK are also logged with a detailed error.  Also, in the
        //error condition, all the rows matching iRow's PK are marked as eST_ROW_IGNORE (including iRow itself). 

        bool bContinueProcessingCurrentRow=true;
        while(bContinueProcessingCurrentRow)
        {
            if(FAILED(hr = i_pISTW2->GetWriteRowIndexBySearch(iMatchingRow+1, m_cPKs, m_saiPKColumns, m_aSizes, m_apvValues, &iMatchingRow)))
            {
                if(hr != E_ST_NOMOREROWS)
                    return hr;
                break;
            }

            //This shouldn't happen because when we find a row that is in error, we find all matching rows and log
            //detailed errors on those row too.  So the 'if(saRowHasDetailedErrorLogged[iRow])' just inside the for
            //startment above should take care of this.
            ASSERT(false == saRowHasDetailedErrorLogged[iMatchingRow]);

            if(saRowHasDetailedErrorLogged[iRow])
            {
                //Something was wrong with one of the earlier rows matching this one's PK.  So that invalidates this
                //row as well.
                ste.hr = E_ST_ROWCONFLICT;
            }
            else
            {
                if(FAILED(hr = i_pISTController->GetWriteRowAction(iMatchingRow, &eMatchingRowAction)))
                    return hr;
                switch(eRowAction)
                {   
                case eST_ROW_INSERT:
                    {
                        switch(eMatchingRowAction)
                        {
                        case eST_ROW_INSERT://Same result for all three of these.
                        //1.1   A row is has a WriteRowAction of eST_ROW_INSERT
                        //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
                        //      Result:
                        //      Detailed Error - (All rows matching the PK are marked as
                        //                        eST_ROW_IGNORE and Detailed Error is added)
                        //
                            ste.hr = E_ST_ROWCONFLICT;//This indicates to log a DetailedError below, on iMatchingRow.
                            break;
                        case eST_ROW_UPDATE:
                        //1.2   A row is has a WriteRowAction of eST_ROW_INSERT
                        //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE
                        //      2nd row marked as eST_ROW_INSERT
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                        //
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iMatchingRow, eST_ROW_INSERT)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_DELETE:
                        //1.3   A row is has a WriteRowAction of eST_ROW_INSERT
                        //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE.
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_IGNORE:
                        //1.4   A row is has a WriteRowAction of eST_ROW_INSERT
                        //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
                        //      Result:
                        //      None action, continue validating against 1st row
                            break;
                        default:
                            ASSERT(false && "Invalid Action returned from GetWriteRowAction");
                            continue;
                        }
                    }
                    break;
                case eST_ROW_UPDATE:
                    {
                        switch(eMatchingRowAction)
                        {
                        case eST_ROW_INSERT:
                        //2.1   A row is has a WriteRowAction of eST_ROW_UPDATE
                        //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
                        //      Result:
                        //      Detailed Error - (All rows matching the PK are marked as
                        //                        eST_ROW_IGNORE and Detailed Error is added)
                        //
                            ste.hr = E_ST_ROWCONFLICT;//This indicates to log a DetailedError below, on iMatchingRow.
                            break;
                        case eST_ROW_UPDATE:
                        //2.2   A row is has a WriteRowAction of eST_ROW_UPDATE
                        //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE.
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_DELETE:
                        //2.3   A row is has a WriteRowAction of eST_ROW_UPDATE
                        //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_IGNORE:
                        //2.4   A row is has a WriteRowAction of eST_ROW_UPDATE
                        //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
                        //      Result:
                        //      None action, continue validating against 1st row
                            break;
                        default:
                            ASSERT(false && "Invalid Action returned from GetWriteRowAction");
                            continue;
                        }
                    }
                    break;
                case eST_ROW_DELETE:
                    {
                        switch(eMatchingRowAction)
                        {
                        case eST_ROW_INSERT:
                        //3.1   A row is has a WriteRowAction of eST_ROW_DELETE
                        //      A second row (matching the first's PK) is marked as eST_ROW_INSERT
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE
                        //      2nd row marked as eST_ROW_UPDATE
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iMatchingRow, eST_ROW_UPDATE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_UPDATE:
                        //3.2   A row is has a WriteRowAction of eST_ROW_DELETE
                        //      A second row (matching the first's PK) is marked as eST_ROW_UPDATE
                        //      Result:
                        //      Detailed Error - (All rows matching the PK are marked as
                        //                        eST_ROW_IGNORE and Detailed Error is added)
                            ste.hr = E_ST_ROWCONFLICT;//This indicates to log a DetailedError below, on iMatchingRow.
                            break;
                        case eST_ROW_DELETE:
                        //3.3   A row is has a WriteRowAction of eST_ROW_DELETE
                        //      A second row (matching the first's PK) is marked as eST_ROW_DELETE
                        //      Result:
                        //      1st row marked as eST_ROW_IGNORE.
                        //      Stop processing 1st row (processing of the 2nd row will handle
                        //                      additional conflicting PKs).
                            if(FAILED(hr = i_pISTController->SetWriteRowAction(iRow, eST_ROW_IGNORE)))
                                return hr;
                            bContinueProcessingCurrentRow = false;
                            break;
                        case eST_ROW_IGNORE:
                        //3.4   A row is has a WriteRowAction of eST_ROW_DELETE
                        //      A second row (matching the first's PK) is marked as eST_ROW_IGNORE
                        //      Result:
                        //      None action, continue validating against 1st row
                            break;
                        default:
                            ASSERT(false && "Invalid Action returned from GetWriteRowAction");
                            continue;
                        }
                    }
                    break;
                case eST_ROW_IGNORE:
                    //      No other processing needs to be done
                    bContinueProcessingCurrentRow = false;
                    break;
                default:
                    ASSERT(false && "Invalid Action returned from GetWriteRowAction");
                    break;
                }
            }

            if(FAILED(ste.hr))
            {   // Add detailed error
                if(false == saRowHasDetailedErrorLogged[iRow])
                {   //if we haven't already logged iRow as a DetailedError then do it now
                    ste.iColumn = iST_ERROR_ALLCOLUMNS;
                    ste.iRow    = iRow;
                    //ste.hr is set above to trigger this DetailedError

                    saRowHasDetailedErrorLogged[iRow] = true;

                    TRACE (L"Detailed error: hr = 0x%x", hr);

                    hr = i_pISTController->AddDetailedError(&ste);
                    ASSERT(SUCCEEDED(hr));//Not sure what to do if this fails.
                    o_bDetailedError = true;//at least on DetailedError was logged
                }

                ste.iColumn = iST_ERROR_ALLCOLUMNS;
                ste.iRow = iMatchingRow;

                TRACE (L"Detailed error: hr = 0x%x", hr);

                hr = i_pISTController->AddDetailedError(&ste);
                ASSERT(SUCCEEDED(hr));//Not sure what to do if this fails.

                saRowHasDetailedErrorLogged[iMatchingRow] = true;//No further processing for this row
                //o_bDetailedError = true; no need for this since all DetailedErrors are reported to iRow first
                ste.hr = S_OK;//reset the error.
            }//FAILED(ste.hr)

        }//while(bContinueProcessingCurrentRow)
    }//for(iRow = 0; ; iRow++)
    
    return S_OK;
}//ValidateWriteCache


HRESULT CXmlSDT::XMLDelete(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows)
{
    if(0 == cExistingRows)//the row may have already been deleted, which is OK
        return S_OK;

    HRESULT hr;

    if(FAILED(hr = pISTW2->GetWriteColumnValues(iRow, CountOfColumns(), 0, m_aStatus, m_aSizes, m_apvValues)))return hr;

    CComPtr<IXMLDOMNode> pNode_Matching;
    if(FAILED(hr = GetMatchingNode(pNodeList_ExistingRows, pNode_Matching)))
        return hr;//using the ColumnValues we just got, match up with a Node in the list

    if(0 == pNode_Matching.p)//if the node doesn't already exist then presume that it's already been deleted, which is OK.
        return S_OK;

    return RemoveElementAndWhiteSpace(pNode_Matching);
}


HRESULT CXmlSDT::XMLInsert(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows)
{
    HRESULT     hr;
    CComVariant null;//initialized as 'Cleared'
    bool bParentNodeCreated = false;

    ASSERT(pXMLDoc);

    if(FAILED(hr = pISTW2->GetWriteColumnValues(iRow, CountOfColumns(), 0, m_aStatus, m_aSizes, m_apvValues)))
        return hr;

    CComPtr<IXMLDOMNode> pNode_Matching;
    if(FAILED(hr = GetMatchingNode(pNodeList_ExistingRows, pNode_Matching)))
        return hr;//using the ColumnValues we just got, match up with a Node in the list

    if(0 != pNode_Matching.p)//if we found a node matching this one's PKs then we can't add this one.
    {
        LOG_UPDATE_ERROR1(IDS_COMCAT_XML_ROWALREADYEXISTS, E_ST_ROWALREADYEXISTS, -1, L"");
        return E_ST_ROWALREADYEXISTS;
    }


    //OK now we need to find or create this new row's parent
    CComPtr<IXMLDOMNode>    pNode_SiblingParent;
    CComPtr<IXMLDOMNode>    pNode_Parent;

    if(m_bSiblingContainedTable)
    {
        if(FAILED(hr = FindSiblingParentNode(pElementRoot, &pNode_SiblingParent)))
            return hr;

        if(FAILED(hr = pNode_SiblingParent->get_parentNode(&pNode_Parent)))
            return hr;
    }
    //If the table is contained, then the parent (or grandparent) must already exist, so look for it.
    else if(*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_ISCONTAINED)//If this table is contained with another, then we need to find the parent table element
    {                                                                 //that should contain this table.
        //So first find the FKs that belong only one level up (two levels if this table is SCOPEDBYTABLENAME
        unsigned long iFKColumn, iLevel;

        iLevel = (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME) ? 1 : 2;

        for(iFKColumn=0; iFKColumn< CountOfColumns(); ++iFKColumn)
        {   //find the first FK that is at iLevel (one or two), so we know what PublicRowName to search for
            if(m_aLevelOfColumnAttribute[iFKColumn] == iLevel)
                break;
        }
        ASSERT(iFKColumn < CountOfColumns());

        //Before we scan the parent list, let's see if the last parent we saw matches
        if(m_pLastPrimaryTable.p)
        {
            CComPtr<IXMLDOMNode> pNode_Row = m_pLastPrimaryTable;
            
            bool bMatch=true;
            for(unsigned long iColumn=0; bMatch && iColumn < *m_TableMetaRow.pCountOfColumns; ++iColumn)
            {
                if(m_aLevelOfColumnAttribute[iColumn] < iLevel)//We're just trying to match up all of the FKs that describe the containment
                    continue;

                CComPtr<IXMLDOMNode> pNode_RowTemp = pNode_Row;
                //Depending on the column, we may need to look at an element a few levels up.
                unsigned int nLevelOfColumnAttribute = m_aLevelOfColumnAttribute[iColumn] - iLevel;//Only (PK | FK) columns should have a non zero value here
                while(nLevelOfColumnAttribute--)
                {   //Find the correct level of ancestor
                    CComPtr<IXMLDOMNode> pNode_Parent;
                    if(FAILED(hr = pNode_RowTemp->get_parentNode(&pNode_Parent)))
                        return hr;

                    if(pNode_Parent==0)
                        return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                    pNode_RowTemp.Release();
                    pNode_RowTemp = pNode_Parent;
                }
                if(m_awstrChildElementName[iColumn].c_str())//This attribute comes from the child
                {
                    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Row = pNode_RowTemp;
                    CComPtr<IXMLDOMNodeList>                        spNodeList_Children;
                    CComBSTR                                        bstrChildElementName = m_awstrChildElementName[iColumn].c_str();
                    if(0 == bstrChildElementName.m_str)
                        return E_OUTOFMEMORY;
                    if(FAILED(hr = spElement_Row->getElementsByTagName(bstrChildElementName, &spNodeList_Children)))
                        return hr;

                    //It might be more appropriate to use getChildren, then walk the list and find the first node that's an Element.
                    CComPtr<IXMLDOMNode> spChild;
                    if(FAILED(hr = spNodeList_Children->nextNode(&spChild)))
                        return hr;
                    if(spChild == 0)//no children
                    {
                        bMatch = false;
                        continue;
                    }
                    pNode_RowTemp.Release();
                    pNode_RowTemp = spChild;//make this the node we examine
                }
                //Now that we've got the right row, get the IXMLDOMElement interface to it.
                CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_Row = pNode_RowTemp;
                if(0 == pElement_Row.p)return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE)
                {
                    CComBSTR bstrElementName;
                    if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                        return hr;
                    bMatch = m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length());
                    continue;
                }
                CComPtr<IXMLDOMAttribute> pNode_Attr;
                if(FAILED(hr = pElement_Row->getAttributeNode(m_abstrColumnNames[iColumn], &pNode_Attr)))return hr;
                if((0 == pNode_Attr.p) && (0 == m_aDefaultValue[iColumn]))
                {
                    bMatch = false;
                    TRACE2(L"We found the element that matches the public row, no attributes and no default value!\n");
                    continue;
                }
                //The parent element name must match
                CComBSTR bstrElementName;
                if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                    return hr;
                if(!m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length()))
                {
                    bMatch = false;
                    continue;
                }

                CComVariant var_Attr;
                if(0 != pNode_Attr.p)
                {
                    if(FAILED(hr = pNode_Attr->get_value(&var_Attr)))
                        return hr;
                }

                if(FAILED(hr = IsMatchingColumnValue(iColumn, (0 != pNode_Attr.p) ? var_Attr.bstrVal : 0, bMatch)))
                    return hr;
            }

            if(bMatch)//If we walked all the columns and none were a mismatch then we know where the new row belongs
                pNode_Parent = m_pLastParent;
        }

        if(0 == pNode_Parent.p)
        {
            ++m_cCacheMiss;
            //Get the list of rows that match the PrimaryTable's PublicRowName
            CComPtr<IXMLDOMNodeList> pList_Parent;
            if(FAILED(hr = pElementRoot->getElementsByTagName(CComBSTR(m_aPublicRowName[iFKColumn].GetFirstPublicRowName()), &pList_Parent)))return hr;

            if(0 == m_cchLocation)//if there is no query by location, then we have to eliminate the tags by the correct
            {                     //name but at the wrong level
                CComPtr<IXMLDOMNodeList> spNodeListWithoutLocation;
                if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(pList_Parent, m_BaseElementLevel-iLevel, &spNodeListWithoutLocation)))
                    return hr;

                pList_Parent.Release();
                pList_Parent = spNodeListWithoutLocation;
            }

            unsigned long cParentTags;
            if(FAILED(hr = pList_Parent->get_length(reinterpret_cast<long *>(&cParentTags))))return hr;

            //Walk the PrimaryTable rows looking for a match
            while(cParentTags--)
            {
                CComPtr<IXMLDOMNode> pNode_Row;
                if(FAILED(hr = pList_Parent->nextNode(&pNode_Row)))return hr;
            
                //We have to ignore text nodes.
                DOMNodeType nodetype;
                if(FAILED(hr = pNode_Row->get_nodeType(&nodetype)))return hr;
                if(NODE_ELEMENT != nodetype)
                    continue;

                bool bMatch=true;
                for(unsigned long iColumn=0; bMatch && iColumn < *m_TableMetaRow.pCountOfColumns; ++iColumn)
                {
                    if(m_aLevelOfColumnAttribute[iColumn] < iLevel)//We're just trying to match up all of the FKs that describe the containment
                        continue;

                    CComPtr<IXMLDOMNode> pNode_RowTemp = pNode_Row;
                    //Depending on the column, we may need to look at an element a few levels up.
                    unsigned int nLevelOfColumnAttribute = m_aLevelOfColumnAttribute[iColumn] - iLevel;//Only (PK | FK) columns should have a non zero value here
                    while(nLevelOfColumnAttribute--)
                    {   //Find the correct level of ancestor
                        CComPtr<IXMLDOMNode> pNode_Parent;
                        if(FAILED(hr = pNode_RowTemp->get_parentNode(&pNode_Parent)))
                            return hr;

                        if(pNode_Parent==0)
                            return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER; 

                        pNode_RowTemp.Release();
                        pNode_RowTemp = pNode_Parent;
                    }
                    if(m_awstrChildElementName[iColumn].c_str())//This attribute comes from the child
                    {
                        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> spElement_Row = pNode_RowTemp;
                        CComPtr<IXMLDOMNodeList>                        spNodeList_Children;
                        CComBSTR                                        bstrChildElementName = m_awstrChildElementName[iColumn].c_str();
                        if(0 == bstrChildElementName.m_str)
                            return E_OUTOFMEMORY;
                        if(FAILED(hr = spElement_Row->getElementsByTagName(bstrChildElementName, &spNodeList_Children)))
                            return hr;

                        //It might be more appropriate to use getChildren, then walk the list and find the first node that's an Element.
                        CComPtr<IXMLDOMNode> spChild;
                        if(FAILED(hr = spNodeList_Children->nextNode(&spChild)))
                            return hr;
                        if(spChild == 0)//no children
                        {
                            bMatch = false;
                            continue;
                        }
                        pNode_RowTemp.Release();
                        pNode_RowTemp = spChild;//make this the node we examine
                    }
                    //Now that we've got the right row, get the IXMLDOMElement interface to it.
                    CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_Row = pNode_RowTemp;
                    if(0 == pElement_Row.p)return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;

                    if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_NOTPERSISTABLE)
                    {
                        CComBSTR bstrElementName;
                        if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                            return hr;
                        bMatch = m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length());
                        continue;
                    }

                    CComPtr<IXMLDOMAttribute> pNode_Attr;
                    if(FAILED(hr = pElement_Row->getAttributeNode(m_abstrColumnNames[iColumn], &pNode_Attr)))return hr;
                    if((0 == pNode_Attr.p) && (0 == m_aDefaultValue[iColumn]))
                    {
                        bMatch = false;
                        TRACE2(L"We found the element that matches the public row, no attributes and no default value!\n");
                        continue;
                    }
                    //The parent element name must match
                    CComBSTR bstrElementName;
                    if(FAILED(hr = pElement_Row->get_baseName(&bstrElementName)))
                        return hr;
                    if(!m_aPublicRowName[iColumn].IsEqual(bstrElementName.m_str, bstrElementName.Length()))
                    {
                        bMatch = false;
                        continue;
                    }

                    CComVariant var_Attr;
                    if(0 != pNode_Attr.p)
                    {
                        if(FAILED(hr = pNode_Attr->get_value(&var_Attr)))
                            return hr;
                    }

                    if(FAILED(hr = IsMatchingColumnValue(iColumn, (0 != pNode_Attr.p) ? var_Attr.bstrVal : 0, bMatch)))
                        return hr;
                }

                if(bMatch)//If we walked all the columns and none were a mismatch then we know where the new row belongs
                {   
                    m_pLastPrimaryTable.Release();
                    m_pLastPrimaryTable = pNode_Row;
                    if(*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME)
                    {   //If the row exists directly under this PrimaryTable row, then we already have the parent
                        pNode_Parent = pNode_Row;
                        m_pLastParent.Release();
                        m_pLastParent = pNode_Parent;
                        break;
                    }
                    else
                    {   //otherwise we need to search to see if a PublicTableName element already exists under this element
                        CComQIPtr<IXMLDOMElement, &_IID_IXMLDOMElement> pElement_Row = pNode_Row;
                        CComPtr<IXMLDOMNodeList> pNode_List;


						// getElementsByTagName returns all children recursively, so also grand children, grand grand
						// children, etc are returned. So we have to loop through all the children, and ensure that we
						// only consider the direct children of pElement_Row.
                        if(FAILED(hr = pElement_Row->getElementsByTagName(m_bstrPublicTableName, &pNode_List)))
                            return hr;						

						// get current element name
						CComBSTR bstrElement_RowName;
						hr = pElement_Row->get_baseName (&bstrElement_RowName);
						if (FAILED (hr))
						{
							return hr;
						}

						for (;;) // we break out for loop when there are no more children or found correct child.
						{
							CComPtr<IXMLDOMNode> spChildNode;
							hr = pNode_List->nextNode(&spChildNode);
							if (FAILED (hr))
							{
								return hr;
							}
							if (spChildNode.p == 0)
							{
								pNode_Parent = 0;
								break;
							}

							CComPtr<IXMLDOMNode> spParentNode;
							hr = spChildNode->get_parentNode(&spParentNode);
							if (FAILED (hr))
							{
								return hr;
							}

							CComBSTR bstrParentName;
						
							hr = spParentNode->get_baseName (&bstrParentName);
							if (FAILED (hr))
							{
								return hr;
							}				

							if (StringCompare((LPWSTR) bstrParentName, (LPWSTR) bstrElement_RowName) == 0)
							{
								pNode_Parent = spChildNode;
								break;
							}
						}
						
                        if(0 == pNode_Parent.p)//if the public table name does not already exist, we need to create it
                        {
                            CComPtr<IXMLDOMNode> pNode_New;
                            CComVariant varElement(L"element");

                            TComBSTR bstr_NameSpace;
                            if(FAILED(hr = pNode_Row->get_namespaceURI(&bstr_NameSpace)))
                                return hr;//Get the namespace of the table
                            if(FAILED(hr = pXMLDoc->createNode(varElement, m_bstrPublicTableName, bstr_NameSpace, &pNode_New)))
                                return hr;//make the new element of that same namespace
                            if(FAILED(hr = pXMLDoc->put_validateOnParse(kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
                                return hr;

							CComPtr<IXMLDOMNode> spFirstChild;
							ULONG cNewLineChars = 0;
							ULONG cTabs			= m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]];
							if (FAILED(hr = pNode_Row->get_firstChild(&spFirstChild)))
								return hr;

							if (spFirstChild.p == 0)
							{
								cNewLineChars = 1;
							}
							else
							{
								cTabs--;
							}

                            //We don't care about the error here, it will just mean that the XML is unformatted.
                            AppendNewLineWithTabs(cTabs, pXMLDoc, pNode_Row, cNewLineChars);
    
                            //Add the newly create element under the PrimaryTable's row.
                            if(FAILED(hr = pNode_Row->appendChild(pNode_New, &pNode_Parent)))
                                return hr;

                            //We don't care about the error here, it will just mean that the XML is unformatted.
                            AppendNewLineWithTabs(m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]] -1, pXMLDoc, pNode_Row);
                            bParentNodeCreated = true;
                        }
                        m_pLastParent.Release();
                        m_pLastParent = pNode_Parent;
                        break;
                    }
                }
            }
            if(0 == pNode_Parent.p)//If we walked the list of PrimaryTable's PublicRows and didn't find a match then we cannot proceed.  With containment,
            {                      //the PrimaryTable needs to already exist.
                LOG_UPDATE_ERROR1(IDS_COMCAT_XML_PARENTTABLEDOESNOTEXIST, E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST, -1, L"");
                return E_SDTXML_PARENT_TABLE_DOES_NOT_EXIST;
            }
        }
        else
        {
            ++m_cCacheHit;
        }
    }
    else
    {   //If no containment
        if(0 == cExistingRows)
        {   
            //If no existing rows
            if(0 == (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
            {
                //It's still possible that the PublicTableName element exists.  If it is then we don't need to create it.
                CComPtr<IXMLDOMNodeList> pNodeList;
                if(FAILED(hr = pElementRoot->getElementsByTagName(m_bstrPublicTableName, &pNodeList)))return hr;

                if(0 == m_cchLocation)//if there is no query by location
                {
                    CComPtr<IXMLDOMNodeList> pNodeListWithoutLocation;
                    if(FAILED(hr = ReduceNodeListToThoseNLevelsDeep(pNodeList, m_BaseElementLevel-1, &pNodeListWithoutLocation)))
                        return hr;

                    pNodeList.Release();
                    pNodeList = pNodeListWithoutLocation;
                }
                if(FAILED(hr = pNodeList->nextNode(&pNode_Parent)))return hr;
            }

            if(!pNode_Parent)
            {
                if(0 == (*m_TableMetaRow.pSchemaGeneratorFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME))
                {   //if PublicRows are scoped by the Table's PublicName, then create the TablePublicName element
                    //Create the outer TableName element, this becomes the parent to the row to be inserted
                    CComPtr<IXMLDOMNode> pNode_New;
                    CComVariant varElement(L"element");

                    TComBSTR bstr_NameSpace;
                    if(FAILED(hr = pElementRoot->get_namespaceURI(&bstr_NameSpace)))
                        return hr;//Get the namespace of the table
                    if(FAILED(hr = pXMLDoc->createNode(varElement, m_bstrPublicTableName, bstr_NameSpace, &pNode_New)))
                        return hr;//make the new element of that same namespace
    
                    //We don't care about the error here, it will just mean that the XML is unformatted.
                    AppendNewLineWithTabs(m_BaseElementLevel-2, pXMLDoc, pElementRoot, 0);

                    if(FAILED(hr = pElementRoot->appendChild(pNode_New, &pNode_Parent)))
                        return hr;

                    //We don't care about the error here, it will just mean that the XML is unformatted.
                    AppendNewLineWithTabs(0, pXMLDoc, pElementRoot);//we added at the root, so newline only
                    bParentNodeCreated = true;
                }
                else
                {   //if not scoped, then the root is the parent
                    pNode_Parent = pElementRoot;
                }
            }
        }
        else
        {   //If a row already exists (and is not contained) then the first row's parent is the parent of the new row as well.
            CComPtr<IXMLDOMNode> pNode_FirstRow;
            if(FAILED(hr = pNodeList_ExistingRows->reset()))return hr;

            if(FAILED(hr = pNodeList_ExistingRows->nextNode(&pNode_FirstRow)))return hr;

            if(FAILED(hr = pNode_FirstRow->get_parentNode(&pNode_Parent)))
                return hr;

            if(pNode_Parent==0)
                return E_SDTXML_UNEXPECTED_BEHAVIOR_FROM_XMLPARSER;
        }
    }

    CComPtr<IXMLDOMNode> spNodeNew;
    if(FAILED(hr = CreateNewNode(pXMLDoc, pNode_Parent, &spNodeNew)))
        return hr;

    CComPtr<IXMLDOMNode> spNodeNew_Child;
    if(-1 != m_iCol_TableRequiresAdditionChildElement)//sometimes values come from a child element.  So create the child too.
    {
        CComPtr<IXMLDOMNode>    spNode_NewChildTemp;
        CComVariant             varElement(L"element");

        TComBSTR                bstr_NameSpace;
        if(FAILED(hr = pNode_Parent->get_namespaceURI(&bstr_NameSpace)))
            return hr;//Get the namespace of the table

        CComBSTR bstrChildElementName = m_awstrChildElementName[m_iCol_TableRequiresAdditionChildElement].c_str();
        if(0 == bstrChildElementName.m_str)
            return E_OUTOFMEMORY;

        if(FAILED(hr = pXMLDoc->createNode(varElement, bstrChildElementName, bstr_NameSpace, &spNode_NewChildTemp)))
            return hr;//make the new element of that same namespace

        AppendNewLineWithTabs(2+m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]], pXMLDoc, spNodeNew);
        if(FAILED(hr = spNodeNew->appendChild(spNode_NewChildTemp, &spNodeNew_Child)))
            return hr;
		AppendNewLineWithTabs(1+m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]], pXMLDoc, spNodeNew);
    }

    if(FAILED(hr = SetRowValues(spNodeNew, spNodeNew_Child)))
        return hr;
    if(FAILED(hr = pXMLDoc->put_validateOnParse(kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
        return hr;


    if(m_bSiblingContainedTable)
    {
        CComPtr<IXMLDOMNode> pNodeRowToInsertBefore;
        CComPtr<IXMLDOMNode> pNodeJustInserted;
        if(FAILED(hr = pNode_SiblingParent->get_nextSibling(&pNodeRowToInsertBefore)) || 0==pNodeRowToInsertBefore.p)
        {   //if there are no XML siblings, then this is the first row (associated with this SiblingParent)
            if(FAILED(hr = pNode_Parent->appendChild(spNodeNew, &pNodeJustInserted)))
                return hr;
            AppendNewLineWithTabs(m_BaseElementLevel, pXMLDoc, pNode_Parent);
        }
        else
        {   //if there is a XML Sibling, the insert the new row before the existing one.
            CComVariant varNode = pNodeRowToInsertBefore;
            if(FAILED(hr = pNode_Parent->insertBefore(spNodeNew, varNode, &pNodeJustInserted)))
                return hr;
            //if this fails, it's not the end of the world (necessarily).
            InsertNewLineWithTabs(m_BaseElementLevel-1, pXMLDoc, pNodeJustInserted, pNode_Parent);
        }
    }
    else
    {
        //We don't care about the error here, it will just mean that the XML is unformatted.
        if(bParentNodeCreated)//add a newline + tabs
            AppendNewLineWithTabs(m_BaseElementLevel-1, pXMLDoc, pNode_Parent);
        else
		{
			ULONG cNewLines = 0;
			ULONG cNrTabs = 1;
			CComPtr<IXMLDOMNode> spFirstChild;
			hr = pNode_Parent->get_firstChild (&spFirstChild);
			if (FAILED (hr))
			{
				return hr;
			}
			if (spFirstChild.p == 0)
			{
				cNewLines = 1;
				cNrTabs = m_BaseElementLevel - 1;
			}	

            AppendNewLineWithTabs(cNrTabs,pXMLDoc, pNode_Parent, cNewLines);//The next element is always one level higher so insert a single tab
		}

        //insert the new node into the table
        if(FAILED(hr = pNode_Parent->appendChild(spNodeNew, 0)))
            return hr;

        AppendNewLineWithTabs(m_BaseElementLevel-2, pXMLDoc, pNode_Parent);

    }

    return S_OK;
}


HRESULT CXmlSDT::XMLUpdate(ISimpleTableWrite2 *pISTW2, IXMLDOMDocument *pXMLDoc, IXMLDOMElement *pElementRoot, unsigned long iRow, IXMLDOMNodeList *pNodeList_ExistingRows, long cExistingRows)
{
    if(0 == cExistingRows)
    {
        LOG_UPDATE_ERROR1(IDS_COMCAT_XML_ROWDOESNOTEXIST, E_ST_ROWDOESNOTEXIST, -1, L"");
        return E_ST_ROWDOESNOTEXIST;
    }

    HRESULT hr;

    if(FAILED(hr = pISTW2->GetWriteColumnValues(iRow, CountOfColumns(), 0, m_aStatus, m_aSizes, m_apvValues)))
        return hr;

    CComPtr<IXMLDOMNode> pNode_Matching;
    if(FAILED(hr = GetMatchingNode(pNodeList_ExistingRows, pNode_Matching)))
        return hr;//using the ColumnValues we just got, match up with a Node in the list

    if(0 == pNode_Matching.p)
    {
        LOG_UPDATE_ERROR1(IDS_COMCAT_XML_ROWDOESNOTEXIST, E_ST_ROWDOESNOTEXIST, -1, L"");
        return E_ST_ROWDOESNOTEXIST;
    }

    //if there isn't an XMLBlob column OR it's value is NULL, then just update as usual
    if(-1 == m_iXMLBlobColumn || 0 == m_apvValues[m_iXMLBlobColumn])
        return SetRowValues(pNode_Matching);


    //XMLBlob specific
    //But if there is an XMLBlob, remove then do an update by doing Delete and Insert
    CComPtr<IXMLDOMNode> spNodeParent;
    if(FAILED(hr = pNode_Matching->get_parentNode(&spNodeParent)))
        return hr;

    if(FAILED(hr = RemoveElementAndWhiteSpace(pNode_Matching)))
        return hr;

    CComPtr<IXMLDOMNode> spNodeNew;
    if(FAILED(hr = CreateNewNode(pXMLDoc, spNodeParent, &spNodeNew)))
        return hr;
    if(FAILED(hr = SetRowValues(spNodeNew)))
        return hr;
    if(FAILED(hr = pXMLDoc->put_validateOnParse(kvboolFalse)))//Tell parser whether to validate according to an XML schema or DTD
        return hr;

    CComPtr<IXMLDOMText> pNode_Newline;
    TComBSTR    bstrNewline(IsScopedByTableNameElement() ? L"\t" : L"\r\n\t");
    if(FAILED(hr = pXMLDoc->createTextNode(bstrNewline, &pNode_Newline)))
        return hr;
    CComVariant null;//initialized as 'Cleared'
    if(FAILED(hr = spNodeParent->insertBefore(pNode_Newline, null, 0)))
        return hr;

    //and finally insert the new node into the table
    if(FAILED(hr = spNodeParent->appendChild(spNodeNew, 0)))return hr;

    //We don't care about the error here, it will just mean that the XML is unformatted.
    AppendNewLineWithTabs(IsScopedByTableNameElement() ? 1+m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]] : 0, pXMLDoc, spNodeParent);
    return S_OK;
}


// ------------------------------------
// ISimpleTableInterceptor
// ------------------------------------
STDMETHODIMP CXmlSDT::Intercept(    LPCWSTR i_wszDatabase,  LPCWSTR i_wszTable, ULONG i_TableID, LPVOID i_QueryData, LPVOID i_QueryMeta, DWORD i_eQueryFormat,
                                    DWORD i_fLOS,           IAdvancedTableDispenser* i_pISTDisp,    LPCWSTR /*i_wszLocator unused*/,
                                    LPVOID i_pSimpleTable,  LPVOID* o_ppvSimpleTable)
{
    HRESULT hr;

    //If we've already been called to Intercept, then fail
    if(0 != m_IsIntercepted)return E_UNEXPECTED;

    //Some basic parameter validation:
    if(i_pSimpleTable)return E_INVALIDARG;//We're at the bottom of the Table hierarchy.  A table under us is Chewbacca.  This is NOT a logic table.
    if(0 == i_pISTDisp)return E_INVALIDARG;
    if(0 == o_ppvSimpleTable)return E_INVALIDARG;

    ASSERT(0 == *o_ppvSimpleTable && "This should be NULL.  Possible memory leak or just an uninitialized variable.");
    *o_ppvSimpleTable = 0;

    if(eST_QUERYFORMAT_CELLS != i_eQueryFormat)return E_ST_QUERYNOTSUPPORTED;//Verify query type.  
    // For the CookDown process we have a logic table that sits above this during PopulateCache time.
    // Hence we should support fST_LOS_READWRITE 
    if(fST_LOS_MARSHALLABLE & i_fLOS)return E_ST_LOSNOTSUPPORTED;//check table flags

    //We're delay loading OleAut32 so we need to know if it exists before continueing with a read/write table.  Otherwise we'll get an exception the first time we try to use OleAut32.
    {
        static bool bOleAut32Exists = false;
        if(!bOleAut32Exists)
        {
            WCHAR szOleAut32[MAX_PATH];

            GetSystemDirectory(szOleAut32, MAX_PATH);
            wcscat(szOleAut32, L"\\OleAut32.dll");
            if(-1 == GetFileAttributes(szOleAut32))
                return E_UNEXPECTED;//This file should always be there.  It's installed with the system.
            bOleAut32Exists = true;
        }
    }

    //Now that we're done with parameter validation
    //Store for later use the query string and type
    m_fLOS=i_fLOS;

    //Create this singleton for future use
    m_pISTDisp = i_pISTDisp; 
    m_wszTable = i_wszTable;

    //This has nothing to do with InternalSimpleInitialize.  This just gets the meta and saves some of it in a more accessible form.
    //This calls GetTable for the meta.  It should probably call the IST (that we get from GetMemoryTable).
    hr = InternalComplicatedInitialize(i_wszDatabase);
    if(FAILED(hr))return hr;

    STQueryCell *   pQueryCell = (STQueryCell*) i_QueryData;    // Query cell array from caller.

    for(unsigned long iColumn=0; iColumn<*m_TableMetaRow.pCountOfColumns; ++iColumn)
    {
        m_aQuery[iColumn].pData  = 0;
        m_aQuery[iColumn].dbType = 0;
    }

    bool    bNonSpecialQuerySpecified = false;
    int     nQueryCount = i_QueryMeta ? *reinterpret_cast<ULONG *>(i_QueryMeta) : 0;
    while(nQueryCount--)//Get the only query cell we care about, and save the information.
    {
        if(pQueryCell[nQueryCount].iCell & iST_CELL_SPECIAL)
        {
            switch(pQueryCell[nQueryCount].iCell)
            {
            case iST_CELL_LOCATION:
                if(pQueryCell[nQueryCount].pData     != 0                  &&
                   pQueryCell[nQueryCount].eOperator == eST_OP_EQUAL       &&
                   pQueryCell[nQueryCount].dbType    == DBTYPE_WSTR        )
                {
                    ++m_BaseElementLevel;

                    m_cchLocation = (ULONG) wcslen(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
                    m_saLocation = new WCHAR [m_cchLocation + 1];
                    if(0 == m_saLocation.m_p)
                        return E_OUTOFMEMORY;
                    wcscpy(m_saLocation, reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
                    m_bAtCorrectLocation = false;//this indicates that we need to search for the location first
                }
                break;
            case iST_CELL_FILE:
                if(pQueryCell[nQueryCount].pData     != 0                  &&
                   pQueryCell[nQueryCount].eOperator == eST_OP_EQUAL       &&
                   pQueryCell[nQueryCount].dbType    == DBTYPE_WSTR        )
                {
                    if(FAILED(hr = GetURLFromString(reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData))))
                    {
                        if(0 == pQueryCell[nQueryCount].pData)
                        {
                            LOG_POPULATE_ERROR1(IDS_COMCAT_XML_FILENAMENOTPROVIDED, hr, 0);
                        }
                        else
                        {
                            LOG_POPULATE_ERROR1(IDS_COMCAT_XML_FILENAMETOOLONG, hr, reinterpret_cast<WCHAR *>(pQueryCell[nQueryCount].pData));
                        }
                        return hr;
                    }
                }
                break;
            default:
                break;//do nothing on those SPECIAL cells that we don't understand.
            }
        }
        else if(pQueryCell[nQueryCount].iCell < *m_TableMetaRow.pCountOfColumns)
        {
            if(pQueryCell[nQueryCount].dbType    != m_acolmetas[pQueryCell[nQueryCount].iCell].dbType   ||
               pQueryCell[nQueryCount].eOperator != eST_OP_EQUAL                                        ||//We only support EQUAL for now.
               fCOLUMNMETA_NOTPERSISTABLE         & m_acolmetas[pQueryCell[nQueryCount].iCell].fMeta    ||
               0                                 != m_aQuery[pQueryCell[nQueryCount].iCell].pData)//currently we only support one query per column
                return E_ST_INVALIDQUERY;

            bNonSpecialQuerySpecified = true;
            //copy all but pData
            memcpy(&m_aQuery[pQueryCell[nQueryCount].iCell].eOperator, &pQueryCell[nQueryCount].eOperator, sizeof(STQueryCell)-sizeof(LPVOID));
            switch(pQueryCell[nQueryCount].dbType)
            {
                case DBTYPE_UI4:
                    if(0 == pQueryCell[nQueryCount].pData)//pData can't be NULL for this type
                        return E_ST_INVALIDQUERY;
                    {
                        ULONG * pUI4 = new ULONG;
                        if(0 == pUI4)
                            return E_OUTOFMEMORY;
                        m_aQuery[pQueryCell[nQueryCount].iCell].pData = pUI4;
                        *pUI4 = *reinterpret_cast<ULONG *>(pQueryCell[nQueryCount].pData);
                        break;
                    }
                case DBTYPE_WSTR:
                    if(m_acolmetas[pQueryCell[nQueryCount].iCell].fMeta & fCOLUMNMETA_MULTISTRING)
                        return E_ST_INVALIDQUERY;//TODO: We don't yet support query on MULTISZ columns

                    if(pQueryCell[nQueryCount].pData)
                    {
                        LPWSTR pString = new WCHAR[wcslen(reinterpret_cast<LPWSTR>(pQueryCell[nQueryCount].pData)) + 1];
                        if(0 == pString)
                            return E_OUTOFMEMORY;
                        m_aQuery[pQueryCell[nQueryCount].iCell].pData = pString;
                        wcscpy(pString, reinterpret_cast<LPWSTR>(pQueryCell[nQueryCount].pData));
                    }
                    else
                        m_aQuery[pQueryCell[nQueryCount].iCell].pData = 0;
                    break;
                case DBTYPE_GUID:
                    TRACE2(L"Don't support query by GUID");
                    ASSERT(false && "Don't support query by GUID");
                    return E_ST_INVALIDQUERY;
                case DBTYPE_BYTES:
                    TRACE2(L"Don't support query by BYTES");
                    ASSERT(false && "Don't support query by BYTES");
                    return E_ST_INVALIDQUERY;
                default:
                    ASSERT(false && "Don't support this type in a query");
                    return E_ST_INVALIDQUERY;
            }
        }
        else
            return E_ST_INVALIDQUERY;
    }
    if(0x00 == m_wszURLPath[0])//The user must supply a URLPath (which must be a filename for writeable tables).
    {
        LOG_POPULATE_ERROR1(IDS_COMCAT_XML_FILENAMENOTPROVIDED, E_SDTXML_FILE_NOT_SPECIFIED, 0);
        return E_SDTXML_FILE_NOT_SPECIFIED;
    }

    // Place the most likely FALSE condition first
    if((*m_TableMetaRow.pMetaFlags & fTABLEMETA_OVERWRITEALLROWS) && bNonSpecialQuerySpecified && (i_fLOS & fST_LOS_READWRITE))
        return E_ST_INVALIDQUERY;//We don't support this.  Since a write will result in the entire table being overwritten - what would it mean
                                 //to specify a query?  In that case would I wipe out only those rows matching the query?  Or the whole thing?
                                 //I'm going to avoid the confusion completely by dis-allowing queries on this type of table (unless
                                 //the user is asking for a read-only table which makes the writing issue moot).

    hr = i_pISTDisp->GetMemoryTable(i_wszDatabase, i_wszTable, i_TableID, 0, 0, i_eQueryFormat, i_fLOS, reinterpret_cast<ISimpleTableWrite2 **>(o_ppvSimpleTable));
    if(FAILED(hr))return hr;

    InterlockedIncrement(&m_IsIntercepted);//We can only be called to Intercept once.

    return S_OK;
}


// ------------------------------------
// IInterceptorPlugin
// ------------------------------------
STDMETHODIMP CXmlSDT::OnPopulateCache(ISimpleTableWrite2* i_pISTW2)
{
    SetErrorInfo(0, 0);
    HRESULT hr = MyPopulateCache(i_pISTW2);

    m_spISTError.Release();//If we had an error, the SetErrorInfo did an AddRef.  We don't want to keep a ref count any longer.
    return hr;
}


STDMETHODIMP CXmlSDT::OnUpdateStore(ISimpleTableWrite2* i_pISTW2)
{
    SetErrorInfo(0,0);
    HRESULT hr = MyUpdateStore(i_pISTW2);

    m_spISTError.Release();//If we had an error, the SetErrorInfo did an AddRef.  We don't want to keep a ref count any longer.
    return hr;
}


// ------------------------------------
// TXmlParsedFileNodeFactory
// ------------------------------------
HRESULT CXmlSDT::CreateNode(const TElement &Element)//IXMLNodeSource * i_pSource, PVOID i_pNodeParent, USHORT i_cNumRecs, XML_NODE_INFO ** i_apNodeInfo, unsigned long CurrentLevel)
{
    //The other types are needed for XMLBlobs only.  They are handled by calling Element.Next(), so we only need to
    if(XML_ELEMENT != Element.m_ElementType || !(Element.m_NodeFlags & fBeginTag))// acknowledge XML_ELEMENTs
        return S_OK;

    if(m_LevelOfBasePublicRow && (Element.m_LevelOfElement + m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]]) < m_LevelOfBasePublicRow)
        return E_SDTXML_DONE;//We're done

#ifdef _DEBUG
    if(0 != m_LevelOfBasePublicRow && m_LevelOfBasePublicRow != m_BaseElementLevel)
    {
       int x;
    }
#endif

    if(1==Element.m_LevelOfElement)
    {
        m_bInsideLocationTag = (8/*wcslen(L"location")*/ == Element.m_ElementNameLength && 0 == memcmp(Element.m_ElementName, L"location", Element.m_ElementNameLength * sizeof(WCHAR)));
        if(fBeginEndTag == (Element.m_NodeFlags & fBeginEndTag))//We can't be inside a location when it's like: <location path="foo"/>
            m_bInsideLocationTag = false;
    }

    if(m_bInsideLocationTag && 0==m_cchLocation && 1<Element.m_LevelOfElement)
        return S_OK;

    if(!m_bAtCorrectLocation)
    {
        ASSERT(m_cchLocation>0);
        ASSERT(m_saLocation.m_p != 0);
        if(1!=Element.m_LevelOfElement)
            return S_OK;
        if(8/*wcslen(L"location")*/ != Element.m_ElementNameLength || 0 != memcmp(Element.m_ElementName, L"location", Element.m_ElementNameLength * sizeof(WCHAR)))
            return S_OK;

        ULONG iLocationAttr=0;
        for(;iLocationAttr<Element.m_NumberOfAttributes; ++iLocationAttr)
        {
            if( 4/*wcslen(L"path")*/    != Element.m_aAttribute[iLocationAttr].m_NameLength        ||
                0                       != memcmp(Element.m_aAttribute[iLocationAttr].m_Name, L"path", sizeof(WCHAR)*Element.m_aAttribute[iLocationAttr].m_NameLength))
                continue;
            if( m_cchLocation           != Element.m_aAttribute[iLocationAttr].m_ValueLength       ||                                             
                0                       != _memicmp(Element.m_aAttribute[iLocationAttr].m_Value, m_saLocation, m_cchLocation * sizeof(WCHAR)))
                return S_OK;
            m_bAtCorrectLocation = true;
            break;
        }
        if(!m_bAtCorrectLocation)
            return S_OK;
    }
    else if(1==Element.m_LevelOfElement && m_cchLocation)//if we were at the correct location AND we hit another Level 1 element then
    {                                   //we're not at the correct location anymore
        m_bAtCorrectLocation = false;
        return E_SDTXML_DONE;//We're done
    }

    //This is kind of a hack.  IMembershipCondition is the child of CodeGroup (which is an XML Blob; but it's also the PublicRowName of
    //FullTrustAssembly.  So we get confused when we seen an IMembershipCondition because ALL of the parent elements match up. EXCEPT,
    //for one, the FullTrustAssemblies element, which we would normally ignore since it's just the TableName scoping and has no real use
    //(no columns come from this element).  And normally we would prevent two different IMembershipCondition elements when compiling the
    //meta; but it's inside a blob.  Thus our dilema.  We won't be solving this for the general case.  We'll just fix the particular
    //problem as it relates to FullTrustAssembly.  We'll do this by comparing the element name with the Table's PublicName when the
    //table IS SCOPEDBYTABLENAME (TableMeta::SchemaGeneratorFlags NOTSCOPEDBYTABLENAME is NOT set);  AND we're at one level above the
    //m_LevelOfBasePublicRow.

    //if this table is SCOPED BY TABLENAME,  AND we've already determined the m_LevelOfBasePublicRow,  
    if(IsScopedByTableNameElement() && m_LevelOfBasePublicRow>0)
    {
        if(Element.m_LevelOfElement<(m_LevelOfBasePublicRow-1))
        {   //if we at a level above the parent, then set to TRUE
            m_bMatchingParentOfBasePublicRowElement = true;
        }
        else if((m_LevelOfBasePublicRow-1)==Element.m_LevelOfElement)
        {   //if we're at one level above the m_LevelOfBasePublicRow, then compare the element name with the Table's PublicName
            m_bMatchingParentOfBasePublicRowElement = false;
            if(m_cchTablePublicName != Element.m_ElementNameLength)
                return S_OK;
            if(0 != memcmp(Element.m_ElementName, m_TableMetaRow.pPublicName, Element.m_ElementNameLength * sizeof(WCHAR)))
                return S_OK;
            m_bMatchingParentOfBasePublicRowElement = true;
        }
        //if we're below the level of the SCOPING PARENT element, then rely on the value as set before when we last compared the parent element name.
    }
    else
    {   //if there's not SCOPINGTABLENAME parent OR if we haven't determined the correct m_LevelOfBasePublicRow, then consider it a match.
        m_bMatchingParentOfBasePublicRowElement = true;
    }

    //if we're not under the correct parent then bail right away
    if(!m_bMatchingParentOfBasePublicRowElement)
        return S_OK;

    HRESULT hr;
    unsigned long iSortedColumn = m_iSortedColumn;

    //If we're not even at the correct level, then we can bail out right away.
    if(m_LevelOfBasePublicRow)
    {
        if(m_bSiblingContainedTable && m_LevelOfBasePublicRow==Element.m_LevelOfElement)
        {
            if(m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstParentLevelColumn]].IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
            {
                iSortedColumn   = m_iSortedFirstParentLevelColumn;
                m_iSortedColumn = m_iSortedFirstParentLevelColumn;
            }
            else if(m_aPublicRowName[m_aColumnsIndexSortedByLevel[m_iSortedFirstChildLevelColumn]].IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
            {
                iSortedColumn   = m_iSortedFirstChildLevelColumn;
                m_iSortedColumn = m_iSortedFirstChildLevelColumn;
            }
            else
            {
                return S_OK;//must be a comment or some other element
            }
        }
        else
        {
            //as we go back up in level (smaller number) we need to decrement the iSortedColumn to match the column level.
            if(Element.m_LevelOfElement < (m_LevelOfBasePublicRow - m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]))
            {   //If we're at a level less than or equal to the previous columns level, 
                if(m_bEnumPublicRowName_NotContainedTable_ParentFound)
                    return E_SDTXML_DONE;
                if(iSortedColumn && (Element.m_LevelOfElement <= (m_LevelOfBasePublicRow - m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn-1]])))
                {   //then we need to decroment m_iSortedColumn to a column of this level or less
                    while(Element.m_LevelOfElement <= (m_LevelOfBasePublicRow - m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]))
                    {
                        --iSortedColumn;
                        if(~0x00 == iSortedColumn)
                            break;
                    }
                    m_iSortedColumn = ++iSortedColumn;
                }
            }
            //This is NOT an else if, the decrement above may have resulted in the level being greater than the level of the row we're interested in.
            if(Element.m_LevelOfElement > (m_LevelOfBasePublicRow - m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]))
                return S_OK;
        }
    }

    //EnumPublicRowName tables either need to be scoped by their table name OR by their parent table.  We have the case covered if
    //the EnumPublicRowName table is contained under another table; but there is a problem when the EnumPublicRowName table is
    //only scoped by its TableName element.  If we only search for elements matching the EnumPublicRowName(s) then we will erroroneously
    //match row names from a different table.  To prevent this we need to keep track of, not only what level, but whether the element
    //we're checking is a child of the TableName element.  Since our internal structure isn't a tree structure and doesn't have a pointer
    //to the parent element, we need to check for it as we go and remember whether we've seen it.

    if(!m_bEnumPublicRowName_NotContainedTable_ParentFound && IsEnumPublicRowNameTable() && !IsContainedTable())//if this table is NOT contained.
    {
        ASSERT(IsScopedByTableNameElement());
        if(!IsScopedByTableNameElement())
            return E_SDTXML_UNEXPECTED;//Catutil should enforce this but doesn't right now (now is 2/3/00)

        //Is the table name a match with the current node?
        if(0 == memcmp(Element.m_ElementName, m_TableMetaRow.pPublicName, Element.m_ElementNameLength * sizeof(WCHAR)) && 0x00==m_TableMetaRow.pPublicName[Element.m_ElementNameLength])
        {//if so remember the m_LevelOfBasePublicRow
//@@@            if(0 == m_LevelOfBasePublicRow)
                m_LevelOfBasePublicRow = 1 + Element.m_LevelOfElement;//1 level below this element.
            m_bEnumPublicRowName_NotContainedTable_ParentFound = true;
        }
        //If this IS the TableName element, then we set the bool and return
        //If this is NOT the TableName element, (and since we haven't already seen the TableName element) there's no need to continue.
        return S_OK;
    }
    else if(IsEnumPublicRowNameTable() && IsContainedTable() && IsScopedByTableNameElement())
    {
        //Is the table name a match with the current node?
        if(0 == m_LevelOfBasePublicRow && 0 == memcmp(Element.m_ElementName, m_TableMetaRow.pPublicName, Element.m_ElementNameLength * sizeof(WCHAR)) && 0x00==m_TableMetaRow.pPublicName[Element.m_ElementNameLength])
        {//if so remember the m_LevelOfBasePublicRow
            m_LevelOfBasePublicRow = 1 + Element.m_LevelOfElement;//1 level below this element.
            m_bEnumPublicRowName_ContainedTable_ParentFound = true;
            return S_OK;
        }
        else if(0 != m_LevelOfBasePublicRow && (m_LevelOfBasePublicRow == 1 + Element.m_LevelOfElement))//Everytime we're at the parent element level, check to see that the parent matches
        {
            m_bEnumPublicRowName_ContainedTable_ParentFound = (0 == memcmp(Element.m_ElementName, m_TableMetaRow.pPublicName, Element.m_ElementNameLength * sizeof(WCHAR)) && 0x00==m_TableMetaRow.pPublicName[Element.m_ElementNameLength]);
            return S_OK;
        }
        if(m_LevelOfBasePublicRow == Element.m_LevelOfElement && !m_bEnumPublicRowName_ContainedTable_ParentFound)
            return S_OK;//If we're at the BasePublicRow and we haven't found the scoped TableName element, there's no need to process this element
    }





    if(!m_aPublicRowName[m_aColumnsIndexSortedByLevel[iSortedColumn]].IsEqual(Element.m_ElementName, Element.m_ElementNameLength))
        return S_OK;//If the tag name of this element doesn't match the PublicRowName of the column we're looking for then ignore it.

    if(0 == m_LevelOfBasePublicRow)//The first time we find a match of the parent most PublicRowName, we can set
    {                              //the level of the base public row.
        ASSERT(0 == iSortedColumn);//the 0th sorted column is the parent most column.
        m_LevelOfBasePublicRow = m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[0]] + Element.m_LevelOfElement;
    }

    //Continue traversing through the columns until we reach the last column, OR one that's at a different level, OR one that doesn't match the query.
    unsigned long Level = m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]];

    //if we have an EnumPublicRowName, then fill it in first
    if(m_LevelOfBasePublicRow==Element.m_LevelOfElement && IsEnumPublicRowNameTable())
    {
        unsigned long iColumn = m_iPublicRowNameColumn;

        LPCWSTR pwcText = Element.m_ElementName;
        ULONG   ulLen   = Element.m_ElementNameLength;

        bool bMatch = false;
        if(0 == m_aQuery[iColumn].dbType || 0 != m_aQuery[iColumn].pData)//If no query OR the query data is NOT NULL then proceed.
        {
            if(FAILED(hr = FillInColumn(iColumn, pwcText, ulLen, m_acolmetas[iColumn].dbType, m_acolmetas[iColumn].fMeta,
                        bMatch)))return hr;
            if(!bMatch)//If not a match then we're done with this element and this level.
                return S_OK;
        }
    }

    ULONG iSortedColumnExit = CountOfColumns();
    if(m_bSiblingContainedTable && iSortedColumn==m_iSortedFirstParentLevelColumn)
    {   //if we're at Level zero and this is a SiblingContainedTable, we need to know whether we're populating
        //the parent or the child columns
        iSortedColumnExit = m_iSortedFirstChildLevelColumn;
    }

    for(;iSortedColumn<iSortedColumnExit && Level == m_aLevelOfColumnAttribute[m_aColumnsIndexSortedByLevel[iSortedColumn]]; ++iSortedColumn)
    {
        unsigned long iColumn = m_aColumnsIndexSortedByLevel[iSortedColumn];
        if(m_iPublicRowNameColumn==iColumn)//The EnumPublicRowNameColumn has already been filled in.
            continue;
        //Walk the Node array to find the attribute that matches this column
        unsigned long   iAttribute  = 0;
        bool            bMatch      = false;


        //If the column is NOTPERSISTABLE but a PRIMARYKEY we fill it in with anything so that it's not NULL
        //@@@ BUGBUG This is a hack bacause the fast cache can't deal with NULL PK or even Defaulted PK.
        if((m_acolmetas[iColumn].fMeta & (fCOLUMNMETA_NOTPERSISTABLE|fCOLUMNMETA_PRIMARYKEY))==
                                         (fCOLUMNMETA_NOTPERSISTABLE|fCOLUMNMETA_PRIMARYKEY))
        {
            if(m_acolmetas[iColumn].fMeta & fCOLUMNMETA_INSERTUNIQUE)
            {
                if( m_acolmetas[iColumn].dbType != DBTYPE_UI4 &&
                    m_acolmetas[iColumn].dbType != DBTYPE_WSTR)//@@@ ToDo: This should be validated in CatUtil
                    return E_SDTXML_NOTSUPPORTED;

                WCHAR wszInsertUnique[3];
                wszInsertUnique[2] = 0x00;
                *reinterpret_cast<LONG *>(wszInsertUnique) = InterlockedIncrement(&m_InsertUnique);
                if(FAILED(hr = FillInColumn(iColumn, wszInsertUnique, 2, m_acolmetas[iColumn].dbType, m_acolmetas[iColumn].fMeta, bMatch)))//I chose l"00" because it is a valid UI4, Byte array and string
                    return hr;
            }
            else
            {
                if(FAILED(hr = FillInColumn(iColumn, L"00", 2, m_acolmetas[iColumn].dbType, m_acolmetas[iColumn].fMeta, bMatch)))//I chose l"00" because it is a valid UI4, Byte array and string
                    return hr;
            }
        }
        else if(m_iXMLBlobColumn == iColumn)
        {
            bool bMatch=false;
            FillInXMLBlobColumn(Element, bMatch);
            if(!bMatch)//If not a match then we're done with this element and this level.
                return S_OK;
        }
        else
        {
            if(0 != m_awstrChildElementName[iColumn].c_str())
            {   //Now we need to walk the children looking for one that matches the TableMeta::ChildElementName
                DWORD LevelOfChildElement = Element.m_LevelOfElement + 1;
                TElement *pNextElement = Element.Next();
                ASSERT(pNextElement);//This can't happen.  We can't be at the end of the file and make it this far

                while((pNextElement->m_LevelOfElement >= Element.m_LevelOfElement)//advance past PCDATA, WHITESPACES and COMMENTs
                        && (pNextElement->m_ElementType != XML_ELEMENT))          //but if we ever see an element at a level above 
                {                                                                 //i_Element.m_LevelOfElement then we're in error
                    pNextElement = pNextElement->Next();                           
                    ASSERT(pNextElement);//This can't happen.  As soon as we're one level above, we bail, so this shouldn't be able to happen
                }

                if(LevelOfChildElement != pNextElement->m_LevelOfElement)//in this case the value is treated as NULL
                {
                    delete [] m_apValue[iColumn];
                    m_apValue[iColumn] = 0;
                    m_aSize[iColumn] = 0;

                    if(FAILED(hr = FillInPKDefaultValue(iColumn, bMatch)))//If this column is a PK with a DefaultValue, then fill it in.
                        return hr;
                    if(!bMatch)//If not a match then we're done with this element and this level.
                        return S_OK;
                }
                else //we found an element
                {
                    if(pNextElement->m_ElementNameLength == m_awstrChildElementName[iColumn].length()
                        && 0==memcmp(pNextElement->m_ElementName, m_awstrChildElementName[iColumn].c_str(), sizeof(WCHAR)*pNextElement->m_ElementNameLength))
                    {
                        if(FAILED(hr = ScanAttributesAndFillInColumn(*pNextElement, iColumn, bMatch)))
                            return hr;
                        if(!bMatch)//If not a match then we're done with this element and this level.
                            return S_OK;
                    }
                    else//For now I'm assuming that the first Element under this one should be the ChildElement we're looking for
                    {   //if it doesn't exist, the treat it as NULL
                        if(FAILED(hr = FillInPKDefaultValue(iColumn, bMatch)))//If this column is a PK with a DefaultValue, then fill it in.
                            return hr;                                        //if it's not a PK then compare with the query
                        if(!bMatch)//If not a match then we're done with this element and this level.
                            return S_OK;
                    }
                }
            }
            else
            {
                if(FAILED(hr = ScanAttributesAndFillInColumn(Element, iColumn, bMatch)))
                    return hr;
                if(!bMatch)//If not a match then we're done with this element and this level.
                    return S_OK;
            }
        }
    }

    //If we reached the last column then we're ready to add the row to the cache
    if(iSortedColumn==CountOfColumns())
    {
        ASSERT(m_pISTW2);
        unsigned long iRow;

        if(FAILED(hr = m_pISTW2->GetWriteRowIndexBySearch(0, m_cPKs, m_saiPKColumns, m_aSizes, reinterpret_cast<void **>(m_apValue), &iRow)))
        {
            if(E_ST_NOMOREROWS == hr)
            {   //If the row doesn't already exist then added it to the WriteCache
                if(FAILED(hr = m_pISTW2->AddRowForInsert(&iRow)))
                    return hr;
                if(FAILED(hr = m_pISTW2->SetWriteColumnValues(iRow, CountOfColumns(), 0, m_aSize, reinterpret_cast<void **>(m_apValue))))
                    return hr;
            }
            else
            {
                return hr;
            }
        }
        else
        {
            LOG_ERROR(Interceptor,(&m_spISTError.p                         /*ppErrInterceptor*/ 
                                   ,m_pISTDisp                             /*pDisp           */ 
                                   ,E_ST_ROWALREADYEXISTS                  /*hrErrorCode     */ 
                                   ,ID_CAT_CAT                             /*ulCategory      */ 
                                   ,IDS_COMCAT_XML_POPULATE_ROWALREADYEXISTS /*ulEvent         */ 
                                   ,L""                                    /*szString1       */ 
                                   ,eSERVERWIRINGMETA_Core_XMLInterceptor  /*ulInterceptor   */ 
                                   ,m_wszTable                             /*szTable         */ 
                                   ,eDETAILEDERRORS_Populate               /*OperationType   */ 
                                   ,iRow                                   /*ulRow           */ 
                                   ,-1                                     /*ulColumn        */ 
                                   ,m_wszURLPath                           /*szConfigSource  */ 
                                   ,eDETAILEDERRORS_ERROR                  /*eType           */ 
                                   ,0                                      /*pData           */ 
                                   ,0                                      /*cbData          */ 
                                   ,0                                      /*MajorVersion    */ 
                                   ,0));                                   /*MinorVersion    */

            return E_ST_ROWALREADYEXISTS;
        }
    }
    else
    {
        //If we didn't reach the end of the list, the we've incremented iSortedColumn to the next lower level element.  So we'll continue
        //checking and assigning columns at the child.
        m_iSortedColumn = iSortedColumn;
    }


    return S_OK;
}//CreateNode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\stringroutines.cpp ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __catalog_h__
    #include "catalog.h"
#endif
#ifndef _CATALOGMACROS
    #include "catmacros.h"
#endif

static WCHAR * kByteToWchar[256] = 
{
    L"00",    L"01",    L"02",    L"03",    L"04",    L"05",    L"06",    L"07",    L"08",    L"09",    L"0a",    L"0b",    L"0c",    L"0d",    L"0e",    L"0f",
    L"10",    L"11",    L"12",    L"13",    L"14",    L"15",    L"16",    L"17",    L"18",    L"19",    L"1a",    L"1b",    L"1c",    L"1d",    L"1e",    L"1f",
    L"20",    L"21",    L"22",    L"23",    L"24",    L"25",    L"26",    L"27",    L"28",    L"29",    L"2a",    L"2b",    L"2c",    L"2d",    L"2e",    L"2f",
    L"30",    L"31",    L"32",    L"33",    L"34",    L"35",    L"36",    L"37",    L"38",    L"39",    L"3a",    L"3b",    L"3c",    L"3d",    L"3e",    L"3f",
    L"40",    L"41",    L"42",    L"43",    L"44",    L"45",    L"46",    L"47",    L"48",    L"49",    L"4a",    L"4b",    L"4c",    L"4d",    L"4e",    L"4f",
    L"50",    L"51",    L"52",    L"53",    L"54",    L"55",    L"56",    L"57",    L"58",    L"59",    L"5a",    L"5b",    L"5c",    L"5d",    L"5e",    L"5f",
    L"60",    L"61",    L"62",    L"63",    L"64",    L"65",    L"66",    L"67",    L"68",    L"69",    L"6a",    L"6b",    L"6c",    L"6d",    L"6e",    L"6f",
    L"70",    L"71",    L"72",    L"73",    L"74",    L"75",    L"76",    L"77",    L"78",    L"79",    L"7a",    L"7b",    L"7c",    L"7d",    L"7e",    L"7f",
    L"80",    L"81",    L"82",    L"83",    L"84",    L"85",    L"86",    L"87",    L"88",    L"89",    L"8a",    L"8b",    L"8c",    L"8d",    L"8e",    L"8f",
    L"90",    L"91",    L"92",    L"93",    L"94",    L"95",    L"96",    L"97",    L"98",    L"99",    L"9a",    L"9b",    L"9c",    L"9d",    L"9e",    L"9f",
    L"a0",    L"a1",    L"a2",    L"a3",    L"a4",    L"a5",    L"a6",    L"a7",    L"a8",    L"a9",    L"aa",    L"ab",    L"ac",    L"ad",    L"ae",    L"af",
    L"b0",    L"b1",    L"b2",    L"b3",    L"b4",    L"b5",    L"b6",    L"b7",    L"b8",    L"b9",    L"ba",    L"bb",    L"bc",    L"bd",    L"be",    L"bf",
    L"c0",    L"c1",    L"c2",    L"c3",    L"c4",    L"c5",    L"c6",    L"c7",    L"c8",    L"c9",    L"ca",    L"cb",    L"cc",    L"cd",    L"ce",    L"cf",
    L"d0",    L"d1",    L"d2",    L"d3",    L"d4",    L"d5",    L"d6",    L"d7",    L"d8",    L"d9",    L"da",    L"db",    L"dc",    L"dd",    L"de",    L"df",
    L"e0",    L"e1",    L"e2",    L"e3",    L"e4",    L"e5",    L"e6",    L"e7",    L"e8",    L"e9",    L"ea",    L"eb",    L"ec",    L"ed",    L"ee",    L"ef",
    L"f0",    L"f1",    L"f2",    L"f3",    L"f4",    L"f5",    L"f6",    L"f7",    L"f8",    L"f9",    L"fa",    L"fb",    L"fc",    L"fd",    L"fe",    L"ff"
};

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

HRESULT StringToByteArray(LPCWSTR i_String, unsigned char * o_ByteArray)
{
    ASSERT(i_String);
    ASSERT(o_ByteArray);

    unsigned char chNibble;
    //We have to consider strings with an odd number of characters (like "A9D").  In this case we ignore the last nibble (the 'D')
    while(*i_String && *(i_String+1))
    {
        if(0 != ((*i_String)&(~0x007f)))//is the WCHAR outside the legal range of lower 128 ASCII
            return E_ST_VALUEINVALID;

        chNibble     =  kWcharToNibble[(*i_String++)&0x007f];//The first character is the high nibble
        if(0xff == chNibble)            //is the WCHAR one of the legal BYTE characters (0-9, a-f, A-F)
            return E_ST_VALUEINVALID;

        *o_ByteArray =  chNibble << 4;

        if(0 != ((*i_String)&(~0x007f)))//is the WCHAR outside the legal range of lower 128 ASCII
            return E_ST_VALUEINVALID;

        chNibble     = kWcharToNibble[(*i_String++)&0x007f];   //The second is the low nibble
        if(0xff == chNibble)            //is the WCHAR one of the legal BYTE characters (0-9, a-f, A-F)
            return E_ST_VALUEINVALID;

        *o_ByteArray |= chNibble;
		o_ByteArray++;
    }
    return S_OK;
}

HRESULT StringToByteArray(LPCWSTR i_String, unsigned char * o_ByteArray, ULONG i_cchString)
{
    ASSERT(i_String);
    ASSERT(o_ByteArray);

    //We have to consider strings with an odd number of characters (like "A9D").  In this case we ignore the last nibble (the 'D')
    unsigned char chNibble;
    while(i_cchString>1)
    {
        if(0 != ((*i_String)&(~0x007f)))
            return E_ST_VALUEINVALID;

        chNibble     =  kWcharToNibble[(*i_String++)&0x007f];//The first character is the high nibble
        if(0xff == chNibble)            //is the WCHAR one of the legal BYTE characters (0-9, a-f, A-F)
            return E_ST_VALUEINVALID;

        *o_ByteArray =  chNibble << 4;

        if(0 != ((*i_String)&(~0x007f)))//is the WCHAR outside the legal range of lower 128 ASCII
            return E_ST_VALUEINVALID;

        chNibble     = kWcharToNibble[(*i_String++)&0x007f];   //The second is the low nibble
        if(0xff == chNibble)            //is the WCHAR one of the legal BYTE characters (0-9, a-f, A-F)
            return E_ST_VALUEINVALID;

        *o_ByteArray |= chNibble;

		o_ByteArray++;
        i_cchString -=2;
    }
    return S_OK;
}

void ByteArrayToString(const unsigned char * i_ByteArray, ULONG i_cbByteArray, LPWSTR o_String)
{
    ASSERT(i_ByteArray);
    ASSERT(i_cbByteArray > 0);
    ASSERT(o_String);

    while(i_cbByteArray--)
    {
        o_String[0] = kByteToWchar[*i_ByteArray][0];//kByteToWchar[*i_ByteArray] is pointing to a two wchar string array (like L"c7").
        o_String[1] = kByteToWchar[*i_ByteArray][1];//So copy the L'c', then copy the L'7'.
        ++i_ByteArray;
        o_String += 2;
    }
    *o_String = L'\0';//NULL terminate the string
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\stringroutines.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __STRINGROUTINES_H__
#define __STRINGROUTINES_H__

//Size of ByteArray is assumed to be large enough
//It should be (wcslen(i_String)/2).  It takes 2 characters to represent a byte and the terminating NULL is ignored.
//HRESULT will return E_FAIL if any of the characters in the string are invalid hex characters
HRESULT StringToByteArray(LPCWSTR i_String, unsigned char * o_ByteArray);

//If i_String is NOT NULL terminated, call this function.
HRESULT StringToByteArray(LPCWSTR i_String, unsigned char * o_ByteArray, ULONG i_cchString);

//The size of the o_String is assumed to be large enough to hold the string representation of the byte array.
//This function can never fail.
void ByteArrayToString(const unsigned char * i_ByteArray, ULONG i_cbByteArray, LPWSTR o_String);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\sdtxml_data.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
#ifndef __SDTXML_DATA_H_
#define __SDTXML_DATA_H_

#include "catalog.h"
#include <objbase.h>

// -----------------------------------------
// struct typedefs:
// -----------------------------------------

//const int kColumnNameSize = 40;
//typedef WCHAR TColumnName[kColumnNameSize] ;

typedef struct							// Simple column meta indexed.
{
	ULONG				iOrder;
	DWORD				dbType;
	ULONG				cbSize;
	DWORD				fMeta;
    LPWSTR              ColumnName;
} SimpleColumnMetaIdx1;

typedef struct							// Map from tid to wiring for fixed data.
{
	const GUID*				ptid;
	LPCWSTR					SimpleColumnMetaArrayName;
} MapTidToMetaArrayName;

extern MapTidToMetaArrayName g_amaptidtowireMETA[];
extern ULONG g_ciMAPTIDTOWIRE_META;


#endif // __SDTXML_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\tlistofxmldomnodelists.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TLISTOFXMLDOMNODELISTS_H__
#define __TLISTOFXMLDOMNODELISTS_H__

//This class was designed so that we could have one XMLNodeList made up of many XMLNodeLists.  This is useful when
//we want to get all the children of multiple Nodes.  At this time there is no need to make the list growable.  Users
//should indicate up front how large the list of lists should be.
class TListOfXMLDOMNodeLists : public _unknown<IXMLDOMNodeList>
{                          
public:
    TListOfXMLDOMNodeLists() : m_SizeMax(0), m_SizeCurrent(0), m_iCurrent(0), m_cItems(0) {_refcount = 0;}
    ~TListOfXMLDOMNodeLists(){}

    HRESULT AddToList(IXMLDOMNodeList *pList)
    {
        HRESULT hr;
        ASSERT(m_SizeCurrent < m_SizeMax);

        m_aXMLDOMNodeList[m_SizeCurrent++] = pList;

        long cItems;
        if(FAILED(hr = pList->get_length(&cItems)))return hr;

        m_cItems += cItems;
        return S_OK;
    }
    HRESULT SetCountOfLists(unsigned long Size)
    {
        m_SizeMax = Size;
        m_aXMLDOMNodeList = new CComPtr<IXMLDOMNodeList>[Size];
        return (!m_aXMLDOMNodeList) ? E_OUTOFMEMORY : S_OK;
    }
//IDispatch methods
    STDMETHOD (GetTypeInfoCount)    (UINT *)        {return E_NOTIMPL;}
    STDMETHOD (GetTypeInfo)         (UINT,
                                     LCID,
                                     ITypeInfo **)  {return E_NOTIMPL;}
    STDMETHOD (GetIDsOfNames)       (REFIID ,
                                     LPOLESTR *,
                                     UINT,
                                     LCID,
                                     DISPID *)      {return E_NOTIMPL;}
    STDMETHOD (Invoke)              (DISPID,
                                     REFIID,
                                     LCID,
                                     WORD,
                                     DISPPARAMS *,
                                     VARIANT *,
                                     EXCEPINFO *,
                                     UINT *)        {return E_NOTIMPL;}
//IXMLDOMNodeList methods
    STDMETHOD (get_item)            (long index,
                                     IXMLDOMNode **){return E_NOTIMPL;}
    STDMETHOD (get_length)          (long * listLength)
    {
        ASSERT(listLength && "What are you doing passing in NULL parameter? TListOfXMLDOMNodeLists::get_length(NULL)");
        *listLength = m_cItems;
        return S_OK;
    }
    STDMETHOD (nextNode)            (IXMLDOMNode ** nextItem)
    {
        *nextItem = 0;
        if(0 == m_cItems)
            return S_OK;

        HRESULT hr;
        if(FAILED(hr = m_aXMLDOMNodeList[m_iCurrent]->nextNode(nextItem)))return hr;
        if(nextItem)//If we found the next node then return
            return S_OK;
        if(++m_iCurrent==m_SizeCurrent)//if we reached the end of the last list, then return, otherwise bump the iCurrent and get the nextNode of the next list
            return S_OK;
        return m_aXMLDOMNodeList[m_iCurrent]->nextNode(nextItem);
    }
    STDMETHOD (reset)               (void)
    {
        HRESULT hr;
        for(m_iCurrent=0; m_iCurrent<m_SizeCurrent; ++m_iCurrent)
        {   //reset all of the individual lists
            if(FAILED(hr = m_aXMLDOMNodeList[m_iCurrent]->reset()))return hr;
        }
        //now point to the 0th one
        m_iCurrent = 0;
        return S_OK;
    }
    STDMETHOD (get__newEnum)        (IUnknown **)   {return E_NOTIMPL;}

private:
    TSmartPointerArray<CComPtr<IXMLDOMNodeList> >   m_aXMLDOMNodeList;
    unsigned long                                   m_cItems;
    unsigned long                                   m_iCurrent;
    unsigned long                                   m_SizeMax;
    unsigned long                                   m_SizeCurrent;
};


#endif //__TLISTOFXMLDOMNODELISTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\tcombstr.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TCOMBSTR_H__
#define __TCOMBSTR_H__


#ifndef __ATLBASE_H__
    #include <atlbase.h>
#endif

//I've defined my own since CComBSTR ALWAYS does a SysFreeString in the dtor.
//This class will not call into OleAut32 if it doesn't have to.  This allow for
//delay loading OleAut32.

//This class is not as complete as CComBSTR.  If you need more functionality
//then just copy and paste new functions from CComBSTR in AtlBase.h.
class TComBSTR
{
public:
	BSTR m_str;
    TComBSTR() : m_str(0){}
	/*explicit*/ TComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	~TComBSTR()
	{
        if(m_str)
		    ::SysFreeString(m_str);
	}
	TComBSTR& operator=(LPCOLESTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = ::SysAllocString(pSrc);
		return *this;
	}
	unsigned int Length() const
	{
		return (m_str == NULL)? 0 : SysStringLen(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	void Empty()
	{
        if(m_str)
		    ::SysFreeString(m_str);
		m_str = NULL;
	}
	bool operator!() const
	{
		return (m_str == NULL);
	}
	bool operator==(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return true;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) == 0;
		return false;
	}
	bool operator==(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return true;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) == 0;
		return false;
	}
};

#endif //__TCOMBSTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\tfilemapping.h ===
//  Copyright (C) 1999-2001 Microsoft Corporation.  All rights reserved.
#ifndef __TFILEMAPPING_H__
#define __TFILEMAPPING_H__


#define E_ERROR_OPENING_FILE    0x80000004


//  TFileMapping
//  
//  This class abstracts the mapping process and guarentees cleanup.
class TFileMapping
{
public:
    TFileMapping() : m_hFile(0), m_hMapping(0), m_pMapping(0), m_Size(0) {}
    ~TFileMapping(){Unload();}

    HRESULT Load(LPCTSTR filename, bool bReadWrite = false)
    {
        ASSERT(0 == m_hFile);
        //We don't do any error checking because the API functions should deal with NULL hFile & hMapping.  Use should check
        //m_pMapping (via Mapping()) before using the object.
        m_hFile = CreateFile(filename, GENERIC_READ | (bReadWrite ? GENERIC_WRITE : 0), FILE_SHARE_READ | (bReadWrite ?  0 : FILE_SHARE_WRITE), NULL, OPEN_EXISTING, FILE_FLAG_RANDOM_ACCESS, NULL);
        m_hMapping = CreateFileMappingA(m_hFile, NULL, (bReadWrite ? PAGE_READWRITE : PAGE_READONLY), 0, 0, NULL);
        m_pMapping = reinterpret_cast<char *>(MapViewOfFile(m_hMapping, (bReadWrite ? FILE_MAP_WRITE : FILE_MAP_READ), 0, 0, 0));
        m_Size = GetFileSize(m_hFile, 0);
        return (0 == m_pMapping) ? E_ERROR_OPENING_FILE : S_OK;
    }
    void Unload()
    {
        if(m_pMapping)
        {
            if(0 == FlushViewOfFile(m_pMapping,0))
            {
                ASSERT(false && "ERROR - UNABLE TO FLUSH TO DISK");
            }
            UnmapViewOfFile(m_pMapping);
        }
        if(m_hMapping)
            CloseHandle(m_hMapping);
        if(m_hFile)
            CloseHandle(m_hFile);

        m_pMapping  = 0;
        m_hMapping  = 0;
        m_hFile     = 0;
        m_Size      = 0;
    }
    unsigned long   Size() const {return m_Size;}
    char *          Mapping() const {return m_pMapping;}
    char *          EndOfFile() const {return (m_pMapping + m_Size);}

private:
    HANDLE          m_hFile;
    HANDLE          m_hMapping;
    char *          m_pMapping;
    unsigned long   m_Size;
};

#endif //__TFILEMAPPING_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\eventtest\eventtest.cpp ===
#include "objbase.h"
#include "catalog.h"
#include "catmeta.h"
#include "stdio.h"
#include "catmacros.h"
#include "consumer.h"

#define goto_on_bad_hr(hr, label) if (FAILED (hr)) { goto label; }
HRESULT GetMaxNode(ISimpleTableDispenser2 *pISTDisp, DWORD	*pdwMaxNode);

const ULONG	g_cConsumer = 5;
const ULONG	g_cIteration = 5;

int _cdecl main(int		argc,					// How many input arguments.
				CHAR	*argv[])				// Optional config args.
{
	CEventConsumer	*pConsumer1;
	CEventConsumer	*pConsumer2;
	HRESULT hr;
	ISimpleTableDispenser2* pISTDisp = NULL;	
	ISimpleTableWrite2* pISimpleTableWrite = NULL;
	ISimpleTableEvent* pISTEvent = NULL;
	ISimpleTableEvent* pISTEvent2 = NULL;
	ISimpleTableAdvise* pISTAdvise = NULL;
	ISimpleTableAdvanced* pISTAdv = NULL;
	DWORD		dwCookie[g_cConsumer];
	ULONG		i;
	ULONG		j;
	DWORD		iUpdateCol;
	ULONG		iNode;
	ULONG		iParent = 30;
	LPWSTR		szName = L"CorpSrv";
	DWORD		dwMaxNode = 0;
	ULONG		iWriteRow;

	MultiSubscribe ams1 = {wszDATABASE_WONS, wszTABLE_WONSIDS, NULL, NULL, eST_QUERYFORMAT_CELLS};

	// Get the dispenser.
	hr = GetSimpleTableDispenser (WSZ_PRODUCT_URT, 0, &pISTDisp);
	if ( FAILED(hr) ) return hr;

	hr = pISTDisp->QueryInterface(IID_ISimpleTableAdvise, (LPVOID*) &pISTAdvise);
	if ( FAILED(hr) ) return hr;

	pConsumer1 = new CEventConsumer;
	pConsumer1->QueryInterface(IID_ISimpleTableEvent, (void**) &pISTEvent);
	
	// Get max node so that no duplicates are inserted.
	hr = GetMaxNode(pISTDisp, &dwMaxNode);
	goto_on_bad_hr( hr, Cleanup );
	iNode = dwMaxNode+1;

	for (j = 0; j < g_cIteration; j++)
	{
		// Sign-up for events.
		for (i = 0; i < g_cConsumer; i++)
		{
			hr = pISTAdvise->SimpleTableAdvise(pISTEvent, 0, &ams1, 1, &dwCookie[i]);
			goto_on_bad_hr( hr, Cleanup );
			pISTEvent->AddRef();
		}
		pConsumer1->CopySubscription(&ams1, 1);

		LPVOID apv[3];
		
		apv[0] = &iNode;
		apv[1] = szName;
		apv[2] = &iParent;

		hr = pISTDisp->GetTable (wszDATABASE_WONS, wszTABLE_WONSIDS, NULL, NULL, eST_QUERYFORMAT_CELLS, 
			fST_LOS_READWRITE, (void**)&pISimpleTableWrite );
		goto_on_bad_hr( hr, Cleanup );
		hr = pISimpleTableWrite->QueryInterface(IID_ISimpleTableAdvanced, (void**) &pISTAdv);
		goto_on_bad_hr( hr, Cleanup );

		// Actions taken on the table.
		// Add three rows.
		for (i = 0; i < 3; i++, iNode++,iParent++)
		{
			hr = pISimpleTableWrite->AddRowForInsert(&iWriteRow);
			goto_on_bad_hr( hr, Cleanup );
			
			hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 3, 0, 0, apv );
			goto_on_bad_hr( hr, Cleanup );
		}

		hr = pISimpleTableWrite->UpdateStore();
		goto_on_bad_hr( hr, Cleanup );

		// Update the three rows.
		hr = pISTAdv->PopulateCache();
		goto_on_bad_hr( hr, Cleanup );
		for (i = 0; i < 3; i++)
		{
			hr = pISimpleTableWrite->AddRowForUpdate(i, &iWriteRow);
			goto_on_bad_hr( hr, Cleanup );
			iParent = 444;
			iUpdateCol = 2;
			hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 1, &iUpdateCol, 0, &apv[iUpdateCol] );
			goto_on_bad_hr( hr, Cleanup );
		}

		hr = pISimpleTableWrite->UpdateStore();
		goto_on_bad_hr( hr, Cleanup );

		// Delete a row, update another row.
		hr = pISTAdv->PopulateCache();
		goto_on_bad_hr( hr, Cleanup );
		hr = pISimpleTableWrite->AddRowForUpdate(0, &iWriteRow);
		goto_on_bad_hr( hr, Cleanup );
		apv[1] = L"LastUpdate";
		iUpdateCol = 1;
		hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 1, &iUpdateCol, 0, &apv[iUpdateCol] );
		goto_on_bad_hr( hr, Cleanup );
		hr = pISimpleTableWrite->AddRowForDelete(1);
		goto_on_bad_hr( hr, Cleanup );

		hr = pISimpleTableWrite->UpdateStore();
		goto_on_bad_hr( hr, Cleanup );

		pISimpleTableWrite->Release();
		pISimpleTableWrite = NULL;
		pISTAdv->Release();
		pISTAdv = NULL;

		// Done with eventing, unadvise.
		for (i = 0; i < g_cConsumer; i++)
		{
			hr = pISTAdvise->SimpleTableUnadvise(dwCookie[i]);
			goto_on_bad_hr( hr, Cleanup );
		}
	}

	pISTEvent->Release();
	pISTEvent = NULL;
	pISTAdvise->Release();
	pISTAdvise = NULL;
	pISTDisp->Release();
	pISTDisp = NULL;


Cleanup:
	if (pISTAdv)
		pISTAdv->Release();

	if (pISTDisp)
		pISTDisp->Release();

	if (pISTEvent)
		pISTEvent->Release();

	if (pISTAdvise)
		pISTAdvise->Release();

	if (pISimpleTableWrite)
		pISimpleTableWrite->Release();
		
	return 0;
/*	STQueryCell sCell[] = {{ &iNode,  eST_OP_EQUAL, 0, DBTYPE_UI4, sizeof(ULONG) },
						{szName,  eST_OP_EQUAL, 1, DBTYPE_WSTR, (wcslen(szName)+1) * 2}};
	ULONG	cCells	= sizeof(sCell)/sizeof(STQueryCell);

	// This test requires the STConsumer test compiled and the component registered.
	// Create the two consumers.
	hr = CoCreateInstance (CLSID_Consumer, NULL, CLSCTX_INPROC_SERVER, IID_ISimpleTableEvent, (void**) &pISTEvent);
	if ( FAILED(hr) ) return hr;
	hr = CoCreateInstance (CLSID_Consumer, NULL, CLSCTX_INPROC_SERVER, IID_ISimpleTableEvent, (void**) &pISTEvent2);
	if ( FAILED(hr) ) return hr;

	// Get the dispenser.
	hr = GetSimpleTableDispenser (WSZ_PRODUCT_URT, 0, &pISTDisp);
	if ( FAILED(hr) ) return hr;

	hr = pISTDisp->QueryInterface(IID_ISimpleTableAdvise, (LPVOID*) &pISTAdvise);
	if ( FAILED(hr) ) return hr;

	// Get max node so that no duplicates are inserted.
	hr = GetMaxNode(pISTDisp, &dwMaxNode);
	goto_on_bad_hr( hr, Cleanup );
	iNode = dwMaxNode+1;
	
	// Sign-up for events.
	hr = pISTAdvise->SimpleTableAdvise(pISTEvent, wszDATABASE_WONS, wszTABLE_WONSIDS, NULL, NULL, eST_QUERYFORMAT_CELLS, &dwCookie);
	goto_on_bad_hr( hr, Cleanup );
	pISTEvent->AddRef();

	hr = pISTAdvise->SimpleTableAdvise(pISTEvent2, wszDATABASE_WONS, wszTABLE_WONSIDS, sCell, &cCells, eST_QUERYFORMAT_CELLS, &dwCookie2);
	goto_on_bad_hr( hr, Cleanup );
	pISTEvent2->AddRef();

	LPVOID apv[3];
	
	apv[0] = &iNode;
	apv[1] = szName;
	apv[2] = &iParent;

	hr = pISTDisp->GetTable (wszDATABASE_WONS, wszTABLE_WONSIDS, NULL, NULL, eST_QUERYFORMAT_CELLS, 
		fST_LOS_READWRITE, (void**)&pISimpleTableWrite );
	goto_on_bad_hr( hr, Cleanup );
	hr = pISimpleTableWrite->QueryInterface(IID_ISimpleTableAdvanced, (void**) &pISTAdv);
	goto_on_bad_hr( hr, Cleanup );

	// Actions taken on the table.
	// Add three rows.
	for (i = 0; i < 3; i++, iNode++,iParent++)
	{
		hr = pISimpleTableWrite->AddRowForInsert(&iWriteRow);
		goto_on_bad_hr( hr, Cleanup );
		
		hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 3, 0, 0, apv );
		goto_on_bad_hr( hr, Cleanup );
	}

	hr = pISimpleTableWrite->UpdateStore();
	goto_on_bad_hr( hr, Cleanup );

	// Update the three rows.
	hr = pISTAdv->PopulateCache();
	goto_on_bad_hr( hr, Cleanup );
	for (i = 0; i < 3; i++)
	{
		hr = pISimpleTableWrite->AddRowForUpdate(i, &iWriteRow);
		goto_on_bad_hr( hr, Cleanup );
		iParent = 444;
		iUpdateCol = 2;
		hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 1, &iUpdateCol, 0, &apv[iUpdateCol] );
		goto_on_bad_hr( hr, Cleanup );
	}

	hr = pISimpleTableWrite->UpdateStore();
	goto_on_bad_hr( hr, Cleanup );

	// Delete a row, update another row.
	hr = pISTAdv->PopulateCache();
	goto_on_bad_hr( hr, Cleanup );
	hr = pISimpleTableWrite->AddRowForUpdate(0, &iWriteRow);
	goto_on_bad_hr( hr, Cleanup );
	apv[1] = L"LastUpdate";
	iUpdateCol = 1;
	hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 1, &iUpdateCol, 0, &apv[iUpdateCol] );
	goto_on_bad_hr( hr, Cleanup );
	hr = pISimpleTableWrite->AddRowForDelete(1);
	goto_on_bad_hr( hr, Cleanup );

	hr = pISimpleTableWrite->UpdateStore();
	goto_on_bad_hr( hr, Cleanup );

	// Done with eventing, unadvise.
	hr = pISTAdvise->SimpleTableUnadvise(dwCookie);
	goto_on_bad_hr( hr, Cleanup );
	hr = pISTAdvise->SimpleTableUnadvise(dwCookie2);
	goto_on_bad_hr( hr, Cleanup );

Cleanup:
	if (pISTAdv)
		pISTAdv->Release();

	if (pISTDisp)
		pISTDisp->Release();

	if (pISTEvent)
		pISTEvent->Release();

	if (pISTEvent2)
		pISTEvent2->Release();

	if (pISTAdvise)
		pISTAdvise->Release();

	if (pISimpleTableWrite)
		pISimpleTableWrite->Release();
		
	CoUninitialize();
*/
}

HRESULT GetMaxNode(ISimpleTableDispenser2 *pISTDisp, DWORD	*pdwMaxNode)
{
	ISimpleTableRead2 *pISimpleTableRead = NULL;
	ULONG		dwColumn = iWONSIDS_NodeId;
	DWORD		*pdwNode;
	ULONG		i;
	HRESULT		hr = S_OK;

	// Find the largest node id.
	*pdwMaxNode = 0;

	hr = pISTDisp->GetTable (wszDATABASE_WONS, wszTABLE_WONSIDS, NULL, NULL, eST_QUERYFORMAT_CELLS, 
		0, (void**)&pISimpleTableRead );
	if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
		return S_OK;
	goto_on_bad_hr( hr, Cleanup );

	for (i = 0; ; i++)
	{
		hr = pISimpleTableRead->GetColumnValues( i, 1, &dwColumn, NULL, (LPVOID*)&pdwNode);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}
		goto_on_bad_hr( hr, Cleanup );
		if (*pdwMaxNode < *pdwNode)
			*pdwMaxNode = *pdwNode;
	}
Cleanup:
	if (pISimpleTableRead)
		pISimpleTableRead->Release();

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\eventtest\stconsumer_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Sat Jul 31 12:26:00 1999
 */
/* Compiler settings for D:\Catalog42\SRC\test\STConsumer\STConsumer.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_STCONSUMERLib = {0x279A675A,0xC4C6,0x4DA0,{0xAE,0x23,0x5E,0x13,0x38,0x58,0x23,0xE0}};


const CLSID CLSID_Consumer = {0x548806D1,0x9EBC,0x4B84,{0x8C,0x11,0x7C,0x8E,0x42,0x71,0x68,0x0F}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\tpublicrowname.h ===
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.
#ifndef __TPUBLICROWNAME_H__
#define __TPUBLICROWNAME_H__

class TPublicRowName
{
public:
    TPublicRowName() : m_cPublicRowNames(0){}
    HRESULT Init(LPCWSTR wszPublicRowName)
    {
        m_cPublicRowNames       = 1;
        m_awstrPublicRowName    = m_fixed_awstrPublicRowName;
        m_awstrPublicRowName[0] = wszPublicRowName;
        return (m_awstrPublicRowName[0].c_str() == 0) ? E_OUTOFMEMORY : S_OK;
    }
    HRESULT Init(tTAGMETARow *aTags, int cTags)
    {
        m_cPublicRowNames       = cTags;
        if(m_cPublicRowNames <= m_kFixedSize)
        {
            m_awstrPublicRowName        = m_fixed_awstrPublicRowName;
        }
        else
        {
            m_alloc_awstrPublicRowName  = new wstring[m_cPublicRowNames];
			if (m_alloc_awstrPublicRowName == 0)
				return E_OUTOFMEMORY;

            m_awstrPublicRowName        = m_alloc_awstrPublicRowName;
        }

        for(unsigned int i=0; i<m_cPublicRowNames; ++i)
        {
            m_awstrPublicRowName[i] = aTags[i].pPublicName;
            if(m_awstrPublicRowName[i].c_str() == 0)
                return E_OUTOFMEMORY;
        }
        return S_OK;
    }

    bool IsEqual(LPCWSTR wsz, unsigned int StringLength) const
    {
        ASSERT(0 != m_cPublicRowNames);
        for(unsigned int i=0; i<m_cPublicRowNames; ++i)
        {
            if(StringLength == m_awstrPublicRowName[i].length() && 0 == wcscmp(wsz, m_awstrPublicRowName[i]))
                return true;
        }
        return false;
    }
    LPCWSTR GetFirstPublicRowName() const {return m_awstrPublicRowName[0].c_str();}
    LPCWSTR GetLastPublicRowName() const {return m_awstrPublicRowName[m_cPublicRowNames-1].c_str();}
private:
    enum
    {
        m_kFixedSize = 3  //This leaves enough room for 'Insert', 'Update' and 'Delete' and other triplet directives.
    };
    wstring                         m_fixed_awstrPublicRowName[m_kFixedSize];
    TSmartPointerArray<wstring>     m_alloc_awstrPublicRowName;
    wstring *                       m_awstrPublicRowName;
    unsigned int                    m_cPublicRowNames;
};

#endif //__TPUBLICROWNAME_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\txmldomnodelist.h ===
//  Copyright (C) 1999 Microsoft Corporation.  All rights reserved.
#ifndef __TXMLDOMNODELIST_H__
#define __TXMLDOMNODELIST_H__

//We need to be able to take an XMLDOMNodeList and further refine the list.  IXMLDOMNodeList doesn't allow us to do that, so this class will.
//For example,  I can call GetElementsByTagName, then walk the resulting list, and add each Node that has a given Attribute to my TXMLDOMNodeList.
//I can then pass this new list around as an IXMLDOMNodeList.
//
//This class was implemented to Add items to the list - it does NOT support removing them!
class TXMLDOMNodeList : public _unknown<IXMLDOMNodeList>
{                          
public:
    TXMLDOMNodeList() : m_cItems(0), m_pCurrent(reinterpret_cast<LinkedXMLDOMNodeItem *>(-1)), m_pFirst(0), m_pLast(0){}
    ~TXMLDOMNodeList()
    {
        //delete the whole list (the XMLDOMNode smart pointers will release themselves
        while(m_pFirst)
        {
            m_pCurrent = m_pFirst->m_pNext;
            delete m_pFirst;
            m_pFirst = m_pCurrent;
        }
    }

    HRESULT AddToList(IXMLDOMNode *pNode)
    {
        ASSERT(pNode && "Idiot passing NULL!!! TXMLDOMNodeList::AddToList(NULL).");

        LinkedXMLDOMNodeItem *  pNewItem = new LinkedXMLDOMNodeItem(pNode);
        if(0 == pNewItem)
            return E_OUTOFMEMORY;

        if(0 == m_pLast)
        {
            ASSERT(0 == m_cItems);
            ASSERT(0 == m_pFirst);

            m_pFirst = pNewItem;
            m_pLast  = pNewItem;
        }
        else
        {
            m_pLast->m_pNext    = pNewItem;
            m_pLast             = pNewItem;
        }

        ++m_cItems;
        return S_OK;
    }
//IDispatch methods
    STDMETHOD (GetTypeInfoCount)    (UINT *)        {return E_NOTIMPL;}
    STDMETHOD (GetTypeInfo)         (UINT,
                                     LCID,
                                     ITypeInfo **)  {return E_NOTIMPL;}
    STDMETHOD (GetIDsOfNames)       (REFIID ,
                                     LPOLESTR *,
                                     UINT,
                                     LCID,
                                     DISPID *)      {return E_NOTIMPL;}
    STDMETHOD (Invoke)              (DISPID,
                                     REFIID,
                                     LCID,
                                     WORD,
                                     DISPPARAMS *,
                                     VARIANT *,
                                     EXCEPINFO *,
                                     UINT *)        {return E_NOTIMPL;}
//IXMLDOMNodeList methods
    STDMETHOD (get_item)            (long index,
                                     IXMLDOMNode **){return E_NOTIMPL;}
    STDMETHOD (get_length)          (long * listLength)
    {
        ASSERT(listLength && "Idiot passing NULL!!! TXMLDOMNodeList::get_length(NULL)");
        *listLength = m_cItems;
        return S_OK;
    }
    STDMETHOD (nextNode)            (IXMLDOMNode ** nextItem)
    {
        ASSERT(nextItem && "Idiot passing NULL!!! TXMLDOMNodeList::nextNode(NULL)");

        *nextItem = 0;
        if(0 == m_cItems)
            return S_OK;
        if(0 == m_pCurrent)
            return S_OK;

        if(-1 == reinterpret_cast<INT_PTR>(m_pCurrent))
            m_pCurrent = m_pFirst;
        else
            m_pCurrent = m_pCurrent->m_pNext;

        if(0 == m_pCurrent)
            return S_OK;

        *nextItem =  m_pCurrent->m_spNode;
        (*nextItem)->AddRef();
        return S_OK;
    }
    STDMETHOD (reset)               (void)
    {
        m_pCurrent = reinterpret_cast<LinkedXMLDOMNodeItem *>(-1);//zero indicated that we're at the end of the list: -1 indicates that we're at the beginning
        return S_OK;
    }
    STDMETHOD (get__newEnum)        (IUnknown **)   {return E_NOTIMPL;}

private:
    struct LinkedXMLDOMNodeItem
    {
        LinkedXMLDOMNodeItem(IXMLDOMNode *pNode) : m_spNode(pNode), m_pNext(0){}
        CComPtr<IXMLDOMNode> m_spNode;
        LinkedXMLDOMNodeItem *m_pNext;
    };

    unsigned long           m_cItems;
    LinkedXMLDOMNodeItem *  m_pCurrent;
    LinkedXMLDOMNodeItem *  m_pFirst;
    LinkedXMLDOMNodeItem *  m_pLast;
};


#endif //__TXMLDOMNODELIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\fastcachetest\test.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.
#include <unicode.h>
#include <windows.h>
#include <icapctrl.h>
#include <conio.h>
#include <stdio.h>
#include <assert.h>

#include "comacros.h"
#include "catmeta.h"
#include "sdtfst.h"

#define cARGS_REQUIRED		3
#define iARG_TEST			1
#define iARG_ITERATIONS		2
#define iARG_SILENT			3
#define szARG_SILENT		"/s"

#define fSETCOLUMNSONLY			0
#define fSETCOLUMNSANDSETROW	1

typedef CMemoryTable* PMEMTABLE;

void Pause (LPCWSTR i_wszMsg);
void SetWriteColumnsAndSetRowTID1 (PMEMTABLE  i_pMemTable, ULONG i_iRow, BOOL bTestDefault = FALSE);
void PrintColumnsOfCurrentRowTID1 (PMEMTABLE  i_pMemTable, ULONG i_iRow);
void SetWriteColumns (PMEMTABLE	i_pMemTable, ULONG i_iRow, ULONG i_ulCol0, LPCWSTR i_wszCol1, 
	LPCWSTR i_wszCol2, GUID i_guidCol3, GUID i_guidCol4, BYTE* i_pbCol5, BYTE* i_pbCol6,
	ULONG i_cbCol6,	DBTIMESTAMP	i_tCol7, BYTE* i_pbCol8, ULONG i_cbCol8, LPCWSTR i_wszCol9);

// Test table schemas:
#define cwchTID1_WSZ1		9
#define cwchTID1_WSZ2		20
#define cwchTID1_WSZ3		10
#define cbTID1_AB1			10
#define cbTID1_AB2			20
#define cbTID1_AB3			20

static SimpleColumnMeta g_acolmetaTID1 [] = 
{
	 {DBTYPE_UI4,			sizeof (ULONG),					fCOLUMNMETA_PRIMARYKEY|fCOLUMNMETA_FIXEDLENGTH|fCOLUMNMETA_NOTNULLABLE}
	,{DBTYPE_WSTR,			cwchTID1_WSZ1*sizeof(WCHAR),	fCOLUMNMETA_FIXEDLENGTH}
	,{DBTYPE_WSTR,			cwchTID1_WSZ2*sizeof(WCHAR),	fCOLUMNMETA_VARIABLESIZE}
	,{DBTYPE_GUID,			sizeof (GUID),					fCOLUMNMETA_PRIMARYKEY|fCOLUMNMETA_FIXEDLENGTH|fCOLUMNMETA_NOTNULLABLE}
	,{DBTYPE_GUID,			sizeof (GUID),					fCOLUMNMETA_FIXEDLENGTH}
	,{DBTYPE_BYTES,			cbTID1_AB1,						fCOLUMNMETA_FIXEDLENGTH}
	,{DBTYPE_BYTES,			cbTID1_AB2,						fCOLUMNMETA_VARIABLESIZE|fCOLUMNMETA_UNKNOWNSIZE}
	,{DBTYPE_DBTIMESTAMP,	sizeof (DBTIMESTAMP),			fCOLUMNMETA_FIXEDLENGTH}
	,{DBTYPE_BYTES,			~0,								fCOLUMNMETA_VARIABLESIZE|fCOLUMNMETA_UNKNOWNSIZE}
	,{DBTYPE_WSTR,			~0,								fCOLUMNMETA_VARIABLESIZE}
};
static const ULONG g_cCOLS_TID1 = (sizeof (g_acolmetaTID1) / sizeof (SimpleColumnMeta));

// Test globals:
static ULONG	g_iTest = 0, g_cIterations;
static BOOL		g_fSilent = FALSE;

// =======================================================================
int __cdecl main (int argc, char *argv[], char *envp[])
{
	ptr_item		(CMemoryTable, pMemTable);
	ULONG			iIteration;
	HRESULT			hr;

	hr = CoInitializeEx (NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY);
	goto_on_bad_hr (hr, Cleanup);

// Command parsing:
	if (cARGS_REQUIRED > argc)
	{
		Pause (L"Command-line syntax error");
		goto Cleanup;
	}
	g_iTest = atol (argv[iARG_TEST]);
	if (0 == g_iTest)
	{
		Pause (L"Command-line syntax error");
		goto Cleanup;
	}
	g_cIterations = atol (argv[iARG_ITERATIONS]);
	if (0 == g_cIterations)
	{
		Pause (L"Command-line syntax error");
		goto Cleanup;
	}
	if (iARG_SILENT < argc)
	{
		if (0 == _stricmp (szARG_SILENT, argv[iARG_SILENT]))
		{
			g_fSilent = TRUE;
		}
		else
		{
			Pause (L"Command-line syntax error");
			goto Cleanup;
		}
	}

// Tests:
	switch (g_iTest)
	{
		case 1: // Test 1: Creation and deletion:
		{
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				new_item (pMemTable, CMemoryTable);
				delete_item (pMemTable);
			}
		}
		break;

		case 2: // Test 2: Creation and deletion accumulated:
		{
			ptr_array (PMEMTABLE, apCSDTCursor);
			new_array (apCSDTCursor, PMEMTABLE, g_cIterations);
			memset (apCSDTCursor, 0, g_cIterations * sizeof (PMEMTABLE));
			Pause (L"About to accumulate");

			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				new_item (apCSDTCursor[iIteration], CMemoryTable);
			}
			Pause (L"Accumulated creation complete");

			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				delete_item (apCSDTCursor[iIteration]);
			}
			Pause (L"Accumulated deletion complete");
			delete_array (apCSDTCursor);
		}
		break;
		case 3: // Test 3: Initialization and deletion:
		{
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				new_item (pMemTable, CMemoryTable);
				pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
				delete_item (pMemTable);
			}
		}
		break;
		case 4: // Test 4: Initialization and deletion accumulated:
		{
			ptr_array (PMEMTABLE, apCSDTCursor);
			new_array (apCSDTCursor, PMEMTABLE, g_cIterations);
			memset (apCSDTCursor, 0, g_cIterations * sizeof (PMEMTABLE));
			Pause (L"About to accumulate");

			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				new_item (apCSDTCursor[iIteration], CMemoryTable);
				apCSDTCursor[iIteration]->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
			}
			Pause (L"Accumulated creation complete");

			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				delete_item (apCSDTCursor[iIteration]);
			}
			Pause (L"Accumulated deletion complete");
			delete_array (apCSDTCursor);
		}
		break;
		case 5: // Test 5: Initialization, pre-population, and deletion:
		{
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				new_item (pMemTable, CMemoryTable);
				pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
				hr = pMemTable->PrePopulateCache (0);
				assert (SUCCEEDED (hr));
				delete_item (pMemTable);
			}
		}
		break;
		case 6: // Test 6: Initialization, pre-population, and deletion accumulated:
		{
			ptr_array (PMEMTABLE, apCSDTCursor);
			new_array (apCSDTCursor, PMEMTABLE, g_cIterations);
			memset (apCSDTCursor, 0, g_cIterations * sizeof (PMEMTABLE));
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				new_item (apCSDTCursor[iIteration], CMemoryTable);
				apCSDTCursor[iIteration]->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
				hr = apCSDTCursor[iIteration]->PrePopulateCache (0);
				assert (SUCCEEDED (hr));
			}
			Pause (L"Accumulated creation complete");

			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				delete_item (apCSDTCursor[iIteration]);
			}
			Pause (L"Accumulated deletion complete");
			delete_array (apCSDTCursor);
		}
		break;
		case 7: // Test 7: Initialization, pre- and post-population, and deletion:
		{
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				new_item (pMemTable, CMemoryTable);
				pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
				hr = pMemTable->PrePopulateCache (0);
				assert (SUCCEEDED (hr));
				hr = pMemTable->PostPopulateCache ();
				assert (SUCCEEDED (hr));
				delete_item (pMemTable);
			}
		}
		break;
		case 10: // Test 10: SetRow to load an empty cache:
		{
			new_item (pMemTable, CMemoryTable);
			pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
			hr = pMemTable->PrePopulateCache (0);
			assert (SUCCEEDED (hr));

			Pause (L"About to load rows");
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				ULONG	iNewRow;
				hr = pMemTable->AddRowForInsert (&iNewRow);
				assert (SUCCEEDED (hr));
				SetWriteColumnsAndSetRowTID1 (pMemTable, iNewRow);
			}
			hr = pMemTable->PostPopulateCache ();
			assert (SUCCEEDED (hr));
			Pause (L"Requested count of rows loaded");
			delete_item (pMemTable);

		}
		break;
		case 12:	// Test 12: Load an empty cache then get all its rows and columns:
					// Notes: This tests all supported types and their variations and NULL values.
		{
			new_item (pMemTable, CMemoryTable);
			pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
			hr = pMemTable->PrePopulateCache (0);
			assert (SUCCEEDED (hr));

			Pause (L"About to load rows");
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				ULONG	iNewRow;
				hr = pMemTable->AddRowForInsert (&iNewRow);
				assert (SUCCEEDED (hr));
				SetWriteColumnsAndSetRowTID1 (pMemTable, iNewRow);
			}
			hr = pMemTable->PostPopulateCache ();
			assert (SUCCEEDED (hr));

			Pause (L"About to read rows");
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				PrintColumnsOfCurrentRowTID1 (pMemTable, iIteration);
			}
			delete_item (pMemTable);

		}
		break;
		case 13:	// Test 13: Load an empty cache then get all its rows and columns twice:
		{
			new_item (pMemTable, CMemoryTable);
			pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
			hr = pMemTable->PrePopulateCache (0);
			assert (SUCCEEDED (hr));
			Pause (L"About to load rows");
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				ULONG	iNewRow;
				hr = pMemTable->AddRowForInsert (&iNewRow);
				assert (SUCCEEDED (hr));
				SetWriteColumnsAndSetRowTID1 (pMemTable, iNewRow);
			}
			hr = pMemTable->PostPopulateCache ();
			assert (SUCCEEDED (hr));

			for (ULONG i = 0; i < 2; i++)
			{
				Pause (L"About to read rows");
				for (iIteration = 0; iIteration < g_cIterations; iIteration++)
				{
					PrintColumnsOfCurrentRowTID1 (pMemTable, iIteration);
				}
			}
			delete_item (pMemTable);

		}
		break;
		case 14: // Test 14: Load 10K rows then delete cache: A good memory leak test:
		{
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				Pause (L"About to create/load/delete another cache");
				new_item (pMemTable, CMemoryTable);
				pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
				hr = pMemTable->PrePopulateCache (0);
				assert (SUCCEEDED (hr));

				for (ULONG iRows = 0; iRows < 10000; iRows++)
				{
					ULONG	iNewRow;
					hr = pMemTable->AddRowForInsert (&iNewRow);
					assert (SUCCEEDED (hr));
					SetWriteColumnsAndSetRowTID1 (pMemTable, iNewRow);
				}
				hr = pMemTable->PostPopulateCache ();
				assert (SUCCEEDED (hr));
				delete_item (pMemTable);
			}
		}
		break;
		case 15: // Test 15: Populate a cache then do inserts into the write cache:
		{
			new_item (pMemTable, CMemoryTable);
			pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
			hr = pMemTable->PrePopulateCache (0);
			assert (SUCCEEDED (hr));
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				ULONG	iNewRow;
				hr = pMemTable->AddRowForInsert (&iNewRow);
				assert (SUCCEEDED (hr));
				SetWriteColumnsAndSetRowTID1 (pMemTable, iNewRow);
			}
			hr = pMemTable->PostPopulateCache ();
			assert (SUCCEEDED (hr));

			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				ULONG	iNewRow;
				hr = pMemTable->AddRowForInsert (&iNewRow);
				assert (SUCCEEDED (hr));
				SetWriteColumnsAndSetRowTID1 (pMemTable, iNewRow);
			}
			delete_item (pMemTable);
		}
		break;

		case 16: // Test 16: Delete row while populating.
		{
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				new_item (pMemTable, CMemoryTable);
				pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, NULL, NULL);
				hr = pMemTable->PrePopulateCache (0);
				assert (SUCCEEDED (hr));

				for (ULONG iRows = 0; iRows < 10; iRows++)
				{
					ULONG iNewRow;
					hr = pMemTable->AddRowForInsert (&iNewRow);
					assert (SUCCEEDED (hr));
					SetWriteColumnsAndSetRowTID1 (pMemTable, iNewRow);
					if ((iRows % 3) == 0)
					{
						hr = pMemTable->SetWriteRowAction (iNewRow, eST_ROW_DELETE);
						assert (SUCCEEDED (hr));
					}
				}
				hr = pMemTable->PostPopulateCache ();
				assert (SUCCEEDED (hr));
				delete_item (pMemTable);
			}
		}
		break;
		case 17:	// Test 17: Test default values.
					// Notes: This tests all supported types and their variations and NULL values.
		{
			ULONG	aulDefSizes[g_cCOLS_TID1];
			LPVOID	apvDefaults[g_cCOLS_TID1];
			LPVOID	rpv[g_cCOLS_TID1];
			ULONG	rcb[g_cCOLS_TID1];
			
			aulDefSizes[g_cCOLS_TID1-1] = (wcslen(L"Defauuuult")+1) * 2;
			apvDefaults[g_cCOLS_TID1-1] = L"Defauuuult";

			new_item (pMemTable, CMemoryTable);
			pMemTable->ShapeCache (0, g_cCOLS_TID1, g_acolmetaTID1, apvDefaults, aulDefSizes);
			hr = pMemTable->PrePopulateCache (0);
			assert (SUCCEEDED (hr));

			Pause (L"About to load rows");
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				ULONG	iNewRow;
				hr = pMemTable->AddRowForInsert (&iNewRow);
				assert (SUCCEEDED (hr));
				SetWriteColumnsAndSetRowTID1 (pMemTable, iNewRow, TRUE);
			}
			hr = pMemTable->PostPopulateCache ();
			assert (SUCCEEDED (hr));

			Pause (L"About to read rows");
			for (iIteration = 0; iIteration < g_cIterations; iIteration++)
			{
				PrintColumnsOfCurrentRowTID1 (pMemTable, iIteration);
			}
			delete_item (pMemTable);

		}
		break;

// Test: Need to verify SetWriteColumn'ing a pass-by-ref primary key or explicit non-nullable as NULL fails (eg: not setting on an new row).
// Test: Time inserts into write cache!
// Test: Try calling methods when cache not ready; when cursor invalid; etc.
// Test: Need to test cache on tables both with and without variable length data (ie: different code paths).
// Test: not nullable meta flag.

// Test x: Table flags...

		default:
			Pause (L"Requested test is out of range");
		break;
	}

Cleanup:
	CoUninitialize ();
	if (!g_fSilent)
	{
		wprintf (L"\nDone: press any key to exit.\n");
		_getche ();
	}
	else
	{
		wprintf (L"\nDone!\n");
	}
	return 0;
}

// =======================================================================
void Pause (LPCWSTR i_wszMsg)
{
	if (!g_fSilent)
	{
		wprintf (L"\nTEST %d: %s: any key to continue.\n", g_iTest, i_wszMsg);
		_getche ();
	}
	else
	{
		wprintf (L"\nTEST %d: %s: continuing...\n", g_iTest, i_wszMsg);
	}
	return;
}

// =======================================================================
void rand_string (LPWSTR o_wsz, ULONG i_cwch)
{
	ULONG	l, i, j;
	WCHAR	wch;

	memset (o_wsz, 0, i_cwch * sizeof (WCHAR));
	l = (i_cwch + rand ()) % i_cwch;
	for (i = 0; i < l; )
	{
		wch = ((96 + rand ()) % 96) + 32;
		for (j = 0; i < l && j < 10; i++, j++)
		{
			o_wsz[i] = wch;
		}
	}
	return;
}

// =======================================================================
void rand_bytes (BYTE* o_ab, ULONG i_cb, ULONG* o_pcb)
{
	ULONG	l, i;
	BYTE	b;

	memset (o_ab, 0, i_cb);
	l = ((i_cb + rand ()) % i_cb) + 1;
	for (i = 0; i < l; i+=10)
	{
		b = (256 + rand ()) % 256;
		memset ((o_ab+i), b, (i+10 <= l ? 10 : l-i));
	}
	if (NULL != o_pcb)
	{
		*o_pcb = l;
	}
	return;
}

// =======================================================================
void rand_timestamp (DBTIMESTAMP* o_ptimestamp)
{
	o_ptimestamp->year = ((200 + rand ()) % 200) + 1900;
	o_ptimestamp->month = ((12 + rand ()) % 12) + 1;
	o_ptimestamp->day = ((28 + rand ()) % 28) + 1;
}

// =======================================================================
// NOTE: Creating random data takes a significant amount of time.
void SetWriteColumnsAndSetRowTID1 (PMEMTABLE i_pMemTable, ULONG i_iRow, BOOL bTestDefault)
{
	ULONG			ul1;
	WCHAR			wsz1 [cwchTID1_WSZ1];
	WCHAR			wsz2 [cwchTID1_WSZ2];
	GUID			guid;
	BYTE			ab1 [cbTID1_AB1];
	BYTE			ab2 [cbTID1_AB2];
	DBTIMESTAMP		timestamp = {1997, 2, 2, 12, 0, 0, 0};
	BYTE			ab3 [cbTID1_AB3];
	WCHAR			wsz3 [cwchTID1_WSZ3];

	ULONG			iColumn;
	LPVOID			rpv[g_cCOLS_TID1];
	ULONG			rcb[g_cCOLS_TID1];
	HRESULT			hr;

	areturn_on_fail (i_pMemTable, ;);

// Set columns:
	for (iColumn = 0, hr = S_OK; iColumn < g_cCOLS_TID1; iColumn++)
	{
		switch (iColumn)
		{
			case 0:
				ul1 = rand ();
				ul1 = rand () % 5 ? ul1 : 0;
				rpv[iColumn] = &ul1;
			break;
			case 1:
				rand_string (wsz1, cwchTID1_WSZ1);
				rpv[iColumn] = (LPVOID) (rand () % 3 ? wsz1 : NULL);
			break;
			case 2:
				rand_string (wsz2, cwchTID1_WSZ2);
				rpv[iColumn] = (LPVOID) (rand () % 3 ? wsz2 : NULL);
			break;
			case 3:
				CoCreateGuid (&guid);
				rpv[iColumn] =  (LPVOID) &guid;
			break;
			case 4:
				CoCreateGuid (&guid);
				rpv[iColumn] = (LPVOID) (rand () % 3 ? &guid : NULL);
			break;
			case 5:
				if (rand () % 3)
				{
					rand_bytes (ab1, cbTID1_AB1, NULL);
					rpv[iColumn] = (LPVOID) ab1;
				}
				else
				{
					rpv[iColumn] = NULL;
				}
			break;
			case 6:
				if (rand () % 3)
				{
					rand_bytes (ab2, cbTID1_AB2, &rcb[iColumn]);
					rpv[iColumn] = (LPVOID) ab2;
				}
				else
				{
					rpv[iColumn] = NULL;
				}
			break;
			case 7:
				rand_timestamp (&timestamp);
				rpv[iColumn] = (LPVOID) (rand () % 3 ? &timestamp : NULL);
			break;
			case 8:
				if (rand () % 3)
				{
					rand_bytes (ab3, cbTID1_AB3, &rcb[iColumn]);
					rpv[iColumn] = (LPVOID) ab3;
				}
				else
				{
					rpv[iColumn] = NULL;
				}
			break;

			case 9:
				rand_string (wsz3, cwchTID1_WSZ3);
				rpv[iColumn] = (LPVOID) ((rand () % 3) && !bTestDefault ? wsz3 : NULL);
			break;
			default:
				rpv[iColumn] = NULL;
			break;
		}
	}
	hr = i_pMemTable->SetWriteColumnValues (i_iRow, g_cCOLS_TID1, NULL, rcb, rpv);
	assert (S_OK == hr);

	return;
}

void SetWriteColumns (
	PMEMTABLE	i_pMemTable, 
	ULONG		i_iRow, 
	ULONG		i_ulCol0, 
	LPCWSTR		i_wszCol1, 
	LPCWSTR		i_wszCol2,
	GUID		i_guidCol3,
	GUID		i_guidCol4,
	BYTE*		i_pbCol5,
	BYTE*		i_pbCol6,
	ULONG		i_cbCol6,
	DBTIMESTAMP	i_tCol7,
	BYTE*		i_pbCol8,
	ULONG		i_cbCol8,
	LPCWSTR		i_wszCol9)
{
//	LPVOID		rpv[g_cCOLS_TID1] = {i_ulCol0 ? &i_ulCol0 : 0, i_wszCol1, i_wszCol2, i_guidCol3 ? &i_guidCol3: 0, i_guidCol4 ? &i_guidCol4 : 0,
//		i_pbCol5, i_pbCol6, &i_cbCol6, i_tCol7 ? &i_tCol7 : 0, i_pbCol8, &i_cbCol8, i_wszCol9};

	ULONG			rcb[g_cCOLS_TID1] = { 0, 0, 0, 0, 0, 0, i_cbCol8, 0, i_cbCol8, 0};
	HRESULT			hr;

	areturn_on_fail (i_pMemTable, ;);

// Set columns:
//	hr = i_pMemTable->SetWriteColumnValues (i_iRow, g_cCOLS_TID1, NULL, rcb, rpv);
	assert (S_OK == hr);

	return;
}

// =======================================================================
void PrintColumnsOfCurrentRowTID1 (PMEMTABLE i_pMemTable, ULONG i_iRow)
{
	SimpleColumnMeta rdwtype[g_cCOLS_TID1];
	LPVOID			rpv[g_cCOLS_TID1];
	ULONG			rcb[g_cCOLS_TID1];
	ptr_comem		(WCHAR, wsz);
	ULONG			ib;
	ULONG			iColumn;
	GUID*			pguid;
	DBTIMESTAMP*	ptimestamp;
	WCHAR			wch;
	HRESULT			hr;

	areturn_on_fail (i_pMemTable, ;);

	if (!g_fSilent)
	{
		wprintf (L"ROW %d ==================>\n", i_iRow);
	}

	hr = i_pMemTable->GetColumnValues (i_iRow, g_cCOLS_TID1, NULL, rcb, rpv);
	assert (S_OK == hr);
	hr = i_pMemTable->GetColumnMetas (g_cCOLS_TID1, NULL, rdwtype);
	assert (S_OK == hr);
	for (iColumn = 0, hr = S_OK; iColumn < g_cCOLS_TID1; iColumn++)
	{
		if (!g_fSilent)
		{
			switch (rdwtype[iColumn].dbType)
			{
				case DBTYPE_UI4: wch = L'U'; break;
				case DBTYPE_GUID: wch = L'G'; break;
				case DBTYPE_DBTIMESTAMP: wch = L'T'; break;
				case DBTYPE_WSTR: wch = L'W'; break;
				case DBTYPE_BYTES: wch = L'B'; break;
			}

			wprintf (L"%d (%c:%d): ",iColumn, wch, rcb[iColumn]);
			switch (iColumn)
			{
				case 0:
					wprintf (L"%d", (ULONG) rpv[iColumn]);
				break;
				case 1:
				case 2:
				case 9:
					wprintf (L"%s", (NULL == rpv[iColumn] ? L"<NULL>" : (LPWSTR) rpv[iColumn]));
				break;
				case 3:
				case 4:
					if (NULL == rpv[iColumn])
					{
						wprintf (L"<NULL>");
					}
					else
					{
						pguid = (GUID*) rpv[iColumn];
						StringFromCLSID (*pguid, &wsz);
						wprintf (L"%s", (LPWSTR) wsz);
						release_comem (wsz);
					}
				break;
				case 5:
				case 6:
				case 8:
					if (NULL == rpv[iColumn])
					{
						wprintf (L"<NULL>");
					}
					else
					{
						for (ib = 0; ib < rcb[iColumn]; ib++)
						{
							wprintf (L"%x", ((BYTE*) rpv[iColumn])[ib]);
						}
					}
				break;
				case 7:
					if (NULL == rpv[iColumn])
					{
						wprintf (L"<NULL>");
					}
					else
					{
						ptimestamp = (DBTIMESTAMP*) rpv[iColumn];
						wprintf (L"%d/%d/%d", ptimestamp->month, ptimestamp->day, ptimestamp->year);
					}
				break;
				default:
					assert (0);
				break;
			}
			wprintf (L"\n");
		}
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\stores\xmltable\xmlparser.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Thu Mar 04 16:31:06 1999
 */
/* Compiler settings for xmlparser.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __xmlparser_h__
#define __xmlparser_h__

/* Forward Declarations */ 

#ifndef __IXMLNodeSource_FWD_DEFINED__
#define __IXMLNodeSource_FWD_DEFINED__
typedef interface IXMLNodeSource IXMLNodeSource;
#endif 	/* __IXMLNodeSource_FWD_DEFINED__ */


#ifndef __IXMLParser_FWD_DEFINED__
#define __IXMLParser_FWD_DEFINED__
typedef interface IXMLParser IXMLParser;
#endif 	/* __IXMLParser_FWD_DEFINED__ */


#ifndef __IXMLNodeFactory_FWD_DEFINED__
#define __IXMLNodeFactory_FWD_DEFINED__
typedef interface IXMLNodeFactory IXMLNodeFactory;
#endif 	/* __IXMLNodeFactory_FWD_DEFINED__ */


#ifndef __XMLParser_FWD_DEFINED__
#define __XMLParser_FWD_DEFINED__

#ifdef __cplusplus
typedef class XMLParser XMLParser;
#else
typedef struct XMLParser XMLParser;
#endif /* __cplusplus */

#endif 	/* __XMLParser_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_xmlparser_0000 */
/* [local] */ 

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//--------------------------------------------------------------------------




typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0001
    {	XML_ELEMENT	= 1,
	XML_ATTRIBUTE	= XML_ELEMENT + 1,
	XML_PI	= XML_ATTRIBUTE + 1,
	XML_XMLDECL	= XML_PI + 1,
	XML_DOCTYPE	= XML_XMLDECL + 1,
	XML_DTDATTRIBUTE	= XML_DOCTYPE + 1,
	XML_ENTITYDECL	= XML_DTDATTRIBUTE + 1,
	XML_ELEMENTDECL	= XML_ENTITYDECL + 1,
	XML_ATTLISTDECL	= XML_ELEMENTDECL + 1,
	XML_NOTATION	= XML_ATTLISTDECL + 1,
	XML_GROUP	= XML_NOTATION + 1,
	XML_INCLUDESECT	= XML_GROUP + 1,
	XML_PCDATA	= XML_INCLUDESECT + 1,
	XML_CDATA	= XML_PCDATA + 1,
	XML_IGNORESECT	= XML_CDATA + 1,
	XML_COMMENT	= XML_IGNORESECT + 1,
	XML_ENTITYREF	= XML_COMMENT + 1,
	XML_WHITESPACE	= XML_ENTITYREF + 1,
	XML_NAME	= XML_WHITESPACE + 1,
	XML_NMTOKEN	= XML_NAME + 1,
	XML_STRING	= XML_NMTOKEN + 1,
	XML_PEREF	= XML_STRING + 1,
	XML_MODEL	= XML_PEREF + 1,
	XML_ATTDEF	= XML_MODEL + 1,
	XML_ATTTYPE	= XML_ATTDEF + 1,
	XML_ATTPRESENCE	= XML_ATTTYPE + 1,
	XML_DTDSUBSET	= XML_ATTPRESENCE + 1,
	XML_LASTNODETYPE	= XML_DTDSUBSET + 1
    }	XML_NODE_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0002
    {	XML_VERSION	= XML_LASTNODETYPE,
	XML_ENCODING	= XML_VERSION + 1,
	XML_STANDALONE	= XML_ENCODING + 1,
	XML_NS	= XML_STANDALONE + 1,
	XML_XMLSPACE	= XML_NS + 1,
	XML_XMLLANG	= XML_XMLSPACE + 1,
	XML_SYSTEM	= XML_XMLLANG + 1,
	XML_PUBLIC	= XML_SYSTEM + 1,
	XML_NDATA	= XML_PUBLIC + 1,
	XML_AT_CDATA	= XML_NDATA + 1,
	XML_AT_ID	= XML_AT_CDATA + 1,
	XML_AT_IDREF	= XML_AT_ID + 1,
	XML_AT_IDREFS	= XML_AT_IDREF + 1,
	XML_AT_ENTITY	= XML_AT_IDREFS + 1,
	XML_AT_ENTITIES	= XML_AT_ENTITY + 1,
	XML_AT_NMTOKEN	= XML_AT_ENTITIES + 1,
	XML_AT_NMTOKENS	= XML_AT_NMTOKEN + 1,
	XML_AT_NOTATION	= XML_AT_NMTOKENS + 1,
	XML_AT_REQUIRED	= XML_AT_NOTATION + 1,
	XML_AT_IMPLIED	= XML_AT_REQUIRED + 1,
	XML_AT_FIXED	= XML_AT_IMPLIED + 1,
	XML_PENTITYDECL	= XML_AT_FIXED + 1,
	XML_EMPTY	= XML_PENTITYDECL + 1,
	XML_ANY	= XML_EMPTY + 1,
	XML_MIXED	= XML_ANY + 1,
	XML_SEQUENCE	= XML_MIXED + 1,
	XML_CHOICE	= XML_SEQUENCE + 1,
	XML_STAR	= XML_CHOICE + 1,
	XML_PLUS	= XML_STAR + 1,
	XML_QUESTIONMARK	= XML_PLUS + 1,
	XML_LASTSUBNODETYPE	= XML_QUESTIONMARK + 1
    }	XML_NODE_SUBTYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0003
    {	XML_E_PARSEERRORBASE	= 0xc00ce500L,
	XML_E_ENDOFINPUT	= XML_E_PARSEERRORBASE,
	XML_E_MISSINGEQUALS	= XML_E_ENDOFINPUT + 1,
	XML_E_MISSINGQUOTE	= XML_E_MISSINGEQUALS + 1,
	XML_E_COMMENTSYNTAX	= XML_E_MISSINGQUOTE + 1,
	XML_E_BADSTARTNAMECHAR	= XML_E_COMMENTSYNTAX + 1,
	XML_E_BADNAMECHAR	= XML_E_BADSTARTNAMECHAR + 1,
	XML_E_BADCHARINSTRING	= XML_E_BADNAMECHAR + 1,
	XML_E_XMLDECLSYNTAX	= XML_E_BADCHARINSTRING + 1,
	XML_E_BADCHARDATA	= XML_E_XMLDECLSYNTAX + 1,
	XML_E_MISSINGWHITESPACE	= XML_E_BADCHARDATA + 1,
	XML_E_EXPECTINGTAGEND	= XML_E_MISSINGWHITESPACE + 1,
	XML_E_BADCHARINDTD	= XML_E_EXPECTINGTAGEND + 1,
	XML_E_BADCHARINDECL	= XML_E_BADCHARINDTD + 1,
	XML_E_MISSINGSEMICOLON	= XML_E_BADCHARINDECL + 1,
	XML_E_BADCHARINENTREF	= XML_E_MISSINGSEMICOLON + 1,
	XML_E_UNBALANCEDPAREN	= XML_E_BADCHARINENTREF + 1,
	XML_E_EXPECTINGOPENBRACKET	= XML_E_UNBALANCEDPAREN + 1,
	XML_E_BADENDCONDSECT	= XML_E_EXPECTINGOPENBRACKET + 1,
	XML_E_INTERNALERROR	= XML_E_BADENDCONDSECT + 1,
	XML_E_UNEXPECTED_WHITESPACE	= XML_E_INTERNALERROR + 1,
	XML_E_INCOMPLETE_ENCODING	= XML_E_UNEXPECTED_WHITESPACE + 1,
	XML_E_BADCHARINMIXEDMODEL	= XML_E_INCOMPLETE_ENCODING + 1,
	XML_E_MISSING_STAR	= XML_E_BADCHARINMIXEDMODEL + 1,
	XML_E_BADCHARINMODEL	= XML_E_MISSING_STAR + 1,
	XML_E_MISSING_PAREN	= XML_E_BADCHARINMODEL + 1,
	XML_E_BADCHARINENUMERATION	= XML_E_MISSING_PAREN + 1,
	XML_E_PIDECLSYNTAX	= XML_E_BADCHARINENUMERATION + 1,
	XML_E_EXPECTINGCLOSEQUOTE	= XML_E_PIDECLSYNTAX + 1,
	XML_E_MULTIPLE_COLONS	= XML_E_EXPECTINGCLOSEQUOTE + 1,
	XML_E_INVALID_DECIMAL	= XML_E_MULTIPLE_COLONS + 1,
	XML_E_INVALID_HEXIDECIMAL	= XML_E_INVALID_DECIMAL + 1,
	XML_E_INVALID_UNICODE	= XML_E_INVALID_HEXIDECIMAL + 1,
	XML_E_WHITESPACEORQUESTIONMARK	= XML_E_INVALID_UNICODE + 1,
	XML_E_TOKEN_ERROR	= XML_E_PARSEERRORBASE + 0x50,
	XML_E_SUSPENDED	= XML_E_TOKEN_ERROR,
	XML_E_STOPPED	= XML_E_SUSPENDED + 1,
	XML_E_UNEXPECTEDENDTAG	= XML_E_STOPPED + 1,
	XML_E_UNCLOSEDTAG	= XML_E_UNEXPECTEDENDTAG + 1,
	XML_E_DUPLICATEATTRIBUTE	= XML_E_UNCLOSEDTAG + 1,
	XML_E_MULTIPLEROOTS	= XML_E_DUPLICATEATTRIBUTE + 1,
	XML_E_INVALIDATROOTLEVEL	= XML_E_MULTIPLEROOTS + 1,
	XML_E_BADXMLDECL	= XML_E_INVALIDATROOTLEVEL + 1,
	XML_E_MISSINGROOT	= XML_E_BADXMLDECL + 1,
	XML_E_UNEXPECTEDEOF	= XML_E_MISSINGROOT + 1,
	XML_E_BADPEREFINSUBSET	= XML_E_UNEXPECTEDEOF + 1,
	XML_E_PE_NESTING	= XML_E_BADPEREFINSUBSET + 1,
	XML_E_INVALID_CDATACLOSINGTAG	= XML_E_PE_NESTING + 1,
	XML_E_UNCLOSEDPI	= XML_E_INVALID_CDATACLOSINGTAG + 1,
	XML_E_UNCLOSEDSTARTTAG	= XML_E_UNCLOSEDPI + 1,
	XML_E_UNCLOSEDENDTAG	= XML_E_UNCLOSEDSTARTTAG + 1,
	XML_E_UNCLOSEDSTRING	= XML_E_UNCLOSEDENDTAG + 1,
	XML_E_UNCLOSEDCOMMENT	= XML_E_UNCLOSEDSTRING + 1,
	XML_E_UNCLOSEDDECL	= XML_E_UNCLOSEDCOMMENT + 1,
	XML_E_UNCLOSEDMARKUPDECL	= XML_E_UNCLOSEDDECL + 1,
	XML_E_UNCLOSEDCDATA	= XML_E_UNCLOSEDMARKUPDECL + 1,
	XML_E_BADDECLNAME	= XML_E_UNCLOSEDCDATA + 1,
	XML_E_BADEXTERNALID	= XML_E_BADDECLNAME + 1,
	XML_E_BADELEMENTINDTD	= XML_E_BADEXTERNALID + 1,
	XML_E_RESERVEDNAMESPACE	= XML_E_BADELEMENTINDTD + 1,
	XML_E_EXPECTING_VERSION	= XML_E_RESERVEDNAMESPACE + 1,
	XML_E_EXPECTING_ENCODING	= XML_E_EXPECTING_VERSION + 1,
	XML_E_EXPECTING_NAME	= XML_E_EXPECTING_ENCODING + 1,
	XML_E_UNEXPECTED_ATTRIBUTE	= XML_E_EXPECTING_NAME + 1,
	XML_E_ENDTAGMISMATCH	= XML_E_UNEXPECTED_ATTRIBUTE + 1,
	XML_E_INVALIDENCODING	= XML_E_ENDTAGMISMATCH + 1,
	XML_E_INVALIDSWITCH	= XML_E_INVALIDENCODING + 1,
	XML_E_EXPECTING_NDATA	= XML_E_INVALIDSWITCH + 1,
	XML_E_INVALID_MODEL	= XML_E_EXPECTING_NDATA + 1,
	XML_E_INVALID_TYPE	= XML_E_INVALID_MODEL + 1,
	XML_E_INVALIDXMLSPACE	= XML_E_INVALID_TYPE + 1,
	XML_E_MULTI_ATTR_VALUE	= XML_E_INVALIDXMLSPACE + 1,
	XML_E_INVALID_PRESENCE	= XML_E_MULTI_ATTR_VALUE + 1,
	XML_E_BADXMLCASE	= XML_E_INVALID_PRESENCE + 1,
	XML_E_CONDSECTINSUBSET	= XML_E_BADXMLCASE + 1,
	XML_E_CDATAINVALID	= XML_E_CONDSECTINSUBSET + 1,
	XML_E_INVALID_STANDALONE	= XML_E_CDATAINVALID + 1,
	XML_E_UNEXPECTED_STANDALONE	= XML_E_INVALID_STANDALONE + 1,
	XML_E_DOCTYPE_IN_DTD	= XML_E_UNEXPECTED_STANDALONE + 1,
	XML_E_MISSING_ENTITY	= XML_E_DOCTYPE_IN_DTD + 1,
	XML_E_ENTITYREF_INNAME	= XML_E_MISSING_ENTITY + 1,
	XML_E_DOCTYPE_OUTSIDE_PROLOG	= XML_E_ENTITYREF_INNAME + 1,
	XML_E_INVALID_VERSION	= XML_E_DOCTYPE_OUTSIDE_PROLOG + 1,
	XML_E_DTDELEMENT_OUTSIDE_DTD	= XML_E_INVALID_VERSION + 1,
	XML_E_DUPLICATEDOCTYPE	= XML_E_DTDELEMENT_OUTSIDE_DTD + 1,
	XML_E_RESOURCE	= XML_E_DUPLICATEDOCTYPE + 1,
	XML_E_LASTERROR	= XML_E_RESOURCE + 1
    }	XML_ERROR_CODE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0004
    {	XMLPARSER_IDLE	= 0,
	XMLPARSER_WAITING	= XMLPARSER_IDLE + 1,
	XMLPARSER_BUSY	= XMLPARSER_WAITING + 1,
	XMLPARSER_ERROR	= XMLPARSER_BUSY + 1,
	XMLPARSER_STOPPED	= XMLPARSER_ERROR + 1,
	XMLPARSER_SUSPENDED	= XMLPARSER_STOPPED + 1
    }	XML_PARSER_STATE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0005
    {	XMLFLAG_FLOATINGAMP	= 1,
	XMLFLAG_SHORTENDTAGS	= 2,
	XMLFLAG_CASEINSENSITIVE	= 4,
	XMLFLAG_NONAMESPACES	= 8,
	XMLFLAG_NOWHITESPACE	= 16,
	XMLFLAG_IE4QUIRKS	= 32,
	XMLFLAG_NODTDNODES	= 64,
	XMLFLAG_IE4COMPATIBILITY	= 255
    }	XML_PARSER_FLAGS;

typedef /* [public][public] */ 
enum __MIDL___MIDL_itf_xmlparser_0000_0006
    {	XMLNF_STARTDOCUMENT	= 0,
	XMLNF_STARTDTD	= XMLNF_STARTDOCUMENT + 1,
	XMLNF_ENDDTD	= XMLNF_STARTDTD + 1,
	XMLNF_STARTDTDSUBSET	= XMLNF_ENDDTD + 1,
	XMLNF_ENDDTDSUBSET	= XMLNF_STARTDTDSUBSET + 1,
	XMLNF_ENDPROLOG	= XMLNF_ENDDTDSUBSET + 1,
	XMLNF_STARTENTITY	= XMLNF_ENDPROLOG + 1,
	XMLNF_ENDENTITY	= XMLNF_STARTENTITY + 1,
	XMLNF_ENDDOCUMENT	= XMLNF_ENDENTITY + 1,
	XMLNF_DATAAVAILABLE	= XMLNF_ENDDOCUMENT + 1,
	XMLNF_LASTEVENT	= XMLNF_DATAAVAILABLE
    }	XML_NODEFACTORY_EVENT;

typedef struct _XML_NODE_INFO
    {
    DWORD dwSize;
    DWORD dwType;
    DWORD dwSubType;
    BOOL fTerminal;
    const WCHAR __RPC_FAR *pwcText;
    ULONG ulLen;
    ULONG ulNsPrefixLen;
    PVOID pNode;
    PVOID pReserved;
    }	XML_NODE_INFO;



extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_xmlparser_0000_v0_0_s_ifspec;


#ifndef __XMLPSR_LIBRARY_DEFINED__
#define __XMLPSR_LIBRARY_DEFINED__

/* library XMLPSR */
/* [version][lcid][helpstring][uuid] */ 


EXTERN_C const IID LIBID_XMLPSR;

#ifndef __IXMLNodeSource_INTERFACE_DEFINED__
#define __IXMLNodeSource_INTERFACE_DEFINED__

/* interface IXMLNodeSource */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeSource;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361d-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeSource : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetFactory( 
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFactory( 
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ BSTR bstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLineNumber( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetLinePosition( void) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetAbsolutePosition( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLineBuffer( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastError( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorInfo( 
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo) = 0;
        
        virtual ULONG STDMETHODCALLTYPE GetFlags( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeSourceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLNodeSource __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLNodeSource __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLNodeSourceVtbl;

    interface IXMLNodeSource
    {
        CONST_VTBL struct IXMLNodeSourceVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeSource_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeSource_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeSource_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeSource_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLNodeSource_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLNodeSource_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLNodeSource_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLNodeSource_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLNodeSource_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLNodeSource_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLNodeSource_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLNodeSource_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLNodeSource_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLNodeSource_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeSource_SetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);


void __RPC_STUB IXMLNodeSource_SetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetFactory_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);


void __RPC_STUB IXMLNodeSource_GetFactory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_Abort_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [in] */ BSTR bstrErrorInfo);


void __RPC_STUB IXMLNodeSource_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLineNumber_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetLinePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLinePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetAbsolutePosition_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetAbsolutePosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLineBuffer_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
    /* [out] */ ULONG __RPC_FAR *pulLen,
    /* [out] */ ULONG __RPC_FAR *pulStartPos);


void __RPC_STUB IXMLNodeSource_GetLineBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetLastError_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetLastError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetErrorInfo_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);


void __RPC_STUB IXMLNodeSource_GetErrorInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


ULONG STDMETHODCALLTYPE IXMLNodeSource_GetFlags_Proxy( 
    IXMLNodeSource __RPC_FAR * This);


void __RPC_STUB IXMLNodeSource_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeSource_GetURL_Proxy( 
    IXMLNodeSource __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLNodeSource_GetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeSource_INTERFACE_DEFINED__ */


#ifndef __IXMLParser_INTERFACE_DEFINED__
#define __IXMLParser_INTERFACE_DEFINED__

/* interface IXMLParser */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLParser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361e-51a0-11d2-9caf-0060b0ec3d39")
    IXMLParser : public IXMLNodeSource
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Load( 
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetInput( 
            /* [in] */ IUnknown __RPC_FAR *pStm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PushData( 
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadDTD( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExpandEntity( 
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRoot( 
            /* [in] */ PVOID pRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRoot( 
            /* [in] */ PVOID __RPC_FAR *ppRoot) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [in] */ long lChars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParserState( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Suspend( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetFlags( 
            /* [in] */ ULONG iFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetSecureBaseURL( 
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSecureBaseURL( 
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLParserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IXMLNodeFactory __RPC_FAR *pNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFactory )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ IXMLNodeFactory __RPC_FAR *__RPC_FAR *ppNodeFactory);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abort )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BSTR bstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLineNumber )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetLinePosition )( 
            IXMLParser __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetAbsolutePosition )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineBuffer )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf,
            /* [out] */ ULONG __RPC_FAR *pulLen,
            /* [out] */ ULONG __RPC_FAR *pulStartPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastError )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetErrorInfo )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *pbstrErrorInfo);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fAsync);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Load )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ BOOL fFullyAvailable,
            /* [in] */ IMoniker __RPC_FAR *pimkName,
            /* [in] */ LPBC pibc,
            /* [in] */ DWORD grfMode);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetInput )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pStm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PushData )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const char __RPC_FAR *pData,
            /* [in] */ ULONG ulChars,
            /* [in] */ BOOL fLastBuffer);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadDTD )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LoadEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
            /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ParseEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen,
            /* [in] */ BOOL fpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExpandEntity )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pwcText,
            /* [in] */ ULONG ulLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID pRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRoot )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ PVOID __RPC_FAR *ppRoot);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Run )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ long lChars);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParserState )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Suspend )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IXMLParser __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ ULONG iFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSecureBaseURL )( 
            IXMLParser __RPC_FAR * This,
            /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);
        
        END_INTERFACE
    } IXMLParserVtbl;

    interface IXMLParser
    {
        CONST_VTBL struct IXMLParserVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLParser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLParser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLParser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLParser_SetFactory(This,pNodeFactory)	\
    (This)->lpVtbl -> SetFactory(This,pNodeFactory)

#define IXMLParser_GetFactory(This,ppNodeFactory)	\
    (This)->lpVtbl -> GetFactory(This,ppNodeFactory)

#define IXMLParser_Abort(This,bstrErrorInfo)	\
    (This)->lpVtbl -> Abort(This,bstrErrorInfo)

#define IXMLParser_GetLineNumber(This)	\
    (This)->lpVtbl -> GetLineNumber(This)

#define IXMLParser_GetLinePosition(This)	\
    (This)->lpVtbl -> GetLinePosition(This)

#define IXMLParser_GetAbsolutePosition(This)	\
    (This)->lpVtbl -> GetAbsolutePosition(This)

#define IXMLParser_GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)	\
    (This)->lpVtbl -> GetLineBuffer(This,ppwcBuf,pulLen,pulStartPos)

#define IXMLParser_GetLastError(This)	\
    (This)->lpVtbl -> GetLastError(This)

#define IXMLParser_GetErrorInfo(This,pbstrErrorInfo)	\
    (This)->lpVtbl -> GetErrorInfo(This,pbstrErrorInfo)

#define IXMLParser_GetFlags(This)	\
    (This)->lpVtbl -> GetFlags(This)

#define IXMLParser_GetURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetURL(This,ppwcBuf)


#define IXMLParser_SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)	\
    (This)->lpVtbl -> SetURL(This,pszBaseUrl,pszRelativeUrl,fAsync)

#define IXMLParser_Load(This,fFullyAvailable,pimkName,pibc,grfMode)	\
    (This)->lpVtbl -> Load(This,fFullyAvailable,pimkName,pibc,grfMode)

#define IXMLParser_SetInput(This,pStm)	\
    (This)->lpVtbl -> SetInput(This,pStm)

#define IXMLParser_PushData(This,pData,ulChars,fLastBuffer)	\
    (This)->lpVtbl -> PushData(This,pData,ulChars,fLastBuffer)

#define IXMLParser_LoadDTD(This,pszBaseUrl,pszRelativeUrl)	\
    (This)->lpVtbl -> LoadDTD(This,pszBaseUrl,pszRelativeUrl)

#define IXMLParser_LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)	\
    (This)->lpVtbl -> LoadEntity(This,pszBaseUrl,pszRelativeUrl,fpe)

#define IXMLParser_ParseEntity(This,pwcText,ulLen,fpe)	\
    (This)->lpVtbl -> ParseEntity(This,pwcText,ulLen,fpe)

#define IXMLParser_ExpandEntity(This,pwcText,ulLen)	\
    (This)->lpVtbl -> ExpandEntity(This,pwcText,ulLen)

#define IXMLParser_SetRoot(This,pRoot)	\
    (This)->lpVtbl -> SetRoot(This,pRoot)

#define IXMLParser_GetRoot(This,ppRoot)	\
    (This)->lpVtbl -> GetRoot(This,ppRoot)

#define IXMLParser_Run(This,lChars)	\
    (This)->lpVtbl -> Run(This,lChars)

#define IXMLParser_GetParserState(This)	\
    (This)->lpVtbl -> GetParserState(This)

#define IXMLParser_Suspend(This)	\
    (This)->lpVtbl -> Suspend(This)

#define IXMLParser_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IXMLParser_SetFlags(This,iFlags)	\
    (This)->lpVtbl -> SetFlags(This,iFlags)

#define IXMLParser_SetSecureBaseURL(This,pszBaseUrl)	\
    (This)->lpVtbl -> SetSecureBaseURL(This,pszBaseUrl)

#define IXMLParser_GetSecureBaseURL(This,ppwcBuf)	\
    (This)->lpVtbl -> GetSecureBaseURL(This,ppwcBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLParser_SetURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fAsync);


void __RPC_STUB IXMLParser_SetURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Load_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ BOOL fFullyAvailable,
    /* [in] */ IMoniker __RPC_FAR *pimkName,
    /* [in] */ LPBC pibc,
    /* [in] */ DWORD grfMode);


void __RPC_STUB IXMLParser_Load_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetInput_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pStm);


void __RPC_STUB IXMLParser_SetInput_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_PushData_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const char __RPC_FAR *pData,
    /* [in] */ ULONG ulChars,
    /* [in] */ BOOL fLastBuffer);


void __RPC_STUB IXMLParser_PushData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadDTD_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl);


void __RPC_STUB IXMLParser_LoadDTD_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_LoadEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl,
    /* [in] */ const WCHAR __RPC_FAR *pszRelativeUrl,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_LoadEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ParseEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen,
    /* [in] */ BOOL fpe);


void __RPC_STUB IXMLParser_ParseEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_ExpandEntity_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pwcText,
    /* [in] */ ULONG ulLen);


void __RPC_STUB IXMLParser_ExpandEntity_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID pRoot);


void __RPC_STUB IXMLParser_SetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetRoot_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ PVOID __RPC_FAR *ppRoot);


void __RPC_STUB IXMLParser_GetRoot_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Run_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ long lChars);


void __RPC_STUB IXMLParser_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetParserState_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_GetParserState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Suspend_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Suspend_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_Reset_Proxy( 
    IXMLParser __RPC_FAR * This);


void __RPC_STUB IXMLParser_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetFlags_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ ULONG iFlags);


void __RPC_STUB IXMLParser_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_SetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [in] */ const WCHAR __RPC_FAR *pszBaseUrl);


void __RPC_STUB IXMLParser_SetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLParser_GetSecureBaseURL_Proxy( 
    IXMLParser __RPC_FAR * This,
    /* [out] */ const WCHAR __RPC_FAR *__RPC_FAR *ppwcBuf);


void __RPC_STUB IXMLParser_GetSecureBaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLParser_INTERFACE_DEFINED__ */


#ifndef __IXMLNodeFactory_INTERFACE_DEFINED__
#define __IXMLNodeFactory_INTERFACE_DEFINED__

/* interface IXMLNodeFactory */
/* [unique][helpstring][uuid][local][object] */ 


EXTERN_C const IID IID_IXMLNodeFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("d242361f-51a0-11d2-9caf-0060b0ec3d39")
    IXMLNodeFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE NotifyEvent( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE BeginChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EndChildren( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Error( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateNode( 
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IXMLNodeFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IXMLNodeFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyEvent )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODEFACTORY_EVENT iEvt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndChildren )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ BOOL fEmpty,
            /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Error )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ HRESULT hrErrorCode,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateNode )( 
            IXMLNodeFactory __RPC_FAR * This,
            /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
            /* [in] */ PVOID pNodeParent,
            /* [in] */ USHORT cNumRecs,
            /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);
        
        END_INTERFACE
    } IXMLNodeFactoryVtbl;

    interface IXMLNodeFactory
    {
        CONST_VTBL struct IXMLNodeFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IXMLNodeFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IXMLNodeFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IXMLNodeFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IXMLNodeFactory_NotifyEvent(This,pSource,iEvt)	\
    (This)->lpVtbl -> NotifyEvent(This,pSource,iEvt)

#define IXMLNodeFactory_BeginChildren(This,pSource,pNodeInfo)	\
    (This)->lpVtbl -> BeginChildren(This,pSource,pNodeInfo)

#define IXMLNodeFactory_EndChildren(This,pSource,fEmpty,pNodeInfo)	\
    (This)->lpVtbl -> EndChildren(This,pSource,fEmpty,pNodeInfo)

#define IXMLNodeFactory_Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> Error(This,pSource,hrErrorCode,cNumRecs,apNodeInfo)

#define IXMLNodeFactory_CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)	\
    (This)->lpVtbl -> CreateNode(This,pSource,pNodeParent,cNumRecs,apNodeInfo)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IXMLNodeFactory_NotifyEvent_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODEFACTORY_EVENT iEvt);


void __RPC_STUB IXMLNodeFactory_NotifyEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_BeginChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_BeginChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_EndChildren_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ BOOL fEmpty,
    /* [in] */ XML_NODE_INFO __RPC_FAR *pNodeInfo);


void __RPC_STUB IXMLNodeFactory_EndChildren_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_Error_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ HRESULT hrErrorCode,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_Error_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IXMLNodeFactory_CreateNode_Proxy( 
    IXMLNodeFactory __RPC_FAR * This,
    /* [in] */ IXMLNodeSource __RPC_FAR *pSource,
    /* [in] */ PVOID pNodeParent,
    /* [in] */ USHORT cNumRecs,
    /* [in] */ XML_NODE_INFO __RPC_FAR *__RPC_FAR *apNodeInfo);


void __RPC_STUB IXMLNodeFactory_CreateNode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IXMLNodeFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_XMLParser;

#ifdef __cplusplus

class DECLSPEC_UUID("d2423620-51a0-11d2-9caf-0060b0ec3d39")
XMLParser;
#endif
#endif /* __XMLPSR_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\filechngtest\filechange.cpp ===
#include "objbase.h"
#include "catalog.h"
#define REGSYSDEFNS_DEFINE
#define REGSYSDEFNS_CLSID_STDISPENSER

#include "catmeta.h"
#include "stdio.h"
#include "catmacros.h"
#include "conio.h"

class CTestListener : public ISimpleTableFileChange
{
public:
	CTestListener() : m_cRef(0)
	{}

	~CTestListener() 
	{}

	////////////////////////////////////////////////////////////////////////////
	// IUnknown:

	STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
	{
		if (NULL == ppv) 
			return E_INVALIDARG;
		*ppv = NULL;

		if (riid == IID_ISimpleTableFileChange)
		{
			*ppv = (ISimpleTableFileChange*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableFileChange*) this;
		}

		if (NULL != *ppv)
		{
			((ISimpleTableFileChange*)this)->AddRef ();
			return S_OK;
		}
		else
		{
			return E_NOINTERFACE;
		}
		
	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return InterlockedIncrement((LONG*) &m_cRef);
		
	}

	STDMETHODIMP_(ULONG) Release()
	{
		long cref = InterlockedDecrement((LONG*) &m_cRef);
		if (cref == 0)
		{
			delete this;
		}
		return cref;
	}

	STDMETHODIMP OnFileCreate(LPCWSTR i_wszFileName)
	{
		wprintf(L"File Created: %s\n", i_wszFileName);
		return S_OK;
	}
	
	STDMETHODIMP OnFileModify(LPCWSTR i_wszFileName)
	{
		wprintf(L"File Modified: %s\n", i_wszFileName);
		return S_OK;
	}

	STDMETHODIMP OnFileDelete(LPCWSTR i_wszFileName)
	{
		wprintf(L"File Deleted: %s\n", i_wszFileName);
		return S_OK;
	}

private:
	LONG	m_cRef;
};

const ULONG	g_cConsumer = 1;
const ULONG	g_cIteration = 1;

int _cdecl main(int		argc,					// How many input arguments.
				CHAR	*argv[])				// Optional config args.
{
	HRESULT hr;
	ISimpleTableDispenser2* pISTDisp = NULL;	
	ISimpleTableFileAdvise* pISTFileAdvise = NULL;
	ISnapshotManager* pISSMgr = NULL;
	SNID		snid;
	CTestListener	*pListener = NULL;
	DWORD		dwCookie[g_cConsumer*2];
    WCHAR       pwszDirectory[256];
	ULONG		i;
	ULONG		j;

    if (argc < 2)
    {
        wprintf(L"Usage: filechngtest <Directory to listen to>");
        return 0;
    }
    else
    {
        MultiByteToWideChar(CP_ACP,0,argv[1],strlen(argv[1])+1,pwszDirectory,256);
        wprintf(L"Listening to directory %s \n", pwszDirectory);  
    }

	hr = CoInitialize(NULL);
	if (FAILED(hr)) { goto Cleanup; }

	// Get the dispenser.
	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);
	if (FAILED(hr)) { goto Cleanup; }

	hr = pISTDisp->QueryInterface(IID_ISnapshotManager, (LPVOID*) &pISSMgr);
	if (FAILED(hr)) { goto Cleanup; }
	pISSMgr->QueryLatestSnapshot(&snid);
	pISSMgr->ReleaseSnapshot(snid);
	pISSMgr->Release();

	hr = pISTDisp->QueryInterface(IID_ISimpleTableFileAdvise, (LPVOID*) &pISTFileAdvise);
	if (FAILED(hr)) { goto Cleanup; }

	pListener = new CTestListener;
	pListener->AddRef();

	for (j = 0; j < g_cIteration; j++)
	{
		// Sign-up for events.
		for (i = 0; i < g_cConsumer; i++)
		{
			hr = pISTFileAdvise->SimpleTableFileAdvise(pListener, pwszDirectory, L"Metabase.xml", fST_FILECHANGE_RECURSIVE, &dwCookie[i*2]);
			if (FAILED(hr)) { goto Cleanup; }
			pListener->AddRef();
		}
		// Are we done?
		_getch();

		// Done with eventing, unadvise.
		for (i = 0; i < g_cConsumer; i++)
		{
			hr = pISTFileAdvise->SimpleTableFileUnadvise(dwCookie[i*2]);
			if (FAILED(hr)) { goto Cleanup; }
		}
	}
Cleanup:
	if (pListener)
		pListener->Release();

	if (pISTDisp)
		pISTDisp->Release();

	if (pISTFileAdvise)
		pISTFileAdvise->Release();

	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\fusionperf\fusionperf.cpp ===
#include "catalog.h"
#include "catmeta.h"
#include "conio.h"

#ifdef _DEBUG
#include "stdio.h"
#endif

#define wszDATABASE_CFG			L"CFG"
#define wszDATABASE_URTGLOBAL	L"URTGLOBAL"

// Globals.
LPCWSTR		wszXMLFile = L"helloworld.cfg";
STQueryCell sXMLQuery[] = {{ (LPVOID)wszXMLFile,  eST_OP_EQUAL, iST_CELL_FILE, DBTYPE_WSTR, (wcslen(wszXMLFile)+1) * 2}};
ULONG		cXMLCells	= sizeof(sXMLQuery)/sizeof(STQueryCell);

ISimpleTableDispenser2* g_pISTDisp = NULL;	
ISimpleTableRead2*		g_pISTBinding = NULL;
ISimpleTableRead2*		g_pISTAssembiles = NULL;
ISimpleTableRead2*		g_pISTModes = NULL;
ISimpleTableRead2*		g_pISTAppDomain = NULL;

int _cdecl main(int		argc,					// How many input arguments.
				CHAR	*argv[])				// Optional config args.
{
	tAPPBINDINGMODETABLERow	sMode;
	tAppDomainRow	sAppDomain;
	tBINDINGREDIRTABLERow sBinding;
	tASSEMBLIESTABLERow sAssembly;
	ULONG		iRow = 0;
	HRESULT		hr = S_OK;

#ifdef _DEBUG
	CoInitialize(NULL);
#endif

	// Get the dispenser and all the necessary tables.
	hr = GetSimpleTableDispenser (WSZ_PRODUCT_URT, 0, &g_pISTDisp);
	if (FAILED(hr)) goto Cleanup;

#ifdef _DEBUG
	wprintf(L"Succeded in getting the dispenser\n");
#endif

	hr = g_pISTDisp->GetTable (wszDATABASE_CFG, wszTABLE_BINDINGREDIRTABLE, sXMLQuery, &cXMLCells, eST_QUERYFORMAT_CELLS, 
					0, (void**)&g_pISTBinding);
	if (FAILED(hr)) goto Cleanup;

#ifdef _DEBUG
	wprintf(L"GetTable succeeded on %s\n", wszTABLE_BINDINGREDIRTABLE);
#endif

	hr = g_pISTDisp->GetTable (wszDATABASE_CFG, wszTABLE_ASSEMBLIESTABLE, sXMLQuery, &cXMLCells, eST_QUERYFORMAT_CELLS, 
					0, (void**)&g_pISTAssembiles);
	if (FAILED(hr)) goto Cleanup;
	
#ifdef _DEBUG
	wprintf(L"GetTable succeeded on %s\n", wszTABLE_ASSEMBLIESTABLE);
#endif

	hr = g_pISTDisp->GetTable (wszDATABASE_CFG, wszTABLE_APPBINDINGMODETABLE, sXMLQuery, &cXMLCells, eST_QUERYFORMAT_CELLS, 
					0, (void**)&g_pISTModes);
	if (FAILED(hr)) goto Cleanup;
	hr = g_pISTModes->GetColumnValues(0, cAPPBINDINGMODETABLE_NumberOfColumns, NULL, NULL, (LPVOID*)&sMode);
	if (FAILED(hr)) goto Cleanup;

#ifdef _DEBUG
	wprintf(L"GetTable succeeded on %s\n", wszTABLE_APPBINDINGMODETABLE);
#endif

	hr = g_pISTDisp->GetTable (wszDATABASE_URTGLOBAL, wszTABLE_AppDomain, sXMLQuery, &cXMLCells, eST_QUERYFORMAT_CELLS, 
					0, (void**)&g_pISTAppDomain);
	if (FAILED(hr)) goto Cleanup;
	hr = g_pISTAppDomain->GetColumnValues(0, cAppDomain_NumberOfColumns, NULL, NULL, (LPVOID*)&sAppDomain);
	if (FAILED(hr)) goto Cleanup;

#ifdef _DEBUG
	wprintf(L"GetTable succeeded on %s\n", wszTABLE_AppDomain);
#endif

	iRow = 0;
	while ((hr = g_pISTBinding->GetColumnValues(iRow, cBINDINGREDIRTABLE_NumberOfColumns, NULL, NULL, (LPVOID*)&sBinding)) == S_OK)
	{
		iRow++;
	}
	if (hr == E_ST_NOMOREROWS)	{	hr = S_OK;	}
	if (FAILED(hr)) goto Cleanup;

	iRow = 0;
	while ((hr = g_pISTAssembiles->GetColumnValues(iRow, cASSEMBLIESTABLE_NumberOfColumns, NULL, NULL, (LPVOID*)&sAssembly)) == S_OK)
	{
		iRow++;
	}
	if (hr == E_ST_NOMOREROWS)	{	hr = S_OK;	}
	if (FAILED(hr)) goto Cleanup;

#ifdef _DEBUG
	wprintf(L"All succeeded press any key to continue\n");
#endif

	if (argc > 1)
	{
		_getch();
	}
	
Cleanup:
	if (FAILED(hr))
		throw;
	if (g_pISTDisp)					{	g_pISTDisp->Release();	}
	if (g_pISTBinding)				{	g_pISTBinding->Release();	}
	if (g_pISTAssembiles)			{	g_pISTAssembiles->Release();	}
	if (g_pISTModes)				{	g_pISTModes->Release();	}
	if (g_pISTAppDomain)			{	g_pISTAppDomain->Release();	}

#ifdef _DEBUG
	CoUninitialize();
#endif

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\perfsecurity\tableprovider.h ===
#ifndef __TABLEPROVIDER_H__
#define __TABLEPROVIDER_H__

LPCWSTR		wszXMLFile = L"d:\\urt\\tests\\configsecurity.xml";
LPCWSTR		wszCLBFile = L"d:\\urt\\tests\\configsecurity.clb";

STQueryCell sXMLQuery[] = {{ (LPVOID)wszXMLFile,  eST_OP_EQUAL, iST_CELL_FILE, DBTYPE_WSTR, (wcslen(wszXMLFile)+1) * 2}};
ULONG	cXMLCells	= sizeof(sXMLQuery)/sizeof(STQueryCell);

STQueryCell sCLBQuery[] = {{ (LPVOID)wszCLBFile,  eST_OP_EQUAL, iST_CELL_FILE, DBTYPE_WSTR, (wcslen(wszCLBFile)+1) * 2}};
ULONG	cCLBCells	= sizeof(sCLBQuery)/sizeof(STQueryCell);

#define iLevels						0
#define iNamedPermissionSets		1
#define iCodeGroups					2
#define iPermissions				3
#define iMemberships				4
#define iTableCount					5

LPCWSTR awszXMLTableNames[] = {wszTABLE_Levels, wszTABLE_NamedPermissionSets, wszTABLE_Codegroups,
		wszTABLE_Permissions, wszTABLE_Memberships };

LPCWSTR awszCLBTableNames[] = {wszTABLE_Levels_CLB, wszTABLE_NamedPermissionSets_CLB, wszTABLE_Codegroups_CLB,
		wszTABLE_Permissions_CLB, wszTABLE_AllMemberships_CLB };


class CTableProvider
{
public:
	CTableProvider() 
	{
		memset(m_rpISTReads, 0, iTableCount * sizeof(ISimpleTableRead2*));
	}

	
	~CTableProvider() 
	{
		ReleaseTables();
	}

	HRESULT GetTable(ISimpleTableDispenser2* i_pISTDisp, ULONG i_iTableID, ISimpleTableRead2** o_ppISTRead)
	{
		HRESULT	hr = S_OK;
		if (m_rpISTReads[i_iTableID] == NULL)
		{
			hr = i_pISTDisp->GetTable (m_wszDatabase, m_awszTableNames[i_iTableID], m_pSTQuery, &m_cQueryCells, eST_QUERYFORMAT_CELLS, 
					0, (void**)&m_rpISTReads[i_iTableID]);
			if (FAILED(hr)) return hr;
		}
		*o_ppISTRead = m_rpISTReads[i_iTableID];
		m_rpISTReads[i_iTableID]->AddRef();
		return hr;
	}

	HRESULT ReleaseTables()
	{
		for (int i = 0; i < iTableCount; i++)
		{
			if (m_rpISTReads[i])
			{
				m_rpISTReads[i]->Release();
				m_rpISTReads[i] = NULL;
			}
		}
		return S_OK;
	}

	LPCWSTR		m_wszDatabase;
	LPCWSTR		*m_awszTableNames;
	STQueryCell	*m_pSTQuery;
	ULONG		m_cQueryCells;
	ISimpleTableRead2* m_rpISTReads[iTableCount];

};

class CXMLTableProvider : public CTableProvider
{
public:
	CXMLTableProvider() 
	{
		m_wszDatabase = wszDATABASE_URTGLOBAL;
		m_awszTableNames = awszXMLTableNames;
		m_pSTQuery = sXMLQuery;
		m_cQueryCells = cXMLCells;
	}	
};

class CCLBTableProvider : public CTableProvider
{
public:
	CCLBTableProvider() 
	{
		m_wszDatabase = wszDATABASE_POLICY;
		m_awszTableNames = awszCLBTableNames;
		m_pSTQuery = sCLBQuery;
		m_cQueryCells = cCLBCells;
	}	
};

#endif // __TABLEPROVIDER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\opntest\opntest.cpp ===
#include "objbase.h"

#define REGSYSDEFNS_DEFINE
#include "catalog.h"
#include "catmeta.h"
#include "stdio.h"

#ifdef _ICECAP
#include "icapctrl.h"
#endif



ULONG ikey = 29;
ULONG nCell = 1; 
STQueryCell sCell = { &ikey,  eST_OP_EQUAL, 0, DBTYPE_UI4, 4 };

#define goto_on_bad_hr(hr, label) if (FAILED (hr)) { goto label; }

//HRESULT CLBCommitWrite( REFGUID did, const WCHAR* wszInFileName );
enum ECommandType {
	eCmdRead = 0x0000,
	eCmdWrite = 0x0001,
	eCmdIndex = 0x0002
};


HRESULT Usage()
{
	printf( "opntest [options]\n" );
	printf( "w	[nodeid] add row to WONS tables\n" );
	printf( "r	read WONS tables\n" );
	printf( "wo	[nodeid] add row to OP tables\n" );
	printf( "ro	read OP tables\n" );
	printf( "qo	index and query test on OP table" );
	printf( "q	[parentid]index and query test on WONS table" );

	return (E_FAIL);
}

int _cdecl main(int			argc,					// How many input arguments.
				CHAR			*argv[])				// Optional config args.

{
	BOOL bReadOnly = TRUE, bOP = FALSE;
	HRESULT hr;
	ISimpleTableDispenser2* pISTDisp = NULL;	
	ISimpleTableWrite2* pISimpleTableWrite = NULL;
	ISimpleTableRead2* pISimpleTableRead = NULL;
	DWORD fTable = 0;
	ECommandType eCommand; 

	if ( argc < 2 )
		return Usage();

	LPSTR starg = argv[1];

	switch (starg[0])
	{
		case 'w':
		case 'W':
			eCommand = eCmdWrite;
			fTable = fST_LOS_READWRITE;
			if ( argc < 3 )
				return Usage();
			break;
		case 'r':
		case 'R':
			eCommand = eCmdRead;
			fTable = 0;
			break;
		case 'Q':
		case 'q':
			eCommand = eCmdIndex;
			break;

		default:
			return ( Usage() );
	}

	switch ( starg[1] )
	{
		case 'o':
		case 'O':
			bOP = TRUE;
	}


	hr = GetSimpleTableDispenser (WSZ_PRODUCT_URT, 0, &pISTDisp);
	if ( FAILED(hr) ) return hr;


	goto_on_bad_hr( hr, Cleanup );

	if ( eCommand == eCmdWrite )
	{
		ULONG iNode = atoi( argv[2] );
		ULONG iParent = iNode + 10;
		ULONG iWriteRow;

		LPVOID apv[3];
		
		apv[0] = &iNode;
		apv[1] = L"CorpSrv";
		apv[2] = &iParent;

		if ( !bOP)
			hr = pISTDisp->GetTable (wszDATABASE_WONS, wszTABLE_WONSIDS, 
									 NULL, NULL, eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableWrite );
		else 
			hr = pISTDisp->GetTable (wszDATABASE_OP, wszTABLE_TBLNAMESPACEIDS, 
									 NULL, NULL, eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableWrite );


		goto_on_bad_hr( hr, Cleanup );
		
		hr = pISimpleTableWrite->AddRowForInsert(&iWriteRow);
		goto_on_bad_hr( hr, Cleanup );
		
		hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 3, 0, 0, apv );
		goto_on_bad_hr( hr, Cleanup );

		iNode++;
		hr = pISimpleTableWrite->AddRowForInsert(&iWriteRow);
		goto_on_bad_hr( hr, Cleanup );
		
		hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 3, 0, 0, apv );
		goto_on_bad_hr( hr, Cleanup );

		hr = pISimpleTableWrite->UpdateStore();
		goto_on_bad_hr( hr, Cleanup );

		pISimpleTableWrite->Release();
		pISimpleTableWrite = NULL;

//		hr = CLBCommitWrite( didWONS, NULL );

	}

	else if ( eCommand == eCmdRead )
	{
		int iRow=0;
		
		if ( !bOP )
			hr = pISTDisp->GetTable  (wszDATABASE_WONS, wszTABLE_WONSIDS,  
									  NULL, 0, eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead );
		else
			hr = pISTDisp->GetTable  (wszDATABASE_OP, wszTABLE_TBLNODEPROPERTYBAGINFO,   
									  NULL, NULL, eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead );


		goto_on_bad_hr( hr, Cleanup );

		LPVOID apv[3];
		ULONG acb[3];
			
		//Get the column data
		while ((hr = pISimpleTableRead->GetColumnValues(iRow, 3,NULL,acb, apv)) == S_OK)
		{
			for ( int i =0; ; i++ )
			{
				
				LPWSTR wsz;
				SimpleColumnMeta stMeta;
				
				DWORD dbtype;
				
				hr = pISimpleTableRead->GetColumnMetas( 1, (ULONG*)&i, &stMeta );
				
				if ( FAILED(hr) )
					break;	
				
				dbtype = stMeta.dbType;
				
				//print the column data
				if ( !apv[i] )
					wprintf(L"\tColumn %d: NULL", i );
				else if ( dbtype == DBTYPE_BYTES )
				{
					ULONG* pul = (ULONG*)apv[i];
					wprintf(L"\tColumn %d:", i );
					
					if (apv[i])
					{
						for ( ULONG n = 0; n < acb[i]/4; n++ )
						{
							wprintf(L"%x ",  *pul);
							pul++;
						}
					}
						wprintf(L"\n");
				}
				else if ( dbtype == DBTYPE_WSTR )
				{
					wsz = (LPWSTR)apv[i];
					if (apv[i])
						wprintf(L"\tColumn %d: %s\n", i, wsz );
					else
						wprintf(L"\tColumn %d: \n", i);
				}
				else if ( dbtype == DBTYPE_UI4 )
				{
					if (apv[i] )
						wprintf(L"\tColumn %d: %d\n", i, *((ULONG*)apv[i]) );

				}
				else if( dbtype == DBTYPE_GUID )
				{
					GUID guid = *((GUID*)apv[i]);
					StringFromCLSID( guid, &wsz );
					wprintf(L"\tColumn %d: %s\n", i, wsz);
					CoTaskMemFree(wsz);
				}		
				
			} //for
			
			iRow++;
			wprintf(L"\n");
		} //while
	
	} 

	else if ( bOP && eCommand == eCmdIndex )
	{
		LPVOID apv[3];
		
	//	apv[2] = L"Dummy";
		WCHAR wsz1[] = L"Dummyxxx";
		WCHAR wsz2[] = L"DummyDummyxxx";

		ULONG iWriteRow;


		ULONG iNode = 10;
		const WCHAR wszProp[] = L"Prop1";

		STQueryCell stCells[] = 
		{
			{ (LPVOID)&iNode,  eST_OP_EQUAL, 0, DBTYPE_UI4, 4 },
			{ (LPVOID)&wszProp, eST_OP_EQUAL, 1, DBTYPE_WSTR, (wcslen(wszProp)+1)*2 }
		};

		ULONG cCells = 1;

#ifdef _ICECAP
		ICAPCtrlStartCAP();
#endif

		hr = pISTDisp->GetTable (wszDATABASE_OP, wszTABLE_TBLNODEPROPERTYBAGINFO, 
								NULL, NULL, eST_QUERYFORMAT_CELLS, fST_LOS_READWRITE, (void**)&pISimpleTableWrite );

		for ( int i = 0; i < 200; i ++ )
		{
			apv[0] = &i;

			apv[1] = L"Prop1";
			_itow( i, &wsz1[5], 10 );
			apv[2] = &wsz1[0];

			hr = pISimpleTableWrite->AddRowForInsert(&iWriteRow);
			goto_on_bad_hr( hr, Cleanup );
			
			hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 3, 0, 0, apv );
			goto_on_bad_hr( hr, Cleanup );

			apv[1] = L"Prop2";
			_itow( i, &wsz2[10], 10 );
			apv[2] = &wsz2[0];

			hr = pISimpleTableWrite->AddRowForInsert(&iWriteRow);
			goto_on_bad_hr( hr, Cleanup );
			
			hr = pISimpleTableWrite->SetWriteColumnValues( iWriteRow, 3, 0, 0, apv );
			goto_on_bad_hr( hr, Cleanup );
		}

		hr = pISimpleTableWrite->UpdateStore();
		if ( hr == E_ST_DETAILEDERRS )
		{
			ISimpleTableAdvanced* pISTAdv = NULL;
			ULONG cErrs;
			STErr err;
			hr = pISimpleTableWrite->QueryInterface( IID_ISimpleTableAdvanced, (void**)&pISTAdv );
			goto_on_bad_hr( hr, Cleanup );
			hr = pISTAdv->GetDetailedErrorCount(&cErrs);
			goto_on_bad_hr( hr, Cleanup );
			hr = pISTAdv->GetDetailedError( 0, &err);
			goto_on_bad_hr( hr, Cleanup );
		}



	//	goto_on_bad_hr( hr, Cleanup );

		pISimpleTableWrite->Release();
		pISimpleTableWrite = NULL;
		


		hr = pISTDisp->GetTable (wszDATABASE_OP, wszTABLE_TBLNODEPROPERTYBAGINFO, 
								stCells, &cCells, eST_QUERYFORMAT_CELLS, 0, (void**)&pISimpleTableRead );

		goto_on_bad_hr( hr, Cleanup );

		hr = pISimpleTableRead->GetColumnValues(0, 3,NULL,NULL, apv);

		if ( hr == S_OK )
			printf("found!");
		else
			printf("Not found.");

#ifdef _ICECAP
		ICAPCtrlStopCAP();
#endif

	}
	else
	{
		ULONG iParent = atoi( argv[2] );
		STQueryCell stCells[] = 
		{
	//		{ (LPVOID)WONSIDS_Dex_Name_ParentId, eST_OP_EQUAL, iST_CELL_INDEXHINT, DBTYPE_WSTR, 0 },
	//		{ (LPVOID)L"CorpSrv",  eST_OP_EQUAL, 1, DBTYPE_WSTR, 0 },
			{ (LPVOID)&iParent, eST_OP_EQUAL, 2,DBTYPE_UI4, 0 },
		};
		ULONG cCells = 1;
		ULONG iRows = 0;
		LPVOID apv[3];

		hr = pISTDisp->GetTable  (wszDATABASE_WONS, wszTABLE_WONSIDS,  
								  stCells, &cCells, eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead );

		goto_on_bad_hr( hr, Cleanup );

		while( pISimpleTableRead->GetColumnValues(iRows, 3,NULL,NULL, apv) == S_OK )
			iRows++;

		printf("%d rows found", iRows);
	}

Cleanup:

	if ( pISTDisp )
		pISTDisp->Release();

	if ( pISimpleTableRead )
		pISimpleTableRead->Release();

	if ( pISimpleTableWrite )
		pISimpleTableWrite->Release();
		
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\perfsecurity\perfsecurity.cpp ===
#include "catalog.h"
#include "catmeta.h"
#include "stdio.h"
#include "catmacros.h"
#include "TableProvider.h"
#include <conio.h>

#define goto_on_bad_hr(hr, label) if (FAILED (hr)) { goto label; }
#define MAXCOLUMNS 64

// Forwards.
HRESULT	PolicyFromConfig(CTableProvider *i_pTableProvider, ISimpleTableDispenser2* i_pISTDisp, LPCWSTR i_wszLevelName);
HRESULT	LevelFromConfig(CTableProvider *i_pTableProvider, ISimpleTableDispenser2* i_pISTDisp, LPCWSTR i_wszLevelName);
HRESULT	PermissionSetsFromConfig(CTableProvider *i_pTableProvider, ISimpleTableDispenser2* i_pISTDisp, LPCWSTR i_wszLevelName, LPCWSTR i_wszPSName);
HRESULT	CodeGroupsFromConfig(CTableProvider *i_pTableProvider, ISimpleTableDispenser2* i_pISTDisp, LPCWSTR i_wszLevelName,	LPCWSTR i_wszCGName);

// Globals.
ULONG	g_iIterations = 1;
BOOL	g_bIsXML = TRUE;

int _cdecl main(int		argc,					// How many input arguments.
				CHAR	*argv[])				// Optional config args.
{
	HRESULT		hr = S_OK;
	ISimpleTableDispenser2* pISTDisp = NULL;	
	CTableProvider *pITableProvider = NULL;
	ULONG		i = 0;

    for(int n=1; n < argc; n++)
	{
        if(*argv[n] == '/' || *argv[n] == '-')//only acknowledge those command lines that begin with a '/' or a '-'
        {
			if ((argv[n][1] == L'c') || (argv[n][1] == L'C'))
			{
				g_bIsXML = FALSE;
			}
        }
		else
		{
			g_iIterations = atoi(argv[n]);
		}
	}

	hr = CoInitialize(NULL);

	if (g_bIsXML)
	{
		pITableProvider = new CXMLTableProvider;
		if (pITableProvider == NULL) { hr = E_OUTOFMEMORY; goto Cleanup;}
	}
	else
	{
		pITableProvider = new CCLBTableProvider;
		if (pITableProvider == NULL) { hr = E_OUTOFMEMORY; goto Cleanup;}
	}

//	_getch();
	for (i = 0; i < g_iIterations; i++)
	{
		// Get the dispenser.
		hr = GetSimpleTableDispenser (WSZ_PRODUCT_URT, 0, &pISTDisp);
		if (FAILED(hr)) goto Cleanup;
		hr = PolicyFromConfig(pITableProvider, pISTDisp, L"Machine");
		if (FAILED(hr)) goto Cleanup;
		pISTDisp->Release();
		pISTDisp = NULL;
		pITableProvider->ReleaseTables();
	}

Cleanup:
	if (pITableProvider)
		delete pITableProvider;

	if (pISTDisp)
		pISTDisp->Release();

	if (FAILED(hr))
		ASSERT(0);
	Sleep(20000);

	return 0;
}

HRESULT	PolicyFromConfig(CTableProvider *i_pTableProvider, ISimpleTableDispenser2* i_pISTDisp, LPCWSTR i_wszLevelName)
{
	ISimpleTableRead2* pISTLevels = NULL;
	LPVOID		apvValues[MAXCOLUMNS];
	ULONG		acbSizes[MAXCOLUMNS];
	DWORD		cRows = 0;
	DWORD		cColumns = 0;
	DWORD		iReadRow = 0;
	HRESULT		hr = S_OK;

	hr = i_pTableProvider->GetTable(i_pISTDisp, iLevels, &pISTLevels);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	hr = pISTLevels->GetTableMeta (NULL, NULL, &cRows, &cColumns);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	for (iReadRow = 0; iReadRow < cRows; iReadRow++)
	{
		hr = pISTLevels->GetColumnValues(iReadRow, cColumns, NULL, acbSizes, apvValues);
		if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		
		if (wcscmp((LPCWSTR)apvValues[0], i_wszLevelName) == 0)
		{
			hr = LevelFromConfig(i_pTableProvider, i_pISTDisp, i_wszLevelName);
			if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		}
	}
Cleanup:
	if (pISTLevels)
		pISTLevels->Release();
	return hr;
}
	
HRESULT	LevelFromConfig(
	CTableProvider *i_pTableProvider, 
	ISimpleTableDispenser2* i_pISTDisp, 
	LPCWSTR		i_wszLevelName)
{
	ISimpleTableRead2* pISTNamedPermissionSets = NULL;
	ISimpleTableRead2* pISTCodeGroups = NULL;
	LPVOID		apvValues[MAXCOLUMNS];
	ULONG		acbSizes[MAXCOLUMNS];
	DWORD		cRows = 0;
	DWORD		cColumns = 0;
	DWORD		iReadRow = 0;
	HRESULT		hr = S_OK;

	hr = i_pTableProvider->GetTable(i_pISTDisp, iNamedPermissionSets, &pISTNamedPermissionSets);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	hr = pISTNamedPermissionSets->GetTableMeta (NULL, NULL, &cRows, &cColumns);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	for (iReadRow = 0; iReadRow < cRows; iReadRow++)
	{
		hr = pISTNamedPermissionSets->GetColumnValues(iReadRow, cColumns, NULL, acbSizes, apvValues);
		if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		
		if (wcscmp((LPCWSTR)apvValues[1], i_wszLevelName) == 0)
		{
			hr = PermissionSetsFromConfig(i_pTableProvider, i_pISTDisp, i_wszLevelName, (LPCWSTR)apvValues[0]);
			if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		}
	}

	hr = i_pTableProvider->GetTable(i_pISTDisp, iCodeGroups, &pISTCodeGroups);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	hr = pISTCodeGroups->GetTableMeta (NULL, NULL, &cRows, &cColumns);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	for (iReadRow = 0; iReadRow < cRows; iReadRow++)
	{
		hr = pISTCodeGroups->GetColumnValues(iReadRow, cColumns, NULL, acbSizes, apvValues);
		if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		
		if ((wcscmp((LPCWSTR)apvValues[0], i_wszLevelName) == 0) && (wcscmp((LPCWSTR)apvValues[1], L"Junk") == 0))
		{
			hr = CodeGroupsFromConfig(i_pTableProvider, i_pISTDisp, i_wszLevelName, (LPCWSTR)apvValues[2]);
			if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		}
	}
Cleanup:
	if (pISTNamedPermissionSets)
		pISTNamedPermissionSets->Release();
	if (pISTCodeGroups)
		pISTCodeGroups->Release();
	return hr;
}
	
HRESULT	PermissionSetsFromConfig(
	CTableProvider *i_pTableProvider, 
	ISimpleTableDispenser2* i_pISTDisp, 
	LPCWSTR		i_wszLevelName,
	LPCWSTR		i_wszPSName)
{
	ISimpleTableRead2* pISTRead = NULL;
	LPVOID		apvValues[MAXCOLUMNS];
	ULONG		acbSizes[MAXCOLUMNS];
	DWORD		cRows = 0;
	DWORD		cColumns = 0;
	DWORD		iReadRow = 0;
	ULONG		iDummy = 0;
	HRESULT		hr = S_OK;

	hr = i_pTableProvider->GetTable(i_pISTDisp, iPermissions, &pISTRead);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	hr = pISTRead->GetTableMeta (NULL, NULL, &cRows, &cColumns);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	for (iReadRow = 0; iReadRow < cRows; iReadRow++)
	{
		hr = pISTRead->GetColumnValues(iReadRow, cColumns, NULL, acbSizes, apvValues);
		if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		
		if ((wcscmp((LPCWSTR)apvValues[0], i_wszLevelName) == 0) && (wcscmp((LPCWSTR)apvValues[1], i_wszPSName) == 0))
		{
			// Do nothing.
			iDummy++;
		}
	}
	if (pISTRead)
	{
		pISTRead->Release();
		pISTRead = NULL;
	}

Cleanup:
	if (pISTRead)
		pISTRead->Release();
	return hr;
}

HRESULT	CodeGroupsFromConfig(
	CTableProvider *i_pTableProvider, 
	ISimpleTableDispenser2* i_pISTDisp, 
	LPCWSTR		i_wszLevelName,
	LPCWSTR		i_wszCGName)
{
	ISimpleTableRead2* pISTRead = NULL;
	ISimpleTableRead2* pISTCodeGroups = NULL;
	LPVOID		apvValues[MAXCOLUMNS];
	ULONG		acbSizes[MAXCOLUMNS];
	DWORD		cRows = 0;
	DWORD		cColumns = 0;
	DWORD		iReadRow = 0;
	BOOL		bFoundMembership = FALSE;
	HRESULT		hr = S_OK;

	hr = i_pTableProvider->GetTable(i_pISTDisp, iMemberships, &pISTRead);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	hr = pISTRead->GetTableMeta (NULL, NULL, &cRows, &cColumns);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	for (iReadRow = 0; (iReadRow < cRows) && !bFoundMembership; iReadRow++)
	{
		hr = pISTRead->GetColumnValues(iReadRow, cColumns, NULL, acbSizes, apvValues);
		if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		
		if ((wcscmp((LPCWSTR)apvValues[0], i_wszLevelName) == 0) && (wcscmp((LPCWSTR)apvValues[1], i_wszCGName) == 0))
		{
			// Do nothing.
			bFoundMembership = TRUE;
		}
	}
	if (pISTRead)
	{
		pISTRead->Release();
		pISTRead = NULL;
	}

	hr = i_pTableProvider->GetTable(i_pISTDisp, iCodeGroups, &pISTCodeGroups);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	hr = pISTCodeGroups->GetTableMeta (NULL, NULL, &cRows, &cColumns);
	if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }

	for (iReadRow = 0; (iReadRow < cRows); iReadRow++)
	{
		hr = pISTCodeGroups->GetColumnValues(iReadRow, cColumns, NULL, acbSizes, apvValues);
		if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		
		if ((wcscmp((LPCWSTR)apvValues[0], i_wszLevelName) == 0) && (wcscmp((LPCWSTR)apvValues[1], i_wszCGName) == 0))
		{
			hr = CodeGroupsFromConfig(i_pTableProvider, i_pISTDisp, i_wszLevelName, (LPCWSTR)apvValues[2]);
			if (FAILED(hr)) {ASSERT(SUCCEEDED(hr)); goto Cleanup; }
		}
	}

Cleanup:
	if (pISTRead)
		pISTRead->Release();
	if (pISTCodeGroups)
		pISTCodeGroups->Release();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\stconsumer\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\stconsumer\consumer.cpp ===
// Consumer.cpp : Implementation of CConsumer
#include "stdafx.h"
#include "STConsumer.h"
#include "Consumer.h"
#include "catmacros.h"
#include "assert.h"

HRESULT PrintRow (ISimpleTableWrite2 *i_pISTWrite, ULONG i_WriteRow);

/////////////////////////////////////////////////////////////////////////////
// CConsumer

STDMETHODIMP CConsumer::OnRowInsert(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow)
{
	HRESULT	hr;

	wprintf(L"Inserting Row to table: %s : \n", i_wszTable); 
	hr = PrintRow(i_pISTWrite, i_iWriteRow);
	i_pISTWrite->Release();
	return hr;
}

STDMETHODIMP CConsumer::OnRowDelete(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow)
{
	HRESULT	hr;

	wprintf(L"Deleting row in table: %s : \n", i_wszTable); 
	hr = PrintRow(i_pISTWrite, i_iWriteRow);
	i_pISTWrite->Release();
	return hr;
}

STDMETHODIMP CConsumer::OnRowUpdate(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow)
{
	HRESULT	hr;

	wprintf(L"Updating row in table: %s : \n", i_wszTable); 
	hr = PrintRow(i_pISTWrite, i_iWriteRow);
	i_pISTWrite->Release();
	return hr;
}


HRESULT PrintRow (ISimpleTableWrite2 *i_pISTWrite, ULONG i_WriteRow)
{
	HRESULT hr;
	ULONG cRows, cColumns;
	SimpleColumnMeta *acColumnMetas;
	LPVOID * apData;
	ULONG * acbSize;
	ULONG j;

	ULONG			ib;
	GUID*			pguid;
	DWORD			dwtype;	
	ULONG			cb;
	LPVOID			pv;
	WCHAR *			wsz;
	
	
	hr = i_pISTWrite->GetTableMeta(NULL, NULL, &cRows, &cColumns);
	if( FAILED (hr)) assert(0);

	acColumnMetas = new SimpleColumnMeta[cColumns];
	apData = new LPVOID[cColumns];
	acbSize = new ULONG[cColumns];
	
	hr = i_pISTWrite->GetColumnMetas(cColumns, NULL, acColumnMetas);
	if( FAILED (hr)) assert(0);
	
	hr = i_pISTWrite->GetWriteColumnValues(i_WriteRow, cColumns, NULL, NULL, acbSize, apData);
	if( FAILED (hr)) assert(0);

	for(j = 0; j<cColumns; j++)
	{
		pv = apData[j];
		cb = acbSize[j];
		dwtype = acColumnMetas[j].dbType;
		
		wprintf (L"%d (%d,%d): ",j, dwtype, cb);		
		
		switch(dwtype){
			case DBTYPE_WSTR: //wstr
				wprintf (L"%s", (NULL == pv ? L"<NULL>" : (LPWSTR) pv));
			break;
			case DBTYPE_GUID: //guid
				if (NULL == pv)
				{
					wprintf (L"<NULL>");
				}
				else
				{
					pguid = (GUID*) pv;
					StringFromCLSID (*pguid, &wsz);
					wprintf (L"%s", (LPWSTR) wsz);
					CoTaskMemFree (wsz);
				}
				break;				
			case DBTYPE_BYTES: //bytes
				if (NULL == pv)
				{
					wprintf (L"<NULL>");
				}
				else
				{
					for (ib = 0; ib < cb; ib++)
					{
						wprintf (L"%x", ((BYTE*) pv)[ib]);
					}
				}
			break;
			case DBTYPE_UI4: // ui4
				wprintf (L"%lu", *(ULONG*) pv);
			break;
			default:
				assert (0);
			break;
		}
		
		wprintf (L"\n");
	} //columns
	wprintf (L"\n");
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\simpletest\test.cpp ===
//  Copyright (C) 1995-1999 Microsoft Corporation.  All rights reserved.

#include "objbase.h"
#include "atlbase.h"
#include "atlimpl.cpp"

#include "catmacros.h"

#include "stdio.h"
#include "conio.h"
#include "catalog.h"
#include "initguid.h"
#include "catmeta.h"

#define cARGS				3
#define iARG_TEST			1
#define iARG_ITERATIONS		2
#define iARG_SILENT			3
#define szSILENT			"/s"

#define g_cIterations 10000


HRESULT PrintTable (ISimpleTableRead2 *pISTRead)
{
	HRESULT hr;
	ULONG cRows, cColumns;
	SimpleColumnMeta * aTypes;
	LPVOID * apData;
	ULONG * acbSize;
	ULONG * aColumnIndexes;
	ULONG i,j;

	ULONG			ib;
	GUID*			pguid;
	DWORD			dwtype;	
	ULONG			cb;
	LPVOID			pv;
	WCHAR *			wsz;
	
	hr = pISTRead->GetTableMeta(NULL, NULL, &cRows, &cColumns);
	if( FAILED (hr)) ASSERT(0);

	aTypes = new SimpleColumnMeta[cColumns];
	apData = new LPVOID[cColumns];
	acbSize = new ULONG[cColumns];
	aColumnIndexes = new ULONG[cColumns];

	hr = pISTRead->GetColumnMetas(cColumns, NULL, aTypes);
	if( FAILED (hr)) ASSERT(0);

	for ( i = 0; i< cColumns; i++)
	{
		aColumnIndexes[i] = i;
	}
	
	for ( i = 0; i< cRows; i++)
	{
		hr = pISTRead->GetColumnValues(i, cColumns, aColumnIndexes, acbSize, apData);
		if( FAILED (hr)) ASSERT(0);

		for(j = 0; j<cColumns; j++)
		{
			pv = apData[j];
			cb = acbSize[j];
			dwtype = aTypes[j].dbType;
			
			wprintf (L"%d (%d,%d): ",i, dwtype, cb);		
			
			switch(aTypes[j].dbType){
				case DBTYPE_WSTR: //wstr
					wprintf (L"%s", (NULL == pv ? L"<NULL>" : (LPWSTR) pv));
				break;
				case DBTYPE_GUID: //guid
					if (NULL == pv)
					{
						wprintf (L"<NULL>");
					}
					else
					{
						pguid = (GUID*) pv;
						StringFromCLSID (*pguid, &wsz);
						wprintf (L"%s", (LPWSTR) wsz);
						CoTaskMemFree (wsz);
					}
					break;				
				case DBTYPE_BYTES: //bytes
					if (NULL == pv)
					{
						wprintf (L"<NULL>");
					}
					else
					{
						for (ib = 0; ib < cb; ib++)
						{
							wprintf (L"%x", ((BYTE*) pv)[ib]);
						}
					}
				break;
				case DBTYPE_UI4: // ui4
					wprintf (L"%lu", (ULONG) pv);
				break;
				default:
					ASSERT (0);
				break;
			}
			
			wprintf (L"\n");
		} //columns
		wprintf (L"\n");
	} //rows
	
	return hr;
}

int __cdecl main (int argc, char *argv[], char *envp[])
{
	ULONG			iTest, iIteration, cIterations;
	HRESULT			hr;

	{
	CComPtr <ISimpleTableRead2>  pIST;
	CComPtr	<ISimpleTableDispenser2> pISTD;

	ULONG			cQueryCells;
	STQueryCell		QueryCell;

// Command parsing:
	if ((cARGS != argc) && (cARGS+1 != argc))
	{ 
		hr = E_FAIL;
		goto Cleanup;
	}
	iTest = atol (argv[iARG_TEST]);
	if (0 == iTest)
	{
		hr = E_FAIL;
		goto Cleanup;
	}
	cIterations = atol (argv[iARG_ITERATIONS]);
	if (0 == cIterations)
	{
		hr = E_FAIL;
		goto Cleanup;
	}
	

	CRITICAL_SECTION mCritSec;
	
	InitializeCriticalSection(&mCritSec);
	
	InitializeCriticalSection(&mCritSec);

	InitializeCriticalSection(&mCritSec);

// Tests:
	switch (iTest)
	{
		case 1:
				hr = GetSimpleTableDispenser (WSZ_PRODUCT_URT, 0, &pISTD);
				if(FAILED(hr))
				{
					goto Cleanup;
				}

				cQueryCells = 1;
				QueryCell.pData     = L"catwire.xml";
				QueryCell.eOperator = eST_OP_EQUAL;
				QueryCell.iCell     = iST_CELL_FILE;
				QueryCell.dbType    = DBTYPE_WSTR;
				QueryCell.cbSize    = (wcslen(L"catwire.xml")+1)*sizeof(WCHAR);

				hr = pISTD->GetTable (wszDATABASE_WIRING, wszTABLE_PERDATABASEW, (LPVOID *)&QueryCell, (LPVOID)(&cQueryCells), 
								eST_QUERYFORMAT_CELLS,  0, reinterpret_cast<void**>(&pIST));
				if(FAILED(hr))
				{
					TRACE (L"Get table failed");
					goto Cleanup;
				}

				hr = PrintTable(pIST);
				break;

		case 2:
//				ASSERT(0 && L"Hmmm, ce interesant");
//				TRACE (L"hr = %d",hr);
//				LOG_ERROR(Simple, (114, 0, L"Iaca-ta un string"));
				break;
		default:;
				ASSERT(0 && L"Invalid test case");
	}//switch
Cleanup:
	
	::wprintf(L"Hresult is %X: ", hr);
	::wprintf(L"Done, press a key \n");
	_getche();
}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\stconsumer\consumer.h ===
// Consumer.h : Declaration of the CConsumer

#ifndef __CONSUMER_H_
#define __CONSUMER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CConsumer
class ATL_NO_VTABLE CConsumer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CConsumer, &CLSID_Consumer>,
	public ISimpleTableEvent
{
public:
	CConsumer()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CONSUMER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CConsumer)
	COM_INTERFACE_ENTRY(ISimpleTableEvent)
END_COM_MAP()

// ISimpleTableEvent
public:
	STDMETHOD (OnRowInsert)(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow);
	STDMETHOD (OnRowDelete)(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow);
	STDMETHOD (OnRowUpdate)(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow);
};

#endif //__CONSUMER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\stconsumer\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by STConsumer.rc
//
#define IDS_PROJNAME                    100
#define IDR_CONSUMER                    101
#define IDI_ICON1                       201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\sdtxmltest\main.cpp ===
#include "objbase.h"
#include "catalog.h"
#define REGSYSDEFNS_DEFINE
#define REGSYSDEFNS_DID_COMSERVICES
#define REGSYSDEFNS_CLSID_STDISPENSER
#define REGSYSDEFNS_TID_COMSERVICES_NAMESPACE
#include "CatMeta.h"
#include "stdio.h"
#include "assert.h"

#define goto_on_bad_hr(hr, label) if (FAILED (hr)) { goto label; }
                                   
HRESULT PrintRow1 (ISimpleTableRead2 * pCSDTCursor, ULONG	iRow)
//void PrintRow1 (CComPtr<ISimpleTableRead> &pCSDTCursor)
{
	DWORD			dwtype;
	ULONG			cb;
	LPVOID			pv;
    WCHAR *         wsz=0;
	ULONG			ib;
	ULONG			iColumn;
	GUID*			pguid;
//	DBTIMESTAMP*	ptimestamp;
	HRESULT			hr;
    ULONG           dwNumColumns;
    ULONG           dwNumRows;

    pCSDTCursor->GetTableMeta(0, 0, &dwNumRows, &dwNumColumns);
    wprintf(L"\t\t\tNumber of Rows = %d,  Number of Columns = %d\n", dwNumRows, dwNumColumns);

    SimpleColumnMeta meta;

	for (iColumn = 0, hr = S_OK, cb = 0; iColumn<dwNumColumns; iColumn++, cb = 0)
	{
//		hr = pCSDTCursor->GetColumn (iColumn, &dwtype, &cb, &pv);
        hr = pCSDTCursor->GetColumnValues(iRow, 1, &iColumn, &cb, &pv);
		if(E_ST_NOMOREROWS == hr)
			break;

        if(FAILED(hr))
            break;

        hr = pCSDTCursor->GetColumnMetas(1, &iColumn, &meta );
        if(FAILED(hr))
            break;
        dwtype = meta.dbType;

        wprintf(L"%02d  ",iColumn);
        switch (dwtype)
		{
        case DBTYPE_BYTES:
            wprintf(L"(BYTES,%5d): ",cb);
			if (NULL == pv)
				wprintf (L"<NULL>");
			else
				for (ib = 0; ib < cb; ib++)
					wprintf (L"%1x", ((BYTE*) pv)[ib]);
            break;
        case DBTYPE_GUID:
            wprintf(L"( GUID,%5d): ",cb);
			if (NULL == pv)
				wprintf (L"<NULL>");
			else
			{
				pguid = (GUID*) pv;
				StringFromCLSID(*pguid, &wsz);
				wprintf (L"%s", (LPWSTR) wsz);
				CoTaskMemFree(wsz);wsz=0;
			}
            break;
        case DBTYPE_UI4:
            wprintf(L"(  UI4,%5d): ",cb);
			if (NULL == pv)
				wprintf (L"<NULL>");
			else
        		wprintf (L"%d", *(reinterpret_cast<ULONG *>(pv)));
            break;
        case DBTYPE_WSTR:
            wprintf(L"( WSTR,%5d): ",cb);
			wprintf(L"%s", (NULL == pv ? L"<NULL>" : (LPWSTR) pv));
            break;
        default://Print as byptes
            wprintf(L"(%5d,%5d): ",dwtype, cb);
			if (NULL == pv)
				wprintf (L"<NULL>");
			else
				for (ib = 0; ib < cb; ib++)
					wprintf (L"%1x", ((BYTE*) pv)[ib]);
            break;
		}
		wprintf (L"\n");
	}	
	return hr;
}

HRESULT Usage()
{
	printf( "SDTXmlTest [Database] [Table] [XML Filename] [-i:value,value,,,value|u:row,value,value,value,,value|d:row]\n" );

	return (E_FAIL);
}

extern "C" int __cdecl wmain( int argc, wchar_t *argv[ ], wchar_t *envp[ ] )
{
	BOOL bReadOnly = TRUE;
	HRESULT hr;
	ISimpleTableDispenser2* pISTDisp = NULL;	
    ISimpleTableAdvanced * pAdvanced = NULL;
	ISimpleTableWrite2* pISimpleTableWrite2 = NULL;
	ISimpleTableRead2*  pISimpleTableRead2 = NULL;
	DWORD fTable = 0;
    unsigned long one   =1;
    unsigned long two   =2;
    unsigned long three =3;
    unsigned long four  =4;

	if ( argc != 3 && argc != 4 && argc != 5 )
		return Usage();

    LPWSTR wszDatabase = argv[1];
    LPWSTR wszTable    = argv[2];

    wprintf(wszDatabase);wprintf(L"\n");
    wprintf(wszTable);wprintf(L"\n");

    hr = CoInitialize(NULL);
	goto_on_bad_hr( hr, Cleanup );

    hr = GetSimpleTableDispenser(WSZ_PRODUCT_URT, 0, &pISTDisp);

    goto_on_bad_hr( hr, Cleanup );
	
    switch(argc)
    {
        case 4:
        {
            if(*argv[3] >= L'0' && *argv[3] <= L'6')
            {
                // the third argument is a number where each digit has the following meanings
                // Most Significant Digit indicates which tidMETA should be used (must be 0-3) 0-wszTABLE_DATABASEMETA, 1-wszTABLE_TABLEMETA, 2-wszTABLE_COLUMNMETA, 3-wszTABLE_TAGMETA
                // 0  in the MSD means query the database meta that matches the did command line argument
                // 1  means query the wszTABLE_TABLEMETA whose database matches the did command line argument
                // 11 means query the wszTABLE_TABLEMETA whose database matches the did and tableid matches the tid passed in
                // 2  means query the wszTABLE_COLUMNMETA whose table id matches the tid command line argument
                // 2x means query for the column indicated by the 'x'
                // 3  means query the wszTABLE_TAGMETA whose tid matches the command line parameter
                // 3x means query the wszTABLE_TAGMETA whose tid matches and whose column index matches 'x'
                // 3xyyyy means query the wszTABLE_TAGMETA whose tid matches, whose column index matches 'x' and whose tag name matches 'yyyy'
                // 4  means query the wszTABLE_INDEXMETA matching the tid
                // 4yyyy means query the wszTABLE_INDEXMETA matching the tid and InternalName of the IndexMeta
                // 4xyyyy means query the wszTABLE_INDEXMETA matching the tid, InternalName and the ColumnOrdinal indicated by 'x'
                // 5
                // 6
                WCHAR *pargv = argv[3];

                static STQueryCell QueryCell[4];
                switch(pargv[0]-L'0')
                {
                case 0:
                    QueryCell[0].pData     = reinterpret_cast<void *>(wszDatabase);
                    QueryCell[0].eOperator = eST_OP_EQUAL;
                    QueryCell[0].iCell     = iDATABASEMETA_InternalName;
                    QueryCell[0].dbType    = DBTYPE_WSTR;
                    QueryCell[0].cbSize    = 0;
    		        hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_DATABASEMETA, &QueryCell, reinterpret_cast<void *>(&one), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                    break;
                case 1:
                    QueryCell[0].pData     = reinterpret_cast<void *>(wszDatabase);
                    QueryCell[0].eOperator = eST_OP_EQUAL;
                    QueryCell[0].iCell     = iTABLEMETA_Database;
                    QueryCell[0].dbType    = DBTYPE_WSTR;
                    QueryCell[0].cbSize    = 0;

                    if(0x00 == pargv[1])
                    {
    		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_TABLEMETA, &QueryCell, reinterpret_cast<void *>(&one), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                    }
                    else
                    {
                        QueryCell[1].pData     = reinterpret_cast<void *>(wszTable);
                        QueryCell[1].eOperator = eST_OP_EQUAL;
                        QueryCell[1].iCell     = iTABLEMETA_InternalName;
                        QueryCell[1].dbType    = DBTYPE_WSTR;
                        QueryCell[1].cbSize    = 0;

    		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_TABLEMETA, &QueryCell, reinterpret_cast<void *>(&two), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                    }
                    break;
                case 2:
                    QueryCell[0].pData     = reinterpret_cast<void *>(wszTable);
                    QueryCell[0].eOperator = eST_OP_EQUAL;
                    QueryCell[0].iCell     = iCOLUMNMETA_Table;
                    QueryCell[0].dbType    = DBTYPE_WSTR;
                    QueryCell[0].cbSize    = 0;

                    if(0x00 == pargv[1])
                    {
    		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_COLUMNMETA, &QueryCell, reinterpret_cast<void *>(&one), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                    }
                    else
                    {
                        WCHAR *pNotUsed;
                        unsigned long iOrder = wcstol(&pargv[1], &pNotUsed, 10);
                        QueryCell[1].pData     = reinterpret_cast<void *>(&iOrder);
                        QueryCell[1].eOperator = eST_OP_EQUAL;
                        QueryCell[1].iCell     = iCOLUMNMETA_Index;
                        QueryCell[1].dbType    = DBTYPE_UI4;
                        QueryCell[1].cbSize    = 0;

    		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_COLUMNMETA, &QueryCell, reinterpret_cast<void *>(&two), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                    }
                    break;
                case 3:
                    QueryCell[0].pData     = reinterpret_cast<void *>(wszTable);
                    QueryCell[0].eOperator = eST_OP_EQUAL;
                    QueryCell[0].iCell     = iTAGMETA_Table;
                    QueryCell[0].dbType    = DBTYPE_WSTR;
                    QueryCell[0].cbSize    = 0;

                    if(0x00 == pargv[1])//if nothing else specified
                    {
    		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_TAGMETA, &QueryCell, reinterpret_cast<void *>(&one), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                    }
                    else
                    {
                        WCHAR *pTagName=0;
                        unsigned long iOrder = wcstol(&pargv[1], &pTagName, 10);
                        QueryCell[1].pData     = reinterpret_cast<void *>(&iOrder);
                        QueryCell[1].eOperator = eST_OP_EQUAL;
                        QueryCell[1].iCell     = iTAGMETA_ColumnIndex;
                        QueryCell[1].dbType    = DBTYPE_UI4;
                        QueryCell[1].cbSize    = 0;

                        if(0x00 == *pTagName)
                        {
        		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_TAGMETA, &QueryCell, reinterpret_cast<void *>(&two), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                        }
                        else
                        {
                            QueryCell[2].pData     = reinterpret_cast<void *>(pTagName);
                            QueryCell[2].eOperator = eST_OP_EQUAL;
                            QueryCell[2].iCell     = iTAGMETA_InternalName;
                            QueryCell[2].dbType    = DBTYPE_WSTR;
                            QueryCell[2].cbSize    = 0;

        		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_TAGMETA, &QueryCell, reinterpret_cast<void *>(&three), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                        }
                    }
                    break;
                case 4:
                    QueryCell[0].pData     = reinterpret_cast<void *>(wszTable);
                    QueryCell[0].eOperator = eST_OP_EQUAL;
                    QueryCell[0].iCell     = iINDEXMETA_Table;
                    QueryCell[0].dbType    = DBTYPE_WSTR;
                    QueryCell[0].cbSize    = 0;

                    if(0x00 == pargv[1])//if nothing else specified
                    {
    		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_INDEXMETA, &QueryCell, reinterpret_cast<void *>(&one), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                    }
                    else
                    {
                        bool bColumnOrderQuery = (pargv[1] >= L'0' && pargv[1]<= L'9');

                        if(!bColumnOrderQuery)
                        {
                            QueryCell[1].pData     = reinterpret_cast<void *>(&pargv[1]);
                            QueryCell[1].eOperator = eST_OP_EQUAL;
                            QueryCell[1].iCell     = iINDEXMETA_InternalName;
                            QueryCell[1].dbType    = DBTYPE_WSTR;
                            QueryCell[1].cbSize    = 0;

        		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_INDEXMETA, &QueryCell, reinterpret_cast<void *>(&two), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                        }
                        else
                        {
                            WCHAR *pIndexName=0;
                            unsigned long iColumnOrder = wcstol(&pargv[1], &pIndexName, 10);

                            QueryCell[2].pData     = reinterpret_cast<void *>(&iColumnOrder);
                            QueryCell[2].eOperator = eST_OP_EQUAL;
                            QueryCell[2].iCell     = iINDEXMETA_ColumnIndex;
                            QueryCell[2].dbType    = DBTYPE_UI4;
                            QueryCell[2].cbSize    = 0;

                            QueryCell[1].pData     = reinterpret_cast<void *>(pIndexName);
                            QueryCell[1].eOperator = eST_OP_EQUAL;
                            QueryCell[1].iCell     = iINDEXMETA_InternalName;
                            QueryCell[1].dbType    = DBTYPE_WSTR;
                            QueryCell[1].cbSize    = 0;

        		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_INDEXMETA, &QueryCell, reinterpret_cast<void *>(&three), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                        }

                    }
                    break;
                case 5:
                    QueryCell[0].pData     = reinterpret_cast<void *>(wszTable);
                    QueryCell[0].eOperator = eST_OP_EQUAL;
                    QueryCell[0].iCell     = iQUERYMETA_Table;
                    QueryCell[0].dbType    = DBTYPE_WSTR;
                    QueryCell[0].cbSize    = 0;

                    if(0x00 == pargv[1])//if nothing else specified
                    {
    		            hr = pISTDisp->GetTable(wszDATABASE_META, wszTABLE_QUERYMETA, &QueryCell, reinterpret_cast<void *>(&one), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
                    }
                    break;
                }
            }
            else
            {//assume filename
                static STQueryCell QueryCell;
                QueryCell.pData     = reinterpret_cast<void *>(argv[3]);
                QueryCell.eOperator = eST_OP_EQUAL;
                QueryCell.iCell     = iST_CELL_FILE;
                QueryCell.dbType    = DBTYPE_WSTR;
                QueryCell.cbSize    = 0;

		        hr = pISTDisp->GetTable(wszDatabase, wszTable, &QueryCell, reinterpret_cast<void *>(&one), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
            }
		    goto_on_bad_hr( hr, Cleanup );


            for(int i=0;;i++)
            {
                if(FAILED(PrintRow1(pISimpleTableRead2, i)))
				    break;
			    wprintf(L"\n");
            }
            break;
        }
        case 5:
        {
            //[-i:value,value,,,value|u:row,value,value,value,,value|d:row]
            static STQueryCell QueryCell;
            QueryCell.pData     = reinterpret_cast<void *>(argv[3]);
            QueryCell.eOperator = eST_OP_EQUAL;
            QueryCell.iCell     = iST_CELL_FILE;
            QueryCell.dbType    = DBTYPE_WSTR;
            QueryCell.cbSize    = 0;

            fTable = fST_LOS_READWRITE;
		    if(FAILED(hr = pISTDisp->GetTable(wszDatabase, wszTable, &QueryCell, reinterpret_cast<void *>(&one), eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableWrite2)))
                break;

            wchar_t *pszWrite = argv[4];
            unsigned long cWrites=0;
            LPWSTR  apszWrite[99];//we support up to 99 writes

            wchar_t *token = wcstok(pszWrite, L"-|");//look past the '-'
            //This breaks thing into chunks
            while(0 != token)
            {
                apszWrite[cWrites] = token;
                cWrites++;
                token = wcstok( NULL, L"|");
            }


            wchar_t *pAction;
            wchar_t *pRow;
            wchar_t *pColumn;
            wchar_t *pValue;

            DWORD dwNumRows, dwNumColumns;
            if(FAILED(hr = pISimpleTableWrite2->GetTableMeta(0, 0, &dwNumRows, &dwNumColumns)))
                break;

            ULONG  * acbSize   = new ULONG[dwNumColumns];
//            ULONG  * aiColumns = new ULONG[dwNumColumns];
            LPVOID * apvValue  = new LPVOID[dwNumColumns];
            LPWSTR * apszValue = new LPWSTR[dwNumColumns];
            if(0 == apszValue || 0 == apvValue || 0 == acbSize)
                break;

            for(unsigned int iWrite=0; iWrite<cWrites; ++iWrite)
            {
                token = wcstok(apszWrite[iWrite], L":");//look past the '-'
                if(token != NULL)
                {
                    switch(token[0])
                    {
                    case L'i':
                        {
                            ULONG iWriteRow;
                            if(FAILED(hr = pISimpleTableWrite2->AddRowForInsert(&iWriteRow)))
                                break;
                            unsigned long cColumnsToSet=0;

                            token = wcstok(NULL, L",");
                            while(token != NULL && cColumnsToSet<(dwNumColumns-1))
                            {
                                apszValue[cColumnsToSet] = token;
                                ++cColumnsToSet;
                                token = wcstok( NULL, L",");
                            }
                            for(unsigned long iColumn=0; iColumn<cColumnsToSet ;++iColumn)
                            {
                                SimpleColumnMeta meta;
                                if(FAILED(hr = pISimpleTableWrite2->GetColumnMetas(1, &iColumn, &meta )))break;

                                switch(meta.dbType)
                                {
                                case DBTYPE_GUID:
                                    wprintf(L"Unsupported datatype for writing.\n");
                                    break;
                                case DBTYPE_WSTR:
                                    apvValue[iColumn] = apszValue[iColumn];
                                    acbSize[iColumn]  = (wcslen(apszValue[iColumn])+1)*sizeof(WCHAR);
                                    break;
                                case DBTYPE_UI4:
                                    {
                                        unsigned long *pui4 = new unsigned long;//screw the memory leak
                                        if(0 == pui4)
                                            break;
                                        *pui4 = wcstol(apszValue[iColumn], 0, 10);
                                        apvValue[iColumn] = pui4;
                                        acbSize[iColumn]  = sizeof(unsigned long);
                                    }
                                    break;
                                case DBTYPE_BYTES:
                                    wprintf(L"Unsupported datatype for writing.\n");
                                    break;
                                default:
                                    wprintf(L"Unsupported datatype for writing.\n");
                                    break;
                                }
                            }
                            if(FAILED(hr = pISimpleTableWrite2->SetWriteColumnValues(iWriteRow, cColumnsToSet, 0, acbSize, apvValue)))break;
                        }
                        break;
                    case L'u':
                        {
                            token = wcstok(NULL, L",");
                            if(token == NULL)
                                break;

                            ULONG iReadRow = wcstol(token, 0, 10);
                            ULONG iWriteRow;
                            if(FAILED(hr = pISimpleTableWrite2->AddRowForUpdate(iReadRow, &iWriteRow)))
                                break;
                            unsigned long cColumnsToSet=0;

                            token = wcstok(NULL, L",");
                            while(token != NULL && cColumnsToSet<(dwNumColumns-1))
                            {
                                apszValue[cColumnsToSet] = token;
                                ++cColumnsToSet;
                                token = wcstok( NULL, L",");
                            }
                            for(unsigned long iColumn=0; iColumn<cColumnsToSet ;++iColumn)
                            {
                                SimpleColumnMeta meta;
                                if(FAILED(hr = pISimpleTableWrite2->GetColumnMetas(1, &iColumn, &meta )))break;

                                switch(meta.dbType)
                                {
                                case DBTYPE_GUID:
                                    wprintf(L"Unsupported datatype for writing.\n");
                                    break;
                                case DBTYPE_WSTR:
                                    apvValue[iColumn] = apszValue[iColumn];
                                    acbSize[iColumn]  = (wcslen(apszValue[iColumn])+1)*sizeof(WCHAR);
                                    break;
                                case DBTYPE_UI4:
                                    {
                                        unsigned long *pui4 = new unsigned long;//screw the memory leak
                                        *pui4 = wcstol(apszValue[iColumn], 0, 10);
                                        apvValue[iColumn] = pui4;
                                        acbSize[iColumn]  = sizeof(unsigned long);
                                    }
                                    break;
                                case DBTYPE_BYTES:
                                    wprintf(L"Unsupported datatype for writing.\n");
                                    break;
                                default:
                                    wprintf(L"Unsupported datatype for writing.\n");
                                    break;
                                }
                            }
                            if(FAILED(hr = pISimpleTableWrite2->SetWriteColumnValues(iWriteRow, cColumnsToSet, 0, acbSize, apvValue)))break;
                        }
                        break;
                    case L'd':
                        {
                            token = wcstok( NULL, L",");
                            ULONG iReadRow = wcstol(token, 0, 10);
                            if(FAILED(hr = pISimpleTableWrite2->AddRowForDelete(iReadRow)))
                                break;
                        }
                        break;
                    default:
                        continue;
                    }//switch
                }//if(token != NULL)
            }//for(iWrite
            if(FAILED(hr = pISimpleTableWrite2->UpdateStore()))
                break;
            break;
        }
        default:
        {
		    hr = pISTDisp->GetTable(wszDatabase, wszTable, 0, 0, eST_QUERYFORMAT_CELLS, fTable, (void**)&pISimpleTableRead2 );
		    goto_on_bad_hr( hr, Cleanup );


            for(int i=0;;i++)
            {
                if(FAILED(PrintRow1(pISimpleTableRead2, i)))
				    break;
			    wprintf(L"\n");
            }
        }
	} //else
Cleanup:

	if ( pISTDisp )
		pISTDisp->Release();

	if ( pISimpleTableRead2 )
		pISimpleTableRead2->Release();

	if ( pISimpleTableWrite2 )
		pISimpleTableWrite2->Release();

	if ( pAdvanced )
		pAdvanced->Release();

	
	CoUninitialize();

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\stconsumer\stconsumer.cpp ===
// STConsumer.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f STConsumerps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "STConsumer.h"

#include "STConsumer_i.c"
#include "Consumer.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_Consumer, CConsumer)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_STCONSUMERLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\simpletest\rk_ev.cpp ===
//  12/04/98
	//if trailing back slash exists in lpData, remove it
	//fix for darwin setup problem

//	04/11/00
	//Added new cmd line parsing and the ability to specify that path names
	//	will be returned in the short form.
	//The following switched are now available:
	//	/hkey:		-	Name of registry key.
	//	/subkey:	-	Name of registry sub key.
	//	/value:		-	Value of the registry key.
	//	/varname:	-	Name of environment variable you would like to create.
	//	/batname:	-	Name of batch file to generate.
	//  /short		-	If you are requesting a file name, convert to short form.


#include <windows.h>
#include <winreg.h>
#include <stdio.h>

int _cdecl main( int argc, char * argv []) 
{
	LONG	stat = 0;
	HKEY	phkResult = NULL;
	HKEY	hKey = NULL;
	BYTE	*lpPath = NULL;
	BYTE	lpLongPath[256];
	BYTE	lpShortPath[256];
	DWORD	lpcbLongPath = sizeof( lpLongPath );
	DWORD	lpcbShortPath = sizeof( lpShortPath );
	DWORD	lpType = 0;
	char	*lastBS = NULL;
	char	*ptrHKey,
			*ptrSubKey,
			*ptrValue,
			*ptrEnvVarName,
			*ptrBatName;
	BOOL	bNewFile = FALSE;

	//	04/11/00
	//Junk below removed... new stuff follows...
	/*	
	if( argc != 6 )
	{
		cout << "Syntax:\n";
		cout << "RKtoEnVar <RegKey> <subkey> <key> <environment var name> <bat name>";
		return -1;
	}
	
	ptrHKey = argv[1];
	ptrSubKey = argv[2];
	ptrValue = argv[3];
	ptrEnvVarName = argv[4];
	ptrBatName = argv[5];

	if( strcmp( ptrHKey, "HKLM" ) == 0)
		hKey = HKEY_LOCAL_MACHINE;
	else if( strcmp( ptrHKey, "HKCU" ) == 0 )
		hKey = HKEY_CURRENT_USER;
	else if( strcmp( ptrHKey, "HKUR" ) == 0 )
		hKey = HKEY_USERS;
	else if( strcmp( ptrHKey, "HKCR" ) == 0 )
		hKey = HKEY_CLASSES_ROOT;
	else
	{
		cout << "First param must be:\nHKLM\nHKCU\nHKUR\nHKCR\n";
		return -1;
	}
	*/

	//	04/11/00
	//New cmd line parsing routine
	for(int index=1; index<argc; index++){
		if(strncmp(_strupr(argv[index]), "/HKEY:", 6)==0){
			ptrHKey = argv[index]+6*sizeof(BYTE);
			if( strcmp( ptrHKey, "HKLM" ) == 0)
				hKey = HKEY_LOCAL_MACHINE;
			else if( strcmp( ptrHKey, "HKCU" ) == 0 )
				hKey = HKEY_CURRENT_USER;
			else if( strcmp( ptrHKey, "HKUR" ) == 0 )
				hKey = HKEY_USERS;
			else if( strcmp( ptrHKey, "HKCR" ) == 0 )
				hKey = HKEY_CLASSES_ROOT;
			else
			{
				printf("/HKEY must be:\nHKLM\nHKCU\nHKUR\nHKCR\n");
				return -1;
			}
		}
		else if(strncmp(_strupr(argv[index]), "/SUBKEY:", 8)==0){
			ptrSubKey = argv[index]+8*sizeof(BYTE);
		}
		else if(strncmp(_strupr(argv[index]), "/VALUE:", 7)==0){
			ptrValue = argv[index]+7*sizeof(BYTE);
		}
		else if(strncmp(_strupr(argv[index]), "/VARNAME:", 9)==0){
			ptrEnvVarName = argv[index]+9*sizeof(BYTE);
		}
		else if(strncmp(_strupr(argv[index]), "/BATNAME:", 9)==0){
			ptrBatName = argv[index]+9*sizeof(BYTE);
		}
		else if(strncmp(_strupr(argv[index]), "/NEWFILE", 6)==0){
			bNewFile=TRUE;
		}
		else if(strncmp(_strupr(argv[index]), "/?", 2)==0){
			printf("\n\n/hkey:    - <required> Name of registry key.\n");
			printf("/subkey:  - <required> Name of registry sub key.\n");
			printf("/value:   - <required> Value of the registry key.\n");
			printf("/varname: - <required> Name of environment variable you would like to create.\n");
			printf("/batname: - <required> Name of batch file to generate.\n");
			printf("/newfile  - <optional> Create a new file (default is append)\n\n");
			return 0;
		}
		//revert to old method
		else{
			printf("\n\nUsing old style syntax.\n");
			printf("/? for new syntax.\n\n");
			if( argc != 6 )
			{
				printf("Old style syntax:\n");
				printf("RKtoEnVar <RegKey> <subkey> <key> <environment var name> <bat name>\n");
				return -1;
			}
			
			ptrHKey = argv[1];
			ptrSubKey = argv[2];
			ptrValue = argv[3];
			ptrEnvVarName = argv[4];
			ptrBatName = argv[5];

			if( strcmp( ptrHKey, "HKLM" ) == 0)
				hKey = HKEY_LOCAL_MACHINE;
			else if( strcmp( ptrHKey, "HKCU" ) == 0 )
				hKey = HKEY_CURRENT_USER;
			else if( strcmp( ptrHKey, "HKUR" ) == 0 )
				hKey = HKEY_USERS;
			else if( strcmp( ptrHKey, "HKCR" ) == 0 )
				hKey = HKEY_CLASSES_ROOT;
			else
			{
				printf("First param must be:\nHKLM\nHKCU\nHKUR\nHKCR\n");
				return -1;
			}
			index = argc;
		}
	}
	/////////////////////////////////////////////////////////////////

	stat = RegOpenKeyEx( 
		hKey,				// handle of open key 
		ptrSubKey,			// address of name of subkey to open 
		0,					// reserved, must be zero
		KEY_QUERY_VALUE,	// security access mask 
		&phkResult );		// address of handle of open key
 
	if( stat != ERROR_SUCCESS ){
		printf("RegOpenKey failed for %s\n", ptrSubKey);
		printf("Error: %d \n",stat);
		return -1;
	}

	stat = RegQueryValueEx( 
		phkResult,			// handle of key to query 
		ptrValue,			// address of name of value to query 
		NULL,				// always NULL
		&lpType,			// address of buffer for value type 
		lpLongPath,				// address of data buffer 
		&lpcbLongPath );		// address of data buffer size 
 
	if( stat != ERROR_SUCCESS ){
		printf("RegQueryKey failed for %s\n", ptrValue);
		printf("Error: %d \n",stat);
		return -1;
	}

	//  12/04/98
	//if trailing back slash exists in lpData, remove it
	//fix for darwin setup problem
	lastBS = strrchr( (char*)lpLongPath, '\\');
	if(lastBS != NULL){
		if(*(lastBS + sizeof(BYTE)) == '\0')
		{
			*lastBS = '\0';
		}
	}

	FILE *flPtr;
	if(bNewFile)
	{
		flPtr = fopen( ptrBatName, "w" );
	}
	else
	{
		flPtr = fopen( ptrBatName, "a" );
		fseek( flPtr, 0, SEEK_END);
	}

	fprintf( flPtr, "SET %s=%s\n", ptrEnvVarName, (char*)lpLongPath);
	fclose(flPtr);

 	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\stconsumer\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8EDF3E3A_71B3_4F9E_A157_E8188FEAA6F8__INCLUDED_)
#define AFX_STDAFX_H__8EDF3E3A_71B3_4F9E_A157_E8188FEAA6F8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8EDF3E3A_71B3_4F9E_A157_E8188FEAA6F8__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\stest\stest.cpp ===
// STEST

#define UNICODE
#define _UNICODE
#include "stdio.h"
#include "conio.h"
#include <objbase.h>

#include "catmacros.h"
#include "catalog.h"
#include "catmeta.h"
#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif

inline void __stdcall Assert(unsigned short const *,unsigned short const *,int){}

// -----------------------------------------------------------------------
// Command-line globals:

// Static sizes:
#define cwchGUID                40                              // Count of characters necessary for a GUID.
#define cwchmaxCOLUMNNAME       256                             // Maximum count of characters per column name supported by stest.
#define cmaxCELLS               10                              // Maximum query cells supported by stest.
#define cmaxCHANGES             20                              // Maximum write changes supported by stest.
#define cmaxUI4S                200                             // Maximum UI4s in query and changes supported by stest.

// Command-line argument flags:
#define fARG_VIEW               0x00000001                      // View action specified.
#define fARG_WRITE              0x00000002                      // Write action specified.
#define fARG_HELP               0x00000004                      // Help action specified.
#define maskARG_ACTIONS         0x000C0007                      // Action specified (mask).
#define fARG_DATABASE           0x00000100                      // Database argument specified.
#define fARG_TABLE              0x00000200                      // Table argument specified.
#define fARG_COLUMNS            0x00000400                      // Columns argument specified.
#define fARG_NAMECOLUMN         0x00000800                      // Name column specified.
#define fARG_QUERY              0x00002000                      // Query specified.
#define fARG_PRODUCT            0x00004000                      // Product specified.
#define fARG_LOS                0x00008000                      // Level of service specified.
#define fARG_CHANGES            0x00010000                      // Changes specified.
#define fARG_POWERCHANGE        0x00020000                      // Power change specified.
#define fARG_POPULATE           0x00040000                      // Populate only, this is useful for perf testing and stepping through the code
#define fARG_TEST1              0x00080000                      // GetRowIndexBySearch test - walks the rows seqentially, then compares the results to GetRowIndexBySearch


// Command-line parse options:
#define fPARSE_ACTION           0x00000001                      // Argument specifies an action.
#define fPARSE_VALUE            0x00000002                      // Argument specifies a value.
#define fPARSE_VIEWREQ          0x10000000                      // Argument required for viewing.
#define fPARSE_WRITEREQ         0x20000000                      // Argument required for writing.
#define fPARSE_VIEWOPT          0x01000000                      // Argument optional for viewing.
#define fPARSE_WRITEOPT         0x02000000                      // Argument optional for writing.
#define fPARSE_CHANGES          0x00100000                      // Argument is a change and may be repeated.

// Command-line global variables:
DWORD   g_fArgs                     = 0;                        // Specified command-line arguments.
LPWSTR  g_wszDatabase               = NULL;                     // Specified database.
LPWSTR  g_wszTable                  = NULL;                     // Specified table.
LPWSTR  g_wszQuery                  = NULL;                     // Specified query.
LPWSTR  g_wszColumns                = NULL;                     // Specified columns.
ULONG*  g_aiColumns                 = NULL;                     // Specified column indexes.
ULONG   g_ciColumns                 = 0;                        // Specified column indexes count.
LPWSTR  g_wszProduct                = NULL;                     // Specified product.
LPWSTR  g_wszLOS                    = 0;                        // Specified level of service string.
DWORD   g_fLOS                      = 0;                        // Specified level of service.
LPWSTR  g_awszChanges [cmaxCHANGES];                            // Specified changes.
DWORD   g_aeChangeTypes [cmaxCHANGES];                          // Specified change types.
ULONG   g_cChanges                  = 0;                        // Count of changes.
LPWSTR  g_wszIndexName              = NULL;                     // IndexName for test1

// Command-line parse array:
struct {
    LPWSTR  wszArg;
    LPWSTR* pwszValue;
    DWORD   fArg;
    DWORD   fParse;
    LPWSTR  wszHelp;
    
} g_aParse [] = {
     L"/?",         NULL,               fARG_HELP,          fPARSE_ACTION,                                      L"Display help"
    ,L"/view",      NULL,               fARG_VIEW,          fPARSE_ACTION,                                      L"View the requested contents"
    ,L"/write",     NULL,               fARG_WRITE,         fPARSE_ACTION,                                      L"Write the requested changes"
    ,L"/d:",        &g_wszDatabase,     fARG_DATABASE,      fPARSE_VALUE | fPARSE_VIEWREQ | fPARSE_WRITEREQ,    L"The virtual database (eg: meta)"
    ,L"/t:",        &g_wszTable,        fARG_TABLE,         fPARSE_VALUE | fPARSE_VIEWREQ | fPARSE_WRITEREQ,    L"The table name (eg: tablemeta)"
    ,L"/c:",        &g_wszColumns,      fARG_COLUMNS,       fPARSE_VALUE | fPARSE_VIEWOPT,                      L"The subset of columns (eg: database,metaflags)"
    ,L"/q:",        &g_wszQuery,        fARG_QUERY,         fPARSE_VALUE | fPARSE_VIEWOPT | fPARSE_WRITEOPT,    L"The query (eg: database=meta,internalname=tagmeta)"
    ,L"/p:",        &g_wszProduct,      fARG_PRODUCT,       fPARSE_VALUE | fPARSE_VIEWOPT | fPARSE_WRITEOPT,    L"The product name (eg: urt)"
    ,L"/los:",      &g_wszLOS,          fARG_LOS,           fPARSE_VALUE | fPARSE_VIEWOPT | fPARSE_WRITEOPT,    L"The level-of-service request (eg: nomerge,readwrite)"
    ,L"/delete:",   g_awszChanges,      fARG_CHANGES,       fPARSE_VALUE | fPARSE_WRITEOPT | fPARSE_CHANGES,    L"A row to delete (eg: extension=.asp)"
    ,L"/update:",   g_awszChanges,      fARG_CHANGES,       fPARSE_VALUE | fPARSE_WRITEOPT | fPARSE_CHANGES,    L"A row to update (eg: extension=.asp,executable=asp.dll)"
    ,L"/insert:",   g_awszChanges,      fARG_CHANGES,       fPARSE_VALUE | fPARSE_WRITEOPT | fPARSE_CHANGES,    L"A row to insert (eg: extension=.asp,executable=asp.dll,cmd=add)"
    ,L"/deleteall", NULL,               fARG_POWERCHANGE,   fPARSE_VALUE | fPARSE_WRITEOPT,                     L"Delete all rows matching query"
    ,L"/updateall:",NULL,               fARG_POWERCHANGE,   fPARSE_VALUE | fPARSE_WRITEOPT,                     L"Update all rows matching query (eg: executable=xxx.dll,cmd=add)"
    ,L"/populate",  NULL,               fARG_POPULATE,      fPARSE_ACTION,                                      L"Populate only, useful for perf testing."
    ,L"/test1:",    &g_wszIndexName,    fARG_TEST1,         fPARSE_ACTION | fPARSE_VALUE,                       L"GetRowIndexBySearch test - compares sequential to searched rows"
};

// Level of service string to flag map:
struct {
    LPWSTR  wszLOS;
    DWORD   fLOS;
} g_amapLOS [] = { 
     L"configwork",     fST_LOS_CONFIGWORK
    ,L"readwrite",      fST_LOS_READWRITE
    ,L"unpopulated",    fST_LOS_UNPOPULATED
    ,L"repopulate",     fST_LOS_REPOPULATE
    ,L"marshallable",   fST_LOS_MARSHALLABLE
    ,L"nologic",        fST_LOS_NOLOGIC
    ,L"cookdown",       fST_LOS_COOKDOWN
    ,L"nologic",        fST_LOS_NOLOGIC
    ,L"nomerge",        fST_LOS_NOMERGE
    ,L"nocacheing",     fST_LOS_NOCACHEING
    ,L"nocache",        fST_LOS_NOCACHEING
#ifdef fST_LOS_EXTENDEDSCHEMA
    ,L"extendedschema", fST_LOS_EXTENDEDSCHEMA
#endif
    ,L"nologging",      fST_LOS_NO_LOGGING
};

// -----------------------------------------------------------------------
// Other globals:

// Global table variables:
ISimpleTableDispenser2* g_pISTDisp              = NULL;         // Table dispenser.
ISimpleTableRead2*      g_pISTDatabaseMeta      = NULL;         // Database meta table.
void**                  g_apvDatabaseMetaValues = NULL;         // Database meta values.
ULONG                   g_cDatabaseMetaValues   = 0;            // Database meta count of values.
ISimpleTableRead2*      g_pISTTableMeta         = NULL;         // Table meta table.
void**                  g_apvTableMetaValues    = NULL;         // Table meta values.
ULONG                   g_cTableMetaValues      = 0;            // Table meta count of values.
ISimpleTableRead2*      g_pISTColumnMeta        = NULL;         // Column meta table.
void**                  g_apvColumnMetaValues   = NULL;         // Column meta values.
ULONG                   g_cColumnMetaValues     = 0;            // Column meta count of values.
ISimpleTableRead2*      g_pISTTagMeta           = NULL;         // Tag meta table.
void**                  g_apvTagMetaValues      = NULL;         // Tag meta values.
ULONG                   g_cTagMetaValues        = 0;            // Tag meta count of values.
ULONG*                  g_aiTagColumns          = NULL;         // Tag meta column indexes.
STQueryCell             g_aCells [cmaxCELLS];                   // Query cell array.
ULONG                   g_cCells                = 0;            // Query cell count.
ULONG                   g_aUI4s [cmaxUI4S];                     // UI4 array.
ULONG                   g_cUI4s                 = 0;            // UI4 count.
void**                  g_apvChanges            = NULL;         // Changes array.
ULONG*                  g_apChangeSizes         = NULL;         // Changes array.
ULONG*                  g_aiPKs                 = NULL;         // Primary key array.
ULONG                   g_cPKs                  = 0;            // Primary key count.

// Function declarations:
HRESULT Test1();
HRESULT CommandLineParse            (int argc, char *argv[], char *envp[]);
void    CommandLineHelp             (void);
HRESULT ObtainMetaAndFinishParsing  ();
HRESULT ViewContent                 ();
HRESULT WriteChanges                ();
HRESULT ObtainTable                 (LPWSTR i_wszDatabase, LPWSTR i_wszTable, STQueryCell* i_acells, ULONG i_cMeta, DWORD i_fLOS, void** o_ppv, ULONG* o_pcColumns, void*** o_papvValues, ULONG** o_pacbSizes);

// -----------------------------------------------------------------------
// main:
int __cdecl main (int argc, char *argv[], char *envp[])
{
    HRESULT     hr = S_OK;

    hr = CoInitialize (NULL);
    if (FAILED (hr)) return -1;

    hr = CommandLineParse (argc, argv, envp);
    if (FAILED (hr)) { wprintf (L"\nERROR: Initial command-line parsing failed.\n"); return -1; }

    if (!(g_fArgs & maskARG_ACTIONS) || (g_fArgs & fARG_HELP))
    {
        CommandLineHelp ();
        return 0;
    }

    hr = GetSimpleTableDispenser (g_wszProduct, 0, &g_pISTDisp);
    if (FAILED (hr)) { wprintf (L"\nERROR: Obtaining table dispenser failed.\n"); return -1; }

    hr = ObtainMetaAndFinishParsing ();
    if (FAILED (hr)) 
	{ 
		wprintf (L"\nERROR: Obtaining meta or finishing command-line parsing failed.\nhr=0x%08x\n", hr); 
		return -1; 
	}

    if (g_fArgs & fARG_POPULATE)
    {
        ISimpleTableRead2 * pISTRead2=0;
        DWORD dwTickCount = GetTickCount();
        hr = g_pISTDisp->GetTable (g_wszDatabase, g_wszTable, (g_fArgs & fARG_QUERY ? g_aCells : NULL), (g_fArgs & fARG_QUERY ? &g_cCells : NULL), eST_QUERYFORMAT_CELLS, g_fLOS, reinterpret_cast<void **>(&pISTRead2));
        if(pISTRead2)
            pISTRead2->Release();
        if (FAILED (hr))
        {
            wprintf (L"\nERROR: Populate cache failed with hr=0x%08x.\n", hr); return -1;
        }
        else
        {
            wprintf (L"\nSUCCESS: Populate cache succeeded.  Elapsed Time: %d\n", GetTickCount()-dwTickCount);
        }
    }
    if (g_fArgs & fARG_TEST1)
    {
        hr = Test1();
        if(FAILED(hr))
        {
            wprintf (L"\nERROR: Test1 failed with hr=0x%08x.\n", hr); return -1;
        }
        else
        {
            wprintf (L"\nTest1 PASSED\n", hr);
        }
    }
    if (g_fArgs & fARG_VIEW)
    {
        hr = ViewContent ();
        if (FAILED (hr)) 
		{ 
			wprintf (L"\nERROR: Viewing content failed.\n hr=0x%08x.\n", hr); 
			return -1; 
		}
    }
    else if (g_fArgs & fARG_WRITE)
    {
        hr = WriteChanges ();
        if (FAILED (hr)) 
		{ 
			wprintf (L"\nERROR: Writing changes failed.\nhr=0x%08x.\n", hr); 
			return -1; 
		}
    }

    CoUninitialize ();
    return 0;
}

HRESULT Test1()
{
    HRESULT hr;

    //First get the table as specified from the command line
    CComPtr<ISimpleTableRead2>  pISTRead2_NoIndexHint;
    if(FAILED(hr = g_pISTDisp->GetTable (g_wszDatabase, g_wszTable, (g_fArgs & fARG_QUERY ? g_aCells : NULL), (g_fArgs & fARG_QUERY ? &g_cCells : NULL), eST_QUERYFORMAT_CELLS, g_fLOS, reinterpret_cast<void **>(&pISTRead2_NoIndexHint))))return hr;

    tTABLEMETARow tablemeta;
    if(FAILED(hr = g_pISTTableMeta->GetColumnValues(0, cTABLEMETA_NumberOfColumns, 0, 0, reinterpret_cast<void **>(&tablemeta))))return hr;

    //Now get the IndexMeta that matches the table's InternalName and the IndexName passed in
    STQueryCell             acellsMeta[2];
    acellsMeta[0].pData        = tablemeta.pInternalName;
    acellsMeta[0].eOperator    = eST_OP_EQUAL;
    acellsMeta[0].iCell        = iINDEXMETA_Table;
    acellsMeta[0].dbType       = DBTYPE_WSTR;
    acellsMeta[0].cbSize       = 0;

    acellsMeta[1].pData        = g_wszIndexName;
    acellsMeta[1].eOperator    = eST_OP_EQUAL;
    acellsMeta[1].iCell        = iINDEXMETA_InternalName;
    acellsMeta[1].dbType       = DBTYPE_WSTR;
    acellsMeta[1].cbSize       = 0;

    ULONG two=2;
    CComPtr<ISimpleTableRead2>  pISTRead2_IndexMeta;
    if(FAILED(hr = g_pISTDisp->GetTable (wszDATABASE_META, wszTABLE_INDEXMETA, &acellsMeta, &two, eST_QUERYFORMAT_CELLS, 0, reinterpret_cast<void **>(&pISTRead2_IndexMeta))))return hr;

    //Now read the first row of the index meta - this will be the index that we will test.
    tINDEXMETARow indexmeta;
    if(FAILED(hr = pISTRead2_IndexMeta->GetColumnValues(0, cINDEXMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&indexmeta))))
    {
        wprintf(L"Couldn't get the IndexMeta for Table (%s) and IndexName (%s).  Make sure the index is defined in CatMeta.xml and Catalog.dll has this meta compiled into it.\n",tablemeta.pInternalName,g_wszIndexName);
        return hr;
    }

    //Now get the table useing the table's first Index as a hint in the query
    STQueryCell             aCells[cmaxCELLS];
    aCells[0].pData        = indexmeta.pInternalName;
    aCells[0].eOperator    = eST_OP_EQUAL;
    aCells[0].iCell        = iST_CELL_INDEXHINT;
    aCells[0].dbType       = DBTYPE_WSTR;
    aCells[0].cbSize       = 0;

    ULONG cCells=1;
    if(g_fArgs & fARG_QUERY)//if a query was specified on the command line, the prepend the index hint query
    {
        memcpy(&aCells[1], g_aCells, g_cCells * sizeof(STQueryCell)) ;
        cCells += g_cCells;
    }

    //Get the table using the Index hint
    CComPtr<ISimpleTableRead2>  pISTRead2_IndexHint;
    if(FAILED(hr = g_pISTDisp->GetTable (g_wszDatabase, g_wszTable, aCells, &cCells, eST_QUERYFORMAT_CELLS, g_fLOS, reinterpret_cast<void **>(&pISTRead2_IndexHint))))return hr;

    ULONG cIndexes;
    if(FAILED(hr = pISTRead2_IndexMeta->GetTableMeta(0, 0,  &cIndexes, 0)))return hr;

    TSmartPointerArray<ULONG> aiColumns = new ULONG [cIndexes];//This will hold the array of column indexes that define the search
    aiColumns[0] = *indexmeta.pColumnIndex;

    for(ULONG i=1;i<cIndexes;++i)
    {
        tINDEXMETARow indexmetaTemp;
        if(FAILED(hr = pISTRead2_IndexMeta->GetColumnValues(i, cINDEXMETA_NumberOfColumns, NULL, NULL, reinterpret_cast<void **>(&indexmetaTemp))))return hr;
        aiColumns[i] = *indexmetaTemp.pColumnIndex;
    }

    TSmartPointerArray<void *> apColumns = new void * [*tablemeta.pCountOfColumns];
    TSmartPointerArray<ULONG>  acbSizes  = new ULONG [*tablemeta.pCountOfColumns];//This will hold the array of column indexes that define the search

    for(ULONG iRow=0; ;++iRow)
    {
        //Get the row sequentially
        if(E_ST_NOMOREROWS == (hr=pISTRead2_NoIndexHint->GetColumnValues(iRow, *tablemeta.pCountOfColumns, NULL/*all columns*/, acbSizes, apColumns)))
            break;
        if(FAILED(hr))return hr;

        //No using the row values, get the row index by searching (no index hint)
        ULONG iRow_NoIndexHint;
        if(FAILED(hr = pISTRead2_NoIndexHint->GetRowIndexBySearch((*indexmeta.pMetaFlags & fINDEXMETA_UNIQUE) ? 0L : iRow, cIndexes, aiColumns, acbSizes, apColumns, &iRow_NoIndexHint)))return hr;

        if(iRow_NoIndexHint != iRow)
        {
            wprintf(L"Error - pISTRead_NoIndexHint->GetRowIndexBySearch returned a bogus row index.  Actual (%d), Expected (%d)\n", iRow_NoIndexHint, iRow);
        }

        ULONG iRow_IndexHint;
        if(FAILED(hr = pISTRead2_IndexHint->GetRowIndexBySearch((*indexmeta.pMetaFlags & fINDEXMETA_UNIQUE) ? 0L : iRow, cIndexes, aiColumns, acbSizes, apColumns, &iRow_IndexHint)))return hr;
        if(iRow_IndexHint != iRow)
        {
            wprintf(L"Error - pISTRead_IndexHint->GetRowIndexBySearch returned a bogus row index.  Actual (%d), Expected (%d)\n", iRow_IndexHint, iRow);
        }
    }
    return S_OK;
}

// -----------------------------------------------------------------------
// CommandLineParse:
HRESULT CommandLineParse (int argc, char *argv[], char *envp[])
{
    LPWSTR*                 awszArgs = NULL;                    // Unicode command-line arguments.
    LPWSTR                  wszArg;                             // Current argument string.
    int                     iArg, iParse, iLOS;
    int                     cParse = sizeof g_aParse / sizeof g_aParse [0];
    HRESULT                 hr = S_OK;

    memset (g_awszChanges, 0, cmaxCHANGES * sizeof (LPWSTR));
    memset (g_aeChangeTypes, 0, cmaxCHANGES * sizeof (DWORD));

// Allocate unicode string array:
    awszArgs = new LPWSTR [argc];
    if (NULL == awszArgs) { hr = E_FAIL; goto Cleanup; }
    memset (awszArgs, 0, argc * sizeof (LPWSTR));

// Parse arguments:
    for (iArg = 1; iArg < argc; iArg++)
    {
    // Allocate unicode string:
        SIZE_T cch = strlen (argv[iArg]);
        awszArgs[iArg] = new WCHAR [cch + 1];
        if (NULL == awszArgs[iArg]) { hr = E_FAIL; goto Cleanup; }

        wszArg = awszArgs[iArg];
        mbstowcs (wszArg, argv[iArg], strlen (argv[iArg]) + 1);

        if(wszArg[cch-1] == L'}')//if the last character is } then replace all { with < and all } with >
        {
            WCHAR * pch = wszArg;
            for(ULONG ich=0 ; ich < cch ; ++ich, ++pch)
            {
                if(*pch == L'{')
                    *pch = L'<';
                else if(*pch == L'}')
                    *pch = L'>';
            }
        }

        for (iParse = 0; iParse < cParse; iParse++)
        {
        // Action parsing:
            if (fPARSE_ACTION & g_aParse[iParse].fParse)
            {
                if (0 == _wcsnicmp (wszArg, g_aParse[iParse].wszArg, wcslen(g_aParse[iParse].wszArg)))
                {
                    if (g_fArgs & maskARG_ACTIONS) { hr = E_FAIL; goto Cleanup; }
                    g_fArgs |= g_aParse[iParse].fArg;
                }
            } 
        // Changes parsing:
            if (fPARSE_CHANGES & g_aParse[iParse].fParse)
            {
                if (0 == _wcsnicmp (wszArg, g_aParse[iParse].wszArg, wcslen (g_aParse[iParse].wszArg)))
                {
                // Parse change value:
                    if (g_cChanges > cmaxCHANGES) { hr = E_OUTOFMEMORY; goto Cleanup; }
                    g_aParse[iParse].pwszValue[g_cChanges] = new WCHAR [wcslen (wszArg) + 1];
                    if (NULL == g_aParse[iParse].pwszValue[g_cChanges]) { hr = E_FAIL; goto Cleanup; }
                    wcscpy (g_aParse[iParse].pwszValue[g_cChanges], wszArg + wcslen (g_aParse[iParse].wszArg));
                    g_fArgs |= g_aParse[iParse].fArg;
                // Parse change type:
                    if (0 == _wcsnicmp (L"/insert:", g_aParse[iParse].wszArg, wcslen (g_aParse[iParse].wszArg)))
                    {
                        g_aeChangeTypes [g_cChanges] = eST_ROW_INSERT;
                    }
                    else if (0 == _wcsnicmp (L"/delete:", g_aParse[iParse].wszArg, wcslen (g_aParse[iParse].wszArg)))
                    {
                        g_aeChangeTypes [g_cChanges] = eST_ROW_DELETE;
                    }
                    else if (0 == _wcsnicmp (L"/update:", g_aParse[iParse].wszArg, wcslen (g_aParse[iParse].wszArg)))
                    {
                        g_aeChangeTypes [g_cChanges] = eST_ROW_UPDATE;
                    }
                    g_cChanges++;
                }
            }
        // Value parsing:
            if (fPARSE_VALUE & g_aParse[iParse].fParse)
            {
                if (0 == _wcsnicmp (wszArg, g_aParse[iParse].wszArg, wcslen (g_aParse[iParse].wszArg)) && 0 == *(g_aParse[iParse].pwszValue))
                {
                    *(g_aParse[iParse].pwszValue) = new WCHAR [wcslen (wszArg) + 1];
                    if (NULL == *(g_aParse[iParse].pwszValue)) { hr = E_FAIL; goto Cleanup; }
                    wcscpy (*(g_aParse[iParse].pwszValue), wszArg + wcslen (g_aParse[iParse].wszArg));
                    g_fArgs |= g_aParse[iParse].fArg;
                }
            }
        // TODO: BUGBUG: Support /deleteall and /updateall:
        }
    }

    if (!g_wszProduct) g_wszProduct = WSZ_PRODUCT_NETFRAMEWORKV1; // ie: Default product if not specified.

// Finish level-of-service parsing:
    if (g_fArgs & fARG_LOS)
    {
        for (iLOS = 0; iLOS < sizeof g_amapLOS / sizeof g_amapLOS[0]; iLOS++)
        {
            if (wcsstr (g_wszLOS, g_amapLOS[iLOS].wszLOS))
            {
                g_fLOS |= g_amapLOS[iLOS].fLOS;
            }
        }
        g_fArgs |= fARG_LOS;
    }

// Verify expected arguments:
    if (g_fArgs & fARG_VIEW)
    {
        if (!(g_fArgs & (fARG_DATABASE | fARG_TABLE))) { hr = E_FAIL; goto Cleanup; }
    }
    else if (g_fArgs & fARG_WRITE)
    {
        if (!(g_fArgs & (fARG_DATABASE | fARG_TABLE))) { hr = E_FAIL; goto Cleanup; }
    }

Cleanup:
    if (awszArgs)
    {
        for (iArg = 0; iArg < argc; iArg++)
        {
            if (awszArgs[iArg])
            {
                delete [] (awszArgs[iArg]);
            }
        }
        delete [] awszArgs;
    }
    return hr;
}

// -----------------------------------------------------------------------
// CommandLineHelp:
void CommandLineHelp ()
{
    ULONG   cArgs = sizeof g_aParse / sizeof g_aParse [0];
    ULONG   iArg;

// Display examples:
    wprintf (L"\nSTEST HELP: (sorry, no spaces within an argument yet...)\n\n");
    wprintf (L"View examples:\n");
    wprintf (L"   stest /view /d:meta /t:tablemeta | more\n");
    wprintf (L"   stest /view /d:meta /t:columnmeta /q:table=tablemeta | more\n");
    wprintf (L"   stest /view /d:meta /t:tablemeta /c:database,publicname,metaflags\n");
    wprintf (L"   stest /view /d:urt /t:scriptmaps /q:file=c:\\foo\\sample.xml /los:nomerge\n");
    wprintf (L"\nWrite examples:\n");
    wprintf (L"   stest /write /d:urt /t:scriptmaps /q:file=c:\\foo\\sample.xml\n");
    wprintf (L"         /los:nomerge,readwrite /updateall:executable=xxx.dll\n");
    wprintf (L"   stest /write /d:urt /t:scriptmaps /q:file=c:\\foo\\sample.xml\n");
    wprintf (L"         /los:nomerge,readwrite /deleteall\n");
    wprintf (L"   stest /write /d:urt /t:scriptmaps /q:file=c:\\foo\\sample.xml\n");
    wprintf (L"         /los:nomerge,readwrite\n");
    wprintf (L"         /insert:extension=.asp,executable=asp.dll,directive=add\n");
    wprintf (L"         /insert:extension=.htx,executable=foo.dll,directive=addfinal\n");
    wprintf (L"         /delete:extension=.htm\n");

// Display action arguments:
    wprintf (L"\nActions:\n");
    for (iArg = 0; iArg < cArgs; iArg++)
    {
        if (g_aParse[iArg].fParse & fPARSE_ACTION)
        {
            wprintf (L"%12s \t%s\n",g_aParse[iArg].wszArg, g_aParse[iArg].wszHelp);
        }
    }

// Display required view arguments:
    wprintf (L"\n/view arguments (required):\n");
    for (iArg = 0; iArg < cArgs; iArg++)
    {
        if (g_aParse[iArg].fParse & fPARSE_VIEWREQ)
        {
            wprintf (L"%12s \t%s\n",g_aParse[iArg].wszArg, g_aParse[iArg].wszHelp);
        }
    }

// Display optional view arguments:
    wprintf (L"\n/view arguments (optional):\n");
    for (iArg = 0; iArg < cArgs; iArg++)
    {
        if (g_aParse[iArg].fParse & fPARSE_VIEWOPT)
        {
            wprintf (L"%12s \t%s\n",g_aParse[iArg].wszArg, g_aParse[iArg].wszHelp);
        }
    }

// Display required write arguments:
    wprintf (L"\n/write arguments (required):\n");
    for (iArg = 0; iArg < cArgs; iArg++)
    {
        if (g_aParse[iArg].fParse & fPARSE_WRITEREQ)
        {
            wprintf (L"%12s \t%s\n",g_aParse[iArg].wszArg, g_aParse[iArg].wszHelp);
        }
    }

// Display optional write arguments:
    wprintf (L"\n/write arguments (optional):\n");
    for (iArg = 0; iArg < cArgs; iArg++)
    {
        if (g_aParse[iArg].fParse & fPARSE_WRITEOPT)
        {
            wprintf (L"%12s \t%s\n",g_aParse[iArg].wszArg, g_aParse[iArg].wszHelp);
        }
    }
}

static unsigned char g_byArray[256][4096];//This is a hack so we can support writing to a DBTYPE_BYTES column (the column index MUST be 0-255, the size of the byte array written must not exceed 4096)

static unsigned char kWcharToNibble[128] = //0xff is an illegal value, the illegal values should be weeded out by the parser
{ //    0       1       2       3       4       5       6       7       8       9       a       b       c       d       e       f
/*00*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*10*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*20*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*30*/  0x0,    0x1,    0x2,    0x3,    0x4,    0x5,    0x6,    0x7,    0x8,    0x9,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*40*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*50*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*60*/  0xff,   0xa,    0xb,    0xc,    0xd,    0xe,    0xf,    0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
/*70*/  0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,   0xff,
};

// -----------------------------------------------------------------------
// ObtainMetaAndFinishParsing:
HRESULT ObtainMetaAndFinishParsing ()
{
    STQueryCell             acellsMeta [] = {   {NULL, eST_OP_EQUAL, ~0, DBTYPE_WSTR, 0},
                                                {NULL, eST_OP_EQUAL, ~0, DBTYPE_WSTR, 0}    };  // Meta query.
    ULONG                   iColumn, cColumns, iTag, cCells;
    WCHAR                   wszColumn [cwchmaxCOLUMNNAME];
    HRESULT                 hr = S_OK;

// Obtain database meta:
    //This kind of query isn't support right now (12/20/99) and g_pISTDatabaseMeta is not used anywhere so let's not get the DatabaseMeta table
    //@@@acellsMeta[0].pData = g_wszDatabase;
    //@@@acellsMeta[0].iCell = iDATABASEMETA_InternalName;
    //@@@hr = ObtainTable (wszDATABASE_META, wszTABLE_DATABASEMETA, acellsMeta, 1, 0, (void**) &g_pISTDatabaseMeta, &g_cDatabaseMetaValues, &g_apvDatabaseMetaValues, NULL);
    //@@@if (FAILED (hr)) return hr;

// Obtain table meta:   
    acellsMeta[0].pData = g_wszTable;
    acellsMeta[0].iCell = iTABLEMETA_InternalName;
    hr = ObtainTable (wszDATABASE_META, wszTABLE_TABLEMETA, acellsMeta, 1, g_fLOS & fST_LOS_EXTENDEDSCHEMA, (void**) &g_pISTTableMeta, &g_cTableMetaValues, &g_apvTableMetaValues, NULL);
    if (FAILED (hr)) return hr;
    cColumns = *((ULONG*) g_apvTableMetaValues[iTABLEMETA_CountOfColumns]);

// Obtain column meta:  
    acellsMeta[0].pData = g_wszTable;
    acellsMeta[0].iCell = iCOLUMNMETA_Table;
    hr = ObtainTable (wszDATABASE_META, wszTABLE_COLUMNMETA, acellsMeta, 1, g_fLOS & fST_LOS_EXTENDEDSCHEMA, (void**) &g_pISTColumnMeta, &g_cColumnMetaValues, &g_apvColumnMetaValues, NULL);
    if (FAILED (hr)) return hr;

// Obtain primary key columns:
    g_aiPKs = new ULONG [cColumns];
    for (iColumn = 0, g_cPKs = 0; ; iColumn++)
    {
        hr = g_pISTColumnMeta->GetColumnValues (iColumn, g_cColumnMetaValues, NULL, NULL, g_apvColumnMetaValues);
        if (E_ST_NOMOREROWS == hr)
        {
            break;
        }
        if (*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_PRIMARYKEY)
        {
            g_aiPKs [g_cPKs] = iColumn;
            g_cPKs++;
        }
    }

// Parse specified columns:
    if (g_fArgs & fARG_COLUMNS)
    {
        g_aiColumns = new ULONG [cColumns];
        if (NULL == g_aiColumns) return E_FAIL;
        for (iColumn = 0, g_ciColumns = 0; ; iColumn++)
        {
            hr = g_pISTColumnMeta->GetColumnValues (iColumn, g_cColumnMetaValues, NULL, NULL, g_apvColumnMetaValues);
            if (E_ST_NOMOREROWS == hr)
            {
                break;
            }
            if (wcslen ((LPWSTR) g_apvColumnMetaValues[iCOLUMNMETA_InternalName]) + 1 > cwchmaxCOLUMNNAME) { return -1; }
            wcscpy (wszColumn, (LPWSTR) g_apvColumnMetaValues[iCOLUMNMETA_InternalName]);
            if (wcsstr (g_wszColumns, _wcslwr (wszColumn)))
            {
                if (*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_NAMECOLUMN)
                {
                    g_fArgs |= fARG_NAMECOLUMN;
                }
                g_aiColumns [g_ciColumns] = iColumn;
                g_ciColumns++;
            }
        }
    }
    else
    {
        g_fArgs |= fARG_NAMECOLUMN;
    }

// Obtain tag meta: 
    acellsMeta[0].pData = g_wszTable;
    acellsMeta[0].iCell = iTAGMETA_Table;
    hr = ObtainTable (wszDATABASE_META, wszTABLE_TAGMETA, acellsMeta, 1, g_fLOS & fST_LOS_EXTENDEDSCHEMA, (void**) &g_pISTTagMeta, &g_cTagMetaValues, &g_apvTagMetaValues, NULL);
    if (FAILED (hr) && E_ST_NOMOREROWS != hr) return hr;

// Build tag column indexes:
    g_aiTagColumns = new ULONG [cColumns];
    if (NULL == g_aiTagColumns) return E_FAIL;
    memset (g_aiTagColumns, ~0, cColumns * sizeof (ULONG));
    for (iTag = 0, iColumn = ~0;; iTag++)
    {
        hr = g_pISTTagMeta->GetColumnValues (iTag, g_cTagMetaValues, NULL, NULL, g_apvTagMetaValues);
        if (E_ST_NOMOREROWS == hr)
        {
            break;
        }
        if (iColumn != *((ULONG*) g_apvTagMetaValues[iTAGMETA_ColumnIndex]))
        {
            iColumn = *((ULONG*) g_apvTagMetaValues[iTAGMETA_ColumnIndex]);
            g_aiTagColumns [iColumn] = iTag;
        }
    }

// Parse query:
    if (g_fArgs & fARG_QUERY)
    {
        LPWSTR      wszNextToken, wszDelimiter;
        ULONG       iCell;
        DWORD       dbType;

        for (wszNextToken = g_wszQuery, wszDelimiter = g_wszQuery, g_cCells = 0; wszDelimiter != NULL; wszNextToken = wszDelimiter + 1)
        {
        // Parse cell name:
            wszDelimiter = wcschr (wszNextToken, L'='); // TODO: Support other operators...
            if (!wszDelimiter) return E_INVALIDARG;
            *wszDelimiter = L'\0';
            for (iColumn = 0; ; iColumn++)
            {
            // Match cell name:
                hr = g_pISTColumnMeta->GetColumnValues (iColumn, g_cColumnMetaValues, NULL, NULL, g_apvColumnMetaValues);
                if (E_ST_NOMOREROWS == hr) // ie: No more columns to match: try reserved cells:
                {
                    if (0 == _wcsicmp (L"file", wszNextToken))
                    {
                        iCell       = iST_CELL_FILE;
                        dbType      = DBTYPE_WSTR;
                    }
                    else if (0 == _wcsicmp (L"location", wszNextToken))
                    {
                        iCell       = iST_CELL_LOCATION;
                        dbType      = DBTYPE_WSTR;
                    }
                    else
                    {
                        return E_INVALIDARG;
                    }
                }
                else // ie: More columns to match:
                {
                    if (0 == _wcsicmp ((LPWSTR) g_apvColumnMetaValues[iCOLUMNMETA_InternalName], wszNextToken))
                    {
                        iCell       = iColumn;
                        dbType      = *((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_Type]);
                    }
                    else
                    {
                        continue;
                    }
                }
            // Parse the cell value:
                wszNextToken = wszDelimiter + 1;
                wszDelimiter = wcschr (wszNextToken, L',');
                if (!wszDelimiter)
                {
                    if (wszNextToken == wszDelimiter) return E_INVALIDARG; // TODO: Support NULL...
                }
                else
                {
                    *wszDelimiter = L'\0';
                }
            // Convert the cell value:
                switch (dbType)
                {
                    case DBTYPE_WSTR:
                        g_aCells [g_cCells].iCell       = iCell;
                        g_aCells [g_cCells].eOperator   = eST_OP_EQUAL;
                        g_aCells [g_cCells].pData       = wszNextToken;
                        g_aCells [g_cCells].dbType      = DBTYPE_WSTR;
                    break;
                    case DBTYPE_UI4:
                        if (dbType & (fCOLUMNMETA_BOOL | fCOLUMNMETA_ENUM | fCOLUMNMETA_FLAG))
                        {
                            return E_NOTIMPL; // TODO: Support these types...
                        }
                        g_aUI4s[g_cUI4s] = _wtol (wszNextToken);
                        g_aCells [g_cCells].iCell       = iCell;
                        g_aCells [g_cCells].eOperator   = eST_OP_EQUAL;
                        g_aCells [g_cCells].pData       = &(g_aUI4s[g_cUI4s]);
                        g_aCells [g_cCells].dbType      = DBTYPE_UI4;
                        g_cUI4s++;
                        if (cmaxUI4S == g_cUI4s) return E_UNEXPECTED;
                    break;
                    default:
                    return E_NOTIMPL; // TODO: Support other types...
                }
                g_cCells++;
                if (cmaxCELLS == g_cCells) return E_UNEXPECTED;
                break;
            }
        }
    }

// Parse changes:
    if (g_fArgs & fARG_CHANGES)
    {
        LPWSTR      wszNextToken, wszDelimiter;
        DWORD       dbType;
        ULONG       iChange;

        g_apvChanges     = new LPVOID [cColumns * g_cChanges];
        g_apChangeSizes  = new ULONG  [cColumns * g_cChanges];
        memset(g_apChangeSizes, 0x00, (cColumns * g_cChanges)*sizeof(ULONG));

        if (NULL == g_apvChanges) return E_FAIL;
        memset (g_apvChanges, 0, cColumns * g_cChanges * sizeof (LPVOID));

        for (iChange = 0, wszNextToken = g_awszChanges[iChange]; iChange < g_cChanges; iChange++, wszNextToken = g_awszChanges[iChange]) // ie: Each change:
        {
            for (wszDelimiter = wszNextToken; wszDelimiter != NULL; wszNextToken = wszDelimiter + 1) // ie: Each column set in this change:
            {
            // Parse column name:
                wszDelimiter = wcschr (wszNextToken, L'=');
                if (!wszDelimiter) return E_INVALIDARG;
                *wszDelimiter = L'\0';
                for (iColumn = 0; ; iColumn++) // ie: Each known column:
                {
                // Match column name:
                    hr = g_pISTColumnMeta->GetColumnValues (iColumn, g_cColumnMetaValues, NULL, NULL, g_apvColumnMetaValues);
                    if (E_ST_NOMOREROWS == hr) // ie: No more columns to match:
                    {
                            return E_INVALIDARG;
                    }
                    else // ie: More columns to match:
                    {
                        if (0 == _wcsicmp ((LPWSTR) g_apvColumnMetaValues[iCOLUMNMETA_InternalName], wszNextToken))
                        {
                            dbType = *((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_Type]);
                        }
                        else
                        {
                            continue;
                        }
                    }
                // Parse column value:
                    wszNextToken = wszDelimiter + 1;
                    wszDelimiter = wcschr (wszNextToken, L',');
                    if (!wszDelimiter)
                    {
                        if (wszNextToken == wszDelimiter) return E_INVALIDARG; // TODO: Support NULL...
                    }
                    else
                    {
                        *wszDelimiter = L'\0';
                    }
                // Convert the column value:
                    switch (dbType)
                    {
                        case DBTYPE_WSTR:
                            g_apvChanges [iColumn + (iChange * cColumns)] = wszNextToken;
                        break;
                        case DBTYPE_UI4:
                            if (*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_ENUM)
                            {
                                for (iTag = g_aiTagColumns [iColumn]; ; iTag++)
                                {
                                    hr = g_pISTTagMeta->GetColumnValues (iTag, g_cTagMetaValues, NULL, NULL, g_apvTagMetaValues);
                                    if (E_ST_NOMOREROWS == hr || *((ULONG*)g_apvTagMetaValues[iTAGMETA_ColumnIndex]) != iColumn)
                                    {
                                        return E_UNEXPECTED;
                                    }
                                    if (FAILED (hr)) return hr;
                                    if (0 == _wcsicmp (wszNextToken, (LPWSTR)g_apvTagMetaValues[iTAGMETA_InternalName]))
                                    {
                                        g_aUI4s[g_cUI4s] = *((ULONG*)g_apvTagMetaValues[iTAGMETA_Value]);
                                        break;
                                    }
                                }
                            }
                            else if (*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_BOOL)
                            {
                                static WCHAR * kwszBoolStringsCaseInsensitive[] = {L"false", L"true", L"0", L"1", L"no", L"yes", L"off", L"on", 0};
								static WCHAR * kwszBoolStringsCaseSensitive[]   = {L"false", L"true", 0};

								ULONG iBoolString;
								WCHAR ** wszBoolStrings = kwszBoolStringsCaseSensitive;
								if(*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_CASEINSENSITIVE)
								{
									wszBoolStrings = kwszBoolStringsCaseInsensitive;
									for(iBoolString=0; 0 != wszBoolStrings[iBoolString] && 0 != _wcsicmp(wszNextToken, wszBoolStrings[iBoolString]); ++iBoolString);
								}
								else
								{
                                   for(iBoolString=0; 0 != wszBoolStrings[iBoolString] && 0 != wcscmp(wszNextToken, wszBoolStrings[iBoolString]); ++iBoolString);
								}
                                if(0 == wszBoolStrings[iBoolString])
                                    return E_ST_VALUEINVALID;
                                g_aUI4s[g_cUI4s] = (iBoolString & 0x01);//The odd indexes are true, the evens are false
                            }
                            else
                            {
                                g_aUI4s[g_cUI4s] = _wtol (wszNextToken);
                            }
                            g_apvChanges [iColumn + (iChange * cColumns)] = &(g_aUI4s[g_cUI4s]);
                            g_cUI4s++;
                            if (cmaxUI4S == g_cUI4s) return E_UNEXPECTED;
                        break;
                        case DBTYPE_BYTES:
                        {
                            LPCWSTR         pwchar  = wszNextToken;
                            unsigned char * pbyte   = g_byArray[iColumn];
                            ULONG           cbArray = (ULONG)(wcslen(wszNextToken)+1)/2;//we want to save the terminating NULL as well so add one.  Also, it takes two characters to represent each byte ie. 'ff' equals a single byte.

                            for(unsigned long i=0; i<cbArray;++i, ++pbyte)
                            {//If the user types a bogus hex character, we'll put the wrong thing into the buffer (who cares).
                                *pbyte =  kWcharToNibble[(*pwchar++)&0x007f]<<4;//The first character is the high nibble
                                *pbyte |= kWcharToNibble[(*pwchar++)&0x007f];   //The second is the low nibble
                            }
                            g_apvChanges [iColumn + (iChange * cColumns)] = reinterpret_cast<void *>(g_byArray[iColumn]);
                            g_apChangeSizes[iColumn + (iChange * cColumns)] = cbArray;
                            break;
                        }
                        default:
                        return E_NOTIMPL; // TODO: Support other types...
                    }
                    break;
                }
            }
        }
    }

    return S_OK;
}


static WCHAR * kByteToWchar[256] = 
{
    L"00",    L"01",    L"02",    L"03",    L"04",    L"05",    L"06",    L"07",    L"08",    L"09",    L"0a",    L"0b",    L"0c",    L"0d",    L"0e",    L"0f",
    L"10",    L"11",    L"12",    L"13",    L"14",    L"15",    L"16",    L"17",    L"18",    L"19",    L"1a",    L"1b",    L"1c",    L"1d",    L"1e",    L"1f",
    L"20",    L"21",    L"22",    L"23",    L"24",    L"25",    L"26",    L"27",    L"28",    L"29",    L"2a",    L"2b",    L"2c",    L"2d",    L"2e",    L"2f",
    L"30",    L"31",    L"32",    L"33",    L"34",    L"35",    L"36",    L"37",    L"38",    L"39",    L"3a",    L"3b",    L"3c",    L"3d",    L"3e",    L"3f",
    L"40",    L"41",    L"42",    L"43",    L"44",    L"45",    L"46",    L"47",    L"48",    L"49",    L"4a",    L"4b",    L"4c",    L"4d",    L"4e",    L"4f",
    L"50",    L"51",    L"52",    L"53",    L"54",    L"55",    L"56",    L"57",    L"58",    L"59",    L"5a",    L"5b",    L"5c",    L"5d",    L"5e",    L"5f",
    L"60",    L"61",    L"62",    L"63",    L"64",    L"65",    L"66",    L"67",    L"68",    L"69",    L"6a",    L"6b",    L"6c",    L"6d",    L"6e",    L"6f",
    L"70",    L"71",    L"72",    L"73",    L"74",    L"75",    L"76",    L"77",    L"78",    L"79",    L"7a",    L"7b",    L"7c",    L"7d",    L"7e",    L"7f",
    L"80",    L"81",    L"82",    L"83",    L"84",    L"85",    L"86",    L"87",    L"88",    L"89",    L"8a",    L"8b",    L"8c",    L"8d",    L"8e",    L"8f",
    L"90",    L"91",    L"92",    L"93",    L"94",    L"95",    L"96",    L"97",    L"98",    L"99",    L"9a",    L"9b",    L"9c",    L"9d",    L"9e",    L"9f",
    L"a0",    L"a1",    L"a2",    L"a3",    L"a4",    L"a5",    L"a6",    L"a7",    L"a8",    L"a9",    L"aa",    L"ab",    L"ac",    L"ad",    L"ae",    L"af",
    L"b0",    L"b1",    L"b2",    L"b3",    L"b4",    L"b5",    L"b6",    L"b7",    L"b8",    L"b9",    L"ba",    L"bb",    L"bc",    L"bd",    L"be",    L"bf",
    L"c0",    L"c1",    L"c2",    L"c3",    L"c4",    L"c5",    L"c6",    L"c7",    L"c8",    L"c9",    L"ca",    L"cb",    L"cc",    L"cd",    L"ce",    L"cf",
    L"d0",    L"d1",    L"d2",    L"d3",    L"d4",    L"d5",    L"d6",    L"d7",    L"d8",    L"d9",    L"da",    L"db",    L"dc",    L"dd",    L"de",    L"df",
    L"e0",    L"e1",    L"e2",    L"e3",    L"e4",    L"e5",    L"e6",    L"e7",    L"e8",    L"e9",    L"ea",    L"eb",    L"ec",    L"ed",    L"ee",    L"ef",
    L"f0",    L"f1",    L"f2",    L"f3",    L"f4",    L"f5",    L"f6",    L"f7",    L"f8",    L"f9",    L"fa",    L"fb",    L"fc",    L"fd",    L"fe",    L"ff"
};



// -----------------------------------------------------------------------
// ViewContent:
HRESULT ViewContent ()
{
    ISimpleTableRead2*      pISTView = NULL;
    void**                  apvValues = NULL;
    ULONG*                  acbSizes = NULL;
    ULONG                   iRow, iColumn, cColumns, cRows, iTag, iColumnIndex;
    ULONG                   cLines = 0;
    WCHAR                   wszGuid [cwchGUID];
    HRESULT                 hr = S_OK;

// Obtain table for viewing:
    hr = ObtainTable (g_wszDatabase, g_wszTable, (g_fArgs & fARG_QUERY ? g_aCells : NULL), (g_fArgs & fARG_QUERY ? g_cCells : NULL), g_fLOS, (void**) &pISTView, &cColumns, &apvValues, &acbSizes);
    if (FAILED (hr) && E_ST_NOMOREROWS != hr) { goto Cleanup; }
    hr = pISTView->GetTableMeta (NULL, NULL, &cRows, NULL);

// Display public table name:
    hr = g_pISTTableMeta->GetColumnValues (0, g_cTableMetaValues, NULL, NULL, g_apvTableMetaValues);
    if (FAILED (hr)) {hr = E_FAIL; goto Cleanup; }
    wprintf (L"\nCONTENT VIEWER: %d %s:\n", cRows, (LPWSTR) g_apvTableMetaValues[iTABLEMETA_PublicName]);

// For each row:
    for (iRow = 0, cLines = 2; ; iRow++)
    {
    // Get row values (all or specified columns):
        if (g_fArgs & fARG_COLUMNS)
        {
            if (1 == g_ciColumns)
            {
                hr = pISTView->GetColumnValues (iRow, g_ciColumns, g_aiColumns, acbSizes, &(apvValues[g_aiColumns[0]]));
            }
            else
            {
                hr = pISTView->GetColumnValues (iRow, g_ciColumns, g_aiColumns, acbSizes, apvValues);
            }
        }
        else
        {
            hr = pISTView->GetColumnValues (iRow, cColumns, NULL, acbSizes, apvValues);
        }
        if (E_ST_NOMOREROWS == hr)
        {
            if (0 == iRow) 
            {
                wprintf (L"   <no matches found>\n");
            }
            break;
        }
        if (FAILED (hr)) {hr = E_FAIL; goto Cleanup; }

    // Display public row name:
        wprintf (L"   %s %s (%d of %d):\n", (LPWSTR) g_apvTableMetaValues[iTABLEMETA_PublicRowName], (g_fArgs & fARG_NAMECOLUMN ? apvValues[*((ULONG*) g_apvTableMetaValues[iTABLEMETA_NameColumn])] : L"<name unavailable>"), iRow+1, cRows);

    // For each column:
        for (iColumn = 0, iColumnIndex = 0; ; iColumn++)
        {
        // Only display specified columns when requested:
            if (g_fArgs & fARG_COLUMNS)
            {
                if (iColumnIndex >= g_ciColumns) break;
                iColumn = g_aiColumns[iColumnIndex];
                iColumnIndex++;
            }

        // Display public column name:
            hr = g_pISTColumnMeta->GetColumnValues (iColumn, g_cColumnMetaValues, NULL, NULL, g_apvColumnMetaValues);
            if (E_ST_NOMOREROWS == hr)
            {
                break;
            }
            if (FAILED (hr)) {hr = E_FAIL; goto Cleanup; }
            wprintf (L"   %25s: ", (LPWSTR) g_apvColumnMetaValues[iCOLUMNMETA_PublicName]);
        // Display NULL values:
            if (NULL == apvValues [iColumn])
            {
                wprintf (L"NULL\n");
                continue;
            }
        // Display value by type:
            switch (*((ULONG*) g_apvColumnMetaValues[iCOLUMNMETA_Type]))
            {
                case DBTYPE_UI4:
                // Display enums:
                    if (*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_ENUM)
                    {
                        for (iTag = g_aiTagColumns [iColumn]; ; iTag++)
                        {
                            hr = g_pISTTagMeta->GetColumnValues (iTag, g_cTagMetaValues, NULL, NULL, g_apvTagMetaValues);
                            if (E_ST_NOMOREROWS == hr || *((ULONG*)g_apvTagMetaValues[iTAGMETA_ColumnIndex]) != iColumn)
                            {
                                wprintf (L"<unknown enum>");
                                break;
                            }
                            if (FAILED (hr)) { goto Cleanup; }
                            if (*((ULONG*)g_apvTagMetaValues[iTAGMETA_Value]) == *((DWORD*) apvValues[iColumn]))
                            {
                                wprintf (L"%s", (LPWSTR) g_apvTagMetaValues[iTAGMETA_PublicName]);
                                break;
                            }
                        }
                    }
                // Display flags:
                    else if (*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_FLAG)
                    {
                        if (0 == *((DWORD*) apvValues[iColumn]))
                        {
                            wprintf (L"<no flags>");
                        }
                        else
                        {
                            for (iTag = g_aiTagColumns [iColumn]; ; iTag++)
                            {
                                hr = g_pISTTagMeta->GetColumnValues (iTag, g_cTagMetaValues, NULL, NULL, g_apvTagMetaValues);
                                if (E_ST_NOMOREROWS == hr || *((ULONG*)g_apvTagMetaValues[iTAGMETA_ColumnIndex]) != iColumn)
                                {
                                    break;
                                }
                                if (FAILED (hr)) { goto Cleanup; }
                                if (*((ULONG*)g_apvTagMetaValues[iTAGMETA_Value]) & *((DWORD*) apvValues[iColumn]))
                                {
                                    wprintf (L"%s ", (LPWSTR) g_apvTagMetaValues[iTAGMETA_PublicName]);
                                }
                            }
                        }
                    }
                // Display bools:
                    else if (*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_BOOL)
                    {
                        if (*((DWORD*) apvValues[iColumn]))
                        {
                            wprintf (L"true");
                        }
                        else
                        {
                            wprintf (L"false");
                        }
                    }
                // Display numbers:
                    else
                    {
                        wprintf (L"%d", *((ULONG*) apvValues[iColumn]));
                    }
                break;
                case DBTYPE_WSTR:

                    if (*((DWORD*) g_apvColumnMetaValues[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_MULTISTRING)
					{
						wprintf (L"MULTISTRING values:");
						for (LPCWSTR pCurString = (LPWSTR) apvValues[iColumn];
							 *pCurString != L'\0';
							 pCurString += wcslen (pCurString) + 1)
						{
                    		wprintf (L"\"%s\",", pCurString); 
						}
					}
					else
					{
                    	wprintf (L"%s", (LPWSTR) apvValues[iColumn]);
					}
                break;
                case DBTYPE_GUID:
                    StringFromGUID2 (*((GUID*) apvValues[iColumn]), wszGuid, cwchGUID);
                    wprintf (L"%s", wszGuid);
                break;
                case DBTYPE_BYTES:
                    {
                        unsigned char * pbyte = reinterpret_cast<unsigned char *>(apvValues[iColumn]);
                        for(unsigned long i=0; i<acbSizes[iColumn]; ++i, ++pbyte)
                            wprintf(kByteToWchar[*pbyte]);
                        break;
                    }
                default:
                    wprintf (L"<unknown type>");
                break;
            }
            wprintf (L"\n");
        }
    }

Cleanup:
    if (E_ST_NOMOREROWS == hr || E_ST_NOMORECOLUMNS == hr) hr = S_OK;
    if (pISTView) pISTView->Release ();
    if (apvValues) delete [] apvValues;
    if (acbSizes) delete [] acbSizes;
    return hr;
}

// -----------------------------------------------------------------------
// WriteChanges:
HRESULT WriteChanges ()
{
    ISimpleTableWrite2*     pISTWrite = NULL;
    void**                  apvValues = NULL;
    ULONG*                  acbSizes = NULL;
    ULONG                   cColumns, iChange, iRow, iWriteRow, iColumn, iPK;
    HRESULT                 hr = S_OK;

// Obtain table for writing:
    hr = ObtainTable (g_wszDatabase, g_wszTable, (g_fArgs & fARG_QUERY ? g_aCells : NULL), (g_fArgs & fARG_QUERY ? g_cCells : NULL), g_fLOS, (void**) &pISTWrite, &cColumns, &apvValues, &acbSizes);
    if (FAILED (hr) && E_ST_NOMOREROWS != hr) { goto Cleanup; }

// Apply changes: 
    for (iChange = 0; iChange < g_cChanges; iChange++)
    {
        switch (g_aeChangeTypes[iChange]) // TODO: BUGBUG: This switch has redundancy which should be eliminated...
        {
            case eST_ROW_INSERT:
            // Insert row:
                hr = pISTWrite->AddRowForInsert (&iWriteRow);
                if (FAILED (hr)) goto Cleanup;

            // Set specified columns:
                for (iColumn = 0; iColumn < cColumns; iColumn++)
                {
                    apvValues [iColumn] = NULL;
                    if (g_apvChanges [iColumn + (iChange * cColumns)]) // ie: Column value specified:
                    {
                        hr = pISTWrite->SetWriteColumnValues (iWriteRow, 1, &iColumn, &g_apChangeSizes[iColumn + (iChange * cColumns)], &(g_apvChanges [iColumn + (iChange * cColumns)]));
                        if (FAILED (hr)) goto Cleanup;
                    }
                }
            break;
            case eST_ROW_DELETE:
            // Locate row and add for deleting:
                for (iPK = 0; iPK < g_cPKs; iPK++)
                {
                    apvValues[iPK] = g_apvChanges [(iChange * cColumns) + g_aiPKs [iPK]];
                }
                hr = pISTWrite->GetRowIndexByIdentity (NULL, apvValues, &iRow);
                if (FAILED (hr)) goto Cleanup;

                hr = pISTWrite->AddRowForDelete (iRow);
                if (FAILED (hr)) goto Cleanup;
            break;

            case eST_ROW_UPDATE:
            // Locate row and add for updating:
                for (iPK = 0; iPK < g_cPKs; iPK++)
                {
                    apvValues[iPK] = g_apvChanges [(iChange * cColumns) + g_aiPKs [iPK]];
                }
                hr = pISTWrite->GetRowIndexByIdentity (NULL, apvValues, &iRow);
                if (FAILED (hr)) goto Cleanup;
                hr = pISTWrite->AddRowForUpdate (iRow, &iWriteRow);
                if (FAILED (hr)) goto Cleanup;

            // Set specified columns:
                for (iColumn = 0; iColumn < cColumns; iColumn++)
                {
                    apvValues [iColumn] = NULL;
                    if (g_apvChanges [iColumn + (iChange * cColumns)]) // ie: Column value specified:
                    {
                        for (iPK = 0; iPK < g_cPKs; iPK++)
                        {
                            if (iColumn == g_aiPKs [iPK])
                            {
                                break;
                            }
                        }
                        if (iPK == g_cPKs) // ie: Column is not a primary key column:
                        {
                            hr = pISTWrite->SetWriteColumnValues (iWriteRow, 1, &iColumn, &g_apChangeSizes[iColumn + (iChange * cColumns)], &(g_apvChanges [iColumn + (iChange * cColumns)]));
                            if (FAILED (hr)) goto Cleanup;
                        }
                    }
                }
            break;
            default:
            return E_UNEXPECTED;
        }
    }

// Flush changes:
    hr = pISTWrite->UpdateStore ();
    if (FAILED (hr)) goto Cleanup;

Cleanup:
    if (pISTWrite) pISTWrite->Release ();
    if (apvValues) delete [] apvValues;
    if (acbSizes) delete [] acbSizes;
    return hr;
}

// -----------------------------------------------------------------------
// ObtainTable:
HRESULT ObtainTable (LPWSTR i_wszDatabase, LPWSTR i_wszTable, STQueryCell* i_acells, ULONG i_cMeta, DWORD i_fLOS, void** o_ppv, ULONG* o_pcColumns, void*** o_papvValues, ULONG** o_pacbSizes)
{
    HRESULT hr = S_OK;

    hr = g_pISTDisp->GetTable (i_wszDatabase, i_wszTable, i_acells, &i_cMeta, eST_QUERYFORMAT_CELLS, i_fLOS, o_ppv);
    if (FAILED (hr)) return hr;
    hr = ((ISimpleTableRead2*) *o_ppv)->GetTableMeta (NULL, NULL, NULL, o_pcColumns);
    if (FAILED (hr)) return hr;
    *o_papvValues = new LPVOID [*o_pcColumns];
    if (NULL == *o_papvValues) return E_OUTOFMEMORY;
    if (o_pacbSizes)
    {
        *o_pacbSizes = new ULONG [*o_pcColumns];
        if (NULL == *o_pacbSizes) return E_OUTOFMEMORY;
    }
    hr = ((ISimpleTableRead2*) *o_ppv)->GetColumnValues (0, *o_pcColumns, NULL, (o_pacbSizes ? *o_pacbSizes : NULL), *o_papvValues);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\testcookdown\configmgr.cpp ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    config_manager.cxx

Abstract:

    The IIS web admin service configuration manager class implementation. 
    This class manages access to configuration metadata, as well as 
    handling dynamic configuration changes.

    Threading: Access to configuration metadata is done on the main worker 
    thread. Configuration changes arrive on COM threads (i.e., secondary 
    threads), and so they post work items to process the changes on the main 
    worker thread.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/



//#include "precomp.h"

#define cAPPPOOLS_BASEVERSION		1
#define cSITES_BASEVERSION			1
#define cAPPS_BASEVERSION			1

#include	"catalog.h"
#include	"catmeta.h"
#include	"ConfigMgr.h"
#include	"Catmeta.h"
#include	"winwrap.h"

LPCWSTR	g_wszCookDownFile		= L"WASMB.CLB";


/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::CONFIG_MANAGER(
    )
{

    //m_Signature = CONFIG_MANAGER_SIGNATURE;


    m_CoInitialized = FALSE;

	m_pISTDisp	= NULL;

}   // CONFIG_MANAGER::CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::~CONFIG_MANAGER(
    )
{

    //DBG_ASSERT( m_Signature == CONFIG_MANAGER_SIGNATURE );


    //
    // Make sure we CoUninitialize on the same thread we CoInitialize'd on
    // originally.
    //

    //DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_CoInitialized )
    {
        CoUninitialize();
        m_CoInitialized = FALSE;
    }


	if(NULL != m_pISTDisp)
		m_pISTDisp->Release();

    //m_Signature = CONFIG_MANAGER_SIGNATURE_FREED;

}   // CONFIG_MANAGER::~CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Initialize the configuration manager.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;


    //DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = CoInitializeEx(
				NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
     /*   DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));
	*/	
        goto exit;
    }

    m_CoInitialized = TRUE;
    
/*
    hr = CookDown(WSZ_PRODUCT_IIS);
    if ( FAILED( hr ) )
    {
    
        goto exit;
    }

	wprintf (L"Calling RecoverFromInetInfoCrash\n");
	hr = RecoverFromInetInfoCrash(WSZ_PRODUCT_IIS);
	if(FAILED(hr))
	{
		wprintf (L"CookDown failed with hr = %08x\n", hr);
		goto exit;
	}
*/

    hr = CookDown(WSZ_PRODUCT_IIS);

    if ( FAILED( hr ) )
    {
    
     /*   DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Cook Down of configuration information failed - Will attempt to read information from the old Cooked down format, if it exists.\n"
            ));
	*/	
        goto exit;
    }


    hr = ReadAllConfiguration();

    if ( FAILED( hr ) )
    {
    
      /*  DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading initial configuration failed\n"
            ));
		*/
        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Read the initial web server configuration from the metabase.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllConfiguration(
    )
{
	HRESULT hr;

    hr = ReadAllAppPools();

    if ( FAILED( hr ) )
    {
    
      /*  DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading app pools failed\n"
            ));
		*/
        goto exit;
    }


    hr = ReadAllVirtualSites();

    if ( FAILED( hr ) )
    {
    
      /*  DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading virtual sites failed\n"
            ));
		*/
        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::ReadAllConfiguration



/***************************************************************************++

Routine Description:

    Enumerate and read all app pools configured in the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllAppPools(
    )
{
	HRESULT							hr;
	ISimpleTableRead2				*pISTAppPools	= NULL;
	ULONG							cBaseVersion;
	ULONG							i;
	WCHAR*							wszAppPoolName;
	//APP_POOL_CONFIG					AppPoolConfig;
    DWORD					        ValidAppPoolCount	= 0;
	static const ULONG				aiAppPoolColumns [] = { 
															iAPPPOOLS_AppPoolID, 
															iAPPPOOLS_PeriodicRestartTime,
															iAPPPOOLS_PeriodicRestartRequests,
															iAPPPOOLS_MaxProcesses,
															iAPPPOOLS_PingingEnabled,
															iAPPPOOLS_IdleTimeout,
															iAPPPOOLS_RapidFailProtection	
															};
	static const ULONG				cAppPoolColumns		= sizeof (aiAppPoolColumns) / sizeof (ULONG);
	static const ULONG				cmaxAppPoolColumns	= iAPPPOOLS_RapidFailProtection + 1;
	void*							apvAppPoolValues [cmaxAppPoolColumns];

	hr = GetTable (	
 				    wszDATABASE_IIS, 
				    wszTABLE_APPPOOLS,
				    0,
				    (void**) &pISTAppPools	
				  );

    if ( FAILED( hr ) )
    {
    
     /*   DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error getting AppPools table\n"
            ));
		*/
        goto exit;
    }

// TODO: Check with Robert as to what this version check means.
/*	#ifdef _DEBUG
		hr = pISTAppPools->GetTableMeta (
										  &cBaseVersion, 
										  NULL, 
										  NULL, 
										  NULL
										);
	
		if (cAPPPOOLS_BASEVERSION != cBaseVersion)
		{
			hr = E_UNEXPECTED;
			goto exit;
		}

	#endif // _DEBUG
*/
	for (i = 0;; i++)
	{

		hr = pISTAppPools->GetColumnValues (
											 i,
											 cAppPoolColumns, 
											 (ULONG *)aiAppPoolColumns, 
											 NULL, 
											 apvAppPoolValues
										   );

		if (E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if ( FAILED( hr ) )
		{
    
		/*	DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Error reading an AppPool row. Ignoring this row. Will continue with next row.\n"
				));
		*/
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}


		wszAppPoolName										=	(WCHAR*) apvAppPoolValues[iAPPPOOLS_AppPoolID];
/*		AppPoolConfig.PeriodicProcessRestartPeriodInMinutes	=	((ULONG)*(apvAppPoolValues[iAPPPOOLS_PeriodicRestartTime]));
		AppPoolConfig.PeriodicProcessRestartRequestCount	=	((ULONG)*(apvAppPoolValues[iAPPPOOLS_PeriodicRestartRequests]));
		AppPoolConfig.MaxSteadyStateProcessCount			=	((ULONG)*(apvAppPoolValues[iAPPPOOLS_MaxProcesses]));
		AppPoolConfig.PingingEnabled						=	((ULONG)*(apvAppPoolValues[iAPPPOOLS_PingingEnabled]));
		AppPoolConfig.IdleTimeoutInMinutes					=	((ULONG)*(apvAppPoolValues[iAPPPOOLS_IdleTimeout]));
		AppPoolConfig.RapidFailProtectionEnabled			=	((ULONG)*(apvAppPoolValues[iAPPPOOLS_RapidFailProtection]));
*/
 /*       IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reading from metabase app pool with ID: %S\n",
                wszAppPoolName
                ));
        }
*/
		//hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateAppPool (wszAppPoolName, &AppPoolConfig);

	    if ( FAILED( hr ) )
		{

		/*	DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Creating app pool failed. Ignoring this. Will contiue with next AppPool\n"
				));
			*/
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;

		}

        ValidAppPoolCount++;

	} // End For all AppPool rows

    if ( ValidAppPoolCount == 0 )
    {
    
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

    /*    DPERROR(( 
            DBG_CONTEXT,
            hr,
            "No valid app pools found in Cooked down metabase\n"
            ));
	*/
        goto exit;
    }


exit: 

	if(NULL != pISTAppPools)
		pISTAppPools->Release();

    return hr;

}   // CONFIG_MANAGER::ReadAllAppPools



/***************************************************************************++

Routine Description:

    Enumerate and read all virtual sites configured in the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllVirtualSites(
    )
{

	HRESULT							hr;
	ISimpleTableRead2				*pISTSites = NULL;
	ULONG							cBaseVersion;
	ULONG							i;
	DWORD							ValidVirtualSiteCount = 0;
	static const ULONG				aiSiteColumns []	= { 
														  iSITES_SiteID, 
														  iSITES_Bindings	
														};
	static const ULONG				cSiteColumns		= sizeof (aiSiteColumns) / sizeof (ULONG);
	static const ULONG				cmaxSiteColumns		= iSITES_Bindings + 1;
	void*							apvSiteValues [cmaxSiteColumns];
	ULONG							acbSiteValues [cmaxSiteColumns];
 
	hr = GetTable (	
					wszDATABASE_IIS, 
					wszTABLE_SITES, 
					0,
					(void**) &pISTSites
				  );

    if ( FAILED( hr ) )
    {

     /*   DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error getting Virtual Sites table\n"
            ));
	*/
        goto exit;
    }

/*	#ifdef _DEBUG

		hr = pISTSites->GetTableMeta (
									   &cBaseVersion, 
									   NULL, 
									   NULL, 
									   NULL
									 );

		if (cSITES_BASEVERSION != cBaseVersion)
		{
			hr = E_UNEXPECTED;
			goto exit;
		}

	#endif // _DEBUG
*/
	for (i = 0;; i++)
	{
		hr = pISTSites->GetColumnValues (
										  i,
										  cSiteColumns, 
										  (ULONG *)aiSiteColumns, 
										  (ULONG *)acbSiteValues, 
										  apvSiteValues
										);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if ( FAILED( hr ) )
		{
    
		/*	DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Error reading an Virtual Site row. Ignoring this row. Will continue with next row.\n"
				));
		*/
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}

/*		hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateAppPool (
																			((ULONG)*(apvSiteValues[iSITES_VirtualSiteID])),
																			(BYTE*) apvSiteValues[iSITES_URLPrefixes],
																			acbSiteValues [iSITES_URLPrefixes]	
																		  );
*/
		if ( FAILED( hr ) )
		{

		/*	DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Creating virtual site failed\n"
				));
		*/
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}

		ValidVirtualSiteCount++;

	}

    if ( ValidVirtualSiteCount == 0 )
    {
    
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

     /*   DPERROR(( 
            DBG_CONTEXT,
            hr,
            "No valid virtual sites found in Cooked Down metabase\n"
            ));
		*/
        goto exit;
    }

   /*  IF_DEBUG( WEB_ADMIN_SERVICE )
    {
       DBGPRINTF((
            DBG_CONTEXT, 
            "Total number of valid virtual sites found: %lu\n",
            ValidVirtualSiteCount
            )); 
    } */


exit: 

	if(NULL != pISTSites)
		pISTSites->Release();

    return hr;

}   // CONFIG_MANAGER::ReadAllVirtualSites


/***************************************************************************++

Routine Description:

    Read and create a set of applications of a site.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    VirtualSiteId - The id for the virtual site which contains these
    applications.

    pApplicationPaths - A MULTISZ containing the metabase paths to the 
    applications under a virtual site.

    pSiteRootPath - The metabase path fragment containing "/<SiteId>/Root".

    pValidRootApplicationExists - Returns TRUE if the root application (the 
    one at the URL "/" within the site) exists and is valid, FALSE otherwise.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadApplications(
    OUT BOOL * pValidRootApplicationExists
    )
{

	HRESULT							hr;

	ISimpleTableRead2				*pISTApps	= NULL;
	ULONG							cBaseVersion;
	ULONG							i;
	DWORD							ValidApplicationCount = 0;
	static const ULONG				aiAppColumns [] =   { 
														  iAPPS_SiteID, 
														  iAPPS_AppPoolId,
														  iAPPS_AppRelativeURL	
														};
	static const ULONG				cAppColumns		= sizeof (aiAppColumns) / sizeof (ULONG);
	static const ULONG				cmaxAppColumns	= iAPPS_AppRelativeURL + 1;
	void*							apvAppValues [cmaxAppColumns];

	hr = GetTable (	
					wszDATABASE_IIS, 
					wszTABLE_APPS, 
					0,
					(void**) &pISTApps	
				  );

    if ( FAILED( hr ) )
    {

     /*   DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error getting Applications table\n"
            ));
	*/
        goto exit;
    }

/*	#ifdef _DEBUG
		hr = pISTApps->GetTableMeta (&cBaseVersion, NULL, NULL, NULL);
		if (cAPPS_BASEVERSION != cBaseVersion)
		{
			hr = E_UNEXPECTED;
			goto exit;
		}
	#endif // _DEBUG
*/
	for (i = 0;; i++)
	{
		hr = pISTApps->GetColumnValues (
										 i,
										 cAppColumns, 
										 (ULONG *)aiAppColumns, 
										 NULL, 
										 apvAppValues
									   );

		if (E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if ( FAILED( hr ) )
		{
    
	/*		DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Error reading an Applications row. Ignoring this row. Will continue with next row.\n"
				));
	*/
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}

/*		hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateApplication (
																			    ((DWORD)*(apvAppValues[iAPPS_SiteID])),
																				(WCHAR*) apvAppValues[iAPPS_AppPoolID],
																				(WCHAR*) apvAppValues[iAPPS_AppURL]	
																			  );

*/		if ( FAILED( hr ) )
		{

	/*		DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Creating application failed\n"
				));
	*/
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}

		// TODO: Check if each application has a valid root site.
		// fail if it doesn't

		ValidApplicationCount++;
    

	}

 /*   IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Number of valid apps (including root app if present) found for site: %lu was: %lu\n",
            VirtualSiteId,
            ValidApplicationCount
            ));  
    } */

exit:

	if(NULL != pISTApps)
		pISTApps->Release();

    return hr;

}   // CONFIG_MANAGER::ReadApplications


/***************************************************************************++

Routine Description:

    Helper function to obtain ISimpleTable* pointers

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CONFIG_MANAGER::GetTable(LPCWSTR	i_wszDatabase,
						  LPCWSTR	i_wszTable,
						  DWORD		i_fServiceRequests,
						  LPVOID	*o_ppIST)
{

	HRESULT hr;
    STQueryCell		QueryCell[1];
	ULONG			cCell	= sizeof(QueryCell)/sizeof(STQueryCell);
	
	static LPWSTR wszFullCookedDownFileName	= NULL;

	if(NULL == m_pISTDisp)
	{

		hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &m_pISTDisp);

		if(FAILED(hr) || (NULL == m_pISTDisp))
		{
		/*	DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Creating dispenser failed\n"
				)); */
			goto exit;
		}
	}

	if(NULL == wszFullCookedDownFileName)
	{
		LPCWSTR wszSubDir	= L"\\XSPDT\\";
		LPWSTR	wszCurPos	= NULL;
		UINT	cb			= WszGetWindowsDirectory(NULL, 0);

		if (cb == 0)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto exit;
		}

		cb++;			// What if they dont include NULL
		cb += lstrlenW(wszSubDir);
		cb += lstrlenW(g_wszCookDownFile);

		wszFullCookedDownFileName = new WCHAR[cb];
		if(wszFullCookedDownFileName == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		cb = WszGetWindowsDirectory(wszFullCookedDownFileName, cb);

		if (cb == 0)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			return E_OUTOFMEMORY;
		}
		
		cb++;			// What if they dont include NULL

		wszCurPos = wszFullCookedDownFileName;
		while (*wszCurPos != '\0')
		{
			wszCurPos ++;
		}

		wszCurPos --;
		if (*wszCurPos == '\\')
		{
			*wszCurPos = '\0';	// If we had a back slash we remove it.
		}

		lstrcatW(wszFullCookedDownFileName, wszSubDir);
		lstrcatW(wszFullCookedDownFileName, g_wszCookDownFile);

	}

    QueryCell[0].pData     = (LPVOID)wszFullCookedDownFileName;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(wszFullCookedDownFileName)+1)*sizeof(WCHAR);


	hr = m_pISTDisp->GetTable(i_wszDatabase, 
							  i_wszTable, 
							  (LPVOID)NULL, 
						      (LPVOID)NULL, 
							  eST_QUERYFORMAT_CELLS, 
							  i_fServiceRequests,	
							  o_ppIST);
	if(FAILED(hr) || (NULL == m_pISTDisp))
	{
	/*	DPERROR(( 
			DBG_CONTEXT,
			hr,
			"Getting table failed\n"
			));		
		goto exit; */
	}

exit:
	return hr;


} // CCooker::GetTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\testcookdown\config_manager.cxx ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    config_manager.cxx

Abstract:

    The IIS web admin service configuration manager class implementation. 
    This class manages access to configuration metadata, as well as 
    handling dynamic configuration changes.

    Threading: Access to configuration metadata is done on the main worker 
    thread. Configuration changes arrive on COM threads (i.e., secondary 
    threads), and so they post work items to process the changes on the main 
    worker thread.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/

#include    "precomp.h"

#define		REGSYSDEFNS_DEFINE
#include	"RegSysDefns.h"
#include	"stable_i.c"

#define cAPPPOOLS_BASEVERSION		1
#define cSITES_BASEVERSION			1
#define cAPPS_BASEVERSION			1


LPCWSTR	g_wszCookDownFile		= L"WASMB.CLB";

STDAPI CookDown();

/***************************************************************************++

Routine Description:

    Constructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::CONFIG_MANAGER(
    )
{

    m_Signature = CONFIG_MANAGER_SIGNATURE;


    m_CoInitialized = FALSE;

	m_pISTDisp	= NULL;

}   // CONFIG_MANAGER::CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Destructor for the CONFIG_MANAGER class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CONFIG_MANAGER::~CONFIG_MANAGER(
    )
{

    DBG_ASSERT( m_Signature == CONFIG_MANAGER_SIGNATURE );


    //
    // Make sure we CoUninitialize on the same thread we CoInitialize'd on
    // originally.
    //

    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    if ( m_CoInitialized )
    {
        CoUninitialize();
        m_CoInitialized = FALSE;
    }


	if(NULL != m_pISTDisp)
		m_pISTDisp->Release();

    m_Signature = CONFIG_MANAGER_SIGNATURE_FREED;

}   // CONFIG_MANAGER::~CONFIG_MANAGER



/***************************************************************************++

Routine Description:

    Initialize the configuration manager.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::Initialize(
    )
{

    HRESULT hr = S_OK;


    DBG_ASSERT( ON_MAIN_WORKER_THREAD );


    hr = CoInitializeEx(
				NULL,                   // reserved
                COINIT_MULTITHREADED    // threading model
                );

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Initializing COM failed\n"
            ));
	
        goto exit;
    }

    m_CoInitialized = TRUE;
    

    hr = CookDown();

    if ( FAILED( hr ) )
    {
    
        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Cook Down of configuration information failed - Will attempt to read information from the old Cooked down format, if it exists.\n"
            ));

        goto exit;
    }


    hr = ReadAllConfiguration();

    if ( FAILED( hr ) )
    {
    
       DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading initial configuration failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::Initialize



/***************************************************************************++

Routine Description:

    Read the initial web server configuration from the metabase.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllConfiguration(
    )
{
	HRESULT hr;

    hr = ReadAllAppPools();

    if ( FAILED( hr ) )
    {
    
      DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading app pools failed\n"
            ));
        goto exit;
    }


    hr = ReadAllVirtualSites();

    if ( FAILED( hr ) )
    {
    
      DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Reading virtual sites failed\n"
            ));

        goto exit;
    }


exit:

    return hr;

}   // CONFIG_MANAGER::ReadAllConfiguration



/***************************************************************************++

Routine Description:

    Enumerate and read all app pools configured in the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllAppPools(
    )
{
	HRESULT							hr;
	ISimpleTableRead2				*pISTAppPools	= NULL;
	ULONG							cBaseVersion;
	ULONG							i;
	WCHAR*							wszAppPoolName;
	APP_POOL_CONFIG					AppPoolConfig;
    DWORD					        ValidAppPoolCount	= 0;
	static const ULONG				aiAppPoolColumns [] = { 
															iDT_AppPoolID, 
															iDT_PeriodicRestartTime,
															iDT_PeriodicRestartRequests,
															iDT_MaxProcesses,
															iDT_PingingEnabled,
															iDT_IdleTimeout,
															iDT_RapidFailProtection	
															};
	static const ULONG				cAppPoolColumns		= sizeof (aiAppPoolColumns) / sizeof (ULONG);
	static const ULONG				cmaxAppPoolColumns	= iDT_RapidFailProtection + 1;
	void*							apvAppPoolValues [cmaxAppPoolColumns];

	hr = GetTable (	
 				    didURTGLOBAL, 
				    tidAPPPOOLS,
				    0,
				    (void**) &pISTAppPools	
				  );

    if ( FAILED( hr ) )
    {
    
      DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error getting AppPools table\n"
            ));

        goto exit;
    }

// TODO: Check with Robert as to what this version check means.
/*	#ifdef _DEBUG
		hr = pISTAppPools->GetTableMeta (
										  &cBaseVersion, 
										  NULL, 
										  NULL, 
										  NULL
										);
	
		if (cAPPPOOLS_BASEVERSION != cBaseVersion)
		{
			hr = E_UNEXPECTED;
			goto exit;
		}

	#endif // _DEBUG
*/
	for (i = 0;; i++)
	{
		hr = pISTAppPools->MoveToRowByIndex (i);

		if (E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}

		if ( FAILED( hr ) )
		{
    
		DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Error reading an AppPool row. Ignoring this row. Will continue with next row.\n"
				));
		
		// TODO: Should we be continuing here?
			goto exit;
		}

		hr = pISTAppPools->GetColumnValues (
											 cAppPoolColumns, 
											 (ULONG *)aiAppPoolColumns, 
											 NULL, 
											 apvAppPoolValues
										   );

		if ( FAILED( hr ) )
		{
    
		DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Error reading an AppPool row. Ignoring this row. Will continue with next row.\n"
				));
		
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}


		wszAppPoolName										=	(WCHAR*) apvAppPoolValues[iDT_AppPoolID];
		AppPoolConfig.PeriodicProcessRestartPeriodInMinutes	=	*((ULONG *)(apvAppPoolValues[iDT_PeriodicRestartTime]));
		AppPoolConfig.PeriodicProcessRestartRequestCount	=	*((ULONG *)(apvAppPoolValues[iDT_PeriodicRestartRequests]));
		AppPoolConfig.MaxSteadyStateProcessCount			=	*((ULONG *)(apvAppPoolValues[iDT_MaxProcesses]));
		AppPoolConfig.PingingEnabled						=	*((ULONG *)(apvAppPoolValues[iDT_PingingEnabled]));
		AppPoolConfig.IdleTimeoutInMinutes					=	*((ULONG *)(apvAppPoolValues[iDT_IdleTimeout]));
		AppPoolConfig.RapidFailProtectionEnabled			=	*((ULONG *)(apvAppPoolValues[iDT_RapidFailProtection]));
        IF_DEBUG( WEB_ADMIN_SERVICE )
        {
            DBGPRINTF((
                DBG_CONTEXT, 
                "Reading from metabase app pool with ID: %S\n",
                wszAppPoolName
                ));
        }

		hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateAppPool (wszAppPoolName, &AppPoolConfig);

	    if ( FAILED( hr ) )
		{

		DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Creating app pool failed. Ignoring this. Will contiue with next AppPool\n"
				));
			
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;

		}

        ValidAppPoolCount++;

	} // End For all AppPool rows

    if ( ValidAppPoolCount == 0 )
    {
    
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "No valid app pools found in Cooked down metabase\n"
            ));
	
        goto exit;
    }


exit: 

	if(NULL != pISTAppPools)
		pISTAppPools->Release();

    return hr;

}   // CONFIG_MANAGER::ReadAllAppPools



/***************************************************************************++

Routine Description:

    Enumerate and read all virtual sites configured in the metabase.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadAllVirtualSites(
    )
{

	HRESULT							hr;
	ISimpleTableRead2				*pISTSites = NULL;
	ULONG							cBaseVersion;
	ULONG							i;
	DWORD							ValidVirtualSiteCount = 0;
	static const ULONG				aiSiteColumns []	= { 
														  iDT_VirtualSiteID, 
														  iDT_URLPrefixes	
														};
	static const ULONG				cSiteColumns		= sizeof (aiSiteColumns) / sizeof (ULONG);
	static const ULONG				cmaxSiteColumns		= iDT_URLPrefixes + 1;
	void*							apvSiteValues [cmaxSiteColumns];
	ULONG							acbSiteValues [cmaxSiteColumns];

	hr = GetTable (	
					didURTGLOBAL, 
					tidSITES, 
					0,
					(void**) &pISTSites
				  );

    if ( FAILED( hr ) )
    {

       DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error getting Virtual Sites table\n"
            ));

        goto exit;
    }

/*	#ifdef _DEBUG

		hr = pISTSites->GetTableMeta (
									   &cBaseVersion, 
									   NULL, 
									   NULL, 
									   NULL
									 );

		if (cSITES_BASEVERSION != cBaseVersion)
		{
			hr = E_UNEXPECTED;
			goto exit;
		}

	#endif // _DEBUG
*/
	for (i = 0;; i++)
	{
		hr = pISTSites->MoveToRowByIndex (i);

		if (E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}

		if ( FAILED( hr ) )
		{
    
		DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Error reading an Virtual Site row. Ignoring this row. Will continue with next row.\n"
				));
		
		// TODO: Should we be continuing here?
			goto exit;
		}

		hr = pISTSites->GetColumnValues (
										  cSiteColumns, 
										  (ULONG *)aiSiteColumns, 
										  (ULONG *)acbSiteValues, 
										  apvSiteValues
										);

		if ( FAILED( hr ) )
		{
    
		DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Error reading an Virtual Site row. Ignoring this row. Will continue with next row.\n"
				));
		
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}

		hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateVirtualSite (
																			*((ULONG*)(apvSiteValues[iDT_VirtualSiteID])),
																			(BYTE*) (apvSiteValues[iDT_URLPrefixes]),
																			acbSiteValues [iDT_URLPrefixes]	
																		  );

		if ( FAILED( hr ) )
		{

			DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Creating virtual site failed\n"
				));
		
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}

		ValidVirtualSiteCount++;

	}

    if ( ValidVirtualSiteCount == 0 )
    {
    
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_DATA );

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "No valid virtual sites found in Cooked Down metabase\n"
            ));
	
        goto exit;
    }

     IF_DEBUG( WEB_ADMIN_SERVICE )
    {
       DBGPRINTF((
            DBG_CONTEXT, 
            "Total number of valid virtual sites found: %lu\n",
            ValidVirtualSiteCount
            )); 
    } 


exit: 

	if(NULL != pISTSites)
		pISTSites->Release();

    return hr;

}   // CONFIG_MANAGER::ReadAllVirtualSites


/***************************************************************************++

Routine Description:

    Read and create a set of applications of a site.

Arguments:

    pMetabase - An instance of the MB class, opened to IIS_MD_W3SVC.

    VirtualSiteId - The id for the virtual site which contains these
    applications.

    pApplicationPaths - A MULTISZ containing the metabase paths to the 
    applications under a virtual site.

    pSiteRootPath - The metabase path fragment containing "/<SiteId>/Root".

    pValidRootApplicationExists - Returns TRUE if the root application (the 
    one at the URL "/" within the site) exists and is valid, FALSE otherwise.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT
CONFIG_MANAGER::ReadApplications(
    OUT BOOL * pValidRootApplicationExists
    )
{

	HRESULT							hr;

	ISimpleTableRead2				*pISTApps;
	ULONG							cBaseVersion;
	ULONG							i;
	DWORD							ValidApplicationCount = 0;
	static const ULONG				aiAppColumns [] =   { 
														  iDT_APP_VirtualSiteID, 
														  iDT_APP_AppPoolID,
														  iDT_APP_AppURL	
														};
	static const ULONG				cAppColumns		= sizeof (aiAppColumns) / sizeof (ULONG);
	static const ULONG				cmaxAppColumns	= iDT_APP_AppURL + 1;
	void*							apvAppValues [cmaxAppColumns];

	hr = GetTable (	
					didURTGLOBAL, 
					tidAPPS, 
					0,
					(void**) &pISTApps	
				  );

    if ( FAILED( hr ) )
    {

        DPERROR(( 
            DBG_CONTEXT,
            hr,
            "Error getting Applications table\n"
            ));
	
        goto exit;
    }

/*	#ifdef _DEBUG
		hr = pISTApps->GetTableMeta (&cBaseVersion, NULL, NULL, NULL);
		if (cAPPS_BASEVERSION != cBaseVersion)
		{
			hr = E_UNEXPECTED;
			goto exit;
		}
	#endif // _DEBUG
*/
	for (i = 0;; i++)
	{
		hr = pISTApps->MoveToRowByIndex (i);

		if (E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}

		if ( FAILED( hr ) )
		{
    
			DPERROR(( 
			DBG_CONTEXT,
				hr,
				"Error reading an Applications row. Ignoring this row. Will continue with next row.\n"
				));
	
		// TODO: Should we be continuing here?
			goto exit;
		}

		hr = pISTApps->GetColumnValues (
										 cAppColumns, 
										 (ULONG *)aiAppColumns, 
										 NULL, 
										 apvAppValues
									   );

		if ( FAILED( hr ) )
		{
    
			DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Error reading an Applications row. Ignoring this row. Will continue with next row.\n"
				));
	
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}

		hr = GetWebAdminService()->GetUlAndWorkerManager()->CreateApplication (
																			    *((DWORD *)(apvAppValues[iDT_APP_VirtualSiteID])),
																				(WCHAR*) apvAppValues[iDT_APP_AppPoolID],
																				(WCHAR*) apvAppValues[iDT_APP_AppURL]	
																			  );

		if ( FAILED( hr ) )
		{

			DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Creating application failed\n"
				));
	
		// TODO: Should we be continuing here?
			hr = S_OK;
			continue;
		}

		// TODO: Check if each application has a valid root site.
		// fail if it doesn't

		ValidApplicationCount++;
    

	}

    IF_DEBUG( WEB_ADMIN_SERVICE )
    {
        DBGPRINTF((
            DBG_CONTEXT, 
            "Number of valid apps (including root app if present) found for site: %lu was: %lu\n",
            *((DWORD *)(apvAppValues[iDT_APP_VirtualSiteID])),
            ValidApplicationCount
            ));  
    } 

exit:

	if(NULL != pISTApps)
		pISTApps->Release();

    return hr;

}   // CONFIG_MANAGER::ReadApplications


/***************************************************************************++

Routine Description:

    Helper function to obtain ISimpleTable* pointers

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CONFIG_MANAGER::GetTable(REFGUID	i_did,
						  REFGUID	i_tid,
						  DWORD		i_fServiceRequests,
						  LPVOID	*o_ppIST)
{

	HRESULT hr;
    STQueryCell		QueryCell[1];
	ULONG			cCell	= sizeof(QueryCell)/sizeof(STQueryCell);
	
	static LPWSTR wszFullCookedDownFileName	= NULL;

	if(NULL == m_pISTDisp)
	{
		hr = CoCreateInstance (CLSID_STDispenser,			
							   NULL,
							   CLSCTX_INPROC_SERVER, 
							   IID_ISimpleTableDispenser2,  
							   (void**)&m_pISTDisp);
		if(FAILED(hr) || (NULL == m_pISTDisp))
		{
			DPERROR(( 
				DBG_CONTEXT,
				hr,
				"Creating dispenser failed\n"
				)); 
			goto exit;
		}
	}

	if(NULL == wszFullCookedDownFileName)
	{
		LPCWSTR wszSubDir	= L"\\XSPDT\\";
		LPWSTR	wszCurPos	= NULL;
		UINT	cb			= GetWindowsDirectoryW(NULL, 0);

		if (cb == 0)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			goto exit;
		}

		cb++;			// What if they dont include NULL
		cb += lstrlenW(wszSubDir);
		cb += lstrlenW(g_wszCookDownFile);

		wszFullCookedDownFileName = new WCHAR[cb];
		if(wszFullCookedDownFileName == NULL)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		cb = GetWindowsDirectoryW(wszFullCookedDownFileName, cb);

		if (cb == 0)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());
			return E_OUTOFMEMORY;
		}
		
		cb++;			// What if they dont include NULL

		wszCurPos = wszFullCookedDownFileName;
		while (*wszCurPos != '\0')
		{
			wszCurPos = CharNextW(wszCurPos);
		}

		wszCurPos = CharPrevW(wszFullCookedDownFileName, wszCurPos);
		if (*wszCurPos == '\\')
		{
			*wszCurPos = '\0';	// If we had a back slash we remove it.
		}

		lstrcatW(wszFullCookedDownFileName, wszSubDir);
		lstrcatW(wszFullCookedDownFileName, g_wszCookDownFile);

	}

    QueryCell[0].pData     = (LPVOID)wszFullCookedDownFileName;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(wszFullCookedDownFileName)+1)*sizeof(WCHAR);

	hr = m_pISTDisp->GetTable(i_did, 
							  i_tid, 
							  (LPVOID)QueryCell, 
						      (LPVOID)&cCell, 
							  eST_QUERYFORMAT_CELLS, 
							  i_fServiceRequests,	
							  o_ppIST);
	if(FAILED(hr) || (NULL == m_pISTDisp))
	{
		DPERROR(( 
			DBG_CONTEXT,
			hr,
			"Getting table failed\n"
			));		
		goto exit; 
	}

exit:
	return hr;


} // CCooker::GetTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\testcookdown\configmgr.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    config_manager.h

Abstract:

    The IIS web admin service configuration manager class definition.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/


#ifndef _CONFIG_MANAGER_H_
#define _CONFIG_MANAGER_H_



//
// common #defines
//

#define CONFIG_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'CFGM' )
#define CONFIG_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'cfgX' )


#define PROTOCOL_STRING_HTTP L"http://"

#define PROTOCOL_STRING_HTTP_CHAR_COUNT_SANS_TERMINATION                \
    ( sizeof( PROTOCOL_STRING_HTTP ) / sizeof( WCHAR ) ) - 1

#define PROTOCOL_STRING_HTTPS L"https://"

#define PROTOCOL_STRING_HTTPS_CHAR_COUNT_SANS_TERMINATION               \
    ( sizeof( PROTOCOL_STRING_HTTPS ) / sizeof( WCHAR ) ) - 1



//
// metabase paths, properties, etc.
//

#define IIS_MD_W3SVC L"/LM/W3SVC"

#define IIS_MD_APP_POOLS L"/AppPools"

#define IIS_MD_VIRTUAL_SITE_ROOT L"/Root"


//
// BUGBUG All these need to move to iiscnfg.h eventually.
//

#define MD_APP_APPPOOL                              ( IIS_MD_HTTP_BASE + 111 )

#define IIS_MD_APPPOOL_BASE 9000

#define MD_APPPOOL_PERIODIC_RESTART_TIME            ( IIS_MD_APPPOOL_BASE + 1 )
#define MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT   ( IIS_MD_APPPOOL_BASE + 2 )
#define MD_APPPOOL_MAX_PROCESS_COUNT                ( IIS_MD_APPPOOL_BASE + 3 )
#define MD_APPPOOL_PINGING_ENABLED                  ( IIS_MD_APPPOOL_BASE + 4 )
#define MD_APPPOOL_IDLE_TIMEOUT                     ( IIS_MD_APPPOOL_BASE + 5 )



//
// Default values.
//

//
// BUGBUG Come up with real default settings. 
//

#define APPPOOL_PERIODIC_RESTART_TIME_DEFAULT               0   // i.e. disabled
#define APPPOOL_PERIODIC_RESTART_REQUEST_COUNT_DEFAULT      0   // i.e. disabled
#define APPPOOL_MAX_PROCESS_COUNT_DEFAULT                   1
#define APPPOOL_PINGING_ENABLED_DEFAULT                     0   // i.e. disabled
#define APPPOOL_IDLE_TIMEOUT_DEFAULT                        0   // i.e. disabled



//
// prototypes
//

class CONFIG_MANAGER
{

public:

    CONFIG_MANAGER(
        );

    ~CONFIG_MANAGER(
        );

    HRESULT
    Initialize(
        );


private:

    HRESULT
    ReadAllConfiguration(
        );

    HRESULT
    ReadAllAppPools(
        );

    HRESULT
    ReadAllVirtualSites(
		);

    HRESULT
    ReadApplications(
		BOOL * pValidRootApplicationExists
		);

	HRESULT
	GetTable(LPCWSTR	i_wszDatabase,
			 LPCWSTR	i_wszTable,
			 DWORD		i_fServiceRequests,
			 LPVOID		*o_ppIST
			 );

    DWORD m_Signature;

    BOOL m_CoInitialized;

	ISimpleTableDispenser2	*m_pISTDisp;

};  // class CONFIG_MANAGER



#endif  // _CONFIG_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\testcookdown\test.cpp ===
// Test.cpp - This is a test program to determine the perf of GetRowValues for the
// sdtfxd data table.

#include <unicode.h>
#include <windows.h>
#include <stdio.h>
#include <conio.h>

#define USE_NONCRTNEW
#define USE_ADMINASSERT
#include "comacros.h"

#define		REGSYSDEFNS_DEFINE
#include	"Catmeta.h"
#include	"catalog.h"
#include	"catalog_i.c"

// #include "Cooker.h"

STDAPI CookDown();

// Forward declaration
ULONG	GetNumOfIter(int argc, char **argv);
HRESULT	DisplayFromCookedDownCLB();
HRESULT	DisplayTable(ISimpleTableDispenser2*	i_pISTDisp,
					 REFGUID					i_did,
					 REFGUID					i_tid,
					 LPVOID						i_QueryData,	
					 LPVOID						i_QueryMeta,	
					 ULONG						i_eQueryFormat,
					 DWORD						i_fServiceRequests
					 );
LPCWSTR	g_wszCookDownFile		= L"D:\\Catalog42\\Drop\\WASMB.CLB";

int __cdecl main(int argc, char ** argv)
{
	ULONG		NumOfIter	= 0;
	HRESULT		hr;
	//CCooker 	*pCooker	= NULL;

	hr = CoInitialize(NULL);
	agoto_on_bad_hr (hr, Cleanup);

	NumOfIter = GetNumOfIter(argc, argv);
	agoto_on_fail(NumOfIter>=1, hr, E_INVALIDARG, Cleanup);

/*	wprintf (L"Creating CCooker\n");
	pCooker = new CCooker();

	if(NULL == pCooker)
	{
		wprintf (L"Could not create CCooker\n");
		hr = E_OUTOFMEMORY;
		goto Cleanup;
	}

	wprintf (L"Calling CookDown\n");
	hr = pCooker->CookDown();
	if(FAILED(hr))
	{
		wprintf (L"CookDown failed with hr = %08x\n", hr);
		goto Cleanup;
	}
	wprintf (L"CookDown succeeded\n");
*/
	wprintf (L"Calling CookDown\n");
	hr = CookDown();
	if(FAILED(hr))
	{
		wprintf (L"CookDown failed with hr = %08x\n", hr);
		goto Cleanup;
	}
	wprintf (L"CookDown succeeded\n");

	wprintf (L"Displaying from Cooked Down CLB\n");
	hr = DisplayFromCookedDownCLB();
	if(FAILED(hr))
	{
		wprintf (L"Displaying from Cooked Down CLB failed with hr = %08x\n", hr);
		goto Cleanup;
	}
	wprintf (L"Finished displaying from Cooked Down CLB\n");

Cleanup:

/*	if(NULL != pCooker)
	{
		wprintf (L"Deleting CCooker\n");
		delete pCooker;
	}
	wprintf (L"Done: press any key to exit.\n");
	_getche ();
*/
	CoUninitialize();		
	return 0;

}

ULONG GetNumOfIter(int argc, char **argv)
{
	ULONG	iter	= 1;

	for (int i=1; i<argc; i++)
	{
		char	*ptr;

		if(argv[i][0] != '-' && argv[i][0] != '/')
		{
			printf("\nUsage: TestPerfGetColumn -i<Num of Iterations(default=1)>\n");
			return 0;
		}

		ptr = argv[i];

		switch(ptr[1])
		{
		case 'i':
		case 'I':
			iter = atol(ptr + 2);
			break;
		default:
			printf("\nUsage: TestPerfGetColumn -i<Num of Iterations(default=1)>\n");
			return iter;		
		}
	}

	return iter;
}

HRESULT	DisplayFromCookedDownCLB()
{

	HRESULT					hr;
	ISimpleTableDispenser2*	pISTDisp = NULL;	
	ISimpleTableRead2*		pISTAppPool = NULL;
	ISimpleTableRead2*		pISTVirtualSite = NULL;
    STQueryCell				QueryCell[1];
	ULONG					cCell	= sizeof(QueryCell)/sizeof(STQueryCell);

	hr = CoCreateInstance (CLSID_STDispenser, NULL, CLSCTX_INPROC_SERVER, 
						   IID_ISimpleTableDispenser2, (void**) &pISTDisp);

	if(FAILED(hr))
	{
		wprintf (L"CoCreateInstance on  CLSID_STDispenser failed with hr = %08x\n", hr);
	}

    QueryCell[0].pData     = (LPVOID)g_wszCookDownFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(g_wszCookDownFile)+1)*sizeof(WCHAR);

	wprintf (L"Displaying AppPool Table\n");

	hr = DisplayTable(pISTDisp,
					  didURTGLOBAL,
					  tidAPPPOOLS,
					  QueryCell,
					  &cCell,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying AppPool Table. Failed with hr = %08x\n", hr);
	}

	wprintf (L"Displaying Virtual Site Table\n");

	hr = DisplayTable(pISTDisp,
					  didURTGLOBAL,
					  tidSITES,
					  QueryCell,
					  &cCell,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying Virtual Site Table. Failed with hr = %08x\n", hr);
	}

	wprintf (L"Displaying App Table\n");

	hr = DisplayTable(pISTDisp,
					  didURTGLOBAL,
					  tidAPPS,
					  QueryCell,
					  &cCell,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying App Table. Failed with hr = %08x\n", hr);
	}

	wprintf (L"Displaying File Time Table\n");

	hr = DisplayTable(pISTDisp,
					  didURTGLOBAL,
					  tidFILETIME,
					  QueryCell,
					  &cCell,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying Virtual Site Table. Failed with hr = %08x\n", hr);
	}

Cleanup:
	release_interface(pISTAppPool);
	release_interface(pISTVirtualSite);
	release_interface(pISTDisp);

	return hr;
}

HRESULT	DisplayTable(ISimpleTableDispenser2*	i_pISTDisp,
					 REFGUID					i_did,
					 REFGUID					i_tid,
					 LPVOID						i_QueryData,	
					 LPVOID						i_QueryMeta,	
					 ULONG						i_eQueryFormat,
					 DWORD						i_fServiceRequests
					 )
{
	HRESULT				hr;
	ISimpleTableRead2	*pISTRead = NULL;
	int					iRow=0;
	ULONG				cCol=0;
	LPVOID				*apv=NULL;
	ULONG				*acb=NULL;

	hr = i_pISTDisp->GetTable ( i_did, i_tid, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests,  
							   (void**)&pISTRead );
	if(FAILED(hr)){ goto Cleanup; }

	hr = pISTRead->GetTableMeta(NULL, NULL, NULL, &cCol);
	if(FAILED(hr)){ goto Cleanup; }
	if(cCol <= 0){ hr = E_ST_NOMORECOLUMNS; goto Cleanup;}

	apv = new LPVOID[cCol];
	if(NULL==apv){hr = E_OUTOFMEMORY; goto Cleanup;}

	acb = new ULONG[cCol];
	if(NULL==acb){hr = E_OUTOFMEMORY; goto Cleanup;}

	while ( pISTRead->MoveToRowByIndex(iRow) == S_OK )
	{		
		//Get the column data
		hr = pISTRead->GetColumnValues(cCol,NULL,acb, apv);
		if(FAILED(hr)){ goto Cleanup; }	
		
		for ( ULONG i=0; i<cCol; i++ )
		{
			LPWSTR	wsz;	
			DWORD	dbtype;
			SimpleColumnMeta stMeta;
			
			hr = pISTRead->GetColumnMeta( 1, (ULONG*)&i, &stMeta );	
			if(FAILED(hr)){ goto Cleanup; }
			
			dbtype = stMeta.dbType;

			//print the column data
			if ( !apv[i] )
				wprintf(L"\tColumn %d: NULL\n", i );
			else if ( dbtype == DBTYPE_BYTES )
			{
				ULONG* pul = (ULONG*)apv[i];
				wprintf(L"\tColumn %d:", i );
				
				if (apv[i])
				{
					for ( ULONG n = 0; n < acb[i]/4; n++ )
					{
						wprintf(L"%x ",  *pul);
						pul++;
					}
				}
					wprintf(L"\n");
			}
			else if ( dbtype == DBTYPE_WSTR )
			{
				wsz = (LPWSTR)apv[i];
				if (apv[i])
					wprintf(L"\tColumn %d: %s\n", i, wsz );
				else
					wprintf(L"\tColumn %d: \n", i);
			}
			else if ( dbtype == DBTYPE_UI4 )
			{
				if (apv[i] )
					wprintf(L"\tColumn %d: %d\n", i, *((ULONG*)apv[i]) );

			}
			else if( dbtype == DBTYPE_GUID )
			{
				GUID guid = *((GUID*)apv[i]);
				StringFromCLSID( guid, &wsz );
				wprintf(L"\tColumn %d: %s\n", i, wsz);
				CoTaskMemFree(wsz);
			}		
			
		} //for
		
		iRow++;
		wprintf(L"\n");
	
	} //while

	if(E_ST_NOMOREROWS == hr){ hr = S_OK; }

Cleanup:
	
	if(NULL != apv)
		delete[] apv;
	if(NULL != acb)
		delete[] acb;
	release_interface(pISTRead);
	return hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\testcookdown\config_manager.h ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    config_manager.h

Abstract:

    The IIS web admin service configuration manager class definition.

Author:

    Seth Pollack (sethp)        5-Jan-1999

Revision History:

--*/


#ifndef _CONFIG_MANAGER_H_
#define _CONFIG_MANAGER_H_



//
// common #defines
//

#define CONFIG_MANAGER_SIGNATURE        CREATE_SIGNATURE( 'CFGM' )
#define CONFIG_MANAGER_SIGNATURE_FREED  CREATE_SIGNATURE( 'cfgX' )


#define PROTOCOL_STRING_HTTP L"http://"

#define PROTOCOL_STRING_HTTP_CHAR_COUNT_SANS_TERMINATION                \
    ( sizeof( PROTOCOL_STRING_HTTP ) / sizeof( WCHAR ) ) - 1

#define PROTOCOL_STRING_HTTPS L"https://"

#define PROTOCOL_STRING_HTTPS_CHAR_COUNT_SANS_TERMINATION               \
    ( sizeof( PROTOCOL_STRING_HTTPS ) / sizeof( WCHAR ) ) - 1



//
// metabase paths, properties, etc.
//

#define IIS_MD_W3SVC L"/LM/W3SVC"

#define IIS_MD_APP_POOLS L"/AppPools"

#define IIS_MD_VIRTUAL_SITE_ROOT L"/Root"


//
// BUGBUG All these need to move to iiscnfg.h eventually.
//

#define MD_APP_APPPOOL                              ( IIS_MD_HTTP_BASE + 111 )

#define IIS_MD_APPPOOL_BASE 9000

#define MD_APPPOOL_PERIODIC_RESTART_TIME            ( IIS_MD_APPPOOL_BASE + 1 )
#define MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT   ( IIS_MD_APPPOOL_BASE + 2 )
#define MD_APPPOOL_MAX_PROCESS_COUNT                ( IIS_MD_APPPOOL_BASE + 3 )
#define MD_APPPOOL_PINGING_ENABLED                  ( IIS_MD_APPPOOL_BASE + 4 )
#define MD_APPPOOL_IDLE_TIMEOUT                     ( IIS_MD_APPPOOL_BASE + 5 )



//
// Default values.
//

//
// BUGBUG Come up with real default settings. 
//

#define APPPOOL_PERIODIC_RESTART_TIME_DEFAULT               0   // i.e. disabled
#define APPPOOL_PERIODIC_RESTART_REQUEST_COUNT_DEFAULT      0   // i.e. disabled
#define APPPOOL_MAX_PROCESS_COUNT_DEFAULT                   1
#define APPPOOL_PINGING_ENABLED_DEFAULT                     0   // i.e. disabled
#define APPPOOL_IDLE_TIMEOUT_DEFAULT                        0   // i.e. disabled



//
// prototypes
//

class CONFIG_MANAGER
{

public:

    CONFIG_MANAGER(
        );

    ~CONFIG_MANAGER(
        );

    HRESULT
    Initialize(
        );


private:

    HRESULT
    ReadAllConfiguration(
        );

    HRESULT
    ReadAllAppPools(
        );

    HRESULT
    ReadAllVirtualSites(
		);

    HRESULT
    ReadApplications(
		BOOL * pValidRootApplicationExists
		);

	HRESULT
	GetTable(REFGUID	i_did,
			 REFGUID	i_tid,
			 DWORD		i_fServiceRequests,
			 LPVOID		*o_ppIST
			 );

    DWORD m_Signature;

    BOOL m_CoInitialized;

	ISimpleTableDispenser2	*m_pISTDisp;

};  // class CONFIG_MANAGER



#endif  // _CONFIG_MANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\testcookdown\testcfgmgr.cpp ===
// Test.cpp - This is a test program to determine the perf of GetRowValues for the
// sdtfxd data table.

#include <unicode.h>
#include <windows.h>
#include <stdio.h>
#include <conio.h>

#include	"catalog.h"
#include	"catmeta.h"
#include	"catmacros.h"

DECLARE_DEBUG_PRINTS_OBJECT();

#define		REGSYSDEFNS_DEFINE
#define		TABLEINFO_SELECT 
#define		DEFINE_GUID_FOR_DIDIIS  
#define		DEFINE_GUID_FOR_TIDAPPPOOLS  
#define		DEFINE_GUID_FOR_TIDSITES  
#define		DEFINE_GUID_FOR_TIDAPPS  
#define		DEFINE_GUID_FOR_TIDFILETIME 
#define		DEFINE_GUID_FOR_TIDFILELIST 
#include	"Catmeta.h"
#include	"catmacros.h"

#include "ConfigMgr.h"

// Forward declaration
ULONG	GetNumOfIter(int argc, char **argv);
HRESULT	DisplayFromCookedDownCLB();
HRESULT	DisplayFromXMLFiles();
HRESULT DisplayBug();
HRESULT	WriteToMetabase();
HRESULT	DisplayTable(ISimpleTableDispenser2*	i_pISTDisp,
					 LPCWSTR					i_wszDatabase,
					 LPCWSTR					i_wszTable,
					 LPVOID						i_QueryData,	
					 LPVOID						i_QueryMeta,	
					 ULONG						i_eQueryFormat,
					 DWORD						i_fServiceRequests
					 );
extern LPCWSTR	g_wszCookDownFile;//		= L"D:\\Catalog42\\Drop\\WASMB.CLB";
HINSTANCE g_hModule=0;

int __cdecl main(int argc, char ** argv)
{
    g_hModule=GetModuleHandle(0);

	ULONG			NumOfIter	= 0;
	HRESULT			hr;
	CONFIG_MANAGER 	*pCfgMgr	= NULL;

	//hr = CoInitialize(NULL);
	//agoto_on_bad_hr (hr, Cleanup);

	NumOfIter = GetNumOfIter(argc, argv);
	if(NumOfIter < 1)
	{
		hr = E_INVALIDARG;
		goto Cleanup;
	}

	wprintf (L"Creating CONFIG_MANAGER\n");
	pCfgMgr = new CONFIG_MANAGER();

	if(NULL == pCfgMgr)
	{
		wprintf (L"Could not create CONFIG_MANAGER\n");
		hr = E_OUTOFMEMORY;
		goto Cleanup;
	}

	wprintf (L"Calling Initialize\n");
	hr = pCfgMgr->Initialize();
	if(FAILED(hr))
	{
		wprintf (L"Initialize failed with hr = %08x\n", hr);
		goto Cleanup;
	}
	wprintf (L"Initialize succeeded\n");

//	wprintf (L"Displaying from XML Files\n");
//	hr = DisplayFromXMLFiles();
//	if(FAILED(hr))
//	{
//		wprintf (L"Displaying from XML Files failed with hr = %08x\n", hr);
//		goto Cleanup;
//	}
//	wprintf (L"Finished displaying from XML Files\n");

	wprintf (L"Displaying from Cooked Down CLB\n");
	hr = DisplayFromCookedDownCLB();
	if(FAILED(hr))
	{
		wprintf (L"Displaying from Cooked Down CLB failed with hr = %08x\n", hr);
		goto Cleanup;
	}
	wprintf (L"Finished displaying from Cooked Down CLB\n");

//	wprintf (L"Displaying Bug\n");
//	hr = DisplayBug();
//	wprintf (L"Finished displaying Bug\n");

	wprintf(L"Writing to Metabase");
	hr = WriteToMetabase();
	wprintf (L"Finished Writing to XML Files\n");


Cleanup:

	if(NULL != pCfgMgr)
	{
		wprintf (L"Deleting CONFIG_MANAGER\n");
		delete pCfgMgr;
	}
/*	wprintf (L"Done: press any key to exit.\n");
	_getche ();
*/
	//CoUninitialize();		
	return 0;

}

ULONG GetNumOfIter(int argc, char **argv)
{
	ULONG	iter	= 1;

	for (int i=1; i<argc; i++)
	{
		char	*ptr;

		if(argv[i][0] != '-' && argv[i][0] != '/')
		{
			printf("\nUsage: TestPerfGetColumn -i<Num of Iterations(default=1)>\n");
			return 0;
		}

		ptr = argv[i];

		switch(ptr[1])
		{
		case 'i':
		case 'I':
			iter = atol(ptr + 2);
			break;
		default:
			printf("\nUsage: TestPerfGetColumn -i<Num of Iterations(default=1)>\n");
			return iter;		
		}
	}

	return iter;
}

HRESULT	DisplayFromCookedDownCLB()
{

	HRESULT					hr;
	ISimpleTableDispenser2*	pISTDisp = NULL;	
	ISimpleTableRead2*		pISTAppPool = NULL;
	ISimpleTableRead2*		pISTVirtualSite = NULL;
    STQueryCell				QueryCell[1];
	ULONG					cCell	= sizeof(QueryCell)/sizeof(STQueryCell);

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
	{
		wprintf (L"CoCreateInstance on  CLSID_STDispenser failed with hr = %08x\n", hr);
	}

    QueryCell[0].pData     = (LPVOID)g_wszCookDownFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(g_wszCookDownFile)+1)*sizeof(WCHAR);

	wprintf (L"Displaying %s Table\n", wszTABLE_APPPOOLS);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_APPPOOLS,
					  NULL,
					  NULL,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
	}

	wprintf (L"Displaying %s Table\n", wszTABLE_SITES);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_SITES,
					  NULL,
					  NULL,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_SITES, hr);
	}


	wprintf (L"Displaying %s Table\n", wszTABLE_APPS);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_APPS,
					  NULL,
					  NULL,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_APPS, hr);
	}

	wprintf (L"Displaying %s Table\n", wszTABLE_GlobalW3SVC);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_GlobalW3SVC,
					  NULL,
					  NULL,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_GlobalW3SVC, hr);
	}

	wprintf (L"Displaying %s Table\n", wszTABLE_CHANGENUMBER);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_CHANGENUMBER,
					  NULL,
					  NULL,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_CHANGENUMBER, hr);
	}

//	wprintf (L"Displaying %s Table\n", wszTABLE_COLUMNMETA);

//	hr = DisplayTable(pISTDisp,
//					  wszDATABASE_META,
//					  wszTABLE_COLUMNMETA,
//					  NULL,
//					  NULL,
//					  eST_QUERYFORMAT_CELLS,
//					  0);

//	if(FAILED(hr))
//	{
//		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_COLUMNMETA, hr);
//	}

Cleanup:

	if(NULL != pISTAppPool)
	{
		pISTAppPool->Release();
	}
	if(NULL != pISTVirtualSite)
	{
		pISTVirtualSite->Release();
	}
	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
	}

	return hr;
}

HRESULT	WriteToMetabase()
{
	HRESULT					hr;
	ISimpleTableDispenser2*	pISTDisp = NULL;	
	ISimpleTableWrite2*		pISTWriteAppPool = NULL;	
	ISimpleTableWrite2*		pISTWriteSite = NULL;	
	ISimpleTableWrite2*		pISTWriteApp = NULL;	
	LPWSTR					wszAppPoolID = L"AppPoolWrite";
	DWORD					dwSiteID  = 1;
	DWORD					dwWin32Err  = 99;
	DWORD					dwServerState  = 88;
	LPWSTR					wszAppRelURL = L"/";
	DWORD					dwAutoStart  = 0;
	ULONG					iWrite = 0;
	ULONG					aiColAppPool[] = {0};
	ULONG					aiColSite[] = {0,16,17};
	ULONG					aiColApp[] = {0,1,5};


	LPVOID					aColValAppPool[] = { (LPVOID)wszAppPoolID,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL

									};

	LPVOID					aColValSite[] = { (LPVOID)&dwSiteID,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  NULL,
										  (LPVOID)&dwWin32Err,
										  (LPVOID)&dwServerState
						
									};

	LPVOID					aColValApp[] = { (LPVOID)wszAppRelURL,
										  (LPVOID)&dwSiteID,
										  NULL,
										  NULL,
										  NULL,
										  (LPVOID)&dwAutoStart
						
									};

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);
	if(FAILED(hr))
	{
		wprintf (L"CoCreateInstance on  CLSID_STDispenser failed with hr = %08x\n", hr);
		goto Cleanup;
	}


	hr = pISTDisp->GetTable (wszDATABASE_IIS, 
							   wszTABLE_APPPOOLS, 
							   NULL, 
							   NULL, 
							   eST_QUERYFORMAT_CELLS, 
							   fST_LOS_READWRITE | fST_LOS_UNPOPULATED,  
							   (void**)&pISTWriteAppPool );
	if(FAILED(hr))
	{
		wprintf (L"GetTable on  %s failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
		goto Cleanup;
	}

	hr = pISTWriteAppPool->AddRowForInsert(&iWrite);
	if(FAILED(hr))
	{
		wprintf (L"AddRowForInsert on  %s failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
		goto Cleanup;
	}

	hr = pISTWriteAppPool->SetWriteColumnValues(iWrite,
							             sizeof(aiColAppPool)/sizeof(ULONG),
							             aiColAppPool,
							             NULL,
							             aColValAppPool);
	if(FAILED(hr))
	{
		wprintf (L"SetWriteColumnValues on  %s failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
		goto Cleanup;
	}

	hr = pISTWriteAppPool->UpdateStore();
	if(FAILED(hr))
	{
		wprintf (L"UpdateStore on  %s failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
		goto Cleanup;
	}

	hr = pISTDisp->GetTable (wszDATABASE_IIS, 
							   wszTABLE_SITES, 
							   NULL, 
							   NULL, 
							   eST_QUERYFORMAT_CELLS, 
							   fST_LOS_READWRITE | fST_LOS_UNPOPULATED,  
							   (void**)&pISTWriteSite );
	if(FAILED(hr))
	{
		wprintf (L"GetTable on  %s failed with hr = %08x\n", wszTABLE_SITES, hr);
		goto Cleanup;
	}

	hr = pISTWriteSite->AddRowForInsert(&iWrite);
	if(FAILED(hr))
	{
		wprintf (L"AddRowForInsert on  %s failed with hr = %08x\n", wszTABLE_SITES, hr);
		goto Cleanup;
	}

	hr = pISTWriteSite->SetWriteColumnValues(iWrite,
							             sizeof(aiColSite)/sizeof(ULONG),
							             aiColSite,
							             NULL,
							             aColValSite);
	if(FAILED(hr))
	{
		wprintf (L"SetWriteColumnValues on  %s failed with hr = %08x\n", wszTABLE_SITES, hr);
		goto Cleanup;
	}

	hr = pISTWriteSite->UpdateStore();
	if(FAILED(hr))
	{
		wprintf (L"UpdateStore on  %s failed with hr = %08x\n", wszTABLE_SITES, hr);
		goto Cleanup;
	}

	hr = pISTDisp->GetTable (wszDATABASE_IIS, 
							   wszTABLE_APPS, 
							   NULL, 
							   NULL, 
							   eST_QUERYFORMAT_CELLS, 
							   fST_LOS_READWRITE | fST_LOS_UNPOPULATED,  
							   (void**)&pISTWriteApp );
	if(FAILED(hr))
	{
		wprintf (L"GetTable on  %s failed with hr = %08x\n", wszTABLE_APPS, hr);
		goto Cleanup;
	}

	hr = pISTWriteApp->AddRowForInsert(&iWrite);
	if(FAILED(hr))
	{
		wprintf (L"AddRowForInsert on  %s failed with hr = %08x\n", wszTABLE_APPS, hr);
		goto Cleanup;
	}

	hr = pISTWriteApp->SetWriteColumnValues(iWrite,
							             sizeof(aiColApp)/sizeof(ULONG),
							             aiColApp,
							             NULL,
							             aColValApp);
	if(FAILED(hr))
	{
		wprintf (L"SetWriteColumnValues on  %s failed with hr = %08x\n", wszTABLE_APPS, hr);
		goto Cleanup;
	}

	hr = pISTWriteApp->UpdateStore();
	if(FAILED(hr))
	{
		wprintf (L"UpdateStore on  %s failed with hr = %08x\n", wszTABLE_APPS, hr);
		goto Cleanup;
	}

Cleanup:

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
	}
	if(NULL != pISTWriteAppPool)
	{
		pISTWriteAppPool->Release();
	}
	if(NULL != pISTWriteSite)
	{
		pISTWriteSite->Release();
	}
	if(NULL != pISTWriteApp)
	{
		pISTWriteApp->Release();
	}

	return hr;
}

HRESULT	DisplayFromXMLFiles()
{

	HRESULT					hr;
	ISimpleTableDispenser2*	pISTDisp = NULL;	
    STQueryCell				QueryCell[2];
	ULONG					cCell	= sizeof(QueryCell)/sizeof(STQueryCell);
	LPWSTR					wszAppPoolID = L"AppPool21";
	ULONG					iLOS = 0;

    QueryCell[0].pData     = (LPVOID)L"D:\\WINNT\\XSPDT\\MACHINE.CFG";
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(L"D:\\WINNT\\XSPDT\\MACHINE.CFG")+1)*sizeof(WCHAR);

    QueryCell[1].pData     = (LPVOID)wszAppPoolID;
    QueryCell[1].eOperator = eST_OP_EQUAL;
    QueryCell[1].iCell     = iAPPPOOLS_AppPoolID;
    QueryCell[1].dbType    = DBTYPE_WSTR;
    QueryCell[1].cbSize    = (lstrlenW(wszAppPoolID)+1)*sizeof(WCHAR);

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
	{
		wprintf (L"CoCreateInstance on  CLSID_STDispenser failed with hr = %08x\n", hr);
		goto Cleanup;
	}

	wprintf (L"Displaying %s Table with NULL Query. Should fail with hr = %08x\n", wszTABLE_APPPOOLS, E_ST_INVALIDQUERY);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_APPPOOLS,
					  NULL,
					  NULL,
					  eST_QUERYFORMAT_CELLS,
					  0);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
	}

	iLOS = 0;

	wprintf (L"Displaying %s Table with LOS = %08x, valid query AppPoolID = %s\n", wszTABLE_APPPOOLS, iLOS, wszAppPoolID);

	cCell--;

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_APPPOOLS,
					  &(QueryCell[1]),
					  &cCell,
					  eST_QUERYFORMAT_CELLS,
					  iLOS);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
	}

	iLOS = fST_LOS_COOKDOWN | fST_LOS_READWRITE;

	wprintf (L"Displaying %s Table with LOS = %08x, valid query AppPoolID = %s\n", wszTABLE_APPPOOLS, iLOS, wszAppPoolID);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_APPPOOLS,
					  &(QueryCell[1]),
					  &cCell,
					  eST_QUERYFORMAT_CELLS,
					  iLOS);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
	}

	cCell++;

	iLOS = 0;

	wprintf (L"Displaying %s Table with LOS = %08x, valid query AppPoolID = %s, FileName = %s\n", wszTABLE_APPPOOLS, iLOS, wszAppPoolID, g_wszCookDownFile);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_APPPOOLS,
					  QueryCell,
					  &cCell,
					  eST_QUERYFORMAT_CELLS,
					  iLOS);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
	}

	iLOS = fST_LOS_COOKDOWN | fST_LOS_READWRITE;

	wprintf (L"Displaying %s Table with LOS = %08x, valid query AppPoolID = %s, FileName = %s\n", wszTABLE_APPPOOLS, iLOS, wszAppPoolID, g_wszCookDownFile);

	hr = DisplayTable(pISTDisp,
					  wszDATABASE_IIS,
					  wszTABLE_APPPOOLS,
					  QueryCell,
					  &cCell,
					  eST_QUERYFORMAT_CELLS,
					  iLOS);

	if(FAILED(hr))
	{
		wprintf (L"Error Displaying %s Table. Failed with hr = %08x\n", wszTABLE_APPPOOLS, hr);
	}



Cleanup:

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
	}

	return hr;
}

HRESULT	DisplayTable(ISimpleTableDispenser2*	i_pISTDisp,
					 LPCWSTR					i_wszDatabase,
					 LPCWSTR					i_wszTable,
					 LPVOID						i_QueryData,	
					 LPVOID						i_QueryMeta,	
					 ULONG						i_eQueryFormat,
					 DWORD						i_fServiceRequests
					 )
{
	HRESULT				hr;
	ISimpleTableRead2	*pISTRead = NULL;
	int					iRow=0;
	ULONG				cCol=0;
	LPVOID				*apv=NULL;
	ULONG				*acb=NULL;
	LPWSTR				wszOneBigURLPrefix=NULL;
	LPWSTR				wszURLPrefix=NULL;

	hr = i_pISTDisp->GetTable ( i_wszDatabase, i_wszTable, i_QueryData, i_QueryMeta, i_eQueryFormat, i_fServiceRequests,  
							   (void**)&pISTRead );
	if(FAILED(hr)){ goto Cleanup; }

	hr = pISTRead->GetTableMeta(NULL, NULL, NULL, &cCol);
	if(FAILED(hr)){ goto Cleanup; }
	if(cCol <= 0){ hr = E_ST_NOMORECOLUMNS; goto Cleanup;}

	apv = new LPVOID[cCol];
	if(NULL==apv){hr = E_OUTOFMEMORY; goto Cleanup;}

	acb = new ULONG[cCol];
	if(NULL==acb){hr = E_OUTOFMEMORY; goto Cleanup;}

	while ( pISTRead->GetColumnValues(iRow, cCol,NULL,acb, apv) == S_OK )
	{		
		
		for ( ULONG i=0; i<cCol; i++ )
		{
			LPWSTR	wsz;	
			DWORD	dbtype;
			SimpleColumnMeta stMeta;
			
			hr = pISTRead->GetColumnMetas( 1, (ULONG*)&i, &stMeta );	
			if(FAILED(hr)){ goto Cleanup; }
			
			dbtype = stMeta.dbType;

			//print the column data
			if ( !apv[i] )
				wprintf(L"\tColumn %d: NULL\n", i );
			else if ( dbtype == DBTYPE_BYTES )
			{				
				if((0 == lstrcmpiW(wszTABLE_SITES,i_wszTable)) && (i == iSITES_Bindings))
				{
					wszOneBigURLPrefix = (LPWSTR) (apv[i]);

					while ((wszURLPrefix = wcschr(wszOneBigURLPrefix, L',')) != NULL)
					{

			//	        Success = UrlPrefixes.Append( (WCHAR *) (apvSiteValues[iSITES_URLPrefixes]) );
						*wszURLPrefix = 0;
						wprintf(L"\tColumn %d: %s\n", i, wszOneBigURLPrefix );
						*wszURLPrefix = L',';
						wszURLPrefix++;
						wszOneBigURLPrefix = wszURLPrefix;

					}

					if (wszOneBigURLPrefix[i])
						wprintf(L"\tColumn %d: %s\n", i, wszOneBigURLPrefix );
					else
						wprintf(L"\tColumn %d: \n", i);
					
				}
				else if (apv[i])
				{
					ULONG* pul = (ULONG*)apv[i];
					wprintf(L"\tColumn %d:", i );

					for ( ULONG n = 0; n < acb[i]/4; n++ )
					{
						wprintf(L"%x ",  *pul);
						pul++;
					}
				}
					wprintf(L"\n");
			}
			else if ( dbtype == DBTYPE_WSTR )
			{
				// For the multisz column in the sites table
				if((0 == lstrcmpiW(wszTABLE_SITES,i_wszTable)) && (i == iSITES_Bindings))
				{
					wszOneBigURLPrefix = (LPWSTR) (apv[i]);

					while ((wszURLPrefix = wcschr(wszOneBigURLPrefix, L',')) != NULL)
					{

			//	        Success = UrlPrefixes.Append( (WCHAR *) (apvSiteValues[iSITES_URLPrefixes]) );
						*wszURLPrefix = 0;
						wprintf(L"\tColumn %d: %s\n", i, wszOneBigURLPrefix );
						*wszURLPrefix = L',';
						wszURLPrefix++;
						wszOneBigURLPrefix = wszURLPrefix;

					}

					if (wszOneBigURLPrefix[i])
						wprintf(L"\tColumn %d: %s\n", i, wszOneBigURLPrefix );
					else
						wprintf(L"\tColumn %d: \n", i);
					
				}
				else
				{
					wsz = (LPWSTR)apv[i];
					if (apv[i])
						wprintf(L"\tColumn %d: %s\n", i, wsz );
					else
						wprintf(L"\tColumn %d: \n", i);
				}
			}
			else if ( dbtype == DBTYPE_UI4 )
			{
				if (apv[i] )
					wprintf(L"\tColumn %d: %d\n", i, *((ULONG*)apv[i]) );

			}
			else if( dbtype == DBTYPE_GUID )
			{
				GUID guid = *((GUID*)apv[i]);
				StringFromCLSID( guid, &wsz );
				wprintf(L"\tColumn %d: %s\n", i, wsz);
				CoTaskMemFree(wsz);
			}		
			
		} //for
		
		iRow++;
		wprintf(L"\n");
	
	} //while

	if(E_ST_NOMOREROWS == hr){ hr = S_OK; }

Cleanup:
	
	if(NULL != apv)
		delete[] apv;
	if(NULL != acb)
		delete[] acb;
	if(NULL != pISTRead)
	{
		pISTRead->Release();
	}

	return hr;

}

HRESULT DisplayBug()
{
	HRESULT					hr;
	ISimpleTableDispenser2*	pISTDisp = NULL;	
	ISimpleTableRead2*		pISTSite = NULL;
	int						i		= 0;

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
	{
		wprintf (L"CoCreateInstance on  CLSID_STDispenser failed with hr = %08x\n", hr);
	}

	wprintf (L"Displaying %s Table\n", wszTABLE_SITES);

	hr = pISTDisp->GetTable ( wszDATABASE_IIS, wszTABLE_SITES, NULL, NULL, eST_QUERYFORMAT_CELLS, 0,  
							   (void**)&pISTSite );
	if(FAILED(hr)){ goto exit; }

	for (i = 0;; i++)
	{

		static const ULONG				aiSiteColumns []	= { 
															  iSITES_SiteID, 
															  iSITES_Bindings	
															};
		static const ULONG				cSiteColumns		= sizeof (aiSiteColumns) / sizeof (ULONG);
		static const ULONG				cmaxSiteColumns		= cSITES_NumberOfColumns;
		void*							apvSiteValues [cmaxSiteColumns];
		ULONG							acbSiteValues [cmaxSiteColumns];
  
		hr = pISTSite->GetColumnValues (
										  i,
										  cSiteColumns, 
										  (ULONG *)aiSiteColumns, 
										  (ULONG *)acbSiteValues, 
										  apvSiteValues
										);

		if (E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if ( FAILED( hr ) )
		{
    
		}
		else
		{
			wprintf (L"Site ID : %d\n", (*(DWORD *)(apvSiteValues[iSITES_SiteID])));
			wprintf (L"Site Bindings: %s\n", (WCHAR *)(apvSiteValues[iSITES_Bindings]));

		}
	}

exit:

	if(NULL != pISTDisp)
	{
		pISTDisp->Release();
		pISTDisp = NULL;
	}
	if(NULL != pISTSite)
	{
		pISTSite->Release();
		pISTSite = NULL;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\errorlog.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  ALL TUX DLLs
//  Copyright (c) 1998, Microsoft Corporation
//
//  Module:  ErrorLog.cpp
//           This is a set of classes used to log errors.  There is a test to
//           start the logging.  Every test after that will have its errors
//           logged and after the last test of a suite, the Output/Stop logging
//           test should be run to output the log.  This is most useful for BVTs
//           or any other suite that has many test.  The log will act as a summary
//           of the errors encountered during that suite.
//
//  Revision History:
//      05/25/1998  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"


bool            ErrorLogEntry::m_bLogging = false;
ErrorLogEntry * ErrorLogEntry::m_pFirst = NULL;
ErrorLogEntry * ErrorLogEntry::m_pLast  = NULL;
ErrorLogEntry * ErrorLogEntry::m_pDefered = NULL;
bool            ErrorLogEntry::m_bDeferOutput = false;
LPCTSTR         ErrorLogEntry::m_szFormatString[]= {TEXT("FAIL: Source Module (%s)\r\n      Failure Condition %x = %s\r\n      Line Number %d"),
                                                    TEXT("FAIL: Source Module (%s)\r\n      Failure Condition %s\r\n      Line Number %d"),
                                                    TEXT("FAIL: (HPURAID #%d) Source Module (%s)\r\n      Failure Condition %x = %s\r\n      Line Number %d"),
                                                    TEXT("FAIL: (HPURAID #%d) Source Module (%s)\r\n      Failure Condition %s\r\n      Line Number %d")};



ErrorLogEntry::ErrorLogEntry(int nLineNumber, LPCTSTR szSourceModule, LPCTSTR szSourceCodeText, DWORD dwError, int nKnownBugNumber)
                : m_dwError(dwError), m_nLineNumber(nLineNumber), m_szSourceModule(szSourceModule), m_szSourceCodeText(szSourceCodeText),
                m_pNext(NULL), m_pPrev(NULL), m_nKnownBugNumber(nKnownBugNumber)
{
    if(m_pFirst)
    {//Put ourself at the end of the linked list
        m_pLast->m_pNext = this;
        m_pPrev = m_pLast;
        m_pLast = this;
    }
    else//Otherwise this is the first and last entry in the list
    {
        m_pFirst = this;
        m_pLast = this;
    }
    m_nFormatStyle =  (m_dwError ?          0x00 : 0x01);
    m_nFormatStyle |= (m_nKnownBugNumber ?  0x02 : 0x00);
}


ErrorLogEntry::~ErrorLogEntry()
{
    //We only support taking that last one out of the list.
    if(this == m_pFirst)
    {
        m_pFirst = NULL;
        m_pLast = NULL;
    }
    else
    {
        ASSERT(this == m_pLast);
        ErrorLogEntry *pTheNewLastError = m_pLast->m_pPrev;
        pTheNewLastError->m_pNext = NULL;
        m_pLast = pTheNewLastError;
    }
}

void ErrorLogEntry::RemoveLast()
{
    delete m_pLast;
}

void ErrorLogEntry::OutputAndDeleteErrorLog()
{
    ErrorLogEntry *pCurrent = m_pFirst;
    if(pCurrent)
    {
        Debug(TEXT("\t_____________________________________________________________________________________________________________________"));
        Debug(TEXT("\t_________________________________________Error Summary_______________________________________________________________"));
        Debug(TEXT("\t_____________________________________________________________________________________________________________________\r\n"));
        while(pCurrent)
        {
            pCurrent->OutputLogEntry();//Output the entry
            pCurrent = pCurrent->m_pNext;//then get the pointer to the next one in the list
            delete m_pFirst;//then delete the one we just output
            m_pFirst = pCurrent;//now make the new one the current one
        }
        m_pLast = NULL;
        Debug(TEXT("\t_____________________________________________________________________________________________________________________"));
        Debug(TEXT("\t_________________________________________End Error Summary___________________________________________________________"));
        Debug(TEXT("\t_____________________________________________________________________________________________________________________\r\n"));
    }
    else
    {
        Debug(TEXT("\t_____________________________________________________________________________________________________________________"));
        Debug(TEXT("\t_________________________________________No Errors In Log____________________________________________________________"));
        Debug(TEXT("\t_____________________________________________________________________________________________________________________\r\n"));
    }
}

void ErrorLogEntry::StartLogging()
{
    m_bLogging = true;
}


void ErrorLogEntry::StopLogging()
{
    m_bLogging = false;
}

void ErrorLogEntry::DeferOutput(bool bDefer)
{
    ASSERT(m_bDeferOutput != bDefer);
    if(!bDefer && m_pDefered)//If turning Defer OFF then output all of the errors since the Defer began
    {
        ErrorLogEntry *pCurrent = m_pDefered->m_pNext;//Start with the first error AFTER deferring began
        while(pCurrent)
        {
            pCurrent->OutputLogEntry();//Output the entry
            pCurrent = pCurrent->m_pNext;//then get the pointer to the next one in the list
        }
    }
    m_pDefered = bDefer ? m_pLast : NULL;
    m_bDeferOutput = bDefer;
}

void ErrorLogEntry::RemoveDeferedErrors()
{
    ASSERT(m_bDeferOutput);
    while(m_pLast != m_pDefered)
        RemoveLast();//Remove the last error until the last error is the last one before deferring began
}

void ErrorLogEntry::NewError(int nLineNumber, LPCTSTR szSourceModule, LPCTSTR szSourceCodeText, DWORD dwError, int nKnownBugNumber)
{
    if(m_bLogging)
    {
        ErrorLogEntry *pThis = new ErrorLogEntry(nLineNumber, szSourceModule, szSourceCodeText, dwError, nKnownBugNumber);
        if(!m_bDeferOutput)
            pThis->OutputLogEntry();
    }
    else
    {
        if(m_bDeferOutput)
            ErrorLogEntry *pThis = new ErrorLogEntry(nLineNumber, szSourceModule, szSourceCodeText, dwError, nKnownBugNumber);
        else
        {
            int nFormatStyle = (dwError ?          0x00 : 0x01);
            nFormatStyle |=    (nKnownBugNumber ?  0x02 : 0x00);
            switch(nFormatStyle)
            {
                case 0: Debug(ErrorLogEntry::m_szFormatString[0],  szSourceModule, dwError, szSourceCodeText, nLineNumber);break;
                case 1: Debug(ErrorLogEntry::m_szFormatString[1],  szSourceModule, szSourceCodeText, nLineNumber);break;
                case 2: Debug(ErrorLogEntry::m_szFormatString[2],  nKnownBugNumber, szSourceModule, dwError, szSourceCodeText, nLineNumber);break;
                case 3: Debug(ErrorLogEntry::m_szFormatString[3],  nKnownBugNumber, szSourceModule, szSourceCodeText, nLineNumber);break;
            }
        }
    }
}


void ErrorLogEntry::OutputLogEntry()
{
    switch(m_nFormatStyle)
    {
        case 0: Debug(ErrorLogEntry::m_szFormatString[0],  m_szSourceModule, m_dwError, m_szSourceCodeText, m_nLineNumber);break;
        case 1: Debug(ErrorLogEntry::m_szFormatString[1],  m_szSourceModule, m_szSourceCodeText, m_nLineNumber);break;
        case 2: Debug(ErrorLogEntry::m_szFormatString[2],  m_nKnownBugNumber, m_szSourceModule, m_dwError, m_szSourceCodeText, m_nLineNumber);break;
        case 3: Debug(ErrorLogEntry::m_szFormatString[3],  m_nKnownBugNumber, m_szSourceModule, m_szSourceCodeText, m_nLineNumber);break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\testmngdist\testmist.cpp ===
#import <mscorlib.dll>
#import "MngdIST.dll"

using namespace System;
using namespace System::IO;
using namespace System::Configuration::Internal;
using namespace System::Runtime::InteropServices;


void _cdecl main()
{

// Create the dispenser

	Console::WriteLine(L"Creating ConfigurationDispenser");
	ConfigurationDispenser *CDisp = new ConfigurationDispenser();
	ConfigurationDispenser *CDisp2 = new ConfigurationDispenser();

////////////////////////////////////////////////////////////////////////////////////////
// Test the ISimpleTableRead interface using managed parameters
////////////////////////////////////////////////////////////////////////////////////////

// Create a query structure
// TODO: tids and dids will change to strings

	String *did		= new String(L"URTGLOBAL");
	String *tidXML	= new String(L"APPPOOL_CFG");
	String *tidCLB	= new String(L"APPPOOLS");

	String *didMeta	= new String(L"META");
	String *tidCMeta= new String(L"COLUMNMETA");

	__gc  QueryCell	*queryCellXML[]	= new __gc QueryCell*[1];
	queryCellXML[0]							= new QueryCell();
	String *strXML							= new String(L"AppPool.XML");

	queryCellXML[0]->objData	= strXML;
	queryCellXML[0]->eOperator	= 2;			// eST_OP_EQUAL
	queryCellXML[0]->iCol		= 0xF0000001;	// iST_CELL_FILE

	__gc  QueryCell	*queryCellCLB[]	= new __gc QueryCell*[1];
	queryCellCLB[0]							= new QueryCell();
	String *strCLB							= new String(L"AppPool.CLB");

	queryCellCLB[0]->objData	= strCLB;
	queryCellCLB[0]->eOperator	= 2;			// eST_OP_EQUAL
	queryCellCLB[0]->iCol		= 0xF0000001;	// iST_CELL_FILE

// GetConfigurationCollection

	Console::Write(L"The machine config dir is = ");
	Console::WriteLine(ConfigManagerHelper::GetMachineConfigDirectory());

	Console::WriteLine(L"Calling ConfigurationDispenser::GetConfigurationCollection on APPPOOL Collection in APPPOOL.XML");
	ConfigurationCollection *CCfgCollXML = CDisp->GetConfigurationCollection(did, tidXML, queryCellXML);

	Console::WriteLine(L"Calling ConfigurationDispenser::GetConfigurationCollection COLUMNMETA Collection in WIRING");
	ConfigurationCollection *CCfgCollXML1 = CDisp->GetConfigurationCollection(didMeta, tidCMeta, 0);

	Console::WriteLine(L"Calling ConfigurationDispenser::GetConfigurationCollection 2nd time on COLUMNMETA Collection in WIRING");
	ConfigurationCollection *CCfgCollXML2 = CDisp->GetConfigurationCollection(didMeta, tidCMeta, 0);

	Console::WriteLine(L"Calling ConfigurationDispenser::GetConfigurationCollection on APPPOOL Collection in APPPOOL.CLB");
	ConfigurationCollection *CCfgCollCLB = CDisp->GetConfigurationCollection(did, tidCLB, queryCellCLB);

// GetCollectionMeta

	Console::WriteLine(L"Calling GetConfigurationCollection::GetCollectionMeta");
	CollectionMeta *collMeta = CCfgCollXML->GetCollectionMeta();

	Console::Write(L"Version     :");
	Console::WriteLine(collMeta->cVersion);
	Console::Write(L"Table Flags :");
	Console::WriteLine(collMeta->fTable);
	Console::Write(L"Row Count   :");
	Console::WriteLine(collMeta->cRows);
	Console::Write(L"Column Count:");
	Console::WriteLine(collMeta->cColumns);

// GetPropertyValues
// GetPropertyMeta

	Console::WriteLine(L"Calling GetConfigurationCollection::GetPropertyValues on all rows");
	Console::WriteLine(L"Calling GetConfigurationCollection::GetPropertyMeta on all rows");
	for (int i=0; ;i++)
	{
		int j;
		__gc int	 a_iCol[] = new __gc int[collMeta->cColumns];
		__gc int	 a_iColWrite[] = new __gc int[collMeta->cColumns+1];



		for(j=0; j<collMeta->cColumns; j++)
		{
			a_iCol[j] = j;
		}

		for(j=0; j<(collMeta->cColumns+1); j++)
		{
			a_iColWrite[j] = j;
		}

		try
		{
			__gc Object *a_PropertyVal[] = CCfgCollXML->GetPropertyValues(i,
																			a_iCol);

			__gc PropertyMeta *PropMeta[] = CCfgCollXML->GetPropertyMeta(a_iCol);

			Console::WriteLine(L"--------------------------");
			Console::Write(L"   ROW: ");
			Console::WriteLine(i);
			Console::WriteLine(L"--------------------------");
			for(j=0; j<collMeta->cColumns; j++)
			{
				Console::Write(L"Column   :");
				Console::WriteLine(j+1);
				Console::Write(L"  Value  :");
				Console::WriteLine(a_PropertyVal[j]);
				Console::Write(L"  fMeta  :");
				Console::WriteLine(PropMeta[j]->fMeta);
				Console::Write(L"  dbType :");
				Console::WriteLine(PropMeta[j]->dbtype);
			}


			if(1 == i)
			{
			// Get the ith column
				int	 iOne = 1;

				Object *o_PropertyValOne = CCfgCollXML->GetPropertyValues(i,
																				iOne);
				Console::WriteLine(L"Single Column   :1");
				Console::Write(L"Single Value    :");
				Console::WriteLine(o_PropertyValOne);

			// Get a couple of columns
				__gc int	 a_iColTwo[] = new __gc int[2];

				a_iColTwo[0] = 5;
				a_iColTwo[1] = 7;

				__gc Object *a_PropertyValTwo[] = CCfgCollXML->GetPropertyValues(i,
																				a_iColTwo);
				Console::WriteLine(L"Two  Column   :5");
				Console::Write(L"Value    :");
				Console::WriteLine(a_PropertyValTwo[5]);
				Console::WriteLine(L"Two Column   :7");
				Console::Write(L"Value    :");
				Console::WriteLine(a_PropertyValTwo[7]);

			}

			__gc Object *aIdentityCLB[] = new __gc Object*[1];

			aIdentityCLB[0] = String::Copy(dynamic_cast<String *>(a_PropertyVal[0]));

			int	iWriteID;
				
			try
			{
				int iReadID	= CCfgCollCLB->GetConfigurationObjectID(aIdentityCLB);

				iWriteID	= CCfgCollCLB->MarkConfigurationObjectForUpdate(iReadID);

			}
			catch(COMException *exp)
			{
				if(0x80110816 == exp->ErrorCode)
				{
					iWriteID = CCfgCollCLB->MarkConfigurationObjectForInsert();
				}
				else
				{
					Console::Write(L"Some error occured hr = ");
					Console::WriteLine(exp->ErrorCode);
					return;
				}
			}

			__gc Object	 *a_PropertyValWrite[] = new __gc Object*[a_PropertyVal->Count+1];

			a_PropertyValWrite[0] = new String(L"AppPOOL.XML");

			for(j=0; j<collMeta->cColumns; j++)
			{
				a_PropertyValWrite[j+1] = a_PropertyVal[j];
			}


			CCfgCollCLB->SetChangedPropertyValues(iWriteID, a_iColWrite, a_PropertyValWrite);

			if(1 == iWriteID)
			{
			// Set a couple of columns
				__gc int	 a_iColTwo[] = new __gc int[2];

				a_iColTwo[0] = 5;
				a_iColTwo[1] = 7;

				__gc Object *a_PropertyValFull[] = new __gc Object *[10];

				a_PropertyValFull[5] = dynamic_cast<Object*>(666);
				a_PropertyValFull[7] = dynamic_cast<Object*>(777);

				CCfgCollCLB->SetChangedPropertyValues(iWriteID, a_iColTwo, a_PropertyValFull);

			}

		}
		catch(COMException *exp)
		{
			if(0x80110816 == exp->ErrorCode)
			{
				Console::WriteLine(L"End of rows");
				break;
			}
			else
			{
				Console::Write(L"Some error occured hr = ");
				Console::WriteLine(exp->ErrorCode);
				return;
			}
		}

	}
	
	try{	CCfgCollCLB->SaveChanges(); }
	catch(COMException *exp)
	{
		Console::Write(L"Some error occured in SaveChanges. hr = ");
		Console::WriteLine(exp->ErrorCode);
		return;
	}
	

// GetConfigurationObjectID

	Console::WriteLine(L"Calling GetConfigurationCollection::GetConfigurationObjectID on a given Configuration object.");

	__gc Object *aIdentityXML[] = new __gc Object*[1];

	aIdentityXML[0] = new String(L"AppPool22");
		
	int idx = CCfgCollXML->GetConfigurationObjectID(aIdentityXML);

	Console::Write(L"The ConfigurationObjectID is: ");
	Console::WriteLine(idx);

////////////////////////////////////////////////////////////////////////////////////////
// Test the ISimpleTableRead interface using unmanaged parameters
////////////////////////////////////////////////////////////////////////////////////////

// Try to repro bug

	Console::WriteLine(L"Calling GetConfigurationCollection::GetPropertyValues on all rows in Column Meta");
	__gc int	 a_iCol[] = new __gc int[12];


	for(int j=0; j<12; j++)
	{
		a_iCol[j] = j;
	}

	for (int i=0; ;i++)
	{

		try
		{

		// Try displaying values of columnmeta table, twice using different config collections.

			__gc Object *a_PropertyVal1[] = CCfgCollXML2->GetPropertyValues(i,
																			a_iCol);

			__gc Object *a_PropertyVal2[] = CCfgCollXML2->GetPropertyValues(i,
																			a_iCol);

			Console::WriteLine(L"--------------------------");
			Console::Write(L"   ROW: ");
			Console::WriteLine(i);
			Console::WriteLine(L"--------------------------");
			for(int j=0; j<12; j++)
			{
				Console::Write(L"Column   :");
				Console::WriteLine(j+1);
				Console::Write(L"  Value  :");
				Console::WriteLine(a_PropertyVal1[j]);
				Console::Write(L"  Value  :");
				Console::WriteLine(a_PropertyVal2[j]);
			}

		}
		catch(COMException *exp)
		{
			if(0x80110816 == exp->ErrorCode)
			{
				Console::WriteLine(L"End of rows");
				break;
			}
			else
			{
				Console::Write(L"Some error occured hr = ");
				Console::WriteLine(exp->ErrorCode);
				return;
			}
		}

	}


};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\displayextendeddescription.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  TUX DLL
//  Copyright (c) 1999, Microsoft Corporation
//
//  Module:  DisplayExtendedDescription.cpp
//           This test will display detailed information about an individual test
//           or the entire list of tests.
//
//  Revision History:
//      03/22/1999  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#ifndef UNDER_CE
#include <stdio.h> //Needed for printf
#endif


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TDisplayExtendedDescription
//
// Description:
//  This test will display detailed information about an individual test or the
//  entire list of tests.
//
class TDisplayExtendedDescription : public TestBase
{
    public:
        TDisplayExtendedDescription(){}
        virtual TestResult  ExecuteTest();
    private:
        void Output(LPCTSTR szFormat, ...) const ;
        void OutputTestDiscription(TuxTestBase &Test) const;
};


TTuxTest<TDisplayExtendedDescription> T999(999, DESCR2("Display Detailed Test Info (use -c\"xxxxx\" for a specific test)",
           TEXT("This test displays detailed information about a given test.  Use Tux's '-c'\r\n")// We manage the newline
           TEXT("option to specify a test number.  Multiple test numbers can be separated by\r\n")// characters manually
           TEXT("commas.  A Range of test numbers is separated by a dash (Example: tux -o -d\r\n")// for proper formatting.
           TEXT("tuxdll.dll -x999 -c\"105-115,200-204\").  If no test numbers are specified \r\n")//
           TEXT("then information on how to use this test is output\r\n\r\n"                     )//
           TEXT("Information displayed includes:  Test Number, Brief Description, Source\r\n"    )//
           TEXT("Code Filename, Source Code Path (relative to _WINCEROOT), Date & Time\r\n"      )//
           TEXT("Compiled, Date of Last Modification, and Detailed Description.  The only\r\n"   )//
           TEXT("information guarenteed to be displayed is the Test Number and Brief\r\n"        )//
           TEXT("Description.  The other information is optional.\r\n\r\n"                       )//
           TEXT("In order to automatically generate the file information a source module\r\n"    )//
           TEXT("needs to declare the test description using the DESCR macro.  The DESCR2\r\n"   )//
           TEXT("is designed to accept two strings.  The first is the Brief Description\r\n"     )//
           TEXT("same as DESCR) and the second is the detailed description.  See test 999\r\n"   )//
           TEXT("for an example of how to use this macro.  Note: the first parameter does\r\n"   )//
           TEXT("require a TEXT macro, the second parameter does.  This is because the\r\n"      )//
           TEXT("compiler can't concatinate the strings without the TEXT macro in front of\r\n"  )//
           TEXT("each line.")));

////////////////////////////////////////////////////////////////////////////////
// TDisplayExtendedDescription::ExecuteTest
//  Queries the TuxTestBase for detailed information about a test (or all the tests if no -c parameter.
//
// Return value:
//  trPASS if the test number passed in is value , trFAIL test number not found,
//
TestResult TDisplayExtendedDescription::ExecuteTest()
{
    TestResult rtn = trFAIL;
    Output(TEXT("\r\n________________________________________________________________________________"));

    if(g_pShellInfo && g_pShellInfo->szDllCmdLine && _tcslen(g_pShellInfo->szDllCmdLine)>2)
    {   //if we were given command line arguments, then parse to find the test numbers in question
        LPCTSTR pString = g_pShellInfo->szDllCmdLine;
        while(*pString)//while we're not at the '\0'
        {
            unsigned int iTemp = _ttoi(pString);//convert the string to an int
            if(iTemp<=0)//if we get something bogus on the command line then bail
                return rtn;

            unsigned int iLastInRange = iTemp;
            while(*pString != 0 && *pString != ',' && *pString != '-')pString++;//advace til we find the end or a comma or a dash
            if(*pString == '-')
            {
                pString++;//if we found a dash then point past it
                iLastInRange = _ttoi(pString);
            }
        
            while(iTemp <= iLastInRange)
            {
                //if the cast fails pThis should be 0.  This cast should not throw an exception
                TuxEntry *pCurrent=TuxEntry::m_pFirst;//walk the linked list from the beginning
                while(pCurrent->m_UniqueID != iTemp && pCurrent->m_pNext)pCurrent = pCurrent->m_pNext;
                if(pCurrent->m_UniqueID == iTemp)//if we didn't get to the end before bailing on the while
                {//then we must have found a match
                    TuxTestBase *pThis=0;
//#ifdef UNDER_CE //CE doesn't support RTTI so we can't do a dynamic_cast
                    if(pCurrent->IsARealTest())//but a match isn't necessarily a TuxTestBase
                         pThis = reinterpret_cast<TuxTestBase *>(pCurrent);
//#else
//                    pThis = dynamic_cast<TuxTestBase *>(pCurrent);//but a match isn't necessarily a TuxTestBase
//#endif
                    if(pThis)//so verify that the cast worked correctly (meaning the it is a TuxTestBase)
                    {
                        OutputTestDiscription(*pThis);//now we're ready to rock!
                        rtn = trPASS;//the first time we find a test that matches the criteria we signify trPASS
                    }
                }
                iTemp++;
            }
            while(*pString != 0 && *pString != ',')pString++;//advace til we find the end or a comma
            if(*pString == ',')pString++;//if we found a comma then point past it
        }
    }
    else
    {   //if no command line arguments are passed then display detailed information about This test T999
        OutputTestDiscription(T999);
        rtn = trPASS;//the first time we find a test that matches the criteria we signify trPASS
    }
    return rtn;
}

void TDisplayExtendedDescription::OutputTestDiscription(TuxTestBase &Test) const
{
    Output(TEXT("Test Number: %d"),      Test.m_UniqueID);
    Output(TEXT("Description: %s"),  Test.GetTestDescription());

    if(*Test.GetSourceFileName())//if there is further information then display it.
    {
        TCHAR szFullFileName[_MAX_PATH];
        _tcscpy(szFullFileName, Test.GetSourceFileName());//make a copy so we can modify it

        TCHAR *szFileName = szFullFileName + _tcslen(szFullFileName) -1;
        while(szFileName>szFullFileName && *szFileName != '\\')szFileName--;//start at the end walk backward til we find the last back slash
        if(*szFileName == '\\')
            *szFileName++ = 0x00;//make the last backslash a '\0' then point just beyond the last backslash to get the unqualified filename (with extension)
        Output(TEXT("Source File Name: %s"), szFileName);

        TCHAR *szDir = szFullFileName;
        while(1)
        {
            while(*szDir != '\\' && *szDir != 0x00)szDir++;//advance to the next backslash
            if(*szDir == 0)//if we've reached the end of the path and still haven't figured out where _WINCEROOT is
            {             //then bail on the whole idea and give the unmodified szFullFileName (minus the unqualified filename)
                Output(TEXT("Source Path:      %s"),   szFullFileName);
                break;
            }
            if(0==_tcsnicmp(szDir, TEXT("\\private\\qahome"), 15))//if we've advanced past the _WINCEROOT 
            {
                Output(TEXT("Source Path:      _WINCEROOT%s"),   szDir);
                break;
            }
            szDir++;//if we've found a \ but it doesn't park the beginning of the relative path then we need to advance
                   //the pointer one time
        }

        Output(TEXT("Date Compiled:    %s"),   Test.GetSourceFileDate());
        Output(TEXT("Time Compiled:    %s"),   Test.GetSourceFileTime());
        Output(TEXT("Last Modified:    %s"),   Test.GetSourceFileTimeStamp());
        Output(TEXT("\r\nDetailed Description:"));
#ifdef UNDER_CE
        OutputDebugString(Test.GetDetailedDescription());//Calling Ouput requires a copy of the buffer, this does not.
#else
        wprintf(Test.GetDetailedDescription());//Calling Ouput requires a copy of the buffer, this does not.
#endif
        Output(TEXT(""));//newline character
    }
    Output(TEXT("________________________________________________________________________________"));
}


////////////////////////////////////////////////////////////////////////////////
// TDisplayExtendedDescription::Output
//  We need our own version of output so we don't have the header that Debug
//  outputs.  This gives more room for formatting.
//
void TDisplayExtendedDescription::Output(LPCTSTR szFormat, ...) const
{
    TCHAR   szBuffer[1024];
    if(_tcslen(szFormat)>sizeof(szBuffer))
        _tcscat(szBuffer, TEXT("String too large!!!\r\n"));
    else
    {
        va_list pArgs;
        va_start(pArgs, szFormat);
        wvsprintf(szBuffer, szFormat,pArgs);
        va_end(pArgs);
        _tcscat(szBuffer, TEXT("\r\n"));
    }
#ifdef UNDER_CE
    OutputDebugString(szBuffer);
#else
    wprintf(szBuffer);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\errorlog.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  ALL TUX DLLs
//  Copyright (c) 1998, Microsoft Corporation
//
//  Module:  ErrorLog.h
//           This is a set of classes used to log errors.  There is a test to
//           start the logging.  Every test after that will have its errors
//           logged and after the last test of a suite, the Output/Stop logging
//           test should be run to output the log.  This is most useful for BVTs
//           or any other suite that has many test.  The log will act as a summary
//           of the errors encountered during that suite.
//
//  Revision History:
//      05/25/1998  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __ERRORLOG_H__
#define __ERRORLOG_H__


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  ErrorLogEntry
//
// Description:
//  This class represents a description of an entry into the error log.  Instantiate
//  one of these for every error encountered.  The Ctor will output the debug message.
//
class ErrorLogEntry
{
    public:
        static void OutputAndDeleteErrorLog();
        static void StartLogging();
        static void StopLogging();
        static void RemoveLast();
        static void RemoveDeferedErrors();
        static void NewError(int nLineNumber, LPCTSTR szSourceModule, LPCTSTR szSourceCodeText, DWORD dwError=0, int nKnownBugNumber=0);
        static void DeferOutput(bool bDefer);

    protected:
        ErrorLogEntry(int nLineNumber, LPCTSTR szSourceModule, LPCTSTR szSourceCodeText, DWORD dwError, int nKnownBugNumber);
        virtual ~ErrorLogEntry();

        static bool                     m_bLogging;
        static ErrorLogEntry           *m_pDefered;
        static bool                     m_bDeferOutput;
        static ErrorLogEntry           *m_pFirst;
        static ErrorLogEntry           *m_pLast;
        static LPCTSTR                  m_szFormatString[4];

        DWORD                           m_dwError;//If this value is zero then it's an error but doesn't have a DWORD error code (ie a compare fails)
        int                             m_nKnownBugNumber;
        int                             m_nLineNumber;
        int                             m_nFormatStyle;
        ErrorLogEntry                  *m_pNext;
        ErrorLogEntry                  *m_pPrev;
        TCHAR                           m_szMediaFile[255];
        LPCTSTR                         m_szSourceModule;
        LPCTSTR                         m_szSourceCodeText;

        void    OutputLogEntry();
};

#endif //__ERRORLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\errormacros.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module:  ErrorMacros.h
//           These are some macros that look a bit like try-catch blocks.  They
//           are used to output errors when they happen as well as doing the
//           jump to clean up code.
//
//  Revision History:
//      11/17/1997  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __ERRORMACROS_H__
#define __ERRORMACROS_H__

//Type safe values that come from Tux.h
enum TestResult
{
    trNOT_HANDLED   = 0,//TPR_NOT_HANDLED,
    trHANDLED       = 1,//TPR_HANDLED,
    trSKIP          = 2,//TPR_SKIP,
    trPASS          = 3,//TPR_PASS,
    trFAIL          = 4,//TPR_FAIL,
    trABORT         = 5,//TPR_ABORT
};


//Don't use the all caps version in WINERROR.H, use the inline versions instead
//this way we can have function overloading.
inline bool Succeeded(HRESULT hResult,   LPVOID pResult=NULL)     {if(pResult)*(HRESULT *)pResult = hResult;return ((HRESULT)(hResult) >= 0);}
inline bool Failed(HRESULT hResult,      LPVOID pResult=NULL)     {if(pResult)*(HRESULT *)pResult = hResult;return ((HRESULT)(hResult)<0);}
inline bool Succeeded(TestResult tResult,LPVOID pResult=NULL)  {if(pResult)*(TestResult *)pResult = tResult;return trPASS == tResult;}
inline bool Failed(TestResult tResult,   LPVOID pResult=NULL)  {if(pResult)*(TestResult *)pResult = tResult;return trFAIL == tResult;}
inline bool IsDoneWithSetUp(){return true;}//This is needed for those methods that aren't derived from TestBase.
inline void StartingTestSetup(){}//This is needed to prevent a compiler error
inline void DoneWithTestSetup(){}//This is needed to prevent a compiler error

//This is like a try-catch-end catch block except that you can't nest them
//because of the goto
#define EM_START   {                        \
                        union emResult      \
                        {                   \
                            HRESULT     hr; \
                            TestResult  tr; \
                            DWORD       dw; \
                        };                  \
                        emResult em={0};    \
                        bool bEmFailed = false;

#define EM_START_SETUP  {                   \
                        union emResult      \
                        {                   \
                            HRESULT     hr; \
                            TestResult  tr; \
                            DWORD       dw; \
                        };                  \
                        emResult em={0};    \
                        bool bEmFailed = false; \
                        StartingTestSetup();

#define EM_TEST_BEGIN   DoneWithTestSetup();

#define EM_CLEANUP          CleanUp:;
#define EM_END     }

//These abstract the 'emhr' variable
#define EM_SUCCEEDED        (!bEmFailed)
#define EM_FAILED           (bEmFailed)
#define EM_HRESULT          em.hr
#define EM_TRESULT          em.tr
#define EM_RETURN_TRESULT   return (EM_SUCCEEDED ? ((em.tr == trSKIP) ? trSKIP : trPASS) : (IsDoneWithSetUp() ? trFAIL : trABORT));}
#define EM_RETURN_HRESULT   {if(Failed(em.hr))Debug(TEXT("Returning HRESULT %08x"), em.dw);return em.hr;}}
#define EM_RETURN_SKIP      {em.tr = trSKIP;bEmFailed = false;goto CleanUp;}


//These make your code readable, just put the call inside the macro like
//  EM_JIF(CoCreateInstace(CLSID_Blah, NULL, CLSCTX_INPROC_SERVER, IID_IBlah, (void **)&pBlah));
//The trailing semicolon is not needed but it make the macro look like a function call.
#define EM_JIFORS(q) if(Failed((TestResult)q, &em.tr)){bEmFailed = true;goto CleanUp;}else{if(em.tr == trSKIP){Debug(TEXT(": LINE:%d - trSKIP"),__LINE__);goto CleanUp;}}

//This is so a project can use the rest of the framework without being forced into doing ErrorLogging
#ifdef __ERRORLOG_H__
#define NewError3(x,y,z) ErrorLogEntry::NewError(x,y,z)
#define NewError4(w,x,y,z) ErrorLogEntry::NewError(w,x,y,z)
#define NewError5(v,w,x,y,z) ErrorLogEntry::NewError(v,w,x,y,z)
#else
#define NewError3(x,y,z)
#define NewError4(w,x,y,z)
#define NewError5(v,w,x,y,z)
#endif

//These macros will fail the test immediately if a failure occurs
//Jump(and Log)IfFailed, Jump(and Log)IfTrue
#define EM_JIF(q) if(Failed(q, &em.dw))         {NewError4(__LINE__, TEXT(__FILE__), TEXT(#q), em.dw);bEmFailed = true;goto CleanUp;}else{}
#define EM_JIT(q) if(bool(q)){em.hr=E_UNEXPECTED;NewError3(__LINE__, TEXT(__FILE__), TEXT(#q));       bEmFailed = true;goto CleanUp;}else{}
#define EM_JINE(q1, q2, tol) if(!IsEqual(q1,q2,tol)){em.hr=E_UNEXPECTED;NewError3(__LINE__, TEXT(__FILE__), TEXT("Not Equal"));Debug(TEXT("Expected ") TEXT(#q1) TEXT(" 0x%x, Actual ") TEXT(#q2) TEXT(" 0x%x, Tolerance ") TEXT(#tol) TEXT(" 0x%x"),(int)(q1),(int)(q2),(int)(tol));bEmFailed = true;goto CleanUp;}else{}

//These macro are used for failure that can be recovered from and should not cause an immediate failure of the test
//LogIfFailed, LogIfTure
#define EM_LIF(q) if(Failed(q, &em.dw))         {NewError4(__LINE__, TEXT(__FILE__), TEXT(#q), em.dw);bEmFailed = true;}else{}
#define EM_LIT(q) if(bool(q)){em.hr=E_UNEXPECTED;NewError3(__LINE__, TEXT(__FILE__), TEXT(#q));       bEmFailed = true;}else{}
#define EM_LINE(q1, q2, tol) if(!IsEqual(q1,q2,tol)){em.hr=E_UNEXPECTED;NewError3(__LINE__, TEXT(__FILE__), TEXT("Not Equal"));Debug(TEXT("Expected ") TEXT(#q1) TEXT(" 0x%x, Actual ") TEXT(#q2) TEXT(" 0x%x, Tolerance ") TEXT(#tol) TEXT(" 0x%x"),(int)(q1),(int)(q2),(int)(tol));bEmFailed = true;}else{}
#define EM_LINEF(q1, q2, tol) if(!IsEqual(q1,q2,tol)){em.hr=E_UNEXPECTED;NewError3(__LINE__, TEXT(__FILE__), TEXT("Not Equal"));Debug(TEXT("Expected ") TEXT(#q1) TEXT(" %f, Actual ") TEXT(#q2) TEXT(" %f, Tolerance ") TEXT(#tol) TEXT(" %f"),(double)(q1),(double)(q2),(double)(tol));bEmFailed = true;}else{}

//These macro are used to Mark the failure without logging it or jumping because of it.  This is needed to prevent error propagation
//from appearing as multiple errors
//MarkIfFailed, MarkIfTure
#define EM_MIF(q) if(Failed(q, &em.dw))         {bEmFailed = true;Debug(TEXT("Cascade Failure: Source Module %s\r\nFailure Condition %x = %s\r\nLine Number %d"),TEXT(__FILE__), em.dw, TEXT(#q), __LINE__);}else{}
#define EM_MIT(q) if(bool(q)){em.hr=E_UNEXPECTED;bEmFailed = true;Debug(TEXT("Cascade Failure: Source Module %s\r\nFailure Condition TRUE == %s\r\nLine Number %d"),TEXT(__FILE__), TEXT(#q), __LINE__);}else{}
#define EM_MINE(q1, q2, tol) if(!IsEqual(q1,q2,tol)){em.hr=E_UNEXPECTED;Debug(TEXT("Expected ") TEXT(#q1) TEXT("%x, Actual ") TEXT(#q2) TEXT("%x"),(int)q1,(int)q2);bEmFailed = true;}else{}

//These macros will fail the test immediately if a failure occurs, but they mark the failure as a cascade one.
//They are different from EM_MIx in that they do jump.
#define EM_MJIF(q) if(Failed(q, &em.dw))          {bEmFailed = true;Debug(TEXT("Cascade Failure: Source Module %s\r\nFailure Condition %x = %s\r\nLine Number %d"),TEXT(__FILE__), em.dw, TEXT(#q), __LINE__);goto CleanUp;}else{}
#define EM_MJIT(q) if(bool(q)) {em.hr=E_UNEXPECTED;bEmFailed = true;Debug(TEXT("Cascade Failure: Source Module %s\r\nFailure Condition TRUE == %s\r\nLine Number %d"),TEXT(__FILE__), TEXT(#q), __LINE__);goto CleanUp;}else{}

//The following are for logging Known errors, they should be used with the bug number from the database
//These macros will fail the test immediately if a failure occurs, reporting the error as known with a bug number.
//Jump(and Log)IfFailed, Jump(and Log)IfTrue
#define KEM_JIF(n,q) if(Failed(q, &em.dw))         {NewError5(__LINE__, TEXT(__FILE__), TEXT(#q), em.dw, n);bEmFailed = true;goto CleanUp;}else{}
#define KEM_JIT(n,q) if(bool(q)){em.hr=E_UNEXPECTED;NewError5(__LINE__, TEXT(__FILE__), TEXT(#q), 0,     n);       bEmFailed = true;goto CleanUp;}else{}
#define KEM_JINE(n, q1, q2, tol) if(!IsEqual(q1,q2,tol)){em.hr=E_UNEXPECTED;NewError5(__LINE__, TEXT(__FILE__), TEXT("Not Equal"), 0, n);Debug(TEXT("Expected ") TEXT(#q1) TEXT(" 0x%x, Actual ") TEXT(#q2) TEXT(" 0x%x, Tolerance ") TEXT(#tol) TEXT(" 0x%x"),(int)(q1),(int)(q2),(int)(tol));bEmFailed = true;goto CleanUp;}else{}

//These macro are used for failure that can be recovered from and should not cause an immediate failure of the test, reporting the error as known with a bug number.
//LogIfFailed, LogIfTure
#define KEM_LIF(n,q) if(Failed(q, &em.dw))         {NewError5(__LINE__, TEXT(__FILE__), TEXT(#q), em.dw, n);bEmFailed = true;}else{}
#define KEM_LIT(n,q) if(bool(q)){em.hr=E_UNEXPECTED;NewError5(__LINE__, TEXT(__FILE__), TEXT(#q), 0,     n);bEmFailed = true;}else{}
#define KEM_LINE(n, q1, q2, tol) if(!IsEqual(q1,q2,tol)){em.hr=E_UNEXPECTED;NewError5(__LINE__, TEXT(__FILE__), TEXT("Not Equal"), 0, n);Debug(TEXT("Expected ") TEXT(#q1) TEXT(" 0x%x, Actual ") TEXT(#q2) TEXT(" 0x%x, Tolerance ") TEXT(#tol) TEXT(" 0x%x"),(int)(q1),(int)(q2),(int)(tol));bEmFailed = true;}else{}
#define KEM_LINEF(n, q1, q2, tol) if(!IsEqual(q1,q2,tol)){em.hr=E_UNEXPECTED;NewError5(__LINE__, TEXT(__FILE__), TEXT("Not Equal"), 0, n);Debug(TEXT("Expected ") TEXT(#q1) TEXT(" %f, Actual ") TEXT(#q2) TEXT(" %f, Tolerance ") TEXT(#tol) TEXT(" %f"),(double)(q1),(double)(q2),(double)(tol));bEmFailed = true;}else{}

#define RemoveLastError() {RemoveLast();}

//These are WARNING macros
#define WARN(x) \
        "------------------------(----(---(--( Warning )--)---)----)---------------------------\r\n" \
        "|                                                                                    |\r\n" \
        "| " x "\r\n" \
        "|                                                                                    |\r\n" \
        "--------------------------------------------------------------------------------------\r\n"

//Known bug worning
#define KWARN(n,x) \
        "-------------------(----(---(--( Warning-Bug #" n ")--)---)----)-----------------------\r\n" \
        "|                                                                                    |\r\n" \
        "| " x "\r\n" \
        "|                                                                                    |\r\n" \
        "--------------------------------------------------------------------------------------\r\n"


template <class T> T Abs(T a)
{
    return (a>=0 ? a : (-1 * a));
}

template <class T> bool IsEqual( T a, T b, T MaxTolerance)
{
    //We must check to see which is larger first to cover the unsigned types.
    return (((a-b)==0) || (a>b && !((a-b)>MaxTolerance)) || (b>a && !((b-a)>MaxTolerance)));
}

template <class T> bool IsMuchGreater( T a, T b, T MaxTolerance)
{
    //We must check to see which is larger first to cover the unsigned types.
    return (a>b &&  (a-b)>MaxTolerance);
}

template <class T> bool IsMuchLess( T a, T b, T MaxTolerance)
{
    //We must check to see which is larger first to cover the unsigned types.
    return (a<b && (b-a)>MaxTolerance);
}

#endif //__ERRORMACROS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\globals.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  TUX DLL
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module: globals.h
//          Declares all global variables and test function prototypes EXCEPT
//          when included by globals.cpp, in which case it DEFINES global
//          variables, including the function table.
//
//  Revision History:
//      11/13/1997  stephenr    Created by the TUX DLL AppWizard.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __GLOBALS_H__
#define __GLOBALS_H__

////////////////////////////////////////////////////////////////////////////////
// Local macros

#ifdef __GLOBALS_CPP__
#define GLOBAL
#define INIT(x) = x
#else // __GLOBALS_CPP__
#define GLOBAL  extern
#define INIT(x)
#endif // __GLOBALS_CPP__

////////////////////////////////////////////////////////////////////////////////
// Global macros

#define countof(x)  (sizeof(x)/sizeof(*(x)))

// Suppress warning C4102: 'CleanUp' : unreferenced label
#pragma warning (disable: 4102)

////////////////////////////////////////////////////////////////////////////////
// Global function prototypes
#ifdef UNICODE
    bool ConvertString(LPTSTR pszOut, LPCTSTR pwszIn, DWORD dwSize);
#else
    bool ConvertString(LPTSTR pszOut, LPWSTR pwszIn, DWORD dwSize);
#endif
void            Debug(LPCTSTR, ...);
SHELLPROCAPI    ShellProc(UINT, SPPARAM);

////////////////////////////////////////////////////////////////////////////////
// Globals

// Global CKato logging object. Set while processing SPM_LOAD_DLL message.
GLOBAL CKato            *g_pKato INIT(NULL);

// Global shell info structure. Set while processing SPM_SHELL_INFO message.
GLOBAL SPS_SHELL_INFO   *g_pShellInfo;

// Global Test Execute structure, set at the beginning of the test.
GLOBAL TPS_EXECUTE       g_TPS_Execute;

GLOBAL HINSTANCE g_hModule;

#define OATRUE (-1)
#define OAFALSE (0)

// Convert the Tick counts in to Millisec.
// The conversion of Tick counts to Millisec depends on the platform.
// LC2W (1 Tick Count = 25 MS)
// KATANA (1 Tick Count = 1 MS)
// PUZZLE (1 Tick Count = 25 MS)
extern DWORD ConverTickCountToMillisec(DWORD dwTickCount);

// Add more globals of your own here. There are two macros available for this:
//  GLOBAL  Precede each declaration/definition with this macro.
//  INIT    Use this macro to initialize globals, instead of typing "= ..."
//
// For example, to declare two DWORDs, one uninitialized and the other
// initialized to 0x80000000, you could enter the following code:
//
//  GLOBAL DWORD        g_dwUninit,
//                      g_dwInit INIT(0x80000000);
////////////////////////////////////////////////////////////////////////////////
GLOBAL LPTSTR g_szProductID    INIT(TEXT("URT"));
GLOBAL LPTSTR g_szDatabaseName INIT(TEXT("META"));
GLOBAL LPTSTR g_szTableName    INIT(TEXT("TABLEMETA"));
GLOBAL LPTSTR g_szFileName     INIT(0);
GLOBAL ULONG  g_LOS            INIT(0);


#endif // __GLOBALS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\globals.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  TUX DLL
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module: globals.cpp
//          Causes the header globals.h to actually define the global variables.
//
//  Revision History:
//      11/13/1997  stephenr    Created by the TUX DLL AppWizard.
//
////////////////////////////////////////////////////////////////////////////////

#define INITGUID

// By defining the symbol __GLOBALS_CPP__, we force the file globals.h to
// define, instead of declare, all global variables.
#define __GLOBALS_CPP__
#include "stdafx.h"
#include "globals.h"

DECLARE_DEBUG_PRINTS_OBJECT();
VOID
PuDbgPrint(
   IN OUT LPDEBUG_PRINTS   pDebugPrints,
   IN const char *         pszFilePath,
   IN int                  nLineNum,
   IN const char *         pszFormat,
   ...){return;}

// Convert the Tick counts in to Millisec.
// The conversion of Tick counts to Millisec depends on the platform.
// LC2W (1 Tick Count = 1 MS)
// KATANA (1 Tick Count = 25 MS)
// PUZZLE (1 Tick Count = 1 MS)
DWORD ConverTickCountToMillisec(DWORD dwTickCount)
{
#ifdef IETV
    return (25 * dwTickCount);//I think the tick count on Puzzle is 25 also
#else
    return (25 * dwTickCount);
#endif // DRAGON
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\losrepopulate.h ===
////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TSelectTable
//
// Description:
//  This test selects a TableName
//
class TSelectTable : public TestBase
{
    public:
        TSelectTable(LPTSTR sz) : m_szTableName(sz){}

        virtual TestResult  ExecuteTest(){g_szTableName = m_szTableName; return trPASS;}
    protected:
        LPTSTR         m_szTableName;
};


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TSelectDatabase
//
// Description:
//  This test selects a Database
//
class TSelectDatabase : public TestBase
{
    public:
        TSelectDatabase(LPTSTR sz) : m_szDatabaseName(sz){}

        virtual TestResult  ExecuteTest(){g_szDatabaseName = m_szDatabaseName; return trPASS;}
    protected:
        LPTSTR         m_szDatabaseName;
};


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TSelectFile
//
// Description:
//  This test selects a file name
//
class TSelectFile : public TestBase
{
    public:
        TSelectFile(LPTSTR sz) : m_szFileName(sz){}

        virtual TestResult  ExecuteTest(){g_szFileName = m_szFileName; return trPASS;}
    protected:
        LPTSTR         m_szFileName;
};


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TSelectProductID
//
// Description:
//  This test selects the ProductID for use when getting a dispenser
//
class TSelectProductID : public TestBase
{
    public:
        TSelectProductID(LPTSTR sz) : m_szProductID(sz){}

        virtual TestResult  ExecuteTest(){g_szProductID = m_szProductID; return trPASS;}
    protected:
        LPTSTR          m_szProductID;
};



////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TSelectLOS
//
// Description:
//  This test selects the LOS for use when getting a table
//
class TSelectLOS : public TestBase
{
    public:
        enum BoolOperator
        {
            AND,
            OR
        };

        TSelectLOS(ULONG los, BoolOperator op) : m_LOS(los), m_Op(op){}

        virtual TestResult  ExecuteTest()
        {
            if(AND == m_Op)
                g_LOS &= m_LOS;
            else
                g_LOS |= m_LOS;
            Debug(TEXT("Current LOS is 0x%08x\r\n"), g_LOS);
            return trPASS;
        }
    protected:
        ULONG           m_LOS;
        BoolOperator    m_Op;
};


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TGetTableBaseClass
//
// Description:
//  This is a base class that handles the overhead of GetDispenser and GetTable using the current: Filename, ProductID, and LOS
//
class TGetTableBaseClass : public TCom
{
    public:
        TGetTableBaseClass(LPTSTR szDatabaseName=0, LPTSTR szTableName=0, LPTSTR szFileName=0, LPTSTR szProductID=0, ULONG los=~0) :
                m_szDatabaseName(szDatabaseName),
                m_szTableName(szTableName),
                m_szFileName(szFileName),
                m_szProductID(szProductID),
                m_LOS(los){}

    protected:
        ULONG   m_LOS;
        LPTSTR  m_szDatabaseName;
        LPTSTR  m_szFileName;
        LPTSTR  m_szProductID;
        LPTSTR  m_szTableName;

        CComPtr<ISimpleTableAdvanced>   m_pISTAdvanced;
        CComPtr<ISimpleTableDispenser2> m_pISTDisp;// Table dispenser.
        CComPtr<ISimpleTableRead2>      m_pISTRead2;
        CComPtr<ISimpleTableWrite2>     m_pISTWrite;
        
        TestResult  GetTable(bool bLockInParameters=true);
        void        LockInParameters();
        void        ReleaseTable();
        void        SetProductID(LPTSTR szProductID);
};


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TLOSRepopulate
//
// Description:
//  This test Gets NormalTable using LOS_UNPOPULATED then does the following sub tests:
//      1>inserts a row into an empty file, calls update store, releases the table
//      2>gets the table with LOS_UNPOPULATED | LOS_REPOPULATE. Count of row should be 0.  After PopulateCache count of rows should be one.  Release table.
//      3>gets the table with LOS of 0. Count of row should be 1.  PopulateCache should fail.  Release table.
//      4>gets the table with LOS_REPOPULATE. Count of row should be 1.  Subsequent PopulateCache should succeed.  Release table.
//      5>gets the table, updates the row just added, calls update store, releases the table
//      6>gets the table, deletes the row just added, releases the table
//      7>gets the table, deletes the row again, Update store should fails with DetailedErrors. releases the table
//      8>gets the table, updates the row previously deleted, Update store should fails with DetailedErrors. releases the table
//
class TLOSRepopulate : public TestBase, public TestCase, public TGetTableBaseClass
{
    public:
        TLOSRepopulate() : 
          TGetTableBaseClass(wszDATABASE_APP_PRIVATE, wszTABLE_NormalTable, TEXT("temp.tst"), 0, fST_LOS_READWRITE), ulTestValue(911)
          {
              m_rowValues.pString = L"teststring";
              m_rowValues.pUI4    = &ulTestValue;
              m_rowValues.pBytes  = 0;
          }

        virtual TestResult  ExecuteTest();
    protected:
        ULONG ulTestValue;
        tNormalTableRow m_rowValues;
};


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TIErrorInfoTest
//
// Description:
//  This test Gets Dirs table from a bogus XML file:
//      1>gets the table and verifies that it returns error.
//      2>calls GetErrorInfo to verify that there is an IErrorInfo set
//      3>QueryInterface on the IErrorInfo and verify that it supports ISimpleTableRead2
//      4>call ISimpleTableRead2::GetColumnValues
//      5>call IErrorInfo::GetDescription
//      6>call IErrorInfo::GetSource
//      7>verify the return values from IErrorInfo agrees with ISimpleTableRead2
//
class TIErrorInfoTest : public TestBase, public TestCase, public TGetTableBaseClass
{
    public:
        TIErrorInfoTest() : 
          TGetTableBaseClass(wszDATABASE_IIS, wszTABLE_Dirs, TEXT("Stephen_bad.xml"), 0, 0)
          {
          }

        virtual TestResult  ExecuteTest();
    protected:
    CComBSTR                    bstrDescription;
    CComBSTR                    bstrSource;
    tDETAILEDERRORSRow          ErrorRow;
    CComPtr<IErrorInfo>         spErrorInfo;
    CComPtr<ISimpleTableRead2>  spISTRead2;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\losrepopulate.cpp ===
#include "stdafx.h"
#include "LOSRepopulate.h"


TTuxTest1<TSelectProductID, LPTSTR>    T101(101, DESCR("Selects URT as the ProductID"), TEXT("URT"));
TTuxTest1<TSelectProductID, LPTSTR>    T102(102, DESCR("Selects IIS as the ProductID"), TEXT("IIS"));

TTuxTest1<TSelectDatabase, LPWSTR>     T110(110, DESCR("Selects Database META         "), wszDATABASE_META         );
TTuxTest1<TSelectDatabase, LPWSTR>     T111(111, DESCR("Selects Database ERRORS       "), wszDATABASE_ERRORS       );
TTuxTest1<TSelectDatabase, LPWSTR>     T112(112, DESCR("Selects Database PACKEDSCHEMA "), wszDATABASE_PACKEDSCHEMA );
TTuxTest1<TSelectDatabase, LPWSTR>     T114(113, DESCR("Selects Database CONFIGSYS    "), wszDATABASE_CONFIGSYS    );
TTuxTest1<TSelectDatabase, LPWSTR>     T115(114, DESCR("Selects Database MEMORY       "), wszDATABASE_MEMORY       );
TTuxTest1<TSelectDatabase, LPWSTR>     T119(115, DESCR("Selects Database METABASE     "), wszDATABASE_METABASE     );
TTuxTest1<TSelectDatabase, LPWSTR>     T120(116, DESCR("Selects Database IIS          "), wszDATABASE_IIS          );
TTuxTest1<TSelectDatabase, LPWSTR>     T121(117, DESCR("Selects Database APP_PRIVATE  "), wszDATABASE_APP_PRIVATE  );

TTuxTest1<TSelectFile, LPTSTR>         T151(151, DESCR("Selects a file (c:\\winnt\\xspdt\\test.xml) as the 'current' file"), TEXT("c:\\winnt\\xspdt\\test.xml"));
TTuxTest1<TSelectFile, LPTSTR>         T152(152, DESCR("Selects a file (c:\\winnt\\xspdt\\stephen.xml) as the 'current' file"), TEXT("c:\\winnt\\xspdt\\stephen.xml"));

TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T210(210, DESCR("Zero out the current LOS"), 0, TSelectLOS::AND);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T211(211, DESCR("Current LOS |= fST_LOS_CONFIGWORK    "), fST_LOS_CONFIGWORK    , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T212(212, DESCR("Current LOS |= fST_LOS_READWRITE     "), fST_LOS_READWRITE     , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T213(213, DESCR("Current LOS |= fST_LOS_UNPOPULATED   "), fST_LOS_UNPOPULATED   , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T214(214, DESCR("Current LOS |= fST_LOS_REPOPULATE    "), fST_LOS_REPOPULATE    , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T215(215, DESCR("Current LOS |= fST_LOS_MARSHALLABLE  "), fST_LOS_MARSHALLABLE  , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T216(216, DESCR("Current LOS |= fST_LOS_NOLOGIC       "), fST_LOS_NOLOGIC       , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T217(217, DESCR("Current LOS |= fST_LOS_COOKDOWN      "), fST_LOS_COOKDOWN      , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T218(218, DESCR("Current LOS |= fST_LOS_NOMERGE       "), fST_LOS_NOMERGE       , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T219(219, DESCR("Current LOS |= fST_LOS_NOCACHEING    "), fST_LOS_NOCACHEING    , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T220(220, DESCR("Current LOS |= fST_LOS_NODEFAULTS    "), fST_LOS_NODEFAULTS    , TSelectLOS::OR);
TTuxTest2<TSelectLOS, ULONG, TSelectLOS::BoolOperator>          T221(221, DESCR("Current LOS |= fST_LOS_EXTENDEDSCHEMA"), fST_LOS_EXTENDEDSCHEMA, TSelectLOS::OR);

TTuxTest1<TSelectTable, LPWSTR>        T1000(1000, DESCR("Selects Table COLUMNMETA             "),          wszTABLE_COLUMNMETA                         );
TTuxTest1<TSelectTable, LPWSTR>        T1001(1001, DESCR("Selects Table DATABASEMETA           "),          wszTABLE_DATABASEMETA                       );
TTuxTest1<TSelectTable, LPWSTR>        T1002(1002, DESCR("Selects Table INDEXMETA              "),          wszTABLE_INDEXMETA                          );
TTuxTest1<TSelectTable, LPWSTR>        T1003(1003, DESCR("Selects Table TABLEMETA              "),          wszTABLE_TABLEMETA                          );
TTuxTest1<TSelectTable, LPWSTR>        T1004(1004, DESCR("Selects Table TAGMETA                "),          wszTABLE_TAGMETA                            );
TTuxTest1<TSelectTable, LPWSTR>        T1005(1005, DESCR("Selects Table RELATIONMETA           "),          wszTABLE_RELATIONMETA                       );
TTuxTest1<TSelectTable, LPWSTR>        T1006(1006, DESCR("Selects Table QUERYMETA              "),          wszTABLE_QUERYMETA                          );
TTuxTest1<TSelectTable, LPWSTR>        T1007(1007, DESCR("Selects Table SERVERWIRINGMETA       "),          wszTABLE_SERVERWIRINGMETA                   );
TTuxTest1<TSelectTable, LPWSTR>        T1008(1008, DESCR("Selects Table DETAILEDERRORS         "),          wszTABLE_DETAILEDERRORS                     );
TTuxTest1<TSelectTable, LPWSTR>        T1009(1009, DESCR("Selects Table COLLECTION_META        "),          wszTABLE_COLLECTION_META                    );
TTuxTest1<TSelectTable, LPWSTR>        T1010(1010, DESCR("Selects Table PROPERTY_META          "),          wszTABLE_PROPERTY_META                      );
TTuxTest1<TSelectTable, LPWSTR>        T1011(1011, DESCR("Selects Table SERVERWIRING_META      "),          wszTABLE_SERVERWIRING_META                  );
TTuxTest1<TSelectTable, LPWSTR>        T1012(1012, DESCR("Selects Table TAG_META               "),          wszTABLE_TAG_META                           );
TTuxTest1<TSelectTable, LPWSTR>        T1017(1017, DESCR("Selects Table ManagedWiring          "),          wszTABLE_ManagedWiring                      );
TTuxTest1<TSelectTable, LPWSTR>        T1018(1018, DESCR("Selects Table SchemaFiles            "),          wszTABLE_SchemaFiles                        );
TTuxTest1<TSelectTable, LPWSTR>        T1019(1019, DESCR("Selects Table MEMORY_SHAPEABLE       "),          wszTABLE_MEMORY_SHAPEABLE                   );















TTuxTest1<TSelectTable, LPWSTR>        T1035(1035, DESCR("Selects Table globalization          "),          wszTABLE_globalization                      );
TTuxTest1<TSelectTable, LPWSTR>        T1036(1036, DESCR("Selects Table compilation            "),          wszTABLE_compilation                        );
TTuxTest1<TSelectTable, LPWSTR>        T1037(1037, DESCR("Selects Table compilers              "),          wszTABLE_compilers                          );
TTuxTest1<TSelectTable, LPWSTR>        T1038(1038, DESCR("Selects Table assemblies             "),          wszTABLE_assemblies                         );
TTuxTest1<TSelectTable, LPWSTR>        T1039(1039, DESCR("Selects Table trace                  "),          wszTABLE_trace                              );

TTuxTest1<TSelectTable, LPWSTR>        T1041(1041, DESCR("Selects Table authentication         "),          wszTABLE_authentication                     );

TTuxTest1<TSelectTable, LPWSTR>        T1043(1043, DESCR("Selects Table credentials            "),          wszTABLE_credentials                        );

TTuxTest1<TSelectTable, LPWSTR>        T1045(1045, DESCR("Selects Table passport               "),          wszTABLE_passport                           );
TTuxTest1<TSelectTable, LPWSTR>        T1046(1046, DESCR("Selects Table authorization          "),          wszTABLE_authorization                      );
TTuxTest1<TSelectTable, LPWSTR>        T1047(1047, DESCR("Selects Table identity               "),          wszTABLE_identity                           );



















TTuxTest1<TSelectTable, LPWSTR>        T1068(1068, DESCR("Selects Table location               "),          wszTABLE_location                           );
TTuxTest1<TSelectTable, LPWSTR>        T1069(1069, DESCR("Selects Table MetabaseBaseClass      "),          wszTABLE_MetabaseBaseClass                  );
TTuxTest1<TSelectTable, LPWSTR>        T1070(1070, DESCR("Selects Table IIsConfigObject        "),          wszTABLE_IIsConfigObject                    );
TTuxTest1<TSelectTable, LPWSTR>        T1071(1071, DESCR("Selects Table IIsObject              "),          wszTABLE_IIsObject                          );
TTuxTest1<TSelectTable, LPWSTR>        T1072(1072, DESCR("Selects Table IIsComputer            "),          wszTABLE_IIsComputer                        );
TTuxTest1<TSelectTable, LPWSTR>        T1073(1073, DESCR("Selects Table IIsWebService          "),          wszTABLE_IIsWebService                      );
TTuxTest1<TSelectTable, LPWSTR>        T1074(1074, DESCR("Selects Table IIsFtpService          "),          wszTABLE_IIsFtpService                      );
TTuxTest1<TSelectTable, LPWSTR>        T1075(1075, DESCR("Selects Table IIsWebServer           "),          wszTABLE_IIsWebServer                       );
TTuxTest1<TSelectTable, LPWSTR>        T1076(1076, DESCR("Selects Table IIsFtpServer           "),          wszTABLE_IIsFtpServer                       );
TTuxTest1<TSelectTable, LPWSTR>        T1077(1077, DESCR("Selects Table IIsWebFile             "),          wszTABLE_IIsWebFile                         );
TTuxTest1<TSelectTable, LPWSTR>        T1078(1078, DESCR("Selects Table IIsWebDirectory        "),          wszTABLE_IIsWebDirectory                    );
TTuxTest1<TSelectTable, LPWSTR>        T1079(1079, DESCR("Selects Table IIsWebVirtualDir       "),          wszTABLE_IIsWebVirtualDir                   );
TTuxTest1<TSelectTable, LPWSTR>        T1080(1080, DESCR("Selects Table IIsFtpVirtualDir       "),          wszTABLE_IIsFtpVirtualDir                   );
TTuxTest1<TSelectTable, LPWSTR>        T1081(1081, DESCR("Selects Table IIsFilter              "),          wszTABLE_IIsFilter                          );
TTuxTest1<TSelectTable, LPWSTR>        T1082(1082, DESCR("Selects Table IIsFilters             "),          wszTABLE_IIsFilters                         );
TTuxTest1<TSelectTable, LPWSTR>        T1083(1083, DESCR("Selects Table IIsCompressionScheme   "),          wszTABLE_IIsCompressionScheme               );
TTuxTest1<TSelectTable, LPWSTR>        T1084(1084, DESCR("Selects Table IIsCompressionSchemes  "),          wszTABLE_IIsCompressionSchemes              );
TTuxTest1<TSelectTable, LPWSTR>        T1085(1085, DESCR("Selects Table IIsCertMapper          "),          wszTABLE_IIsCertMapper                      );
TTuxTest1<TSelectTable, LPWSTR>        T1086(1086, DESCR("Selects Table IIsMimeMap             "),          wszTABLE_IIsMimeMap                         );
TTuxTest1<TSelectTable, LPWSTR>        T1087(1087, DESCR("Selects Table IIsLogModule           "),          wszTABLE_IIsLogModule                       );
TTuxTest1<TSelectTable, LPWSTR>        T1088(1088, DESCR("Selects Table IIsLogModules          "),          wszTABLE_IIsLogModules                      );
TTuxTest1<TSelectTable, LPWSTR>        T1089(1089, DESCR("Selects Table IIsCustomLogModule     "),          wszTABLE_IIsCustomLogModule                 );
TTuxTest1<TSelectTable, LPWSTR>        T1090(1090, DESCR("Selects Table IIsWebInfo             "),          wszTABLE_IIsWebInfo                         );
TTuxTest1<TSelectTable, LPWSTR>        T1091(1091, DESCR("Selects Table IIsFtpInfo             "),          wszTABLE_IIsFtpInfo                         );
TTuxTest1<TSelectTable, LPWSTR>        T1092(1092, DESCR("Selects Table IIsNntpService         "),          wszTABLE_IIsNntpService                     );
TTuxTest1<TSelectTable, LPWSTR>        T1093(1093, DESCR("Selects Table IIsNntpServer          "),          wszTABLE_IIsNntpServer                      );
TTuxTest1<TSelectTable, LPWSTR>        T1094(1094, DESCR("Selects Table IIsNntpVirtualDir      "),          wszTABLE_IIsNntpVirtualDir                  );
TTuxTest1<TSelectTable, LPWSTR>        T1095(1095, DESCR("Selects Table IIsNntpInfo            "),          wszTABLE_IIsNntpInfo                        );
TTuxTest1<TSelectTable, LPWSTR>        T1096(1096, DESCR("Selects Table IIsSmtpService         "),          wszTABLE_IIsSmtpService                     );
TTuxTest1<TSelectTable, LPWSTR>        T1097(1097, DESCR("Selects Table IIsSmtpServer          "),          wszTABLE_IIsSmtpServer                      );
TTuxTest1<TSelectTable, LPWSTR>        T1098(1098, DESCR("Selects Table IIsSmtpVirtualDir      "),          wszTABLE_IIsSmtpVirtualDir                  );
TTuxTest1<TSelectTable, LPWSTR>        T1099(1099, DESCR("Selects Table IIsSmtpDomain          "),          wszTABLE_IIsSmtpDomain                      );
TTuxTest1<TSelectTable, LPWSTR>        T1100(1100, DESCR("Selects Table IIsSmtpRoutingSource   "),          wszTABLE_IIsSmtpRoutingSource               );
TTuxTest1<TSelectTable, LPWSTR>        T1101(1101, DESCR("Selects Table IIsSmtpInfo            "),          wszTABLE_IIsSmtpInfo                        );
TTuxTest1<TSelectTable, LPWSTR>        T1102(1102, DESCR("Selects Table IIsPop3Service         "),          wszTABLE_IIsPop3Service                     );
TTuxTest1<TSelectTable, LPWSTR>        T1103(1103, DESCR("Selects Table IIsPop3Server          "),          wszTABLE_IIsPop3Server                      );
TTuxTest1<TSelectTable, LPWSTR>        T1104(1104, DESCR("Selects Table IIsPop3VirtualDir      "),          wszTABLE_IIsPop3VirtualDir                  );
TTuxTest1<TSelectTable, LPWSTR>        T1105(1105, DESCR("Selects Table IIsPop3RoutingSource   "),          wszTABLE_IIsPop3RoutingSource               );
TTuxTest1<TSelectTable, LPWSTR>        T1106(1106, DESCR("Selects Table IIsPop3Info            "),          wszTABLE_IIsPop3Info                        );
TTuxTest1<TSelectTable, LPWSTR>        T1107(1107, DESCR("Selects Table IIsImapService         "),          wszTABLE_IIsImapService                     );
TTuxTest1<TSelectTable, LPWSTR>        T1108(1108, DESCR("Selects Table IIsImapServer          "),          wszTABLE_IIsImapServer                      );
TTuxTest1<TSelectTable, LPWSTR>        T1109(1109, DESCR("Selects Table IIsImapVirtualDir      "),          wszTABLE_IIsImapVirtualDir                  );
TTuxTest1<TSelectTable, LPWSTR>        T1110(1110, DESCR("Selects Table IIsImapRoutingSource   "),          wszTABLE_IIsImapRoutingSource               );
TTuxTest1<TSelectTable, LPWSTR>        T1111(1111, DESCR("Selects Table IIsImapInfo            "),          wszTABLE_IIsImapInfo                        );
TTuxTest1<TSelectTable, LPWSTR>        T1112(1112, DESCR("Selects Table IIsNntpRebuild         "),          wszTABLE_IIsNntpRebuild                     );
TTuxTest1<TSelectTable, LPWSTR>        T1113(1113, DESCR("Selects Table IIsNntpSessions          "),        wszTABLE_IIsNntpSessions                    );
TTuxTest1<TSelectTable, LPWSTR>        T1114(1114, DESCR("Selects Table IIsNntpFeeds             "),        wszTABLE_IIsNntpFeeds                       );
TTuxTest1<TSelectTable, LPWSTR>        T1115(1115, DESCR("Selects Table IIsNntpExpiration        "),        wszTABLE_IIsNntpExpiration                  );
TTuxTest1<TSelectTable, LPWSTR>        T1116(1116, DESCR("Selects Table IIsNntpGroups            "),        wszTABLE_IIsNntpGroups                      );
TTuxTest1<TSelectTable, LPWSTR>        T1117(1117, DESCR("Selects Table IIsSmtpSessions          "),        wszTABLE_IIsSmtpSessions                    );
TTuxTest1<TSelectTable, LPWSTR>        T1118(1118, DESCR("Selects Table IIsPop3Sessions          "),        wszTABLE_IIsPop3Sessions                    );
TTuxTest1<TSelectTable, LPWSTR>        T1119(1119, DESCR("Selects Table IIsImapSessions          "),        wszTABLE_IIsImapSessions                    );
TTuxTest1<TSelectTable, LPWSTR>        T1120(1120, DESCR("Selects Table IIS_FTP_TEMPLATE         "),        wszTABLE_IIS_FTP_TEMPLATE                   );
TTuxTest1<TSelectTable, LPWSTR>        T1121(1121, DESCR("Selects Table IIS_FTP_TEMPLATESETTINGS "),        wszTABLE_IIS_FTP_TEMPLATESETTINGS           );
TTuxTest1<TSelectTable, LPWSTR>        T1122(1122, DESCR("Selects Table IIS_WEB_TEMPLATE         "),        wszTABLE_IIS_WEB_TEMPLATE                   );
TTuxTest1<TSelectTable, LPWSTR>        T1123(1123, DESCR("Selects Table IIS_WEB_TEMPLATESETTINGS "),        wszTABLE_IIS_WEB_TEMPLATESETTINGS           );
TTuxTest1<TSelectTable, LPWSTR>        T1124(1124, DESCR("Selects Table IIS_ADMIN                "),        wszTABLE_IIS_ADMIN                          );
TTuxTest1<TSelectTable, LPWSTR>        T1125(1125, DESCR("Selects Table IIS_EVENTMANAGER         "),        wszTABLE_IIS_EVENTMANAGER                   );
TTuxTest1<TSelectTable, LPWSTR>        T1126(1126, DESCR("Selects Table IIS_ROOT                 "),        wszTABLE_IIS_ROOT                           );
TTuxTest1<TSelectTable, LPWSTR>        T1127(1127, DESCR("Selects Table IIS_Global               "),        wszTABLE_IIS_Global                         );
TTuxTest1<TSelectTable, LPWSTR>        T1128(1128, DESCR("Selects Table MBProperty               "),        wszTABLE_MBProperty                         );
TTuxTest1<TSelectTable, LPWSTR>        T1129(1129, DESCR("Selects Table MBPropertyDiff           "),        wszTABLE_MBPropertyDiff                     );
TTuxTest1<TSelectTable, LPWSTR>        T1130(1130, DESCR("Selects Table APPPOOLS                 "),        wszTABLE_APPPOOLS                           );
TTuxTest1<TSelectTable, LPWSTR>        T1131(1131, DESCR("Selects Table SITES                    "),        wszTABLE_SITES                              );
TTuxTest1<TSelectTable, LPWSTR>        T1132(1132, DESCR("Selects Table APPS                     "),        wszTABLE_APPS                               );
TTuxTest1<TSelectTable, LPWSTR>        T1133(1133, DESCR("Selects Table GlobalW3SVC              "),        wszTABLE_GlobalW3SVC                        );
TTuxTest1<TSelectTable, LPWSTR>        T1134(1134, DESCR("Selects Table CHANGENUMBER             "),        wszTABLE_CHANGENUMBER                       );
TTuxTest1<TSelectTable, LPWSTR>        T1135(1135, DESCR("Selects Table Dirs                     "),        wszTABLE_Dirs                               );
TTuxTest1<TSelectTable, LPWSTR>        T1136(1136, DESCR("Selects Table VDir                     "),        wszTABLE_VDir                               );

TTuxTest1<TSelectTable, LPWSTR>        T1146(1146, DESCR("Selects Table TestProperty               "),     wszTABLE_TestProperty                       );
TTuxTest1<TSelectTable, LPWSTR>        T1147(1147, DESCR("Selects Table NormalTable                "),     wszTABLE_NormalTable                        );
TTuxTest1<TSelectTable, LPWSTR>        T1148(1148, DESCR("Selects Table NoParentTable              "),     wszTABLE_NoParentTable                      );
TTuxTest1<TSelectTable, LPWSTR>        T1149(1149, DESCR("Selects Table ContainedTable             "),     wszTABLE_ContainedTable                     );
TTuxTest1<TSelectTable, LPWSTR>        T1150(1150, DESCR("Selects Table NoParentContainedTable     "),     wszTABLE_NoParentContainedTable             );
TTuxTest1<TSelectTable, LPWSTR>        T1151(1151, DESCR("Selects Table ParentToEnumAsPublicRowName"),     wszTABLE_ParentToEnumAsPublicRowName        );
TTuxTest1<TSelectTable, LPWSTR>        T1152(1152, DESCR("Selects Table EnumAsPublicRowName        "),     wszTABLE_EnumAsPublicRowName                );
TTuxTest1<TSelectTable, LPWSTR>        T1153(1153, DESCR("Selects Table EnumAsPublicRowName2       "),     wszTABLE_EnumAsPublicRowName2               );



TTuxTest<TLOSRepopulate>      T401(401, DESCR2("Populates a table with LOSRepopulate and then calls Populate multiple times",
            TEXT("This test Gets 'NormalTable' and does the following LOS tests:            \r\n")
            TEXT("  1>insert a row into an empty file, call update store, release table     \r\n")
            TEXT("  2>get the table with LOS_UNPOPULATED | LOS_REPOPULATE. Count of rows    \r\n")
            TEXT("    should be 0.  After Populate, count of rows should be 1. release table\r\n")
            TEXT("  3>get the table with LOS of 0. Count of rows should be 1.  PopulateCache\r\n")
            TEXT("    should fail.  release table.                                          \r\n")
            TEXT("  4>get the table with LOS_REPOPULATE. Count of rows should be 1.  Subse- \r\n")
            TEXT("    quent PopulateCache should succeed.  release table.                   \r\n")
            TEXT("  5>get the table with LOS_UNPOPULATED update the row just added, call    \r\n")
            TEXT("    update store, release table.                                          \r\n")
            TEXT("  6>get the table with LOS_UNPOPULATED delete the row just added. release \r\n")
            TEXT("    table.                                                                \r\n")
            TEXT("  7>get the table with LOS_UNPOPULATED delete the row again, update store.\r\n")
            TEXT("    release table.                       \r\n")
            TEXT("  8>get the table with LOS_UNPOPULATED update the row previously deleted, \r\n")
            TEXT("    Update store should fail with DetailedErrors. release table.          \r\n")));


TTuxTest<TIErrorInfoTest>     T402(402, DESCR2("GetTable should return fail and SetErrorInfo upon failure",
            TEXT("This test Gets Dirs table from a bogus XML file:                          \r\n")
            TEXT("  1>gets the table and verifies that it returns error.                    \r\n")
            TEXT("  2>calls GetErrorInfo to verify that there is an IErrorInfo set          \r\n")
            TEXT("  3>IErrorInfo::QueryInterface and verify it supports ISimpleTableRead2   \r\n")
            TEXT("  4>call ISimpleTableRead2::GetColumnValues                               \r\n")
            TEXT("  5>call IErrorInfo::GetDescription                                       \r\n")
            TEXT("  6>call IErrorInfo::GetSource                                            \r\n")
            TEXT("  7>verify the return values from IErrorInfo agrees with ISimpleTableRead2\r\n")));


TestResult TGetTableBaseClass::GetTable(bool bLockInParameters)
{
    EM_START

    if(bLockInParameters)
        LockInParameters();

    if(0 == m_pISTDisp.p)
    {
        EM_JIF(GetSimpleTableDispenser(m_szProductID, 0, &m_pISTDisp));
    }

    if(0!=m_szFileName)
    {
        STQueryCell             acellsMeta;
        acellsMeta.pData        = m_szFileName;
        acellsMeta.eOperator    = eST_OP_EQUAL;
        acellsMeta.iCell        = iST_CELL_FILE;
        acellsMeta.dbType       = DBTYPE_WSTR;
        acellsMeta.cbSize       = 0;

        ULONG                   one=1;

        EM_JIF(m_pISTDisp->GetTable(m_szDatabaseName, m_szTableName, reinterpret_cast<LPVOID>(&acellsMeta), reinterpret_cast<LPVOID>(&one), eST_QUERYFORMAT_CELLS, m_LOS, reinterpret_cast<void **>(&m_pISTRead2)));
    }
    else
    {
        EM_JIF(m_pISTDisp->GetTable(m_szDatabaseName, m_szTableName, 0,0, eST_QUERYFORMAT_CELLS, m_LOS, reinterpret_cast<void **>(&m_pISTRead2)));
    }

    EM_JIF(m_pISTRead2->QueryInterface(IID_ISimpleTableAdvanced, reinterpret_cast<LPVOID *>(&m_pISTAdvanced)));
    if(m_LOS & fST_LOS_READWRITE)
    {
        EM_JIF(m_pISTRead2->QueryInterface(IID_ISimpleTableWrite2, reinterpret_cast<LPVOID *>(&m_pISTWrite)));
    }

    EM_CLEANUP
    EM_RETURN_TRESULT
}


void TGetTableBaseClass::LockInParameters()
{
        m_szDatabaseName    = (0==m_szDatabaseName? g_szDatabaseName    : m_szDatabaseName);
        m_szTableName       = (0==m_szTableName   ? g_szTableName       : m_szTableName);
        m_szFileName        = (0==m_szFileName    ? g_szFileName        : m_szFileName);
        m_LOS               = (~0==m_LOS          ? g_LOS               : m_LOS);

        SetProductID(0==m_szProductID   ? g_szProductID     : m_szProductID);

        Debug(TEXT("Database (%s)\r\nTable (%s)\r\nFileName (%s)\r\nProductID (%s)\r\nLOS (0x%08x)\r\n"),
            m_szDatabaseName, m_szTableName, m_szFileName ? m_szFileName : TEXT("none"), m_szProductID, m_LOS);
}


void TGetTableBaseClass::ReleaseTable()
{
    m_pISTRead2.Release();
    m_pISTAdvanced.Release();
    m_pISTWrite.Release();
}


void TGetTableBaseClass::SetProductID(LPTSTR szProductID)
{
    if(szProductID == m_szProductID)
        return;//nothing to do

    m_szProductID = szProductID;
    while(0 != m_pISTDisp.p)//Changing the ProductID invalidates our Dispenser
        m_pISTDisp.Release();
}


////////////////////////////////////////////////////////////////////////////////
// Description:
//  This test Gets NormalTable using LOS_UNPOPULATED then does the following sub tests:
//      1>inserts a row into an empty file, calls update store, releases the table
//      2>gets the table with LOS_UNPOPULATED | LOS_REPOPULATE. Count of row should be 0.  After PopulateCache count of rows should be one.  Release table.
//      3>gets the table with LOS of 0. Count of row should be 1.  PopulateCache should fail.  Release table.
//      4>gets the table with LOS_REPOPULATE. Count of row should be 1.  Subsequent PopulateCache should succeed.  Release table.
//      5>gets the table with LOS_UNPOPULATED updates the row just added, calls update store, releases the table
//      6>gets the table with LOS_UNPOPULATED deletes the row just added, releases the table
//      7>gets the table with LOS_UNPOPULATED deletes the row again, Update store should fails with DetailedErrors. releases the table
//      8>gets the table with LOS_UNPOPULATED updates the row previously deleted, Update store should fails with DetailedErrors. releases the table
//
TestResult TLOSRepopulate::ExecuteTest()
{
    EM_START_SETUP

    LockInParameters();
    if(-1 != GetFileAttributes(m_szFileName))//if the file exists then delete it
    {
        EM_JIT(0 == DeleteFile(m_szFileName));
    }

    EM_TEST_BEGIN

    SetTestNumber(1);
    {// 1>inserts a row into an empty file, calls update store, releases the table
        ULONG   iRow;

        m_LOS |= fST_LOS_UNPOPULATED;
        m_LOS &= ~fST_LOS_REPOPULATE;
        EM_JIF(GetTable());

        EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
        EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cNormalTable_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_rowValues)));
        EM_JIF(m_pISTWrite->UpdateStore());
        ReleaseTable();
    }

    SetTestNumber(2);
    {// 2>gets the table with LOS_UNPOPULATED | LOS_REPOPULATE. Count of row should be 0.  After PopulateCache count of rows should be one.  Release table.
        ULONG cRows;
        m_LOS |= fST_LOS_REPOPULATE | fST_LOS_UNPOPULATED;

        EM_JIF(GetTable());
        EM_JIF(m_pISTRead2->GetTableMeta(0, 0, &cRows, 0));
        EM_JIT(0 != cRows && L"Expected to get back an empty table");

        EM_JIF(m_pISTAdvanced->PopulateCache());
        EM_JIF(m_pISTRead2->GetTableMeta(0, 0, &cRows, 0));
        EM_MIT(1 != cRows && L"Expected to get back a table with exactly one row");

        EM_JIF(m_pISTAdvanced->PopulateCache());
        EM_JIF(m_pISTRead2->GetTableMeta(0, 0, &cRows, 0));
        EM_MIT(1 != cRows && L"Expected to get back a table with exactly one row");
        ReleaseTable();
    }

    SetTestNumber(3);
    {// 3>gets the table with LOS of 0. Count of row should be 1.  PopulateCache should fail.  Release table.
        ULONG cRows;
        m_LOS &= ~(fST_LOS_REPOPULATE | fST_LOS_UNPOPULATED);

        EM_JIF(GetTable());
        EM_JIF(m_pISTRead2->GetTableMeta(0, 0, &cRows, 0));
        EM_JIT(1 != cRows && L"Expected to get back a table with exactly one row");

        EM_JIT(E_ST_LOSNOTSUPPORTED != m_pISTAdvanced->PopulateCache());
        ReleaseTable();
    }
    
    SetTestNumber(4);
    {// 4>gets the table with LOS_REPOPULATE. Count of row should be 1.  Subsequent PopulateCache should succeed.  Release table.
        ULONG cRows;
        m_LOS |= fST_LOS_REPOPULATE;
        m_LOS &= ~fST_LOS_UNPOPULATED;

        EM_JIF(GetTable());
        EM_JIF(m_pISTRead2->GetTableMeta(0, 0, &cRows, 0));
        EM_JIT(1 != cRows && L"Expected to get back a table with exactly one row");

        EM_JIF(m_pISTAdvanced->PopulateCache());
        EM_JIF(m_pISTRead2->GetTableMeta(0, 0, &cRows, 0));
        EM_JIT(1 != cRows && L"Expected to get back a table with exactly one row");

        EM_JIF(m_pISTAdvanced->PopulateCache());
        EM_JIF(m_pISTRead2->GetTableMeta(0, 0, &cRows, 0));
        EM_JIT(1 != cRows && L"Expected to get back a table with exactly one row");
        ReleaseTable();
    }

    SetTestNumber(5);
    {// 5>gets the table with LOS_UNPOPULATED updates the row just added, calls update store, releases the table
        ULONG   iRow;
        CComPtr<ISimpleTableController> pISTController;

        m_LOS |= fST_LOS_UNPOPULATED;
        m_LOS &= ~fST_LOS_REPOPULATE;

        EM_JIF(GetTable());

        EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
        ulTestValue = 411;
        EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cNormalTable_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_rowValues)));

        EM_JIF(m_pISTRead2->QueryInterface(IID_ISimpleTableController, reinterpret_cast<LPVOID *>(&pISTController)));
        EM_JIF(pISTController->SetWriteRowAction(iRow, eST_ROW_UPDATE));

        EM_JIF(m_pISTWrite->UpdateStore());
        ReleaseTable();
    }

    SetTestNumber(6);
    {// 6>gets the table with LOS_UNPOPULATED deletes the row just added, releases the table
        ULONG   iRow;
        CComPtr<ISimpleTableController> pISTController;

        m_LOS |= fST_LOS_UNPOPULATED;
        m_LOS &= ~fST_LOS_REPOPULATE;

        EM_JIF(GetTable());

        EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
        ulTestValue = 411;
        EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cNormalTable_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_rowValues)));

        EM_JIF(m_pISTRead2->QueryInterface(IID_ISimpleTableController, reinterpret_cast<LPVOID *>(&pISTController)));
        EM_JIF(pISTController->SetWriteRowAction(iRow, eST_ROW_DELETE));

        EM_JIF(m_pISTWrite->UpdateStore());
        ReleaseTable();
    }

    SetTestNumber(7);
    {// 7>gets the table with LOS_UNPOPULATED deletes the row again, Update store should fails with DetailedErrors. releases the table
        ULONG   iRow;
        CComPtr<ISimpleTableController> pISTController;

        m_LOS |= fST_LOS_UNPOPULATED;
        m_LOS &= ~fST_LOS_REPOPULATE;

        EM_JIF(GetTable());

        EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
        ulTestValue = 411;
        EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cNormalTable_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_rowValues)));

        EM_JIF(m_pISTRead2->QueryInterface(IID_ISimpleTableController, reinterpret_cast<LPVOID *>(&pISTController)));
        EM_JIF(pISTController->SetWriteRowAction(iRow, eST_ROW_DELETE));

        EM_JIF(m_pISTWrite->UpdateStore());
        ReleaseTable();
    }

    SetTestNumber(8);
    {// 8>gets the table with LOS_UNPOPULATED updates the row previously deleted, Update store should fails with DetailedErrors. releases the table
        ULONG   iRow;
        CComPtr<ISimpleTableController> pISTController;

        m_LOS |= fST_LOS_UNPOPULATED;
        m_LOS &= ~fST_LOS_REPOPULATE;

        EM_JIF(GetTable());

        EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
        ulTestValue = 411;
        EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cNormalTable_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_rowValues)));

        EM_JIF(m_pISTRead2->QueryInterface(IID_ISimpleTableController, reinterpret_cast<LPVOID *>(&pISTController)));
        EM_JIF(pISTController->SetWriteRowAction(iRow, eST_ROW_UPDATE));

        EM_JIT(E_ST_DETAILEDERRS != m_pISTWrite->UpdateStore());
        ReleaseTable();
    }


    EM_CLEANUP
    EM_RETURN_TRESULT
}


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TIErrorInfoTest
//
// Description:
//  This test Gets Dirs table from a bogus XML file:
//      1>gets the table and verifies that it returns error.
//      2>calls GetErrorInfo to verify that there is an IErrorInfo set
//      3>QueryInterface on the IErrorInfo and verify that it supports ISimpleTableRead2
//      4>call ISimpleTableRead2::GetColumnValues
//      5>call IErrorInfo::GetDescription
//      6>call IErrorInfo::GetSource
//      7>verify the return values from IErrorInfo agrees with ISimpleTableRead2
//
TestResult TIErrorInfoTest::ExecuteTest()
{
    EM_START_SETUP

    LockInParameters();
    EM_JIT(-1 == GetFileAttributes(m_szFileName));//the file must exist

    EM_TEST_BEGIN

    SetTestNumber(1);
    {// 1>gets the table and verifies that it returns error.
        EM_JIT(trFAIL != GetTable());
    }

    SetTestNumber(2);
    {// 2>calls GetErrorInfo to verify that there is an IErrorInfo set
        EM_JIT(S_FALSE == GetErrorInfo(0, &spErrorInfo));
    }

    SetTestNumber(3);
    {// 3>QueryInterface on the IErrorInfo and verify that it supports ISimpleTableRead2
        EM_JIF(spErrorInfo->QueryInterface(IID_ISimpleTableRead2, reinterpret_cast<void **>(&spISTRead2)));
    }
    
    SetTestNumber(4);
    {// 4>call ISimpleTableRead2::GetColumnValues
        ULONG cbSizes[cDETAILEDERRORS_NumberOfColumns];
        EM_JIF(spISTRead2->GetColumnValues(0, cDETAILEDERRORS_NumberOfColumns, 0, cbSizes, reinterpret_cast<LPVOID*>(&ErrorRow)));
    }

    SetTestNumber(5);
    {// 5>call IErrorInfo::GetDescription
        EM_JIF(spErrorInfo->GetDescription(&bstrDescription));
    }

    SetTestNumber(6);
    {// 6>call IErrorInfo::GetSource
        EM_JIF(spErrorInfo->GetSource(&bstrSource));
    }

    SetTestNumber(7);
    {// 7>verify the return values from IErrorInfo agrees with ISimpleTableRead2
        EM_JIT(0 != wcscmp(bstrDescription.m_str,   ErrorRow.pDescription));
        EM_JIT(0 != wcscmp(bstrSource.m_str,        ErrorRow.pSource));
    }

    EM_CLEANUP
    EM_RETURN_TRESULT
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\kato.h ===
//******************************************************************************
//
// KATO.H
//
// Definition module for the Kato constants and CKato interface
//
// Date     Name     Description
// -------- -------- -----------------------------------------------------------
// 02/13/95 SteveMil Created
//
//******************************************************************************

#ifndef __KATO_H__
#define __KATO_H__

//******************************************************************************
// Define functions as import when building kato, and as export when this file
// is included by all other applications. We only use KATOAPI on C++ classes.
// For straight C functions, our DEF file will take care of exporting them.
//******************************************************************************

#ifndef KATOAPI
   #define KATOAPI __declspec(dllimport)
#endif

//******************************************************************************
// Define EXTERN_C so that the flat API's will not get mangled by C++
//******************************************************************************

#ifndef EXTERN_C
   #ifdef __cplusplus
      #define EXTERN_C extern "C"
   #else
      #define EXTERN_C
   #endif
#endif

//******************************************************************************
// Specify 32 bit pack size to ensure everyone creates the correct size objects
//******************************************************************************

#pragma pack(4)

//******************************************************************************
// Constants
//******************************************************************************

#define KATO_MAX_LEVEL            31
#define KATO_MAX_VERBOSITY        15
#define KATO_MAX_STRING_LENGTH  1023
#define KATO_MAX_DATA_SIZE      1024

//******************************************************************************
// Types
//******************************************************************************

typedef HANDLE HKATO;

typedef struct _KATOCALLBACKSTRUCTW {
   LPARAM  lParam;
   HKATO   hKato;
   DWORD   dwThreadID;
   DWORD   dwTickCount;
   DWORD   dwLevel;
   DWORD   dwLevelID;
   DWORD   dwVerbosity;
   LPCWSTR wszLog;
} KATOCALLBACKSTRUCTW, *LPKATOCALLBACKSTRUCTW;

typedef struct _KATOCALLBACKSTRUCTA {
   LPARAM  lParam;
   HKATO   hKato;
   DWORD   dwThreadID;
   DWORD   dwTickCount;
   DWORD   dwLevel;
   DWORD   dwLevelID;
   DWORD   dwVerbosity;
   LPCSTR  szLog;
} KATOCALLBACKSTRUCTA, *LPKATOCALLBACKSTRUCTA;

typedef BOOL (CALLBACK *LPKATOCALLBACKW)(LPKATOCALLBACKSTRUCTW);
typedef BOOL (CALLBACK *LPKATOCALLBACKA)(LPKATOCALLBACKSTRUCTA);

typedef enum _KATO_FLUSH_TYPE {
   KATO_FLUSH_ON,
   KATO_FLUSH_OFF,
   KATO_FLUSH_NOW,
} KATO_FLUSH_TYPE, *LPKATO_FLUSH_TYPE;

//******************************************************************************
// Common APIs for C and C++ interfaces
//******************************************************************************

EXTERN_C BOOL  WINAPI KatoSetServerW(LPCWSTR wszServer);
EXTERN_C BOOL  WINAPI KatoSetServerA(LPCSTR szServer);
EXTERN_C BOOL  WINAPI KatoGetServerW(LPWSTR wszServer, INT nCount);
EXTERN_C BOOL  WINAPI KatoGetServerA(LPSTR szServer, INT nCount);
EXTERN_C BOOL  WINAPI KatoSetCallbackW(LPKATOCALLBACKW lpCallbackW, LPARAM lParam);
EXTERN_C BOOL  WINAPI KatoSetCallbackA(LPKATOCALLBACKA lpCallbackA, LPARAM lParam);
EXTERN_C BOOL  WINAPI KatoFlush(KATO_FLUSH_TYPE flushType);
EXTERN_C BOOL  WINAPI KatoDebug(BOOL fEnabled, DWORD dwMaxLogVersbosity, 
                                DWORD dwMaxCommentVersbosity, DWORD dwMaxLevel);

EXTERN_C HKATO WINAPI KatoGetDefaultObject(VOID);

//******************************************************************************
// APIs for C interface (C++ applications should use the CKato class)
//******************************************************************************

// Construction and destruction
EXTERN_C HKATO WINAPI  KatoCreateW(LPCWSTR wszName);
EXTERN_C HKATO WINAPI  KatoCreateA(LPCSTR szName);
EXTERN_C BOOL  WINAPI  KatoDestroy(HKATO hKato);

// Unicode functions
EXTERN_C INT   WINAPIV KatoBeginLevelW(HKATO hKato, DWORD dwLevelID, LPCWSTR wszFormat, ...);
EXTERN_C INT   WINAPIV KatoBeginLevelVW(HKATO hKato, DWORD dwLevelID, LPCWSTR wszFormat, va_list pArgs);
EXTERN_C INT   WINAPIV KatoEndLevelW(HKATO hKato, LPCWSTR wszFormat, ...);
EXTERN_C INT   WINAPIV KatoEndLevelVW(HKATO hKato, LPCWSTR wszFormat, va_list pArgs);
EXTERN_C BOOL  WINAPIV KatoLogW(HKATO hKato, DWORD dwVerbosity, LPCWSTR wszFormat, ...);
EXTERN_C BOOL  WINAPIV KatoLogVW(HKATO hKato, DWORD dwVerbosity, LPCWSTR wszFormat, va_list pArgs);
EXTERN_C BOOL  WINAPIV KatoCommentW(HKATO hKato, DWORD dwVerbosity, LPCWSTR wszFormat, ...);
EXTERN_C BOOL  WINAPIV KatoCommentVW(HKATO hKato, DWORD dwVerbosity, LPCWSTR wszFormat, va_list pArgs);

// ASCII functions
EXTERN_C INT   WINAPIV KatoBeginLevelA(HKATO hKato, DWORD dwLevelID, LPCSTR szFormat, ...);
EXTERN_C INT   WINAPIV KatoBeginLevelVA(HKATO hKato, DWORD dwLevelID, LPCSTR szFormat, va_list pArgs);
EXTERN_C INT   WINAPIV KatoEndLevelA(HKATO hKato, LPCSTR szFormat, ...);
EXTERN_C INT   WINAPIV KatoEndLevelVA(HKATO hKato, LPCSTR szFormat, va_list pArgs);
EXTERN_C BOOL  WINAPIV KatoLogA(HKATO hKato, DWORD dwVerbosity, LPCSTR szFormat, ...);
EXTERN_C BOOL  WINAPIV KatoLogVA(HKATO hKato, DWORD dwVerbosity, LPCSTR szFormat, va_list pArgs);
EXTERN_C BOOL  WINAPIV KatoCommentA(HKATO hKato, DWORD dwVerbosity, LPCSTR szFormat, ...);
EXTERN_C BOOL  WINAPIV KatoCommentVA(HKATO hKato, DWORD dwVerbosity, LPCSTR szFormat, va_list pArgs);

// Non-string functions
EXTERN_C BOOL  WINAPI  KatoSetItemData(HKATO hKato, DWORD dwItemData);
EXTERN_C DWORD WINAPI  KatoGetItemData(HKATO hKato);
EXTERN_C BOOL  WINAPI  KatoSendSystemData(HKATO hKato, DWORD dwSystemID, LPCVOID lpcvBuffer, DWORD dwSize);
EXTERN_C DWORD WINAPI  KatoGetCurrentLevel(HKATO hKato);
EXTERN_C INT   WINAPI  KatoGetVerbosityCount(HKATO hKato, DWORD dwVerbosity, DWORD dwLevel);

//******************************************************************************
// Map function names to the correct APIs based on the UNICODE flag
//******************************************************************************

#ifdef UNICODE
   #define KATOCALLBACKSTRUCT   KATOCALLBACKSTRUCTW
   #define LPKATOCALLBACKSTRUCT LPKATOCALLBACKSTRUCTW
   #define LPKATOCALLBACK       LPKATOCALLBACKW
   #define KatoCreate           KatoCreateW
   #define KatoSetCallback      KatoSetCallbackW
   #define KatoSetServer        KatoSetServerW
   #define KatoGetServer        KatoGetServerW
   #define KatoBeginLevel       KatoBeginLevelW
   #define KatoBeginLevelV      KatoBeginLevelVW
   #define KatoEndLevel         KatoEndLevelW
   #define KatoEndLevelV        KatoEndLevelVW
   #define KatoLog              KatoLogW
   #define KatoLogV             KatoLogVW
   #define KatoComment          KatoCommentW
   #define KatoCommentV         KatoCommentVW
#else
   #define KATOCALLBACKSTRUCT   KATOCALLBACKSTRUCTA
   #define LPKATOCALLBACKSTRUCT LPKATOCALLBACKSTRUCTA
   #define LPKATOCALLBACK       LPKATOCALLBACKA
   #define KatoCreate           KatoCreateA
   #define KatoSetCallback      KatoSetCallbackA
   #define KatoSetServer        KatoSetServerA
   #define KatoGetServer        KatoGetServerA
   #define KatoBeginLevel       KatoBeginLevelA
   #define KatoBeginLevelV      KatoBeginLevelVA
   #define KatoEndLevel         KatoEndLevelA
   #define KatoEndLevelV        KatoEndLevelVA
   #define KatoLog              KatoLogA
   #define KatoLogV             KatoLogVA
   #define KatoComment          KatoCommentA
   #define KatoCommentV         KatoCommentVA
#endif

//******************************************************************************
// CKato - Interface for C++ applications
//******************************************************************************

#ifdef __cplusplus

class KATOAPI CKato {
public:
   // Overlaod new and delete to prevent mismatched heaps (KB:Q122675)
   void* __cdecl operator new(size_t stAllocate);
   void  __cdecl operator delete(void *pvMemory);

   // Construction and destruction
   CKato(LPCWSTR wszName = NULL);
   CKato(LPCSTR szName);
   virtual ~CKato(VOID);

   // Unicode functions
   INT  WINAPIV BeginLevel (DWORD dwLevelID, LPCWSTR wszFormat, ...);
   INT  WINAPI  BeginLevelV(DWORD dwLevelID, LPCWSTR wszFormat, va_list pArgs);
   INT  WINAPIV EndLevel (LPCWSTR wszFormat, ...);
   INT  WINAPI  EndLevelV(LPCWSTR wszFormat, va_list pArgs);
   BOOL WINAPIV Log (DWORD dwVerbosity, LPCWSTR wszFormat, ...);
   BOOL WINAPI  LogV(DWORD dwVerbosity, LPCWSTR wszFormat, va_list pArgs);
   BOOL WINAPIV Comment (DWORD dwVerbosity, LPCWSTR wszFormat, ...);
   BOOL WINAPI  CommentV(DWORD dwVerbosity, LPCWSTR wszFormat, va_list pArgs);

   // ASCII functions
   INT  WINAPIV BeginLevel (DWORD dwLevelID, LPCSTR szFormat, ...);
   INT  WINAPI  BeginLevelV(DWORD dwLevelID, LPCSTR szFormat, va_list pArgs);
   INT  WINAPIV EndLevel (LPCSTR szFormat, ...);
   INT  WINAPI  EndLevelV(LPCSTR szFormat, va_list pArgs);
   BOOL WINAPIV Log (DWORD dwVerbosity, LPCSTR szFormat, ...);
   BOOL WINAPI  LogV(DWORD dwVerbosity, LPCSTR szFormat, va_list pArgs);
   BOOL WINAPIV Comment (DWORD dwVerbosity, LPCSTR szFormat, ...);
   BOOL WINAPI  CommentV(DWORD dwVerbosity, LPCSTR szFormat, va_list pArgs);

   // Non-string functions
   BOOL  WINAPI SetItemData(DWORD dwItemData);
   DWORD WINAPI GetItemData(VOID);
   BOOL  WINAPI SendSystemData(DWORD dwSystemID, LPCVOID lpcvBuffer, DWORD dwSize);
   DWORD WINAPI GetCurrentLevel(VOID);
   INT   WINAPI GetVerbosityCount(DWORD dwVerbosity, DWORD dwLevel = -1);

   // Internal data
protected:
   LPVOID m_lpvKatoData;
};

#endif // __cplusplus

#pragma pack() // restore packing size to previous state

#endif // __KATO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\main.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  TUX DLL
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module: main.cpp
//          Contains the shell processing function.
//
//  Revision History:
//      11/13/1997  stephenr    Created by the TUX DLL AppWizard.
//
////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "main.h"

#ifdef COMPILE_TUXDLL_AS_EXE
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    SPS_SHELL_INFO  ShellInfo={0};
    g_pShellInfo = &ShellInfo;
    g_pShellInfo->hInstance = hInstance;
    g_hModule = hInstance;

    TuxTestBase::StaticExecuteTest(lpCmdLine);

    return(0);
}
#else
#ifdef UNDER_CE
////////////////////////////////////////////////////////////////////////////////
// DllMain
//  Main entry point of the DLL. Called when the DLL is loaded or unloaded.
//
// Parameters:
//  hInstance       Module instance of the DLL.
//  dwReason        Reason for the function call.
//  lpReserved      Reserved for future use.
//
// Return value:
//  TRUE if successful, FALSE to indicate an error condition.

BOOL WINAPI DllMain(HANDLE hInstance, ULONG dwReason, LPVOID lpReserved)
{
    // Any initialization code goes here.
    return TRUE;
}
#endif // UNDER_CE
#endif //COMPILE_AS_EXE

////////////////////////////////////////////////////////////////////////////////
// ConvertString
//  Converts the given wide string to either a UNICODE or ANSI string
//
// Parameters:
//  LPTSTR      The output string
//  LPWSTR      The input wide string
//  DWORD       The length of the output string (in bytes)
//
// Return value:
//  TRUE is the function succeded.

#ifdef UNICODE
bool ConvertString(LPTSTR pszOut, LPCTSTR pwszIn, DWORD dwSize)
{
    return wcslen(pwszIn) < dwSize ? !!wcscpy(pszOut, pwszIn) : false;
}
#else
bool ConvertString(LPTSTR pszOut, LPWSTR pwszIn, DWORD dwSize)
{
    return !!WideCharToMultiByte( CP_ACP, 0, pwszIn, -1, pszOut, dwSize, NULL, NULL);
}
#endif   // UNICODE

////////////////////////////////////////////////////////////////////////////////
// Debug
//  Printf-like wrapping around OutputDebugString.
//
// Parameters:
//  szFormat        Formatting string (as in printf).
//  ...             Additional arguments.
//
// Return value:
//  None.

void Debug(LPCTSTR szFormat, ...)
{
    static  TCHAR   szHeader[] = TEXT("CONFIG: ");
    TCHAR   szBuffer[1024];

    va_list pArgs;
    va_start(pArgs, szFormat);
    wcscpy(szBuffer, szHeader);
    wvsprintf(
        szBuffer + countof(szHeader) - 1,
        szFormat,
        pArgs);
    va_end(pArgs);

    _tcscat(szBuffer, TEXT("\r\n"));

    OutputDebugString(szBuffer);
    if(g_pKato)
        g_pKato->Log(LOG_EXCEPTION, szBuffer);
}

////////////////////////////////////////////////////////////////////////////////
// ShellProc
//  Processes messages from the TUX shell.
//
// Parameters:
//  uMsg            Message code.
//  spParam         Additional message-dependent data.
//
// Return value:
//  Depends on the message.

SHELLPROCAPI ShellProc(UINT uMsg, SPPARAM spParam)
{
    LPSPS_BEGIN_TEST    pBT;
    LPSPS_END_TEST      pET;

    switch (uMsg)
    {
    case SPM_LOAD_DLL:
        // Sent once to the DLL immediately after it is loaded. The spParam
        // parameter will contain a pointer to a SPS_LOAD_DLL structure. The
        // DLL should set the fUnicode member of this structure to TRUE if the
        // DLL is built with the UNICODE flag set. If you set this flag, Tux
        // will ensure that all strings passed to your DLL will be in UNICODE
        // format, and all strings within your function table will be processed
        // by Tux as UNICODE. The DLL may return SPR_FAIL to prevent the DLL
        // from continuing to load.
        Debug(TEXT("ShellProc(SPM_LOAD_DLL, ...) called"));

        // If we are UNICODE, then tell Tux this by setting the following flag.
#ifdef UNICODE
        ((LPSPS_LOAD_DLL)spParam)->fUnicode = TRUE;
#endif // UNICODE
        g_pKato = (CKato*)KatoGetDefaultObject();
        break;

    case SPM_UNLOAD_DLL:
        // Sent once to the DLL immediately before it is unloaded.
        Debug(TEXT("ShellProc(SPM_UNLOAD_DLL, ...) called"));
        break;

    case SPM_SHELL_INFO:
        // Sent once to the DLL immediately after SPM_LOAD_DLL to give the DLL
        // some useful information about its parent shell and environment. The
        // spParam parameter will contain a pointer to a SPS_SHELL_INFO
        // structure. The pointer to the structure may be stored for later use
        // as it will remain valid for the life of this Tux Dll. The DLL may
        // return SPR_FAIL to prevent the DLL from continuing to load.
        Debug(TEXT("ShellProc(SPM_SHELL_INFO, ...) called"));

        // Store a pointer to our shell info for later use.
        g_pShellInfo = (LPSPS_SHELL_INFO)spParam;
        break;

    case SPM_REGISTER:
        // This is the only ShellProc() message that a DLL is required to
        // handle (except for SPM_LOAD_DLL if you are UNICODE). This message is
        // sent once to the DLL immediately after the SPM_SHELL_INFO message to
        // query the DLL for its function table. The spParam will contain a
        // pointer to a SPS_REGISTER structure. The DLL should store its
        // function table in the lpFunctionTable member of the SPS_REGISTER
        // structure. The DLL may return SPR_FAIL to prevent the DLL from
        // continuing to load.
        Debug(TEXT("ShellProc(SPM_REGISTER, ...) called"));
//@@@Obsolete        ((LPSPS_REGISTER)spParam)->lpFunctionTable = g_lpFTE;
        ((LPSPS_REGISTER)spParam)->lpFunctionTable = TuxEntry::GetFunctionTable();
#ifdef UNICODE
        return SPR_HANDLED | SPF_UNICODE;
#else // UNICODE
        return SPR_HANDLED;
#endif // UNICODE

    case SPM_START_SCRIPT:
        // Sent to the DLL immediately before a script is started. It is sent
        // to all Tux DLLs, including loaded Tux DLLs that are not in the
        // script. All DLLs will receive this message before the first
        // TestProc() in the script is called.
        Debug(TEXT("ShellProc(SPM_START_SCRIPT, ...) called"));
        break;

    case SPM_STOP_SCRIPT:
        // Sent to the DLL when the script has stopped. This message is sent
        // when the script reaches its end, or because the user pressed
        // stopped prior to the end of the script. This message is sent to
        // all Tux DLLs, including loaded Tux DLLs that are not in the script.
        Debug(TEXT("ShellProc(SPM_STOP_SCRIPT, ...) called"));
        break;

    case SPM_BEGIN_GROUP:
        // Sent to the DLL before a group of tests from that DLL is about to
        // be executed. This gives the DLL a time to initialize or allocate
        // data for the tests to follow. Only the DLL that is next to run
        // receives this message. The prior DLL, if any, will first receive
        // a SPM_END_GROUP message. For global initialization and
        // de-initialization, the DLL should probably use SPM_START_SCRIPT
        // and SPM_STOP_SCRIPT, or even SPM_LOAD_DLL and SPM_UNLOAD_DLL.
        Debug(TEXT("ShellProc(SPM_BEGIN_GROUP, ...) called"));
        g_pKato->BeginLevel(0, TEXT("BEGIN GROUP: CfgDevTest0.DLL"));
        break;

    case SPM_END_GROUP:
        // Sent to the DLL after a group of tests from that DLL has completed
        // running. This gives the DLL a time to cleanup after it has been
        // run. This message does not mean that the DLL will not be called
        // again; it just means that the next test to run belongs to a
        // different DLL. SPM_BEGIN_GROUP and SPM_END_GROUP allow the DLL
        // to track when it is active and when it is not active.
        Debug(TEXT("ShellProc(SPM_END_GROUP, ...) called"));
        g_pKato->EndLevel(TEXT("END GROUP: CfgDevTest0.DLL"));
        break;

    case SPM_BEGIN_TEST:
        // Sent to the DLL immediately before a test executes. This gives
        // the DLL a chance to perform any common action that occurs at the
        // beginning of each test, such as entering a new logging level.
        // The spParam parameter will contain a pointer to a SPS_BEGIN_TEST
        // structure, which contains the function table entry and some other
        // useful information for the next test to execute. If the ShellProc
        // function returns SPR_SKIP, then the test case will not execute.
        Debug(TEXT("ShellProc(SPM_BEGIN_TEST, ...) called"));
        // Start our logging level.
        pBT = (LPSPS_BEGIN_TEST)spParam;
        g_pKato->BeginLevel(
            pBT->lpFTE->dwUniqueID,
            TEXT("BEGIN TEST: \"%s\", Threads=%u, Seed=%u"),
            pBT->lpFTE->lpDescription,
            pBT->dwThreadCount,
            pBT->dwRandomSeed);
        break;

    case SPM_END_TEST:
        // Sent to the DLL after a single test executes from the DLL.
        // This gives the DLL a time perform any common action that occurs at
        // the completion of each test, such as exiting the current logging
        // level. The spParam parameter will contain a pointer to a
        // SPS_END_TEST structure, which contains the function table entry and
        // some other useful information for the test that just completed. If
        // the ShellProc returned SPR_SKIP for a given test case, then the
        // ShellProc() will not receive a SPM_END_TEST for that given test case.
        Debug(TEXT("ShellProc(SPM_END_TEST, ...) called"));
        // End our logging level.
        pET = (LPSPS_END_TEST)spParam;
        g_pKato->EndLevel(
            TEXT("END TEST: \"%s\", %s, Time=%u.%03u"),
            pET->lpFTE->lpDescription,
            pET->dwResult == TPR_SKIP ? TEXT("SKIPPED") :
            pET->dwResult == TPR_PASS ? TEXT("PASSED") :
            pET->dwResult == TPR_FAIL ? TEXT("FAILED") : TEXT("ABORTED"),
            pET->dwExecutionTime / 1000, pET->dwExecutionTime % 1000);
        break;

    case SPM_EXCEPTION:
        // Sent to the DLL whenever code execution in the DLL causes and
        // exception fault. TUX traps all exceptions that occur while
        // executing code inside a test DLL.
        Debug(TEXT("ShellProc(SPM_EXCEPTION, ...) called"));
        g_pKato->Log(LOG_EXCEPTION, TEXT("Exception occurred!"));
        break;

    default:
        // Any messages that we haven't processed must, by default, cause us
        // to return SPR_NOT_HANDLED. This preserves compatibility with future
        // versions of the TUX shell protocol, even if new messages are added.
        return SPR_NOT_HANDLED;
    }

    return SPR_HANDLED;
}

////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\main.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  TUX DLL
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module: main.h
//          Header for all files in the project.
//
//  Revision History:
//      11/13/1997  stephenr    Created by the TUX DLL AppWizard.
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __MAIN_H__
#define __MAIN_H__

////////////////////////////////////////////////////////////////////////////////
// Included files

#ifndef __STDAFX_H__
    #include "stdafx.h"
#endif

////////////////////////////////////////////////////////////////////////////////
// Suggested log verbosities

#define LOG_EXCEPTION          0
#define LOG_FAIL               2
#define LOG_ABORT              4
#define LOG_SKIP               6
#define LOG_NOT_IMPLEMENTED    8
#define LOG_PASS              10
#define LOG_DETAIL            12
#define LOG_COMMENT           14

////////////////////////////////////////////////////////////////////////////////

#endif // __MAIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\smartcom.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  ProjectName
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module:  SmartCom.cpp
//           Usefull functions, classes and macros for making Com programming
//           fun and easy.  Tell your friends, "When it's gotta be COM,
//           it's gotta be SmartCom."
//
//  Revision History:
//      11/17/1997  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"

void _ComBaseAssignPtr (IUnknown **pp, IUnknown *p)
{
    AddRefInterface (p);
    ReleaseInterface (*pp);
	*pp = p;
}


void _ComBaseAssignQIPtr (IUnknown **pp, IUnknown *p, const IID &iid)
{
	IUnknown * pTemp = *pp;
	*pp = 0;
    if (p)
        p->QueryInterface (iid, (void**)pp);
	ReleaseInterface  (pTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\smartcom.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module:  SmartCom.h
//           Usefull functions, classes and macros for making Com programming
//           fun and easy.  Tell your friends, "When it's gotta be COM,
//           it's gotta be SmartCom."
//
//  Revision History:
//      11/17/1997  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////


#ifndef __SMARTCOM_H__
#define __SMARTCOM_H__

template <class T> inline void AddRefInterface  (T *p) { if (p) p->AddRef(); }

template <class T> inline void ReleaseInterface (T *p) { if (p) p->Release(); }

template <class T> inline void ReleaseAndNull (T *&p) { ReleaseInterface (p); p = 0; }


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TCom
//
// Description:
//  Simple class that encapsulates initialization of the Com library.  Declare
//  one of these inside of each thread that wants to use Com.  We default to
//  COINIT_MULTITHREADED instead of COINIT_APARTMENTTHREADED.  This will fail
//  if the OS is too old.
//
class TCom
{
    public:
#ifdef WORK_AROUND_COINITIALIZE_BUG
        TCom ()     : m_hResult (0) { }
        explicit TCom (DWORD dwFlags)
                    : m_hResult (0) { }
#else
        TCom ()     : m_hResult ( CoInitializeEx (0, COINIT_MULTITHREADED)) { }
        explicit TCom (DWORD dwFlags)
                    : m_hResult (CoInitializeEx (0, dwFlags)) { }
#endif
#ifdef WORK_AROUND_COINITIALIZE_BUG
        ~TCom ()    {}
#else
        ~TCom ()    {if (SUCCEEDED (m_hResult)) ::CoUninitialize ();}
#endif
        HRESULT     GetResult () const { return m_hResult; }

        bool        operator ! () const { return FAILED (m_hResult); }
        operator bool () const          { return SUCCEEDED (m_hResult); }

    private:
        HRESULT m_hResult;
};


extern void _ComBaseAssignPtr   (IUnknown **pp, IUnknown *p);
extern void _ComBaseAssignQIPtr (IUnknown **pp, IUnknown *p, const IID &);


////////////////////////////////////////////////////////////////////////////////
//
// Class Template
//  TComPtr
//
// Description:
//  This template help keep track of ref counts for you.  Assign the pointer
//  and it will automatically have its ref count incremented.  Delete it,
//  or NULL it out and the ref count will be decremented.
//
template <class T>
class TComPtr
{
    public:
        TComPtr (const TComPtr<T>& c)  : m_p(c.m_p) { AddRefInterface (m_p); }
        TComPtr (T *p)                 : m_p(p)     { AddRefInterface (m_p); }
        TComPtr ()                     : m_p(0)     { }
        ~TComPtr()                                  { ReleaseInterface (m_p); }

        void SafeAddRef ()              { AddRefInterface (m_p); }
        void SafeRelease()              { ReleaseAndNull (m_p); }
        IUnknown * AsUnknown () const   { return m_pUnk; }

        //  The assert on operator& usually indicates a bug:
        T** operator  & ()                      { ASSERT(!m_p); return &m_p; }
        T * operator  = (T *p)                  { return AssignPtr (p); }
        T * operator  = (const TComPtr<T>& c)   { return AssignPtr (c.m_p); }

        operator      T*() const                { return m_p; }
        T & operator  * () const                { ASSERT(m_p); return *m_p; }
        T * operator  ->() const                { ASSERT(m_p); return m_p; }
        bool operator ! () const                { return !m_p; }
        operator bool   () const                { return (NULL != m_p); }

        bool operator == (const TComPtr<T> &c) const { return m_p == c.m_p; }
        bool operator != (const TComPtr<T> &c) const { return m_p != c.m_p; }

        bool operator == (const T * p) const { return m_p == p; }
        bool operator != (const T * p) const { return m_p != p; }

    protected:
        union
        {
            T         * m_p;
            IUnknown  * m_pUnk;
        };

        inline T * AssignPtr (T *p)
            { _ComBaseAssignPtr (&m_pUnk, p); return m_p; }
};


#endif // __SMARTCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\mbschematests.cpp ===
#include "stdafx.h"
#include "LOSRepopulate.h"//TGetTableBaseClass is defined here

////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TMBSchemaGenerationTest
//
// Description:
//  This test generate the MBSchema.Bin file from MBSchema.Xml, then does a GetTable on ColumnMeta using the generated bin file as
//          the first cell of the query:
//      1>QueryInterface on the Dispenser for IMetabaseSchemaCompiler.          
//      2>Generates the Bin File and the MBSchema.Xml file.                     
//      3>Populates the ColumnMeta using the Bin file as part of the query.     
//      4>Make a copy of the Bin file.                                          
//      5>Generates the Bin File and the MBSchema.Xml file from the newly       
//        created MBSchema.Xml file.                                            
//      6>Compare the first Bin file with the secind Bin file (they should be   
//        identical).                                                           
//      7>Compare the first Xml file with the secind Xml file (they should be   
//        identical).                                                           
//
class TMBSchemaGenerationTest : public TestBase, public TestCase, public TGetTableBaseClass
{
    public:
        TMBSchemaGenerationTest() : 
          TGetTableBaseClass(wszDATABASE_META, wszTABLE_COLUMNMETA, TEXT("MBSchema.bin"), L"IIS", 0)
          {
          }

        virtual TestResult  ExecuteTest();
    protected:
};



TTuxTest<TMBSchemaGenerationTest>      T411(411, DESCR2("Generates MBSchema.bin & MBSchema.Xml from MBSchemaExtensions.Xml",
            TEXT("Generates MBSchema.bin & MBSchema.Xml from MBSchemaExtensions.Xml:        \r\n")
            TEXT("  1>QueryInterface on the Dispenser for IMetabaseSchemaCompiler.          \r\n")
            TEXT("  2>Generates the Bin File and the MBSchema.Xml file.                     \r\n")
            TEXT("  3>Populates the ColumnMeta using the Bin file as part of the query.     \r\n")
            TEXT("  4>Make a copy of the Bin file.                                          \r\n")
            TEXT("  5>Generates the Bin File and the MBSchema.Xml file from the newly       \r\n")
            TEXT("    created MBSchema.Xml file.                                            \r\n")
            TEXT("  6>Compare the first Bin file with the secind Bin file (they should be   \r\n")
            TEXT("    identical).                                                           \r\n")
            TEXT("  7>Compare the first Xml file with the secind Xml file (they should be   \r\n")
            TEXT("    identical).                                                           \r\n")));


TestResult TMBSchemaGenerationTest::ExecuteTest()
{
    EM_START_SETUP

    LockInParameters();
    if(-1 != GetFileAttributes(m_szFileName))//if the file exists then delete it
    {
        EM_JIT(0 == DeleteFile(m_szFileName));
    }

    if(-1 != GetFileAttributes(L"MBSchema.Xml"))//if the file exists then delete it
    {
        EM_JIT(0 == DeleteFile(L"MBSchema.Xml"));
    }

    EM_JIT(-1 == GetFileAttributes(L"MBSchemaExtensions.Xml"));//This file must exist

    EM_JIF(GetSimpleTableDispenser(m_szProductID, 0, &m_pISTDisp));

    WCHAR wszMBSchemaPath[1024];
    WCHAR wszMBSchema0[1024];
    WCHAR wszMBSchema1[1024];
    WCHAR wszMBSchemaExtensions[1024];
    WCHAR wszMBSchemaBinFileName0[1024];
    WCHAR wszMBSchemaBinFileName1[1024];

    ULONG cch;
    cch= sizeof(wszMBSchemaBinFileName0)/sizeof(WCHAR);
    
    LPWSTR pwsz;
    pwsz= wszMBSchemaPath + GetModuleFileName(g_hModule, wszMBSchemaPath, sizeof(wszMBSchemaPath)/sizeof(WCHAR)) -2;
    while(*pwsz != L'\\')--pwsz;
    *(++pwsz) = 0x00;

    wcscpy(wszMBSchema1, wszMBSchemaPath);
    wcscat(wszMBSchema1, L"MBSchema1.Xml");

    wcscpy(wszMBSchemaExtensions, wszMBSchemaPath);
    wcscat(wszMBSchemaExtensions, L"MBSchemaExtensions.Xml");

    wcscpy(wszMBSchema0, wszMBSchemaPath);
    wcscat(wszMBSchema0, L"MBSchema0.Xml");


    EM_TEST_BEGIN

    {
        CComPtr<IMetabaseSchemaCompiler>   m_pSchemaCompiler;

        SetTestNumber(1);// 1>QueryInterface on the Dispenser for IMetabaseSchemaCompiler.
        EM_JIF(m_pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler, reinterpret_cast<LPVOID *>(&m_pSchemaCompiler)));

        SetTestNumber(2);// 2>Generates the Bin File and the MBSchema.Xml file.
        EM_JIF(m_pSchemaCompiler->SetBinPath(wszMBSchemaPath));
        EM_JIF(m_pSchemaCompiler->GetBinFileName(wszMBSchemaBinFileName0, &cch));
        EM_JIF(m_pSchemaCompiler->ReleaseBinFileName(wszMBSchemaBinFileName0));
        EM_JIF(m_pSchemaCompiler->Compile(wszMBSchemaExtensions, wszMBSchema0));

        SetTestNumber(3);// 3>Populates the ColumnMeta using the Bin file as part of the query.
        EM_JIF(m_pSchemaCompiler->GetBinFileName(wszMBSchemaBinFileName0, &cch));
        EM_JIT(0x00 == wszMBSchemaBinFileName0[0]);
        m_szFileName = wszMBSchemaBinFileName0;
        EM_JIF(GetTable());
        EM_JIF(m_pSchemaCompiler->ReleaseBinFileName(wszMBSchemaBinFileName0));
    
        SetTestNumber(4);// 4>Make a copy of the Bin file.
        EM_JIF(m_pSchemaCompiler->GetBinFileName(wszMBSchemaBinFileName0, &cch));
        EM_JIT(0x00 == wszMBSchemaBinFileName0[0]);
        EM_JIT(0 == CopyFile(wszMBSchemaBinFileName0, L"MBSchema0.bin", FALSE));
        EM_JIF(m_pSchemaCompiler->ReleaseBinFileName(wszMBSchemaBinFileName0));

        SetTestNumber(5);// 5>Generates the Bin File and the MBSchema.Xml file from the newly created MBSchema.Xml file.
        EM_JIF(m_pSchemaCompiler->Compile(wszMBSchema0, wszMBSchema1));
        EM_JIF(m_pSchemaCompiler->GetBinFileName(wszMBSchemaBinFileName1, &cch));
        EM_JIT(0x00 == wszMBSchemaBinFileName0[0]);
        EM_JIT(0 == CopyFile(wszMBSchemaBinFileName1, L"MBSchema1.bin", FALSE));
        EM_JIF(m_pSchemaCompiler->ReleaseBinFileName(wszMBSchemaBinFileName1));

        SetTestNumber(6);// 6>Compare the first Bin file with the secind Bin file (they should be identical).
        SetTestNumber(7);// 7>Compare the first Xml file with the secind Xml file (they should be identical).
    }

    EM_CLEANUP
    EM_RETURN_TRESULT
}



////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TMBSchemaGenerationSimulationTest
//
// Description:
//  This test generate the MBSchema.Bin file from MBSchemaExtensions.Xml, then generate the resulting MBSchema.xml
//      1>QueryInterface on the Dispenser for IMetabaseSchemaCompiler.          
//      2>Generates the Bin File and the MBSchema.Xml file.                     
//
class TMBSchemaGenerationSimulationTest : public TestBase, public TestCase, public TGetTableBaseClass
{
    public:
        TMBSchemaGenerationSimulationTest() : 
          TGetTableBaseClass(wszDATABASE_META, wszTABLE_COLUMNMETA, TEXT("MBSchema.bin"), L"IIS", 0)
          {
          }

        virtual TestResult  ExecuteTest();
    protected:
};



TTuxTest<TMBSchemaGenerationSimulationTest>      T412(412, DESCR2("Simulates the Metabase schema compilation process.",
            TEXT("Generates MBSchema.bin & MBSchema.Xml from MBSchemaExtensions.Xml:        \r\n")
            TEXT("  1>QueryInterface on the Dispenser for IMetabaseSchemaCompiler.          \r\n")
            TEXT("  2>Generates the Bin File and the MBSchema.Xml file.                     \r\n")));


TestResult TMBSchemaGenerationSimulationTest::ExecuteTest()
{
    EM_START_SETUP

    LockInParameters();
    if(-1 != GetFileAttributes(m_szFileName))//if the file exists then delete it
    {
        EM_JIT(0 == DeleteFile(m_szFileName));
    }

    if(-1 != GetFileAttributes(L"MBSchema.Xml"))//if the file exists then delete it
    {
        EM_JIT(0 == DeleteFile(L"MBSchema.Xml"));
    }

    EM_JIT(-1 == GetFileAttributes(L"MBSchemaExtensions.Xml"));//This file must exist

    EM_JIF(GetSimpleTableDispenser(m_szProductID, 0, &m_pISTDisp));

    WCHAR wszMBSchemaPath[1024];
    WCHAR wszMBSchema0[1024];
    WCHAR wszMBSchemaExtensions[1024];
    WCHAR wszMBSchemaBinFileName0[1024];

    ULONG cch;
    cch= sizeof(wszMBSchemaBinFileName0)/sizeof(WCHAR);
    
    LPWSTR pwsz;
    pwsz= wszMBSchemaPath + GetModuleFileName(g_hModule, wszMBSchemaPath, sizeof(wszMBSchemaPath)/sizeof(WCHAR)) -2;
    while(*pwsz != L'\\')--pwsz;
    *(++pwsz) = 0x00;

    wcscpy(wszMBSchemaExtensions, wszMBSchemaPath);
    wcscat(wszMBSchemaExtensions, L"MBSchemaExtensions.Xml");

    wcscpy(wszMBSchema0, wszMBSchemaPath);
    wcscat(wszMBSchema0, L"MBSchema0.Xml");

    EM_TEST_BEGIN

    {
        CComPtr<IMetabaseSchemaCompiler>   m_pSchemaCompiler;

        SetTestNumber(1);// 1>QueryInterface on the Dispenser for IMetabaseSchemaCompiler.
        EM_JIF(m_pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler, reinterpret_cast<LPVOID *>(&m_pSchemaCompiler)));

        SetTestNumber(2);// 2>Generates the Bin File and the MBSchema.Xml file.
        EM_JIF(m_pSchemaCompiler->SetBinPath(wszMBSchemaPath));
        EM_JIF(m_pSchemaCompiler->GetBinFileName(wszMBSchemaBinFileName0, &cch));
        EM_JIF(m_pSchemaCompiler->ReleaseBinFileName(wszMBSchemaBinFileName0));
        EM_JIF(m_pSchemaCompiler->Compile(wszMBSchemaExtensions, wszMBSchema0));
    }

    EM_CLEANUP
    EM_RETURN_TRESULT
}



////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TMBSchemaGetRowIndexByIdentity
//
// Description:
//  TableMeta from bin & does GetRowIndexByIdentity for IIsConfigObject.
//      1>Gets the TableMeta from the Bin file.     
//      2>GetRowIndexByIdentity for IIsConfigObject.
//
class TMBSchemaGetRowIndexByIdentity : public TestBase, public TestCase, public TGetTableBaseClass
{
    public:
        TMBSchemaGetRowIndexByIdentity() : 
          TGetTableBaseClass(wszDATABASE_META, wszTABLE_TABLEMETA, TEXT("dummy"), L"IIS", 0)
          {
          }

        virtual TestResult  ExecuteTest();
    protected:
};



TTuxTest<TMBSchemaGetRowIndexByIdentity>      T413(413, DESCR2("TableMeta from bin & does GetRowIndexByIdentity for IIsConfigObject.",
            TEXT("TableMeta from bin & does GetRowIndexByIdentity for IIsConfigObject:      \r\n")
            TEXT("  1>Gets the TableMeta from the Bin file.                                 \r\n")
            TEXT("  2>GetRowIndexByIdentity for IIsConfigObject.                            \r\n")));


TestResult TMBSchemaGetRowIndexByIdentity::ExecuteTest()
{
    CComPtr<IMetabaseSchemaCompiler>   m_pSchemaCompiler;

    EM_START_SETUP

    static LPWSTR s_IIsConfigObject = L"IIsConfigObject";

    LockInParameters();
    EM_JIF(GetSimpleTableDispenser(m_szProductID, 0, &m_pISTDisp));

    WCHAR wszMBSchemaPath[1024];
    WCHAR wszMBSchemaBinFileName0[1024];

    wszMBSchemaBinFileName0[0] = 0x00;

    ULONG cch;
    cch= sizeof(wszMBSchemaBinFileName0)/sizeof(WCHAR);
    
    LPWSTR pwsz;
    pwsz= wszMBSchemaPath + GetModuleFileName(g_hModule, wszMBSchemaPath, sizeof(wszMBSchemaPath)/sizeof(WCHAR)) -2;
    while(*pwsz != L'\\')--pwsz;
    *(++pwsz) = 0x00;

    EM_JIF(m_pISTDisp->QueryInterface(IID_IMetabaseSchemaCompiler, reinterpret_cast<LPVOID *>(&m_pSchemaCompiler)));
    EM_JIF(m_pSchemaCompiler->SetBinPath(wszMBSchemaPath));
    EM_JIF(m_pSchemaCompiler->GetBinFileName(wszMBSchemaBinFileName0, &cch));

    EM_TEST_BEGIN
    {
        SetTestNumber(1);// 1>Gets the TableMeta from the Bin file.
        EM_JIT(0x00 == wszMBSchemaBinFileName0[0]);
        m_szFileName = wszMBSchemaBinFileName0;
        EM_JIF(GetTable());
        EM_JIF(m_pSchemaCompiler->ReleaseBinFileName(wszMBSchemaBinFileName0));
        wszMBSchemaBinFileName0[0] = 0x00;

        SetTestNumber(2);// 2>GetRowIndexByIdentity for IIsConfigObject

        ULONG ulRow;
        EM_JIF(m_pISTRead2->GetRowIndexByIdentity(0, reinterpret_cast<LPVOID *>(&s_IIsConfigObject), &ulRow));
    }

    EM_CLEANUP

    EM_RETURN_TRESULT
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\stdafx.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module:  stdafx.h
//           This is the first file that should be included by every cpp module.
//           This is where all of the common headers go.  This makes things
//           easier for precompiled headers and also works with MFC apps.
//
//  Revision History:
//      11/17/1997  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __STDAFX_H__
#define __STDAFX_H__

#define UNICODE
#define _UNICODE

#ifndef _WINDOWS_
    #include "windows.h"
#endif

#ifndef _INC_STDIO
    #include "stdio.h"
#endif

#ifndef _INC_CONIO
    #include "conio.h"
#endif

#if !defined( _OBJBASE_H_ )
    #include <objbase.h>
#endif

#ifndef __SMARTCOM_H__
    #include "SmartCom.h"
#endif

#ifndef _CATALOGMACROS
    #include "catmacros.h"
#endif

#ifndef __catalog_h__
    #include "catalog.h"
#endif

#ifndef __TABLEINFO_H__  
    #include "catmeta.h"
#endif

#ifndef __SMARTPOINTER_H__
    #include "SmartPointer.h"
#endif

#ifndef _INC_STDLIB
    #include <stdlib.h>
#endif

#ifndef _INC_TCHAR
    #include <tchar.h>
#endif

//Ole stuff
#ifndef _OBJBASE_H_
    #include "objbase.h"
#endif

#ifndef __TUX_H__
    #include <tux.h>
#endif

#ifndef __KATO_H__
    #include <kato.h>
#endif

#ifndef __GLOBALS_H__
    #include "Globals.h"
#endif

//Must come before ErrorMacros.h
#ifndef __ERRORLOG_H__
    #include "ErrorLog.h"
#endif

#ifndef __ERRORMACROS_H__
    #include "ErrorMacros.h"
#endif

//These are where the base classes are included
#ifndef __TUXTEST_H__
    #include "TuxTest.h"
#endif

//#ifndef __TUXSTRESS_H__
//    #include "TuxStress.h"
//#endif

#endif //__STDAFX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\tools.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  ALL TUX DLLs
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module:  Tools.cpp
//           This contains some small tools that can be used in test
//           1. TRunApp:        runs an application with a given command line
//           2. TSleep:         sleeps for an amount of time
//           3. TShowMemory:    displays memory usage
//
//  Revision History:
//      10/12/1998  Stephenr    Created
//      08/04/1999  Hjiang      Changed file name from RunApp.cpp to Tools.cpp
//                              Added TShowMemory
//
////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Tools.h"

TTuxTest1<TSleep, DWORD>      T305(305, DESCR("Sleeps for 4 seconds"), 4000);
TTuxTest<TShowMemory>         T306(306, DESCR("Show Memory Usage"));

TestResult TRunApp::ExecuteTest()
{
    return trFAIL;
}


TestResult TShowMemory::ExecuteTest()
{
    MEMORYSTATUS mst;
    memset(&mst, 0, sizeof(mst));
    mst.dwLength = sizeof(mst);

    GlobalMemoryStatus(&mst);

    DWORD kbPercent = mst.dwMemoryLoad;
    DWORD kbTotal = mst.dwTotalPhys / 1024;
    DWORD kbUsed = (mst.dwTotalPhys - mst.dwAvailPhys) / 1024;
    DWORD kbFree = mst.dwAvailPhys / 1024;
    Debug(TEXT("================= Estimated System Memory ==================="));
    Debug(TEXT("Memory (KB):      %7d total   %7d used   %7d free"), kbTotal, kbUsed, kbFree);

#ifdef UNDER_CE
    STORE_INFORMATION sti;
    GetStoreInformation(&sti);

    DWORD stikbTotal = sti.dwStoreSize / 1024;
    DWORD stikbUsed = (sti.dwStoreSize - sti.dwFreeSize) / 1024;
    DWORD stikbFree = sti.dwFreeSize / 1024;
    Debug(TEXT("File Store (KB):  %7d total   %7d used   %7d free"), stikbTotal, stikbUsed, stikbFree);
#endif // UNDER_CE

    Debug(TEXT("=============================================================\r\n"));

    return trPASS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\tools.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  ALL TUX DLLs
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module:  Tools.h
//           This contains some small tools that can be used in test
//           1. TRunApp:        runs an application with a given command line
//           2. TSleep:         sleeps for an amount of time
//           3. TShowMemory:    displays memory usage
//
//  Revision History:
//      10/12/1998  Stephenr    Created
//      08/04/1999  Hjiang      Changed file name from RunApp.h to Tools.h
//                              Added TShowMemory
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __TOOLS_H__
#define __TOOLS_H__


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TRunApp
//
// Description:
//  This test runs an app with a given command-line
//
class TRunApp : public TestBase
{
    public:
        TRunApp(LPCTSTR szApp, LPCTSTR szParameters=NULL, LPCTSTR szDir=NULL) :
                m_szApp(szApp), m_szParameters(szParameters), m_szDirectory(szDir){}

        virtual TestResult  ExecuteTest();
    protected:
        LPCTSTR m_szApp;
        LPCTSTR m_szDirectory;
        LPCTSTR m_szParameters;
};


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TSleep
//
// Description:
//  This test just sleeps for the give amount of time (in milliseconds)
//
class TSleep : public TestBase
{
    public:
        TSleep(DWORD dwSleepTime) : m_dwSleepTime(dwSleepTime){}

        virtual TestResult  ExecuteTest(){Sleep(m_dwSleepTime);return trPASS;}
    protected:
        DWORD   m_dwSleepTime;
};



////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TShowMemory
//
// Description:
//  This test reports estimated avaiable memory size
//
class TShowMemory : public TestBase
{
    public:
        TShowMemory(){}

        virtual TestResult ExecuteTest();
};

#endif // __TOOLS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\tuxstress.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  ALL TUX DLLs
//  Copyright (c) 1998, Microsoft Corporation
//
//  Module:  TuxStress.cpp
//           This is a base class used to simplify writing stress tests.  It is
//           based off of CDirectXStressFramework class created by lblanco.
//
//  Revision History:
//      5/19/1998  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
//#include "dxqamem.h"


TStressTestBase::TStressTestBase() : m_NumberOfTimesToExecute(100), m_TimeLimit(0), m_bExitByReps(false), m_bExitByTime(false),
                m_ExecutionCount(0), m_TimeToStop(0), m_NumberOfMediaFiles(2)
{   //by default we will run the test only once, without regards to how long the test takes.
    //BTW m_TimeLimit will not interrupt a test and kill it if it's in the middle of a test, it will only
    //check to see if that much time has passed before doing the test again.
    
    //Notice how we default to running 100 times or 1 hour which ever comes first
    //If the command line reads 'T:0 N:0' then the stress test has no exit condition so it should run forever.
    ParseTimeLimit();
    ParseNumberOfExecutions();
    ParseNumberOfMediaFiles();
}


//Parse the command line for the time limit (ie. T:40). Time is given in seconds but stored as milliseconds
void TStressTestBase::ParseTimeLimit()
{
    if(g_pShellInfo && g_pShellInfo->szDllCmdLine && _tcslen(g_pShellInfo->szDllCmdLine)>2)
    {
        LPCTSTR pString = g_pShellInfo->szDllCmdLine;
        //Parse the commandline for 'T:'
        while(*(pString+2))
        {
            if(*pString == 'T' && *(pString+1) == ':')
            {
                int iTemp = _ttoi(pString+2);
                m_TimeLimit = 1000 * iTemp;
                if(m_TimeLimit > 864000000 || iTemp<0)//if greater than 10 days then assume the user made a mistake
                {
                    Debug(TEXT("Stress timeout greater than 864000 seconds (10 days), defaulting to zero (ignore Time Limit)"));
                    m_TimeLimit = 0;
                }
                break;
            }
            pString++;
        }
    }
    m_bExitByTime = (m_TimeLimit > 0);
}

//Parse the command line for the Number of Repititions (ie. N:30) where 'N:2' will execute the test twice.
void TStressTestBase::ParseNumberOfExecutions()
{
    if(g_pShellInfo && g_pShellInfo->szDllCmdLine && _tcslen(g_pShellInfo->szDllCmdLine)>2)
    {
        LPCTSTR pString = g_pShellInfo->szDllCmdLine;
        //Parse the commandline for 'N:'
        while(*pString)
        {
            if(*pString == 'N' && *(pString+1) == ':')
            {
                m_NumberOfTimesToExecute = _ttoi(pString+2);
                if(m_NumberOfTimesToExecute < 0)//if negative number then assume the user made a mistake
                {
                    Debug(TEXT("Negative stress repetition count, defaulting to zero (ignore repitition count)"));
                    m_NumberOfTimesToExecute = 0;
                }
                break;
            }
            pString++;
        }
    }
    m_bExitByReps = (m_NumberOfTimesToExecute > 0);
}

//Parse the command line for the number of media files (ie. M:2). 
void TStressTestBase::ParseNumberOfMediaFiles()
{
    if(g_pShellInfo && g_pShellInfo->szDllCmdLine && _tcslen(g_pShellInfo->szDllCmdLine)>2)
    {
        LPCTSTR pString = g_pShellInfo->szDllCmdLine;
        //Parse the commandline for 'M:'
        while(*(pString+2))
        {
            if(*pString == 'M' && *(pString+1) == ':')
            {
                m_NumberOfMediaFiles = _ttoi(pString+2);
                if(m_NumberOfMediaFiles < 0)//if negative number then assume the user made a mistake
                {
                    Debug(TEXT("Negative MediaFile count, defaulting to 2"));
                    m_NumberOfMediaFiles = 2;
                }
                break;
            }
            pString++;
        }
    }
}

//The deriving class should call this before executing the test each time (including the first time through)
bool TStressTestBase::IsOkToContinue()
{
    DWORD dwAvailableMemory, dwNumFragments;
    
    if(0 == m_ExecutionCount)//If this is the first time through
    {
        m_TimeToStop = m_TimeLimit + GetTickCount();//mark the stopping time
        Debug(TEXT("Estimating initial available memory..."));
    }

    EstimateAvailableMemory(&dwAvailableMemory, &dwNumFragments);
    m_statAvailableMemory.AddDataPoint(m_ExecutionCount+1, dwAvailableMemory);
    m_statMemoryFragments.AddDataPoint(m_ExecutionCount+1, dwNumFragments);
    OutputStatistics(dwAvailableMemory, dwNumFragments);

    OutputElapsedTime();
    OutputTimeRemaining();

    if((m_bExitByReps && m_ExecutionCount>=m_NumberOfTimesToExecute) || (m_bExitByTime && m_TimeToStop<GetTickCount()))
    {
        Debug(TEXT("Tux Stress Completed\r\n"));
        return false;
    }
    else
    {
        //Do some memory checking
        m_ExecutionCount++;//Presumably the test will be executed immediately following the return
        Debug(TEXT("Loop Count: %d"),m_ExecutionCount);
        return true;
    }
}

#define REDUCTION_FACTOR    16
#define INITIAL_ALLOCATION  16

////////////////////////////////////////////////////////////////////////////////
// TStressTestBase::EstimateAvailableMemory
//  Calculates the amount of memory available for allocations and estimates
//  heap fragmentation.
//
// Parameters:
//  pdwAvailable    Returns the total amount of memory available. This is the
//                  sum of the sizes of all fragments, so it may not be possible
//                  to allocate one block as big as this value. This pointer
//                  may be NULL if this value is not needed.
//  pdwFragments    Returns the number of fragments the heap is partitioned
//                  into. If this value is 1, it is possible to allocate one
//                  chunk of memory as big as the value reported in the previous
//                  parameter. This pointer may be NULL if this value is not
//                  needed.
//
// Return value:
//  None.

void TStressTestBase::EstimateAvailableMemory(DWORD *pdwAvailable, DWORD *pdwFragments)
{
    MEMORYSTATUS mst;

    mst.dwLength = sizeof(mst);
    GlobalMemoryStatus(&mst);

    *pdwAvailable = mst.dwAvailPhys;
    *pdwFragments = 0;
    //kbTotal = mst.dwTotalPhys / 1024;
    //kbUsed = (mst.dwTotalPhys - mst.dwAvailPhys) / 1024;
    //kbFree = mst.dwAvailPhys / 1024;
}
/*
    BYTE    *pBlock,
            *pFirstBlock = NULL,
            *pNext;
    DWORD   dwDelta,
            dwSize,
            dwAvailable = 0,
            dwFragments = 0;

    enum
    {
        STATE_NEWBLOCK,
        STATE_SETTLE,
        STATE_ADDBLOCK,
        STATE_RELEASE,
        STATE_DONE
    } state = STATE_NEWBLOCK;

    // Reset the variables
    dwSize = INITIAL_ALLOCATION*1024*1024/sizeof(DWORD);
    while(state != STATE_DONE)
    {
        switch(state)
        {
        case STATE_NEWBLOCK:
            dwDelta = dwSize/REDUCTION_FACTOR;
            if(dwDelta == 0)
                dwDelta = 1;
            state = STATE_SETTLE;
            break;

        case STATE_SETTLE:
            // Attempt to allocate a block of the current size
            pBlock = new BYTE[sizeof(DWORD)*dwSize];

            // Were we successful?
            if(pBlock != NULL)
            {
                if(dwDelta == 1)
                {
                    // This is the largest block we can allocate. Keep it
                    state = STATE_ADDBLOCK;
                }
                else
                {
                    // Free the current block and try larger values
                    delete[] pBlock;

                    // Calculate the next iteration
                    dwSize += dwDelta;

                    dwDelta /= REDUCTION_FACTOR;
                    if(dwDelta == 0)
                        dwDelta = 1;

                    dwSize -= dwDelta;
                }
            }
            else
            {
                // Nope
                if(dwSize == 1)
                {
                    // We couldn't allocate the smallest possible amount of
                    // memory, so we are done
                    state = STATE_RELEASE;
                }
                else
                {
                    // Try a smaller amount
                    if(dwSize < dwDelta)
                    {
                        dwDelta = dwSize/REDUCTION_FACTOR;
                        if(dwDelta == 0)
                            dwDelta = 1;
                    }
                    dwSize -= dwDelta;
                    if(dwSize == 0)
                        dwSize = 1;
                }
            }
            break;

        case STATE_ADDBLOCK:
            // One more fragment, and some more available memory
            dwAvailable += sizeof(DWORD)*dwSize;
            dwFragments++;

            // Link this block with the others
            *(BYTE **)pBlock = pFirstBlock;
            pFirstBlock = pBlock;

            // Start with another block
            state = STATE_NEWBLOCK;
            break;

        case STATE_RELEASE:
            // Release all of the memory we've allocated
            pBlock = pFirstBlock;
            while(pBlock)
            {
                pNext = *(BYTE **)pBlock;
                delete[] pBlock;
                pBlock = pNext;
            }

            state = STATE_DONE;
            break;
        }
    }

    // Return the requested data
    if(pdwAvailable)
        *pdwAvailable = dwAvailable;

    if(pdwFragments)
        *pdwFragments = dwFragments;
}
*/
void TStressTestBase::OutputStatistics(DWORD dwAvailable, DWORD dwFragments)
{
    TCHAR       szAverage[16], szStdDeviation[16], szLinearIntercept[16], szLinearSlope[16],
                szFormat1[] = TEXT("%-6s %8d %12s %12s %12s %12s"),
                szFormat2[] = TEXT("%-6s %8s %12s %12s %12s %12s");
    double      lfLinearIntercept, lfLinearSlope;

    Debug(
        TEXT("==================================")
        TEXT("=================================="));
    Debug(
        szFormat2,
        TEXT(""),
        TEXT("Last"),
        TEXT("Average"),
        TEXT("Deviation"),
        TEXT("Intercept"),
        TEXT("Slope"));
    Debug(
        TEXT("----------------------------------")
        TEXT("----------------------------------"));

    // Available memory
    DoubleToText(szAverage, m_statAvailableMemory.Average(), 2);
    DoubleToText(szStdDeviation, m_statAvailableMemory.StandardDeviation(), 2);
    m_statAvailableMemory.LinearFit(lfLinearIntercept, lfLinearSlope);
    DoubleToText(szLinearIntercept, lfLinearIntercept, 2);
    DoubleToText(szLinearSlope, lfLinearSlope, 2);
    Debug(szFormat1, TEXT("@Mem"), dwAvailable, szAverage, szStdDeviation, szLinearIntercept, szLinearSlope);

    // Number of fragments
    DoubleToText(szAverage, m_statMemoryFragments.Average(), 2);
    DoubleToText(szStdDeviation, m_statMemoryFragments.StandardDeviation(), 2);
    m_statMemoryFragments.LinearFit(lfLinearIntercept, lfLinearSlope);
    DoubleToText(szLinearIntercept, lfLinearIntercept, 2);
    DoubleToText(szLinearSlope, lfLinearSlope, 2);
    Debug(
        szFormat1,
        TEXT("Frags"),
        dwFragments,
        szAverage,
        szStdDeviation,
        szLinearIntercept,
        szLinearSlope);

    Debug(
        TEXT("==================================")
        TEXT("=================================="));
}

////////////////////////////////////////////////////////////////////////////////
// TStressTestBase::OutputTime
//  Outputs the Description: time
//
// Parameters:
//  dwTime          The elapsed time.
//
// Return value:
//  None.

void TStressTestBase::OutputTime(LPCTSTR lpDescription, DWORD dwTime)
{
    DWORD   dwHours,
            dwMinutes,
            dwSeconds,
            dwMilliseconds;
    TCHAR   szMessage[128],
            *pszMessage = szMessage;

    _tcscpy(pszMessage, lpDescription);
    pszMessage += lstrlen(pszMessage);

    dwHours = dwTime/(1000*60*60);
    if(dwHours)
    {
        wsprintf(pszMessage, TEXT("%dh"), dwHours);
        pszMessage += lstrlen(pszMessage);
        dwTime -= dwHours*(1000*60*60);
    }

    dwMinutes = dwTime/(1000*60);
    if(dwMinutes)
    {
        if(dwHours)
        {
            wsprintf(pszMessage, TEXT("%02dm"), dwMinutes);
        }
        else
        {
            wsprintf(pszMessage, TEXT("%dm"), dwMinutes);
        }
        pszMessage += lstrlen(pszMessage);
        dwTime -= dwMinutes*(1000*60);
    }
    else if(dwHours)
    {
        lstrcat(pszMessage, TEXT("00m"));
        pszMessage += 3;
    }

    dwSeconds = dwTime/(1000);
    if(dwHours || dwMinutes)
    {
        wsprintf(pszMessage, TEXT("%02d."), dwSeconds);
    }
    else
    {
        wsprintf(pszMessage, TEXT("%d."), dwSeconds);
    }
    pszMessage += lstrlen(pszMessage);
    dwTime -= dwSeconds*(1000);

    dwMilliseconds = dwTime;
    wsprintf(pszMessage, TEXT("%03ds"), dwMilliseconds);

    Debug(szMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\tux.h ===
//******************************************************************************
//
// TUX.H
//
// Definitions of Tux types, structures, and messages.
//
// Date     Name     Description
// -------- -------- -----------------------------------------------------------
// 02/14/95 SteveMil Created
//
//******************************************************************************

#ifndef __TUX_H__
#define __TUX_H__

//******************************************************************************
//***** Function Types
//******************************************************************************

// Forward declaration of LPFUNCTION_TABLE_ENTRY
typedef struct _FUNCTION_TABLE_ENTRY *LPFUNCTION_TABLE_ENTRY;

// Define our ShellProc Param and TestProc Param types
typedef LPARAM  SPPARAM;
typedef LPDWORD TPPARAM;

// Shell and Test message handling procs
typedef INT (WINAPI *SHELLPROC)(UINT uMsg, SPPARAM spParam);
typedef INT (WINAPI *TESTPROC )(UINT uMsg, TPPARAM tpParam, LPFUNCTION_TABLE_ENTRY lpFTE);

// SHELLPROCAPI and TESTPROCAPI
#ifdef __cplusplus
#define SHELLPROCAPI extern "C" INT __declspec(dllexport) WINAPI
#else
#define SHELLPROCAPI INT __declspec(dllexport) WINAPI
#endif
#define TESTPROCAPI  INT WINAPI

//******************************************************************************
//***** Function Table Entry Structure
//******************************************************************************

typedef struct _FUNCTION_TABLE_ENTRY {
   LPCTSTR  lpDescription; // description of test
   UINT     uDepth;        // depth of item in tree hierarchy
   DWORD    dwUserData;    // user defined data that will be passed to TestProc at runtime
   DWORD    dwUniqueID;    // uniquely identifies the test - used in loading/saving scripts
   TESTPROC lpTestProc;    // pointer to TestProc function to be called for this test
} FUNCTION_TABLE_ENTRY, *LPFUNCTION_TABLE_ENTRY;

//******************************************************************************
//***** ShellProc() Message values
//******************************************************************************

#define SPM_LOAD_DLL               1
#define SPM_UNLOAD_DLL             2
#define SPM_START_SCRIPT           3
#define SPM_STOP_SCRIPT            4
#define SPM_BEGIN_GROUP            5
#define SPM_END_GROUP              6
#define SPM_SHELL_INFO             7
#define SPM_REGISTER               8
#define SPM_EXCEPTION              9
#define SPM_BEGIN_TEST            10
#define SPM_END_TEST              11

//******************************************************************************
//***** ShellProc() Return values
//******************************************************************************

#define SPR_NOT_HANDLED            0  
#define SPR_HANDLED                1
#define SPR_SKIP                   2
#define SPR_FAIL                   3

//******************************************************************************
//***** TestProc() Message values
//******************************************************************************

#define TPM_EXECUTE              101
#define TPM_QUERY_THREAD_COUNT   102

//******************************************************************************
//***** TestProc() Return values
//******************************************************************************

#define TPR_SKIP                   2
#define TPR_PASS                   3
#define TPR_FAIL                   4
#define TPR_ABORT                  5

//******************************************************************************
//***** ShellProc() Structures
//******************************************************************************

// ShellProc() Structure for SPM_LOAD_DLL message
typedef struct _SPS_LOAD_DLL {
   BOOL fUnicode;  // Set to true if your Dll is UNICODE
} SPS_LOAD_DLL, *LPSPS_LOAD_DLL;

// ShellProc() Structure for SPM_SHELL_INFO message
typedef struct _SPS_SHELL_INFO {
   HINSTANCE hInstance;     // Instance handle of shell.
   HWND      hWnd;          // Main window handle of shell (currently set to NULL).
   HINSTANCE hLib;          // Test Dll instance handle.
   HANDLE    hevmTerminate; // Manual event that is set by Tux to inform all
                            // tests to shutdown (currently not used).
   BOOL      fUsingServer;  // Set if Tux is connected to Tux Server.
   LPCTSTR   szDllCmdLine;  // Command line arguments for test DLL.
} SPS_SHELL_INFO, *LPSPS_SHELL_INFO;

// ShellProc() Structure for SPM_REGISTER message
typedef struct _SPS_REGISTER {
   LPFUNCTION_TABLE_ENTRY lpFunctionTable;
} SPS_REGISTER, *LPSPS_REGISTER;

// ShellProc() Structure for SPM_BEGIN_TEST message
typedef struct _SPS_BEGIN_TEST {
   LPFUNCTION_TABLE_ENTRY lpFTE;
   DWORD                  dwRandomSeed;
   DWORD                  dwThreadCount;
} SPS_BEGIN_TEST, *LPSPS_BEGIN_TEST;

// ShellProc() Structure for SPM_END_TEST message
typedef struct _SPS_END_TEST {
   LPFUNCTION_TABLE_ENTRY lpFTE;
   DWORD                  dwResult;
   DWORD                  dwRandomSeed;
   DWORD                  dwThreadCount;
   DWORD                  dwExecutionTime;
} SPS_END_TEST, *LPSPS_END_TEST;

// ShellProc() Structure for SPM_EXCEPTION message
typedef struct _SPS_EXCEPTION {
   LPFUNCTION_TABLE_ENTRY lpFTE;
   DWORD                  dwExceptionCode;
   EXCEPTION_POINTERS    *lpExceptionPointers;
   DWORD                  dwExceptionFilter;
   UINT                   uMsg;
} SPS_EXCEPTION, *LPSPS_EXCEPTION;


//******************************************************************************
//***** TestProc() Structures
//******************************************************************************

// TestProc() Structure for TPM_EXECUTE message
typedef struct _TPS_EXECUTE {
   DWORD dwRandomSeed;
   DWORD dwThreadCount;
   DWORD dwThreadNumber;
} TPS_EXECUTE, *LPTPS_EXECUTE;

// TestProc() Structure for TPM_QUERY_THREAD_COUNT message
typedef struct _TPS_QUERY_THREAD_COUNT {
   DWORD dwThreadCount;
} TPS_QUERY_THREAD_COUNT, *LPTPS_QUERY_THREAD_COUNT;

//******************************************************************************
//***** Old constants defined for compatibility - DO NOT USE THESE CONSTANTS!!!
//******************************************************************************

#define TPR_NOT_HANDLED   0
#define TPR_HANDLED       1
#define SPM_START_TESTS   SPM_BEGIN_GROUP
#define SPM_STOP_TESTS    SPM_END_GROUP
#define SHELLINFO         SPS_SHELL_INFO
#define LPSHELLINFO       LPSPS_SHELL_INFO
#define SPF_UNICODE       0x00010000

#endif //__TUX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\toverwriteallrowstest.cpp ===
#include "stdafx.h"
#include "LOSRepopulate.h"//TGetTableBaseClass is defined here

////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TOverWriteAllRowsTest
//
// Description:
//  This test gets a table with the OVERWRITEALLROWS metaflag (OverWriteTestTable) 
//              and does various read & write operations.
//      1.0> Get OverWriteTestTable (writable)                                         
//      1.1> Insert a single row.                                                      
//      1.2> Update Store                                                              
//      1.3> Release Table                                                             
//                                                                                   
//      2.0> Get OverWriteTestTable (writable)                                         
//      2.1> Verify there is one row & the contents match the row just written.   
//      2.2> Insert two rows (different from the first one).                           
//      2.3> Update Store                                                              
//      2.4> Release Table                                                             
//                                                                                     
//      3.0> Get OverWriteTestTable (writable)                                         
//      3.1> Verify there are two rows & the contents match the rows just written.
//      3.2> Delete One of the rows                                                    
//      3.3> Update Store                                                              
//      3.4> Release Table                                                             
//                                                                                     
//      4.0> Get OverWriteTestTable (writable)                                         
//      4.1> Verify the table is empty (deleting one row should delete them both) 
//      4.2> Insert two rows                                                           
//      4.3> Update Store                                                              
//      4.4> Release Table                                                             
//                                                                                     
//      5.0> Get OverWriteTestTable (readonly, querying one of the two rows)           
//      5.1> Verify the GetTable succeeded with the one row                       
//      5.2> Release Table                                                             
//                                                                                     
//      6.0> Get OverWriteTestTable (writable, querying one of the two rows)           
//           Verify the GetTable fails with E_ST_INVALIDQUERY                     
//

class TOverWriteAllRowsTest : public TestBase, public TestCase, public TGetTableBaseClass
{
    public:
        TOverWriteAllRowsTest() : 
          TGetTableBaseClass(wszDATABASE_APP_PRIVATE, wszTABLE_OverWriteAllRows, TEXT("TOverWriteAllRowsTest.xml"), L"IIS",
                            fST_LOS_READWRITE)
          { 
              wcscpy(m_aStrings[0], L"TestString0");
              wcscpy(m_aStrings[1], L"TestString1");
              wcscpy(m_aStrings[2], L"TestString2");
              wcscpy(m_aStrings[3], L"TestString3");
              wcscpy(m_aStrings[4], L"TestString4");

              m_UI4[0] = 0;
              m_UI4[1] = 1;
              m_UI4[2] = 2;
              m_UI4[3] = 3;
              m_UI4[4] = 4;

              m_Row[0].pString  = m_aStrings[0];
              m_Row[0].pUI4     = &m_UI4[0];

              m_Row[1].pString  = m_aStrings[1];
              m_Row[1].pUI4     = &m_UI4[1];

              m_Row[2].pString  = m_aStrings[2];
              m_Row[2].pUI4     = &m_UI4[2];

              m_Row[3].pString  = m_aStrings[3];
              m_Row[3].pUI4     = &m_UI4[3];

              m_Row[4].pString  = m_aStrings[4];
              m_Row[4].pUI4     = &m_UI4[4];
          }

        virtual TestResult  ExecuteTest();
    private:
        tOverWriteAllRowsRow m_Row[5];
        WCHAR                m_aStrings[5][20];
        ULONG                m_UI4[5];
};


TTuxTest<TOverWriteAllRowsTest>      T501(501, DESCR2("Tests the OVERWRITEALLROWS functionality",
            TEXT("This test gets a table with the OVERWRITEALLROWS metaflag (OverWriteTestTable) \r\n")
            TEXT("            and does various read & write operations.                          \r\n")
            TEXT("    1.0> Get OverWriteTestTable (writable)                                     \r\n")
            TEXT("    1.1> Insert a single row.                                                  \r\n")
            TEXT("    1.2> Update Store                                                          \r\n")
            TEXT("    1.3> Release Table                                                         \r\n")
            TEXT("                                                                               \r\n")
            TEXT("    2.0> Get OverWriteTestTable (writable)                                     \r\n")
            TEXT("    2.1> Verify there is one row & the contents match the row just written.    \r\n")
            TEXT("    2.2> Insert two rows (different from the first one).                       \r\n")
            TEXT("    2.3> Update Store                                                          \r\n")
            TEXT("    2.4> Release Table                                                         \r\n")
            TEXT("                                                                               \r\n")
            TEXT("    3.0> Get OverWriteTestTable (writable)                                     \r\n")
            TEXT("    3.1> Verify there are two rows & the contents match the rows just written. \r\n")
            TEXT("    3.2> Delete One of the rows                                                \r\n")
            TEXT("    3.3> Update Store                                                          \r\n")
            TEXT("    3.4> Release Table                                                         \r\n")
            TEXT("                                                                               \r\n")
            TEXT("    4.0> Get OverWriteTestTable (writable)                                     \r\n")
            TEXT("    4.1> Verify the table is empty (deleting one row should delete them both)  \r\n")
            TEXT("    4.2> Insert two rows                                                       \r\n")
            TEXT("    4.3> Update Store                                                          \r\n")
            TEXT("    4.4> Release Table                                                         \r\n")
            TEXT("                                                                               \r\n")
            TEXT("    5.0> Get OverWriteTestTable (readonly, querying one of the two rows)       \r\n")
            TEXT("    5.1> Verify the GetTable succeeded with the one row                        \r\n")
            TEXT("    5.2> Release Table                                                         \r\n")
            TEXT("                                                                               \r\n")
            TEXT("    6.0> Get OverWriteTestTable (writable, querying one of the two rows)       \r\n")
            TEXT("         Verify the GetTable fails with E_ST_INVALIDQUERY                      \r\n")
            TEXT("\r\n")));


TestResult TOverWriteAllRowsTest::ExecuteTest()
{
    EM_START_SETUP

    EM_TEST_BEGIN
    {
        //Test 1
        {
            ULONG   iRow;

//      1.0> Get OverWriteTestTable (writable)                                         
            SetTestNumber(1, 0);
            EM_JIF(GetTable());

//      1.1> Insert a single row.                                                      
            SetTestNumber(1, 1);
            EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
            EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cOverWriteAllRows_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_Row[0])));

//      1.2> Update Store                                                              
            SetTestNumber(1, 2);
            EM_JIF(m_pISTWrite->UpdateStore());

//      1.3> Release Table                                                             
            SetTestNumber(1, 3);
            ReleaseTable();
        }



        //Test 2
        {
            ULONG                   cRows;
            ULONG                   iRow;
            tOverWriteAllRowsRow    tRow;

//      2.0> Get OverWriteTestTable (writable)                                         
            SetTestNumber(2, 0);
            EM_JIF(GetTable());

//      2.1> Verify there is one row & the contents match the row just written.   
            SetTestNumber(2, 1);
            EM_JIF(m_pISTWrite->GetTableMeta(   /*o_pcVersion   */  0,
                                                /*o_pfTable     */  0,
                                                /*o_pcRows      */  &cRows,
                                                /*o_pcColumns   */  0));
            EM_JIT(1 != cRows);
            EM_JIF(m_pISTWrite->GetColumnValues(/*i_iRow        */  0,
                                                /*i_cColumns    */  cOverWriteAllRows_NumberOfColumns,
                                                /*i_aiColumns   */  0,
                                                /*o_acbSizes    */  0,
                                                /*o_apvValues   */  reinterpret_cast<void **>(&tRow)));
            EM_JIT(0 != wcscmp(tRow.pString, m_Row[0].pString));
            EM_JIT((0 == tRow.pUI4) || (*tRow.pUI4 != *m_Row[0].pUI4));


//      2.2> Insert two rows (different from the first one).                           
            SetTestNumber(2, 2);
            EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
            EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cOverWriteAllRows_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_Row[1])));
            EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
            EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cOverWriteAllRows_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_Row[2])));

//      2.3> Update Store                                                              
            SetTestNumber(2, 3);
            EM_JIF(m_pISTWrite->UpdateStore());

//      2.4> Release Table                                                             
            SetTestNumber(2, 4);
            ReleaseTable();
        }


        //Test 3
        {
            ULONG                   cRows;
            tOverWriteAllRowsRow    tRow;

//      3.0> Get OverWriteTestTable (writable)                                         
            SetTestNumber(3, 0);
            EM_JIF(GetTable());

//      3.1> Verify there are two rows & the contents match the rows just written.
            SetTestNumber(3, 1);
            EM_JIF(m_pISTWrite->GetTableMeta(   /*o_pcVersion   */  0,
                                                /*o_pfTable     */  0,
                                                /*o_pcRows      */  &cRows,
                                                /*o_pcColumns   */  0));
            EM_JIT(2 != cRows);
            EM_JIF(m_pISTWrite->GetColumnValues(/*i_iRow        */  0,
                                                /*i_cColumns    */  cOverWriteAllRows_NumberOfColumns,
                                                /*i_aiColumns   */  0,
                                                /*o_acbSizes    */  0,
                                                /*o_apvValues   */  reinterpret_cast<void **>(&tRow)));
            EM_JIT(0 != wcscmp(tRow.pString, m_Row[1].pString));
            EM_JIT((0 == tRow.pUI4) || (*tRow.pUI4 != *m_Row[1].pUI4));
            EM_JIF(m_pISTWrite->GetColumnValues(/*i_iRow        */  1,
                                                /*i_cColumns    */  cOverWriteAllRows_NumberOfColumns,
                                                /*i_aiColumns   */  0,
                                                /*o_acbSizes    */  0,
                                                /*o_apvValues   */  reinterpret_cast<void **>(&tRow)));
            EM_JIT(0 != wcscmp(tRow.pString, m_Row[2].pString));
            EM_JIT((0 == tRow.pUI4) || (*tRow.pUI4 != *m_Row[2].pUI4));

//      3.2> Delete One of the rows                                                    
            SetTestNumber(3, 2);
            EM_JIF(m_pISTWrite->AddRowForDelete(1));

//      3.3> Update Store                                                              
            SetTestNumber(3, 3);
            EM_JIF(m_pISTWrite->UpdateStore());

//      3.4> Release Table                                                             
            SetTestNumber(3, 4);
            ReleaseTable();
        }


        //Test 4
        {
            ULONG                   cRows;
            ULONG                   iRow;
//      4.0> Get OverWriteTestTable (writable)                                         
            SetTestNumber(4, 0);
            EM_JIF(GetTable());

//      4.1> Verify the table is empty (deleting one row should delete them both) 
            SetTestNumber(4, 1);
            EM_JIF(m_pISTWrite->GetTableMeta(   /*o_pcVersion   */  0,
                                                /*o_pfTable     */  0,
                                                /*o_pcRows      */  &cRows,
                                                /*o_pcColumns   */  0));
            EM_JIT(0 != cRows);

//      4.2> Insert two rows                                                           
            SetTestNumber(4, 2);
            EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
            EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cOverWriteAllRows_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_Row[3])));
            EM_JIF(m_pISTWrite->AddRowForInsert(&iRow));
            EM_JIF(m_pISTWrite->SetWriteColumnValues(iRow, cOverWriteAllRows_NumberOfColumns, 0, 0, reinterpret_cast<LPVOID *>(&m_Row[4])));
//      4.3> Update Store                                                              
            SetTestNumber(4, 3);
            EM_JIF(m_pISTWrite->UpdateStore());
//      4.4> Release Table                                                             
            SetTestNumber(4, 4);
            ReleaseTable();
        }


        //Test 5
        {
            STQueryCell     acellsMeta[2];
            ULONG           cQuery  =2;
            ULONG           cRows;
//      5.0> Get OverWriteTestTable (readonly, querying one of the two rows)           
            SetTestNumber(5, 0);
            m_LOS ^= fST_LOS_READWRITE;
            acellsMeta[0].pData     = m_szFileName;
            acellsMeta[0].eOperator = eST_OP_EQUAL;
            acellsMeta[0].iCell     = iST_CELL_FILE;
            acellsMeta[0].dbType    = DBTYPE_WSTR;
            acellsMeta[0].cbSize    = 0;

            acellsMeta[1].pData     = m_Row[4].pString;
            acellsMeta[1].eOperator = eST_OP_EQUAL;
            acellsMeta[1].iCell     = iOverWriteAllRows_String;
            acellsMeta[1].dbType    = DBTYPE_WSTR;
            acellsMeta[1].cbSize    = 0;

            EM_JIF(m_pISTDisp->GetTable(m_szDatabaseName, m_szTableName, reinterpret_cast<LPVOID>(acellsMeta), reinterpret_cast<LPVOID>(&cQuery), eST_QUERYFORMAT_CELLS, m_LOS, reinterpret_cast<void **>(&m_pISTRead2)));

//      5.1> Verify the GetTable succeeded with the one row                       
            SetTestNumber(5, 1);
            EM_JIF(m_pISTRead2->GetTableMeta(   /*o_pcVersion   */  0,
                                                /*o_pfTable     */  0,
                                                /*o_pcRows      */  &cRows,
                                                /*o_pcColumns   */  0));
            EM_JIT(1 != cRows);

//      5.2> Release Table                                                             
            SetTestNumber(5, 2);
            ReleaseTable();
        }

        //Test 5
        {
            STQueryCell     acellsMeta[2];
            ULONG           cQuery  =2;
            ULONG           cRows;
//      6.0> Get OverWriteTestTable (writable, querying one of the two rows)           
//           Verify the GetTable fails with E_ST_INVALIDQUERY
            SetTestNumber(6, 0);
            m_LOS |= fST_LOS_READWRITE;
            acellsMeta[0].pData     = m_szFileName;
            acellsMeta[0].eOperator = eST_OP_EQUAL;
            acellsMeta[0].iCell     = iST_CELL_FILE;
            acellsMeta[0].dbType    = DBTYPE_WSTR;
            acellsMeta[0].cbSize    = 0;

            acellsMeta[0].pData     = m_Row[4].pString;
            acellsMeta[0].eOperator = eST_OP_EQUAL;
            acellsMeta[0].iCell     = iOverWriteAllRows_String;
            acellsMeta[0].dbType    = DBTYPE_WSTR;
            acellsMeta[0].cbSize    = 0;

            EM_JIT(E_ST_INVALIDQUERY != m_pISTDisp->GetTable(m_szDatabaseName, m_szTableName, reinterpret_cast<LPVOID>(acellsMeta), reinterpret_cast<LPVOID>(&cQuery), eST_QUERYFORMAT_CELLS, m_LOS, reinterpret_cast<void **>(&m_pISTRead2)));
        }
    }


    EM_CLEANUP
    EM_RETURN_TRESULT
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\tuxstress.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  ALL TUX DLLs
//  Copyright (c) 1998, Microsoft Corporation
//
//  Module:  TuxStress.h
//           This is a base class used to simplify writing stress tests.  It is
//           based off of CDirectXStressFramework class created by lblanco.
//
//  Revision History:
//      5/19/1998  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __TUXSTRESS_H__
#define __TUXSTRESS_H__


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TStressTestBase
//
// Description:
//           This is an abstract base class that should be derived from to
//           implement a test (TUX or other).  It is used to encapsulate
//           the ExecuteTest function as well as provide functionality
//           needed to loop and determine memory usage.
//
//           Just derive your tests from this base class and instanciate
//           them and ExecuteTest.
//
class TStressTestBase : public TestBase
{
    public:
        TStressTestBase();

        virtual TestResult  ExecuteTest() = 0;

    protected:
        bool        m_bExitByReps;//Did the command line specify that the test should exit by a certain number of Reps
        bool        m_bExitByTime;//Did the command line specify that the test should exit in a certain amount of time
        int         m_ExecutionCount;//This is the number of tests executed
        int         m_NumberOfTimesToExecute;//Number of times to execute the test, IsOkToContinue will return 'true' this many times.
        int         m_NumberOfMediaFiles; // Number of media files for the test (These will be played simultaneously)
        CStatVar    m_statAvailableMemory;//Stats for available memory
        CStatVar    m_statMemoryFragments;//Stats for the Number of Fragments in the available memory
        DWORD       m_TimeLimit;//Num milliseconds to keep repeating the test (the command line give this in seconds)
        DWORD       m_TimeToStop;//this is the TickCount upon which we will stop the test

        bool IsOkToContinue();

    private:
        void    ParseTimeLimit();
        void    ParseNumberOfExecutions();
        void    ParseNumberOfMediaFiles();
        void    EstimateAvailableMemory(DWORD *pdwAvailable, DWORD *pdwFragments);
        void    OutputStatistics(DWORD dwAvailable, DWORD dwFragments);
        void    OutputElapsedTime(){OutputTime(TEXT("Elapsed time: "), m_TimeLimit-(m_TimeToStop-GetTickCount()));}
        void    OutputTimeRemaining(){OutputTime(TEXT("Time Remaining: "), m_TimeToStop-GetTickCount());}
        void    OutputTime(LPCTSTR lpDescription, DWORD dwTime);

};

#endif //__TUXSTRESS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\tuxtest.cpp ===
////////////////////////////////////////////////////////////////////////////////
//
//  ALL TUX DLLs
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module:  TuxTest.cpp
//           This is a set of useful classes, macros etc for simplifying the
//           implementation of a TUX test.
//
//  Revision History:
//      11/14/1997  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"


//static member initialization
//
TuxEntry               *TuxEntry::m_pFirst          = NULL;
LPFUNCTION_TABLE_ENTRY  TuxEntry::m_pFunctionTable  = NULL;
int                     TuxEntry::m_NumTuxEntries   = 0;

////////////////////////////////////////////////////////////////////////////////
// TuxEntry
//  Ctor - These are the descriptions, they aren't tests and they always at
//  depth 0.
//

TuxEntry::TuxEntry(DWORD UniqueID, LPCTSTR Description) : m_szDescription(Description), m_UniqueID(UniqueID)
{
    if(!m_pFirst || m_pFirst->m_UniqueID >= m_UniqueID)
    {//Put ourself at the beginning of the linked list
        m_pNext  = m_pFirst;
        m_pFirst = this;
    }
    else//Otherwise put ourselves in the correct numerical position in the list
    {
        TuxEntry *pCurrent = m_pFirst;

        while(pCurrent->m_pNext && pCurrent->m_pNext->m_UniqueID < m_UniqueID)
            pCurrent = pCurrent->m_pNext;

        m_pNext = pCurrent->m_pNext;
        pCurrent->m_pNext = this;
    }

    m_NumTuxEntries++;
}


////////////////////////////////////////////////////////////////////////////////
// ~TuxEntry
//  Dtor - WARNING we don't take ourself out of the linked list when destructed.
//  The consequence of this is we can't handle dynamic allocation of a TuxTest.
//  This is a reasonable assumption, however, since ALL TuxTests should be
//  instanciated at global scope.
//

TuxEntry::~TuxEntry()
{
    m_NumTuxEntries--;

    if(!m_NumTuxEntries)//This is really just a formality in a 32bit module.
    {
        delete [] m_pFunctionTable;//deleting NULL is perfectly OK
        m_pFunctionTable = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////////
// Assign
//  Fills in the FUNCTION_TABLE_ENTRY struct with this objects members.
//
// Parameters:
//  pEntry          FUNCTION_TABLE_ENTRY pointer to fill

void TuxEntry::Assign(LPFUNCTION_TABLE_ENTRY pEntry) const
{
    pEntry->lpDescription  = m_szDescription;
    pEntry->uDepth         = 0;
    pEntry->dwUserData     = 0;
    pEntry->dwUniqueID     = 0;
    pEntry->lpTestProc     = NULL;
}


////////////////////////////////////////////////////////////////////////////////
// GetFunctionTable
//  Fills in the table of Tux functions, and the test descriptions.
//
// Return value:
//  The function table

LPFUNCTION_TABLE_ENTRY TuxEntry::GetFunctionTable()
{
    ASSERT(m_NumTuxEntries);//A TUX DLL without a TuxEntry is useless

    if(!m_pFunctionTable && m_NumTuxEntries)
    {
        //Allocate one extra since the table is NULL terminating
        m_pFunctionTable = new FUNCTION_TABLE_ENTRY[m_NumTuxEntries+1];

        if(m_pFunctionTable)
        {
            //Point past the end of the Function table array
            LPFUNCTION_TABLE_ENTRY  pTableEntry = m_pFunctionTable;
            TuxEntry               *pCurrent    = m_pFirst;

            //The array is NULL terminated so fill the last entry with all zeroes
            memset(&pTableEntry[m_NumTuxEntries], 0x00, sizeof FUNCTION_TABLE_ENTRY);

            //The constructors should have taken care of putting the FunctionTableEntries in
            //the correct order
            while(pCurrent)
            {
                pCurrent->Assign(pTableEntry++);
                pCurrent = pCurrent->m_pNext;
            }
        }
    }
    return m_pFunctionTable;
}


//static member initialization
//
TuxTestBase * TuxTestBase::m_CurrentTest=0;

////////////////////////////////////////////////////////////////////////////////
// Assign
//  Fills in the FUNCTION_TABLE_ENTRY struct with this objects members.
//
// Parameters:
//  pEntry          FUNCTION_TABLE_ENTRY pointer to fill

void TuxTestBase::Assign(LPFUNCTION_TABLE_ENTRY pEntry) const
{
    pEntry->lpDescription  = m_szDescription;
    pEntry->uDepth         = 1;//All TuxTests are at depth 1
    pEntry->dwUserData     = (DWORD)this;//Member variables should contain this
    pEntry->dwUniqueID     = m_UniqueID;
    pEntry->lpTestProc     = StaticTuxTest;
}


TuxTestBase::TuxTestBase(DWORD UniqueTestID, LPCTSTR Description) : TuxEntry(UniqueTestID, Description)
{
    //By assigning these vaues an empty string, routines don't need to verify that they're not NULL
    m_szSourceFileDate = TEXT("");
    m_szSourceFileName = m_szSourceFileDate;
    m_szSourceFileTime = m_szSourceFileDate;
    m_szSourceFileTimeStamp = m_szSourceFileDate;
    m_szDetailedDescription = m_szSourceFileDate;

    while(*Description != NULL_CHAR && 0 != _tcscmp(Description, TEXT("...")))Description++;
    if(*Description == NULL_CHAR)//If we reached the NULL before reaching a '...' then we're done
        goto DONE_PARSING;
    Description += 4;//Point past the '...', and the NULL
    if(0 != _tcsncmp(Description, SEPARATOR, _tcslen(SEPARATOR)))//and see if there's a SEPARATOR, if there isn't we're done
        goto DONE_PARSING;
    Description++;//if there is then
    m_szSourceFileDate = Description;//the string that follows the separator is the __DATE__
    Debug(Description);

    while(*Description != NULL_CHAR)Description++;
    if(0 != _tcsncmp(Description+1, SEPARATOR, _tcslen(SEPARATOR)))//and see if there's a SEPARATOR, if there isn't we're done
        goto DONE_PARSING;
    Description += 2;//Point past the separator
    m_szSourceFileName = Description;//the string following this separator is the __FILE__

    while(*Description != NULL_CHAR)Description++;
    if(0 != _tcsncmp(Description+1, SEPARATOR, _tcslen(SEPARATOR)))//and see if there's a SEPARATOR, if there isn't we're done
        goto DONE_PARSING;
    Description += 2;//Point past the separator
    m_szSourceFileTime = Description;//the string following this separator is the __TIME__

    while(*Description != NULL_CHAR)Description++;
    if(0 != _tcsncmp(Description+1, SEPARATOR, _tcslen(SEPARATOR)))//and see if there's a SEPARATOR, if there isn't we're done
        goto DONE_PARSING;
    Description += 2;//Point past the separator
    m_szSourceFileTimeStamp = Description;//the string following this separator is the __TIMESTAMP__

    while(*Description != NULL_CHAR)Description++;
    if(0 != _tcsncmp(Description+1, SEPARATOR, _tcslen(SEPARATOR)))//and see if there's a SEPARATOR, if there isn't we're done
        goto DONE_PARSING;
    Description += 2;//Point past the separator
    m_szDetailedDescription = Description;//the string following this separator is the Detailed Description

DONE_PARSING:
    if(_tcslen(m_szDescription)>67)//Limit descriptions of tests to 66 characters to prevent wrap around in the Tux -l output
    {
        m_szShortDescription[67] = 0x00;
        _tcsncpy(m_szShortDescription, m_szDescription, 67);
        m_szDescription = m_szShortDescription;
        if(m_szSourceFileDate != m_szSourceFileName)//if there's extended information, make sure the description ends in '...'
        {
            m_szShortDescription[64] = '.';
            m_szShortDescription[65] = '.';
            m_szShortDescription[66] = '.';
        }
    }
}


////////////////////////////////////////////////////////////////////////////////
// StaticTuxTest
//  This static member function Parses a string like "102,5010,12001" and runs
//  the three tests
//
// Parameters:
//  LPCTSTR                 lpszTestList //String of comma delimited test numbers
//
// Return value:
//  If any of the tests failed the return is trFAIL otherwise trPASS.
TestResult TuxTestBase::StaticExecuteTest(LPCTSTR lpszTestList)
{
    TestResult trResult = trPASS;
    TPS_EXECUTE tParam={0};
    static TCHAR szResult[6][15] = {TEXT("trNOT_HANDLED"), TEXT("trHANDLED"), TEXT("trSKIP"), TEXT("trPASS"), TEXT("trFAIL"), TEXT("trABORT")};


    if(NULL == GetFunctionTable())//Initialize the function table so we can search it.
        return trResult;

    Debug(TEXT("-----------------------------------"));
    Debug(TEXT("----------Executing Tests----------"));
    Debug(TEXT("-----------------------------------"));

    while(lpszTestList)
    {
        UINT nTestNumber = _ttoi(lpszTestList);
        if(0==nTestNumber)
            break;
        for(int n=0;n<m_NumTuxEntries;n++)//loop til we find the entry with the UniqueID
        {
            if(m_pFunctionTable[n].dwUniqueID == nTestNumber)
            {
                TestResult trThisResult;
                Debug(TEXT("------Executing Test %d-------"), nTestNumber);
                trThisResult = static_cast<TestResult>(StaticTuxTest(TPM_EXECUTE, reinterpret_cast<unsigned long *>(&tParam), &m_pFunctionTable[n]));
                if(trResult == trPASS)//If we're ever returned anything but pass then remember the first non pass result
                    trResult = trThisResult;
                Debug(TEXT("------Test %d returned %s-------"), nTestNumber, szResult[trThisResult]);
            }
        }
        lpszTestList = _tcschr(lpszTestList, ',');
        if(lpszTestList)
            lpszTestList++;
    }
    Debug(TEXT("-----------------------------------"));
    Debug(TEXT("---------Test %11s----------"), szResult[trResult]);
    Debug(TEXT("-----------------------------------"));
    return trResult;
}


////////////////////////////////////////////////////////////////////////////////
// StaticTuxTest
//  This static member function dispatches calls to the derived class' TuxTest
//
// Parameters:
//  UINT                    uMsg
//  TPPARAM                 tpParam
//  LPFUNCTION_TABLE_ENTRY  lpFTE
//
// Return value:
//  Whatever the derived TuxTest returned.

int WINAPI TuxTestBase::StaticTuxTest(UINT uMsg, TPPARAM tpParam, LPFUNCTION_TABLE_ENTRY lpFTE)
{
    // The shell doesn't necessarily want us to execute the test. Make sure
    if(uMsg != TPM_EXECUTE)//first.
        return trNOT_HANDLED;

    TuxTestBase *pThis = (TuxTestBase *)lpFTE->dwUserData;
    ASSERT(pThis);

    //Make a globally accessible copy of the Execute info.
    memcpy((void *)&g_TPS_Execute, (void *)tpParam, sizeof(g_TPS_Execute));
    srand(g_TPS_Execute.dwRandomSeed);

    m_CurrentTest = pThis;
    return pThis->ExecuteTest();
}


////////////////////////////////////////////////////////////////////////////////
// GetTestCaseString
//  The string representation of the TestNumber.TestCase is private; this is the
//  accessor function for it.
//
// Return value:
//  The TestNumber.TestCase as a string in xxxxx,yyy  form.

LPCTSTR TestCase::GetTestCaseString()
{
    TCHAR szTemp[5];

    m_szTestCase[0] = 0x00;
    for(int n=0;n<5 && m_TestNumber[n];n++)
    {
        _tcscat(m_szTestCase, _itot(m_TestNumber[n], szTemp, 10));
        _tcscat(m_szTestCase, TEXT("."));
    }
    return m_szTestCase;
}


////////////////////////////////////////////////////////////////////////////////
// GetTestCaseString
//  Sets the TestNumber and optionally the TestCase
//

void TestCase::SetTestNumber(DWORD Sub1, DWORD Sub2, DWORD Sub3, DWORD Sub4)
{
    ASSERT(Sub1<200);//This is here to make sure someone doesn't call SetTestCase when they meant
                            //to call SetTestNumber
    m_TestNumber[0] = Sub1;

    ASSERT(Sub2<200);//This is here to make sure someone doesn't call SetTestCase when they meant
                            //to call SetTestNumber
    m_TestNumber[1] = Sub2;

    ASSERT(Sub3<200);//This is here to make sure someone doesn't call SetTestCase when they meant
                            //to call SetTestNumber
    m_TestNumber[2] = Sub3;

    ASSERT(Sub4<200);//This is here to make sure someone doesn't call SetTestCase when they meant
                            //to call SetTestNumber
    m_TestNumber[3] = Sub4;


    TCHAR szTemp[80], szTemp2[20];
    szTemp[0] = 0x00;
    _tcscat(szTemp, TEXT("Test Case "));
    if(TuxTestBase::m_CurrentTest)
        _tcscat(szTemp, _itot(TuxTestBase::m_CurrentTest->m_UniqueID, szTemp2, 10));
    for(int n=0;n<4 && m_TestNumber[n];n++)
    {
        _tcscat(szTemp, TEXT("."));
        _tcscat(szTemp, _itot(m_TestNumber[n], szTemp2, 10));
    }
    Debug(szTemp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\waseventtest\consumer.h ===
#ifndef __CONSUMER_H__
#define __CONSUMER_H__

#include "catalog.h"

class CEventConsumer : public ISimpleTableEvent
{
public:
	CEventConsumer(): m_cRef(0), m_ams(NULL), m_cms(0)
	{};
	~CEventConsumer()
	{};

//IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

// ISimpleTableEvent
	STDMETHOD (OnChange)(ISimpleTableWrite2** i_ppISTWrite, ULONG i_cTables, DWORD i_dwCookie);

// Util.
	HRESULT	CopySubscription(MultiSubscribe* i_ams, ULONG i_cms);

private:
	HRESULT OnRowInsert(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow);
	HRESULT OnRowDelete(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow);
	HRESULT OnRowUpdate(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow);

	LONG		m_cRef;
	MultiSubscribe* m_ams; 
	ULONG		m_cms;
};

#endif // __CONSUMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\tuxtests\tuxtest.h ===
////////////////////////////////////////////////////////////////////////////////
//
//  ALL TUX DLLs
//  Copyright (c) 1997, Microsoft Corporation
//
//  Module:  TuxTest.h
//           This is a set of useful classes, macros etc for simplifying the
//           implementation of a TUX test.
//
//  Revision History:
//      11/14/1997  stephenr    Created
//
////////////////////////////////////////////////////////////////////////////////

#ifndef __TUXTEST_H__
#define __TUXTEST_H__


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TuxEntry
//
// Description:
//  This class represents a description of a suite of tests.  All descriptions
//  reside a depth 0 in the Tux FUNCTION_TABLE_ENTRY structure.
//
class TuxEntry
{
    public:
        TuxEntry(DWORD UniqueID, LPCTSTR Description);
        virtual ~TuxEntry();

        static LPFUNCTION_TABLE_ENTRY   GetFunctionTable();
        virtual bool                    IsARealTest() const {return false;}
        const DWORD                     m_UniqueID;


        static TuxEntry *m_pFirst;
        TuxEntry        *m_pNext;

    protected:
        static LPFUNCTION_TABLE_ENTRY   m_pFunctionTable;
        static int                      m_NumTuxEntries;

        LPCTSTR                         m_szDescription;

        virtual void Assign(LPFUNCTION_TABLE_ENTRY) const;
};

typedef TuxEntry TuxTestDescription;

////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TestBase
//
// Description:
//           This is an abstract base class that should be derived from to
//           implement a test (TUX or other).  It is used to encapsulate
//           hte ExecuteTest function.
//
//           Just derive your tests from this base class and instanciate
//           them and ExecuteTest.
//
class TestBase
{
    public:
        TestBase() : m_bDoneWithSetUp(true){}

        virtual TestResult  ExecuteTest() = 0;
    protected:
        void StartingTestSetup(){m_bDoneWithSetUp = false;}
        void DoneWithTestSetup(){m_bDoneWithSetUp = true;}
        bool IsDoneWithSetUp() const {return m_bDoneWithSetUp;}

    private:
        bool    m_bDoneWithSetUp;//This is defaulted to true so those tests that
                                 //don't use this will trFAIL instead of trABORTing
};


////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TuxTestBase
//
// Description:
//           This is an abstract base class that should be derived from to
//           implement a TUX test.  It is used to encapsulate dependant
//           variables, as well as automate the registration of the TUX
//           FUNCTION_TABLE_ENTRY structure.
//
//           Just derive your tests from this base class and instanciate
//           them at global scope.  When your ShellProc is called with an
//           SPM_REGISTER message, just call the static GetFunctionTable
//           method.  There is no need to muck with a global function
//           table.
//
class TuxTestBase : public TuxEntry, public TestBase
{
    public:
        TuxTestBase(DWORD UniqueTestID, LPCTSTR Description);
        static TestResult StaticExecuteTest(LPCTSTR lpszTestList);
        static TuxTestBase * m_CurrentTest;

        LPCTSTR GetDetailedDescription() const {return m_szDetailedDescription;}
        LPCTSTR GetSourceFileDate() const  {return m_szSourceFileDate;}
        LPCTSTR GetSourceFileName() const  {return m_szSourceFileName;}
        LPCTSTR GetSourceFileTime() const  {return m_szSourceFileTime;}
        LPCTSTR GetSourceFileTimeStamp() const {return m_szSourceFileTimeStamp;}
        LPCTSTR GetTestDescription() const {return m_szDescription;}

        virtual bool  IsARealTest() const {return true;}
    protected:
        static int WINAPI   StaticTuxTest(UINT uMsg, TPPARAM tpParam, LPFUNCTION_TABLE_ENTRY lpFTE);
        virtual void        Assign(LPFUNCTION_TABLE_ENTRY) const;

    protected://Deriving classes don't need to expose their ExecuteTest method
        virtual TestResult  ExecuteTest() = 0;

    private:
        TCHAR   m_szShortDescription[68];
        LPCTSTR m_szDetailedDescription;
        LPCTSTR m_szSourceFileDate;
        LPCTSTR m_szSourceFileName;
        LPCTSTR m_szSourceFileTime;
        LPCTSTR m_szSourceFileTimeStamp;
};

#define NULL_CHAR '\0'
#define SEPARATOR TEXT("")
#define SEPARATOR_STR  TEXT("\0")
#define SEPARATOR_STR1  TEXT("...\0")
#define END_STR  TEXT("\0\0")
#define DESCR(x) TEXT(x) SEPARATOR_STR1 TEXT(__DATE__) SEPARATOR_STR TEXT(__FILE__) SEPARATOR_STR TEXT(__TIME__) SEPARATOR_STR TEXT(__TIMESTAMP__) END_STR
#define DESCR2(x,y) TEXT(x) SEPARATOR_STR1 TEXT(__DATE__) SEPARATOR_STR TEXT(__FILE__) SEPARATOR_STR TEXT(__TIME__) SEPARATOR_STR TEXT(__TIMESTAMP__) SEPARATOR_STR y END_STR

////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TestCase
//
// Description:
//  This is just a helper class and is not really needed.  It just helps keep
//  track of which test case is being run with a larger test.
//
class TestCase
{
    public:
        TestCase(){memset(m_TestNumber, 0x00, 4*sizeof(DWORD));}

    protected:
        LPCTSTR GetTestCaseString();
        void    SetTestNumber(DWORD Sub1, DWORD Sub2=0, DWORD Sub3=0, DWORD Sub4=0);

        DWORD   m_TestNumber[4];
    private:
        TCHAR   m_szTestCase[30];
};



////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TTuxTest
//
// Description:
//  This template class represents a description of a tux test.  The type T is
//  the actual test class the gets instantiated at run time and executed.  The
//  type T must derive from TestBase or at least have a virtual ExecuteTest
//  function of the same prototype.
//
template <class T>
class TTuxTest : public TuxTestBase
{
    public:
        TTuxTest(DWORD dwUniqueTestID, LPCTSTR szDescription)  :
                TuxTestBase(dwUniqueTestID, szDescription){}

    protected:
        virtual TestResult ExecuteTest(){return T().ExecuteTest();}
};

////////////////////////////////////////////////////////////////////////////////
//
// Class:
//  TTuxTest
//
// Description:
//  Just like the template above, except some test classes one derives might
//  require extra parameters so the following set of templates allows test class
//  with additional parameters.
//
template <class T, class U>
class TTuxTest1 : public TuxTestBase
{
    public:
        TTuxTest1(DWORD dwUniqueTestID, LPCTSTR szDescription, U u)  :
                TuxTestBase(dwUniqueTestID, szDescription), m_U(u){}

    protected:
        U m_U;
        virtual TestResult ExecuteTest(){return T(m_U).ExecuteTest();}
};

template <class T, class U, class V>
class TTuxTest2 : public TuxTestBase
{
    public:
        TTuxTest2(DWORD dwUniqueTestID, LPCTSTR szDescription, U u, V v)  :
                TuxTestBase(dwUniqueTestID, szDescription), m_U(u), m_V(v){}

    protected:
        U m_U;
        V m_V;
        virtual TestResult ExecuteTest(){return T(m_U, m_V).ExecuteTest();}
};

template <class T, class U, class V, class W>
class TTuxTest3 : public TuxTestBase
{
    public:
        TTuxTest3(DWORD dwUniqueTestID, LPCTSTR szDescription, U u, V v, W w)  :
                TuxTestBase(dwUniqueTestID, szDescription), m_U(u), m_V(v), m_W(w){}

    protected:
        U m_U;
        V m_V;
        W m_W;
        virtual TestResult ExecuteTest(){return T(m_U,m_V,m_W).ExecuteTest();}
};

#endif// __TUXTEST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\cooker.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    Cooker.h

Abstract:

	Class that does the cookdown process.

Author:

    Varsha Jayasimha (varshaj)        14-Jun-1999

Revision History:

--*/


#ifndef _COOKER_H_
#define _COOKER_H_


class CCooker
{

public:

    CCooker();

    ~CCooker();

	HRESULT	CookDown(BOOL i_bRecoveringFromCrash);

	HRESULT CookDown(WAS_CHANGE_OBJECT* i_aWASChngObj,
				     ULONG				i_cWASChngObj);

	static HRESULT InitializeCookDownFile(LPWSTR* o_wszCookDownFileDir,
								          LPWSTR* o_wszCookDownFile);

	static HRESULT GetMachineConfigDirectory(LPWSTR* o_wszPathDir);

private:

	HRESULT DeleteObsoleteFiles();

	HRESULT	BeginCookDown();

	HRESULT CookDownFromMetabase(DWORD	i_dwChangeNumber,
								 BYTE*  i_pbTimeStamp,
								 BOOL i_bRecoveringFromCrash); 

	HRESULT	EndCookDown(HRESULT	i_hr);

	HRESULT InitializeCookDownFromMetabase(IMSAdminBase**			o_pIMSAdminBase,
										   ISimpleTableDispenser2**	o_pISTDisp,
										   METADATA_HANDLE*			o_phMBHandle,
										   CMBAppPoolCooker**		o_pAppPoolCooker,
										   CMBSiteCooker**			o_pSiteCooker,
										   CMBGlobalCooker**		o_pGlobalCooker);

	HRESULT InitializeAdminBaseObjectAndDispenser(IMSAdminBase**			o_pIMSAdminBase,
												  METADATA_HANDLE*			o_phMBHandle,
												  ISimpleTableDispenser2**	o_pISTDisp);

	HRESULT IncrementalCookDownAppPools(WAS_CHANGE_OBJECT*        i_aWASChngObj,
                                        ULONG				      i_cWASChngObj,
                                        IMSAdminBase*			  i_pIMSAdminBase,
                                        METADATA_HANDLE		      i_hMBHandle,
                                        ISimpleTableDispenser2*   i_pISTDisp);

	HRESULT IncrementalCookDownSites(WAS_CHANGE_OBJECT*          i_aWASChngObj,
                                     ULONG				         i_cWASChngObj,
                                     IMSAdminBase*			     i_pIMSAdminBase,
                                     METADATA_HANDLE		     i_hMBHandle,
                                     ISimpleTableDispenser2*     i_pISTDisp);


	HRESULT IncrementalCookDownApps(WAS_CHANGE_OBJECT*         i_aWASChngObj,
                                    ULONG				       i_cWASChngObj,
                                    IMSAdminBase*			   i_pIMSAdminBase,
                                    METADATA_HANDLE		       i_hMBHandle,
                                    ISimpleTableDispenser2*    i_pISTDisp);

	HRESULT IncrementalCookDownGlobalW3SVC(WAS_CHANGE_OBJECT*        i_aWASChngObj,
                                           ULONG				     i_cWASChngObj,
                                           IMSAdminBase*			 i_pIMSAdminBase,
                                           METADATA_HANDLE		     i_hMBHandle,
                                           ISimpleTableDispenser2*   i_pISTDisp);

private:

	LPWSTR						m_wszCookDownFileDir;
	LPWSTR						m_wszCookDownFile;
	HANDLE						m_hHandle;

};  // class CCooker

#endif  // _COOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\waseventtest\consumer.cpp ===
#include "objbase.h"
#include "consumer.h"
#include "Coremacros.h"
#include "catmeta.h"
#include "stdio.h"

HRESULT PrintRow (ISimpleTableWrite2 *i_pISTWrite, ULONG i_WriteRow);

STDMETHODIMP CEventConsumer::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableEvent)
	{
		*ppv = (ISimpleTableEvent*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableEvent*) this;
	}

	if (NULL != *ppv)
	{
		((ISimpleTableEvent*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
	
}

STDMETHODIMP_(ULONG) CEventConsumer::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

STDMETHODIMP_(ULONG) CEventConsumer::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

STDMETHODIMP CEventConsumer::OnChange(
	ISimpleTableWrite2** i_ppISTWrite, 
	ULONG		i_cTables, 
	DWORD		i_dwCookie)
{
	ISimpleTableController *pISTControl = NULL;
	ULONG		iTable;
	ULONG		iRow;
	DWORD		eAction;
	HRESULT		hr = S_OK;

	for (iTable = 0; iTable < i_cTables; iTable++)
	{
		if (i_ppISTWrite[iTable] == NULL)
		{
			continue;
		}
		hr = i_ppISTWrite[iTable]->QueryInterface(IID_ISimpleTableController, (LPVOID*)&pISTControl);
		if (FAILED(hr)) {	ASSERT(SUCCEEDED(hr)); return hr;	}

		iRow = 0;
		while ((hr = pISTControl->GetWriteRowAction(iRow, &eAction)) == S_OK)
		{
			switch (eAction)
			{
			case eST_ROW_IGNORE:
				// Don't do anything.
				break;
			case eST_ROW_INSERT:
				hr = OnRowInsert(m_ams[iTable].wszDatabase, m_ams[iTable].wszTable, i_ppISTWrite[iTable], iRow);
				if (FAILED(hr)) {	ASSERT(SUCCEEDED(hr)); return hr;	}
				break;
			case eST_ROW_UPDATE:
				hr = OnRowUpdate(m_ams[iTable].wszDatabase, m_ams[iTable].wszTable, i_ppISTWrite[iTable], iRow);
				if (FAILED(hr)) {	ASSERT(SUCCEEDED(hr)); return hr;	}
				break;
			case eST_ROW_DELETE:
				hr = OnRowDelete(m_ams[iTable].wszDatabase, m_ams[iTable].wszTable, i_ppISTWrite[iTable], iRow);
				if (FAILED(hr)) {	ASSERT(SUCCEEDED(hr)); return hr;	}
				break;
			default:
				ASSERT(0 && "Invalid row action for an event");
				break;
			}

			iRow++;
		}
		pISTControl->Release();
		i_ppISTWrite[iTable]->Release();
	}
	return S_OK;
}

HRESULT	CEventConsumer::CopySubscription(MultiSubscribe* i_ams, ULONG i_cms)
{
	m_ams = new MultiSubscribe[i_cms];
	if (m_ams == NULL) {	ASSERT(0); return E_OUTOFMEMORY;	}
	ZeroMemory(m_ams, sizeof(MultiSubscribe) * i_cms);

	for (ULONG	i = 0; i < i_cms; i++)
	{
		m_ams[i].wszDatabase = new WCHAR[wcslen(i_ams[i].wszDatabase)+1];
		if (m_ams[i].wszDatabase == NULL) {	ASSERT(0); return E_OUTOFMEMORY;	}
		wcscpy(m_ams[i].wszDatabase, i_ams[i].wszDatabase);

		m_ams[i].wszTable = new WCHAR[wcslen(i_ams[i].wszTable)+1];
		if (m_ams[i].wszTable == NULL) {	ASSERT(0); return E_OUTOFMEMORY;	}
		wcscpy(m_ams[i].wszTable, i_ams[i].wszTable);
		// The rest is not required.
	}
	return S_OK;
}

HRESULT CEventConsumer::OnRowInsert(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow)
{
	HRESULT	hr;

	wprintf(L"Inserting Row to table: %s : \n", i_wszTable); 
	hr = PrintRow(i_pISTWrite, i_iWriteRow);
	return hr;
}

HRESULT CEventConsumer::OnRowDelete(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow)
{
	HRESULT	hr;

	wprintf(L"Deleting row in table: %s : \n", i_wszTable); 
	hr = PrintRow(i_pISTWrite, i_iWriteRow);
	return hr;
}

HRESULT CEventConsumer::OnRowUpdate(LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, ISimpleTableWrite2* i_pISTWrite, ULONG i_iWriteRow)
{
	HRESULT	hr;

	wprintf(L"Updating row in table: %s : \n", i_wszTable); 
	hr = PrintRow(i_pISTWrite, i_iWriteRow);
	return hr;
}


HRESULT PrintRow (ISimpleTableWrite2 *i_pISTWrite, ULONG i_WriteRow)
{
	HRESULT hr;
	ULONG cRows, cColumns;
	SimpleColumnMeta *acColumnMetas;
	LPVOID * apData;
	ULONG * acbSize;
	ULONG*	adwStatus;
	ULONG j;

	ULONG			ib;
	GUID*			pguid;
	DWORD			dwtype;	
	ULONG			cb;
	DWORD			dwStatus;
	DWORD			dwfMeta;
	LPVOID			pv;
	WCHAR *			wsz;
	
	
	hr = i_pISTWrite->GetTableMeta(NULL, NULL, &cRows, &cColumns);
	if( FAILED (hr)) 
	{
		wprintf(L"FAILED!!! \n"); 
	}

	acColumnMetas = new SimpleColumnMeta[cColumns];

	apData = new LPVOID[cColumns];
	acbSize = new ULONG[cColumns];
	adwStatus = new DWORD[cColumns];
	
	hr = i_pISTWrite->GetColumnMetas(cColumns, NULL, acColumnMetas);
	if( FAILED (hr)) 
	{
		wprintf(L"FAILED!!! \n"); 
	}
	
	hr = i_pISTWrite->GetWriteColumnValues(i_WriteRow, cColumns, NULL, adwStatus, acbSize, apData);
	if( FAILED (hr)) 
	{
		wprintf(L"FAILED!!! \n"); 
	}

	for(j = 0; j<cColumns; j++)
	{
		pv = apData[j];
		cb = acbSize[j];
		dwStatus = adwStatus[j];

		dwtype = acColumnMetas[j].dbType;

		dwfMeta = acColumnMetas[j].fMeta;

		if((fST_COLUMNSTATUS_CHANGED != (dwStatus & fST_COLUMNSTATUS_CHANGED) ) && 
		   (fCOLUMNMETA_PRIMARYKEY != (dwfMeta & fCOLUMNMETA_PRIMARYKEY)))
			continue;

		
		wprintf (L"%d (%d,%d): ",j, dwtype, cb);		
		
		switch(dwtype){
			case DBTYPE_WSTR: //wstr
				wprintf (L"%s", (NULL == pv ? L"<NULL>" : (LPWSTR) pv));
			break;
			case DBTYPE_GUID: //guid
				if (NULL == pv)
				{
					wprintf (L"<NULL>");
				}
				else
				{
					pguid = (GUID*) pv;
					StringFromCLSID (*pguid, &wsz);
					wprintf (L"%s", (LPWSTR) wsz);
					CoTaskMemFree (wsz);
				}
				break;				
			case DBTYPE_BYTES: //bytes
				if (NULL == pv)
				{
					wprintf (L"<NULL>");
				}
				else
				{
					for (ib = 0; ib < cb; ib++)
					{
						wprintf (L"%x", ((BYTE*) pv)[ib]);
					}
				}
			break;
			case DBTYPE_UI4: // ui4
				if (NULL == pv)
				{
					wprintf (L"<NULL>");
				}
				else
				{
					wprintf (L"%lu", *(ULONG*) pv);
				}
			break;
			default:
				ASSERT (0);
			break;
		}
		
		wprintf (L"\n");
	} //columns
	wprintf (L"\n");

	delete [] acColumnMetas;
	delete [] apData;
	delete [] acbSize;
	delete [] adwStatus;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\test\waseventtest\waseventtest.cpp ===
#define _WIN32_DCOM
#include "objbase.h"
#include "catalog.h"
#include "catmeta.h"
#include "conio.h"
#include "CoreMacros.h"
#include "atlbase.h"
#include "consumer.h"

HRESULT GetMaxNode(ISimpleTableDispenser2 *pISTDisp, DWORD	*pdwMaxNode);

HINSTANCE g_hModule;

// Debugging
DECLARE_DEBUG_PRINTS_OBJECT();



int _cdecl main(int		argc,					// How many input arguments.
				CHAR	*argv[])				// Optional config args.
{
	CEventConsumer	*pConsumer;
	CComPtr<ISimpleTableDispenser2> pISTDisp;	
	CComPtr<ISnapshotManager> pISSMgr;
	CComPtr<ISimpleTableRead2> pISTPools;
	CComPtr<ISimpleTableRead2> pISTSites;
	CComPtr<ISimpleTableRead2> pISTApps;
	CComPtr<ISimpleTableRead2> pISTGlobalW3SVC;
	CComPtr<ISimpleTableEvent> pISTEvent;
	CComPtr<ISimpleTableAdvise> pISTAdvise;
	DWORD		dwCookie;
	SNID		snid;
	HRESULT		hr = S_OK;

	MultiSubscribe ams[] = {{wszDATABASE_IIS, wszTABLE_APPPOOLS, NULL, NULL, eST_QUERYFORMAT_CELLS},
							{wszDATABASE_IIS, wszTABLE_SITES, NULL, NULL, eST_QUERYFORMAT_CELLS},
							{wszDATABASE_IIS, wszTABLE_APPS, NULL, NULL, eST_QUERYFORMAT_CELLS},
							{wszDATABASE_IIS, wszTABLE_GlobalW3SVC, NULL, NULL, eST_QUERYFORMAT_CELLS}};
	ULONG	cms = sizeof(ams) / sizeof(MultiSubscribe);

	CoInitializeEx(NULL, COINIT_MULTITHREADED);

	// Initialize security. (Bug fix to make notification work on W2K SP1)
	hr = CoInitializeSecurity(NULL, 
							-1, 
							NULL, 
							NULL, 
							RPC_C_AUTHN_LEVEL_DEFAULT,
							RPC_C_IMP_LEVEL_IMPERSONATE,
                            NULL,
                            EOAC_NONE,
                            NULL);
	if(FAILED(hr)) {	return hr;	}	

	// Cookdown.
	hr = CookDown (WSZ_PRODUCT_IIS);
	if ( FAILED(hr) ) return hr;

	hr = UninitCookdown (WSZ_PRODUCT_IIS,FALSE);
	if ( FAILED(hr) ) return hr;

	hr = CookDown (WSZ_PRODUCT_IIS);
	if ( FAILED(hr) ) return hr;

    wprintf (L"Cookdown is done!. Sleeping 5 sec.\n");		
    Sleep (5000);
    wprintf (L"Woke up.\n");		

	// Get the dispenser.
	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);
	if ( FAILED(hr) ) return hr;

	hr = pISTDisp->QueryInterface(IID_ISnapshotManager, (LPVOID*) &pISSMgr);
	if ( FAILED(hr) ) return hr;

	hr = pISSMgr->QueryLatestSnapshot(&snid);
	if ( FAILED(hr) ) return hr;

	STQueryCell	qcell = {(LPVOID)&snid, eST_OP_EQUAL, iST_CELL_SNID, DBTYPE_UI4, 0};
	ULONG		ccells = 1;

	hr = pISTDisp->GetTable (wszDATABASE_IIS, wszTABLE_APPPOOLS, &qcell, &ccells, eST_QUERYFORMAT_CELLS, 0, (LPVOID*)&pISTPools);
	if ( FAILED(hr) ) return hr;
	hr = pISTDisp->GetTable (wszDATABASE_IIS, wszTABLE_SITES, &qcell, &ccells, eST_QUERYFORMAT_CELLS, 0, (LPVOID*)&pISTSites);
	if ( FAILED(hr) ) return hr;
	hr = pISTDisp->GetTable (wszDATABASE_IIS, wszTABLE_APPS, &qcell, &ccells, eST_QUERYFORMAT_CELLS, 0, (LPVOID*)&pISTApps);
	if ( FAILED(hr) ) return hr;

	// Do WAS stuff.

    wprintf (L"Sleeping for another 5 sec after QLS.\n");		
    Sleep(5000);
    wprintf (L"Woke up.\n");		

	hr = pISTDisp->QueryInterface(IID_ISimpleTableAdvise, (LPVOID*) &pISTAdvise);
	if ( FAILED(hr) )	{	ASSERT(SUCCEEDED(hr)); return hr;	}

	pConsumer = new CEventConsumer;
	pConsumer->QueryInterface(IID_ISimpleTableEvent, (void**) &pISTEvent);
	
	hr = pISTAdvise->SimpleTableAdvise(pISTEvent, snid, ams, cms, &dwCookie);
	if ( FAILED(hr) )	{	ASSERT(SUCCEEDED(hr)); return hr;	}

	hr = pISSMgr->ReleaseSnapshot(snid);
	if ( FAILED(hr) ) return hr;

	pConsumer->CopySubscription(ams, cms);

	// wait for some file changes.
	_getch();
	
	hr = pISTAdvise->SimpleTableUnadvise(dwCookie);
	if ( FAILED(hr) )	{	ASSERT(SUCCEEDED(hr)); return hr;	}


	// Uninitialize.
	hr = UninitCookdown (WSZ_PRODUCT_IIS,FALSE);
	if ( FAILED(hr) ) return hr;

	CoUninitialize();
	return 0;
}

HRESULT OnAppDelete(
	ISimpleTableDispenser2	*i_pISTDisp,
	LPWSTR		i_wszAppURL,
	ULONG		i_iSiteID)
{
	CComPtr<ISimpleTableWrite2> pISTApps;
	ULONG		iApp;
	ULONG		iColumn = iAPPS_AppRelativeURL;
	ULONG		cChars;
	LPWSTR		wszAppURL;
	HRESULT		hr = S_OK;

	STQueryCell	qcell[] = {
		{(LPVOID)&i_iSiteID, eST_OP_EQUAL, iAPPS_SiteID, DBTYPE_UI4, 0}};
	ULONG		ccells = sizeof(qcell)/sizeof(qcell[0]);

	hr = i_pISTDisp->GetTable (wszDATABASE_IIS, wszTABLE_APPS, qcell, &ccells, eST_QUERYFORMAT_CELLS, fST_LOS_READWRITE, (LPVOID*)&pISTApps);
	if (FAILED(hr))	{	return hr;	}

	iApp = 0;
	cChars = wcslen(i_wszAppURL);
	while ((hr = pISTApps->GetColumnValues(iApp, 1, &iColumn, NULL, (LPVOID*)&wszAppURL)) == S_OK)
	{
		if (_wcsnicmp(i_wszAppURL, wszAppURL, cChars) == 0)
		{
			hr = pISTApps->AddRowForDelete(iApp);
			if (FAILED(hr))	{	return hr;	}
		}
		iApp++;
	}

	if (hr = E_ST_NOMOREROWS)
	{
		hr = S_OK;
	}
	if (FAILED(hr))	{	return hr;	}

	hr = pISTApps->UpdateStore();
	
	return hr;
}

HRESULT OnSiteDelete(
	ISimpleTableDispenser2	*pISTDisp,
	ULONG		iSiteID)
{
	CComPtr<ISimpleTableWrite2> pISTApps;
	ULONG		iApp;
	HRESULT		hr = S_OK;

	STQueryCell	qcell[] = {
		{(LPVOID)&iSiteID, eST_OP_EQUAL, iAPPS_SiteID, DBTYPE_UI4, 0}};
	ULONG		ccells = sizeof(qcell)/sizeof(qcell[0]);

	hr = pISTDisp->GetTable (wszDATABASE_IIS, wszTABLE_APPS, qcell, &ccells, eST_QUERYFORMAT_CELLS, fST_LOS_READWRITE, (LPVOID*)&pISTApps);
	if (FAILED(hr))	{	return hr;	}

	iApp = 0;
	while ((hr = pISTApps->AddRowForDelete(iApp)) == S_OK)
	{
		iApp++;
	}

	if (hr = E_ST_NOMOREROWS)
	{
		hr = S_OK;
	}
	if (FAILED(hr))	{	return hr;	}

	hr = pISTApps->UpdateStore();
	
	return hr;
}

HRESULT OnAppPoolDelete(
	ISimpleTableDispenser2	*i_pISTDisp,
	LPWSTR		i_wszAppPoolID)
{
	CComPtr<ISimpleTableWrite2> pISTApps;
	ULONG		iApp;
	ULONG		iColumn = iAPPS_AppPoolId;
	LPWSTR		wszDefaultAppPoolID = L"DefaultAppPoolID";
	HRESULT		hr		= S_OK;

	STQueryCell	qcell[] = {
		{(LPVOID)i_wszAppPoolID, eST_OP_EQUAL, iAPPS_AppPoolId, DBTYPE_WSTR, 0}};
	ULONG		ccells = sizeof(qcell)/sizeof(qcell[0]);

	hr = i_pISTDisp->GetTable (wszDATABASE_IIS, wszTABLE_APPS, qcell, &ccells, eST_QUERYFORMAT_CELLS, fST_LOS_READWRITE, (LPVOID*)&pISTApps);
	if (FAILED(hr))	{	return hr;	}

	iApp = 0;

	while ((hr = pISTApps->SetWriteColumnValues(iApp, 1, &iColumn, NULL, (LPVOID*)&wszDefaultAppPoolID)) == S_OK)
	{
		iApp++;
	}

	if (hr = E_ST_NOMOREROWS)
	{
		hr = S_OK;
	}
	if (FAILED(hr))	{	return hr;	}

	hr = pISTApps->UpdateStore();
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\isthelper.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "catalog.h"
#include "catmeta.h"
#include "ISTHelper.h"
#include <iadmw.h>
#include "catmacros.h"

HRESULT FillInColumnMeta(ISimpleTableRead2* i_pISTColumnMeta,
						 LPCWSTR            i_wszTable,
						 ULONG              i_iCol,
						 LPVOID*            io_apvColumnMeta)
{
	HRESULT hr           = S_OK;
	ULONG   a_iCol[]     = {iCOLUMNMETA_InternalName,
		                    iCOLUMNMETA_Type, 
			                iCOLUMNMETA_MetaFlags,
						    iCOLUMNMETA_FlagMask,
						    iCOLUMNMETA_StartingNumber,
						    iCOLUMNMETA_EndingNumber,
							iCOLUMNMETA_SchemaGeneratorFlags,
							iCOLUMNMETA_ID,
							iCOLUMNMETA_UserType,
							iCOLUMNMETA_Attributes
	};
	ULONG   cCol         = sizeof(a_iCol)/sizeof(ULONG);
	LPVOID  a_Identity[] = {(LPVOID)i_wszTable,
		                    (LPVOID)&i_iCol
	};
	ULONG   iReadRow     = 0;

	hr = i_pISTColumnMeta->GetRowIndexByIdentity(NULL,
			                                     a_Identity,
												 &iReadRow);
	if(FAILED(hr))
	{
		return hr;
	}

	hr = i_pISTColumnMeta->GetColumnValues(iReadRow,
									       cCol,
									       a_iCol,
									       NULL,
									       (LPVOID*)io_apvColumnMeta);
	if(FAILED(hr))
	{
		return hr;
	}

	return hr;

} // FillInColumnMeta


DWORD GetMetabaseType(DWORD i_dwType,
					  DWORD i_dwMetaFlags)
{
	if(i_dwType <= 5)
    {
		return i_dwType;  // Already metabase type.
    }

	switch(i_dwType)
	{
		case DBTYPE_UI4:
			return DWORD_METADATA;
		case DBTYPE_BYTES:
			return BINARY_METADATA;
		case DBTYPE_WSTR:
			if(0 != (i_dwMetaFlags & fCOLUMNMETA_MULTISTRING))
            {
				return MULTISZ_METADATA;
            }
            else if(0 != (i_dwMetaFlags & fCOLUMNMETA_EXPANDSTRING))
            {
                return EXPANDSZ_METADATA;
            }
			else
            {
				return STRING_METADATA;
            }
		default:
			ASSERT(0 && L"Invalid catalog type");
			break;
	}

	return -1;

} //  GetMetabaseType

BOOL IsMetabaseProperty(DWORD i_dwProperty)
{
	return (0 != i_dwProperty);

	//
	// We assume that all columns with ID zero are not associated with
	// a property in the metabase. Although ID 0 is a valid metabase 
	// ID, none of the WAS tables use this property and hence we can
	// make the assumption.
	//
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\cooker.cpp ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    Cooker.cpp

Abstract:

    This object cooks down metabase data that the Web admin service needs into
	a persisted cache. (CLB). Validations of the cooked down metabase data are
	also done here. Incremental changes to the metabase are also cooked down
	into the persisted cache with the help of this class.

Author:

    Varsha Jayasimha (varshaj)        06-Mar-2000

Revision History:

--*/


#include "Catmeta.h"
#include "catalog.h"
#include "catmacros.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "MBListen.h"

LPCWSTR	g_wszCookDownFile			= L"WASMB.CLB";
#define IIS_MD_W3SVC				L"/LM/W3SVC"
#define MB_TIMEOUT					(30 * 1000)
#define SEARCH_EXTENSION			L".????????????"
#define LONG_PATH_SIGNATURE			L"\\\\?\\"
#define SLASH						L"\\"
#define CMAX_RETRY                  20
#define CMS_SLEEP_BEFORE_RETRY      5000

#include "MBBaseCooker.h"
#include "MBGlobalCooker.h"
#include "MBAppPoolCooker.h"
#include "MBAppCooker.h"
#include "MBSiteCooker.h"
#include "Cooker.h"
#include "undefs.h"
#include "SvcMsg.h"
#include "SafeCS.h"

//
// TODO: Move elsewhere
//
HRESULT CLBCommitWrite( LPCWSTR wszDatabase, const WCHAR* wszInFileName );
HRESULT CLBAbortWrite( LPCWSTR wszDatabase, const WCHAR* wszInFileName );
HRESULT GetWriteLock( LPCWSTR wszDatabase, const WCHAR* wszInFileName, HANDLE* phLock );
HRESULT ReleaseWriteLock( HANDLE hLock );

CSafeAutoCriticalSection g_SafeCSCookdown;

/***************************************************************************++


Routine Description:

    This is called by uninit and writes the Stopistening property in the
	metabase, gets the change number of the metabase, forces a flush
	and gets the metabase file timestamp.

Arguments:

    [out] - Change number.
	[out] - File Attributes.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT GetMetabaseInfo(DWORD*                     o_dwChangeNumber,
						WIN32_FILE_ATTRIBUTE_DATA* o_FileAttr)
{
	CComPtr<IMSAdminBase>			spIMSAdminBase;
	LPWSTR                          wszMetabaseFile          = NULL; 
    HRESULT                         hr                       = S_OK;
	METADATA_HANDLE                 hMBHandle                = NULL;
	METADATA_RECORD                 mdr;
	DWORD                           dwStopListening          = 1;

	hr = CoCreateInstance(CLSID_MSAdminBase,           // CLSID
						  NULL,                        // controlling unknown
						  CLSCTX_SERVER,               // desired context
						  IID_IMSAdminBase,            // IID
						  (void**)&spIMSAdminBase);     // returned interface

	if(FAILED(hr))
	{
		TRACE (L"CoCreateInstance on CLSID_MSAdminBase failed. hr = %08x\n", hr);
		goto exit;
	}

	//
	// Lock the metabase
	//

	hr = spIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
								 L"",
								 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
								 MB_TIMEOUT,
								 &hMBHandle);

	if(FAILED(hr))
	{
		TRACE (L"Unable to open the root key in the metabase. Open key failed. hr = %08x\n", hr);
		goto exit;
	}

	//
	// Write the StopListening property to signal to the metabase listener
	// to stop all cookdowns.
	//

	mdr.dwMDIdentifier	= 9987;
	mdr.dwMDDataLen		= sizeof(DWORD);
	mdr.pbMDData		= (BYTE*)&dwStopListening;
	mdr.dwMDAttributes	= METADATA_VOLATILE;
	mdr.dwMDDataType	= DWORD_METADATA;

	hr = spIMSAdminBase->SetData(hMBHandle, 
								 L"", 
								 &mdr);


	if(FAILED(hr))
	{
		TRACE (L"Unable to set StopListening property. SetData failed. hr = %08x\n", hr);
		goto exit;
	}

	//
	// Get the metabase in-memory change number
	//

	hr = spIMSAdminBase->GetSystemChangeNumber(o_dwChangeNumber);

	if(FAILED(hr))
	{
		TRACE (L"Unable to retreive the change number from in-memory metabase. GetSystemChangeNumber failed. hr = %08x\n", hr);
		goto exit;
	}

	//
	// Unlock the metabase
	//

	spIMSAdminBase->CloseKey(hMBHandle);

	hMBHandle = NULL;

	//
	// Flush the metabase to disk
	//

	hr = spIMSAdminBase->SaveData();

	if(FAILED(hr))
	{
		TRACE (L"Flushing the metabase to disk (SaveData) failed. hr = %08x\n", hr);
		goto exit;
	}

	//
	// Retreive the timestamp of the metabase file.
	//

	hr = CMBBaseCooker::GetMetabaseFile(&wszMetabaseFile);

	if(FAILED(hr))
	{
		TRACE (L"Unable to metabase file timestamp. GetMetabaseFile failed. hr = %08x\n", hr);
		goto exit;
	}

	if(!GetFileAttributesEx(wszMetabaseFile,
							GetFileExInfoStandard,
							o_FileAttr)
	  )
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		TRACE (L"Unable to metabase file timestamp. Setting it to 0 which will force a full cookdown on subsequent startup. GetFileAttributesEx failed. hr = %08x\n", hr);
		goto exit;
	}

exit:

	if(NULL != 	hMBHandle)
	{
		spIMSAdminBase->CloseKey(hMBHandle);
		hMBHandle = NULL;
	}

	if(NULL != wszMetabaseFile)
	{
		delete [] wszMetabaseFile;
		wszMetabaseFile = NULL;
	}

    return hr;

} // GetMetabaseInfo


/***************************************************************************++


Routine Description:

    This function does a full cookdown. This is an internal function, and must
	not be called from WAS. WAS must call API CookDown with calls 
	CookDownInternal.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

HRESULT FullCookDown (BOOL i_bRecoveringFromCrash)
{
	CCooker 	*pCooker	= NULL;
	HRESULT		hr			= S_OK;
	DWORD       dwRes       = 0;
	CSafeLock   csSafe(g_SafeCSCookdown);

	dwRes = csSafe.Lock();
	
	if(ERROR_SUCCESS != dwRes)
	{
		TRACE (L"Lock failed with dwError = %08x\n", dwRes);
		return HRESULT_FROM_WIN32(dwRes);
	}
	
	pCooker = new CCooker();

	if(NULL == pCooker)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		hr = pCooker->CookDown(i_bRecoveringFromCrash);
		if(FAILED(hr))
		{
			TRACE (L"CookDown failed with hr = %08x\n", hr);
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_FAILED, NULL));
		}

		delete pCooker;
	}

	csSafe.Unlock();  // Signal CookDownDone.

	return hr;

} // FullCookDown

/***************************************************************************++


Routine Description:

    CookDown API. Assumption: This API is called to do a full cookdown, once,
	during the startup of WAS (Web Admin Service). Hence initialization of 
	global variables is done here in InitializeGlobalEvents

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

STDAPI CookDownInternal ()
{
	return FullCookDown(FALSE);

} // API CookDown


/***************************************************************************++


Routine Description:

    CookDown API. This API is called to do incremental cookdowns, while the
	WAS (Web Admin Service) is running. This can be called multiple times
	when the process is running. An initial full cookdown (CookDownInternal)
	must be called once, at process startup (WAS startup) time, before this  
	function can be called multiple times, because CookDownInternal 
	initializes global variables in InitializeGlobalEvents.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

STDAPI CookDownIncrementalInternal(WAS_CHANGE_OBJECT* i_aWASChngObj,
								   ULONG			  i_cWASChngObj)
{
	CCooker 	*pCooker	= NULL;
	HRESULT		hr			= S_OK;
	DWORD       dwRes       = ERROR_SUCCESS;
	CSafeLock   csSafe(g_SafeCSCookdown);

	dwRes = csSafe.Lock();
	
	if(ERROR_SUCCESS != dwRes)
	{
		TRACE (L"Lock failed with dwError = %08x\n", dwRes);
		return HRESULT_FROM_WIN32(dwRes);
	}
	
	pCooker = new CCooker();

	if(NULL == pCooker)
	{
		hr = E_OUTOFMEMORY;
	}
	else
	{
		hr = pCooker->CookDown(i_aWASChngObj,
							   i_cWASChngObj);
		if(FAILED(hr))
		{
			TRACE (L"CookDown failed with hr = %08x\n", hr);
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_FAILED, NULL));
		}

		delete pCooker;
	}

	csSafe.Unlock();  // Signal CookDownDone.

	return hr;

} // API CookDownIncrementalInternal 

/***************************************************************************++


Routine Description:

    This API is called to recover from an inetinfo crash. We wait for any
	pending cookdowns to complete and then trigger a fresh cookdown.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

STDAPI RecoverFromInetInfoCrashInternal()
{
	return FullCookDown(TRUE);

} // API RecoverFromInetInfoCrash 


/***************************************************************************++


Routine Description:

    This API is called when WAS is done with Cookdown work and telling us
    to do the proper cleanup.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

STDAPI UninitCookdownInternal(BOOL bDoNotTouchMetabase)
{
	CComPtr<ISimpleTableDispenser2> spISTDisp;
	CComPtr<ISimpleTableEventMgr>   spIEventMgr;
	CSafeLock                       csSafe(g_SafeCSCookdown);
    HRESULT                         hr                       = S_OK;
	DWORD                           dwRes                    = 0;
	LPWSTR                          wszCookDownFileDir       = NULL;
	LPWSTR                          wszCookDownFile          = NULL;
	DWORD                           dwMBChangeNumber         = 0;
	WIN32_FILE_ATTRIBUTE_DATA       FileAttr;
	BOOL                            bFailedToGetMetabaseInfo = FALSE;
	DWORD                           dwLOS                    = fST_LOS_READWRITE;

	memset(&FileAttr, 0, sizeof(WIN32_FILE_ATTRIBUTE_DATA));

	if(!bDoNotTouchMetabase)
	{
		hr = GetMetabaseInfo(&dwMBChangeNumber,
			                 &FileAttr);

		if(FAILED(hr))
		{
			TRACE (L"Unable to get metabase info. hr = %08x\n", hr);
			hr = S_OK;
			bFailedToGetMetabaseInfo = TRUE;
		}

	} // End if (!bDoNotTouchMetabase)

	//
	// Call Unadvise 
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &spISTDisp);
	if(FAILED(hr))
	{
		TRACE (L"Could not get dispenser. GetSimpleTableDispenser failed. hr = %08x\n", hr);
		goto exit;
	}

	hr = spISTDisp->QueryInterface(IID_ISimpleTableEventMgr,
			                      (LPVOID*)&spIEventMgr);

	if(FAILED(hr))
    {
		TRACE (L"Could not get event manager. QI failed. hr = %08x\n", hr);
		goto exit;
    }

	hr = spIEventMgr->UninitMetabaseListener();

	if(FAILED(hr))
    {
		TRACE (L"UninitMetabaseListener failed. hr = %08x\n", hr);
		goto exit;
    }
	else if(S_FALSE == hr)
	{
		//
		// If UninitMetabaseListener returns S_FALSE, then it means that
		// it did not get notified about the StopListening property and we 
		// want to force a full cookdown on a subsequent restart, hence we do not  
		// update the change number and timestamps.
		//
		goto exit;
	}

	if((!bDoNotTouchMetabase) && (!bFailedToGetMetabaseInfo))
	{
		//
		// Update change number and time stamp
		//

		hr = CCooker::InitializeCookDownFile(&wszCookDownFileDir,
											 &wszCookDownFile);

		if(FAILED(hr))
		{
			TRACE (L"Unable to get cookdown file name. InitializeCookDownFile failed. hr = %08x\n", hr);
			goto exit;
		}

		dwRes = csSafe.Lock();

		if(ERROR_SUCCESS != dwRes)
		{
			TRACE (L"Lock failed with dwError = %08x\n", dwRes);
			hr = HRESULT_FROM_WIN32(dwRes);
			goto exit;
		}

		hr = CMBBaseCooker::UpdateChangeNumber(wszCookDownFile,
											   dwMBChangeNumber,
											   (BYTE*)&FileAttr.ftLastWriteTime,
											   dwLOS);

   		csSafe.Unlock();

		if(FAILED(hr))
		{
			TRACE (L"Writing to the CLB failed. UpdateChangeNumber failed. hr = %08x\n", hr);
			goto exit;
		}
	}

exit:

	if(NULL != wszCookDownFileDir)
	{
		delete [] wszCookDownFileDir;
		wszCookDownFileDir = NULL;
	}
	
	if(NULL != wszCookDownFile)
	{
		delete [] wszCookDownFile;
		wszCookDownFile = NULL;
	}

    return hr;

} // API UninitCookdownInternal


/***************************************************************************++


Routine Description:

    Constructor for the CCooker class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CCooker::CCooker():
m_wszCookDownFileDir(NULL),
m_wszCookDownFile(NULL),
m_hHandle(NULL)
{

} // CCooker::CCooker


/***************************************************************************++

Routine Description:

    Destructor for the CCooker class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CCooker::~CCooker()
{
	if(NULL != m_wszCookDownFile)
	{
		delete [] m_wszCookDownFile;
		m_wszCookDownFile = NULL;
	}
	if(NULL != m_wszCookDownFileDir)
	{
		delete [] m_wszCookDownFileDir;
		m_wszCookDownFileDir = NULL;
	}
	if(NULL != m_hHandle)
	{
		ReleaseWriteLock(m_hHandle);
		m_hHandle = NULL;
	}

} // CCooker::~CCooker


HRESULT CCooker::DeleteObsoleteFiles()
{
	HRESULT			hr = S_OK;
	HANDLE			hFind				= INVALID_HANDLE_VALUE;	// Find handle.
	WIN32_FIND_DATA FileData;									// For each found file.
	WCHAR*			wszFileName			= NULL;
	WCHAR*			wszDeleteFileName	= NULL;

	if ((Wszlstrlen(m_wszCookDownFile) + Wszlstrlen(SEARCH_EXTENSION) + 1) > MAX_PATH)
	{
		wszFileName = new WCHAR[Wszlstrlen(LONG_PATH_SIGNATURE)	+ 
								Wszlstrlen(m_wszCookDownFile)	+ 
								Wszlstrlen(SEARCH_EXTENSION)	+ 1];
		if(NULL == wszFileName)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		Wszlstrcpy(wszFileName, LONG_PATH_SIGNATURE);
		Wszlstrcat(wszFileName, m_wszCookDownFile);
		Wszlstrcat(wszFileName, SEARCH_EXTENSION);

	}
	else
	{
		wszFileName = new WCHAR[Wszlstrlen(m_wszCookDownFile)			+ 
							Wszlstrlen(SEARCH_EXTENSION)	+ 1];
		if(NULL == wszFileName)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		Wszlstrcpy(wszFileName, m_wszCookDownFile);
		Wszlstrcat(wszFileName, SEARCH_EXTENSION);

	}

	hFind = FindFirstFile(wszFileName, 
						  &FileData);

	if (hFind == INVALID_HANDLE_VALUE)
	{
		hr = S_OK;
		goto exit;
	}

	//
	// Loop through every file we can find.
	//

	do
	{
		wszDeleteFileName = new WCHAR[Wszlstrlen(m_wszCookDownFileDir) + 
							Wszlstrlen(FileData.cFileName) + 1];

		if(NULL == wszDeleteFileName)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		Wszlstrcpy(wszDeleteFileName, m_wszCookDownFileDir);
		Wszlstrcat(wszDeleteFileName, FileData.cFileName);

		DeleteFile(wszDeleteFileName);

		delete [] wszDeleteFileName;
		wszDeleteFileName = NULL;

	
	}while (FindNextFile(hFind, &FileData));

exit:

	if(NULL != wszDeleteFileName)
	{
		delete [] wszDeleteFileName;
		wszDeleteFileName = NULL;
	}

	if(NULL != wszFileName)
	{
		delete [] wszFileName;
		wszFileName = NULL;
	}

	if (hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);

	return hr;

} // CCooker::DeleteObsoleteFiles


/***************************************************************************++

Routine Description:

    CookDown process

Arguments:

    [in] Bool - Indicates if we need to delete the CLB file and cookdown a
	            brand new clb file, or if we need to keep the clb file and
				do a full cookdown, but as a delta on the clb file. (like
				in the caase of recovery from inetinfo crash).

Return Value:

    HRESULT.

--***************************************************************************/

HRESULT CCooker::CookDown(BOOL i_bRecoveringFromCrash)
{

	HRESULT                   hr;
	DWORD	                  dwChangeNumber  = 0;
	WIN32_FILE_ATTRIBUTE_DATA FileAttr;
	BOOL	                  bCookable		  = FALSE;

	//
	// TODO: Add a product ID to cookdown. Based on the product ID
	//       initialize the correct CookDown file.
	//

	hr = InitializeCookDownFile(&m_wszCookDownFileDir,
		                        &m_wszCookDownFile);

	if(FAILED(hr))
	{
		TRACE(L"InitializeCookDownFile failed with hr = %08x\n", hr);
		return hr;
	}

	//
	// TODO: Add a product ID to cookdown. Based on the product ID
	//       invoke the correct cookable.
	//

	hr = CMBBaseCooker::Cookable(m_wszCookDownFile,
								 &bCookable,
		                         &FileAttr,
								 &dwChangeNumber);

	if(FAILED(hr)) 
		goto exit;
	else if(!bCookable)
		return hr;

	//
	//	Delete Obsolete files if any.
	//

	if(!i_bRecoveringFromCrash)
	{
		hr = DeleteObsoleteFiles();

		if(FAILED(hr))
			return hr;
	}

	hr = BeginCookDown();

	if(FAILED(hr))
	{
		TRACE(L"BeginCookDown failed with hr = %08x\n", hr);
		return hr;
	}

	//
	// TODO: Add a product ID to cookdown. Based on the product ID
	//       invoke the correct cookdown.
	//

	hr = CookDownFromMetabase(dwChangeNumber,
		                      (BYTE*)&(FileAttr.ftLastWriteTime),
							  i_bRecoveringFromCrash);

	if(FAILED(hr))
	{
		TRACE(L"CookDownFromMetabase failed with hr = %08x\n", hr);
		goto exit;
	}


exit:

	hr = EndCookDown(hr);

	if(FAILED(hr))
	{
		TRACE(L"EndCookDown failed with hr = %08x\n", hr);
	}

	return hr;


} // CCooker::CookDown


/***************************************************************************++

Routine Description:

    CookDown process

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/

HRESULT CCooker::CookDown(WAS_CHANGE_OBJECT* i_aWASChngObj,
						  ULONG				 i_cWASChngObj)
{

	HRESULT hr;
	LONG	iTable;
	CComPtr<IMSAdminBase>			spIMSAdminBase;
	CComPtr<ISimpleTableDispenser2>	spISTDisp;
	METADATA_HANDLE					hMBHandle	   = NULL;
	CMBSiteCooker*					pSiteCooker	   = NULL;
	CMBGlobalCooker*				pGlobalCooker  = NULL;
	WCHAR							wszSiteID[20];

	hr = InitializeCookDownFile(&m_wszCookDownFileDir,
		                        &m_wszCookDownFile);

	if(FAILED(hr))
	{
		TRACE(L"InitializeCookDownFile failed with hr = %08x\n", hr);
		return hr;
	}

	hr = BeginCookDown();

	if(FAILED(hr))
	{
		TRACE(L"BeginCookDown failed with hr = %08x\n", hr);
		return hr;
	}

	hr = InitializeAdminBaseObjectAndDispenser(&spIMSAdminBase,
										       &hMBHandle,
										       &spISTDisp);

	if(FAILED(hr))
		goto exit;

	// Handle changes is this order: APPPOOLS, SITES, APPS.
	for(iTable=wttAPPPOOL; iTable<=wttGLOBALW3SVC; iTable++)
	{
		switch(iTable)
		{
		case wttAPPPOOL:
			hr = IncrementalCookDownAppPools(i_aWASChngObj,
				                             i_cWASChngObj,
                                             spIMSAdminBase,
                                             hMBHandle,
                                             spISTDisp);
			break;
		case wttSITE:
			hr = IncrementalCookDownSites(i_aWASChngObj,
			                              i_cWASChngObj,
                                          spIMSAdminBase,
                                          hMBHandle,
                                          spISTDisp);
			break;
		case wttAPP:
			hr = IncrementalCookDownApps(i_aWASChngObj,
				                         i_cWASChngObj,
                                         spIMSAdminBase,
                                         hMBHandle,
                                         spISTDisp);
			break;
		case wttGLOBALW3SVC:
			hr = IncrementalCookDownGlobalW3SVC(i_aWASChngObj,
				                                i_cWASChngObj,
                                                spIMSAdminBase,
                                                hMBHandle,
                                                spISTDisp);
			break;
		default:
			break;
		}

		if(FAILED(hr))
		{
			goto exit;
		}

	}
	
exit:

	hr = EndCookDown(hr);

	if(FAILED(hr))
	{
		TRACE(L"EndCookDown failed with hr = %08x\n", hr);
	}

	if(NULL != hMBHandle)
	{
		spIMSAdminBase->CloseKey(hMBHandle);
		hMBHandle = NULL;
	}


	return hr;


} // CCooker::CookDown (Incremental)

/***************************************************************************++

Routine Description:

    IncrementalCookDownGlobalW3SVC process

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::IncrementalCookDownGlobalW3SVC(WAS_CHANGE_OBJECT*        i_aWASChngObj,
                                                ULONG				      i_cWASChngObj,
                                                IMSAdminBase*			  i_pIMSAdminBase,
                                                METADATA_HANDLE		  i_hMBHandle,
                                                ISimpleTableDispenser2*   i_pISTDisp)
{
	HRESULT              hr             = S_OK;
	ULONG	             i              = 0;
	CMBGlobalCooker*	 pGlobalCooker  = NULL;

	pGlobalCooker = new CMBGlobalCooker();
	if(NULL == pGlobalCooker)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	//
	// Initialize the Cooker
	//

	hr = pGlobalCooker->BeginCookDown(i_pIMSAdminBase,
									  i_hMBHandle,
									  i_pISTDisp,
									  m_wszCookDownFile);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		goto exit;
	}

	for(i=0; i<i_cWASChngObj; i++)
	{
		if (!(i_aWASChngObj[i].dwWASTableType & TABLEMASK(wttGLOBALW3SVC)))
		{
			continue;
		}

		//
		// WARNING: The type values are not enums, but bit flags. So we might be better of changing to an if stmt.
		//

		switch(i_aWASChngObj[i].dwMDChangeType)
		{
		case MD_CHANGE_TYPE_ADD_OBJECT:
		case MD_CHANGE_TYPE_SET_DATA:
		case MD_CHANGE_TYPE_ADD_OBJECT|MD_CHANGE_TYPE_SET_DATA:
		case MD_CHANGE_TYPE_DELETE_DATA:

			hr = pGlobalCooker->CookDown(&(i_aWASChngObj[i]));
			break;

		case MD_CHANGE_TYPE_DELETE_OBJECT:

			//
			// TODO: Delete globals.
			//

			hr = pGlobalCooker->CookDown(&(i_aWASChngObj[i]));
			break;

		default:

			//
			// Note: Rename is not supported
			//

			break;
		} 

	} // End for all global changes

	if(FAILED(hr))
		goto exit;

	// 
	// End CookDown on Cooker.
	//

	hr = pGlobalCooker->EndCookDown();

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		goto exit;
	}

		
exit:

	if(NULL != pGlobalCooker)
	{
		delete pGlobalCooker;
		pGlobalCooker = NULL;
	}

	return hr;

} // CCooker::IncrementalCookDownGlobalW3SVC


/***************************************************************************++

Routine Description:

    IncrementalCookDownApps process

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::IncrementalCookDownApps(WAS_CHANGE_OBJECT*        i_aWASChngObj,
                                         ULONG				       i_cWASChngObj,
                                         IMSAdminBase*			   i_pIMSAdminBase,
                                         METADATA_HANDLE		   i_hMBHandle,
                                         ISimpleTableDispenser2*   i_pISTDisp)
{
	HRESULT              hr             = S_OK;
	ULONG	             i              = 0;
	CMBSiteCooker*	     pSiteCooker    = NULL;
	WCHAR				 wszSiteID[20];
	DWORD                VirtualSiteId  = 0;

	for(i=0; i<i_cWASChngObj; i++)
	{
		if (!(i_aWASChngObj[i].dwWASTableType & TABLEMASK(wttAPP)))
		{
			continue;
		}

		//
		// Create and initialize the Cooker.
		//
		// Note that this is done within the for loop because we want to invoke
		// EndCookDown (UpdateStore) on every change. The reason is for certain 
		// properties Eg. ServerCommand we need to track inserts and updates. 
		// If we have just one UpdateStore then, if we have an insert of a site 
		// followed by update (in the same list), the user will see it as only 
		// an insert.
		//

		pSiteCooker = new CMBSiteCooker();
		if(NULL == pSiteCooker)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		hr = pSiteCooker->BeginCookDown(i_pIMSAdminBase,
										i_hMBHandle,
										i_pISTDisp,
										m_wszCookDownFile);

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			goto exit;
		}

		//
		// Perform the cookdown
		//

		if((i_aWASChngObj[i].wszPath == NULL) || (0 == *(i_aWASChngObj[i].wszPath)))
		{
			//
			// Path equals NULL means that an property changed at a location 
			// which could not be associated with a specific app. Hence it 
			// may be inherited by some or all apps. Hence cook all apps
			//

			hr = pSiteCooker->CookDown(&(i_aWASChngObj[i]));

			if(FAILED(hr))
				goto exit;

		}
		else
		{
			//
			// WARNING: The type values are not enums, but bit flags. So we might be better of changing to an if stmt.
			//

			switch(i_aWASChngObj[i].dwMDChangeType)
			{
			case MD_CHANGE_TYPE_ADD_OBJECT:
			case MD_CHANGE_TYPE_SET_DATA:
			case MD_CHANGE_TYPE_ADD_OBJECT|MD_CHANGE_TYPE_SET_DATA:
			case MD_CHANGE_TYPE_DELETE_DATA:
				//
				// We cook the site when an app changes, because should 
				// the app (eg root app) get invalidated, the site should
				// also get invalidated.
				//

				_ltow(i_aWASChngObj[i].iVirtualSiteID, wszSiteID, 10);
				hr = pSiteCooker->CookDownSite(wszSiteID,
											   &(i_aWASChngObj[i]),
											   i_aWASChngObj[i].iVirtualSiteID);	

	 		    //hr = pSiteCooker->GetAppCooker()->CookDownApplication(i_aWASChngObj[i].wszPath, 
				//													  i_aWASChngObj[i].wszSiteRootPath,
				//													  i_aWASChngObj[i].iVirtualSiteID,
	          	//													  &bIsRootApp); 
				break;

			case MD_CHANGE_TYPE_DELETE_OBJECT:
				//
				// We cook the site when an app is deleted, because should 
				// the app (eg root app) get deleted, the site should
				// also get invalidated.
				//

				hr = pSiteCooker->GetAppCooker()->DeleteApplication(i_aWASChngObj[i].wszPath, 
																	i_aWASChngObj[i].wszSiteRootPath,
																	i_aWASChngObj[i].iVirtualSiteID,
																	TRUE); 

				_ltow(i_aWASChngObj[i].iVirtualSiteID, wszSiteID, 10);

				hr = pSiteCooker->CookDownSite(wszSiteID,
					                           &(i_aWASChngObj[i]),
											   i_aWASChngObj[i].iVirtualSiteID);	
				break;
			default:
				//
				// Note: Rename is not supported
				//
				break;
			} 

		} // End if not inherited prop

		// 
		// End CookDown on Cooker.
		//

		hr = pSiteCooker->EndCookDown();

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			goto exit;
		}

		delete pSiteCooker;
		pSiteCooker = NULL;

	} // End for all site changes
		
exit:

	if(NULL != pSiteCooker)
	{
		delete pSiteCooker;
		pSiteCooker = NULL;
	}

	return hr;

} // CCooker::IncrementalCookDownApps


/***************************************************************************++

Routine Description:

    IncrementalCookDownSites process

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::IncrementalCookDownSites(WAS_CHANGE_OBJECT*        i_aWASChngObj,
                                          ULONG				        i_cWASChngObj,
                                          IMSAdminBase*			    i_pIMSAdminBase,
                                          METADATA_HANDLE		    i_hMBHandle,
                                          ISimpleTableDispenser2*   i_pISTDisp)
{
	HRESULT              hr             = S_OK;
	ULONG	             i              = 0;
	CMBSiteCooker*	     pSiteCooker = NULL;

	for(i=0; i<i_cWASChngObj; i++)
	{
		if (!(i_aWASChngObj[i].dwWASTableType & TABLEMASK(wttSITE)))
		{
			continue;
		}

		//
		// Create and initialize the Cooker.
		//
		// Note that this is done within the for loop because we want to invoke
		// EndCookDown (UpdateStore) on every change. The reason is for certain 
		// properties Eg. ServerCommand we need to track inserts and updates. 
		// If we have just one UpdateStore then, if we have an insert of a site 
		// followed by update (in the same list), the user will see it as only 
		// an insert.
		//

		pSiteCooker = new CMBSiteCooker();
		if(NULL == pSiteCooker)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		hr = pSiteCooker->BeginCookDown(i_pIMSAdminBase,
										i_hMBHandle,
										i_pISTDisp,
										m_wszCookDownFile);

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			goto exit;
		}

		//
		// Perform the cookdown
		//

		if((i_aWASChngObj[i].wszPath == NULL) || (0 == *(i_aWASChngObj[i].wszPath)))
		{
			//
			// Path equals NULL means that an property changed at a location 
			// which could not be associated with a specific site. Hence it 
			// may be inherited by some or all sites. Hence cook all sites
			//

			hr = pSiteCooker->CookDown(&(i_aWASChngObj[i]));

			if(FAILED(hr))
				goto exit;

		}
		else
		{
			//
			// WARNING: The type values are not enums, but bit flags. So we might be better of changing to an if stmt.
			//

			switch(i_aWASChngObj[i].dwMDChangeType)
			{
			case MD_CHANGE_TYPE_ADD_OBJECT:
			case MD_CHANGE_TYPE_SET_DATA:
			case MD_CHANGE_TYPE_ADD_OBJECT|MD_CHANGE_TYPE_SET_DATA:
			case MD_CHANGE_TYPE_DELETE_DATA:
				hr = pSiteCooker->CookDownSite(i_aWASChngObj[i].wszPath,
											   &(i_aWASChngObj[i]),
											   i_aWASChngObj[i].iVirtualSiteID);	
				break;

			case MD_CHANGE_TYPE_DELETE_OBJECT:
				hr = pSiteCooker->DeleteSite(i_aWASChngObj[i].wszPath,
											 i_aWASChngObj[i].iVirtualSiteID);
				break;
			default:
				//
				// Note: Rename is not supported
				//
				break;
			} 

		}  // End if not inherited prop

		// 
		// End CookDown on Cooker.
		//

		hr = pSiteCooker->EndCookDown();

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			goto exit;
		}

		delete pSiteCooker;
		pSiteCooker = NULL;

	} // End for all site changes
		
exit:

	if(NULL != pSiteCooker)
	{
		delete pSiteCooker;
		pSiteCooker = NULL;
	}

	return hr;

} // CCooker::IncrementalCookDownSites


/***************************************************************************++

Routine Description:

    IncrementalCookDownAppPools process

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::IncrementalCookDownAppPools(WAS_CHANGE_OBJECT*        i_aWASChngObj,
                                             ULONG				      i_cWASChngObj,
                                             IMSAdminBase*			  i_pIMSAdminBase,
                                             METADATA_HANDLE		  i_hMBHandle,
                                             ISimpleTableDispenser2*   i_pISTDisp)
{
	HRESULT              hr                   = S_OK;
	ULONG	             i                    = 0;
	BOOL                 bInsertedNewAppPools = FALSE;
	CMBAppPoolCooker*	 pAppPoolCooker       = NULL;
	CMBSiteCooker*	     pSiteCooker          = NULL;
	Array<ULONG>         aDependentVirtualSites;

	for(i=0; i<i_cWASChngObj; i++)
	{
		if (!(i_aWASChngObj[i].dwWASTableType & TABLEMASK(wttAPPPOOL)))
		{
			continue;
		}

		//
		// Create and initialize the Cooker.
		//
		// Note that this is done within the for loop because we want to invoke
		// EndCookDown (UpdateStore) on every change. The reason is for certain 
		// properties Eg. ApppoolCommand we need to track inserts and updates. 
		// If we have just one UpdateStore then, if we have an insert of a site 
		// followed by update (in the same list), the user will see it as only 
		// an insert.
		//

		pAppPoolCooker = new CMBAppPoolCooker();
		if(NULL == pAppPoolCooker)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		hr = pAppPoolCooker->BeginCookDown(i_pIMSAdminBase,
										   i_hMBHandle,
										   i_pISTDisp,
										   m_wszCookDownFile);

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			goto exit;
		}

		//
		// Perform the cookdown
		//

		if((i_aWASChngObj[i].wszPath == NULL) || (0 == *(i_aWASChngObj[i].wszPath)))
		{
			//
			// Path equals NULL means that an property changed at a location 
			// which could not be associated with a specific apppool. Hence it 
			// may be inherited by some or all apppool. Hence cook all apppool
			//

			hr = pAppPoolCooker->CookDown(&(i_aWASChngObj[i]),
				                          &bInsertedNewAppPools,
										  &aDependentVirtualSites);

			if(FAILED(hr))
				goto exit;
		}
		else
		{
			//
			// WARNING: The type values are not enums, but bit flags. So we might be better of changing to an if stmt.
			//

			switch(i_aWASChngObj[i].dwMDChangeType)
			{
			case MD_CHANGE_TYPE_ADD_OBJECT:
			case MD_CHANGE_TYPE_SET_DATA:
			case MD_CHANGE_TYPE_ADD_OBJECT|MD_CHANGE_TYPE_SET_DATA:
			case MD_CHANGE_TYPE_DELETE_DATA:

				hr = pAppPoolCooker->CookDownAppPool(i_aWASChngObj[i].wszPath,
					                                 &(i_aWASChngObj[i]),
					                                 &bInsertedNewAppPools,
													 &aDependentVirtualSites);	
				break;

			case MD_CHANGE_TYPE_DELETE_OBJECT:

				hr = pAppPoolCooker->DeleteAppPool(i_aWASChngObj[i].wszPath,
					                               &aDependentVirtualSites);
				break;
			default:
				//
				// Note: Rename is not supported
				//
				break;
			} 
		}// End if not inherited prop

		// 
		// End CookDown on Cooker.
		//

		hr = pAppPoolCooker->EndCookDown();

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			goto exit;
		}

		delete pAppPoolCooker;
		pAppPoolCooker = NULL;

	} // End for all apppool changes


	if(bInsertedNewAppPools)
	{
		//
		// If there were apps that were invalidated because apppool was invalid,
		// then if there are new apppools added, perhaps the apppool was 
		// validated, hence we cook all the sites down so that the apps get 
		// validated.
		//

		pSiteCooker = new CMBSiteCooker();
		if(NULL == pSiteCooker)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		hr = pSiteCooker->BeginCookDown(i_pIMSAdminBase,
									    i_hMBHandle,
										i_pISTDisp,
										m_wszCookDownFile);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = pSiteCooker->CookDown(NULL);

		if(FAILED(hr))
		{
			goto exit;
		}

		hr = pSiteCooker->EndCookDown();

		if(FAILED(hr))
		{
			goto exit;
		}
	}
	else
	{
		hr = CMBSiteCooker::CookdownSiteFromList(&aDependentVirtualSites,
						                         NULL,
										         i_pIMSAdminBase,
							                     i_hMBHandle,
							                     i_pISTDisp,
							                     m_wszCookDownFile);

		if(FAILED(hr))
		{
			goto exit;
		}
	}
	
exit:

	if(NULL != pAppPoolCooker)
	{
		delete pAppPoolCooker;
		pAppPoolCooker = NULL;
	}

	if(NULL != pSiteCooker)
	{
		delete pSiteCooker;
		pSiteCooker = NULL;
	}

	return hr;

} // IncrementalCookDownAppPools


/***************************************************************************++

Routine Description:

    Begin CookDown process - 
	1. Initialize CookDown FileName
	2. GetWriteLock to serialize CookDown
	3. Create the metabase object and open the key.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::BeginCookDown()
{
	HRESULT     hr;
	BOOL        bSuccess   = FALSE;

	// 
	// Write lock this file. This is an API call into CLB code.
	//

	hr = GetWriteLock(wszDATABASE_IIS, 
					  m_wszCookDownFile, 
					  &m_hHandle);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		return hr;
	}

	//
    // TODO: Add an ASSERT that the m_hHandle is non NULL.
	//

	return hr;

} // CCooker::BeginCookDown



/***************************************************************************++

Routine Description:

    InitializeCookDownFile - 
	1. Initialize CookDown FileName

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::InitializeCookDownFile(LPWSTR* o_wszCookDownFileDir,
										LPWSTR* o_wszCookDownFile)
{

	HRESULT	hr = S_OK;	
	//
	// Get full path of Cookdown file i.e. persisted cache
	//

	//
    // Get the path in which this file resides.
	//

	hr = GetMachineConfigDirectory(o_wszCookDownFileDir);

	if(FAILED(hr) || (NULL == (*o_wszCookDownFileDir)) || ((*o_wszCookDownFileDir)[0] == 0))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		return hr;
	}

	//
    // Construct the full file name by appending the filename to the path 
    // obtained above.
	//

	*o_wszCookDownFile = new WCHAR [Wszlstrlen((*o_wszCookDownFileDir)) + Wszlstrlen(g_wszCookDownFile) + 1];
	if(NULL == (*o_wszCookDownFile)) {return E_OUTOFMEMORY;}
	Wszlstrcpy((*o_wszCookDownFile), (*o_wszCookDownFileDir));		
	Wszlstrcat((*o_wszCookDownFile) ,g_wszCookDownFile);

	return hr;

} // CCooker::InitializeCookDownFile


/***************************************************************************++

Routine Description:

    CookDownFromMetabase - 
	1. Invokes appropriate objects to cookdown from metabase

    This method assumes that if the i_bRecoveringFromCrash is FALSE, then
    a Full Cookdown is taking place.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::CookDownFromMetabase(DWORD	i_dwChangeNumber,
									  BYTE* i_pbTimeStamp,
									  BOOL i_bRecoveringFromCrash)
{
	HRESULT hr;
	CComPtr<IMSAdminBase>			spIMSAdminBase;
	CComPtr<ISimpleTableDispenser2>	spISTDisp;
	METADATA_HANDLE					hMBHandle	   = NULL;
	CMBAppPoolCooker*				pAppPoolCooker = NULL;
	CMBSiteCooker*					pSiteCooker	   = NULL;
	CMBGlobalCooker*				pGlobalCooker  = NULL;
	BOOL							bCookable      = TRUE;
	DWORD                           dwLOS          = fST_LOS_READWRITE | fST_LOS_COOKDOWN;

	//
	// If its cookable, then always do a full cookdown, since this will be
	// invoked only at startup time. Changes to metabase while running will
	// be applied through change notifications. Hence delete previous CLBs
	//

	hr = InitializeCookDownFromMetabase(&spIMSAdminBase,
										&spISTDisp,
										&hMBHandle,
										&pAppPoolCooker,
										&pSiteCooker,
										&pGlobalCooker);

	if(FAILED(hr))
		goto exit;

	//
	// Invoke Cookdown on Cookers.
	//

	hr = pGlobalCooker->CookDown(NULL);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		goto exit;
	}

	hr = pGlobalCooker->EndCookDown();

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		goto exit;
	}

	hr = pAppPoolCooker->CookDown();

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		goto exit;
	}

	hr = pAppPoolCooker->EndCookDown();

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		goto exit;
	}

	hr = pSiteCooker->CookDown(NULL);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		goto exit;
	}

	// 
	// End CookDown on Cookers.
	//

	hr = pSiteCooker->EndCookDown();

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		goto exit;
	}

	hr = CMBBaseCooker::UpdateChangeNumber(m_wszCookDownFile,
										   i_dwChangeNumber,
										   i_pbTimeStamp,
										   dwLOS);

	if(FAILED(hr))
		goto exit;

	if(FALSE == i_bRecoveringFromCrash)
	{
		//
		// Start listening to the metabase before releasing the lock on the metabase.
		//

		CComPtr<ISimpleTableEventMgr>   spEventMgr;

		hr = spISTDisp->QueryInterface(IID_ISimpleTableEventMgr,
			                          (LPVOID*)&spEventMgr);

		if(FAILED(hr))
			goto exit;

		hr = spEventMgr->InitMetabaseListener();

		if(FAILED(hr))
			goto exit;

	}
	else 
	{
		//
		// Call rehook change notifications on the event manager, before
		// releasing the lock on the metabase.
		//

		CComPtr<ISimpleTableEventMgr>   spEventMgr;

		hr = spISTDisp->QueryInterface(IID_ISimpleTableEventMgr,
			                          (LPVOID*)&spEventMgr);

		if(FAILED(hr))
			goto exit;

		hr = spEventMgr->RehookNotifications();

		if(FAILED(hr))
			goto exit;

	}

exit:

	if(NULL != pAppPoolCooker)
	{
		delete pAppPoolCooker;
		pAppPoolCooker = NULL;
	}
	if(NULL != pSiteCooker)
	{
		delete pSiteCooker;
		pSiteCooker = NULL;
	}
	if(NULL != pGlobalCooker)
	{
		delete pGlobalCooker;
		pGlobalCooker = NULL;
	}
	if(NULL != hMBHandle)
	{
		spIMSAdminBase->CloseKey(hMBHandle);
		hMBHandle = NULL;
	}

	return hr;

} // CCooker::CookDownFromMetabase


/***************************************************************************++

Routine Description:

    InitializeCookDownFromMetabase - 
	1. Create the metabase object and open the metabase to the key containing 
	   configuration for the web service on the local machine.
	2. Create and initialize AppPool and Site Cooker.
	
Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::InitializeCookDownFromMetabase(IMSAdminBase**				o_pIMSAdminBase,
												ISimpleTableDispenser2**	o_pISTDisp,
												METADATA_HANDLE*			o_phMBHandle,
												CMBAppPoolCooker**			o_pAppPoolCooker,
												CMBSiteCooker**				o_pSiteCooker,
												CMBGlobalCooker**			o_pGlobalCooker)
{

	HRESULT hr;

	// 
	// Create the metabase object and open the metabase to the key containing 
	// configuration for the web service on the local machine.
	//

	hr = InitializeAdminBaseObjectAndDispenser(o_pIMSAdminBase,
		                                       o_phMBHandle,
								               o_pISTDisp);

	if(FAILED(hr))
	{
		return hr;
	}

	// 
	// Create the various cookers.
	//

	*o_pAppPoolCooker = new CMBAppPoolCooker();
	if(NULL == *o_pAppPoolCooker)
		return E_OUTOFMEMORY;

	*o_pSiteCooker = new CMBSiteCooker();
	if(NULL == *o_pSiteCooker)
		return E_OUTOFMEMORY;

	*o_pGlobalCooker = new CMBGlobalCooker();
	if(NULL == *o_pGlobalCooker)
		return E_OUTOFMEMORY;


	//
	// Initialize the Cookers
	//

	hr = (*o_pAppPoolCooker)->BeginCookDown(*o_pIMSAdminBase,
										    *o_phMBHandle,
											*o_pISTDisp,
											m_wszCookDownFile);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		return hr;
	}

	hr = (*o_pSiteCooker)->BeginCookDown(*o_pIMSAdminBase,
										 *o_phMBHandle,
										 *o_pISTDisp,
										 m_wszCookDownFile);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		return hr;
	}

	hr = (*o_pGlobalCooker)->BeginCookDown(*o_pIMSAdminBase,
										   *o_phMBHandle,
										   *o_pISTDisp,
										   m_wszCookDownFile);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		return hr;
	}

	return hr;

} // CCooker::InitializeCookDownFromMetabase


/***************************************************************************++

Routine Description:

    InitializeAdminBaseObjectAndDispenser - 
	1. Create the metabase object and open the metabase to the key containing 
	   configuration for the web service on the local machine.
	2. Create the dispenser
	
Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::InitializeAdminBaseObjectAndDispenser(IMSAdminBase**			o_pIMSAdminBase,
													   METADATA_HANDLE*			o_phMBHandle,
													   ISimpleTableDispenser2**	o_pISTDisp)
{
	HRESULT hr;
	ULONG   cRetry = 0;

	//
    // Create the base admin object.
	//

    hr = CoCreateInstance(CLSID_MSAdminBase,           // CLSID
                          NULL,                        // controlling unknown
                          CLSCTX_SERVER,               // desired context
                          IID_IMSAdminBase,            // IID
                          (void**)o_pIMSAdminBase);    // returned interface

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		return hr;
	}

	//
	// Open the metabase key. By opening the W3SVC key for read, we are read 
	// locking the metabase. If you get a path busy error retry a few times
	// before giving up.
	//

	do
	{
		hr = (*o_pIMSAdminBase)->OpenKey(METADATA_MASTER_ROOT_HANDLE ,
										 IIS_MD_W3SVC,
										 METADATA_PERMISSION_READ, 
										 MB_TIMEOUT,
										 o_phMBHandle );

		if(HRESULT_FROM_WIN32(ERROR_PATH_BUSY) == hr)
		{
			cRetry++;
			Sleep(CMS_SLEEP_BEFORE_RETRY);
		}

	} while((HRESULT_FROM_WIN32(ERROR_PATH_BUSY) == hr) && (cRetry < CMAX_RETRY));

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		return hr;
	}  
	
	//
	// Initialize the dispenser
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, o_pISTDisp);
	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		return hr;
	}

	return hr;

} // CCooker::InitializeAdminBaseObjectAndDispenser

/***************************************************************************++

Routine Description:

    Commit CookDown process - Commit or Abort CookDown and release all locks.

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CCooker::EndCookDown(HRESULT	i_hr)
{
	HRESULT	hr	= i_hr;

	if( SUCCEEDED(hr)) 

		//
		//&&
		//((0 < m_cCookedDownVirtualSites) || (0 < m_cCookedDownAppPools) || (0 < m_cCookedDownApps) || (0 < m_cDeletedApps)))
		//

	{
		
		hr = CLBCommitWrite(wszDATABASE_IIS, m_wszCookDownFile);

		if(FAILED(hr))
		{
	        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			goto exit;
		}
	}
	else
	{
		hr = CLBAbortWrite(wszDATABASE_IIS, m_wszCookDownFile);

		if(FAILED(hr))
		{
	        LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			goto exit;
		}

	}

exit:

	//
	// Note we MUST always release the lock.	
	//

	if(NULL != m_hHandle)
	{
		hr = ReleaseWriteLock(m_hHandle);
		m_hHandle = NULL;
	}

	if(SUCCEEDED(i_hr))
		return hr;
	else if(FAILED(hr))
		return hr;
	else
		return i_hr;

} // CCooker::EndCookDown


HRESULT CCooker::GetMachineConfigDirectory(LPWSTR* i_pwszPathDir)
{
	UINT iRes = ::GetMachineConfigDirectory(WSZ_PRODUCT_IIS, NULL, 0);

	if(!iRes)
		return HRESULT_FROM_WIN32(GetLastError());

	*i_pwszPathDir = NULL;
	*i_pwszPathDir = new WCHAR[iRes+2];
	if(NULL == *i_pwszPathDir)
		return E_OUTOFMEMORY;

	iRes = ::GetMachineConfigDirectory(WSZ_PRODUCT_IIS, *i_pwszPathDir, iRes);

	if(!iRes)
		return HRESULT_FROM_WIN32(GetLastError());

	if((*i_pwszPathDir)[lstrlen(*i_pwszPathDir)-1] != L'\\')
	{
		Wszlstrcat(*i_pwszPathDir, SLASH);
	}

	WszCharUpper(*i_pwszPathDir);

	return S_OK;

} // CCooker::GetMachineConfigDirectory
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbapppoolcooker.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "Catmeta.h"
#include "catalog.h"
#include "catmacros.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "MBBaseCooker.h"
#include "MBGlobalCooker.h"
#include "MBAppPoolCooker.h"
#include "MBAppCooker.h"
#include "MBSiteCooker.h"
#include "undefs.h"
#include "SvcMsg.h"
#include "limits.h"
#include "array_t.h"

#define IIS_MD_APPPOOLS					L"/AppPools"

#define MIN_APP_POOL					1
#define MAX_APP_POOL					256

// ULONG compare for the binary search on the ulong array.
BOOL ULONGCompare(ULONG* ul1, void* ul2)
{
	ASSERT(ul1 && ul2);
	return (*ul1 <= *(ULONG*)ul2);

}

CMBAppPoolCooker::CMBAppPoolCooker():
CMBBaseCooker()
{

} // CMBAppPoolCooker::CMBAppPoolCooker


CMBAppPoolCooker::~CMBAppPoolCooker()
{

} // CMBAppPoolCooker::~CMBAppPoolCooker


HRESULT CMBAppPoolCooker::BeginCookDown(IMSAdminBase*			i_pIMSAdminBase,
										METADATA_HANDLE			i_MBHandle,
										ISimpleTableDispenser2*	i_pISTDisp,
										LPCWSTR					i_wszCookDownFile)
{
	HRESULT hr;

	//
	// Initialize CLB table name.
	//

	m_wszTable = wszTABLE_APPPOOLS;

	//
	// Invoke the base class BeginCookDown to initialize all the structures.
	// Note the base class BeginCookDown must always be invoked after 
	// initializing m_wszTable
	//

	hr = CMBBaseCooker::BeginCookDown(i_pIMSAdminBase,
									  i_MBHandle,
									  i_pISTDisp,
									  i_wszCookDownFile);
	return hr;

} // CMBAppPoolCooker::BeginCookDown


HRESULT CMBAppPoolCooker::CookDown(WAS_CHANGE_OBJECT* i_pWASChngObj,
								   BOOL*              o_bNewRowAdded,
								   Array<ULONG>*      i_paDependentVirtualSites)
{
    WCHAR         wszAppPoolID[METADATA_MAX_NAME_LEN];
    DWORD         dwEnumIndex		        = 0;
    DWORD         dwValidAppPoolCount       = 0;    
    HRESULT       hr					    = S_OK;
	Array<ULONG>  aDependenVirtualSites;
	Array<ULONG>* paDependenVirtualSites    = NULL;

	//
	// Initialize paDependenVirtualSites
	//

	if(NULL == i_paDependentVirtualSites)
	{
		paDependenVirtualSites = &aDependenVirtualSites;
	}
	else
	{
		paDependenVirtualSites = i_paDependentVirtualSites;
	}

	//
	// Enumerate all keys under IIS_MD_APPPOOLS below IIS_MD_W3SVC.
	//

	for(dwEnumIndex=0; SUCCEEDED(hr); dwEnumIndex++)
	{
		hr = m_pIMSAdminBase->EnumKeys(m_hMBHandle,
									   IIS_MD_APPPOOLS,
									   wszAppPoolID,
									   dwEnumIndex);
		if(SUCCEEDED(hr))
		{
			hr = CookDownAppPool(wszAppPoolID,
				                 i_pWASChngObj,
				                 o_bNewRowAdded,
								 paDependenVirtualSites); 

			if (FAILED(hr ))
			{
        
				//
				// There is no need to log error messages here as 
				// it will be done in CookDownAppPool
				//
				hr = S_OK; 
			}
			else          
				dwValidAppPoolCount++;

		}
	}  

	//
	// Make sure we ran out of items, as opposed to a real error, such
	// as the IIS_MD_APPPOOLS key being missing entirely.
	//

    if (FAILED(hr))	
    {
		if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
			hr = S_OK;
		else
		{
			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_POOLS, NULL));
		}
    }

    if (dwValidAppPoolCount == 0)
    {
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_NO_VALID_APPLICATION_APPPOOLS, NULL));

		//
		// Delete all apppools that may be present.
		//

		hr = DeleteAllAppPools(paDependenVirtualSites);
    }
	else if (SUCCEEDED(hr))
	{
		hr = DeleteObsoleteAppPools(paDependenVirtualSites);

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_APPPOOL_INTERNAL_ERROR, NULL));
		}
	}

	if(NULL == i_paDependentVirtualSites)
	{
		//
		// This means that we can cook down the dependent sites internally
		//

		hr = CMBSiteCooker::CookdownSiteFromList(paDependenVirtualSites,
								                 m_pISTCLB,
												 m_pIMSAdminBase,
									             m_hMBHandle,
									             m_pISTDisp,
									             m_wszCookDownFile);

		if(FAILED(hr))
		{
			return hr;
		}

	} // Else hand it out so that the caller can cookdown


    return hr;

} // CMBAppPoolCooker::CookDown

HRESULT CMBAppPoolCooker::EndCookDown()
{
	HRESULT hr = S_OK;

	hr = m_pISTCLB->UpdateStore();

	if(FAILED(hr))
	{
		hr = GetDetailedErrors(hr);
	}

	return hr;

} // CMBAppPoolCooker::EndCookDown

HRESULT CMBAppPoolCooker::CookDownAppPool(WCHAR*	         i_wszAppPool,
										  WAS_CHANGE_OBJECT* i_pWASChngObj,
										  BOOL*              o_bNewRowAdded,
										  Array<ULONG>*      i_paDependentVirtualSites)
{
    HRESULT	hr	= S_OK;
	ULONG	i	= 0;
	WCHAR	wszAppPoolPath[ ( sizeof( IIS_MD_APPPOOLS ) / sizeof ( WCHAR ) ) + 1 + METADATA_MAX_NAME_LEN + 1 ];
    _snwprintf( wszAppPoolPath, sizeof( wszAppPoolPath ) / sizeof ( WCHAR ), L"%s/%s", IIS_MD_APPPOOLS, i_wszAppPool );

	//
	// Read AppPool config that is not from MB properties.
	// Eg. From MB location etc.
	//

	if(m_acb[iAPPPOOLS_AppPoolID] < (Wszlstrlen(i_wszAppPool)+1)*sizeof(WCHAR))
	{
		if(NULL != m_apv[iAPPPOOLS_AppPoolID])
		{
			delete [] m_apv[iAPPPOOLS_AppPoolID];
			m_apv[iAPPPOOLS_AppPoolID] = NULL;
			m_acb[iAPPPOOLS_AppPoolID] = 0;
			m_apv[iAPPPOOLS_AppPoolID] = new WCHAR[Wszlstrlen(i_wszAppPool)+1];
			if(NULL == m_apv[iAPPPOOLS_AppPoolID])
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			m_acb[iAPPPOOLS_AppPoolID] = ((int)Wszlstrlen((LPCWSTR)i_wszAppPool)+1)*sizeof(WCHAR);
		}
	}
	Wszlstrcpy((LPWSTR)m_apv[iAPPPOOLS_AppPoolID], (LPCWSTR)i_wszAppPool);

	//
	// Read AppPool config from MB properties
	//

	hr = GetData(wszAppPoolPath);

	if(FAILED(hr))
	{
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_POOL_PROPERTIES, wszAppPoolPath));
		goto exit;
	}

	//
	// Validate AppPool.
	//

	hr = ValidateAppPool();

	if(FAILED(hr))
		goto exit;	  //
					  // There is no need to log error messages here as 
					  // it will be done in ValidateAppPool
					  //

	//
	// Copy all AppPool rows.
	//

	hr = CopyRows(&(m_apv[iAPPPOOLS_AppPoolID]),
                  i_pWASChngObj,		      
		          o_bNewRowAdded);

	if(FAILED(hr))
	{
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_APPPOOL_INTERNAL_ERROR, (LPWSTR)m_apv[iAPPPOOLS_AppPoolID]));
		goto exit;
	}

exit:

	if(FAILED(hr))
	{
		DeleteAppPool(i_wszAppPool,
			          i_paDependentVirtualSites);
	}

	return hr;

} // CMBAppPoolCooker::CookDownAppPool


HRESULT CMBAppPoolCooker::DeleteAllAppPools(Array<ULONG>*  i_paDependentVirtualSites)
{
	HRESULT hr           = S_OK;

	//
	// Go through the read cache and delete all apppools.
	//

	for(ULONG i=0; ;i++)
	{
		hr = DeleteAppPoolAt(i,
			                 i_paDependentVirtualSites);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
		{
			return hr;
		}
	}

	return hr;

} // CMBAppPoolCooker::DeleteAllAppPools


HRESULT CMBAppPoolCooker::DeleteAppPool(WCHAR*	       i_wszAppPoolID,
										Array<ULONG>*  i_paDependentVirtualSites)
{
	CComPtr<ISimpleTableWrite2> spISTApps;
	ULONG		                iColumn             = iAPPS_SiteID;
	ULONG		                iApp;
	ULONG		                iSite;
	ULONG*		                pulVSite;
	HRESULT		                hr		            = S_OK;


	//
	// Query to update all the Apps in this AppPool.
	//
	STQueryCell	qcell[] = {{(LPVOID)i_wszAppPoolID, 
		                     eST_OP_EQUAL, 
							 iAPPS_AppPoolId, 
							 DBTYPE_WSTR, 0
	}};
	ULONG		ccells  = sizeof(qcell)/sizeof(qcell[0]);

	//
	// Delete the AppPool from the CLB.
	//

	hr = DeleteRow((LPVOID*)&i_wszAppPoolID);

	if(FAILED(hr))
	{
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_APPPOOL_INTERNAL_ERROR, i_wszAppPoolID));
		goto exit;
	}

	//
	// Update all Apps with the default AppPool.
	//
	hr = m_pISTDisp->GetTable (wszDATABASE_IIS, 
		                       wszTABLE_APPS, 
							   qcell, 
							   &ccells, 
							   eST_QUERYFORMAT_CELLS, 
							   fST_LOS_READWRITE | fST_LOS_COOKDOWN, 
							   (LPVOID*)&spISTApps);
	if (FAILED(hr))	
	{	
		goto exit;	
	}

	iApp = 0;

	while ((hr = spISTApps->GetColumnValues(iApp, 1, &iColumn, NULL, (LPVOID*)&pulVSite)) == S_OK)
	{
		iSite = i_paDependentVirtualSites->binarySearch(&ULONGCompare, pulVSite);
		if ((i_paDependentVirtualSites->size() == 0) || (i_paDependentVirtualSites->size() == iSite) || ((*i_paDependentVirtualSites)[iSite] != *pulVSite))
		{
			try
			{
				i_paDependentVirtualSites->insertAt(iSite, *pulVSite);
			}
			catch(HRESULT e)
			{
				hr = e;//should only throw E_OUTOFMEMORY;
				goto exit;
			}
		}
		iApp++;
	}

	if (hr == E_ST_NOMOREROWS)
	{
		hr = S_OK;
	}

	if(FAILED(hr))
	{
		goto exit;
	}

exit:
	
	return hr;

} // CMBAppPoolCooker::DeleteAppPool


HRESULT CMBAppPoolCooker::DeleteAppPoolAt(ULONG         i_iReadRow,
										  Array<ULONG>* i_paDependentVirtualSites)
{
	HRESULT hr           = S_OK;
	LPWSTR  wszAppPoolID = NULL;
	ULONG   iCol         = iAPPPOOLS_AppPoolID;

	hr = m_pISTCLB->GetColumnValues(i_iReadRow,
			                        1,
									&iCol,
									NULL,
									(LPVOID*)&wszAppPoolID);

	if (FAILED(hr))
	{
		return hr;
	}

	hr = DeleteAppPool(wszAppPoolID,
		               i_paDependentVirtualSites);

	return hr;

} // CMBAppPoolCooker::DeleteAppPoolAt


HRESULT CMBAppPoolCooker::DeleteObsoleteAppPools(Array<ULONG>* i_paDependentVirtualSites)
{
	HRESULT hr = S_OK;

	hr = ComputeObsoleteReadRows();

	if(FAILED(hr))
		return hr;

	for(ULONG i=0; i<m_paiReadRowObsolete->size(); i++)
	{
		hr = DeleteAppPoolAt((*m_paiReadRowObsolete)[i],
			                 i_paDependentVirtualSites);

		if(FAILED(hr))
		{
			return hr;
		}
	}

	return hr;

} // CMBAppPoolCooker::DeleteObsoleteAppPools


HRESULT CMBAppPoolCooker::ValidateAppPool()
{

	HRESULT hr	            = S_OK;
	LPVOID	pv			    = NULL;
	ULONG   cb              = 0;
	DWORD	dwRestartTime   = 0;
	DWORD	dwIdleTimeout   = 0;

	for(ULONG iCol=0; iCol<m_cCol; iCol++)
	{
		if(NULL != m_apv[iCol])
		{
			hr = ValidateAppPoolColumn(iCol,
			                           m_apv[iCol],
								       m_acb[iCol],
									   &dwRestartTime,
									   &dwIdleTimeout);

			if(HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
			{
				//
				// Data was invalid - force default,
				//

				delete [] m_apv[iCol];
				m_apv[iCol] = NULL;			
				m_acb[iCol] = 0;
			}
			else if(FAILED(hr))
			{
				return hr; // If any other failure return
			}

		}

		if(NULL == m_apv[iCol])
		{
			//
			// If you reach here it means that either the value was
			// null, or the value was invalid and hence it has been
			// set to null so that defaults can be applied.
			//

			hr = GetDefaultValue(iCol,
				                 &pv,  
								 &cb);
			if(FAILED(hr))
			{
				return hr;
			}

			hr = ValidateAppPoolColumn(iCol,
			                           pv,
								       cb,
									   &dwRestartTime,
									   &dwIdleTimeout);

			if(FAILED(hr))
			{
				if(HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
				{
					ASSERT(0 && L"Invalid default - fix the schema");
				}
				return hr;
			}
		}
	}

	if((dwRestartTime > 0) && (dwIdleTimeout >0))
	{
		//
		// TODO: If this condition does not hold, then do we attempt to default these values?
		//

		if(dwIdleTimeout >= dwRestartTime)
		{
			WCHAR wszIdleTimeout[20];
			WCHAR wszPeriodicRestartTime[20];

			_ultow(dwIdleTimeout, wszIdleTimeout, 10);
			_ultow(dwRestartTime, wszPeriodicRestartTime, 10);
			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_CONFLICTING_PERIODICRESTARTTIME_IDLETIMEOUT, (LPWSTR)(m_apv[iAPPPOOLS_AppPoolID]), wszIdleTimeout, wszPeriodicRestartTime));

			if(NULL != m_apv[iAPPPOOLS_PeriodicRestartTime])
			{
				delete [] m_apv[iAPPPOOLS_PeriodicRestartTime];
			}
			m_apv[iAPPPOOLS_PeriodicRestartTime] = NULL;
			m_acb[iAPPPOOLS_PeriodicRestartTime] = 0;

			if(NULL != m_apv[iAPPPOOLS_IdleTimeout])
			{
				delete [] m_apv[iAPPPOOLS_IdleTimeout];
			}
			m_apv[iAPPPOOLS_IdleTimeout] = NULL;
			m_acb[iAPPPOOLS_IdleTimeout] = 0;
			
			hr = S_OK;
		}
	}

	return hr;

} // CMBAppPoolCooker::ValidateAppPool


HRESULT CMBAppPoolCooker::ValidateAppPoolColumn(ULONG   i_iCol,
                                                LPVOID  i_pv,
                                                ULONG   i_cb,
												DWORD*  o_pdwRestartTime,
												DWORD*  o_pdwIdleTimeout)
{
	HRESULT hr              = S_OK;
	WCHAR   wszTemp[MAX_PATH];
	WCHAR   wszMin[20];
	WCHAR   wszMax[20];
	WCHAR   wszValue[20];

	if(NULL == i_pv)
	{
		return hr;
	}

	//
	// Always call the base class validate column before doing custom 
	// validations.
	//

	hr = ValidateColumn(i_iCol,
		                i_pv,
						i_cb);

	if(FAILED(hr))
	{
		return hr;
	}

	//
	// Perform any custom validations
	//

	switch(i_iCol)
	{

	case iAPPPOOLS_AppPoolID:
		if(((DWORD)MAX_APP_POOL < lstrlenW((WCHAR*)i_pv)) || ((DWORD)MIN_APP_POOL > lstrlenW((WCHAR*)i_pv)))
		{
			_ultow(MIN_APP_POOL, wszMin, 10);
			_ultow(MAX_APP_POOL, wszMax, 10);

			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_APPLICATION_POOL_NAME, wszMin, wszMax, (LPWSTR)i_pv));
		}
		break;

	case iAPPPOOLS_PeriodicRestartTime:
		*o_pdwRestartTime = *(DWORD *)(i_pv);
		break;

	case iAPPPOOLS_IdleTimeout:
		*o_pdwIdleTimeout = *(DWORD *)(i_pv);
		break;

	default:
		break;

	} // End switch

	return hr;

} // CMBAppPoolCooker::ValidateAppPoolColumn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbapppoolcooker.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#ifndef _MBAPPPOOLCOOKER_H_
#define _MBAPPPOOLCOOKER_H_

//
// TODO: This has to ultimately move to iiscnfg.h so that it becomes visible to
//       other metabase consumers.
//

//#define IIS_MD_APPPOOL_BASE 9000

//#define MD_APPPOOL_PERIODIC_RESTART_TIME				(IIS_MD_APPPOOL_BASE+1)
//#define MD_APPPOOL_PERIODIC_RESTART_REQUESTS			(IIS_MD_APPPOOL_BASE+2)
//#define MD_APPPOOL_MAX_PROCESSES						(IIS_MD_APPPOOL_BASE+3)
//#define MD_APPPOOL_PINGING_ENABLED						(IIS_MD_APPPOOL_BASE+4)
//#define MD_APPPOOL_IDLE_TIMEOUT							(IIS_MD_APPPOOL_BASE+5)
//#define MD_APPPOOL_RAPID_FAIL_PROTECTION				(IIS_MD_APPPOOL_BASE+6)
//#define MD_APPPOOL_SMP_AFFINITIZED						(IIS_MD_APPPOOL_BASE+7)
//#define MD_APPPOOL_SMP_PROCESSOR_AFFINITY_MASK			(IIS_MD_APPPOOL_BASE+8)
//#define MD_APPPOOL_ORPHAN_WORKER_PROCESS				(IIS_MD_APPPOOL_BASE+9)
//#define MD_APPPOOL_RUN_AS_LOCAL_SYSTEM					(IIS_MD_APPPOOL_BASE+10)
//#define MD_APPPOOL_STARTUP_TIME_LIMIT					(IIS_MD_APPPOOL_BASE+11)
//#define MD_APPPOOL_SHUTDOWN_TIME_LIMIT					(IIS_MD_APPPOOL_BASE+12)
//#define MD_APPPOOL_PING_INTERVAL						(IIS_MD_APPPOOL_BASE+13)
//#define MD_APPPOOL_PING_RESPONSE_TIME_LIMIT				(IIS_MD_APPPOOL_BASE+14)
//#define MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION		(IIS_MD_APPPOOL_BASE+15)
//#define MD_APPPOOL_ORPHAN_ACTION						(IIS_MD_APPPOOL_BASE+16)
//#define MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH				(IIS_MD_APPPOOL_BASE+17)
//#define MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGES	(IIS_MD_APPPOOL_BASE+18)
//#define MD_APPPOOL_FRIENDLY_NAME						(IIS_MD_APPPOOL_BASE+19)

class CMBSiteCooker;

class CMBAppPoolCooker: public CMBBaseCooker
{

public:

	CMBAppPoolCooker();
	
	~CMBAppPoolCooker();
	
	HRESULT BeginCookDown(IMSAdminBase*				i_pIMSAdminBase,
						  METADATA_HANDLE			i_MBHandle,
						  ISimpleTableDispenser2*	i_pISTDisp,
						  LPCWSTR					i_wszCookDownFile);

	HRESULT CookDown(WAS_CHANGE_OBJECT* i_pWASChngObj=NULL,
		             BOOL*              o_bNewRowAdded=NULL,
                     Array<ULONG>*      i_paDependentVirtualSites=NULL);
	
	HRESULT EndCookDown();

public:

	HRESULT CookDownAppPool(WCHAR*	           i_wszAppPool,
		                    WAS_CHANGE_OBJECT* i_pWASChngObj,
		                    BOOL*              o_bNewRowAdded,
						    Array<ULONG>*      i_paDependentVirtualSites);

	HRESULT DeleteAppPool(WCHAR*	    i_wszAppPool,
			              Array<ULONG>* i_paDependentVirtualSites);

private:

	HRESULT ValidateAppPool();

	HRESULT ValidateAppPoolColumn(ULONG   i_iCol,
                                  LPVOID  i_pv,
                                  ULONG   i_cb,
								  DWORD*  o_pdwRestartTime,
								  DWORD*  o_pdwIdleTimeout);

	HRESULT DeleteAllAppPools(Array<ULONG>* i_paDependentVirtualSites);

	HRESULT DeleteAppPoolAt(ULONG         i_iReadRow,
						    Array<ULONG>* i_paDependentVirtualSites);

	HRESULT DeleteObsoleteAppPools(Array<ULONG>* i_paDependentVirtualSites);

};

#endif // _MBAPPPOOLCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbappcooker.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#ifndef _MBAPPCOOKER_H_
#define _MBAPPCOOKER_H_

//
// TODO: This has to ultimately move to iiscnfg.h so that it becomes visible to
//       other metabase consumers.
//

#define IIS_MD_APP_BASE  9100

#define MD_APP_APPPOOL_ID								(IIS_MD_APP_BASE+1)
#define MD_APP_ALLOW_TRANSIENT_REGISTRATION				(IIS_MD_APP_BASE+2)
#define MD_APP_AUTO_START								(IIS_MD_APP_BASE+3)


class CMBAppCooker: public CMBBaseCooker
{

public:

	CMBAppCooker();
	
	~CMBAppCooker();
	
	HRESULT BeginCookDown(IMSAdminBase*				i_pIMSAdminBase,
						  METADATA_HANDLE			i_MBHandle,
						  ISimpleTableDispenser2*	i_pISTDisp,
						  LPCWSTR					i_wszCookDownFile);

	HRESULT CookDown(LPCWSTR            i_wszApplicationPath,
					 LPCWSTR            i_wszSiteRootPath,
					 DWORD              i_dwVirtualSiteId,
	                 WAS_CHANGE_OBJECT* i_pWASChngObj,
					 BOOL*	            o_pValidRootApplicationExists);

	HRESULT EndCookDown();

public:

	HRESULT CookDownApplication(LPCWSTR            i_wszApplicationPath,
					            LPCWSTR            i_wszSiteRootPath,
						        DWORD              i_dwVirtualSiteId,
	                            WAS_CHANGE_OBJECT* i_pWASChngObj,
						        BOOL*              o_pIsRootApplication);

	HRESULT DeleteApplication(LPCWSTR i_wszApplicationPath,
					        LPCWSTR i_wszSiteRootPath,
						    DWORD   i_dwVirtualSiteId,
							BOOL    i_bRecursive);

	HRESULT SetAppPoolCache(ISimpleTableWrite2* i_pISTCLB);

	HRESULT DeleteObsoleteApplications();

private:

	HRESULT ValidateApplication(LPCWSTR i_wszPath,
							    BOOL      i_bIsRootApp);

	HRESULT ValidateApplicationColumn(ULONG   i_iCol,
                                      LPVOID  i_pv,
                                      ULONG   i_cb,
									  BOOL*   o_ApplyDefaults);

	HRESULT DeleteApplicationUrl(LPCWSTR i_wszApplicationUrl,
                                 ULONG  i_dwSiteId,
							     BOOL    i_bRecursive);

	ISimpleTableWrite2*  m_pISTAppPool;

};

#endif // _MBAPPCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbappcooker.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "Catmeta.h"
#include "catalog.h"
#include "catmacros.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "MBBaseCooker.h"
#include "MBGlobalCooker.h"
#include "MBAppPoolCooker.h"
#include "MBAppCooker.h"
#include "MBSiteCooker.h"
#include "undefs.h"
#include "SvcMsg.h"

CMBAppCooker::CMBAppCooker():
CMBBaseCooker()
{

} // CMBAppCooker::CMBAppCooker


CMBAppCooker::~CMBAppCooker()
{
	if(NULL != m_pISTAppPool)
	{
		m_pISTAppPool->Release();
		m_pISTAppPool = NULL;
	}

} // CMBAppCooker::~CMBAppCooker

HRESULT CMBAppCooker::BeginCookDown(IMSAdminBase*			i_pIMSAdminBase,
									METADATA_HANDLE			i_MBHandle,
									ISimpleTableDispenser2*	i_pISTDisp,
									LPCWSTR					i_wszCookDownFile)
{
	HRESULT hr;

	//
	// Initialize CLB table name.
	//

	m_pISTAppPool = NULL;
	m_wszTable = wszTABLE_APPS;

	// 
	// Invoke the base class BeginCookDown so that all the structures are
	// initialized.
	//

	hr = CMBBaseCooker::BeginCookDown(i_pIMSAdminBase,
									  i_MBHandle,
									  i_pISTDisp,
									  i_wszCookDownFile);

	return hr;

} // CMBAppCooker::BeginCookDown


//
// Note that the i_wszApplicationPath is relative to w3svc
//
//

HRESULT CMBAppCooker::CookDown(LPCWSTR            i_wszApplicationPath,
							   LPCWSTR            i_wszSiteRootPath,
							   DWORD              i_dwVirtualSiteId,
							   WAS_CHANGE_OBJECT* i_pWASChngObj,
							   BOOL*	          o_pValidRootApplicationExists)
{

    HRESULT hr            = S_OK;
	WCHAR*	wszSubApp     = NULL; // Do not declare as stack variables because this function is recursive
	WCHAR*	wszFullSubApp = NULL;

    hr = CookDownApplication(i_wszApplicationPath, 
	                         i_wszSiteRootPath, 
							 i_dwVirtualSiteId,
							 i_pWASChngObj,
                             o_pValidRootApplicationExists);

    if (FAILED(hr))
    {
		//
		// There is no need to log error messages here as 
		// it will be done in CookDownApplication
		// We reset the hr and continue enumerating and cooking sub-applications.
		//

		hr = S_OK;
    }


	wszSubApp = new WCHAR[METADATA_MAX_NAME_LEN+1];
	if(NULL == wszSubApp)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

    //
    // Enumerate all the sub applications 
    //

	for(DWORD dwIndex=0; SUCCEEDED(hr) ; dwIndex++)
	{

		//
		// Enum a subkey under i_wszApplicationPath
		//

		hr = m_pIMSAdminBase->EnumKeys(m_hMBHandle,
									   i_wszApplicationPath, // relative to w3svc
									   wszSubApp,
									   dwIndex);


		if(SUCCEEDED(hr))
		{

			//
			// Construct the full path path of sub app relative to W3SVC
			//

			wszFullSubApp = new WCHAR[Wszlstrlen(i_wszApplicationPath) + 1 +
					                  Wszlstrlen(wszSubApp) + 1];
			if (wszFullSubApp == NULL)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}

			Wszlstrcpy(wszFullSubApp, i_wszApplicationPath);
			if(wszFullSubApp[Wszlstrlen(wszFullSubApp)-1] != L'/')
				Wszlstrcat(wszFullSubApp, L"/");		// TODO: Define seperator
			Wszlstrcat(wszFullSubApp, wszSubApp);

			//
			// Cookdown all applications in this sub path.
			//

			hr = CookDown(wszFullSubApp,
						  i_wszSiteRootPath,
						  i_dwVirtualSiteId, 
						  i_pWASChngObj,
						  o_pValidRootApplicationExists);

			if(NULL != wszFullSubApp)
			{
				delete [] wszFullSubApp;
				wszFullSubApp = NULL;
			}

			if (FAILED(hr))
			{
				//
				// There is no need to log error messages here as 
				// it will be done in CookDown
				//

				//
				// We continue, meaning if one of the apps fail
				// to cook, we will continue with the siblings of the app
				//

				hr = S_OK;
			}

		} // If succeeded enumerating the key

	} // For all keys 
				
	if(FAILED(hr))
	{
		if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
			hr = S_OK;
		else
		{
			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATIONS, i_wszApplicationPath));
		}
	}

exit:

	if(NULL != wszSubApp)
	{
		delete [] wszSubApp;
		wszSubApp = NULL;
	}

	if(NULL != wszFullSubApp)
	{
		delete [] wszFullSubApp;
		wszFullSubApp = NULL;
	}

    return hr;

} // CMBAppCooker::CookDown


HRESULT CMBAppCooker::EndCookDown()
{
	HRESULT hr;

	hr = m_pISTCLB->UpdateStore();

	if(FAILED(hr))
	{
		hr = GetDetailedErrors(hr);
	}

	return hr;

} // CMBAppCooker::EndCookDown

HRESULT CMBAppCooker::CookDownApplication(LPCWSTR            i_wszApplicationPath,
										  LPCWSTR            i_wszSiteRootPath,
										  DWORD              i_dwVirtualSiteId,
							              WAS_CHANGE_OBJECT* i_pWASChngObj,
										  BOOL*              o_pIsRootApplication)
{

    HRESULT hr                 = S_OK;
    LPCWSTR wszApplicationUrl  = NULL;
    DWORD   dwLen              = 0;
	BOOL    bIsRootApplication = FALSE;

    //
    // To get the (site-relative) application URL, lop off the front of
    // the application path, which is exactly the site root path.
    //

    ASSERT( _wcsnicmp( i_wszApplicationPath, i_wszSiteRootPath, wcslen( i_wszSiteRootPath ) ) == 0 );
    
    wszApplicationUrl = i_wszApplicationPath + wcslen( i_wszSiteRootPath );

	if(m_acb[iAPPS_AppRelativeURL] < (Wszlstrlen(wszApplicationUrl)+2)*sizeof(WCHAR))
	{
		if(NULL != m_apv[iAPPS_AppRelativeURL])
		{
			delete [] m_apv[iAPPS_AppRelativeURL];
			m_apv[iAPPS_AppRelativeURL] = NULL;
			m_acb[iAPPS_AppRelativeURL] = 0;
			m_apv[iAPPS_AppRelativeURL] = new WCHAR[Wszlstrlen(wszApplicationUrl)+2]; // Account for the terminating / if not present.
			if(NULL == m_apv[iAPPS_AppRelativeURL])
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}
			m_acb[iAPPS_AppRelativeURL] = ((ULONG)Wszlstrlen(wszApplicationUrl)+2)*sizeof(WCHAR);
		}
	}
	Wszlstrcpy((LPWSTR)m_apv[iAPPS_AppRelativeURL], wszApplicationUrl);

	dwLen = (DWORD)Wszlstrlen(wszApplicationUrl);

	if(dwLen > 0)
	{
		if( wszApplicationUrl[dwLen-1] != L'/')
		{
			// 
			// If the last character is not / add it. No need to realloc, 
		    // because we have accounted for it above
			//

			((LPWSTR)m_apv[iAPPS_AppRelativeURL])[dwLen] = L'/';
			((LPWSTR)m_apv[iAPPS_AppRelativeURL])[dwLen+1] = 0;
		}
	}
	else if(wszApplicationUrl[0] == 0) 
	{
		//
		// TODO: Fix this.
		// This is a root app case
		// If this is the root app, sometimes during notifications you will
		// get a root url without / ie /1/root instead of /1/root/
		// In that case add a /. No need to realloc, because we have accounted
		// for it above
		//

		((LPWSTR)m_apv[iAPPS_AppRelativeURL])[0] = L'/';
		((LPWSTR)m_apv[iAPPS_AppRelativeURL])[1] = 0;
	}

	//
	// Determine if its a root application - Note assign to 
	// o_pIsRootApplication only at the end, if everything
	// succeeds
	//

    if ( ( *wszApplicationUrl == L'/' ) && ( *( wszApplicationUrl + 1 ) == L'\0' ) )
        bIsRootApplication = TRUE;


	// 
	// Fill in the SiteID
	//
	
	*(DWORD*)m_apv[iAPPS_SiteID] = i_dwVirtualSiteId;


	//
	// Read config from MB.
	//

	hr = GetData((LPWSTR)i_wszApplicationPath);

	if(FAILED(hr))
	{
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_PROPERTIES, i_wszApplicationPath));
		goto exit;
	}

	//
	// Validate App config.
	//

	hr = ValidateApplication(i_wszApplicationPath,
		                     bIsRootApplication);

	if(FAILED(hr))
		goto exit;		//
						// There is no need to log error messages here as 
						// it will be done in ValidateApplication
						//

	//
	// Copy all AppPool rows.
	//

	hr = CopyRows(&(m_apv[iAPPS_AppRelativeURL]),
				  i_pWASChngObj);

	if(FAILED(hr))
	{
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_APPLICATION_INTERNAL_ERROR, (LPWSTR)m_apv[iAPPS_AppRelativeURL], NULL));
		goto exit;
	}

    //
    // Now assign when everything has succeeded and it is a root app. Else do not assign.
    //

	if(bIsRootApplication)
	{
	    *o_pIsRootApplication = bIsRootApplication;
	}

exit:

	if(FAILED(hr))
	{
		DeleteApplication(i_wszApplicationPath,
					      i_wszSiteRootPath,
						  i_dwVirtualSiteId,
						  FALSE);

	}
    
    return hr;

} // CMBAppCooker::CookDownApplication


HRESULT CMBAppCooker::DeleteObsoleteApplications()
{

	HRESULT hr = S_OK;

	hr = ComputeObsoleteReadRows();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_paiReadRowObsolete->size(); i++)
	{
		ULONG  a_iCol [] = {iAPPS_SiteID,
					 	    iAPPS_AppRelativeURL
	                       };
		ULONG  cCol = sizeof(a_iCol)/sizeof(a_iCol[0]);
		LPVOID a_pv[cAPPS_NumberOfColumns];

		hr = m_pISTCLB->GetColumnValues((*m_paiReadRowObsolete)[i],
										cCol,
										a_iCol,
										NULL,
										(LPVOID*)a_pv);

		if(FAILED(hr))
		{
			return hr;
		}

		hr = DeleteApplicationUrl((LPWSTR)a_pv[iAPPS_AppRelativeURL],
		                          *(DWORD*)a_pv[iAPPS_SiteID],
								  FALSE);

		if(FAILED(hr))
		{
			return hr;
		}
	}

	return hr;

} // CMBAppCooker::DeleteObsoleteApplications


HRESULT CMBAppCooker::DeleteApplication(LPCWSTR i_wszApplicationPath,
										LPCWSTR i_wszSiteRootPath,
										DWORD   i_dwVirtualSiteId,
										BOOL    i_bRecursive)
{
    LPCWSTR wszApplicationUrl = NULL;    
	HRESULT hr                = S_OK;

    //
    // To get the (site-relative) application URL, lop off the front of
    // the application path, which is exactly the site root path.
    //

    ASSERT( _wcsnicmp( i_wszApplicationPath, i_wszSiteRootPath, wcslen( i_wszSiteRootPath ) ) == 0 );
    
    wszApplicationUrl = i_wszApplicationPath + wcslen( i_wszSiteRootPath );

	hr = DeleteApplicationUrl(wszApplicationUrl,
	                          i_dwVirtualSiteId,
							  i_bRecursive);

	return hr;

} // CMBAppCooker::DeleteApplication


HRESULT CMBAppCooker::DeleteApplicationUrl(LPCWSTR i_wszApplicationUrl,
                                           ULONG   i_dwSiteId,
										   BOOL    i_bRecursive)
{
	CComPtr<ISimpleTableWrite2> spISTApps;
	ULONG		iApp;
	ULONG		iColumn = iAPPS_AppRelativeURL;
	ULONG		cChars;
	LPWSTR		wszAppURL;
	HRESULT		hr = S_OK;
	ULONG		aColumn[] = {iAPPS_SiteID,
					 		 iAPPS_AppRelativeURL
	};
	ULONG       cCol = sizeof(aColumn)/sizeof(aColumn[0]);
	LPVOID		apv[cAPPS_NumberOfColumns];
	CComPtr<ISimpleTableController> spISTController;

	STQueryCell	qcell[2];
	ULONG		ccells = sizeof(qcell)/sizeof(qcell[0]);
	LPVOID      aIdentity[2];
	ULONG       iReadRow=0;

    //
    // Get all the apps on this site.
    //

    qcell[0].pData     = (LPVOID)m_wszCookDownFile;
    qcell[0].eOperator = eST_OP_EQUAL;
    qcell[0].iCell     = iST_CELL_FILE;
    qcell[0].dbType    = DBTYPE_WSTR;
    qcell[0].cbSize    = (lstrlenW(m_wszCookDownFile)+1)*sizeof(WCHAR);

    qcell[1].pData     = (LPVOID)&i_dwSiteId;
    qcell[1].eOperator = eST_OP_EQUAL;
    qcell[1].iCell     = iAPPS_SiteID;
    qcell[1].dbType    = DBTYPE_UI4;
    qcell[1].cbSize    = 0;

	hr = m_pISTDisp->GetTable (wszDATABASE_IIS, 
		                       wszTABLE_APPS, 
							   qcell, 
							   &ccells, 
							   eST_QUERYFORMAT_CELLS, 
							   fST_LOS_READWRITE | fST_LOS_COOKDOWN, 
							   (LPVOID*)&spISTApps);

	if (FAILED(hr))
		return hr;	

	iApp = 0;
	cChars = (ULONG)wcslen(i_wszApplicationUrl);
	while (S_OK == (hr = spISTApps->GetColumnValues(iApp, 
												    1, 
												    &iColumn, 
												    NULL, 
												    (LPVOID*)&wszAppURL)))
	{
		ULONG ulCompare = 0;

		if(i_bRecursive)
		{
			// Delete all the apps that are a sub-app of the app.
			ulCompare = _wcsnicmp(i_wszApplicationUrl, wszAppURL, cChars);
		}
		else
		{
			// Delete just this one app.
			ulCompare = _wcsnicmp(i_wszApplicationUrl, wszAppURL, cChars);

			if(0 == ulCompare)
			{
				// Check that the cch is at most greater than cChars. If not it is a sub app.
				// If it is one greater than cChars, check that the last char is a slash
				ULONG cch = wcslen(wszAppURL);

				if((cChars == cch) ||
                   ((cChars+1 == cch) &&
					(L'/' == wszAppURL[cch-1])
				   )               ||  
                   ((cChars+1 == cch) &&
					(L'\\' == wszAppURL[cch-1])
				   )
				  )
				{
					;
				}
				else
				{
					ulCompare = 1;
				}

			}


		}

		if (ulCompare == 0)
		{
			//
			// Note that we fetch the apps from disk, but we delete from our
			// read cache, since there is no efficient way to traverse the
			// read cache for all apps and sub apps. If we do not delete
			// from our read cache, subsequent inserts will show up as
			// updates because they will be present in the read cache and
			// not in the write cache.
			//

			aIdentity[0] = (LPVOID) wszAppURL;
			aIdentity[1] = (LPVOID) &i_dwSiteId;

			hr = DeleteRow(aIdentity);
		}
		iApp++;
	}

	if (hr == E_ST_NOMOREROWS)
	{
		hr = S_OK;
	}
	else if (FAILED(hr))	
	{
		return hr;
	}

	//
	// Look in the write cache and change any inserts on this app and its 
	// sub-apps to ignore. Change any updates to deletes, and keep deletes
	// or ignores intact.
	//

	hr = m_pISTCLB->QueryInterface(IID_ISimpleTableController,
								   (void**)&spISTController);

	iApp = 0;
	while(S_OK == (hr = m_pISTCLB->GetWriteColumnValues(iApp,
		                                                cCol,
												        aColumn,
												        NULL,
												        NULL,
												        apv)))
	{
		if(i_dwSiteId == *(DWORD*)apv[iAPPS_SiteID])
		{
			ULONG ulCompare = 0;

			if(i_bRecursive)
			{
				// Delete all the apps that are a sub-app of the app.
				ulCompare = _wcsnicmp(i_wszApplicationUrl, (LPWSTR)apv[iAPPS_AppRelativeURL], cChars);
			}
			else
			{
				// Delete just this one app.
				ulCompare = _wcsnicmp(i_wszApplicationUrl, (LPWSTR)apv[iAPPS_AppRelativeURL], cChars);

				if(0 == ulCompare)
				{
					// Check that the cch is at most greater than cChars. If not it is a sub app.
					// If it is one greater than cChars, check that the last char is a slash
					ULONG cch = wcslen((LPWSTR)apv[iAPPS_AppRelativeURL]);

					if((cChars == cch) ||
                       ((cChars+1 == cch) &&
						(L'/' == ((LPWSTR)apv[iAPPS_AppRelativeURL])[cch-1])
					   )               ||  
                       ((cChars+1 == cch) &&
						(L'\\' == ((LPWSTR)apv[iAPPS_AppRelativeURL])[cch-1])
					   )
					  )
					{
						;
					}
					else
					{
						ulCompare = 1;
					}

				}
			}

			if(ulCompare == 0)
			{
				DWORD	eAction;
				DWORD   eNewAction = eST_ROW_IGNORE;

				hr = spISTController->GetWriteRowAction(iApp,
				 										&eAction);
				if(FAILED(hr))
				{
					return hr;
				}

				if((eAction == eST_ROW_UPDATE) || 
				   (eAction == eST_ROW_INSERT)
				  )
				{
					if(eAction == eST_ROW_UPDATE)
					{
						eNewAction = eST_ROW_DELETE;
					}
					else // eAction == eST_ROW_INSERT
					{
						eNewAction = eST_ROW_IGNORE;
					}

					hr = spISTController->SetWriteRowAction(iApp,
															eNewAction);

					if(FAILED(hr))
					{
						return hr;
					}
				}
				// else Do nothing if eAction is eST_ROW_DELETE or eST_ROW_IGNORE
			}
		}
		iApp++;
	}

	if (hr == E_ST_NOMOREROWS)
	{
		hr = S_OK;
	}

	return hr;


} // CMBAppCooker::DeleteApplicationUrl


HRESULT CMBAppCooker::ValidateApplication(LPCWSTR	i_wszPath,
										  BOOL      i_bIsRootApp)
{
	HRESULT hr;
	LPVOID	pv			    = NULL;
	ULONG   cb              = 0;

	//
	// Custom non-column specific validations
	// These are typically done after column validations,
	// But here
	//
	//
	// Validate that the AppIsolated property is specified
	// for this app. If it is not, then it is not a valid app.
	//

	METADATA_RECORD mdr;
	DWORD			dwAppIsolated = 0;
	DWORD			dwRequiredDataLen = 0;

	mdr.dwMDIdentifier = MD_APP_ISOLATED;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
	mdr.dwMDUserType   = ALL_METADATA;
	mdr.dwMDDataType   = DWORD_METADATA;
	mdr.dwMDDataLen    = sizeof(DWORD);
	mdr.pbMDData       = (BYTE *) &dwAppIsolated;

	hr = m_pIMSAdminBase->GetData(m_hMBHandle,
								  i_wszPath,
								  &mdr,
								  &dwRequiredDataLen);

	
	if((MD_ERROR_DATA_NOT_FOUND == hr) && i_bIsRootApp)
	{
		//
		// OK for a root application not to have the app isolated property.
		//

		hr = S_OK;
	}
	else if(FAILED(hr))
	{
		if(MD_ERROR_DATA_NOT_FOUND != hr)
		{
			WCHAR wszSiteID[21];
			_ultow(*(DWORD*)(m_apv[iAPPS_SiteID]), wszSiteID, 10);
			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_APPLICATION_PROPERTIES, (LPWSTR)m_apv[iAPPS_AppRelativeURL],wszSiteID));
		}
		return hr;
	}


	//
	// Validate columns.
	//

	for(ULONG iCol=0; iCol<m_cCol; iCol++)
	{
		if(NULL != m_apv[iCol])
		{
			BOOL bApplyDefaults;

			hr = ValidateApplicationColumn(iCol,
			                               m_apv[iCol],
								           m_acb[iCol],
										   &bApplyDefaults);

			if((HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr) &&
			    bApplyDefaults
			  )
			{
				//
				// Data was invalid - force default,
				//

				delete [] m_apv[iCol];
				m_apv[iCol] = NULL;			
				m_acb[iCol] = 0;
			}
			else if(FAILED(hr))
			{
				return hr; // If any other failure return
			}

		}

		if(NULL == m_apv[iCol])
		{
			//
			// If you reach here it means that either the value was
			// null, or the value was invalid and hence it has been
			// set to null so that defaults can be applied.
			//

			hr = GetDefaultValue(iCol,
				                 &pv,  
								 &cb);
			if(FAILED(hr))
			{
				return hr;
			}

			hr = ValidateApplicationColumn(iCol,
			                               pv,
								           cb,
										   NULL);

			if(FAILED(hr))
			{
				if((HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr) &&
				   (iAPPS_AppPoolId != iCol)
				  )
				{
					ASSERT(0 && L"Invalid default - fix the schema");
				}
				return hr;
			}
		}
	}

	return hr;

} // CMBAppCooker::ValidateApplication


HRESULT CMBAppCooker::ValidateApplicationColumn(ULONG   i_iCol,
                                                LPVOID  i_pv,
                                                ULONG   i_cb,
												BOOL*   o_ApplyDefaults)
{
	HRESULT hr;
	WCHAR   wszSiteID[20];
	ULONG iWriteRow = 0;
	ULONG iReadRow = 0;

	if(NULL != o_ApplyDefaults)
	{
		*o_ApplyDefaults = FALSE;
	}

	//
	// Always call the base class validate column before doing custom 
	// validations.
	//

	hr = ValidateColumn(i_iCol,
		                i_pv,
						i_cb);

	if(FAILED(hr))
	{
		if(NULL != o_ApplyDefaults)
		{
			*o_ApplyDefaults = TRUE;
		}
		return hr;
	}

	//
	// Perform any custom column validations
	//

	if(iAPPS_AppPoolId == i_iCol)
	{
		if(NULL == i_pv)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			_ultow(*(DWORD*)(m_apv[iAPPS_SiteID]), wszSiteID, 10);
			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_INVALID_APPLICATION_APPPOOL,  (LPWSTR)m_apv[iAPPS_AppRelativeURL],wszSiteID,NULL));
			return hr;
		}

		if(NULL == m_pISTAppPool)
		{
			//
			// Validate that the app belongs to a valid AppPool
			//

			STQueryCell	QueryCell[1];	
			ULONG		cCell = sizeof(QueryCell)/sizeof(QueryCell[0]);
			ULONG		cRow = 0;

			
			QueryCell[0].pData     = (LPVOID)m_wszCookDownFile;
			QueryCell[0].eOperator = eST_OP_EQUAL;
			QueryCell[0].iCell     = iST_CELL_FILE;
			QueryCell[0].dbType    = DBTYPE_WSTR;
			QueryCell[0].cbSize    = (lstrlenW(m_wszCookDownFile)+1)*sizeof(WCHAR);

			hr = m_pISTDisp->GetTable(wszDATABASE_IIS,
									  wszTABLE_APPPOOLS,
									 (LPVOID)QueryCell,
									 (LPVOID)&cCell,
									 eST_QUERYFORMAT_CELLS,
									 fST_LOS_READWRITE | fST_LOS_COOKDOWN,
									 (LPVOID *)&m_pISTAppPool);

			if(FAILED(hr))
			{
				WCHAR wszTemp[MAX_PATH];
				_ultow(*(DWORD*)(m_apv[iAPPS_SiteID]), wszSiteID, 10);
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_APPLICATION_INTERNAL_ERROR, (LPWSTR)m_apv[iAPPS_AppRelativeURL], wszSiteID));
				return hr;

			}

		}

		//
		// First check the write cache and see if it is present and not marked
		// for delete. Always check write cache before read because it can be
		// marked for delete.
		//

		hr = m_pISTAppPool->GetWriteRowIndexByIdentity(NULL,
													   &i_pv,
													   &iWriteRow);

		if(SUCCEEDED(hr))
		{
			//
			// Found in write cache - check the row action to make sure its not deleted.
			//

			CComPtr<ISimpleTableController> spISTController;
			DWORD                           eAction = 0;

			hr = m_pISTAppPool->QueryInterface(IID_ISimpleTableController,
											   (void**)&spISTController);

			if(SUCCEEDED(hr))
			{
				hr = spISTController->GetWriteRowAction(iWriteRow,
														&eAction);

			}

			if((FAILED(hr)) || (eAction == eST_ROW_DELETE))
			{
				hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				_ultow(*(DWORD*)(m_apv[iAPPS_SiteID]), wszSiteID, 10);
				LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_INVALID_APPLICATION_APPPOOL,  (LPWSTR)m_apv[iAPPS_AppRelativeURL],wszSiteID));
				return hr;

			}

		}
		else if(E_ST_NOMOREROWS == hr)
		{
			//
			// Not in write cache - check in read cache.
			//

			hr = m_pISTAppPool->GetRowIndexByIdentity(NULL,
													  &i_pv,
													  &iReadRow);
			if(FAILED(hr))
			{
				hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
				_ultow(*(DWORD*)(m_apv[iAPPS_SiteID]), wszSiteID, 10);
				LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_INVALID_APPLICATION_APPPOOL,  (LPWSTR)m_apv[iAPPS_AppRelativeURL],wszSiteID));
				return hr;
			}
		}
		else 
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			_ultow(*(DWORD*)(m_apv[iAPPS_SiteID]), wszSiteID, 10);
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_APPLICATION_INTERNAL_ERROR,  (LPWSTR)m_apv[iAPPS_AppRelativeURL],wszSiteID));
			return hr;
		}
	}

	return hr;

} // CMBAppCooker::ValidateApplication


HRESULT CMBAppCooker::SetAppPoolCache(ISimpleTableWrite2* i_pISTCLB)
{
	HRESULT hr = S_OK;

	if(NULL != i_pISTCLB)
	{
		hr = i_pISTCLB->QueryInterface(IID_ISimpleTableWrite2,
									   (LPVOID*)&m_pISTAppPool);
	}

	return hr;

} // CMBAppCooker::SetAppPoolCache
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbbasecooker.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "Catmeta.h"
#include "catalog.h"
#include "catmacros.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "MBBaseCooker.h"
#include "MBGlobalCooker.h"
#include "MBAppPoolCooker.h"
#include "MBAppCooker.h"
#include "MBSiteCooker.h"
#include "undefs.h"
#include "SvcMsg.h"
#include "ISTHelper.h"

#define cmaxCOLUMNS 50
#define WSZ_METABASE_FILE L"Metabase.XML"
#define CCH_METABASE_FILE (sizeof(WSZ_METABASE_FILE)/sizeof(WCHAR))
#define CCH_MAX_ULONG 10
#define WSZ_EXTENSION L":"
#define CCH_EXTENSTION (sizeof(WSZ_EXTENSION)/sizeof(WCHAR))

LPCWSTR g_wszByTableAndColumnIndexAndValueOnly = L"ByTableAndColumnIndexAndValueOnly";
 
int _cdecl MyIntCompare(const void *a,
			            const void *b)
{
	if(*(ULONG*)a == *(ULONG*)b)
		return 0;
	else if(*(ULONG*)a < *(ULONG*)b)
		return -1;
	else
		return 1;
}

CMBBaseCooker::CMBBaseCooker():
m_pIMSAdminBase(NULL),
m_hMBHandle(NULL),
m_pISTDisp(NULL),
m_pISTCLB(NULL),
m_pISTColumnMeta(NULL),
m_pISTTagMeta(NULL),
m_wszTable(NULL),
m_wszCookDownFile(NULL),
m_apv(NULL),
m_acb(NULL),
m_aiCol(NULL),
m_cCol(0),
m_pOSVersionInfo(NULL),
m_paiReadRowPresent(NULL),
m_paiReadRowObsolete(NULL)
{

} // CMBBaseCooker::CMBBaseCooker()


CMBBaseCooker::~CMBBaseCooker()
{
	if(NULL != m_apv)
	{
		if(0 < m_cCol)
		{
			for(ULONG i=0; i<m_cCol; i++)
			{
				if(NULL != m_apv[i])
				{
					delete [] m_apv[i];
					m_apv[i] = NULL;
				}
			}
		}
		delete [] m_apv;
		m_apv = NULL;
	}
	if(NULL != m_acb)
	{
		delete [] m_acb;
		m_acb = NULL;
	}
	if(NULL != m_aiCol)
	{
		delete [] m_aiCol;
		m_aiCol = NULL;
	}

	if(NULL != m_pIMSAdminBase)
	{
		m_pIMSAdminBase->Release();
		m_pIMSAdminBase = NULL;
	}

	if(NULL != m_pISTCLB)
	{
		m_pISTCLB->Release();
		m_pISTCLB = NULL;
	}
	if(NULL != m_pISTColumnMeta)
	{
		m_pISTColumnMeta->Release();
		m_pISTColumnMeta = NULL;
	}
	if(NULL != m_pISTTagMeta)
	{
		m_pISTTagMeta->Release();
		m_pISTTagMeta = NULL;
	}
	if(NULL != m_pISTDisp)
	{
		m_pISTDisp->Release();
		m_pISTDisp = NULL;
	}

	if(NULL != m_pOSVersionInfo)
	{
		delete m_pOSVersionInfo;
		m_pOSVersionInfo = NULL;
	}

	if(NULL != m_paiReadRowPresent)
	{
		delete m_paiReadRowPresent;
		m_paiReadRowPresent = NULL;
	}

	if(NULL != m_paiReadRowObsolete)
	{
		delete m_paiReadRowObsolete;
		m_paiReadRowObsolete = NULL;
	}

} // CMBBaseCooker::~CMBBaseCooker()


HRESULT CMBBaseCooker::CookDown()
{

// This function must be imlemented by derived classes.

	return E_NOTIMPL;

} // CMBBaseCooker::CookDown

HRESULT CMBBaseCooker::CookDown(LPCWSTR  i_wszAppPath,
							    LPCWSTR  i_wszSiteRootPath,
							    DWORD    i_dwVirtualSiteId,
							    BOOL*	  o_pValidRootApplicationExists)
{

// This function must be imlemented by derived classes.

	return E_NOTIMPL;

} // CMBBaseCooker::CookDown


HRESULT CMBBaseCooker::BeginCookDown(IMSAdminBase*				i_pIMSAdminBase,
									 METADATA_HANDLE			i_MBHandle,
									 ISimpleTableDispenser2*	i_pISTDisp,
									 LPCWSTR					i_wszCookDownFile)
{
	HRESULT hr;
	STQueryCell  QueryCellCLB[1];
	ULONG		 cCellCLB = sizeof(QueryCellCLB) / sizeof(QueryCellCLB[0]);

	// 
	// m_wszTable must always be initialized before this call.
	//

	if(NULL == m_wszTable)
	{
		ASSERT(0 && "Call derived class BeginCookDOwn");
		return E_INVALIDARG;
	}

	//
	// Save MSAdminBase pointer.
	//

	hr = i_pIMSAdminBase->QueryInterface(IID_IMSAdminBase, 
										 (void**)&m_pIMSAdminBase);

	if(FAILED(hr))
		return hr;

	//
	// Save MB handle
	//

	m_hMBHandle = i_MBHandle;

	//
	// Save Dispenser
	//

	hr = i_pISTDisp->QueryInterface(IID_ISimpleTableDispenser2,
									(void**)&m_pISTDisp);

	if(FAILED(hr))
		return hr;

	//
	// Save the CookDown file name
	//

	m_wszCookDownFile = i_wszCookDownFile;

	//
	// Create CLBIST pointer.
	//

    QueryCellCLB[0].pData     = (LPVOID)m_wszCookDownFile;
    QueryCellCLB[0].eOperator = eST_OP_EQUAL;
    QueryCellCLB[0].iCell     = iST_CELL_FILE;
    QueryCellCLB[0].dbType    = DBTYPE_WSTR;
    QueryCellCLB[0].cbSize    = (lstrlenW(m_wszCookDownFile)+1)*sizeof(WCHAR);


	hr = m_pISTDisp->GetTable(wszDATABASE_IIS,
							  m_wszTable,
							  (LPVOID)QueryCellCLB,
							  (LPVOID)&cCellCLB,
							  eST_QUERYFORMAT_CELLS,
							  fST_LOS_READWRITE | fST_LOS_COOKDOWN,
							  (LPVOID *)&m_pISTCLB);


	if(FAILED(hr))
		return hr;


	//
	// Initialize Meta information.
	//

	hr = InitializeMeta();

	//
	// Create the arrays to compute and store obsolete row information.
	//

	m_paiReadRowPresent = new Array<ULONG>;
	
	if(m_paiReadRowPresent == NULL)
	{ 
		return E_OUTOFMEMORY; 
	}

	m_paiReadRowObsolete = new Array<ULONG>;
	
	if(m_paiReadRowObsolete == NULL)
	{ 
		return E_OUTOFMEMORY; 
	}

	return hr;

} // CMBBaseCooker::BeginCookDown


HRESULT CMBBaseCooker::InitializeMeta()
{
	HRESULT       hr;
	ULONG         i			 = 0;
	DWORD	      iWriteRow	 = 0;
	
	//
	// Get count of columns
	//

	hr = m_pISTCLB->GetTableMeta(NULL,
                                 NULL,
                                 NULL,
                                 &m_cCol);
	if(FAILED(hr))
		return hr;

	//
	// Allocate memory for the various column meta structures.
	//

	m_apv = new LPVOID[m_cCol];
	if(NULL == m_apv)
	{
		return E_OUTOFMEMORY;
	}

	for(i=0; i<m_cCol; i++)
	{
		m_apv[i] = NULL;
	}

	m_acb = new ULONG[m_cCol];
	if(NULL == m_acb)
	{
		return E_OUTOFMEMORY;
	}

	for(i=0; i<m_cCol; i++)
	{
		m_acb[i] = 0;
	}

	m_aiCol = new ULONG[m_cCol];
	if(NULL == m_aiCol)
	{
		return E_OUTOFMEMORY;
	}

	//
	// Fill in meta structures allocated above
	//

	hr = m_pISTDisp->GetTable (wszDATABASE_META, 
							   wszTABLE_COLUMNMETA, 
							   (LPVOID)NULL, 
							   (LPVOID)NULL, 
							   eST_QUERYFORMAT_CELLS, 
							   0, 
							   (void**)(&m_pISTColumnMeta));


	if(FAILED(hr))
	{
		return hr;
	}

	for(i=0; i<m_cCol; i++)
	{
		LPVOID   a_pvColMeta[cCOLUMNMETA_NumberOfColumns];

		hr = FillInColumnMeta(m_pISTColumnMeta,
			                  m_wszTable,
			                  i,
			                  a_pvColMeta);

		if(FAILED(hr))
		{
			return hr;
		}

		switch(*(DWORD*)a_pvColMeta[iCOLUMNMETA_Type])
		{

		case DBTYPE_UI4:
		case DWORD_METADATA:
			m_apv[i] = new DWORD[1];
			m_acb[i] = sizeof(DWORD) * 1;
			break;

		case DBTYPE_WSTR:
		case STRING_METADATA:
		case EXPANDSZ_METADATA:
			m_apv[i] = new WCHAR[MAX_PATH];		// TODO: Figure out a reasonable MAX for WSTRs
			m_acb[i] = sizeof(WCHAR) * MAX_PATH;
			break;

		case DBTYPE_BYTES:
		case BINARY_METADATA:
		case MULTISZ_METADATA:
			m_apv[i] = new BYTE[1024];			// TODO: Figure out a reasonable MAX for WSTRs
			m_acb[i] = sizeof(BYTE) * 1024;
			break;

		default:
		// Since we are dealing with only metabase types, it should be sufficient to
		// check for them as opposed to all what catalog supports.
			ASSERT(0 && L"Invalid type encountered for a column in a WAS table, hence unable to preallocate");
			break;
		}

		if(NULL == m_apv[i])
		{
			return E_OUTOFMEMORY;
		}
									   
	}

	m_pOSVersionInfo = new OSVERSIONINFOEX;
	if(NULL == m_pOSVersionInfo)
		return E_OUTOFMEMORY;

	m_pOSVersionInfo->dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

	if(!GetVersionEx((LPOSVERSIONINFO)m_pOSVersionInfo))
		return HRESULT_FROM_WIN32(GetLastError());

	return S_OK;

} // CMBBaseCooker::InitializeMeta


HRESULT CMBBaseCooker::GetData(WCHAR*  i_wszPath)
{
	HRESULT hr = S_OK;

	for(ULONG i=0; i<m_cCol; i++)
	{
	    METADATA_RECORD mdr;
		DWORD           dwRequiredDataLen = 0;
		LPVOID          a_pvColMeta[cCOLUMNMETA_NumberOfColumns];

		hr = FillInColumnMeta(m_pISTColumnMeta,
			                  m_wszTable,
			                  i,
			                  a_pvColMeta);

		if(FAILED(hr))
		{
			return hr;
		}

		if(!IsMetabaseProperty(*(DWORD*)a_pvColMeta[iCOLUMNMETA_ID]))
		{
			continue;
		}

		hr = GetDataFromMB(i_wszPath,
						   *(DWORD*)a_pvColMeta[iCOLUMNMETA_ID],
					 	   METADATA_INHERIT,
					  	   ALL_METADATA,
					 	   GetMetabaseType(*(DWORD*)a_pvColMeta[iCOLUMNMETA_Type],
						                   *(DWORD*)a_pvColMeta[iCOLUMNMETA_MetaFlags]),
					 	   (BYTE**)(&(m_apv[i])),
					 	   &(m_acb[i]),
					 	   FALSE);

		if(FAILED(hr))
		{
			return hr;
		}
	}

	return hr;

} // CMBBaseCooker::GetData


//
// Consider the following scenario valid/invalid scenarios:
// Insert Update Delete
// Insert Delete Update
// Update Insert Delete
// Update Delete Insert
// Delete Insert Update
// Delete Update Insert 
//

HRESULT	CMBBaseCooker::CopyRows(LPVOID*	           i_aIdentity,
								WAS_CHANGE_OBJECT* i_pWASChngObj,
								BOOL*              o_bNewRowAdded)
{

	HRESULT  hr             = S_OK;
	ULONG    cColChanged	= 0;
	ULONG    iReadRow		= 0;
	ULONG    iWriteRow		= 0;
	ULONG*	 acb            = NULL;
	LPVOID*	 apv            = NULL;
	CComPtr<ISimpleTableController> spISTController;
	BOOL     bFoundInReadCache = FALSE;
	DWORD	eAction            = eST_ROW_IGNORE;
	DWORD   eNewAction         = eST_ROW_IGNORE;

	//
	// Always intialize array with column ordianls each time, as they can be
	// overwritten in CompareRows.
	//

	for(ULONG i=0; i<m_cCol; i++)
		m_aiCol[i] = i;

	hr = m_pISTCLB->QueryInterface(IID_ISimpleTableController,
								   (void**)&spISTController);

	if(FAILED(hr))
		return hr;

	hr = m_pISTCLB->GetRowIndexByIdentity (NULL, 
										   i_aIdentity, 
										   &iReadRow);

	if(SUCCEEDED(hr))
	{
		//
		// The row that is being modified is present in the read cache, 
		// compute the columns that have changed.
		//

		hr = CompareRows(iReadRow,
			             i_pWASChngObj,
						 &cColChanged,		// returns the count of the actual changed columns
						 &apv,				// Initialized with m_apv, optimized for single column writes per IST semantics.
						 &acb);				// Initialized with m_acb for reqd byte columns, optimized for single column writes per IST semantics.

		if(FAILED(hr))
			return hr;

		bFoundInReadCache = TRUE;

		TRACE(L"Cooking down an existing row in table %s.\n", m_wszTable);

		hr = AddReadRowIndexToPresentList(iReadRow);

		if(FAILED(hr))
		{
			TRACE(L"AddReadRowIndexToPresentList failed with hr=0x%x.\n", hr);
			return hr;
		}
		
	}
	else if(E_ST_NOMOREROWS == hr)
	{
		//
		// The row that is being modified is absent in the read cache.
		// Hence we assume that all columns need to be written.
		//

		cColChanged = m_cCol;	// Copy all columns
		apv = m_apv;
		acb = m_acb;
	}
	else
	{
		return hr;
	}

	//
	// Check to see if the row being modified is already in the write cache.
	// This can happen in the following scenarios:
	// Insert, Update
	// Update, Delete
	// Delete, Insert
	// Update, Update
	// Insert, Delete
	//

	hr = m_pISTCLB->GetWriteRowIndexByIdentity (NULL, 
												i_aIdentity, 
												&iWriteRow);


	if (E_ST_NOMOREROWS == hr)
	{
		//
		// Did not find the row being modified in the write cache. Can conclude
		// that its an insert.
		//

		if(bFoundInReadCache)
		{
			if(cColChanged == 0)
			{
				return S_OK;
			}
			TRACE(L"Cooking down an existing row in table %s.\n", m_wszTable);
			hr = m_pISTCLB->AddRowForUpdate(iReadRow,
				                            &iWriteRow);

		}
		else
		{
			TRACE(L"Cooking down a new row in table %s.\n", m_wszTable);
			hr = m_pISTCLB->AddRowForInsert (&iWriteRow);

			if(NULL != o_bNewRowAdded)
			{
				*o_bNewRowAdded = TRUE;
			}
		}

		if(FAILED(hr))
			return hr;


	}
	else if(FAILED(hr))
	{
		return hr;
	}
	else
	{
		//
		// Found the row being modified in the write cache. Update the row 
		// action appropriately.
		//

		hr = spISTController->GetWriteRowAction(iWriteRow,
											    &eAction);

		if(FAILED(hr))
			return hr;

		if((eAction == eST_ROW_DELETE) || 
		   (eAction == eST_ROW_IGNORE)
		  )
		{
			if(bFoundInReadCache)
			{
				eNewAction = eST_ROW_UPDATE;
			}
			else
			{
				eNewAction = eST_ROW_INSERT;   // Can happen when there is an insert, delete, insert.
			}
		}
		else if(eAction == eST_ROW_UPDATE)
		{
			if(!bFoundInReadCache)
			{
				TRACE(L"Found a row for update in the write cache, but not in the read cache. Changing to insert\n");
				eNewAction = eST_ROW_INSERT;
			}
			else
			{
				eNewAction = eST_ROW_UPDATE;
			}
		}
		else if(eAction == eST_ROW_INSERT)
		{
			if(bFoundInReadCache)
			{
				TRACE(L"Found a row for insert write cache, but also found in the read cache. Changing to update\n");
				eNewAction = eST_ROW_UPDATE;
			}
			else
			{
				eNewAction = eST_ROW_INSERT;
			}
		}

		hr = spISTController->SetWriteRowAction(iWriteRow,
											    eNewAction);

		if(FAILED(hr))
			return hr;

	}

	if(cColChanged == 0)
	{
		//
		// At this point check to see if nothing changed, if so, then set to ignore.
		//

		hr = spISTController->SetWriteRowAction(iWriteRow,
											    eST_ROW_IGNORE);

		return hr;
	}

	if((NULL != o_bNewRowAdded) && (eNewAction == eST_ROW_INSERT))
	{
		*o_bNewRowAdded = TRUE;
	}

	hr = m_pISTCLB->SetWriteColumnValues(iWriteRow,
										 cColChanged, 
			                             m_aiCol, 
										 acb, 
										 apv);

	return hr;

} // CMBBaseCooker::CopyRows


HRESULT CMBBaseCooker::CompareRows(ULONG		      i_iReadRow,
					               WAS_CHANGE_OBJECT* i_pWASChngObj,
								   ULONG*		      o_pcColChanged,
								   LPVOID**		      o_apv,
								   ULONG**		      o_acb)
{	
	HRESULT				hr							= S_OK;
	ULONG				a_Fixedcb[cmaxCOLUMNS];
	LPVOID				a_Fixedpv[cmaxCOLUMNS];
	SimpleColumnMeta	a_FixedColumnMeta[cmaxCOLUMNS];
	ULONG*				a_cb						= NULL;
	LPVOID*				a_pv						= NULL;
	SimpleColumnMeta*	a_ColumnMeta				= NULL;
	ULONG				iCol						= 0;

	if(m_cCol <= cmaxCOLUMNS)	// Allocate WRT cColDest as count of dest columns are always greater than source columns
	{
		a_cb			= a_Fixedcb;
		a_pv			= a_Fixedpv;
		a_ColumnMeta	= a_FixedColumnMeta;
	}
	else
	{
		a_cb = NULL;
		a_cb = new ULONG[m_cCol];
		if(!a_cb) {hr = E_OUTOFMEMORY; goto exit;}

		a_pv = NULL;
		a_pv = new LPVOID[m_cCol];
		if(!a_pv) {hr = E_OUTOFMEMORY; goto exit;}

		a_ColumnMeta = NULL;
		a_ColumnMeta = new SimpleColumnMeta[m_cCol];
		if(!a_ColumnMeta) {hr = E_OUTOFMEMORY; goto exit;}

		
	}

	//
	// Get the original read row which is present in the read cache.
	//

	hr = m_pISTCLB->GetColumnValues(i_iReadRow,
									m_cCol,
									NULL,
									a_cb,
									a_pv);

	if(FAILED(hr))
		goto exit;

	//
	// Get the column meta
	//

	hr = m_pISTCLB->GetColumnMetas(m_cCol, 
								   NULL,				// TODO: Check if this works.
								   a_ColumnMeta);

	if(FAILED(hr))
		goto exit;

	//
	// Compare each column and Update only if something has changed.
	//

	for(iCol=0, *o_pcColChanged=0; iCol<m_cCol; iCol++)
	{
		BOOL bColChanged = FALSE;
		
		LPVOID pvMB  = m_apv[iCol];
		ULONG  cbMB  = m_acb[iCol];

		//
		// If there is no value, then we should compare 
		// with the default value.
		//

		if(NULL == m_apv[iCol])
		{
			hr = GetDefaultValue(iCol,
				                 &pvMB,
				                 &cbMB);

			if(FAILED(hr))
				goto exit;
		}

		if((NULL != a_pv[iCol]) && (NULL != pvMB))
		{
			switch(a_ColumnMeta[iCol].dbType)
			{
			case DBTYPE_UI4:

				if( * (ULONG*)(a_pv[iCol]) != * (ULONG*)(pvMB) )
					bColChanged = TRUE;
				break;

			case DBTYPE_WSTR:

				if(0 != Wszlstrcmpi((LPWSTR)(a_pv[iCol]), (LPWSTR)(pvMB)))
					bColChanged = TRUE;
				break;

			case DBTYPE_BYTES:
				
				if(a_cb[iCol] != cbMB)
					bColChanged = TRUE;
				else if(0 != memcmp((BYTE*)(a_pv[iCol]), (BYTE*)(pvMB), cbMB))
					bColChanged = TRUE;
				break;

			case DBTYPE_GUID:

				if( * (GUID*)(a_pv[iCol]) != * (GUID*)(pvMB) )
					bColChanged = TRUE;
				break;

			default:
				ASSERT(0 && "Unknown DBTYPE");
				hr = HRESULT_FROM_WIN32(ERROR_UNSUPPORTED_TYPE);
				goto exit;
			}
		}
		else if(NULL == pvMB)
		{
			if(NULL != a_pv[iCol])
				bColChanged = TRUE;
		}
		else	
		{
			//
			// means that a_pvDestRead[iColDest] is null & i_apvDest[iColDest]  
			// is non null
			//

			bColChanged = TRUE;	
		}


		if((!bColChanged) && NotifyWhenNoChangeInValue(iCol,i_pWASChngObj))
		{
			bColChanged = TRUE;
		}

		if(bColChanged)
		{
			m_aiCol[(*o_pcColChanged)++] = iCol;
		}
		else
			;  //
			   // Donot reset the column value if it has not changed, as it may
			   // be needed later.
			   //

	}

	if(1 == *o_pcColChanged)
	{

		//
		// Special case single columns because of IST optimization.
		// The value for single columns is always set in the 0th column.
		//

		*o_apv = &m_apv[m_aiCol[0]];
		*o_acb = &m_acb[m_aiCol[0]];
	}
	else
	{
		*o_apv = m_apv;
		*o_acb = m_acb;

	}

exit:

	if(m_cCol > cmaxCOLUMNS)
	{
		if(NULL != a_cb)
		{
			delete [] a_cb;
			a_cb = NULL;
		}

		if(NULL != a_pv)
		{
			delete [] a_pv;
			a_pv = NULL;
		}

		if(NULL != a_ColumnMeta)
		{
			delete [] a_ColumnMeta;
			a_ColumnMeta = NULL;
		}

	}

	return hr;

} // CMBBaseCooker::CompareRows


HRESULT	CMBBaseCooker::DeleteRow(LPVOID*	i_aIdentity)
{

	CComPtr<ISimpleTableController> spISTController;
	HRESULT  hr             = S_OK;
	ULONG    iReadRow		= 0;
	ULONG    iWriteRow		= 0;
	BOOL     bFoundRowInReadCache = FALSE;
	BOOL     bFoundRowInWriteCache = FALSE;

	hr = m_pISTCLB->QueryInterface(IID_ISimpleTableController,
								   (void**)&spISTController);
	if(FAILED(hr))
	{
		return hr;
	}

	//
	// Find the row to be deleted in the read cache
	//

	hr = m_pISTCLB->GetRowIndexByIdentity (NULL, 
										   i_aIdentity, 
										   &iReadRow);

	if(SUCCEEDED(hr))
	{
		bFoundRowInReadCache = TRUE;
	}
	else if(E_ST_NOMOREROWS == hr)
	{
		bFoundRowInReadCache = FALSE;
		hr = S_OK;
	}
	else
	{
		return hr;
	}

	//
	// Try and see if it's already in the write cache. This could happen when one deletes a row
	// that has been just added, or if it has been added for update
	//

	hr = m_pISTCLB->GetWriteRowIndexByIdentity (NULL, 
												i_aIdentity, 
												&iWriteRow);

	if(SUCCEEDED(hr))
	{
		bFoundRowInWriteCache = TRUE;
	}
	else if (E_ST_NOMOREROWS == hr)
	{
		bFoundRowInWriteCache = FALSE;
		hr = S_OK;

	}
	else
	{
		return hr;
	}

	if(!bFoundRowInReadCache && !bFoundRowInWriteCache)
	{
		TRACE(L"Attempted to delete a non-existent row in table %s.\n", m_wszTable);
		return S_OK;
	}
	else if(bFoundRowInReadCache && !bFoundRowInWriteCache)
	{
		hr = m_pISTCLB->AddRowForDelete (iReadRow);

		if(FAILED(hr))
			return hr;

		TRACE(L"Deleting an existing row in table %s.\n", m_wszTable);
		
	}
	else if(bFoundRowInReadCache && bFoundRowInWriteCache)
	{
		hr = spISTController->SetWriteRowAction(iWriteRow,
											    eST_ROW_DELETE);
		if(FAILED(hr))
			return hr;

		TRACE(L"Deleting an existing row in table %s.\n", m_wszTable);
		
	}
	else if(!bFoundRowInReadCache && bFoundRowInWriteCache)
	{
		hr = spISTController->SetWriteRowAction(iWriteRow,
											    eST_ROW_IGNORE);
		if(FAILED(hr))
			return hr;

		TRACE(L"Deleting an existing row (that has just been added) in table %s.\n", m_wszTable);

	}

	return hr;

} // CMBBaseCooker::DeleteRow


HRESULT CMBBaseCooker::Cookable(LPCWSTR	                    i_wszCookDownFile,
								BOOL*	                    o_pbCookable,
								WIN32_FILE_ATTRIBUTE_DATA*  io_pFileAttr,
		                        DWORD*	                    o_pdwChangeNumber)
{

	HRESULT							hr;
	CComPtr<IMSAdminBase>			spIMSAdminBase;
	CComPtr<ISimpleTableDispenser2>	spISTDisp;
	CComPtr<ISimpleTableRead2>		spISTChangeNumber;
	STQueryCell						QueryCell[1];
	ULONG							cCell                = sizeof(QueryCell)/sizeof(QueryCell[0]);
	ULONG							iRow                 = 0;
	ULONG                           a_iCol[]             = {iCHANGENUMBER_ChangeNumber,
		                                                    iCHANGENUMBER_TimeStamp
	};
	ULONG                           cCol                 = sizeof(a_iCol)/sizeof(a_iCol[0]);
	LPVOID                          a_pv[cCHANGENUMBER_NumberOfColumns];
	WCHAR*                          wszMetabaseFile      = NULL;
	SIZE_T                          cch                  = wcslen(i_wszCookDownFile);
	BOOL                            bChangeNumberChanged = TRUE;
	BOOL                            bTimeStampChanged    = TRUE;

	*o_pbCookable = TRUE;
	*o_pdwChangeNumber = 0;
	memset(io_pFileAttr, 0, sizeof(FILETIME));
	memset(a_pv,0,sizeof(a_pv));

	// 
	// We cannot rely on the m_pIMSAdminBase object to be instantiated at
	// this point because this function is called before we initialize 
	// anything.
	//

	hr = CoCreateInstance(CLSID_MSAdminBase,           // CLSID
                          NULL,                        // controlling unknown
                          CLSCTX_SERVER,               // desired context
                          IID_IMSAdminBase,            // IID
                          (void**)&spIMSAdminBase);     // returned interface

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr,ID_CAT_CAT,IDS_COMCAT_COOKDOWN_INTERNAL_ERROR,NULL));
		return hr;
	}

	hr = spIMSAdminBase->GetSystemChangeNumber(o_pdwChangeNumber);

	if(FAILED(hr))
		return hr;

	// 
	// We cannot rely on the m_pISTDisp object to be instantiated at
	// this point because this function is called before we initialize 
	// anything.
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &spISTDisp);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr,ID_CAT_CAT,IDS_COMCAT_COOKDOWN_INTERNAL_ERROR,NULL));
		return hr;
	}

    QueryCell[0].pData     = (LPVOID)i_wszCookDownFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(i_wszCookDownFile)+1)*sizeof(WCHAR);

	hr = spISTDisp->GetTable(wszDATABASE_IIS,
						     wszTABLE_CHANGENUMBER,
							 (LPVOID)QueryCell,
							 (LPVOID)&cCell,
							 eST_QUERYFORMAT_CELLS,
							 0,
							 (LPVOID *)&spISTChangeNumber);

	if(FAILED(hr))
	{
		if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
		{
			hr = S_OK;
		}
		return hr;
	}
	else
	{
		hr = spISTChangeNumber->GetColumnValues(iRow,
											    cCol,
											    a_iCol,
											    NULL,
											    (LPVOID*)a_pv);

		if(FAILED(hr))
		{
			if(E_ST_NOMOREROWS == hr)
			{
				hr = S_OK;
			}
			return hr;
		}
		else if(*(DWORD*)a_pv[iCHANGENUMBER_ChangeNumber] == *o_pdwChangeNumber)
		{
			bChangeNumberChanged = FALSE;
		}
	}


	//
	// We look at the timestamp of the XML file as well as the system change
	// number to determine if we need to cookdown. The reason is because 
	// if a user edits the xml file when the server is down, the change 
	// number doesnt change, and only the timestamp changes.
	//

	hr = GetMetabaseFile(&wszMetabaseFile);

	if(FAILED(hr))
	{
		return hr;
	}

	if(GetFileAttributesEx(wszMetabaseFile,
				           GetFileExInfoStandard,
					       io_pFileAttr)
	  )
	{
		if((NULL != a_pv[iCHANGENUMBER_TimeStamp]) &&
		   (0 == CompareFileTime((FILETIME*)a_pv[iCHANGENUMBER_TimeStamp],
						         &(io_pFileAttr->ftLastWriteTime))
		   )
		  )
		{
			bTimeStampChanged = FALSE;
		}

	}

	delete [] wszMetabaseFile;
	wszMetabaseFile = NULL;

	if(!bChangeNumberChanged && !bTimeStampChanged)
	{
		*o_pbCookable = FALSE;
	}

	return hr;
}


HRESULT CMBBaseCooker::UpdateChangeNumber(LPCWSTR	i_wszCookDownFile,
										  DWORD		i_dwChangeNumber,
										  BYTE*     i_pbTimeStamp,
										  DWORD     i_dwLOS)
{

	CComPtr<ISimpleTableDispenser2>	spISTDisp;
	CComPtr<ISimpleTableWrite2>		spISTChangeNumber;
	STQueryCell						QueryCell[1];
	ULONG							cCell = sizeof(QueryCell)/sizeof(QueryCell[0]);
	ULONG							iReadRow = 0;
	ULONG							iWriteRow = 0;
	ULONG                           a_iCol[] = {iCHANGENUMBER_ChangeNumber,
		                                        iCHANGENUMBER_TimeStamp
	};
	ULONG                           cCol = sizeof(a_iCol)/sizeof(a_iCol[0]);
	LPVOID                          a_pv[cCHANGENUMBER_NumberOfColumns];
	HRESULT							hr;
	DWORD*							pdwChangeNumber = &i_dwChangeNumber;
	LPVOID                          a_pvWrite[cCHANGENUMBER_NumberOfColumns];
	ULONG                           a_cbWrite[cCHANGENUMBER_NumberOfColumns];
	a_pvWrite[iCHANGENUMBER_ChangeNumber] = (LPVOID)&i_dwChangeNumber;
	a_pvWrite[iCHANGENUMBER_TimeStamp]    = i_pbTimeStamp;

	// 
	// We cannot rely on the m_pISTDisp object to be instantiated at
	// this point because this function is called before we initialize 
	// anything.
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &spISTDisp);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, 
			              ID_CAT_CAT, 
						  IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, 
						  NULL));
		return hr;
	}

    QueryCell[0].pData     = (LPVOID)i_wszCookDownFile;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = iST_CELL_FILE;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(i_wszCookDownFile)+1)*sizeof(WCHAR);

	hr = spISTDisp->GetTable(wszDATABASE_IIS,
						     wszTABLE_CHANGENUMBER,
							 (LPVOID)QueryCell,
							 (LPVOID)&cCell,
							 eST_QUERYFORMAT_CELLS,
							 i_dwLOS,
							 (LPVOID *)&spISTChangeNumber);

	if(FAILED(hr))
		return hr;

	hr = spISTChangeNumber->GetColumnValues(iReadRow,
										   cCol,
										   a_iCol,
										   NULL,
										   (LPVOID*)a_pv);

	if(E_ST_NOMOREROWS == hr) 
		hr = spISTChangeNumber->AddRowForInsert(&iWriteRow);
	else if(SUCCEEDED(hr))
	{
		if((*(DWORD*)a_pv[iCHANGENUMBER_ChangeNumber]) != i_dwChangeNumber)
		{
			hr = spISTChangeNumber->AddRowForDelete(iReadRow);
	
			if(FAILED(hr))
				return hr;

			hr = spISTChangeNumber->AddRowForInsert(&iWriteRow);
		}
		else
		{
			hr = spISTChangeNumber->AddRowForUpdate(iReadRow,
				                                    &iWriteRow);

			if(FAILED(hr))
				return hr;
		}

	}
	  
	if(FAILED(hr))
		return hr;

	a_cbWrite[iCHANGENUMBER_ChangeNumber] = sizeof(DWORD);
	a_cbWrite[iCHANGENUMBER_TimeStamp] = sizeof(FILETIME);

	hr = spISTChangeNumber->SetWriteColumnValues(iWriteRow,
		                                         cCol,
												 a_iCol,
												 a_cbWrite,
												 (LPVOID*)a_pvWrite);

	if(FAILED(hr))
		return hr;

	hr = spISTChangeNumber->UpdateStore();

	return hr;

} // CMBBaseCooker::UpdateChangeNumber


HRESULT CMBBaseCooker::GetMetabaseFile(LPWSTR* o_wszMetabaseFile)
{
	HRESULT hr                     = S_OK;
	static LPCWSTR wszMetabaseDir  = L"%windir%\\system32\\inetsrv\\";
	static LPCWSTR wszAdminRegKey  = L"SOFTWARE\\Microsoft\\INetMgr\\Parameters";
	static LPCWSTR wszFileValue    = L"MetadataFile";
	ULONG   cchWithNullMetabaseDir = 0;
	DWORD   dwRes                  = ERROR_SUCCESS;
	DWORD   dwType                 = 0;
    HKEY    hkRegistryKey          = NULL;
	ULONG   cbSize                 = 0;

	//
	// First look in the registry for the cookdown file. If not found then 
	// assume the %windir%\system32\inetsrv directory.
	//

    dwRes = RegOpenKey(HKEY_LOCAL_MACHINE,
                       wszAdminRegKey,
                       &hkRegistryKey);

    if (dwRes == ERROR_SUCCESS) 
	{
        dwRes = RegQueryValueEx(hkRegistryKey,
                                wszFileValue,
                                NULL,
                                &dwType,
                                NULL,
                                &cbSize);

		if((dwRes == ERROR_SUCCESS) && (0 != cbSize))
		{
			cchWithNullMetabaseDir = cbSize/sizeof(WCHAR);

			*o_wszMetabaseFile = new WCHAR[cchWithNullMetabaseDir+1];
			if(NULL == *o_wszMetabaseFile)
			{
				hr = E_OUTOFMEMORY;
				goto exit;
			}

			dwRes = RegQueryValueEx(hkRegistryKey,
									wszFileValue,
									NULL,
									&dwType,
									(LPBYTE)*o_wszMetabaseFile,
									&cbSize);

			if ((dwRes == ERROR_SUCCESS) && dwType == (REG_SZ)) 
			{
				hr = S_OK;
				goto exit;
			}

		}

        RegCloseKey(hkRegistryKey);
        hkRegistryKey = NULL;

    }


	//
	// Not found in registry - construct from inetsrv
	// 

	*o_wszMetabaseFile = NULL;

	cchWithNullMetabaseDir = ExpandEnvironmentStrings(wszMetabaseDir,
		                                      NULL,
								              0);

	if(!cchWithNullMetabaseDir)
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		goto exit;
	}

	cchWithNullMetabaseDir += CCH_METABASE_FILE;

	*o_wszMetabaseFile = new WCHAR[cchWithNullMetabaseDir+1];
	if(NULL == *o_wszMetabaseFile)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	cchWithNullMetabaseDir = ExpandEnvironmentStrings(wszMetabaseDir,
		                                              *o_wszMetabaseFile,
								                      cchWithNullMetabaseDir);

	if(!cchWithNullMetabaseDir)
	{
		hr = GetLastError();
		hr = HRESULT_FROM_WIN32(hr);
		goto exit;
	}

	if(L'\\' != (*o_wszMetabaseFile)[cchWithNullMetabaseDir-2])
	{
		(*o_wszMetabaseFile)[cchWithNullMetabaseDir-1] = L'\\';
		(*o_wszMetabaseFile)[cchWithNullMetabaseDir]   = L'\0';
	}

	wcscat(*o_wszMetabaseFile, WSZ_METABASE_FILE);

exit:

	if(FAILED(hr) && (NULL != *o_wszMetabaseFile))
	{
		delete [] *o_wszMetabaseFile;
		*o_wszMetabaseFile = NULL;
	}

	if(NULL != hkRegistryKey)
	{
        RegCloseKey(hkRegistryKey);
        hkRegistryKey = NULL;
	}

	return hr;

} // CMBBaseCooker::GetMetabaseFile


HRESULT CMBBaseCooker::ReadFilterFlags(LPCWSTR	i_wszFilterFlagsRootPath,
                                       DWORD**  io_pdwFilterFlags,
									   ULONG*   io_cbFilterFlags)
{
	HRESULT			hr					= S_OK;
	WCHAR			wszBufferFixed[MAX_PATH];
	ULONG			cchBuffer			= MAX_PATH;
	ULONG			cchBufferReqd		= 0;
	WCHAR*			wszBuffer			= wszBufferFixed;
	WCHAR*			wszPath             = NULL;
	DWORD			dwFilterFlags       = 0;
    METADATA_RECORD	mdr;
	DWORD			dwFlag              = 0;
	DWORD*          pdwFlag             = &dwFlag;
	DWORD           cbFlag              = sizeof(DWORD);

	//
	// Get all the paths below i_wszFilterFlagsRootPath that contain the 
	// MD_FILTER_FLAGS
	//

	hr = GetDataPaths(i_wszFilterFlagsRootPath,
					  MD_FILTER_FLAGS,
					  DWORD_METADATA,
					  &wszBuffer,
					  cchBuffer);

	if(HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND) == hr)
	{
		if(NULL != *io_pdwFilterFlags)
		{
			delete [] *io_pdwFilterFlags;
			*io_pdwFilterFlags = NULL;
			*io_cbFilterFlags = 0; 
		}

		hr = S_OK;
		goto exit;
	}
	else if(FAILED(hr))
	{
		goto exit;
	}

	//
	// Get the filter flags from the individual paths
	//

	wszPath			   = wszBuffer;
	mdr.dwMDIdentifier = MD_FILTER_FLAGS;
	mdr.dwMDAttributes = METADATA_INHERIT;
	mdr.dwMDUserType   = IIS_MD_UT_SERVER;
	mdr.dwMDDataType   = DWORD_METADATA;
	mdr.dwMDDataLen    = sizeof(DWORD);
	mdr.pbMDData       = (BYTE*)&dwFlag;

	while(*wszPath != 0)
	{
		dwFlag  = 0;
		pdwFlag = &dwFlag;
		cbFlag  = sizeof(DWORD);

		hr = GetDataFromMB(wszPath,
						   MD_FILTER_FLAGS,
					 	   METADATA_INHERIT,
					  	   IIS_MD_UT_SERVER,
					 	   DWORD_METADATA,
					 	   (BYTE**)&pdwFlag,
					 	   &cbFlag,
					 	   TRUE);

		// TODO: ASSERT (pdwFlag != &dwFlag)

		if(SUCCEEDED(hr))
		{
			dwFilterFlags = dwFilterFlags | *pdwFlag;
		}
		else
		{
			//
			// TODO: Assert that ERROR_INSUFFICIENT_BUFFER is not returned.
			//

			goto exit;
		}

		wszPath = wszPath + wcslen(wszPath) + 1;
	}

	if(NULL == *io_pdwFilterFlags)
	{
		*io_pdwFilterFlags = new DWORD[1];
		if(NULL == *io_pdwFilterFlags)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		*io_cbFilterFlags = sizeof(DWORD) * 1;

	}

	*(*io_pdwFilterFlags) = dwFilterFlags;

exit:

	if(wszBuffer != wszBufferFixed)
	{
		delete [] wszBuffer;
		wszBuffer = NULL;
	}

	return hr;

} // CMBBaseCooker::ReadFilterFlags


HRESULT CMBBaseCooker::GetDataPaths(LPCWSTR	i_wszRoot,
									DWORD	i_dwIdentifier,
									DWORD	i_dwType,
									WCHAR** io_pwszBuffer,
									DWORD   i_cchBuffer)
{
	HRESULT hr				= S_OK;
	DWORD   cchBufferReqd	= 0;
	
	**io_pwszBuffer	= 0;

	hr = m_pIMSAdminBase->GetDataPaths(m_hMBHandle,
									   i_wszRoot,
									   i_dwIdentifier,
									   i_dwType,
									   i_cchBuffer,
									   *io_pwszBuffer,
									   &cchBufferReqd);

	if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
	{
		hr = S_OK;

		*io_pwszBuffer = new WCHAR[cchBufferReqd];
		
		if(NULL == *io_pwszBuffer)
		{
			hr = E_OUTOFMEMORY;
			return hr;
		}
		
		i_cchBuffer = cchBufferReqd;

		hr = m_pIMSAdminBase->GetDataPaths(m_hMBHandle,
										   i_wszRoot,
										   i_dwIdentifier,
										   i_dwType,
										   i_cchBuffer,
										   *io_pwszBuffer,
										   &cchBufferReqd);

	}
	
	return hr;

} // CMBBaseCooker::GetDataPaths


HRESULT CMBBaseCooker::GetDataFromMB(WCHAR*  i_wszPath,
									 DWORD   i_dwID,
									 DWORD   i_dwAttributes,
									 DWORD   i_dwUserType,
									 DWORD   i_dwType,
									 BYTE**  io_pBuff,
									 ULONG*  io_pcbBuff,
									 BOOL    i_BuffStatic)
{
	HRESULT			hr					= S_OK;
	METADATA_RECORD mdr;
	DWORD           dwRequiredDataLen	= 0;

	mdr.dwMDIdentifier = i_dwID;
	mdr.dwMDAttributes = i_dwAttributes;
	mdr.dwMDUserType   = i_dwUserType;
	mdr.dwMDDataType   = i_dwType;
	mdr.dwMDDataLen    = *io_pcbBuff;
	mdr.pbMDData       = *io_pBuff;

	hr = m_pIMSAdminBase->GetData(m_hMBHandle,
								  i_wszPath,
								  &mdr,
								  &dwRequiredDataLen);

	if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
	{
		//
		// Resize the pv buffer and retry. 
		//

		if((NULL != *io_pBuff) && (!i_BuffStatic))
		{
			delete [] *io_pBuff;
			*io_pBuff = NULL;
		}
		*io_pcbBuff			= 0;

		*io_pBuff = new BYTE[dwRequiredDataLen];
		if(NULL == *io_pBuff)
		{
			hr = E_OUTOFMEMORY;
			return hr;
		}
		*io_pcbBuff			= dwRequiredDataLen;

		mdr.dwMDDataLen		= *io_pcbBuff;
		mdr.pbMDData		= (BYTE *) *io_pBuff;

		hr = m_pIMSAdminBase->GetData(m_hMBHandle,
									  i_wszPath,
									  &mdr,
									  &dwRequiredDataLen);

	}

	//
	// If data type is binary metadata or multisz metadata, then store 
	// the size as it will be needed while writing into clb.
	//

	if((SUCCEEDED(hr)) && 
	   (BINARY_METADATA == mdr.dwMDDataType || MULTISZ_METADATA == mdr.dwMDDataType))
	{
		*io_pcbBuff = mdr.dwMDDataLen;
	}
	else if(MD_ERROR_DATA_NOT_FOUND == hr)
	{
		//
		// TODO: Is there a better way to handle this? We are undoing 
		// the effect of pre-allocation be doing this.
		//

		if((NULL != *io_pBuff) && (!i_BuffStatic))
		{
			delete [] *io_pBuff;
			*io_pBuff = NULL;
		}
		*io_pcbBuff	= 0;
		hr = S_OK;
	}

	return hr;

} // CMBBaseCooker::GetDataFromMB

HRESULT CMBBaseCooker::GetDefaultValue(ULONG   i_iCol,
									   LPVOID* o_apv,
									   ULONG*  o_cb)
{
	HRESULT hr = S_OK;
	LPVOID  a_Identity[] = {(LPVOID)m_wszTable,
	                        (LPVOID)&i_iCol
	};
	ULONG   iRow = 0;
	ULONG   iCol = iCOLUMNMETA_DefaultValue;

	*o_apv = NULL;
	*o_cb = 0;

	hr = m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
		                                         a_Identity,
												 &iRow);

	if(FAILED(hr))
		return hr;	// Should always find the row.

	hr = m_pISTColumnMeta->GetColumnValues(iRow,
		                                   1,
										   &iCol,
										   o_cb,
										   o_apv);

	return hr;

} // CMBBaseCooker::GetDefaultValue


HRESULT CMBBaseCooker::AddReadRowIndexToPresentList(ULONG i_iReadRow)
{
	HRESULT hr = S_OK;

	//
	// Save the read row index.
	//

	try
	{
		m_paiReadRowPresent->setSize(m_paiReadRowPresent->size()+1);
	}
	catch(...)
	{
		return E_OUTOFMEMORY;
	}

	(*m_paiReadRowPresent)[m_paiReadRowPresent->size()-1] = i_iReadRow;

	return S_OK;

} // CMBBaseCooker::AddReadRowIndexToPresentList


//
// Delete all rows from the read cache that are no longer present
// m_paiReadRowPresent has all the rows that are present.
//

HRESULT CMBBaseCooker::ComputeObsoleteReadRows()
{
	HRESULT  hr                = S_OK;
	ULONG    cMax              = m_paiReadRowPresent->size();
	ULONG    i                 = 0;
	ULONG    j                 = 0;
	ULONG*   a_iReadRowPresent = NULL;

	//
	// Sort the array (m_paiReadRowPresent) that contains
	// all the read row indicies of rows that are present.
	// then compute the obsolete read row indicies by 
	// looking at the missing read row indicies in the
	// array (m_paiReadRowPresent)
	//

	//
	// Sort m_paiReadRowPresent
	//

	a_iReadRowPresent = new ULONG[cMax];

	if(NULL == a_iReadRowPresent)
	{
		return E_OUTOFMEMORY;
	}

	for(i=0; i<cMax; i++)
	{
		a_iReadRowPresent[i] = (*m_paiReadRowPresent)[i];
	}

	qsort((void*)a_iReadRowPresent, cMax, sizeof(ULONG), MyIntCompare);

	//
	// Compute obsolete read row indicies.
	//

	for(i=0,j=0; i<cMax;)
	{
		if(j == a_iReadRowPresent[i])
		{
			i++;
			j++;
			continue;
		}
		else if(j < a_iReadRowPresent[i])
		{
			//
			// This means that we found a row in the read cache that
			// is obsolete
			//

			hr = AddReadRowIndexToObsoleteList(j);

			if(FAILED(hr))
			{
				goto exit;
			}

			j++;

			continue;
		}
		else
		{
			i++;
		}	
	}

	for(;;j++)
	{
		//
		// If the read cache has remaining rows, it means that the were
		// not found in m_paiReadRowPresent, hence they will need to be
		// deleted
		//

		ULONG  iCol = 0;
		LPVOID pv   = NULL;

		hr = m_pISTCLB->GetColumnValues(j,
			                            1,
										&iCol,
										NULL,
										&pv);

		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if(FAILED(hr))
		{
			goto exit;
		}

		hr = AddReadRowIndexToObsoleteList(j);

		if(FAILED(hr))
		{
			goto exit;
		}

	}

exit:

	if(NULL != a_iReadRowPresent)
	{
		delete [] a_iReadRowPresent;
		a_iReadRowPresent = NULL;
	}

	return S_OK;

} // CMBBaseCooker::ComputeObsoleteReadRows


HRESULT CMBBaseCooker::AddReadRowIndexToObsoleteList(ULONG i_iReadRow)
{
	HRESULT hr = S_OK;

	//
	// Save the read row index.
	//

	try
	{
		m_paiReadRowObsolete->setSize(m_paiReadRowObsolete->size()+1);
	}
	catch(...)
	{
		return E_OUTOFMEMORY;
	}

	(*m_paiReadRowObsolete)[m_paiReadRowObsolete->size()-1] = i_iReadRow;

	return S_OK;

} // CMBBaseCooker::AddReadRowIndexToPresentList


//
// This function is called when there is an error. The aim is to spew detailed errors,
// if any.
//

HRESULT CMBBaseCooker::GetDetailedErrors(DWORD i_hr)
{
	HRESULT hr = S_OK;
	CComPtr<ISimpleTableController> spISTAdvanced;
	WCHAR wszTemp[MAX_PATH*2];
	WCHAR wszRow[1024];

	hr = m_pISTCLB->QueryInterface(IID_ISimpleTableAdvanced,
								   (void**)&spISTAdvanced);

	if(FAILED(hr))
	{
        LOG_ERROR(Win32, (hr, 
			              ID_CAT_CAT, 
						  IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, 
						  NULL));

		return i_hr;
	}

	if(E_ST_DETAILEDERRS == i_hr)
	{
		ULONG cError = 0;

		hr = spISTAdvanced->GetDetailedErrorCount(&cError);

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, 
							  ID_CAT_CAT, 
							  IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, 
							  NULL));

			return i_hr;

		}

		for(ULONG i=0; i<cError; i++)
		{
			STErr stError;

			hr = spISTAdvanced->GetDetailedError(i,
				                                 &stError);

			if(FAILED(hr))
			{
				LOG_ERROR(Win32, (hr, 
								  ID_CAT_CAT, 
								  IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, 
								  NULL));
				continue;
			}

			//
			// Convert the primary key to a string and log details.
			//

			wszRow[0] = 0;

			for(ULONG j=0; j<m_cCol; j++)
			{
				ULONG  iReadRow     = 0;
				LPVOID a_Identity[] = {(LPVOID)m_wszTable,
									   (LPVOID)&j
				};
				ULONG  a_iCol []    = {iCOLUMNMETA_InternalName,
					                   iCOLUMNMETA_MetaFlags,
					                   iCOLUMNMETA_Type
				};
				ULONG  cCol         = sizeof(a_iCol)/sizeof(a_iCol[0]);
				LPVOID a_pv[cCOLUMNMETA_NumberOfColumns];
				WCHAR  wszDWORD[20];
				LPVOID pv           = NULL;

				//
				// Check the meta for each column
				//

				hr = m_pISTColumnMeta->GetRowIndexByIdentity(NULL,
															 a_Identity,
															 &iReadRow);
				if(FAILED(hr))
					continue;

				hr = m_pISTColumnMeta->GetColumnValues(iReadRow,
													   cCol,
													   a_iCol,
													   NULL,
													   (LPVOID*)a_pv);

				if(FAILED(hr))
					continue;

				if(((*(DWORD*)a_pv[iCOLUMNMETA_MetaFlags]) & fCOLUMNMETA_PRIMARYKEY) != fCOLUMNMETA_PRIMARYKEY)
				{
					//
					// If not PK then continue
					//
					continue;
				}

				//
				// If PK then get the value for that column and print it.
				//

				hr = m_pISTCLB->GetWriteColumnValues(stError.iRow,
					                                 1,
													 &j, 
													 NULL,
													 NULL,
													 &pv);
				if(FAILED(hr))
					continue;

				wcscat(wszRow, (LPWSTR)a_pv[iCOLUMNMETA_InternalName]);
				wcscat(wszRow, L": ");

				if(NULL == pv)
				{
					wcscat(wszRow, L"NULL");
					continue;
				}

				switch(*(DWORD*)a_pv[iCOLUMNMETA_Type])
				{

				case DBTYPE_UI4:
				case DWORD_METADATA:

					_ultow(*(ULONG*)pv, wszDWORD, 10);
					wcscat(wszRow, wszDWORD);
					break;

				case DBTYPE_WSTR:
				case STRING_METADATA:
				case EXPANDSZ_METADATA:
					wcscat(wszRow, (LPWSTR)pv);
					break;

				case DBTYPE_BYTES:
				case BINARY_METADATA:
				case MULTISZ_METADATA:
					wcscat(wszRow, L"BINARY value");
					break;

				default:
					wcscat(wszRow, L"Unknown type");
					break;
				}
				wcscat(wszRow, L"\n");
			}

			wsprintf(wszTemp, 
					 L"DetailedError #%d:\nhr:0x%x\tiRow:%d\tiColumn:%d\nRowDetails:\n%s",
					 i,
					 stError.hr,
					 stError.iRow,
					 stError.iColumn,
					 wszRow);
			LOG_ERROR(Win32, (hr, 
							  ID_CAT_CAT, 
							  IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, 
							  wszTemp));


		}
	}

	return i_hr;

} // CMBBaseCooker::GetDetailedErrors


HRESULT CMBBaseCooker::ValidateColumn(ULONG   i_iCol,
                                      LPVOID  i_pv,
                                      ULONG   i_cb)
{
	HRESULT hr          =  S_OK;
	LPVOID   a_pvColMeta[cCOLUMNMETA_NumberOfColumns];

	if(NULL == i_pv)
	{
		return hr;
	}

    hr = FillInColumnMeta(m_pISTColumnMeta,
			              m_wszTable,
			              i_iCol,
	                      a_pvColMeta);

	if(FAILED(hr))
	{
		return hr;
	}

	//
	// Check for the type of the column - This function validates range
	// for UI4 columns and flag values for flag columns.
	//

	if(eCOLUMNMETA_UI4 == *(DWORD*)(a_pvColMeta[iCOLUMNMETA_Type]))
	{
		if(fCOLUMNMETA_FLAG == (fCOLUMNMETA_FLAG & (*(DWORD*)(a_pvColMeta[iCOLUMNMETA_MetaFlags]))))
		{
			return ValidateFlag(i_iCol,
                                i_pv,
                                i_cb,
								a_pvColMeta);
		}
		else if(fCOLUMNMETA_ENUM == (fCOLUMNMETA_ENUM & (*(DWORD*)(a_pvColMeta[iCOLUMNMETA_MetaFlags]))))
		{
			return ValidateEnum(i_iCol,
                                i_pv,
                                i_cb,
								a_pvColMeta);

		}
		else if(fCOLUMNMETA_BOOL == (fCOLUMNMETA_BOOL & (*(DWORD*)(a_pvColMeta[iCOLUMNMETA_MetaFlags]))))
		{
			//
			// No need to validate range for bool columns.
			//

			return S_OK;

		}
		else
		{
			//
			// This means that it is a regular UI4 column - Validate the range.
			//

			return ValidateMinMaxRange(*(ULONG*)i_pv,
				                       NULL,
									   NULL,
									   i_iCol,
                                       a_pvColMeta);
		}

	}

	return hr;

} // CMBBaseCooker::ValidateColumn


HRESULT CMBBaseCooker::ValidateFlag(ULONG    i_iCol,
                                    LPVOID   i_pv,
                                    ULONG    i_cb,
					                LPVOID*  i_aColMeta)
{
	HRESULT hr          = S_OK;
	DWORD   dwFlagValue = *(DWORD*)i_pv;
	DWORD   dwFlagMask  = *(DWORD*)i_aColMeta[iCOLUMNMETA_FlagMask];

	//
	// First check if the flag has valid bits set
	//

	if(0 != (dwFlagValue & (~(dwFlagValue & (dwFlagMask)))))
	{
		return LogInvalidFlagError(dwFlagValue,
			                       dwFlagMask,
								   (LPWSTR)i_aColMeta[iCOLUMNMETA_InternalName]);
	}

	//
	// Note: There are a lot of flags configured as zero in the metabase
	// We will tolerate zero for now. If, at some point we deem them to be 
	// invalid we will have to explicitly search the meta tables for the
	// zero flag.
	// 

	return hr;

} // CMBBaseCooker::ValidateFlag


HRESULT CMBBaseCooker::LogInvalidFlagError(DWORD  dwFlagValue,
							               DWORD  dwFlagMask,
										   LPWSTR wszColumn)
{
	HRESULT hr     = S_OK;
	WCHAR*  wszRow = NULL;

	hr = ConstructRow(NULL,
		              &wszRow);

	if(SUCCEEDED(hr))
	{
		WCHAR wszFlagValue[CCH_MAX_ULONG+1];
		WCHAR wszFlagMask[CCH_MAX_ULONG+1];

		_ultow(dwFlagValue, wszFlagValue, 10);
		_ultow(dwFlagMask, wszFlagMask, 10);

		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_FLAG, wszRow, wszColumn, wszFlagValue, wszFlagMask));	

		//
		// If the flag mask is invalid,  we will log an error, but we will not 
		// treat it as an error (i.e. we will not simply default it). This is 
		// because users may often set invalid bits and we will tolerate
		// them. By resetting hr to S_OK, we will not force defaults.
		//

		hr = S_OK;
	}
	if(NULL != wszRow)
	{
		delete [] wszRow;
		wszRow = NULL;
	}

	return hr;

} // CMBBaseCooker::LogInvalidFlagError


HRESULT CMBBaseCooker::ValidateEnum(ULONG    i_iCol,
                                    LPVOID   i_pv,
                                    ULONG    i_cb,
					                LPVOID*  i_aColMeta)
{
	HRESULT hr                             = S_OK;
	DWORD   dwEnumValue                    = *(DWORD*)i_pv;
	ULONG   aColSearchByValue[]            = {iTAGMETA_Table,
							                  iTAGMETA_ColumnIndex,
							                  iTAGMETA_Value
	};
	ULONG   cColSearchByValue              = sizeof(aColSearchByValue)/sizeof(aColSearchByValue[0]);
	ULONG   iStartRow                      = 0;
	ULONG   iRow                           = 0;
	LPVOID  apvSearchByValue[cTAGMETA_NumberOfColumns];
	apvSearchByValue[iTAGMETA_Table]       = (LPVOID)m_wszTable;
	apvSearchByValue[iTAGMETA_ColumnIndex] = (LPVOID)&i_iCol;
	apvSearchByValue[iTAGMETA_Value]       = (LPVOID)&dwEnumValue;
	WCHAR*  wszRow                         = NULL;

	if(NULL == m_pISTTagMeta)
	{
		STQueryCell  QueryCell[1];
		ULONG        cCell = sizeof(QueryCell)/sizeof(QueryCell[0]);

		QueryCell[0].pData		= (void*)g_wszByTableAndColumnIndexAndValueOnly;
		QueryCell[0].eOperator	= eST_OP_EQUAL;
		QueryCell[0].iCell		= iST_CELL_INDEXHINT;
		QueryCell[0].dbType		= DBTYPE_WSTR;
		QueryCell[0].cbSize		= 0;

		hr = m_pISTDisp->GetTable(wszDATABASE_META,
								  wszTABLE_TAGMETA,
								  (LPVOID)QueryCell,
								  (LPVOID)&cCell,
								  eST_QUERYFORMAT_CELLS,
								  0,
								  (LPVOID *)&m_pISTTagMeta);

		if(FAILED(hr))
		{
			return hr;
		}

	}

	hr = m_pISTTagMeta->GetRowIndexBySearch(iStartRow, 
										    cColSearchByValue, 
											aColSearchByValue,
											NULL, 
											apvSearchByValue,
											&iRow);

	if(E_ST_NOMOREROWS == hr)
	{
		hr = ConstructRow(NULL,
			              &wszRow);

		if(SUCCEEDED(hr))
		{
			WCHAR wszValue[CCH_MAX_ULONG+1];

			_ultow(*(DWORD*)(i_pv), wszValue, 10);

			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_ENUM, wszRow, (LPWSTR)i_aColMeta[iCOLUMNMETA_InternalName], wszValue));	

			//
			// If the enum value is invalid,  we will log an error, but we will not 
			// treat it as an error (i.e. we will not simply default it). This is 
			// because users may often set invalid enums and we will tolerate
			// them. By resetting hr to S_OK, we will not force defaults.
			//

			hr = S_OK;
		}
	}

	if(NULL != wszRow)
	{
		delete [] wszRow;
		wszRow = NULL;
	}

	return hr;

} // CMBBaseCooker::ValidateEnum


HRESULT CMBBaseCooker::ValidateMinMaxRange(ULONG    i_ulValue,
										   ULONG*   i_pulMin,
										   ULONG*   i_pulMax,
										   ULONG    i_iCol,
                                           LPVOID*  i_aColMeta)
{
	HRESULT  hr       = S_OK;
	ULONG    ulMin;
	ULONG    ulMax;
	LPVOID   a_pvColMeta[cCOLUMNMETA_NumberOfColumns];
	LPVOID*  aColMeta = i_aColMeta;

	if(NULL == aColMeta)
	{
	   hr = FillInColumnMeta(m_pISTColumnMeta,
			                 m_wszTable,
			                 i_iCol,
		                     a_pvColMeta);

	   if(FAILED(hr))
	   {
		   return  hr;
	   }

       aColMeta = a_pvColMeta;

	}

	if(NULL != i_pulMin)
	{
		ulMin = *i_pulMin;

	}
	else
	{
		ulMin = *(ULONG*)aColMeta[iCOLUMNMETA_StartingNumber];
	}

	if(NULL != i_pulMax)
	{
		ulMax = *i_pulMax;

	}
	else
	{
		ulMax = *(ULONG*)aColMeta[iCOLUMNMETA_EndingNumber];
	}

	if( (i_ulValue > ulMax )  ||
        (i_ulValue < ulMin) 
	  )
	{
		hr = LogRangeError(i_ulValue,
			               *(DWORD*)aColMeta[iCOLUMNMETA_StartingNumber],
                           *(DWORD*)aColMeta[iCOLUMNMETA_EndingNumber],
						   (LPWSTR)aColMeta[iCOLUMNMETA_InternalName]);
			               
	}

	return hr;

} // CMBBaseCooker::ValidateMinMaxRange


HRESULT CMBBaseCooker::ConstructRow(WCHAR* i_wszColumn,
									WCHAR** o_pwszRow)
{
	HRESULT  hr     = S_OK;
	SIZE_T   cch    = wcslen(m_wszTable);        
	WCHAR    wszSiteID[CCH_MAX_ULONG+1];
	WCHAR*   wszPK1 = NULL;
	WCHAR*   wszPK2 = NULL;

	if(0 == wcscmp(m_wszTable, wszTABLE_APPPOOLS))
	{
		wszPK1 = (LPWSTR)m_apv[iAPPPOOLS_AppPoolID];
	}
	else if(0 == wcscmp(m_wszTable, wszTABLE_SITES))
	{
		_ultow(*(DWORD*)m_apv[iSITES_SiteID], wszSiteID, 10);
		wszPK1 = wszSiteID;
	}
	else if(0 == wcscmp(m_wszTable, wszTABLE_APPS))
	{
		_ultow(*(DWORD*)m_apv[iAPPS_SiteID], wszSiteID, 10);
		wszPK1 = wszSiteID;
		wszPK2 = (LPWSTR)m_apv[iAPPS_AppRelativeURL];
	}

	if(NULL != i_wszColumn)
	{
		cch += CCH_EXTENSTION;
		cch += wcslen(i_wszColumn);
	}

	if(NULL != wszPK1)
	{
		cch += CCH_EXTENSTION;
		cch += wcslen(wszPK1);
	}

	if(NULL != wszPK2)
	{
		cch += wcslen(wszPK2);
	}

	*o_pwszRow = new WCHAR[cch+1];
	if(NULL == *o_pwszRow)
	{
		return E_OUTOFMEMORY;
	}

	wcscpy(*o_pwszRow, m_wszTable);

	if(NULL != wszPK1)
	{
		wcscat(*o_pwszRow, WSZ_EXTENSION);
		wcscat(*o_pwszRow, wszPK1);

		if(NULL != wszPK2)
		{
			wcscat(*o_pwszRow, wszPK2);
		}
	}

	if(NULL != i_wszColumn)
	{
		wcscat(*o_pwszRow, WSZ_EXTENSION);
		wcscat(*o_pwszRow, i_wszColumn);
	}

	return S_OK;

} // CMBBaseCooker::ConstructRow


HRESULT CMBBaseCooker::LogRangeError(DWORD  dwValue,
							         DWORD  dwMin,
							         DWORD  dwMax,
								     LPWSTR wszColumn)
{
	HRESULT hr     = S_OK;
	WCHAR*  wszRow = NULL;
	WCHAR wszMin[CCH_MAX_ULONG+1];
	WCHAR wszMax[CCH_MAX_ULONG+1];
	WCHAR wszValue[CCH_MAX_ULONG+1];

	_ultow(dwMin, wszMin, 10);
	_ultow(dwMax, wszMax, 10);
	_ultow(dwValue, wszValue, 10);

	hr = ConstructRow(wszColumn,
					  &wszRow);

	if(SUCCEEDED(hr))
	{
		hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_RANGE, wszRow, wszValue, wszMin, wszMax));	
	}

	if(NULL != wszRow)
	{
		delete [] wszRow;
		wszRow = NULL;
	}

	return hr;

} // CMBBaseCooker::LogInvalidFlagError


BOOL CMBBaseCooker::NotifyWhenNoChangeInValue(ULONG              i_iCol,
		  					                  WAS_CHANGE_OBJECT* i_pWASChngObj)
{
	HRESULT hr = S_OK;
	LPVOID  a_pvColMeta[cCOLUMNMETA_NumberOfColumns];
	BOOL    bFoundInChangeNotificationList = FALSE;

	hr = FillInColumnMeta(m_pISTColumnMeta,
			              m_wszTable,
			              i_iCol,
			              a_pvColMeta);

	if(FAILED(hr))
	{
		ASSERT(0 && L"Unexpected hr from FillInColumnMeta. Assuming we need to notify in case of no change.");
		return TRUE;
	}

	ASSERT(NULL != a_pvColMeta[iCOLUMNMETA_SchemaGeneratorFlags]);
	ASSERT(NULL != a_pvColMeta[iCOLUMNMETA_ID]);

	//
	// Check if this property is in the change notification list.
	//

	if(NULL != i_pWASChngObj)
	{
		for(ULONG i=0; i<i_pWASChngObj->dwMDNumDataIDs; i++)
		{
			if(i_pWASChngObj->pdwMDDataIDs[i] == *(DWORD*)a_pvColMeta[iCOLUMNMETA_ID])
			{
				bFoundInChangeNotificationList = TRUE;
				break;
			}
		}
	}

	//
	// The property needs to be notified only when it is in the change 
	// notification list and it is marked with the notify when no change 
	// in value flag in the meta tables.
	//

	if( (bFoundInChangeNotificationList)                          &&
		((fCOLUMNMETA_WAS_NOTIFICATION_ON_NO_CHANGE_IN_VALUE) == 
		 ((fCOLUMNMETA_WAS_NOTIFICATION_ON_NO_CHANGE_IN_VALUE)&
		  (*(DWORD*)a_pvColMeta[iCOLUMNMETA_SchemaGeneratorFlags])
		 )
		)
	  )
	{
		return TRUE;
	}

	return FALSE;

} // CMBBaseCooker::NotifyWhenNoChangeInValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbglobalcooker.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "Catmeta.h"
#include "catalog.h"
#include "catmacros.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "MBBaseCooker.h"
#include "MBGlobalCooker.h"
#include "MBAppPoolCooker.h"
#include "MBAppCooker.h"
#include "MBSiteCooker.h"
#include "undefs.h"
#include "SvcMsg.h"

#define IIS_MD_GLOBAL_FILTER_FLAGS_ROOT	L"Filters"


CMBGlobalCooker::CMBGlobalCooker():
CMBBaseCooker()
{

} // CMBGlobalCooker::CMBGlobalCooker


CMBGlobalCooker::~CMBGlobalCooker()
{

} // CMBGlobalCooker::~CMBGlobalCooker

HRESULT CMBGlobalCooker::BeginCookDown(IMSAdminBase*			i_pIMSAdminBase,
									   METADATA_HANDLE			i_MBHandle,
									   ISimpleTableDispenser2*	i_pISTDisp,
									   LPCWSTR					i_wszCookDownFile)
{
	HRESULT hr;

	//
	// Initialize CLB table name.
	//

	m_wszTable = wszTABLE_GlobalW3SVC;

	// 
	// Invoke the base class BeginCookDown so that all the structures are
	// initialized.
	//

	hr = CMBBaseCooker::BeginCookDown(i_pIMSAdminBase,
									  i_MBHandle,
									  i_pISTDisp,
									  i_wszCookDownFile);

	return hr;

} // CMBGlobalCooker::BeginCookDown


HRESULT CMBGlobalCooker::CookDown(WAS_CHANGE_OBJECT* i_pWASChngObj)
{
    HRESULT hr = S_OK;

    
	//
	// Read config from MB.
	//

	hr = GetData(NULL);

	if(FAILED(hr))
	{
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_GLOBALW3SVC_PROPERTIES, NULL));
		return hr;
	}

	//
	// MaxGlobalBandwidth is the primary key and hence we need to special case 
	// it because we dont support NULL PKs.
	//

	if(NULL == m_apv[iGlobalW3SVC_MaxGlobalBandwidth])
	{
		//
		// If the PK is missing, then default it.
		//

		m_apv[iGlobalW3SVC_MaxGlobalBandwidth] = new DWORD[1];

		if(NULL == m_apv[iGlobalW3SVC_MaxGlobalBandwidth])
			return E_OUTOFMEMORY;

		m_acb[iGlobalW3SVC_MaxGlobalBandwidth] = sizeof(DWORD);

		*(DWORD*)m_apv[iGlobalW3SVC_MaxGlobalBandwidth] = -1; 
		
	}

	hr = ReadGlobalFilterFlags();

	if(FAILED(hr))
	{
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_GLOBALW3SVC_PROPERTIES, NULL));
		return hr;
	}

	//
	// Validate AppPool.
	//

	hr = ValidateGlobals();

	if(FAILED(hr))
	{
		return hr;
	}

	//
	// Copy all Global row
	//

	hr = CopyRows(&(m_apv[iGlobalW3SVC_MaxGlobalBandwidth]),
		          i_pWASChngObj);

	if(FAILED(hr))
	{
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_GLOBALW3SVC_INTERNAL_ERROR, NULL));
		return hr;
	}
	else if(SUCCEEDED(hr))
	{
		hr = DeleteObsoleteGlobals();

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_GLOBALW3SVC_INTERNAL_ERROR, NULL));
		}
	}

    return hr;

} // CMBGlobalCooker::CookDown


HRESULT CMBGlobalCooker::DeleteObsoleteGlobals()
{
	HRESULT hr = S_OK;

	hr = ComputeObsoleteReadRows();

	if(FAILED(hr))
	{
		return hr;
	}

	for(ULONG i=0; i<m_paiReadRowObsolete->size(); i++)
	{
		ULONG  a_iCol [] = {iGlobalW3SVC_MaxGlobalBandwidth,
					 	    iGlobalW3SVC_MaxGlobalConnections
	                       };
		ULONG  cCol = sizeof(a_iCol)/sizeof(a_iCol[0]);
		LPVOID a_pv[cGlobalW3SVC_NumberOfColumns];
		LPVOID a_pvIdentity[cGlobalW3SVC_NumberOfColumns];

		hr = m_pISTCLB->GetColumnValues((*m_paiReadRowObsolete)[i],
										cCol,
										a_iCol,
										NULL,
										(LPVOID*)a_pv);

		if(FAILED(hr))
		{
			return hr;
		}

		a_pvIdentity[iGlobalW3SVC_MaxGlobalBandwidth] = a_pv[iGlobalW3SVC_MaxGlobalBandwidth];
		a_pvIdentity[iGlobalW3SVC_MaxGlobalConnections] = a_pv[iGlobalW3SVC_MaxGlobalConnections];

		hr = DeleteGlobals(a_pvIdentity);

		if(FAILED(hr))
		{
			return hr;
		}

	}

	return hr;

} // CMBGlobalCooker::DeleteObsoleteGlobals


HRESULT CMBGlobalCooker::EndCookDown()
{
	HRESULT hr;

	hr = m_pISTCLB->UpdateStore();

	return hr;

} // CMBGlobalCooker::EndCookDown


HRESULT CMBGlobalCooker::DeleteGlobals(LPVOID* i_apvIdentity)
{

    HRESULT hr = S_OK;

	//
	// Delete the AppPool from the CLB.
	//

	hr = DeleteRow(i_apvIdentity);

	if(FAILED(hr))
	{
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_GLOBALW3SVC_INTERNAL_ERROR, NULL));
	}

    return hr;

}   // CCooker::DeleteGlobals


HRESULT CMBGlobalCooker::ReadGlobalFilterFlags()
{
	HRESULT			hr					= S_OK;
    WCHAR			wszGlobalFilterFlagsRootPath[1 + 
									             (sizeof(IIS_MD_GLOBAL_FILTER_FLAGS_ROOT)/sizeof(WCHAR))+
											     1 
											    ];

	//
	// Construct the starting key.
	//

    _snwprintf(wszGlobalFilterFlagsRootPath, 
	           sizeof(wszGlobalFilterFlagsRootPath)/sizeof(WCHAR), 
			   L"/%s", 
			   IIS_MD_GLOBAL_FILTER_FLAGS_ROOT);

	//
	// If there is a filter flag set at the w3svc level, it will be read at
	// this point - we should not be considering it - hence delete it.
	//

	if(NULL != m_apv[iGlobalW3SVC_FilterFlags])
	{
		*(DWORD*)(m_apv[iGlobalW3SVC_FilterFlags]) = 0;
	}

	//
	// Compute rolled up filter flags starting from wszGlobalFilterFlagsRootPath
	// MD_FILTER_FLAGS_PROPERTY
	//

	return ReadFilterFlags(wszGlobalFilterFlagsRootPath,
						   (DWORD**)(&(m_apv[iGlobalW3SVC_FilterFlags])),
						   &(m_acb[iGlobalW3SVC_FilterFlags]));

} // CMBGlobalCooker::ReadGlobalFilterFlags


HRESULT CMBGlobalCooker::ValidateGlobals()
{

	HRESULT hr	            = S_OK;
	LPVOID	pv			    = NULL;
	ULONG   cb              = 0;

	//
	// Normally you would call ValidateGlobalColumn which calls ValidateColumn 
	// and then performs custom validations. Since there are no custom
	// validations, we directly call ValidateColumn from here.
	//

	for(ULONG iCol=0; iCol<m_cCol; iCol++)
	{
		if(NULL != m_apv[iCol])
		{
			hr = ValidateColumn(iCol,
		                        m_apv[iCol],
						        m_acb[iCol]);

			if(HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
			{
				//
				// Data was invalid - force default,
				//

				delete [] m_apv[iCol];
				m_apv[iCol] = NULL;			
				m_acb[iCol] = 0;
			}
			else if(FAILED(hr))
			{
				return hr; // If any other failure return
			}

		}

		if(NULL == m_apv[iCol])
		{
			//
			// If you reach here it means that either the value was
			// null, or the value was invalid and hence it has been
			// set to null so that defaults can be applied.
			//

			hr = GetDefaultValue(iCol,
				                 &pv,  
								 &cb);
			if(FAILED(hr))
			{
				return hr;
			}

			hr = ValidateColumn(iCol,
								pv,
								cb);

			if(FAILED(hr))
			{
				if(HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
				{
					ASSERT(0 && L"Invalid default - fix the schema");
				}
				return hr;
			}
		}
	}

	return hr;

} // CMBGlobalCooker::ValidateGlobals
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbbasecooker.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#ifndef _MBBASECOOKER_H_
#define _MBBASECOOKER_H_

#include "array_t.h"
#include "MBListen.h"

class CMBBaseCooker
{
public:

	CMBBaseCooker();
	
	~CMBBaseCooker();

	virtual HRESULT BeginCookDown(IMSAdminBase*				i_pIMSAdminBase,
								  METADATA_HANDLE			i_MBHandle,
								  ISimpleTableDispenser2*	i_pISTDisp,
								  LPCWSTR					i_wszCookDownFile);

	//
	// This function must be imlemented by derived classes.
	//

	virtual HRESULT CookDown();

	//
	// This function must be imlemented by derived classes.
	//

	virtual HRESULT CookDown(LPCWSTR  i_wszAppPath,
							 LPCWSTR  i_wszSiteRootPath,
							 DWORD    i_dwVirtualSiteId,
							 BOOL*	  o_pValidRootApplicationExists);

	//
	// This function must be imlemented by derived classes.
	//

	virtual HRESULT EndCookDown() = 0;

	//
	// These are global functions used to determine whether to cookdown
	// or not and if we do cookdown, then update the change number.
	//

	static HRESULT Cookable(LPCWSTR	                    i_wszCookDownFile,
		                    BOOL*	                    o_pbCookable,
							WIN32_FILE_ATTRIBUTE_DATA*  io_pFileAttr,
		                    DWORD*	                    o_pdwChangeNumber);

	static HRESULT UpdateChangeNumber(LPCWSTR	i_wszCookDownFile,
		                              DWORD		i_dwChangeNumber,
									  BYTE*     i_pbTimeStamp,
									  DWORD     i_dwLOS);

	static HRESULT GetMetabaseFile(LPWSTR* o_wszMetabaseFile);

protected:

	HRESULT InitializeMeta();

	HRESULT GetData(WCHAR*			i_wszPath);

	HRESULT CopyRows(LPVOID*		    i_aIdentity,
					 WAS_CHANGE_OBJECT* i_pWASChngObj,
		             BOOL*              o_bNewRowAdded = NULL);

	HRESULT CompareRows(ULONG		       i_iReadRow,
		                WAS_CHANGE_OBJECT* i_pWASChngObj,
						ULONG*		       o_pcColChanged,
						LPVOID**	       o_apv,
						ULONG**		       o_acb);

	HRESULT	DeleteRow(LPVOID*		i_aIdentity);

	HRESULT ReadFilterFlags(LPCWSTR	 i_wszFilterFlagsRootPath,
                            DWORD**  io_pdwFilterFlags,
						    ULONG*   io_cbFilterFlags);

	HRESULT GetDefaultValue(ULONG   i_iCol,
						    LPVOID* o_apv,
						    ULONG*  o_cb);

	HRESULT GetDetailedErrors(DWORD i_hr);

	HRESULT ComputeObsoleteReadRows();

	HRESULT ValidateColumn(ULONG   i_iCol,
                           LPVOID  i_pv,
                           ULONG   i_cb);

	HRESULT ValidateMinMaxRange(ULONG    i_ulValue,
							    ULONG*   i_pulMin,
							    ULONG*   i_pulMax,
							    ULONG    i_iCol,
                                LPVOID*  i_aColMeta);

private:

	HRESULT GetDataPaths(LPCWSTR	i_wszRoot,
						 DWORD		i_dwIdentifier,
						 DWORD		i_dwAttributes,
						 WCHAR**	io_pwszBuffer,
						 DWORD		i_cchBuffer);

	HRESULT GetDataFromMB(WCHAR*  i_wszPath,
						  DWORD   i_dwID,
						  DWORD   i_dwAttributes,
						  DWORD   i_dwUserType,
						  DWORD   i_dwType,
						  BYTE**  io_pBuff,
						  ULONG*  io_pcbBuff,
						  BOOL    i_BuffStatic);

	HRESULT AddReadRowIndexToPresentList(ULONG i_iReadRow);

	HRESULT AddReadRowIndexToObsoleteList(ULONG i_iReadRow);

	HRESULT ValidateFlag(ULONG    i_iCol,
                         LPVOID   i_pv,
                         ULONG    i_cb,
		                 LPVOID*  i_aColMeta);

	HRESULT LogInvalidFlagError(DWORD dwFlagValue,
				                DWORD dwFlagMask,
								LPWSTR wszColumn);

	HRESULT LogRangeError(DWORD  dwValue,
				          DWORD  dwMin,
						  DWORD  dwMax,
						  LPWSTR wszColumn);

	HRESULT ValidateEnum(ULONG    i_iCol,
                         LPVOID   i_pv,
                         ULONG    i_cb,
		                 LPVOID*  i_aColMeta);

	HRESULT ConstructRow(WCHAR* i_wszColumn,
		                 WCHAR** o_pwszRow);

	BOOL NotifyWhenNoChangeInValue(ULONG              i_Col,
				                   WAS_CHANGE_OBJECT* i_pWASChngObj);

protected:

	IMSAdminBase*			m_pIMSAdminBase;
	METADATA_HANDLE			m_hMBHandle;
	ISimpleTableDispenser2* m_pISTDisp;
	ISimpleTableWrite2*		m_pISTCLB;
	ISimpleTableRead2*		m_pISTColumnMeta;
	ISimpleTableRead2*		m_pISTTagMeta;
	LPCWSTR					m_wszTable;
	LPCWSTR					m_wszCookDownFile;
	LPVOID*					m_apv;
	ULONG*					m_acb;
	ULONG*					m_aiCol;
	ULONG					m_cCol;
	LPOSVERSIONINFOEX		m_pOSVersionInfo;
	Array<ULONG>*           m_paiReadRowPresent;
	Array<ULONG>*           m_paiReadRowObsolete;

}; // Class CMBBaseCooker

#endif  // _MBBASECOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbglobalcooker.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#ifndef _MBGLOBALCOOKER_H_
#define _MBGLOBALCOOKER_H_

#define IIS_MD_GLOBAL_BASE 9200

#define MD_GLOBAL_MAX_GLOBAL_BANDWIDTH		(IIS_MD_GLOBAL_BASE+1)
#define MD_GLOBAL_MAX_GLOBAL_CONNECTIONS	(IIS_MD_GLOBAL_BASE+2)
#define MD_GLOBAL_BACKWARD_COMPACT_ENABLED	(IIS_MD_GLOBAL_BASE+3)

class CMBGlobalCooker: public CMBBaseCooker
{

public:

	CMBGlobalCooker();
	
	~CMBGlobalCooker();
	
	HRESULT BeginCookDown(IMSAdminBase*				i_pIMSAdminBase,
						  METADATA_HANDLE			i_MBHandle,
						  ISimpleTableDispenser2*	i_pISTDisp,
						  LPCWSTR					i_wszCookDownFile);
	HRESULT CookDown(WAS_CHANGE_OBJECT* i_pWASChngObj);

	HRESULT EndCookDown();

public:

	HRESULT CookDownGlobals();

	HRESULT DeleteGlobals(LPVOID* i_apvIdentity);

private:

	HRESULT ReadGlobalFilterFlags();

	HRESULT DeleteObsoleteGlobals();

	HRESULT ValidateGlobals();

};

#endif // _MBGLOBALCOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dirmon\dirmon.cpp ===
/**************************************************************************++
    Copyright (c) 2001 Microsoft Corporation

 * DirMonListener implementation. It subscribes to file change notification and calls back to the
 * managed code whenever a file change occurs.
 * 
 */
#include "objbase.h"
#include "catalog.h"
#include "catmeta.h"
#include "catmacros.h"

ISimpleTableFileAdvise* g_pISTFileAdvise = NULL;
HRESULT ReallyGetSimpleTableDispenser(REFIID riid, LPVOID* o_ppv, LPCWSTR i_wszProduct);
/**
 * Callback for file change notifications.
 * COM+ delegates are marshaled as this callback.
 */

typedef void (__stdcall *PFNDIRMONCALLBACK)(int action, WCHAR *pFilename);
//The corresponding delegate in the managed code is:
//delegate void NativeFileChangeNotification(int action, int filenameAsInt);

class DirMonListener : public ISimpleTableFileChange
{
public:
	DirMonListener(PFNDIRMONCALLBACK callback)
	: m_cRef(0),
	  m_pfnCallback(callback)
	{}

	~DirMonListener()
	{}

	////////////////////////////////////////////////////////////////////////////
	// IUnknown:
	STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
	{
		if (NULL == ppv) 
			return E_INVALIDARG;
		*ppv = NULL;

		if (riid == IID_ISimpleTableFileChange)
		{
			*ppv = (ISimpleTableFileChange*) this;
		}
		else if (riid == IID_IUnknown)
		{
			*ppv = (ISimpleTableFileChange*) this;
		}

		if (NULL != *ppv)
		{
			((ISimpleTableFileChange*)this)->AddRef ();
			return S_OK;
		}
		else
		{
			return E_NOINTERFACE;
		}
		
	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return InterlockedIncrement((LONG*) &m_cRef);
		
	}

	STDMETHODIMP_(ULONG) Release()
	{
		long cref = InterlockedDecrement((LONG*) &m_cRef);
		if (cref == 0)
		{
			delete this;
		}
		return cref;
	}

	STDMETHODIMP OnFileCreate(LPCWSTR i_wszFileName)
	{
		CallCallback(FILE_ACTION_ADDED, i_wszFileName );
		return S_OK;
	}
	
	STDMETHODIMP OnFileModify(LPCWSTR i_wszFileName)
	{
		CallCallback(FILE_ACTION_MODIFIED, i_wszFileName );
		return S_OK;
	}

	STDMETHODIMP OnFileDelete(LPCWSTR i_wszFileName)
	{
		CallCallback(FILE_ACTION_REMOVED, i_wszFileName );
		return S_OK;
	}

	HRESULT CallCallback( int action, LPCWSTR pFilename )
	{
		if ( !pFilename )
			return E_INVALIDARG;
		//Exact the file name only from the path
		LPWSTR pStart = wcsrchr( pFilename, '\\' );
		if ( !pStart )
			pStart = (LPWSTR)pFilename;
		else
			pStart++;

		LPWSTR pName = new WCHAR[wcslen(pStart)+1];
		if ( !pName )
			return E_OUTOFMEMORY;
		wcscpy( pName, pStart );

		WszCharUpper( pName );

		if ( m_pfnCallback != NULL )
			(*m_pfnCallback)(action, (LPWSTR)pName );

		if ( pName )
			delete [] pName;

		return S_OK;
	}

private:
	LONG	m_cRef;
    PFNDIRMONCALLBACK m_pfnCallback;    // the delegate marshaled as callback

};


/**
 * Create DirMonListener and returns it as int.
 */
int
__stdcall
DirMonOpen(
    LPCWSTR pDir,
    PFNDIRMONCALLBACK pCallbackDelegate)
{

    HRESULT hr = S_OK;
    DirMonListener *pDirMon = NULL;
	DWORD	dwCookie = 0;

	if ( g_pISTFileAdvise == NULL )
	{
		ISimpleTableFileAdvise* pISTFileAdvise = NULL;
		
		hr = ReallyGetSimpleTableDispenser (IID_ISimpleTableFileAdvise, (LPVOID*) &pISTFileAdvise, WSZ_PRODUCT_NETFRAMEWORKV1);
		if (FAILED(hr)) { goto Cleanup; }

		if (NULL != InterlockedCompareExchangePointer ( (PVOID*) &g_pISTFileAdvise, pISTFileAdvise, NULL))
			pISTFileAdvise->Release();
	}

	pDirMon = new DirMonListener( pCallbackDelegate );
	if ( NULL == pDirMon )
		return 0;

	hr = g_pISTFileAdvise->SimpleTableFileAdvise(pDirMon, pDir, NULL, 0, &dwCookie);
	if (FAILED(hr)) 
		return 0;

    
Cleanup:

    return (int)dwCookie;
}

/**
 * Release DirMonListener passed as int.
 */
void
__stdcall
DirMonClose(
    int dwCookie)
{
    if ( !g_pISTFileAdvise )
		return;

	g_pISTFileAdvise->SimpleTableFileUnadvise( dwCookie );
}


//APIs copied from xsp native code
int __stdcall GetNumberOfProcessors()
{
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    return si.dwNumberOfProcessors;
}


HRESULT
__stdcall
ConvertToLongFileName(WCHAR * path, WCHAR * buf)
{
    HRESULT         hr = S_OK;
    HANDLE          hFindFile;
    WIN32_FIND_DATA wfd;

    // FindFirstFile will find using the short name
    // We can then find the long name from the WIN32_FIND_DATA
    hFindFile = WszFindFirstFile(path, &wfd);
    if (hFindFile == INVALID_HANDLE_VALUE)
        return ( HRESULT_FROM_WIN32( GetLastError() ) ); 

    // Now that we have the find data we don't need the handle
    FindClose(hFindFile);
    wcscpy(buf, wfd.cFileName);

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbsitecooker.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#ifndef _MBSITECOOKER_H_
#define _MBSITECOOKER_H_

class CMBSiteCooker: public CMBBaseCooker
{

public:

	CMBSiteCooker();
	
	~CMBSiteCooker();
	
	HRESULT BeginCookDown(IMSAdminBase*				i_pIMSAdminBase,
						  METADATA_HANDLE			i_MBHandle,
						  ISimpleTableDispenser2*	i_pISTDisp,
						  LPCWSTR					i_wszCookDownFile);
	HRESULT CookDown(WAS_CHANGE_OBJECT* i_pWASChngObj);

	HRESULT EndCookDown();

public:

	HRESULT CookDownSite(LPCWSTR            i_wszVirtualSiteKeyName,
						 WAS_CHANGE_OBJECT* i_pWASChngObj,
						 DWORD              i_VirtualSiteId);
	HRESULT DeleteSite(LPCWSTR  i_wszVirtualSiteKeyName,
						 DWORD    i_VirtualSiteId);

	CMBAppCooker*	GetAppCooker() { return m_pMBApplicationCooker; };

	static HRESULT CookdownSiteFromList(Array<ULONG>*           i_paVirtualSites,
										ISimpleTableWrite2*     i_pISTCLBAppPool,
										IMSAdminBase*		    i_pIMSAdminBase,
	                                    METADATA_HANDLE		    i_hMBHandle,
	                                    ISimpleTableDispenser2* i_pISTDisp,
										LPCWSTR					i_wszCookDownFile);

private:

	HRESULT ReadAllBindingsAndReturnUrlPrefixes(LPCWSTR i_wszVirtualSiteKeyName);

	HRESULT ValidateSite();

	HRESULT ValidateSiteColumn(ULONG  i_iCol,
                               LPVOID i_pv,
                               ULONG  i_cb);

	HRESULT ConvertBindingsToUrlPrefixes(BYTE*   i_pbBindingStrings,
								         LPCWSTR i_wszProtocolString, 
										 ULONG   i_ulProtocolStringCharCountSansTermination,
										 BYTE**	 io_pbUrlPrefixes,
										 ULONG*	 io_cbUrlPrefix,
										 ULONG*	 io_cbUsedUrlPrefix);

	HRESULT BindingStringToUrlPrefix(LPCWSTR i_wszBindingString,
									 LPCWSTR i_wszProtocolString, 
									 ULONG   i_ulProtocolStringCharCountSansTermination,
									 LPWSTR* io_wszUrlPrefixes,
									 ULONG*	 io_cchUrlPrefix);

	HRESULT ReadSiteFilterFlags(LPCWSTR	i_wszVirtualSiteKeyName);

	HRESULT DeleteAllSites();

	HRESULT DeleteObsoleteSites();

	HRESULT DeleteSiteAt(ULONG i_iReadRow);

private:

	CMBAppCooker*	m_pMBApplicationCooker;

};

#endif // _MBSITECOOKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\undefs.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#ifdef MD_ERROR_READING_SCHEMA_BIN
#undef MD_ERROR_READING_SCHEMA_BIN
#endif

#ifdef MD_ERROR_NO_MATCHING_HISTORY_FILE
#undef MD_ERROR_NO_MATCHING_HISTORY_FILE
#endif

#ifdef MD_ERROR_PROCESSING_TEXT_EDITS
#undef MD_ERROR_PROCESSING_TEXT_EDITS
#endif

#ifdef MD_ERROR_COMPUTING_TEXT_EDITS
#undef MD_ERROR_COMPUTING_TEXT_EDITS
#endif

#ifdef MD_ERROR_READING_TEXT_EDITS
#undef MD_ERROR_READING_TEXT_EDITS
#endif

#ifdef MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE
#undef MD_ERROR_APPLYING_TEXT_EDITS_TO_METABASE
#endif

#ifdef MD_ERROR_APPLYING_TEXT_EDITS_TO_HISTORY
#undef MD_ERROR_APPLYING_TEXT_EDITS_TO_HISTORY
#endif

#ifdef MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS
#undef MD_ERROR_THREAD_THAT_PROCESS_TEXT_EDITS
#endif

#ifdef MD_ERROR_SHARING_VIOLATION
#undef MD_ERROR_SHARING_VIOLATION
#endif

#ifdef MD_ERROR_SAVING_APPLIED_TEXT_EDITS
#undef MD_ERROR_SAVING_APPLIED_TEXT_EDITS
#endif

#ifdef MD_ERROR_COPY_ERROR_FILE
#undef MD_ERROR_COPY_ERROR_FILE
#endif

#ifdef MD_ERROR_UNABLE_TOSAVE_METABASE
#undef MD_ERROR_UNABLE_TOSAVE_METABASE
#endif

#ifdef MD_ERROR_READ_XML_FILE
#undef MD_ERROR_READ_XML_FILE
#endif

#ifdef MD_ERROR_DAFAULTING_MAX_HISTORY_FILES
#undef MD_ERROR_DAFAULTING_MAX_HISTORY_FILES
#endif

#ifdef MD_ERROR_COPYING_EDITED_FILE
#undef MD_ERROR_COPYING_EDITED_FILE
#endif

#ifdef MD_WARNING_RESETTING_READ_ONLY_ATTRIB
#undef MD_WARNING_RESETTING_READ_ONLY_ATTRIB
#endif

#ifdef MD_WARNING_HIGHEST_POSSIBLE_MINOR_FOUND
#undef MD_WARNING_HIGHEST_POSSIBLE_MINOR_FOUND
#endif

#ifdef MD_WARNING_IGNORING_DISCONTINUOUS_NODE
#undef MD_WARNING_IGNORING_DISCONTINUOUS_NODE
#endif

#ifdef MD_ERROR_METABASE_PATH_NOT_FOUND
#undef MD_ERROR_METABASE_PATH_NOT_FOUND
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\cookdownfrommb\mbsitecooker.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "Catmeta.h"
#include "catalog.h"
#include "catmacros.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "MBBaseCooker.h"
#include "MBGlobalCooker.h"
#include "MBAppPoolCooker.h"
#include "MBAppCooker.h"
#include "MBSiteCooker.h"
#include "undefs.h"
#include "SvcMsg.h"

#define MAX_STRINGIZED_ULONG_CHAR_COUNT 11
#define PROTOCOL_STRING_HTTP L"http://"
#define PROTOCOL_STRING_HTTP_CHAR_COUNT_SANS_TERMINATION                \
    ( sizeof( PROTOCOL_STRING_HTTP ) / sizeof( WCHAR ) ) - 1
#define PROTOCOL_STRING_HTTPS L"https://"
#define PROTOCOL_STRING_HTTPS_CHAR_COUNT_SANS_TERMINATION               \
    ( sizeof( PROTOCOL_STRING_HTTPS ) / sizeof( WCHAR ) ) - 1
#define DIFF(x)     ((size_t)(x))
#define IIS_MD_VIRTUAL_SITE_ROOT	L"/Root"
#define IIS_MD_VIRTUAL_SITE_FILTER_FLAGS_ROOT	L"/Filters"

#define MAX_CONNECTION_PRO_PERSONAL		0x0000000A


CMBSiteCooker::CMBSiteCooker():
CMBBaseCooker(),
m_pMBApplicationCooker(NULL)
{

} // CMBSiteCooker::CMBSiteCooker


CMBSiteCooker::~CMBSiteCooker()
{
	if(NULL != m_pMBApplicationCooker)
	{
		delete m_pMBApplicationCooker;
		m_pMBApplicationCooker = NULL;
	}

} // CMBSiteCooker::~CMBSiteCooker

HRESULT CMBSiteCooker::BeginCookDown(IMSAdminBase*				i_pIMSAdminBase,
									 METADATA_HANDLE			i_MBHandle,
									 ISimpleTableDispenser2*	i_pISTDisp,
									 LPCWSTR					i_wszCookDownFile)
{
	HRESULT hr;

	//
	// Initialize CLB table name.
	//

	m_wszTable = wszTABLE_SITES;

	// 
	// Invoke the base class BeginCookDown so that all the structures are
	// initialized.
	//

	hr = CMBBaseCooker::BeginCookDown(i_pIMSAdminBase,
									  i_MBHandle,
									  i_pISTDisp,
									  i_wszCookDownFile);
	if(FAILED(hr))
		return hr;

	//
	// The site cooker needs to store the app cooker since each site cooks
	// down all its apps.
	//

	m_pMBApplicationCooker = new CMBAppCooker();
	if(NULL == m_pMBApplicationCooker)
		return E_OUTOFMEMORY;

	hr = m_pMBApplicationCooker->BeginCookDown(i_pIMSAdminBase,
											   i_MBHandle,
											   i_pISTDisp,
											   i_wszCookDownFile); 

	return hr;

} // CMBSiteCooker::BeginCookDown


HRESULT CMBSiteCooker::CookDown(WAS_CHANGE_OBJECT* i_pWASChngObj)
{

    WCHAR   wszKeyName[METADATA_MAX_NAME_LEN ];
    DWORD   dwEnumIndex             = 0;
    DWORD   dwVirtualSiteId         = 0;
    DWORD   dwValidVirtualSiteCount = 0;
    HRESULT hr						= S_OK;
    WCHAR   wszBuffer[ MAX_STRINGIZED_ULONG_CHAR_COUNT ];

    
    // enumerate all keys under IIS_MD_W3SVC

	for(dwEnumIndex=0; SUCCEEDED(hr); dwEnumIndex++)
	{
		hr = m_pIMSAdminBase->EnumKeys(m_hMBHandle,
									   NULL,
									   wszKeyName,
									   dwEnumIndex);
        //
        // See if we have a virtual site, as opposed to some other key, 
        // by checking if the key name is numeric (and greater than zero). 
        // Ignore other keys.
        //
        // Note that _wtol returns zero if the string passed to it is not 
        // numeric. 
        //
        // Note also that using _wtol we will mistake a key that starts 
        // numeric but then has non-numeric characters as a number, leading 
        // us to try to read it as a virtual site. This is harmless though 
        // because it will not contain valid site properties, so we will
        // end up ignoring it in the end. In any case, such site names
        // are illegal in previous IIS versions anyways. We also check in
        // debug builds for this case.
        //
        
        dwVirtualSiteId = _wtol( wszKeyName );

        if ( dwVirtualSiteId > 0 )
        {
            ASSERT( wcscmp( wszKeyName, _ltow( dwVirtualSiteId, wszBuffer, 10 ) ) == 0 );

			//
			// TODO: trace that  you are reading a site
			//

            hr = CookDownSite(wszKeyName, 
				              i_pWASChngObj,
				              dwVirtualSiteId ); 

            if (FAILED(hr))
            {
            
				//
				// There is no need to log error messages here as 
				// it will be done in CookDownSite
				//
                hr = S_OK;
            }
            else
                dwValidVirtualSiteCount++;
        }
        else
        {
			//
			// TODO: Trace: "Ignoring key under /LM/W3SVC while looking for 
			// virtual sites: %S\n"
			//
        }

	}  

    if ( FAILED(hr))	
    {
		if(HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
			hr = S_OK;
		else
		{
			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_SITES, NULL));			
		}
    }
    
    //
    // Make sure we found at least one virtual site; if not, it is 
    // a fatal error.
    //
    
    if (dwValidVirtualSiteCount == 0 )
    {
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_NO_VALID_SITES, NULL));

		//
		// Delete all sites that may be present.
		//

		hr = DeleteAllSites();
    }
	else if (SUCCEEDED(hr))
	{
		hr = DeleteObsoleteSites();

		if(FAILED(hr))
		{
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
		}
		else
		{
			hr = m_pMBApplicationCooker->DeleteObsoleteApplications();

			if(FAILED(hr))
			{
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));
			}

		}

	}

	//
	// TODO: Trace valid virtual site count.
	//

    return hr;

} // CMBSiteCooker::CookDown


HRESULT CMBSiteCooker::EndCookDown()
{
	HRESULT hr;

	hr = m_pISTCLB->UpdateStore();

	if(FAILED(hr))
	{
		hr = GetDetailedErrors(hr);

		return hr;
	}

	hr = m_pMBApplicationCooker->EndCookDown();

	return hr;

} // CMBSiteCooker::EndCookDown


HRESULT CMBSiteCooker::CookDownSite(LPCWSTR            i_wszVirtualSiteKeyName,
									WAS_CHANGE_OBJECT* i_pWASChngObj,
								    DWORD              i_dwVirtualSiteId)
{

    HRESULT hr = S_OK;
    BOOL	ValidRootApplicationExists = FALSE;    

    ASSERT( i_wszVirtualSiteKeyName != NULL );

    WCHAR wszSiteRootPath[ 1 + MAX_STRINGIZED_ULONG_CHAR_COUNT + ( sizeof( IIS_MD_VIRTUAL_SITE_ROOT ) / sizeof ( WCHAR ) ) + 1 ];
    _snwprintf( wszSiteRootPath, sizeof( wszSiteRootPath ) / sizeof ( WCHAR ), L"/%s%s", i_wszVirtualSiteKeyName, IIS_MD_VIRTUAL_SITE_ROOT );

    WCHAR wszAppRootPath[ 1 + MAX_STRINGIZED_ULONG_CHAR_COUNT + ( sizeof( IIS_MD_VIRTUAL_SITE_ROOT ) / sizeof ( WCHAR ) ) + 1 + 1];
    _snwprintf( wszAppRootPath, sizeof( wszAppRootPath ) / sizeof ( WCHAR ), L"/%s%s/", i_wszVirtualSiteKeyName, IIS_MD_VIRTUAL_SITE_ROOT );

    hr = ReadAllBindingsAndReturnUrlPrefixes(i_wszVirtualSiteKeyName);

    if ( FAILED( hr ) )
    {
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_BINDINGS, i_wszVirtualSiteKeyName));
		goto exit;
    }

	*(DWORD*)m_apv[iSITES_SiteID] = i_dwVirtualSiteId; 
    
	//
	// Read site properties from the metabase.
	//

	hr = GetData((LPWSTR)i_wszVirtualSiteKeyName);

	if(FAILED(hr))
	{
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_ERROR_ENUM_METABASE_SITE_PROPERTIES, i_wszVirtualSiteKeyName));
		goto exit;
	}

	//
	// Read filter flags after getting the data, so that it is overwritten
	//

	hr = ReadSiteFilterFlags(i_wszVirtualSiteKeyName);

    if ( FAILED( hr ) )
    {
		LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_SITEFILTERFLAGS, i_wszVirtualSiteKeyName));
		goto exit;
    }

	//
	// Validate Site
	//

	hr = ValidateSite();

	if(FAILED(hr))
		goto exit;    //
					  // There is no need to log error messages here as 
					  // it will be done in ValidateSite
					  //

	//
	// Copy all Site rows.
	//

	hr = CopyRows(&(m_apv[iSITES_SiteID]),
		          i_pWASChngObj);

	if(FAILED(hr))
	{
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_SITE_INTERNAL_ERROR, i_wszVirtualSiteKeyName));
		goto exit;
	}


    //
    // Read and create the applications of this virtual site.
    //

    hr = m_pMBApplicationCooker->CookDown(wszAppRootPath,
										  wszSiteRootPath, 
                                          i_dwVirtualSiteId,
										  i_pWASChngObj,
                                          &ValidRootApplicationExists);

    if ( FAILED( hr ) )
    {
    
		//
		// There is no need to log error messages here as 
		// it will be done in CookDown. 
		//

		goto exit;

		//
		// TODO: Should we validate that root app exists and conitnue?
		// or Should we delete site and continue?
		//
    }


    //
    // Make sure that the root application exists for this site and is
    // valid; if not, the site is considered invalid. 
    //

exit:

    if (!ValidRootApplicationExists || FAILED(hr))
    {
        //
		// Delete the site we just created. Also clean up any app within 
		// the site.
		//

		DeleteSite(i_wszVirtualSiteKeyName,
		           i_dwVirtualSiteId);
    
    }

    return hr;

}   // CCooker::CookDownSite


HRESULT CMBSiteCooker::ReadSiteFilterFlags(LPCWSTR	i_wszVirtualSiteKeyName)
{
	HRESULT			hr					= S_OK;
    WCHAR			wszSiteFilterFlagsRootPath[1 + 
							                   MAX_STRINGIZED_ULONG_CHAR_COUNT + 
									           (sizeof(IIS_MD_VIRTUAL_SITE_FILTER_FLAGS_ROOT)/sizeof(WCHAR))+
											   1 
											  ];

	//
	// Construct the starting key.
	//

    _snwprintf(wszSiteFilterFlagsRootPath, 
	           sizeof(wszSiteFilterFlagsRootPath)/sizeof(WCHAR), 
			   L"/%s%s", 
			   i_wszVirtualSiteKeyName, 
			   IIS_MD_VIRTUAL_SITE_FILTER_FLAGS_ROOT);

	//
	// Compute rolled up filter flags starting from wszSiteFilterFlagsRootPath
	// MD_FILTER_FLAGS
	//

	return ReadFilterFlags(wszSiteFilterFlagsRootPath,
						   (DWORD**)(&(m_apv[iSITES_FilterFlags])),
						   &(m_acb[iSITES_FilterFlags]));

} // CMBSiteCooker::ReadSiteFilterFlags


HRESULT CMBSiteCooker::DeleteObsoleteSites()
{
	HRESULT hr = S_OK;

	hr = ComputeObsoleteReadRows();

	if(FAILED(hr))
		return hr;

	for(ULONG i=0; i<m_paiReadRowObsolete->size(); i++)
	{
		hr = DeleteSiteAt((*m_paiReadRowObsolete)[i]);

		if(FAILED(hr))
		{
			return hr;
		}
	}

	return hr;

} // CMBSiteCooker::DeleteObsoleteSites


HRESULT CMBSiteCooker::DeleteSiteAt(ULONG i_iReadRow)
{
	HRESULT hr           = S_OK;
	DWORD*  pdwSiteID    = NULL;
	ULONG   iCol         = iSITES_SiteID;
	WCHAR   wszKeyName[21];

	hr = m_pISTCLB->GetColumnValues(i_iReadRow,
			                        1,
									&iCol,
									NULL,
									(LPVOID*)&pdwSiteID);

	if (FAILED(hr))
	{
		return hr;
	}

    _ltow(*pdwSiteID, wszKeyName, 10 );

	hr = DeleteSite(wszKeyName,
			        *pdwSiteID);

	return hr;

} // CMBSiteCooker::DeleteObsoleteSites


HRESULT CMBSiteCooker::DeleteAllSites()
{
	HRESULT hr           = S_OK;
	DWORD*  pdwSiteID    = NULL;
	ULONG   iCol         = iSITES_SiteID;
	WCHAR   wszKeyName[21];

	//
	// Go through the read cache and delete all sites.
	//

	for(ULONG i=0; ;i++)
	{
		hr = DeleteSiteAt(i);
		
		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if (FAILED(hr))
		{
			return hr;
		}
	}

	return hr;

} // CMBSiteCooker::DeleteAllSites


HRESULT CMBSiteCooker::DeleteSite(LPCWSTR i_wszVirtualSiteKeyName,
								  DWORD   i_dwVirtualSiteId)
{

    HRESULT hr = S_OK;

    ASSERT( i_wszVirtualSiteKeyName != NULL );

    WCHAR wszSiteRootPath[ 1 + MAX_STRINGIZED_ULONG_CHAR_COUNT + ( sizeof( IIS_MD_VIRTUAL_SITE_ROOT ) / sizeof ( WCHAR ) ) + 1 ];
    _snwprintf( wszSiteRootPath, sizeof( wszSiteRootPath ) / sizeof ( WCHAR ), L"/%s%s", i_wszVirtualSiteKeyName, IIS_MD_VIRTUAL_SITE_ROOT );

    WCHAR wszAppRootPath[ 1 + MAX_STRINGIZED_ULONG_CHAR_COUNT + ( sizeof( IIS_MD_VIRTUAL_SITE_ROOT ) / sizeof ( WCHAR ) ) + 1 + 1];
    _snwprintf( wszAppRootPath, sizeof( wszAppRootPath ) / sizeof ( WCHAR ), L"/%s%s/", i_wszVirtualSiteKeyName, IIS_MD_VIRTUAL_SITE_ROOT );


    hr = m_pMBApplicationCooker->DeleteApplication(wszAppRootPath,
												   wszSiteRootPath, 
												   i_dwVirtualSiteId,
												   TRUE);

    if ( FAILED( hr ) )
    {   
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_DELETING_SITE_APPLICATIONS, i_wszVirtualSiteKeyName));
		return hr;

    }

	//
	// Delete the site itself.
	//

	*(DWORD*)m_apv[iSITES_SiteID] = i_dwVirtualSiteId; 

	hr = DeleteRow(&m_apv[iSITES_SiteID]);

	if(FAILED(hr))
	{
		LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_DELETING_SITE, i_wszVirtualSiteKeyName));
		return hr;
	}

    return hr;

}   // CCooker::DeleteSite


HRESULT CMBSiteCooker::ReadAllBindingsAndReturnUrlPrefixes(LPCWSTR i_wszVirtualSiteKeyName)
{
    HRESULT			hr					= S_OK;
	DWORD			dwRequiredDataLen	= 0;
    METADATA_RECORD mdr;

	BYTE			aFixedServerBindings[1024];						// TODO: Figure out max.
	BYTE			aFixedSecureBindings[1024];						// TODO: Figure out max.
	BYTE			aFixedUrlPrefix[(1024*2)+2];					// TODO: Figure out max
	BYTE*			aServerBindings		= (BYTE*)aFixedServerBindings;
	BYTE*			aSecureBindings		= (BYTE*)aFixedSecureBindings;
	BYTE*			aUrlPrefix			= (BYTE*)aFixedUrlPrefix;
	DWORD			cbServerBindings	= 1024;
	DWORD			cbSecureBindings	= 1024;
	DWORD			cbUrlPrefix			= (1024*2)+2;
	DWORD			cbUsedUrlPrefix		= 0;

    ASSERT( i_wszVirtualSiteKeyName != NULL );

    //
    // Read the server binding information for this virtual site from the 
    // metabase. This property is not required.
    //

	mdr.dwMDIdentifier = MD_SERVER_BINDINGS;
	mdr.dwMDAttributes = METADATA_INHERIT;
	mdr.dwMDUserType   = ALL_METADATA;
	mdr.dwMDDataType   = MULTISZ_METADATA;
	mdr.dwMDDataLen    = cbServerBindings;
	mdr.pbMDData       = (BYTE *)aServerBindings;

	do
	{
		hr = m_pIMSAdminBase->GetData(m_hMBHandle,
									  i_wszVirtualSiteKeyName,
									  &mdr,
									  &dwRequiredDataLen);

		if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
		{
			// Resize the pv buffer and retry

			aServerBindings = NULL;
			aServerBindings = new BYTE[dwRequiredDataLen];
			if(NULL == aServerBindings)
				hr = E_OUTOFMEMORY;
			cbServerBindings = dwRequiredDataLen;
			mdr.dwMDDataLen    = cbServerBindings;
			mdr.pbMDData       = aServerBindings;

		}

		if((SUCCEEDED(hr)) && 
		   (BINARY_METADATA == mdr.dwMDDataType || MULTISZ_METADATA == mdr.dwMDDataType))
		{
			cbServerBindings = mdr.dwMDDataLen;
		}
		else if(MD_ERROR_DATA_NOT_FOUND == hr)
		{
			//
			// TODO: Is there a better way to handle this? We are undoing 
			// the effect of pre-allocation be doing this.
			//

			aServerBindings = NULL;
			cbServerBindings = 0;
			hr = S_OK;
		}


	}while(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr);

	if(FAILED(hr))
		return hr;

    hr = ConvertBindingsToUrlPrefixes(aServerBindings, 
                                      PROTOCOL_STRING_HTTP,
                                      PROTOCOL_STRING_HTTP_CHAR_COUNT_SANS_TERMINATION,
                                      &aUrlPrefix,
				                      &cbUrlPrefix,
									  &cbUsedUrlPrefix);

	if(FAILED(hr))
		return hr;


	//
	// Get Secure bindings and convert to URLPrefix
	//

	mdr.dwMDIdentifier = MD_SECURE_BINDINGS;
	mdr.dwMDAttributes = METADATA_INHERIT;
	mdr.dwMDUserType   = ALL_METADATA;
	mdr.dwMDDataType   = MULTISZ_METADATA;
	mdr.dwMDDataLen    = cbSecureBindings;
	mdr.pbMDData       = (BYTE *)aSecureBindings;

	do
	{
		hr = m_pIMSAdminBase->GetData(m_hMBHandle,
									  i_wszVirtualSiteKeyName,
									  &mdr,
									  &dwRequiredDataLen);

		if(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
		{
			// Resize the pv buffer and retry

			aSecureBindings = NULL;
			aSecureBindings = new BYTE[dwRequiredDataLen];
			if(NULL == aSecureBindings)
				hr = E_OUTOFMEMORY;
			cbSecureBindings   = dwRequiredDataLen;
			mdr.dwMDDataLen    = cbSecureBindings;
			mdr.pbMDData       = aSecureBindings;

		}

		if((SUCCEEDED(hr)) && 
		   (BINARY_METADATA == mdr.dwMDDataType || MULTISZ_METADATA == mdr.dwMDDataType))
		{
			cbSecureBindings = mdr.dwMDDataLen;
		}
		else if(MD_ERROR_DATA_NOT_FOUND == hr)
		{
			//
			// TODO: Is there a better way to handle this? We are undoing 
			// the effect of pre-allocation be doing this.
			//

			aSecureBindings = NULL;
			cbSecureBindings = 0;
			hr = S_OK;
		}


	}while(HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr);

	if(FAILED(hr))
		return hr;

	if(cbUsedUrlPrefix > 0)
		cbUsedUrlPrefix = cbUsedUrlPrefix - sizeof(WCHAR);

    hr = ConvertBindingsToUrlPrefixes(aSecureBindings, 
                                      PROTOCOL_STRING_HTTPS,
                                      PROTOCOL_STRING_HTTPS_CHAR_COUNT_SANS_TERMINATION,
                                      &aUrlPrefix,
				                      &cbUrlPrefix,
									  &cbUsedUrlPrefix);

	if(FAILED(hr))
		return hr;


	if(m_acb[iSITES_Bindings] < cbUsedUrlPrefix)
	{
		//
		// If what was allocated previously is less than the size after 
		// trasforming, then reallocate. 
		//

		if(NULL != m_apv[iSITES_Bindings])
		{
			delete [] m_apv[iSITES_Bindings];
			m_apv[iSITES_Bindings] = NULL;
			m_acb[iSITES_Bindings] = 0;
		}
		m_apv[iSITES_Bindings] = new WCHAR[cbUsedUrlPrefix];
		if(NULL == m_apv[iSITES_Bindings])
			return E_OUTOFMEMORY;

	}

	m_acb[iSITES_Bindings] = cbUsedUrlPrefix;
	memcpy(m_apv[iSITES_Bindings],aUrlPrefix,cbUsedUrlPrefix);

	if((0 == cbSecureBindings) && (0 == cbServerBindings) )
	{
		//
		// If both server and secure bindings are not found, then treat as error
		//
		hr = MD_ERROR_DATA_NOT_FOUND;
	}

	//
	// TODO: Leaking memory if aUrlPrefix has been reallocated under the cover i.e. if aUrlPrefix != aUrlPrefixFixed
	//

    return hr;

} // CMBSiteCooker::ReadAllBindingsAndReturnUrlPrefixes


HRESULT CMBSiteCooker::ValidateSite()
{

	HRESULT hr	            = S_OK;
	LPVOID	pv			    = NULL;
	ULONG   cb              = 0;

	for(ULONG iCol=0; iCol<m_cCol; iCol++)
	{
		if(NULL != m_apv[iCol])
		{
			hr = ValidateSiteColumn(iCol,
			                        m_apv[iCol],
								    m_acb[iCol]);

			if(HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
			{
				//
				// Data was invalid - force default,
				//

				delete [] m_apv[iCol];
				m_apv[iCol] = NULL;			
				m_acb[iCol] = 0;
			}
			else if(FAILED(hr))
			{
				return hr; // If any other failure return
			}

		}

		if(NULL == m_apv[iCol])
		{
			//
			// If you reach here it means that either the value was
			// null, or the value was invalid and hence it has been
			// set to null so that defaults can be applied.
			//

			hr = GetDefaultValue(iCol,
				                 &pv,  
								 &cb);
			if(FAILED(hr))
			{
				return hr;
			}

			hr = ValidateSiteColumn(iCol,
			                        pv,
								    cb);

			if(FAILED(hr))
			{
				if(HRESULT_FROM_WIN32(ERROR_INVALID_DATA) == hr)
				{
					ASSERT(0 && L"Invalid default - fix the schema");
				}
				return hr;
			}
		}

	}

	return hr;

} // CMBSiteCooker::ValidateSite


HRESULT CMBSiteCooker::ValidateSiteColumn(ULONG  i_iCol,
                                          LPVOID i_pv,
                                          ULONG  i_cb)
{
	HRESULT hr              = S_OK;
	DWORD	dwMax			= 0;
	WCHAR   wszMin[20];
	WCHAR   wszMax[20];
	WCHAR   wszValue[20];
	WCHAR   wszSiteID[20];

	if(NULL == i_pv && (iSITES_Bindings != i_iCol))		// NULL Binding is invalid
	{
		return hr;
	}

	_ultow(*(DWORD*)(m_apv[iSITES_SiteID]), wszSiteID, 10);

	//
	// Always call the base class validate column before doing custom 
	// validations.
	//

	hr = ValidateColumn(i_iCol,
		                i_pv,
						i_cb);

	if(FAILED(hr))
	{
		return hr;
	}

	//
	// Perform any custom validations
	//

	switch(i_iCol)
	{

	case iSITES_MaxConnections:

		if(VER_NT_WORKSTATION == m_pOSVersionInfo->wProductType)
		{
			DWORD dwMax = MAX_CONNECTION_PRO_PERSONAL;

			return ValidateMinMaxRange(*(ULONG *)(i_pv),
				                       NULL,
				                       &dwMax,
                                       iSITES_MaxConnections,
									   NULL);

		}
		break;

	case iSITES_Bindings:

		if(i_pv == NULL || i_cb == 0)
		{
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			LOG_WARNING(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_CONFIG_ERROR_BINDINGS, wszSiteID));
			return hr;
		}

		break;

	default:
		break;

	} // End switch

	return S_OK;

} // CMBSiteCooker::ValidateSite



HRESULT CMBSiteCooker::ConvertBindingsToUrlPrefixes(BYTE*   i_pbBindingStrings,
											        LPCWSTR i_wszProtocolString, 
													ULONG   i_ulProtocolStringCharCountSansTermination,
													BYTE**	io_pbUrlPrefix,
													ULONG*	io_cbUrlPrefix,
													ULONG*	io_cbUsedUrlPrefix)
{

    LPWSTR  wszBindingToConvert		= NULL;
    HRESULT hr						= S_OK;
	ULONG	cbUsedUrlPrefix			= 0;
	BYTE*	pbUrlPrefix				= NULL;
	BOOL	bReallocatedFromFixed	= FALSE;
	LPWSTR	wszTerminatingNull		= L"\0";

	ASSERT(io_pbUrlPrefix != NULL);
	ASSERT(*io_pbUrlPrefix != NULL);
	ASSERT(io_cbUrlPrefix != NULL);
	ASSERT(*io_cbUrlPrefix != 0);

    wszBindingToConvert = (LPWSTR)(i_pbBindingStrings);

    while ((wszBindingToConvert != NULL) && (*wszBindingToConvert != 0))
    {
		LPWSTR	wszResultFixed[MAX_PATH];
		ULONG	cChwszResult	= MAX_PATH;
		LPWSTR	wszResult		= (LPWSTR)wszResultFixed;
        
        hr = BindingStringToUrlPrefix(wszBindingToConvert, 
									  i_wszProtocolString,
									  i_ulProtocolStringCharCountSansTermination,
									  &wszResult,
									  &cChwszResult);

        if (FAILED(hr))
        {        
			LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, NULL));

            //
            // Note: keep trying to convert other bindings.
            //

            hr = S_OK;
        }
        else
        {
            //
            // If we converted one successfully, append it to our result.
            //
        
			if(*io_cbUrlPrefix <  *io_cbUsedUrlPrefix + cbUsedUrlPrefix + Wszlstrlen(wszResult) + 2)
			{
				//
				// Reallocate url prefix and copy previous contents.
				//

				BYTE*	pbSaved = *io_pbUrlPrefix;

				//
				// Allocate double of what is necessary
				//

				*io_cbUrlPrefix = 0;
				*io_pbUrlPrefix = NULL;
				*io_pbUrlPrefix = new BYTE[*io_cbUsedUrlPrefix + 
					((cbUsedUrlPrefix + Wszlstrlen(wszResult) + 2)*2)];

				if(NULL == *io_pbUrlPrefix)
					hr = E_OUTOFMEMORY;
				else
				{
					*io_cbUrlPrefix = *io_cbUsedUrlPrefix + 
						((cbUsedUrlPrefix + (ULONG)Wszlstrlen(wszResult) + 2)*2);

					//
					// Copy the previous contents
					//

					memcpy(*io_pbUrlPrefix, pbSaved, *io_cbUsedUrlPrefix + cbUsedUrlPrefix);

				}

				//
				// Note that when this function is called, io_pbUrlPrefixes
				// points to a fixed array. If we need a larger array, this
				// pointer will be discarded and a new array of the desired size
				// will be dynamically allocated. We should not be deleting the
				// fixed array pointer. We should delete all dynamic array 
				// pointers.
				//

				if(bReallocatedFromFixed)
				{
					if(NULL != pbSaved)
					{
						delete [] pbSaved;
						pbSaved = NULL;
					}
				}
				else
					bReallocatedFromFixed = TRUE;


			}

			//
			// Only E_OUTOFMEMORY failures can occur here
			//

			if(SUCCEEDED(hr)) 
			{
				//
				// Append the result.
				//

				pbUrlPrefix = *io_pbUrlPrefix + *io_cbUsedUrlPrefix + cbUsedUrlPrefix;
				memcpy(pbUrlPrefix, wszResult, ((Wszlstrlen(wszResult)+1)*sizeof(WCHAR)));
				cbUsedUrlPrefix = cbUsedUrlPrefix + (((int)Wszlstrlen(wszResult)+1)*sizeof(WCHAR));
			}
            
        }


        if(wszResult != (LPWSTR)wszResultFixed)
		{
			delete [] wszResult;
			wszResult = NULL;
		}

		//
		// Only E_OUTOFMEMORY failures can occur here
		//

		if(FAILED(hr))
		{
			return hr;
		}

        wszBindingToConvert = wszBindingToConvert + Wszlstrlen(wszBindingToConvert) + 1;

    }

	//
	// Add the terminating NULL
	//

	if(cbUsedUrlPrefix > 0 || *io_cbUsedUrlPrefix > 0)
	{
		pbUrlPrefix = *io_pbUrlPrefix + *io_cbUsedUrlPrefix + cbUsedUrlPrefix;
		memcpy(pbUrlPrefix, wszTerminatingNull, sizeof(WCHAR));
		cbUsedUrlPrefix = cbUsedUrlPrefix + sizeof(WCHAR);
	}

	*io_cbUsedUrlPrefix = *io_cbUsedUrlPrefix + cbUsedUrlPrefix;

    return hr;

}   // CMBSiteCooker::ConvertBindingsToUrlPrefixes


HRESULT CMBSiteCooker::BindingStringToUrlPrefix(LPCWSTR i_wszBindingString,
												LPCWSTR i_wszProtocolString, 
												ULONG   i_ulProtocolStringCharCountSansTermination,
												LPWSTR* io_wszUrlPrefix,
												ULONG*	io_cchUrlPrefix)
{

    HRESULT hr = S_OK;
    LPCWSTR wszIpAddress = NULL;
    LPCWSTR wszIpPort = NULL;
    LPCWSTR wszHostName = NULL;
    ULONG IpAddressCharCountSansTermination = 0;
    ULONG IpPortCharCountSansTermination = 0;
   	LPWSTR	wszTemp = NULL;
	ULONG cCh = 0;


    ASSERT( io_wszUrlPrefix != NULL );
    ASSERT( *io_wszUrlPrefix != NULL );
	ASSERT(io_cchUrlPrefix != NULL);
	ASSERT(*io_cchUrlPrefix !=0);

    
    //
    // Find the various parts of the binding.
    //

    wszIpAddress = i_wszBindingString;

    wszIpPort = wcschr( wszIpAddress, L':' );

    if ( wszIpPort == NULL )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }

    wszIpPort++;

    wszHostName = wcschr( wszIpPort, L':' );

    if (wszHostName == NULL )
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }

    wszHostName++;

    //
    // Validate the ip address.
    //

    if ( *wszIpAddress == L':' )
        wszIpAddress = NULL; // no ip address specified
    else
        IpAddressCharCountSansTermination = (ULONG)(DIFF( wszIpPort - wszIpAddress ) - 1);


    //
    // Validate the ip port.
    //

    if ( *wszIpPort == L':' )
    {
        // no ip port specified in binding string
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto exit;
    }
    
    IpPortCharCountSansTermination = (ULONG)(DIFF(wszHostName - wszIpPort ) - 1);


    //
    // Validate the host-name.
    //

    if (*wszHostName == L'\0' )
    {
        // no host-name specified
        
        wszHostName = NULL;
    }


    //
    // Now create the UL-style URL prefix.
    //

	cCh = i_ulProtocolStringCharCountSansTermination;

    if (wszIpAddress != NULL )
    {
        if (wszHostName != NULL )
        {
            //
            // Note - It was illegal for both host-name and ip address to be specified,
			// but now we just use host name
            //

            //hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            //goto exit;
			cCh += (ULONG)Wszlstrlen(wszHostName);
			wszIpAddress = NULL;

        }
        else
	        cCh += IpAddressCharCountSansTermination;
    }
    else
    {
        if (wszHostName != NULL )
			cCh += (ULONG)Wszlstrlen(wszHostName);
        else
			cCh += (ULONG)Wszlstrlen(L"*");
    }

	cCh += (ULONG)Wszlstrlen(L":");
	cCh += IpPortCharCountSansTermination;
	
	//
	// We are passed in a fixed array. If our size exceeds that of the fixed
	// array, we need to reallocate, but we neednt delete the previous pointer
	// as it will be fixed.
	//

	if(cCh+1 > *io_cchUrlPrefix)
	{
		*io_wszUrlPrefix = NULL;
		*io_cchUrlPrefix = 0;
		*io_wszUrlPrefix = new WCHAR[cCh + 1];
		if(NULL == *io_wszUrlPrefix)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}
		*io_cchUrlPrefix = cCh + 1;

	}

	wszTemp = *io_wszUrlPrefix;

	memcpy(wszTemp, i_wszProtocolString, i_ulProtocolStringCharCountSansTermination*(sizeof(WCHAR)));
	wszTemp += i_ulProtocolStringCharCountSansTermination;

    //
    // Determine whether to use host-name, ip address, or "*".
    //

    if (wszIpAddress != NULL )
    {
        if (wszHostName != NULL )
        {
            //
            // It is illegal for both host-name and ip address to be specified.
            //

            hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
            goto exit;
        }
        else
        {
			memcpy(wszTemp, wszIpAddress, IpAddressCharCountSansTermination*sizeof(WCHAR));
			wszTemp += IpAddressCharCountSansTermination;
        }
    }
    else
    {
        if (wszHostName != NULL )
        {
			memcpy(wszTemp, wszHostName, Wszlstrlen(wszHostName)*sizeof(WCHAR));
			wszTemp += Wszlstrlen(wszHostName);
        }
        else
        {
			memcpy(wszTemp, L"*", Wszlstrlen(L"*")*sizeof(WCHAR));
			wszTemp += Wszlstrlen(L"*");
        }
    }

	memcpy(wszTemp, L":", Wszlstrlen(L":")*sizeof(WCHAR));
	wszTemp += Wszlstrlen(L":");

	memcpy(wszTemp, wszIpPort, IpPortCharCountSansTermination*sizeof(WCHAR));
	wszTemp += IpPortCharCountSansTermination;

	*wszTemp = 0; // terminating NULL

exit:

    //
    // CODEWORK log an event if there was a bad binding string? If so, 
    // need to pass down the site information so we can log which site
    // has the bad binding. 
    //

    return hr;

}   // CMBSiteCooker::BindingStringToUrlPrefix


HRESULT CMBSiteCooker::CookdownSiteFromList(Array<ULONG>*           i_paVirtualSites,
											ISimpleTableWrite2*     i_pISTCLBAppPool,
											IMSAdminBase*		    i_pIMSAdminBase,
	                                        METADATA_HANDLE		    i_hMBHandle,
	                                        ISimpleTableDispenser2* i_pISTDisp,
											LPCWSTR					i_wszCookDownFile)
{
	HRESULT           hr          = S_OK;
	CMBSiteCooker*    pSiteCooker = NULL;
	ULONG		      iSite;
	WCHAR		      wszVirtualSite[20];

	if(0 != i_paVirtualSites->size())
	{
		pSiteCooker = new CMBSiteCooker();
		if(NULL == pSiteCooker)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		hr = pSiteCooker->BeginCookDown(i_pIMSAdminBase,
										i_hMBHandle,
										i_pISTDisp,
										i_wszCookDownFile);

		if(FAILED(hr))
		{
			goto exit;
		}

		//
		// This is needed so that it this cache can be used to
		// validate the apppool
		//

		hr = pSiteCooker->GetAppCooker()->SetAppPoolCache(i_pISTCLBAppPool);

		if(FAILED(hr))
		{
			goto exit;
		}

		for (iSite = 0; iSite < i_paVirtualSites->size(); iSite++)
		{
			_itow((*i_paVirtualSites)[iSite], wszVirtualSite, 10);

			hr = pSiteCooker->CookDownSite(wszVirtualSite, 
				                           NULL, 
										   (*i_paVirtualSites)[iSite]);

			if(FAILED(hr))
				hr = S_OK; // All errors are logged internally, so continue.
		}

		hr = pSiteCooker->EndCookDown();

		if(FAILED(hr))
		{
			goto exit;
		}
	}

exit:

	if(NULL != pSiteCooker)
	{
		delete pSiteCooker;
		pSiteCooker = NULL;
	}

	return hr;

} // CMBSiteCooker::CookdownSiteFromList
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtincptr\dtincptr.h ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//  DTIncptr.h: Definition of the CDTIncptr class - Interceptor for
//              Ducttape table.
//
//////////////////////////////////////////////////////////////////////
#ifndef _DTINCPTR_H_
#define _DTINCPTR_H_


#include "catalog.h"

interface ISimpleTableInterceptor;
/////////////////////////////////////////////////////////////////////////////
// CDTIncptr

class CDTIncptr : 
	public ISimpleTableInterceptor
{
public:
	CDTIncptr();
	~CDTIncptr();


public:

	//IUnknown

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

	//ISimpleDataTable
	STDMETHOD(Intercept)( 
						LPCWSTR						i_wszDatabase,
						LPCWSTR						i_wszTable,
						ULONG						i_TableID,
						LPVOID						i_QueryData,
						LPVOID						i_QueryMeta,
						ULONG						i_QueryType,
						DWORD						i_fTable,
						IAdvancedTableDispenser*	i_pISTDisp,
						LPCWSTR						i_wszLocator,
						LPVOID						i_pSimpleTable,
						LPVOID*						o_ppv);

private:

	HRESULT	GetSrcCFGFileName(LPCWSTR					i_wszDatabase,
							  LPCWSTR					i_wszTable,
							  LPVOID					i_QueryData,	
							  LPVOID					i_QueryMeta,	
							  ULONG						i_eQueryFormat,
							  DWORD						i_fServiceRequests,
							  IAdvancedTableDispenser*	i_pISTDisp,
							  ULONG*					piColSrcCFGFile,
							  LPWSTR*					i_pwszSrcCFGFile);

	HRESULT GetTable(LPCWSTR					i_wszDatabase,
					 LPCWSTR					i_wszTable,
					 LPVOID						i_QueryData,
					 ULONG						nQueryCells,
					 ULONG						i_QueryType,
					 DWORD						i_fLOS,
					 IAdvancedTableDispenser*	i_pISTDisp,
					 LPWSTR						i_wszSrcCFGFile,
					 LPVOID*					o_ppv);

	HRESULT	GetCookedDownFileName(LPWSTR*	i_pwszCookedDownFile);

	HRESULT	GetGlobalFileName(LPWSTR*	i_pwszCookedDownFile);

	HRESULT GetPathDir(LPWSTR*	i_pwszPathDir);

private:

  ULONG       m_cRef;
};

#endif // _DTINCPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtplugin\dtplugin.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/


#ifndef __DTPLUGIN_H__
#define __DTPLUGIN_H__

#include "catalog.h"

union Values
{
	DWORD	dwUI4;
	WCHAR	*pWCHAR;
	BYTE	*pBYTE;
};

struct STDefaultValues
{
	LPCWSTR         wszTable;
	ULONG			iCol;
	Values			Val;

};

class CDTPlugin:
	public ISimplePlugin
{
public:
	CDTPlugin() 
		:m_cRef(0)
	{}

	// IUnknown
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release) 		();

	// ISimplePlugin 
	STDMETHOD (OnInsert)(ISimpleTableDispenser2* i_pDisp, LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, DWORD i_fLOS, ULONG i_iRow, ISimpleTableWrite2* i_pISTW2);
	STDMETHOD (OnUpdate)(ISimpleTableDispenser2* i_pDisp,LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, DWORD i_fLOS, ULONG i_iRow, ISimpleTableWrite2* i_pISTW2);
	STDMETHOD (OnDelete)(ISimpleTableDispenser2* i_pDisp,LPCWSTR i_wszDatabase, LPCWSTR i_wszTable, DWORD i_fLOS, ULONG i_iRow, ISimpleTableWrite2* i_pISTW2);

private:
	HRESULT ValidateRow(LPCWSTR              i_wszTable,
								DWORD		         i_fLOS, 
							    ULONG                i_iRow,
								ISimpleTableWrite2*  i_pISTW2);

	HRESULT ApplyColumnDefaults(ISimpleTableWrite2*	 i_pISTWrite, 
		                        ULONG                i_iRow, 
								STDefaultValues*     i_aDefaultValues, 
								ULONG                i_cDefaultValues);

	HRESULT	ValidateForeignKey(LPWSTR	i_wszTable,
							   DWORD	i_fLOS, 
							   LPVOID*	i_apvIdentity);

	HRESULT	ValidateColumnConstraintsForSites(DWORD	  i_fLOS, 
                                              ULONG   i_cCol, 
											  ULONG*  i_aSize, 
											  LPVOID* i_apv);

	HRESULT	ValidateColumnConstraintsForAppPools(ULONG   i_cCol, 
												 ULONG*  i_aSize, 
												 LPVOID* i_apv);

	HRESULT	ValidateColumnConstraintsForBindings(ULONG   i_cCol, 
											     ULONG*  i_aSize, 
											     LPVOID* i_apv);

	HRESULT	ValidateColumnConstraintsForApplicationList(DWORD	i_fLOS, 
                                                        ULONG   i_cCol, 
											            ULONG*  i_aSize, 
											            LPVOID* i_apv);
	HRESULT ExpandEnvString(LPCWSTR i_wszPath,
							LPWSTR* o_pwszExpandedPath);

	HRESULT GetAttribute(LPCWSTR i_wszFile);

	HRESULT GetTable(LPCWSTR	i_wszDatabase,
				     LPCWSTR	i_wszTable,
					 LPVOID		i_QueryData,	
					 LPVOID		i_QueryMeta,	
					 ULONG		i_eQueryFormat,
					 DWORD		i_fServiceRequests,
					 LPVOID*	o_ppIST);

	WCHAR	HexCharToNumber(IN WCHAR ch);

	DWORD	DecodeUrl(IN		LPWSTR Url,
					  IN		DWORD UrlLength,
					  OUT		LPWSTR DecodedString,
					  IN OUT	LPDWORD DecodedLength);

	DWORD	DecodeUrlInSitu(IN     LPWSTR	BufferAddress,
							IN OUT LPDWORD	BufferLength);

	DWORD	DecodeUrlStringInSitu(IN     LPWSTR BufferAddress,
								  IN OUT LPDWORD BufferLength);

	DWORD	GetUrlAddressInfo(IN OUT LPWSTR* Url,
							  IN OUT LPDWORD UrlLength,
							  OUT    LPWSTR* PartOne,
							  OUT    LPDWORD PartOneLength,
							  OUT    LPBOOL PartOneEscape,
							  OUT    LPWSTR* PartTwo,
							  OUT    LPDWORD PartTwoLength,
							  OUT    LPBOOL PartTwoEscape);

	DWORD	GetUrlAddress(IN OUT LPWSTR* lpszUrl,
						  OUT    LPDWORD lpdwUrlLength,
						  OUT    LPWSTR* lpszUserName OPTIONAL,
						  OUT    LPDWORD lpdwUserNameLength OPTIONAL,
						  OUT    LPWSTR* lpszPassword OPTIONAL,
						  OUT    LPDWORD lpdwPasswordLength OPTIONAL,
						  OUT    LPWSTR* lpszHostName OPTIONAL,
						  OUT    LPDWORD lpdwHostNameLength OPTIONAL,
						  OUT    LPDWORD lpPort OPTIONAL,
//						  OUT    LPINTERNET_PORT lpPort OPTIONAL,
						  OUT    LPBOOL pHavePort);

	BOOLEAN ValidateBinding(IN PWCHAR InputUrl);

private:
	ULONG   m_cRef;
};

#endif	// __DTPLUGIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtplugin\dtplugin.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "DTPlugin.h"
#include "Catmeta.h"
#include "catmacros.h"
#include "SvcMsg.h"
#include "limits.h"

#define	cmaxCOLUMNS			20

// -----------------------------------------
// CDTPlugin: IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CDTPlugin::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimplePlugin)
	{
		*ppv = (ISimplePlugin*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimplePlugin*) this;
	}

	if (NULL != *ppv)
	{
		((ISimplePlugin*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CDTPlugin::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
}

// =======================================================================
STDMETHODIMP_(ULONG) CDTPlugin::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
// ------------------------------------
// ISimpleTablePlugin:
// ------------------------------------

STDMETHODIMP CDTPlugin::OnInsert(
	ISimpleTableDispenser2* i_pDisp,
	LPCWSTR		i_wszDatabase, 
	LPCWSTR		i_wszTable, 
	DWORD		i_fLOS, 
	ULONG		i_Row,
	ISimpleTableWrite2* i_pISTW2)
{
	return ValidateRow(i_wszTable, 
					   	       i_fLOS, 
			                   i_Row, 
							   i_pISTW2);
}

STDMETHODIMP CDTPlugin::OnUpdate(
	ISimpleTableDispenser2* i_pDisp,
	LPCWSTR		i_wszDatabase, 
	LPCWSTR		i_wszTable, 
	DWORD		i_fLOS, 
	ULONG		i_Row, 
	ISimpleTableWrite2* i_pISTW2)
{
	return ValidateRow(i_wszTable, 
					   	       i_fLOS, 
			                   i_Row, 
							   i_pISTW2);
}

STDMETHODIMP CDTPlugin::OnDelete(
	ISimpleTableDispenser2* i_pDisp,
	LPCWSTR		i_wszDatabase, 
	LPCWSTR		i_wszTable, 
	DWORD		i_fLOS, 
	ULONG		i_Row, 
	ISimpleTableWrite2* i_pISTW2)
{
	ASSERT(0 && L"Logic check on delete is not yet implemented");
	return E_NOTIMPL;
}

// ==================================================================
HRESULT CDTPlugin::ValidateRow(LPCWSTR              i_wszTable,
									   DWORD		        i_fLOS, 
	  								   ULONG                i_iRow, 
									   ISimpleTableWrite2*  i_pISTWrite)
{

	LPVOID							a_StaticpvData[cmaxCOLUMNS];
	ULONG							a_StaticSize[cmaxCOLUMNS];
	ULONG							cCol;
	LPVOID*							a_pvData	= NULL;
	ULONG*							a_Size		= NULL;
	HRESULT							hr;
	HRESULT							hrSites = S_OK;
	CComPtr<ISimpleTableController>	pISTController;

	hr = i_pISTWrite->QueryInterface(IID_ISimpleTableController, (void**)&pISTController);

	if(FAILED(hr))
		return hr;

	hr = i_pISTWrite->GetTableMeta(NULL, 
								   NULL, 
								   NULL, 
								   &cCol);
	if(FAILED(hr))
		return hr;

	if(cCol > cmaxCOLUMNS)
	{
		a_Size = new ULONG[cCol];
		if(NULL == a_Size)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}

		a_pvData = new LPVOID[cCol];
		if(NULL == a_pvData)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}
	}
	else
	{
		a_Size = a_StaticSize;
		a_pvData = a_StaticpvData;
	}


	ASSERT(0 && L"Plugins are not supported for this table");
	hr = E_INVALIDARG;
	goto Cleanup;

	if(FAILED(hr))
	{
	// This means some column constraints were violated.
		hr = pISTController->SetWriteRowAction(i_iRow, eST_ROW_DELETE);

		if(FAILED(hr))
			TRACE(L"SetWriteRowAction fors table %s. failed with hr = %08x\n",i_wszTable,  hr);

	}

Cleanup:

	if(cCol > cmaxCOLUMNS)
	{
		if(NULL != a_Size)
		{
			delete[] a_Size;
			a_Size = NULL;
		}

		if(NULL != a_pvData)
		{
			delete[] a_pvData;
			a_pvData = NULL;
		}
	}

	if(SUCCEEDED(hr) && (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hrSites))
		return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
	else
		return hr;

}


// ==================================================================
HRESULT	CDTPlugin::ValidateColumnConstraintsForSites(DWORD	 i_fLOS,
													 ULONG   i_cCol, 
											         ULONG*  i_aSize, 
											         LPVOID* i_apv)
{
	HRESULT hr				= S_OK;
	DWORD	cb				= 0;
	WCHAR	wszTemp[MAX_PATH];

// TODO: Define correct error codes.

	for(ULONG iCol=0; iCol<i_cCol; iCol++)
	{
		LPWSTR wszHomeDirExpand = NULL;

		switch(iCol)
		{

		case iSITES_SiteID:
			if(0 > *(LONG *)(i_apv[iCol]))
			{
				wsprintf(wszTemp, 
					     L"Site %d must be > 0. Ignoring this site.\n", 
					     *(DWORD *)(i_apv[iCol]));
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			break;

		default:
			break;

		}

	}

	return hr;

}


// ==================================================================
HRESULT	CDTPlugin::ValidateColumnConstraintsForAppPools(ULONG   i_cCol, 
												        ULONG*  i_aSize, 
												        LPVOID* i_apv)
{
	HRESULT hr	          = S_OK;
	DWORD	dwRestartTime = 0;
	DWORD	dwIdleTimeout = 0;
	WCHAR	wszTemp[MAX_PATH];
	ULONG   maxAppPool    = 256;
	ULONG   minAppPool    = 1;

// TODO: Define correct error codes.

	for(ULONG iCol=0; iCol<i_cCol; iCol++)
	{
		switch(iCol)
		{

		case iAPPPOOLS_AppPoolID:
			if((256 < lstrlenW((WCHAR*)i_apv[iCol])) || (1 > lstrlenW((WCHAR*)i_apv[iCol])))
			{
				WCHAR* wszTempLong = new WCHAR[lstrlenW((WCHAR*)i_apv[iCol]) + 100];
				if(!wszTempLong)
					return E_OUTOFMEMORY;

				wsprintf(wszTempLong, 
					     L"Invalid App pool ID %s. Should be <= %d and >= %d char. Ignoring this app pool.\n", 
						   (LPWSTR)(i_apv[iCol]), maxAppPool, minAppPool);
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTempLong));

				delete[] wszTempLong;
				wszTempLong = NULL;

				return E_UNEXPECTED;
			}
			break;

		case iAPPPOOLS_PeriodicRestartTime:
			if(0 > *(DWORD *)(i_apv[iCol]))
			{
				wsprintf(wszTemp, 
					     L"Invalid periodic restart time %d. Should be >= 0. Ignoring app pool %s.\n", 
						 *(DWORD *)(i_apv[iCol]), 
						 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			dwRestartTime = *(DWORD *)(i_apv[iCol]);
			break;

		case iAPPPOOLS_PeriodicRestartRequests:
			if(0 > *(DWORD *)(i_apv[iCol]))
			{
				wsprintf(wszTemp, 
					     L"Invalid periodic restart request %d. Should be >= 0. Ignoring app pool %s.\n", 
						 *(DWORD *)(i_apv[iCol]), 
						 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			break;

		case iAPPPOOLS_MaxProcesses:
			if(0 > *(DWORD *)(i_apv[iCol]))
			{
				wsprintf(wszTemp, 
					     L"Invalid max processes %d. Should be >= 0. Ignoring app pool %s.\n", 
						 *(DWORD *)(i_apv[iCol]), 
						 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			break;

		case iAPPPOOLS_IdleTimeout:
			if(0 > *(DWORD *)(i_apv[iCol]))
			{
				wsprintf(wszTemp, 
					     L"Invalid idle timeout %d. Should be >= 0. Ignoring app pool %s.\n", 
						 *(DWORD *)(i_apv[iCol]), 
						 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			dwIdleTimeout = *(DWORD *)(i_apv[iCol]);
			break;

		case iAPPPOOLS_StartupTimeLimit:		
			if((NULL != i_apv[iCol]) && 
			   ((1 > *(DWORD *)(i_apv[iCol])) || ((ULONG_MAX/1000) <= *(DWORD *)(i_apv[iCol]))))
			{
				wsprintf(wszTemp, 
					     L"Invalid Startup time limit: %d. Should be >= 1 and < ULONG_MAX/1000. Ignoring app pool %s.\n", 
						 *(DWORD *)(i_apv[iCol]), 
						 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			break;

		case iAPPPOOLS_ShutdownTimeLimit:		
			if((NULL != i_apv[iCol]) && 
			   ((1 > *(DWORD *)(i_apv[iCol])) || ((ULONG_MAX/1000) <= *(DWORD *)(i_apv[iCol]))))
			{
				wsprintf(wszTemp, 
					     L"Invalid Shutdown time limit: %d. Should be >= 1 and < ULONG_MAX/1000. Ignoring app pool %s.\n", 
						 *(DWORD *)(i_apv[iCol]), 
						 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			break;

		case iAPPPOOLS_PingInterval:		
			if((NULL != i_apv[iCol]) && 
			   ((1 > *(DWORD *)(i_apv[iCol])) || ((ULONG_MAX/1000) <= *(DWORD *)(i_apv[iCol]))))
			{
				wsprintf(wszTemp, 
					     L"Invalid Ping interval: %d. Should be >= 1 and < ULONG_MAX/1000. Ignoring app pool %s.\n", 
						 *(DWORD *)(i_apv[iCol]), 
						 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			break;

		case iAPPPOOLS_PingResponseTime:		
			if((NULL != i_apv[iCol]) && 
			   ((1 > *(DWORD *)(i_apv[iCol])) || ((ULONG_MAX/1000) <= *(DWORD *)(i_apv[iCol]))))
			{
				wsprintf(wszTemp, 
					     L"Invalid Ping response time limit: %d. Should be >= 1 and < ULONG_MAX/1000. Ignoring app pool %s.\n", 
						 *(DWORD *)(i_apv[iCol]), 
						 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}
			break;

		default:
			break;

		} // End switch

	}

	if((dwRestartTime > 0) && (dwIdleTimeout >0))
	{
		if(dwIdleTimeout >= dwRestartTime)
		{
			wsprintf(wszTemp, 
					 L"Idle time out %d should be < periodic restart time %d. Ignoring app pool %s.\n", 
					 *(DWORD *)(i_apv[iAPPPOOLS_IdleTimeout]), 
					 *(DWORD *)(i_apv[iAPPPOOLS_PeriodicRestartTime]), 
					 (LPWSTR)(i_apv[iAPPPOOLS_AppPoolID]) );
			LOG_ERROR(Win32, (E_UNEXPECTED, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
			return E_UNEXPECTED;
		}
	}

	return hr;

}


// ==================================================================
HRESULT	CDTPlugin::ValidateColumnConstraintsForBindings(ULONG   i_cCol, 
											            ULONG*  i_aSize, 
											            LPVOID* i_apv)
{
	HRESULT hr				= S_OK;
	WCHAR	wszTemp[MAX_PATH];
	LPWSTR	wszBinding		=  NULL; 

// TODO: Define correct error codes.

	for(ULONG iCol=0; iCol<i_cCol; iCol++)
	{
		switch(iCol)
		{

		case iSITES_Bindings:
			if((NULL == ((LPWSTR)(i_apv[iCol]))) ||
			   (0    == *((LPWSTR)(i_apv[iCol]))) 
			  )
			{
				wsprintf(wszTemp, 
					     L"NULL binding encountered. Ignoring this binding for site %d.\n", 
						 *(DWORD *)(i_apv[iSITES_SiteID]));
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				return E_UNEXPECTED;
			}

			wszBinding = new WCHAR[Wszlstrlen((LPWSTR)(i_apv[iCol]))+1];
			if(NULL == wszBinding)
				return E_OUTOFMEMORY;
			Wszlstrcpy(wszBinding, (LPWSTR)(i_apv[iCol])); // Validate URL may make modifications in place

			if(!ValidateBinding(wszBinding))
			{
				wsprintf(wszTemp, 
					     L"Binding %s is invalid. Ignoring this binding for site %d.\n", 
						 (LPWSTR)(i_apv[iCol]), *(DWORD *)(i_apv[iSITES_SiteID]));
				LOG_ERROR(Win32, (hr, ID_CAT_CAT, IDS_COMCAT_COOKDOWN_INTERNAL_ERROR, wszTemp));
				delete [] wszBinding;
				wszBinding = NULL;
				return E_UNEXPECTED;

			}

			delete [] wszBinding;
			wszBinding = NULL;

			break;

		default:
			break;

		}

	}

	return hr;

}


// ==================================================================
HRESULT	CDTPlugin::ValidateColumnConstraintsForApplicationList(DWORD   i_fLOS,
															   ULONG   i_cCol, 
												               ULONG*  i_aSize, 
												               LPVOID* i_apv)
{

	HRESULT hr				= E_NOTIMPL;
	WCHAR	wszTemp[MAX_PATH];

// TODO: Define correct error codes.

	return hr;
}


// ==================================================================
HRESULT CDTPlugin::ApplyColumnDefaults(ISimpleTableWrite2*	i_pISTWrite, 
									   ULONG			    i_iRow, 
									   STDefaultValues*		i_aDefaultValues, 
									   ULONG				i_cDefaultValues)
{
	STQueryCell		strucQuery;
	DWORD			fStatus		= 0;
	DWORD			dbtype;
	ULONG			iCol;
	ULONG			cCol;
	LPVOID			a_StaticpvData[cmaxCOLUMNS];
	ULONG			a_StaticSize[cmaxCOLUMNS];
	LPVOID			*a_pvData	= NULL;
	ULONG			*a_Size		= NULL;
	HRESULT			hr;
	ULONG			iDefaultValues;
	
	hr = i_pISTWrite->GetTableMeta(NULL, 
								   NULL, 
								   NULL, 
								   &cCol);
	if(FAILED(hr))
		return hr;

	if(cCol > cmaxCOLUMNS)
	{
		a_Size = new ULONG[cCol];
		if(NULL == a_Size)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}

		a_pvData = new LPVOID[cCol];
		if(NULL == a_pvData)
		{
			hr = E_OUTOFMEMORY;
			goto Cleanup;
		}
	}
	else
	{
		a_pvData = a_StaticpvData;
		a_Size = a_StaticSize;
	}

	hr = i_pISTWrite->GetWriteColumnValues(i_iRow,
										   cCol, 
										   NULL,
										   NULL,
										   a_Size, 
										   a_pvData);
	if(FAILED(hr))
		goto Cleanup;

// Check each column and if undefined, then apply defaults.

	for(iCol=0; iCol<cCol; iCol++)
	{
		if(NULL == a_pvData[iCol])
		{
		// Apply defaults
			for(iDefaultValues=0; iDefaultValues<i_cDefaultValues; iDefaultValues++)
			{
				if(iCol == i_aDefaultValues[iDefaultValues].iCol)
				{
					DWORD				dbType;
					LPVOID				pvVal[1];
					SimpleColumnMeta	stMeta;

					hr = i_pISTWrite->GetColumnMetas( 1, &iCol, &stMeta );	
					if(FAILED(hr))
						goto Cleanup;

					dbType = stMeta.dbType;

					switch(dbType)
					{

					case DBTYPE_UI4:
						pvVal[0] = (void *)(&(i_aDefaultValues[iDefaultValues].Val));
						break;

					case DBTYPE_WSTR:
						pvVal[0] = (void *)(*(WCHAR **)(&(i_aDefaultValues[iDefaultValues].Val)));
						break;

					case DBTYPE_BYTES:
						pvVal[0] = (void *)(*(BYTE **)(&(i_aDefaultValues[iDefaultValues].Val)));
						break;

					default:
						pvVal[0] = (void *)(&(i_aDefaultValues[iDefaultValues].Val));
						break;

					}

					hr = i_pISTWrite->SetWriteColumnValues(i_iRow, 1, &iCol, NULL, pvVal );
					if(FAILED(hr))
						goto Cleanup;

					break;	// Found a match, hence break

				} // End if col matches

			} // End iterate for all default values

		} // End if column value is null

	} // End for all columns

Cleanup:

	if(cCol > cmaxCOLUMNS)
	{
		if(NULL != a_Size)
		{
			delete [] a_Size;
			a_Size = NULL;
		}

		if(NULL != a_pvData)
		{
			delete [] a_pvData;
			a_pvData = NULL;
		}
	}

	return hr;

} // CDTPlugin::ApplyColumnDefaults


// ==================================================================
HRESULT CDTPlugin::ValidateForeignKey(LPWSTR	i_wszTable,
									  DWORD	    i_fLOS,
								      LPVOID*	i_apvIdentity)
{
	CComPtr<ISimpleTableRead2>	pISTCLB;
	ULONG cRow = 0;
	STQueryCell	QueryCellCLB[1];
	ULONG		cCellCLB = sizeof(QueryCellCLB)/sizeof(STQueryCell);
	HRESULT		hr;

	QueryCellCLB[0].pData     = (LPVOID)i_apvIdentity[0];
	QueryCellCLB[0].eOperator = eST_OP_EQUAL;
	QueryCellCLB[0].iCell     = iAPPPOOLS_AppPoolID;
	QueryCellCLB[0].dbType    = DBTYPE_WSTR;
	QueryCellCLB[0].cbSize    = (lstrlenW((LPWSTR)(i_apvIdentity[0]))+1)*sizeof(WCHAR);

// If you are calling GetTable during CookDown of a CLB table, then set 
// readwrite flags so that you will get an IST from the latest (updated version)

	if(fST_LOS_COOKDOWN  == (i_fLOS & fST_LOS_COOKDOWN))
		i_fLOS = i_fLOS | fST_LOS_READWRITE;

	hr = GetTable(wszDATABASE_IIS,
				  i_wszTable,
				  (LPVOID)QueryCellCLB,
				  (LPVOID)&cCellCLB,
				  eST_QUERYFORMAT_CELLS,
				  i_fLOS,
				  (LPVOID *)&pISTCLB);

	if(FAILED(hr))
		return hr;

	hr = pISTCLB->GetTableMeta(NULL,
							   NULL,
							   &cRow,
							   NULL);

	if(FAILED(hr))
		return hr;
	else if(0 == cRow)
		return E_ST_NOMOREROWS;
	else 
		return S_OK;

} // CDTPlugin::ValidateForeignKey

HRESULT CDTPlugin::ExpandEnvString(LPCWSTR i_wszPath,
								   LPWSTR	*o_pwszExpandedPath)
{
	ULONG	cb;
	HRESULT hr	= S_OK;

	cb = WszExpandEnvironmentStrings(i_wszPath, NULL, 0);
	if(0 == cb)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		TRACE(L"ExpandEnvironmentStrings on %s failed with hr = %08x\n", i_wszPath, hr);
		return hr;
	}
	cb++;	// If they dont include NULL

	(*o_pwszExpandedPath) = new WCHAR [cb];
	if(NULL == (*o_pwszExpandedPath)) {hr = E_OUTOFMEMORY; return hr;}

	cb = WszExpandEnvironmentStrings(i_wszPath, (*o_pwszExpandedPath), cb);
	if(0 == cb)
	{
		hr = HRESULT_FROM_WIN32(GetLastError());
		TRACE(L"ExpandEnvironmentStrings on %s failed with hr = %08x\n", i_wszPath, hr);
		return hr;
	}

	WszCharUpper(*o_pwszExpandedPath);

	return hr;

} // CDTPlugin::ExpandEnvString


/***************************************************************************++

Routine Description:

    Helper function to obtain ISimpleTable* pointers

Arguments:

    None.

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CDTPlugin::GetTable(LPCWSTR	i_wszDatabase,
						    LPCWSTR	i_wszTable,
						    LPVOID	i_QueryData,	
						    LPVOID	i_QueryMeta,	
						    ULONG		i_eQueryFormat,
						    DWORD		i_fServiceRequests,
						    LPVOID	*o_ppIST)
{

	HRESULT hr;

// TODO: This should be cached. Since GetTable is being called only once
//       for now it should be ok.

	CComPtr<ISimpleTableDispenser2> pISTDisp;

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);

	if(FAILED(hr))
	{
		TRACE(L"Could not obtain Dispenser hr = %08x\n", hr);
		return hr;
	}

	hr = pISTDisp->GetTable(i_wszDatabase, 
							  i_wszTable, 
							  i_QueryData, 
							  i_QueryMeta, 
							  i_eQueryFormat, 
							  i_fServiceRequests,	
							  o_ppIST);
	if(FAILED(hr))
	{
		TRACE(L"Could not obtain IST hr = %08x\n", hr);
	}

	return hr;


} // CDTPlugin::GetTable


/***************************************************************************++

Routine Description:

	Helper function that invokes FindFirstFile to obtain attributes of the
	file, in case GetFileAttributesEx fails (Eg. on Win 95)

Arguments:

	[in]      File Name 

Return Value:

    HRESULT.

--***************************************************************************/
HRESULT CDTPlugin::GetAttribute(LPCWSTR i_wszFile)
{

	WIN32_FILE_ATTRIBUTE_DATA	CurrCFGFileAttr;
	HRESULT						hr					= S_OK;

	if(!WszGetFileAttributesEx(i_wszFile, 
							   GetFileExInfoStandard, 
							   &CurrCFGFileAttr))
	{
		WCHAR           wszTemp[MAX_PATH];
		WIN32_FIND_DATA	CurrCFGFileFindData;
		HANDLE			hFile	= INVALID_HANDLE_VALUE;

		hr = HRESULT_FROM_WIN32(GetLastError());

		wsprintf(wszTemp,
			     L"Could not obtain file attributes for file %s. Failed with hr = %08x. Trying with FindFirstFile. \n",
				 i_wszFile, hr);
		TRACE(wszTemp);

		hr = S_OK;

		hFile = WszFindFirstFile(i_wszFile, &CurrCFGFileFindData);
		if(INVALID_HANDLE_VALUE == hFile)
		{
			hr = HRESULT_FROM_WIN32(GetLastError());

			wsprintf(wszTemp,
			         L"Could not obtain file attributes for file %s. Failed with hr = %08x. \n",
					 i_wszFile, hr);
			TRACE(wszTemp);

			return hr;
		}

		FindClose(hFile);

		return hr;
		
	}

	return hr;

} // CDTPlugin::GetAttribute
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtincptr\dtincptr.cpp ===
//  Copyright (C) 1995-2001 Microsoft Corporation.  All rights reserved.
//  DTIncptr.h: Implementation of the CDTIncptr class - Interceptor for
//              Ducttape table.
//

#include "DTIncptr.h"
#include "catmeta.h"
#include "catmacros.h"
#include "SmartPointer.h"

LPCWSTR	g_awszAppPoolCFG[]		= {L"MACHINE.CFG"};
extern LPCWSTR	g_wszCookDownFile;	// Defined in Cooker.cpp
extern BOOL		g_bOnWinnt;			// Defined in CreateDispenser.cpp

////////////////////////////////////////////////////////////////////////////
//


CDTIncptr::CDTIncptr()
:m_cRef(0)
{

}

CDTIncptr::~CDTIncptr()
{
	
}

////////////////////////////////////////////////////////////////////////////
// IUnknown:

STDMETHODIMP CDTIncptr::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableInterceptor)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}

	if (NULL != *ppv)
	{
		((IInterceptorPlugin*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
	
}

STDMETHODIMP_(ULONG) CDTIncptr::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

STDMETHODIMP_(ULONG) CDTIncptr::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

////////////////////////////////////////////////////////////////////////////
// ISimpleTableInterceptor:

HRESULT STDMETHODCALLTYPE CDTIncptr::Intercept( 
												LPCWSTR						i_wszDatabase,
												LPCWSTR						i_wszTable,
												ULONG						i_TableID,
												LPVOID						i_QueryData,
												LPVOID						i_QueryMeta,
												ULONG						i_QueryType,
												DWORD						i_fLOS,
												IAdvancedTableDispenser*	i_pISTDisp,
												LPCWSTR						i_wszLocator,
												LPVOID						i_pSimpleTable,
												LPVOID*						o_ppv)
{

	HRESULT		hr = S_OK;
	STQueryCell	QueryCellCLB[1];
	ULONG		cCellCLB		= sizeof(QueryCellCLB)/sizeof(STQueryCell);
	ULONG		nQueryCells		= 0;
	ULONG		iCol			= 0;
	ULONG		i				= 0;
	LPWSTR		wszFile			= NULL;
	DWORD		iLOS			= i_fLOS;
	DWORD		fNoLogic		= 0;

// Validate relevant args.

	if ( i_pSimpleTable)
		return E_INVALIDARG;

	if(Wszlstrcmpi(i_wszDatabase, wszDATABASE_IIS) != 0)
		return E_ST_OMITDISPENSER;

	nQueryCells = i_QueryMeta ? *(ULONG*)i_QueryMeta : 0;

	if(i_QueryData)											// If FileName is specified in any of the
	{														// cells, then do not intercept.
		for(i=0; i<nQueryCells; i++)							
		{
			if ( ((STQueryCell*)i_QueryData)[i].iCell == iST_CELL_FILE )
			{
				// Found a File cell - This dispenser is of no use.
					return E_ST_OMITDISPENSER;
			}
		}
	}

	if( (Wszlstrcmpi(i_wszTable,                     wszTABLE_APPS) == 0) || 
		     (Wszlstrcmpi(i_wszTable,                    wszTABLE_SITES) == 0) ||
			 (Wszlstrcmpi(i_wszTable,                 wszTABLE_APPPOOLS) == 0) ||
			 (Wszlstrcmpi(i_wszTable,                 wszTABLE_GlobalW3SVC) == 0) ||
			 (Wszlstrcmpi(i_wszTable,                 wszTABLE_CHANGENUMBER) == 0) 
		   )
	{

	// Dont care if query is present or not.
	// But we do need to search for CookDownFileName

		hr = GetCookedDownFileName(&wszFile);

		if(FAILED(hr))
			return hr;

	// Return appropriate IST

		hr = GetTable(i_wszDatabase,
			          i_wszTable,
					  i_QueryData,
					  nQueryCells,
					  i_QueryType,
					  i_fLOS,
				      i_pISTDisp,
					  wszFile,
					  o_ppv);

	}
	else
	{
		return E_ST_OMITDISPENSER;
	}

	delete [] wszFile;
	wszFile = NULL;

	if(SUCCEEDED(hr))
		return E_ST_OMITLOGIC;
	else
		return hr;


} // CDTIncptr::Intercept

HRESULT	CDTIncptr::GetSrcCFGFileName(LPCWSTR					i_wszDatabase,
									 LPCWSTR					i_wszTable,
									 LPVOID						i_QueryData,	
									 LPVOID						i_QueryMeta,	
									 ULONG						i_eQueryFormat,
									 DWORD						i_fServiceRequests,
									 IAdvancedTableDispenser*	i_pISTDisp,
									 ULONG*						piColSrcCFGFile,
									 LPWSTR*					i_pwszSrcCFGFile)
{
	CComPtr<ISimpleTableRead2>	pIST			= NULL;
	ULONG						iRow			= 0;
	LPWSTR						wszSrcCFGFile	= NULL;
	HRESULT						hr;
	DWORD						iLOS			= 0;

	if(i_fServiceRequests & fST_LOS_COOKDOWN)
		iLOS = fST_LOS_COOKDOWN | fST_LOS_READWRITE;		// To read from temp file

	hr = i_pISTDisp->GetTable(i_wszDatabase,
							  i_wszTable,
							  i_QueryData,
							  i_QueryMeta,
							  i_eQueryFormat,
						  	  iLOS,
							  (LPVOID *)&pIST);
	if(FAILED(hr))
		return hr;

	hr = pIST->GetColumnValues(iRow,
							   1,
							   piColSrcCFGFile,						
							   NULL,
							   (LPVOID *)&wszSrcCFGFile);

	if((E_ST_NOMOREROWS == hr) || (NULL == wszSrcCFGFile) || (0 == *wszSrcCFGFile))
		return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);					// TODO: Search recursively through dirs to find.
	else if(FAILED(hr))
		return hr;

	*i_pwszSrcCFGFile = NULL;
	*i_pwszSrcCFGFile = new WCHAR[lstrlenW(wszSrcCFGFile)+1];
	if(NULL == *i_pwszSrcCFGFile)
		return E_OUTOFMEMORY;

	Wszlstrcpy(*i_pwszSrcCFGFile, wszSrcCFGFile);

	return S_OK;

} // CDTIncptr::GetSrcCFGFileName


HRESULT CDTIncptr::GetTable(LPCWSTR						i_wszDatabase,
							LPCWSTR						i_wszTable,
						    LPVOID						i_QueryData,
						    ULONG						nQueryCell,
						    ULONG						i_QueryType,
						    DWORD						i_fLOS,
						    IAdvancedTableDispenser*	i_pISTDisp,
						    LPWSTR						i_wszSrcCFGFile,
						    LPVOID*						o_ppv)
{
	STQueryCell*			aQueryCell	= NULL;
	ULONG					iSrc=0, iDest=0;
	HRESULT					hr;

	aQueryCell = new STQueryCell[nQueryCell+1];
	if(NULL == aQueryCell)
		return E_OUTOFMEMORY;

	aQueryCell[0].pData		= i_wszSrcCFGFile;
	aQueryCell[0].eOperator = eST_OP_EQUAL;
	aQueryCell[0].iCell     = iST_CELL_FILE;
	aQueryCell[0].dbType    = DBTYPE_WSTR;
	aQueryCell[0].cbSize    = (lstrlenW(i_wszSrcCFGFile)+1)*sizeof(WCHAR);

	for(iSrc=0,iDest=1; iSrc<nQueryCell; iSrc++,iDest++)
	{
		aQueryCell[iDest].pData		= ((STQueryCell*)i_QueryData)[iSrc].pData;
		aQueryCell[iDest].eOperator = ((STQueryCell*)i_QueryData)[iSrc].eOperator;
		aQueryCell[iDest].iCell     = ((STQueryCell*)i_QueryData)[iSrc].iCell;
		aQueryCell[iDest].dbType    = ((STQueryCell*)i_QueryData)[iSrc].dbType;
		aQueryCell[iDest].cbSize    = ((STQueryCell*)i_QueryData)[iSrc].cbSize;
	}

	nQueryCell++;
	hr =  i_pISTDisp->GetTable(i_wszDatabase, 
							   i_wszTable, 
							   (LPVOID)aQueryCell, 
							   (LPVOID)&nQueryCell, 
							   i_QueryType, 
							   i_fLOS,	
							   o_ppv);

	delete [] aQueryCell;
	aQueryCell = NULL;

	return hr;

} // CDTIncptr::GetTable


HRESULT CDTIncptr::GetCookedDownFileName(LPWSTR*	i_pwszCookedDownFile)
{
	HRESULT	hr;
	LPWSTR	wszPathDir = NULL;

	hr = GetPathDir(&wszPathDir);

	if(FAILED(hr))
		return hr;

	*i_pwszCookedDownFile = NULL;
	*i_pwszCookedDownFile = new WCHAR [lstrlenW(wszPathDir) + lstrlenW(g_wszCookDownFile) + 1];
	if(!(*i_pwszCookedDownFile)) { return E_OUTOFMEMORY; }

	Wszlstrcpy(*i_pwszCookedDownFile, wszPathDir);
	Wszlstrcat(*i_pwszCookedDownFile, g_wszCookDownFile);

	delete [] wszPathDir;
	wszPathDir = NULL;

	return S_OK;

} // CDTIncptr::GetCookedDownFileName


HRESULT CDTIncptr::GetGlobalFileName(LPWSTR*	i_pwszGlobalFile)
{
	HRESULT	hr;
	LPWSTR	wszPathDir = NULL;

	hr = GetPathDir(&wszPathDir);

	if(FAILED(hr))
		return hr;

	*i_pwszGlobalFile = NULL;
	*i_pwszGlobalFile = new WCHAR [lstrlenW(wszPathDir) + lstrlenW(g_awszAppPoolCFG[0]) + 1];
	if(!(*i_pwszGlobalFile)) { return E_OUTOFMEMORY; }

	Wszlstrcpy(*i_pwszGlobalFile, wszPathDir);
	Wszlstrcat(*i_pwszGlobalFile, g_awszAppPoolCFG[0]);

	delete [] wszPathDir;
	wszPathDir = NULL;

	return S_OK;

} // CDTIncptr::GetGlobalFileName


HRESULT CDTIncptr::GetPathDir(LPWSTR*	i_pwszPathDir)
{

	UINT iRes = GetMachineConfigDirectory(WSZ_PRODUCT_IIS, NULL, 0);

	if(!iRes)
		return HRESULT_FROM_WIN32(GetLastError());

	*i_pwszPathDir = NULL;
	*i_pwszPathDir = new WCHAR[iRes+1];
	if(NULL == *i_pwszPathDir)
		return E_OUTOFMEMORY;

	iRes = GetMachineConfigDirectory(WSZ_PRODUCT_IIS, *i_pwszPathDir, iRes);

	if(!iRes)
		return HRESULT_FROM_WIN32(GetLastError());

	if((*i_pwszPathDir)[lstrlen(*i_pwszPathDir)-1] != L'\\')
	{
		Wszlstrcat(*i_pwszPathDir, L"\\");
	}

	WszCharUpper(*i_pwszPathDir);

	return S_OK;

} // CDTIncptr::GetPathDir
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtwriteincptr\dttable.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#ifndef _DTTABLE_H_
#define _DTTABLE_H_

//
// fwd declaration
//
class CDTTable;

typedef HRESULT (*PFNCOMPUTERELATIVEPATH)(ULONG*, LPVOID*, LPWSTR*, IMSAdminBase*, METADATA_HANDLE);

class CDTTable :public ISimpleTableWrite2,
				public ISimpleTableController,
				public ISimpleTableMarshall	

{
public:
	CDTTable	();
	~CDTTable	();

//
// IUnknown
//

public:
	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	STDMETHOD_(ULONG,AddRef)		();
	STDMETHOD_(ULONG,Release)		();

public:
	HRESULT Initialize(ISimpleTableWrite2*	i_pISTWrite,
					   LPCWSTR				i_wszTable);

//
// ISimpleTableRead2
//

public:

	STDMETHOD (GetRowIndexByIdentity)	(ULONG*		i_cb, 
										 LPVOID*	i_pv, 
										 ULONG*		o_piRow);

    STDMETHOD (GetRowIndexBySearch)     (ULONG      i_iStartingRow,
                                         ULONG      i_cColumns,
                                         ULONG*     i_aiColumns,
                                         ULONG*     i_acbSizes,
                                         LPVOID*    i_apvValues,
                                         ULONG* o_piRow){return E_NOTIMPL;}

	STDMETHOD (GetColumnValues)			(ULONG		i_iRow, 
										 ULONG		i_cColumns, 
										 ULONG*		i_aiColumns, 
										 ULONG*		o_acbSizes, 
										 LPVOID*	o_apvValues);

	STDMETHOD (GetTableMeta)			(ULONG*		o_pcVersion, 
										 DWORD*		o_pfTable, 
										 ULONG*		o_pcRows, 
										 ULONG*		o_pcColumns);

	STDMETHOD (GetColumnMetas)			(ULONG				i_cColumns, 
										 ULONG*				i_aiColumns,
										 SimpleColumnMeta*	o_aColumnMetas);

//
// ISimpleTableWrite2
//

public:
	STDMETHOD (AddRowForDelete)			(ULONG		i_iReadRow);

	STDMETHOD (AddRowForInsert)			(ULONG*		o_piWriteRow);

	STDMETHOD (AddRowForUpdate)			(ULONG		i_iReadRow, 
										 ULONG*		o_piWriteRow);

	STDMETHOD (GetWriteColumnValues)	(ULONG		i_iRow, 
										 ULONG		i_cColumns, 
										 ULONG*		i_aiColumns, 
										 DWORD*		o_afStatus, 
										 ULONG*		o_acbSizes, 
										 LPVOID*	o_apvValues);

	STDMETHOD (SetWriteColumnValues)	(ULONG		i_iRow, 
										 ULONG		i_cColumns, 
										 ULONG*		i_aiColumns, 
										 ULONG*		o_acbSizes, 
										 LPVOID*	i_apvValues);

	STDMETHOD (GetWriteRowIndexByIdentity)	(ULONG*		i_cbSizes, 
											 LPVOID*	i_apvValues, 
											 ULONG*		o_piRow);

	STDMETHOD (GetWriteRowIndexBySearch)(ULONG      i_iStartingRow,
                                         ULONG      i_cColumns,
                                         ULONG*     i_aiColumns,
                                         ULONG*     i_acbSizes,
                                         LPVOID*    i_apvValues,
                                         ULONG* o_piRow){return E_NOTIMPL;}

	STDMETHOD (GetErrorTable)           (DWORD i_fServiceRequests, LPVOID* o_ppvSimpleTable)
                                        {return E_NOTIMPL;}

	STDMETHOD (UpdateStore)				();
	
//
// ISimpleTableController
//

public:
	STDMETHOD (ShapeCache)				(DWORD				i_fTable, 
										 ULONG				i_cColumns, 
										 SimpleColumnMeta*	i_acolmetas, 
										 LPVOID*			i_apvDefaults, 
										 ULONG*				i_acbSizes);

	STDMETHOD (PrePopulateCache)		(DWORD i_fControl);

	STDMETHOD (PostPopulateCache)		();

	STDMETHOD (DiscardPendingWrites)	();

	STDMETHOD (GetWriteRowAction)		(ULONG	i_iRow, 
										 DWORD*	o_peAction);

	STDMETHOD (SetWriteRowAction)		(ULONG	i_iRow, 
										 DWORD	i_eAction);

	STDMETHOD (ChangeWriteColumnStatus)	(ULONG		i_iRow, 
										 ULONG		i_iColumn, 
										 DWORD		i_fStatus);

	STDMETHOD (AddDetailedError)		(STErr* o_pSTErr);

	STDMETHOD (GetMarshallingInterface) (IID*		o_piid, 
										 LPVOID*	o_ppItf);

//
// ISimpleTableAdvanced
//

public:
	STDMETHOD (PopulateCache)		();

	STDMETHOD (GetDetailedErrorCount)	(ULONG* o_pcErrs);

	STDMETHOD (GetDetailedError)		(ULONG	i_iErr, 
										 STErr*	o_pSTErr);

//
// ISimpleTableMarshall
//

public:
	STDMETHOD (SupplyMarshallable)		(DWORD	i_fReadNotWrite,
										 char**	o_ppv1,	
										 ULONG*	o_pcb1,	
										 char**	o_ppv2, 
										 ULONG*	o_pcb2, 
										 char**	o_ppv3,
										 ULONG*	o_pcb3, 
										 char**	o_ppv4, 
										 ULONG*	o_pcb4, 
										 char**	o_ppv5,	
										 ULONG*	o_pcb5);

	STDMETHOD (ConsumeMarshallable) (DWORD	i_fReadNotWrite,
									 char*	i_pv1, 
									 ULONG	i_cb1,
									 char*	i_pv2,
									 ULONG	i_cb2,
									 char*	i_pv3,
									 ULONG	i_cb3,
									 char*	i_pv4,
									 ULONG	i_cb4,
									 char*	i_pv5, 
									 ULONG	i_cb5);

private:
	
	ISimpleTableWrite2*		m_pISTWrite;
	ISimpleTableController*	m_pISTController;
	LPWSTR					m_wszTable;
	ULONG					m_cRef;
	CComPtr<IMSAdminBase>	m_spIMSAdminBase;
	ISimpleTableRead2*		m_pISTColumnMeta;
	PFNCOMPUTERELATIVEPATH	m_pfnComputeRelativePath;

};

HRESULT ComputeGlobalRelativePath(ULONG*	i_acbSizes,
                                  LPVOID*	i_apvValues,
                                  LPWSTR*	o_wszRelativePath,
                                  IMSAdminBase*		i_pMSAdminBase,
                                  METADATA_HANDLE	i_hMBHandle);

HRESULT ComputeAppsRelativePath(ULONG*	        i_acbSizes,
					            LPVOID*	        i_apvValues,
                                LPWSTR*	        o_wszRelativePath,
                                IMSAdminBase*	i_pMSAdminBase,
                                METADATA_HANDLE	i_hMBHandle);

HRESULT ComputeSiteRelativePath(ULONG*	        i_acbSizes,
                                LPVOID*	        i_apvValues,
                                LPWSTR*	        o_wszRelativePath,
                                IMSAdminBase*	i_pMSAdminBase,
                                METADATA_HANDLE	i_hMBHandle);

HRESULT ComputeAppPoolRelativePath(ULONG*	i_acbSizes,
                                   LPVOID*	i_apvValues,
                                   LPWSTR*	o_wszRelativePath,
                                   IMSAdminBase*		i_pMSAdminBase,
                                   METADATA_HANDLE	i_hMBHandle);

#endif _DTTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtwriteincptr\dtwriteincptr.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "catalog.h"
#include "catmeta.h"
#include "catmacros.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "DTWriteIncptr.h"
#include "DTTable.h"

//========================================================================
//Constructor and destructor
CDTWriteInterceptorPlugin::CDTWriteInterceptorPlugin():
m_cRef(0)
{
}


CDTWriteInterceptorPlugin::~CDTWriteInterceptorPlugin()
{
}
 

//========================================================================
// IInterceptorPlugin: Intercept
//========================================================================
HRESULT	CDTWriteInterceptorPlugin::Intercept (LPCWSTR					i_wszDatabase, 
											  LPCWSTR					i_wszTable, 
											  ULONG						i_TableID, 
											  LPVOID					i_QueryData, 
											  LPVOID					i_QueryMeta, 
											  DWORD						i_eQueryFormat, 
											  DWORD						i_fLOS,  
											  IAdvancedTableDispenser*	i_pISTDisp, 
											  LPCWSTR					i_wszLocator, 
											  LPVOID					i_pSimpleTable, 
											  LPVOID*					o_ppvSimpleTable)
{
	HRESULT hr;
	ISimpleTableWrite2*	pISTWrite = NULL;
	CDTTable*	pCDTTable = NULL;

	//
	// Plugin this dispenser only if fST_LOS_UNPOPULATED, fST_LOS_READWRITE
	// are set and fST_LOS_COOKDOWN is not set.
	//

	if( (fST_LOS_UNPOPULATED != (i_fLOS & fST_LOS_UNPOPULATED)) ||
		(fST_LOS_READWRITE   != (i_fLOS & fST_LOS_READWRITE))   ||
		(fST_LOS_COOKDOWN    == (i_fLOS & fST_LOS_COOKDOWN))   				
	  )
		return E_ST_OMITDISPENSER;

	//
	// We donot support any type of query as yet.
	//

	if((NULL != i_QueryData) && (NULL != i_QueryMeta))
		return E_INVALIDARG;

	//
	// Setup the cache
	//

	hr = i_pISTDisp->GetMemoryTable( i_wszDatabase,
									 i_wszTable,
									 0,
									 0,
									 0,
									 i_eQueryFormat,
									 i_fLOS,
									 &pISTWrite);

	if (FAILED(hr)) 
		return hr;

	//
	// Create the MBTable and pass it the cache
	//

	pCDTTable = new CDTTable();
	if(NULL == pCDTTable)
	{
		hr = E_OUTOFMEMORY;
		goto exit;
	}

	hr = pCDTTable->Initialize(pISTWrite,
							   i_wszTable);

	if(FAILED(hr))
		goto exit;

	//
	// Hand out the MBtable as the table.
	//

	hr = pCDTTable->QueryInterface(IID_ISimpleTableWrite2,
		                           o_ppvSimpleTable);

	if(FAILED(hr))
		goto exit;

exit:

	if(NULL != pISTWrite)
	{
		pISTWrite->Release();
		pISTWrite = NULL;
	}

	return hr;
}

//========================================================================
// IInterceptorPlugin: OnPopulateCache
//========================================================================
HRESULT	CDTWriteInterceptorPlugin::OnPopulateCache( ISimpleTableWrite2*  i_pISTW2)
{
	HRESULT hr;
	CComPtr<ISimpleTableController> spISTController;

	hr = i_pISTW2->QueryInterface(IID_ISimpleTableController, (LPVOID*)&spISTController);
    if (FAILED(hr)) 
		return hr;

	hr = spISTController->PrePopulateCache(0);
	if (FAILED(hr)) 
		return hr;

	hr = spISTController->PostPopulateCache();
	return hr;
}

//========================================================================
// IInterceptorPlugin: OnUpdateStore
//========================================================================		
HRESULT	CDTWriteInterceptorPlugin::OnUpdateStore( ISimpleTableWrite2*  i_pISTW2 )
{
	return S_OK;
}
	


// =======================================================================
// IUnknown:

STDMETHODIMP CDTWriteInterceptorPlugin::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableInterceptor)
	{
		*ppv = (ISimpleTableInterceptor*) this;
	}
	else if (riid == IID_IInterceptorPlugin)
	{
		*ppv = (IInterceptorPlugin*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (IInterceptorPlugin*) this;
	}

	if (NULL != *ppv)
	{
		((IInterceptorPlugin*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
	
}

STDMETHODIMP_(ULONG) CDTWriteInterceptorPlugin::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

STDMETHODIMP_(ULONG) CDTWriteInterceptorPlugin::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtplugin\validatebinding.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/


#include "DTPlugin.h"

#define INTERNET_MAX_PORT_NUMBER_LENGTH		5
#define INTERNET_MAX_PORT_NUMBER			65535


/*++

Routine Description:

    Converts an ANSI character in the range '0'..'9' 'A'..'F' 'a'..'f' to its
    corresponding hexadecimal value (0..f)

Arguments:

    ch  - character to convert

Return Value:

    char
        hexadecimal value of ch, as an 8-bit (signed) character value

--*/
WCHAR
CDTPlugin::HexCharToNumber(
							IN WCHAR ch
						  )

{
    return (ch <= L'9') ? (ch - L'0')
                       : ((ch >= L'a') ? ((ch - L'a') + 10) : ((ch - L'A') + 10));
}



/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_DATA (ERROR_INTERNET_INVALID_URL)
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/
DWORD
CDTPlugin::DecodeUrl(
    IN LPWSTR Url,
    IN DWORD UrlLength,
    OUT LPWSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )
{
    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {

        WCHAR ch;

        if (*Url == L'%') {

            //
            // BUGBUG - would %00 ever appear in an URL?
            //

            ++Url;
            if (isxdigit(*Url)) {
                ch = HexCharToNumber(*Url++) << 4;
                if (isxdigit(*Url)) {
                    ch |= HexCharToNumber(*Url++);
                } else {
                    return ERROR_INVALID_DATA; //ERROR_INTERNET_INVALID_URL;
                }
            } else {
                return ERROR_INVALID_DATA; //ERROR_INTERNET_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}


/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_DATA (ERROR_INTERNET_INVALID_URL)
                  ERROR_INSUFFICIENT_BUFFER

--*/
DWORD
CDTPlugin::DecodeUrlInSitu(
    IN LPWSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )
{
    DWORD stringLength;

    stringLength = *BufferLength;
    if (memchr(BufferAddress, L'%', stringLength)) {
        return DecodeUrl(BufferAddress,
                         stringLength,
                         BufferAddress,
                         BufferLength
                         );
    } else {

        //
        // no escape character in the string, just return success
        //

        return ERROR_SUCCESS;
    }
}


/*++

Routine Description:

    Performs DecodeUrlInSitu() on a string and zero terminates it

    Assumes: 1. Even if no decoding is performed, *BufferLength is large enough
                to fit an extra '\0' character

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string, excluding '\0'

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_DATA (ERROR_INTERNET_INVALID_URL)
                  ERROR_INSUFFICIENT_BUFFER

--*/
DWORD
CDTPlugin::DecodeUrlStringInSitu(
    IN LPWSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )
{
    DWORD error;

    error = DecodeUrlInSitu(BufferAddress, BufferLength);
    if (error == ERROR_SUCCESS) {
        BufferAddress[*BufferLength] = L'\0';
    }
    return error;
}


/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_DATA (ERROR_INTERNET_INVALID_URL)

--*/
DWORD
CDTPlugin::GetUrlAddressInfo(
    IN OUT LPWSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPWSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPWSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )
{
    LPWSTR pString;
    LPWSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    while ((*pString != L'/') && (*pString != L'\0') && (length != 0)) {
        if (*pString == L'%') {

            //
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //

            *partEscape = TRUE;
        }
        if (*pString == L':') {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                return ERROR_INVALID_DATA; //ERROR_INTERNET_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }
        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_INTERNET_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INTERNET_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/
DWORD
CDTPlugin::GetUrlAddress(
    IN OUT LPWSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPWSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPWSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPWSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    OUT LPDWORD lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )
{
    LPWSTR pAt;
    DWORD urlLength;
    LPWSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    WCHAR portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPWSTR pPortNumber;
    DWORD error;
    LPWSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = (DWORD)wcslen(pUrl);

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    pAt = NULL;
    for (DWORD i = 0; i < urlLength; ++i) {
        if (pUrl[i] == L'/') {
            break;
        } else if (pUrl[i] == L'@') {
            pAt = &pUrl[i];
            break;
        }
    }

    if (pAt != NULL) {

        DWORD addressPartLength;
        LPWSTR userName;
        DWORD userNameLength;
        LPWSTR password;
        DWORD passwordLength;

        addressPartLength = (DWORD) (pAt - pUrl);
        urlLength -= addressPartLength;
        error = GetUrlAddressInfo(&pUrl,
                                  &addressPartLength,
                                  &userName,
                                  &userNameLength,
                                  &part1Escape,
                                  &password,
                                  &passwordLength,
                                  &part2Escape
                                  );
        if (error != ERROR_SUCCESS) {
            return error;
        }

        //
        // ensure there is no address information unparsed before the '@'
        //

        //ASSERT(addressPartLength == 0);
        //ASSERT(pUrl == pAt);

        if (NULL != lpszUserName) {

            //INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            //
            // convert the user name in situ
            //

            if (part1Escape) {

                //INET_ASSERT(userName != NULL);
                //INET_ASSERT(userNameLength != 0);

                error = DecodeUrlInSitu(userName, &userNameLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszUserName = userName;
            *lpdwUserNameLength = userNameLength;
        }

        if (lpszPassword != NULL) {

            //
            // convert the password in situ
            //

            if (part2Escape) {

                //INET_ASSERT(userName != NULL);
                //INET_ASSERT(userNameLength != 0);
                //INET_ASSERT(password != NULL);
                //INET_ASSERT(passwordLength != 0);

                error = DecodeUrlInSitu(password, &passwordLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }
            *lpszPassword = password;
            *lpdwPasswordLength = passwordLength;
        }

        //
        // the URL pointer now points at the host:port fields (remember that
        // ExtractAddressParts() must have bumped pUrl up to the end of the
        // password field (if present) which ends at pAt)
        //

        ++pUrl;

        //
        // similarly, bump urlLength to account for the '@'
        //

        --urlLength;
    } else {

        //
        // no '@' therefore no username or password
        //

        if (NULL != lpszUserName) {

            //INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));

            *lpszUserName = NULL;
            *lpdwUserNameLength = 0;
        }
        if (NULL != lpszPassword) {

            //INET_ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));

            *lpszPassword = NULL;
            *lpdwPasswordLength = 0;
        }
    }

    //
    // now get the host name and the optional port
    //

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );

    if (error != ERROR_SUCCESS) {
        return error;
    }

    //
    // the URL address information MUST contain the host name
    //

//  if ((hostName == NULL) || (hostNameLength == 0)) {
//      return ERROR_INTERNET_INVALID_URL;
//  }

    if (NULL != lpszHostName) {

        //INET_ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape) {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS) {
                return error;
            }
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (NULL != lpPort) {
        if (portNumberLength != 0) {

            DWORD i;
            DWORD port;

            //INET_ASSERT(pPortNumber != NULL);

            if (part2Escape) {
                error = DecodeUrlInSitu(pPortNumber, &portNumberLength);
                if (error != ERROR_SUCCESS) {
                    return error;
                }
            }

            //
            // ensure all characters in the port number buffer are numeric, and
            // calculate the port number at the same time
            //

            for (i = 0, port = 0; i < portNumberLength; ++i) {
                if (!isdigit(*pPortNumber)) {
                    return ERROR_INVALID_DATA; //ERROR_INTERNET_INVALID_URL;
                }
                port = port * 10 + (int)(*pPortNumber++ - L'0');
                // We won't allow ports larger than 65535 ((2^16)-1)
                // We have to check this every time to make sure that someone
                // doesn't try to overflow a DWORD.
                if (port > 65535)
                {
                    return ERROR_INVALID_DATA; //ERROR_INTERNET_INVALID_URL;
                }
            }
            *lpPort = port;
            if (NULL != pHavePort) {
                *pHavePort = TRUE;
            }
        } else {
            *lpPort = -1; // INTERNET_INVALID_PORT_NUMBER;
            if (NULL != pHavePort) {
                *pHavePort = FALSE;
            }
        }
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    return ERROR_SUCCESS;
}

BOOLEAN CDTPlugin::ValidateBinding(IN PWCHAR InputUrl)
{
    PWCHAR Url;
    static const WCHAR http[]  = L"http://";
    static const WCHAR https[] = L"https://";
    DWORD dwUrlLength = (DWORD)wcslen(InputUrl);
    DWORD Port;
    INT HavePort;
    DWORD error;

    // 
    // search for http:// or https://
    //

    if((dwUrlLength  >= wcslen(http) && _wcsnicmp(InputUrl, http, wcslen(http)) == 0))
    {
        // We found a http!
        Url = InputUrl + wcslen(http);
        dwUrlLength -= (DWORD)wcslen(http);
    }
    else 
    {
        if (dwUrlLength >= wcslen(https) && _wcsnicmp(InputUrl, https, wcslen(https)) == 0 )
        {
            // we found a https://
            Url = InputUrl + wcslen(https);
            dwUrlLength -= (DWORD)wcslen(https);
        }
        else 
        {
            return FALSE;
        }

    }

    
    error = GetUrlAddress(&Url,
                          &dwUrlLength,  // Length of the URL
                          NULL,          // User Name         (NULL since we don't care)
                          NULL,          // User Name Length  (NULL since we don't care)
                          NULL,          // Password          (NULL since we don't care)
                          NULL,          // Password Length   (NULL since we don't care)
                          NULL,          // HostName
                          NULL,          // HostNameLength
                          &Port,
                          &HavePort
                          );
   
    if(error == ERROR_SUCCESS)
        return TRUE;

    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\filelistener\listener.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    Listner.h

Abstract:

	Class that does subscribes and process file change notifications.

Author:

    Varsha Jayasimha (varshaj)			30-Nov-1999

Revision History:

--*/

#ifndef _LISTNER_H_
#define _LISTNER_H_

struct FileNotificationInfo
{
	LPWSTR wszFile;
	DWORD  Status;						// i.e. Insert, Update, Delete
};

struct FileNotificationCookie
{
	LPWSTR wszDir;
	DWORD  dwCookie;					// i.e. cookie returned by ISimplTableAdvise
};

enum eUNSUBSCRIBE_ACTION
{
	eACTION_UNSUBSCRIBE_ALL =0,
	eACTION_UNSUBSCRIBE_OBSOLETE,
	cUNSUBSCRIBE_ACTION
};

enum eFILE_NOTIFICATION
{
	eFILE_CREATE = 0,
	eFILE_MODIFY,
	eFILE_DELETE,
	cFILE_NOTIFCATION
};

typedef FileNotificationInfo*	LP_FileNotificationInfo;
typedef FileNotificationCookie*	LP_FileNotificationCookie;

#define cTIMEOUT	120000				// Wait timeout in milliseconds 
#define cNotificationThreshold 1		// Number of Noification to wait for before triggering cookdown


class CFileListener : 
public ISimpleTableFileChange
{

public:

	CFileListener();

	~CFileListener();

private:

	DWORD								m_cRef;

	HANDLE*								m_paHandle;

	DWORD								m_cHandle;

	Array<LP_FileNotificationInfo>		m_aReceivedFileNotification;

	CSemExclusive						m_seReceived;

	Array<LP_FileNotificationCookie>	m_aRequestedFileNotification;

	ISimpleTableDispenser2*				m_pISTDisp;

	ISimpleTableFileAdvise*				m_pISTFileAdvise;

public:

	// Initialize

	HRESULT Init(HANDLE* i_pHanlde);

	// IUnknown

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);

	STDMETHOD_(ULONG,AddRef)		();

	STDMETHOD_(ULONG,Release)		();

	// ISimpleTableFileChange

	STDMETHOD (OnFileCreate)		(LPCWSTR i_wszFileName);	// Add notifications to the received queue. 

	STDMETHOD (OnFileModify)		(LPCWSTR i_wszFileName);	// Add notifications to the received queue. 

	STDMETHOD (OnFileDelete)		(LPCWSTR i_wszFileName);	// Add notifications to the received queue. 

	// Methods to start and stop Listening

	HRESULT StartListening();										// Start the state machine.

private:

	HRESULT Subscribe();											// Read machine config directory and subscribe
																	// for notifications. Also Read home directory 
																	// of all sites and subscribe 
																	// for file change notifications on them.
																	

	HRESULT UnSubscribe(DWORD dwStatus);							// Unsubscribe for file change notifications on
																	// obsolete directories or all directories if the service
																	// is being stopped.
																	// Purges entries from the requested queue.

	HRESULT ProcessNotifications(BOOL* i_pbDone);					// This method should be triggered by an event.
																	// such as no. of notifications recd. reaching a max or
																	// some timer expiring.
																	// This method would move notifications from the received
																	// queue to the processing queue and then invoke CookDown
																	// for all files in the processing queue.

	HRESULT StopListening(BOOL* i_pbDone);							// Stop the state machine.


private: 	

	HRESULT FileAdvise(LPCWSTR	i_pwszDir,
					   DWORD	i_dwStatus);							// Subscribes for file change notifications on the 
																	// given directory. Adds notifications to the requested queue.

	HRESULT CheckIfObsolete(LPCWSTR i_pwszDir, 
							BOOL* o_pbObsolete);					// Checks if the dir is an obsolete home dir.

	HRESULT AddReceivedNotification(LPCWSTR i_wszFile, 
									DWORD i_eNotificationStatus);	// Adds to recd array

	HRESULT AddRequestedNotification(LPCWSTR i_wszDir, 
									 DWORD i_dwCookie);				// Adds to requested array

	INT GetRequestedNotification(LPCWSTR i_wszDir);					// Check if notifications has already been requested on the dir.

	HRESULT GetTable(LPCWSTR	i_wszDatabase,
					 LPCWSTR	i_wszTable,
					 LPVOID	    i_QueryData,	
					 LPVOID	    i_QueryMeta,	
					 ULONG	    i_eQueryFormat,
					 DWORD	    i_fServiceRequests,
					 LPVOID*    o_ppIST);

}; // CFileListner

#endif _LISTNER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\filelistener\listener.cpp ===
/*++


Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    Listner.cpp

Abstract:

	Implementation of the class that does subscribes and process file change notifications.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include	"catalog.h"
#include	"catmeta.h"
#include	"catmacros.h"
#include	"Array_t.h"
#include    "Utsem.h"
#include    "ListenerController.h"
#include    "Listener.h"

// Forward declaration

STDAPI CookDownInternal ();


/***************************************************************************++

Routine Description:

    Constructor for the CFileListener class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CFileListener::CFileListener()
{
	m_cRef				= 0;
	m_paHandle			= NULL;
	m_cHandle			= 0;
	m_pISTDisp			= NULL;
	m_pISTFileAdvise	= NULL;

}


HRESULT CFileListener::Init(HANDLE* i_pHanlde)
{

	m_paHandle	= i_pHanlde;
	m_cHandle	= 2;				// TODO: Only the First two matter. 
	                                //       Need a better way to set 2.
	
	m_aReceivedFileNotification.reset();
	m_aRequestedFileNotification.reset();

	return S_OK;

} // CFileListener::Init


/***************************************************************************++

Routine Description:

    Destructor for the CFileListener class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CFileListener::~CFileListener()
{
	ULONG i = 0;

	for(i=0; i<m_aReceivedFileNotification.size(); i++)
	{
		if(NULL != m_aReceivedFileNotification[i])
		{
			if(NULL != m_aReceivedFileNotification[i]->wszFile)
			{
				delete [] m_aReceivedFileNotification[i]->wszFile;
				m_aReceivedFileNotification[i]->wszFile = NULL;
			}
			delete m_aReceivedFileNotification[i];
			m_aReceivedFileNotification[i] = NULL;
		}
	}

	m_aReceivedFileNotification.reset();

	for(i=0; i<m_aRequestedFileNotification.size(); i++)
	{
		if(NULL != m_aRequestedFileNotification[i])
		{
			if(NULL != m_aRequestedFileNotification[i]->wszDir)
			{
				delete [] m_aRequestedFileNotification[i]->wszDir;
				m_aRequestedFileNotification[i]->wszDir = NULL;
			}
			delete m_aRequestedFileNotification[i];
			m_aRequestedFileNotification[i] = NULL;
		}
	}

	m_aRequestedFileNotification.reset();

	if(NULL != m_pISTFileAdvise)
	{
		m_pISTFileAdvise->Release();
		m_pISTFileAdvise = NULL;
	}

	if(NULL != m_pISTDisp)
	{
		m_pISTDisp->Release();
		m_pISTDisp = NULL;
	}

}


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::QueryInterface

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP CFileListener::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableFileChange)
	{
		*ppv = (ISimpleTableFileChange*) this;
	}
	else if(riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableFileChange*) this;
	}
	
	if (NULL != *ppv)
	{
		((ISimpleTableFileChange*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}

} // CFileListener::QueryInterface


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::AddRef

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CFileListener::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
} // CFileListener::AddRef


/***************************************************************************++

Routine Description:

    Implementation of IUnknown::Release

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

STDMETHODIMP_(ULONG) CFileListener::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;

} // CFileListener::Release


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileCreate
	It adds the notifications to the received queue. 

Arguments:

    [in]	FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileCreate(LPCWSTR i_wszFileName)
{
	return AddReceivedNotification(i_wszFileName, eFILE_CREATE);

} // CFileListener::OnFileCreate


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileModify
	It adds the notifications to the received queue. 

Arguments:

    [in]	FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileModify(LPCWSTR i_wszFileName)	
{
	return AddReceivedNotification(i_wszFileName, eFILE_MODIFY);

} // CFileListener::OnFileModify


/***************************************************************************++

Routine Description:

    Implementation of ISimpleTableFileChange::OnFileDelete
	It adds the notifications to the received queue. 

Arguments:

    [in]	FileName

Return Value:

    HRESULT

--***************************************************************************/

STDMETHODIMP CFileListener::OnFileDelete(LPCWSTR i_wszFileName)
{
	return AddReceivedNotification(i_wszFileName, eFILE_DELETE);
	
} // CFileListener::OnFileDelete


/***************************************************************************++

Routine Description:

    Start listening i.e subscribe to file change notifications.
	and process any received notifications.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::StartListening()
{
	HRESULT hr		= S_OK;
	BOOL    bDone	= FALSE;   // If bDone is TRUE, it means StopListening was executed.
	                           // Does not mean that StopListening was successfully executed.

	while (!bDone)
	{
		hr = Subscribe();

		if(FAILED(hr))
			goto exit;

		hr = UnSubscribe(eACTION_UNSUBSCRIBE_OBSOLETE);

		if(FAILED(hr))
			goto exit;

		hr = ProcessNotifications(&bDone);

		if(FAILED(hr))
			goto exit;

	}

exit:

	if(FAILED(hr) && (!bDone))
		StopListening(NULL);

	return hr;

} // CFileListener::StartListening


/***************************************************************************++

Routine Description:

    Stop listening i.e unsubscribe all file change notifications.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

HRESULT CFileListener::StopListening(BOOL* i_pbDone)
{
	HRESULT hr = S_OK;

	if(NULL != i_pbDone)
		*i_pbDone = TRUE;	

	hr = UnSubscribe(eACTION_UNSUBSCRIBE_ALL);

	if(FAILED(hr))
		return hr;
	else
		return S_OK;

} // CFileListener::StopListening


/***************************************************************************++

Routine Description:

	Read home directory of all sites and subscribe for file change 
	notifications on them. Adds notification cookies to the requested queue.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::Subscribe()
{

	HRESULT hr = S_OK;
	CComPtr<ISimpleTableRead2>	pISTSite;
	ULONG	i=0;
	LPWSTR	wszMachineConfigDir = NULL;
	UINT	cCh = 0;

// Subscribe to all home directories.	

	hr = GetTable(wszDATABASE_IIS,
				  wszTABLE_SITES,
				  NULL,
				  0,
				  eST_QUERYFORMAT_CELLS,
				  0,
				  (LPVOID *)&pISTSite);

	if(FAILED(hr))
		return hr;
	for(i=0; ;i++)
	{

	// Local vaiables

		//
		// TODO: Home Directory no longer exists.
		// Need to figure out what we can use the listener for.
		//

		ULONG						iColHomeDir			=	0; // iSITES_HomeDirectory;
		ULONG						cColsSite			=	1;
		LPWSTR						wszHomeDir			= NULL;
		
	// Get HomeDirectory 

		hr = pISTSite->GetColumnValues(i,
									   cColsSite,
									   &iColHomeDir,
									   NULL,
									   (LPVOID *)&wszHomeDir);
		if(E_ST_NOMOREROWS == hr)
		{
			hr = S_OK;
			break;
		}
		else if (FAILED(hr))
			return hr;

		hr = FileAdvise(wszHomeDir,
						fST_FILECHANGE_RECURSIVE);

		if(FAILED(hr))
			return hr;

	} // For all Site rows.

// First subscribe to the MachineConfigDirectory

	cCh = GetMachineConfigDirectory(WSZ_PRODUCT_IIS,
								   wszMachineConfigDir,
								   cCh);

	if(!cCh)
		return HRESULT_FROM_WIN32(GetLastError());

	wszMachineConfigDir = new WCHAR [cCh+1];
	if(NULL == wszMachineConfigDir)
		return E_OUTOFMEMORY;

	cCh = GetMachineConfigDirectory(WSZ_PRODUCT_IIS,
								   wszMachineConfigDir,
								   cCh);

	if(!cCh)
	{
		delete [] wszMachineConfigDir;
		wszMachineConfigDir = NULL;
		return HRESULT_FROM_WIN32(GetLastError());
	}

	hr = FileAdvise(wszMachineConfigDir,
				    0); // No need to recursively search this directory.

	delete [] wszMachineConfigDir;
	wszMachineConfigDir = NULL;

	return hr;

} // CFileListener::Subscribe


HRESULT CFileListener::FileAdvise(LPCWSTR	i_pwszDir,
								  DWORD		i_dwStatus) 
{
	int		NotifIndx	= 0;
	DWORD	dwCookie	= 0;
	HRESULT hr			= S_OK;

// Check if this directory has already been subscribed

	NotifIndx = GetRequestedNotification(i_pwszDir);

	if(-1 == NotifIndx)
	{

	// m_pISTDisp is initialized the first time GetTable is called.

		ASSERT(m_pISTDisp);

		if(NULL == m_pISTFileAdvise)
		{
			hr = m_pISTDisp->QueryInterface(IID_ISimpleTableFileAdvise, (void**)&m_pISTFileAdvise);

			if(FAILED(hr))
				return hr;
		}

	// Subscribe for Notification

		hr = m_pISTFileAdvise->SimpleTableFileAdvise((ISimpleTableFileChange *)this,
													 i_pwszDir,
													 NULL,
													 i_dwStatus,
													 &dwCookie);

		if (FAILED(hr))
			return hr;


	// Add notification cookie to queue

		hr = AddRequestedNotification(i_pwszDir, dwCookie);

		if (FAILED(hr))
			return hr;
	}

	return hr;

} // CFileListener::FileAdvise

/***************************************************************************++

Routine Description:

	Unsubscribe for file change notifications on obsolete directories or 
	all directories if the service is being stopped. Purges entries from the 
	requested queue.

Arguments:

    [in] Action indicating unsubscribe all or unsubscribe obsolete directories.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::UnSubscribe(DWORD dwAction)
{

	HRESULT hr = S_OK;
	ULONG i = 0;

	ASSERT(m_pISTFileAdvise != NULL);

	switch(dwAction)
	{
		case eACTION_UNSUBSCRIBE_ALL:
			
			for(i=0; i<m_aRequestedFileNotification.size(); i++)
			{
				FileNotificationCookie**	ppFileNotifCookie = NULL;

				m_aRequestedFileNotification.getAt(i, &ppFileNotifCookie);

				hr = m_pISTFileAdvise->SimpleTableFileUnadvise((*ppFileNotifCookie)->dwCookie);

				if(FAILED(hr))
					return hr;
			}

			m_aRequestedFileNotification.reset();

			break;

		case eACTION_UNSUBSCRIBE_OBSOLETE:

			for(i=0; i<m_aRequestedFileNotification.size(); i++)
			{
				FileNotificationCookie**	ppFileNotifCookie = NULL;

				m_aRequestedFileNotification.getAt(i, &ppFileNotifCookie);

				BOOL bUnadvise = FALSE;
				
				hr = CheckIfObsolete((*ppFileNotifCookie)->wszDir, &bUnadvise);

				if(FAILED(hr))
					return hr;

				if(bUnadvise)
				{
					hr = m_pISTFileAdvise->SimpleTableFileUnadvise((*ppFileNotifCookie)->dwCookie);

					if(FAILED(hr))
						return hr;

					m_aRequestedFileNotification.deleteAt(i);

					i--;
				}

			}

			break;

		default:
			ASSERT(0)
			break;
	}

	return hr;
    
} // CFileListener::UnSubscribe


/***************************************************************************++

Routine Description:

	This method should be triggered by an event. such as no. of notifications 
	recd. reaching a max or some timer expiring. This method would move 
	notifications from the received queue to the processing queue and then 
	invoke CookDown for all files in the processing queue.

Arguments:

	None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CFileListener::ProcessNotifications(BOOL* i_pbDone)
{
	DWORD dwRes = 0;
	ULONG i		= 0;

	CLock ReceivedLock(&m_seReceived, FALSE);
	
sleep:

	dwRes = WaitForMultipleObjects(m_cHandle,
			 				       m_paHandle,
								   FALSE,
								   cTIMEOUT);

	if(WAIT_FAILED == dwRes)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}
	else if(WAIT_TIMEOUT == dwRes)
	{

	// If there are no notifications to process then go back to sleep
	// else fall through for further processing

		ReceivedLock.Lock();

		ULONG cNotif = m_aReceivedFileNotification.size();

		ReceivedLock.UnLock();

		if(0 == cNotif)
			goto sleep;

	}
	else if(iEVENT_STOPLISTENING == (dwRes - WAIT_OBJECT_0) )
	{

	// Unsubscribe set i_pbDone so that the thread exits.

		return StopListening(i_pbDone);
	}
	else
	{

	// TODO: Will dwRes ever be WAIT_ABANDONED_0+* in our case? 
	//       If so, need to handle that scenario.

		ASSERT(iEVENT_PROCESSNOTIFICATIONS == (dwRes - WAIT_OBJECT_0) );
	}

	ReceivedLock.Lock();

	for(i=0; i<m_aReceivedFileNotification.size(); i++)
	{
		if(NULL != m_aReceivedFileNotification[i])
		{
			if(NULL != m_aReceivedFileNotification[i]->wszFile)
			{
				delete [] m_aReceivedFileNotification[i]->wszFile;
				m_aReceivedFileNotification[i]->wszFile = NULL;
			}
			delete m_aReceivedFileNotification[i];
			m_aReceivedFileNotification[i] = NULL;
		}
	}

	m_aReceivedFileNotification.reset();

	ReceivedLock.UnLock();
	
// TODO: When CookDown becomes file aware, then we need to pass the files
//       down to CookDown, before resetting it.

	return CookDownInternal();

} // CFileListener::ProcessNotifications


/***************************************************************************++

Routine Description:

	This method checks if the dir is a valid homedirectory.

Arguments:

	[in] Directory name.

Return Value:

    BOOL

--***************************************************************************/

HRESULT CFileListener::CheckIfObsolete(LPCWSTR i_pwszDir, BOOL* o_pbObsolete)
{

	HRESULT hr = S_OK;
	CComPtr<ISimpleTableRead2>	pISTSite;
	STQueryCell					QueryCell[1];
	ULONG						cCell	= sizeof(QueryCell) / sizeof(STQueryCell);
	ULONG						cRows   = 0;

	//
	// TODO: Home Directory no longer exists.
	// Need to figure out what we can use the listener for.
	//

	QueryCell[0].pData     = (LPVOID)i_pwszDir;
    QueryCell[0].eOperator = eST_OP_EQUAL;
    QueryCell[0].iCell     = 0; // iSITES_HomeDirectory;
    QueryCell[0].dbType    = DBTYPE_WSTR;
    QueryCell[0].cbSize    = (lstrlenW(i_pwszDir)+1)*sizeof(WCHAR);

	hr = GetTable(wszDATABASE_IIS,
				  wszTABLE_SITES,
				  QueryCell,
				  (VOID*)&cCell,
				  eST_QUERYFORMAT_CELLS,
				  0,
				  (LPVOID *)&pISTSite);

	if(FAILED(hr))
		return hr;

	hr = pISTSite->GetTableMeta(NULL,
								NULL,
								&cRows,
								NULL);


	if(FAILED(hr))
		return hr;

	if(0 == cRows)
	{
		// Check the machine config directory
		LPWSTR	wszMachineConfigDir = NULL;
		UINT	cCh = 0;

		cCh = GetMachineConfigDirectory(WSZ_PRODUCT_IIS,
									   wszMachineConfigDir,
									   cCh);

		if(!cCh)
			return HRESULT_FROM_WIN32(GetLastError());

		wszMachineConfigDir = new WCHAR [cCh+1];
		if(NULL == wszMachineConfigDir)
			return E_OUTOFMEMORY;

		cCh = GetMachineConfigDirectory(WSZ_PRODUCT_IIS,
									   wszMachineConfigDir,
									   cCh);

		if(!cCh)
		{
			delete [] wszMachineConfigDir;
			wszMachineConfigDir = NULL;
			return HRESULT_FROM_WIN32(GetLastError());
		}

		if(Wszlstrcmpi(wszMachineConfigDir, i_pwszDir) == 0)
			*o_pbObsolete = FALSE;
		else
			*o_pbObsolete = TRUE;

		delete [] wszMachineConfigDir;
		wszMachineConfigDir = NULL;

	}
	else
		*o_pbObsolete = FALSE;

	return hr;

} // CFileListener::CheckIfObsolete


HRESULT CFileListener::AddReceivedNotification(LPCWSTR i_wszFile, DWORD i_eNotificationStatus)
{
	HRESULT hr		= S_OK;
	ULONG   Size	= 0;
	BOOL	bRes	= 0;

	FileNotificationInfo**	ppFileNotif = NULL;

	CLock ReceivedLock(&m_seReceived);

// Add a new FileNotificationInfo.

	try
	{
		m_aReceivedFileNotification.setSize(m_aReceivedFileNotification.size()+1);

		Size = m_aReceivedFileNotification.size();

		ppFileNotif = &m_aReceivedFileNotification[Size-1];
		
		*ppFileNotif = NULL;
		(*ppFileNotif) = new FileNotificationInfo;
		if(NULL == (*ppFileNotif))
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		(*ppFileNotif)->Status = i_eNotificationStatus;

		(*ppFileNotif)->wszFile = NULL;
		(*ppFileNotif)->wszFile = new WCHAR[Wszlstrlen(i_wszFile) + 1];
		if(NULL == (*ppFileNotif)->wszFile)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		Wszlstrcpy((*ppFileNotif)->wszFile, i_wszFile);

	}
	catch(HRESULT e)
	{
        ASSERT(E_OUTOFMEMORY == e);
		hr = e;//should array should only throw E_OUTOFMEMORY;
	}

exit:

	ReceivedLock.UnLock();

	if(Size >= cNotificationThreshold)
	{
		bRes = SetEvent(m_paHandle[iEVENT_PROCESSNOTIFICATIONS]);

		// TODO: Can we safely ignore this error?

		if(!bRes)
			hr = HRESULT_FROM_WIN32(GetLastError());
	}

	return hr;

} // CFileListener::AddReceivedNotification


HRESULT CFileListener::AddRequestedNotification(LPCWSTR i_wszDir, DWORD i_dwCookie)
{

	HRESULT hr = S_OK;

	FileNotificationCookie**	ppFileNotifCookie = NULL;

// Add a new FileNotificationCookie.

	try
	{
		m_aRequestedFileNotification.setSize(m_aRequestedFileNotification.size()+1);

		ppFileNotifCookie = &m_aRequestedFileNotification[m_aRequestedFileNotification.size()-1];
		
		*ppFileNotifCookie = NULL;
		(*ppFileNotifCookie) = new FileNotificationCookie;
		if(NULL == (*ppFileNotifCookie))
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		(*ppFileNotifCookie)->dwCookie = i_dwCookie;

		(*ppFileNotifCookie)->wszDir = NULL;
		(*ppFileNotifCookie)->wszDir = new WCHAR[Wszlstrlen(i_wszDir) + 1];
		if(NULL == (*ppFileNotifCookie)->wszDir)
		{
			hr = E_OUTOFMEMORY;
			goto exit;
		}

		Wszlstrcpy((*ppFileNotifCookie)->wszDir, i_wszDir);

	}
	catch(HRESULT e)
	{
        ASSERT(E_OUTOFMEMORY == e);
		hr = e;//array should only throw E_OUTOFMEMORY;
	}

exit:

	return hr;

} // CFileListener::AddRequestedNotification


INT CFileListener::GetRequestedNotification(LPCWSTR i_wszDir)
{

	int indx = -1;

	FileNotificationCookie*	pFileNotifCookie = NULL;

	for(ULONG i=0; i<m_aRequestedFileNotification.size(); i++)
	{
		pFileNotifCookie = m_aRequestedFileNotification[i];

		if(0 == Wszlstrcmpi(i_wszDir, pFileNotifCookie->wszDir))
		{
			indx = i;
			break;
		}

	}

	return indx;
	
} // CFileListener::GetRequestedNotification


HRESULT CFileListener::GetTable(LPCWSTR	i_wszDatabase,
							   LPCWSTR	i_wszTable,
							   LPVOID	i_QueryData,	
							   LPVOID	i_QueryMeta,	
							   ULONG	i_eQueryFormat,
							   DWORD	i_fServiceRequests,
							   LPVOID	*o_ppIST)
{

	HRESULT hr;

	if(NULL == m_pISTDisp)
	{
		hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &m_pISTDisp);

		if(FAILED(hr))
			return hr;
	}

	hr = m_pISTDisp->GetTable(i_wszDatabase, 
							  i_wszTable, 
							  i_QueryData, 
							  i_QueryMeta, 
							  i_eQueryFormat, 
							  i_fServiceRequests,	
							  o_ppIST);

	return hr;


} // CFileListener::GetTable
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtwriteincptr\dttable.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#include "Catalog.h"
#include "Catmeta.h"
#include "Catmacros.h"
#include <iadmw.h>
#include <iiscnfg.h>
#include "DTTable.h"
#include "ISTHelper.h"


#define IIS_MD_W3SVC				L"/LM/W3SVC"
#define MB_TIMEOUT					(30 * 1000)

////////////////////


//
// Constructor and destructor
//

CDTTable::CDTTable():
m_pISTWrite(NULL),
m_pISTController(NULL),
m_wszTable(NULL),
m_pfnComputeRelativePath(NULL),
m_pISTColumnMeta(NULL),
m_cRef(0)
{

}


CDTTable::~CDTTable()
{
	if(NULL != m_pISTWrite)
	{
		m_pISTWrite->Release();
		m_pISTWrite = NULL;
	}

	if(NULL != m_pISTController)
	{
		m_pISTController->Release();
		m_pISTController = NULL;
	}

	if(NULL != m_pISTColumnMeta)
	{
		m_pISTColumnMeta->Release();
		m_pISTColumnMeta = NULL;
	}

	if(NULL != m_wszTable)
	{
		delete [] m_wszTable;
		m_wszTable = NULL;
	}
		
}


HRESULT CDTTable::Initialize(ISimpleTableWrite2*	i_pISTWrite,
							 LPCWSTR				i_wszTable)
{
	HRESULT                 hr;
	ISimpleTableDispenser2* pISTDisp = NULL;

	hr = i_pISTWrite->QueryInterface(IID_ISimpleTableWrite2,
		                             (void**)&m_pISTWrite);

	if(FAILED(hr))
		return hr;

	hr = i_pISTWrite->QueryInterface(IID_ISimpleTableController,
		                             (void**)&m_pISTController);

	if(FAILED(hr))
		return hr;

	m_wszTable = new WCHAR[Wszlstrlen(i_wszTable) + 1];
	if(NULL == m_wszTable)
		return E_OUTOFMEMORY;

	Wszlstrcpy(m_wszTable, i_wszTable);

	if(Wszlstrcmp(i_wszTable, wszTABLE_APPS) == 0)
	{
		m_pfnComputeRelativePath = ComputeAppsRelativePath;
	}
	else if(Wszlstrcmp(i_wszTable, wszTABLE_SITES) == 0)
	{
		m_pfnComputeRelativePath = ComputeSiteRelativePath;
	}
	else if(Wszlstrcmp(i_wszTable, wszTABLE_APPPOOLS) == 0)
	{
		m_pfnComputeRelativePath = ComputeAppPoolRelativePath;
	}
	else if(Wszlstrcmp(i_wszTable, wszTABLE_GlobalW3SVC) == 0)
	{
		m_pfnComputeRelativePath = ComputeGlobalRelativePath;
	}

	//
	// Save a pointer to the columnmeta table. We will need columnmeta
	// info when we writer.
	//

	hr = GetSimpleTableDispenser (WSZ_PRODUCT_IIS, 0, &pISTDisp);
	if(FAILED(hr))
	{
		return hr;
	}


	hr = pISTDisp->GetTable (wszDATABASE_META, 
                             wszTABLE_COLUMNMETA, 
                             (LPVOID)NULL, 
                             (LPVOID)NULL, 
                             eST_QUERYFORMAT_CELLS, 
                             0, 
                             (void**)(&m_pISTColumnMeta));

	pISTDisp->Release();

	if(FAILED(hr))
	{
		return hr;
	}

	//
    // Create the base admin object.
	//

    hr = CoCreateInstance(CLSID_MSAdminBase,           // CLSID
                          NULL,                        // controlling unknown
                          CLSCTX_SERVER,               // desired context
                          IID_IMSAdminBase,            // IID
                          (void**)&m_spIMSAdminBase);   // returned interface

	return hr;

}


// 
// IUnknown
//

STDMETHODIMP CDTTable::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;
	*ppv = NULL;

	if (riid == IID_ISimpleTableWrite2)
	{
		*ppv = (ISimpleTableWrite2*) this;
	}
	else if (riid == IID_ISimpleTableController)
	{
		*ppv = (ISimpleTableController*) this;
	}
	else if (riid == IID_ISimpleTableMarshall)
	{
		*ppv = (ISimpleTableMarshall*) this;
	}	
	else if (riid == IID_IUnknown)
	{
		*ppv = (ISimpleTableWrite2*) this;
	}

	if (NULL != *ppv)
	{
		((ISimpleTableWrite2*)this)->AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
	
}

STDMETHODIMP_(ULONG) CDTTable::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
	
}

STDMETHODIMP_(ULONG) CDTTable::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}

//
// ISimpleTableRead2 
//

HRESULT CDTTable::GetRowIndexByIdentity(ULONG*		i_cb, 
										LPVOID*		i_pv, 
										ULONG*		o_piRow)
{
	return E_NOTIMPL;

} // CDTTable::GetRowIndexByIdentity


HRESULT CDTTable::GetColumnValues(ULONG		i_iRow, 
								  ULONG		i_cColumns, 
								  ULONG*	i_aiColumns, 
								  ULONG*	o_acbSizes, 
								  LPVOID*	o_apvValues)
{
	return E_NOTIMPL;

} // CDTTable::GetColumnValues


HRESULT CDTTable::GetTableMeta(ULONG*		o_pcVersion, 
							   DWORD*		o_pfTable, 
							   ULONG*		o_pcRows, 
							   ULONG*		o_pcColumns)
{
	return E_NOTIMPL;
	
} // CDTTable::GetTableMeta


HRESULT CDTTable::GetColumnMetas(ULONG				i_cColumns, 
								 ULONG*				i_aiColumns,
								 SimpleColumnMeta*	o_aColumnMetas)
{
	return E_NOTIMPL;

} // CDTTable::GetColumnMetas

//
// ISimpleTableWrite2
//

HRESULT CDTTable::AddRowForDelete(ULONG i_iReadRow)
{
	return E_NOTIMPL;

} // CDTTable::AddRowForDelete


HRESULT CDTTable::AddRowForInsert(ULONG* o_piWriteRow)
{
	return m_pISTWrite->AddRowForInsert(o_piWriteRow);

} // CDTTable::AddRowForInsert


HRESULT CDTTable::AddRowForUpdate(ULONG  i_iReadRow,
								  ULONG* o_piWriteRow)
{
	return E_NOTIMPL;

} // CDTTable::AddRowForUpdate


HRESULT CDTTable::GetWriteColumnValues(ULONG   i_iRow,
								       ULONG   i_cColumns,
									   ULONG*  i_aiColumns,
									   DWORD*  o_afStatus,
									   ULONG*  o_acbSizes,
									   LPVOID* o_apvValues)
{
	return E_NOTIMPL;

} // CDTTable::GetWriteColumnValues

/*
  The assumption here is that WAS will not call AddRowForInsert or
  AddRowForUpdate or UpdateStore. Instead it will just call 
  SetWriteColumnValues and we will directly (within SetWriteColumnValues) 
  update the metabase with the values. If the column is set to NULL it means 
  that we will have to delete the data.
*/

HRESULT CDTTable::SetWriteColumnValues(ULONG   i_iRow,
									   ULONG   i_cColumns,
									   ULONG*  i_aiColumns,
									   ULONG*  i_acbSizes,
									   LPVOID* i_apvValues)
{
	HRESULT hr;
	ULONG	i,iCol;
	LPWSTR	wszRelativePath = NULL;
	METADATA_HANDLE	hMBHandle = NULL;

	//
	//	We open the metabase key only when someone wants to write.
	//

    hr = m_spIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE ,
                                   IIS_MD_W3SVC,
                                   METADATA_PERMISSION_WRITE  | METADATA_PERMISSION_READ, 
                                   MB_TIMEOUT,
                                   &hMBHandle );

	if(FAILED(hr))
		return hr;


	//
	// Each of the three tables has one PK column that maps
	// to a metabase key. Make sure that this column gets 
	// processed first.
	//
	
	hr = (*m_pfnComputeRelativePath)(i_acbSizes,
						             i_apvValues,
						             &wszRelativePath,
						             m_spIMSAdminBase,
						             hMBHandle);

	if(FAILED(hr))
		goto exit;

	for(i=0; i<i_cColumns; i++)
	{
		LPVOID   a_pvColMeta[cCOLUMNMETA_NumberOfColumns];

		iCol = i_aiColumns[i];

		hr = FillInColumnMeta(m_pISTColumnMeta,
			                  (LPCWSTR)m_wszTable,
			                  iCol,
	                          a_pvColMeta);

		if(FAILED(hr))
			goto exit;

		//
		// If it is not a writeable column, then do not process it.
		// A column is marked non-writeable when it doesnot correspond
		// to a metabase property. For eg. if a column is derived from 
		// a key (like in the case of PKs).
		//

		if(!IsMetabaseProperty(*(DWORD*)a_pvColMeta[iCOLUMNMETA_ID]))
		{
			continue;
		}
		else if (NULL == i_apvValues[iCol])
		{
			//
			// Columns that are set to NULL, imply that the property
			// has to be deleted.
			//

			hr = m_spIMSAdminBase->DeleteData(hMBHandle,
											  wszRelativePath,
											  *(DWORD*)a_pvColMeta[iCOLUMNMETA_ID],
											  GetMetabaseType(*(DWORD*)a_pvColMeta[iCOLUMNMETA_Type],
						                                      *(DWORD*)a_pvColMeta[iCOLUMNMETA_MetaFlags]));
			if(FAILED(hr))
				goto exit;

		}
		else
		{
			//
			// Set the data
			//

			METADATA_RECORD mdr;

			mdr.dwMDIdentifier = *(DWORD*)a_pvColMeta[iCOLUMNMETA_ID];
			mdr.dwMDAttributes = *(DWORD*)a_pvColMeta[iCOLUMNMETA_Attributes];
			mdr.dwMDUserType   = *(DWORD*)a_pvColMeta[iCOLUMNMETA_UserType];
			mdr.dwMDDataType   = GetMetabaseType(*(DWORD*)a_pvColMeta[iCOLUMNMETA_Type],
						                         *(DWORD*)a_pvColMeta[iCOLUMNMETA_MetaFlags]); 
			mdr.pbMDData	   = (BYTE*)i_apvValues[iCol];

			switch(GetMetabaseType(*(DWORD*)a_pvColMeta[iCOLUMNMETA_Type],
						           *(DWORD*)a_pvColMeta[iCOLUMNMETA_MetaFlags])
				  )
			{
				case DWORD_METADATA:
					mdr.dwMDDataLen = sizeof(DWORD);
					break;

				case STRING_METADATA:
				case EXPANDSZ_METADATA:
					mdr.dwMDDataLen = ((int)Wszlstrlen((LPWSTR)i_apvValues[iCol])+1)*sizeof(WCHAR);					
					break;

				case MULTISZ_METADATA:
				case BINARY_METADATA:
					mdr.dwMDDataLen = i_acbSizes[iCol];					
					break;

				default:
					ASSERT(0 && "Unextected data type");
					hr = ERROR_INVALID_DATA;
					goto exit;

			}

			hr = m_spIMSAdminBase->SetData(hMBHandle,
										   wszRelativePath,
										   &mdr);

			if(FAILED(hr))
				goto exit;
		}

	}

exit:

	if(NULL != wszRelativePath)
	{
		delete [] wszRelativePath;
		wszRelativePath = NULL;
	}

	if((m_spIMSAdminBase != NULL) && (NULL != hMBHandle))
		m_spIMSAdminBase->CloseKey(hMBHandle);

	return hr;

} // CDTTable::SetWriteColumnValues


HRESULT CDTTable::GetWriteRowIndexByIdentity(ULONG*  i_cbSizes,
											 LPVOID* i_apvValues,
											 ULONG*  o_piRow)
{
	return E_NOTIMPL;

} // CDTTable::GetWriteRowIndexByIdentity


HRESULT CDTTable::UpdateStore()
{
	return S_OK;

} // CDTTable::UpdateStore

	
//
// ISimpleTableController
//

HRESULT CDTTable::ShapeCache(DWORD				i_fTable, 
							 ULONG				i_cColumns, 
							 SimpleColumnMeta*	i_acolmetas, 
							 LPVOID*			i_apvDefaults, 
							 ULONG*				i_acbSizes)
{
	
	return m_pISTController->ShapeCache(i_fTable,
										i_cColumns,
										i_acolmetas,
										i_apvDefaults,
										i_acbSizes);

} // CDTTable::ShapeCache


HRESULT CDTTable::PrePopulateCache(DWORD i_fControl)
{
	return m_pISTController->PrePopulateCache(i_fControl);

} // CDTTable::PrePopulateCache


HRESULT CDTTable::PostPopulateCache()
{
	return m_pISTController->PostPopulateCache();

} // CDTTable::PostPopulateCache


HRESULT CDTTable::DiscardPendingWrites()
{
	return m_pISTController->DiscardPendingWrites();

} // CDTTable::DiscardPendingWrites



HRESULT CDTTable::GetWriteRowAction(ULONG	i_iRow, 
								    DWORD*	o_peAction)
{
	return m_pISTController->GetWriteRowAction(i_iRow,
	                                           o_peAction);

} // CDTTable::GetWriteRowAction


HRESULT CDTTable::SetWriteRowAction(ULONG	i_iRow, 
									DWORD	i_eAction)
{
	return m_pISTController->SetWriteRowAction(i_iRow,
											   i_eAction);

} // CDTTable::SetWriteRowAction


HRESULT CDTTable::ChangeWriteColumnStatus(ULONG		i_iRow, 
										 ULONG		i_iColumn, 
										 DWORD		i_fStatus)
{
	return m_pISTController->ChangeWriteColumnStatus(i_iRow,
													 i_iColumn,
													 i_fStatus);

	
} // CDTTable::ChangeWriteCOlumnStatus


HRESULT CDTTable::AddDetailedError(STErr* o_pSTErr)
{
	return m_pISTController->AddDetailedError(o_pSTErr);

} // CDTTable::AddDetailedError


HRESULT CDTTable::GetMarshallingInterface(IID*		o_piid, 
										  LPVOID*	o_ppItf)
{
	return m_pISTController->GetMarshallingInterface(o_piid,
													 o_ppItf);

} // CDTTable::GetMarshallingInterface

//
// ISimpleTableAdvanced
//


HRESULT CDTTable::PopulateCache()
{
	return m_pISTController->PopulateCache();

} // CDTTable::PopulateCache


HRESULT CDTTable::GetDetailedErrorCount(ULONG* o_pcErrs)
{
	return m_pISTController->GetDetailedErrorCount(o_pcErrs);

} // CDTTable::GetDetailedErrorCount


HRESULT CDTTable::GetDetailedError(ULONG	i_iErr, 
								   STErr*	o_pSTErr)
{
	return m_pISTController->GetDetailedError(i_iErr,
											  o_pSTErr);

} // CDTTable::GetDetailedError

//
// ISimpleTableMarshall
//

HRESULT CDTTable::SupplyMarshallable(DWORD	i_fReadNotWrite,
									 char**	o_ppv1,	
									 ULONG*	o_pcb1,	
									 char**	o_ppv2, 
									 ULONG*	o_pcb2, 
									 char**	o_ppv3,
									 ULONG*	o_pcb3, 
									 char**	o_ppv4, 
									 ULONG*	o_pcb4, 
									 char**	o_ppv5,	
									 ULONG*	o_pcb5)
{
	return E_NOTIMPL;

} // CDTTable::SupplyMarshallable


HRESULT CDTTable::ConsumeMarshallable(DWORD	i_fReadNotWrite,
									 char*	i_pv1, 
									 ULONG	i_cb1,
									 char*	i_pv2,
									 ULONG	i_cb2,
									 char*	i_pv3,
									 ULONG	i_cb3,
									 char*	i_pv4,
									 ULONG	i_cb4,
									 char*	i_pv5, 
									 ULONG	i_cb5)
{
	return E_NOTIMPL;

} // CDTTable::ConsumeMarshallable


HRESULT ComputeAppPoolRelativePath(ULONG*				i_acbSizes,
                                   LPVOID*			i_apvValues,
                                   LPWSTR*			o_wszRelativePath,
                                   IMSAdminBase*		i_pMSAdminBase,
                                   METADATA_HANDLE	i_hMBHandle)
{
	LPWSTR	        wszRoot           = L"AppPools/";
	LPWSTR	        wszTerminate      = L"/";
	LPWSTR	        wszRelativePath   = NULL;
	HRESULT         hr                = S_OK;
	WCHAR           wszSubKey[METADATA_MAX_NAME_LEN+1];
	ULONG           iEnumKey          = 0;

	if(NULL == i_apvValues[iAPPPOOLS_AppPoolID])
	{
		ASSERT(0 && "Missing primary key");
		return ERROR_INVALID_DATA;
	}

	wszRelativePath = new WCHAR[Wszlstrlen(wszRoot)+Wszlstrlen(LPWSTR(i_apvValues[iAPPPOOLS_AppPoolID]))+Wszlstrlen(wszTerminate)+1];
	if(NULL == wszRelativePath)
		return E_OUTOFMEMORY;
	Wszlstrcpy(wszRelativePath, wszRoot);
	Wszlstrcat(wszRelativePath, (LPWSTR)i_apvValues[iAPPPOOLS_AppPoolID]);
	Wszlstrcat(wszRelativePath, wszTerminate);
	*o_wszRelativePath = wszRelativePath;

	hr = i_pMSAdminBase->EnumKeys(i_hMBHandle ,
							      wszRelativePath,
								  wszSubKey,
								  iEnumKey);

	if(FAILED(hr) && HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
		hr = S_OK; // Found the key but no sub keys - ok.
	}

	return hr;

} // ComputeAppPoolRelativePath


HRESULT ComputeSiteRelativePath(ULONG*			i_acbSizes,
                                LPVOID*			i_apvValues,
                                LPWSTR*			o_wszRelativePath,
                                IMSAdminBase*	i_pMSAdminBase,
                                METADATA_HANDLE	i_hMBHandle)
{
	LPWSTR	        wszTerminate      = L"/";
	LPWSTR	        wszRelativePath   = NULL;
	WCHAR	        wszSiteID[20];
	HRESULT         hr                = S_OK;
	WCHAR           wszSubKey[METADATA_MAX_NAME_LEN+1];
	ULONG           iEnumKey          = 0;

	if(NULL == i_apvValues[iSITES_SiteID])
	{
		ASSERT(0 && "Missing primary key");
		return ERROR_INVALID_DATA;
	}

	_ltow(*(DWORD*)i_apvValues[iSITES_SiteID],wszSiteID,10);

	wszRelativePath = new WCHAR[Wszlstrlen(wszSiteID)+Wszlstrlen(wszTerminate)+1];
	if(NULL == wszRelativePath)
		return E_OUTOFMEMORY;
	Wszlstrcpy(wszRelativePath, wszSiteID);
	Wszlstrcat(wszRelativePath, wszTerminate);
	*o_wszRelativePath = wszRelativePath;

	hr = i_pMSAdminBase->EnumKeys(i_hMBHandle ,
							      wszRelativePath,
								  wszSubKey,
								  iEnumKey);

	if(FAILED(hr) && HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
		hr = S_OK; // Found the key but no sub keys - ok.
	}

	return hr;

} // ComputeSiteRelativePath


HRESULT ComputeAppsRelativePath(ULONG*			i_acbSizes,
                                LPVOID*			i_apvValues,
                                LPWSTR*			o_wszRelativePath,
                                IMSAdminBase*	i_pMSAdminBase,
                                METADATA_HANDLE	i_hMBHandle)
{
	LPWSTR	        wszRoot           = L"/Root";
	LPWSTR	        wszTerminate      = L"/";
	LPWSTR	        wszRelativePath   = NULL;
	WCHAR	        wszSiteID[20];
	HRESULT         hr                = S_OK;
	WCHAR           wszSubKey[METADATA_MAX_NAME_LEN+1];
	ULONG           iEnumKey          = 0;

	if((NULL == i_apvValues[iAPPS_SiteID]) || (NULL == i_apvValues[iAPPS_AppRelativeURL]))
	{
		ASSERT(0 && "Missing primary key");
		return ERROR_INVALID_DATA;
	}
	else if(*(WCHAR*)(i_apvValues[iAPPS_AppRelativeURL]) != L'/')
	{
		ASSERT(0 && "AppRelative Url must always begin with a slash (/).");
		return ERROR_INVALID_DATA;		
	}

	_ltow(*(DWORD*)i_apvValues[iAPPS_SiteID], wszSiteID, 10);

	wszRelativePath = new WCHAR[Wszlstrlen(wszSiteID) 
		                       +Wszlstrlen(wszRoot)+
							   +Wszlstrlen((LPWSTR)(i_apvValues[iAPPS_AppRelativeURL]))
							   +Wszlstrlen(wszTerminate)+1];
	if(NULL == wszRelativePath)
		return E_OUTOFMEMORY;
	Wszlstrcpy(wszRelativePath, wszSiteID);
	Wszlstrcat(wszRelativePath, wszRoot);
	Wszlstrcat(wszRelativePath, (LPWSTR)(i_apvValues[iAPPS_AppRelativeURL]));

	if(wszRelativePath[Wszlstrlen(wszRelativePath)-1] != L'/')
		Wszlstrcat(wszRelativePath, wszTerminate);

	*o_wszRelativePath = wszRelativePath;

	hr = i_pMSAdminBase->EnumKeys(i_hMBHandle ,
							      wszRelativePath,
								  wszSubKey,
								  iEnumKey);

	if(FAILED(hr) && HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
	{
		hr = S_OK; // Found the key but no sub keys - ok.
	}

	return hr;

} // ComputeAppsRelativePath


HRESULT ComputeGlobalRelativePath(ULONG*			i_acbSizes,
                                  LPVOID*			i_apvValues,
                                  LPWSTR*			o_wszRelativePath,
                                  IMSAdminBase*	   i_pMSAdminBase,
                                  METADATA_HANDLE	i_hMBHandle)
{
	if(NULL == i_apvValues[iGlobalW3SVC_MaxGlobalBandwidth])
	{
		ASSERT(0 && "Missing primary key");
		return ERROR_INVALID_DATA;
	}

	*o_wszRelativePath = NULL;

	return S_OK;

} // ComputeGlobalRelativePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\filelistener\listenercontroller.cpp ===
/*++


Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    ListenerController.cpp

Abstract:

	Implementation of the class that starts and stops the Listener.

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:


--*/

#include	"catalog.h"
//#include	"catmeta.h"
#include	"catmacros.h"
#include	"Array_t.h"
#include    "Utsem.h"
#include	"ListenerController.h"
#include    "Listener.h"

CListenerController* g_pListenerController = NULL;

// Fwd declaration 

DWORD GetListenerController(CListenerController**	i_ppListenerController);
DWORD WINAPI StartListenerThread(LPVOID	lpParam);



/***************************************************************************++

Routine Description:

    Constructor for the ListenerController class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CListenerController::CListenerController()
{
	m_cStartStopRef = 0;

}

HRESULT CListenerController::Init()
{

	for (ULONG i = 0; i < cmaxLISTENERCONTROLLER_EVENTS; i++) 
	{ 
		m_aHandle[i] = INVALID_HANDLE_VALUE;
	}

	m_aHandle[iEVENT_STOPLISTENING] = CreateEvent(NULL,   // no security attributes
												  FALSE,  // auto-reset event object
												  FALSE,  // initial state is nonsignaled
												  NULL);  // unnamed object

	if (m_aHandle[iEVENT_STOPLISTENING] == INVALID_HANDLE_VALUE) 
		return HRESULT_FROM_WIN32(GetLastError());


	m_aHandle[iEVENT_PROCESSNOTIFICATIONS] = CreateEvent(NULL,   // no security attributes
												         FALSE,  // auto-reset event object
												         FALSE,  // initial state is nonsignaled
												         NULL);  // unnamed object

	if (m_aHandle[iEVENT_PROCESSNOTIFICATIONS] == INVALID_HANDLE_VALUE) 
		return HRESULT_FROM_WIN32(GetLastError());

	m_aHandle[iEVENT_STOPPEDLISTENING] = CreateEvent(NULL,   // no security attributes
												     TRUE,   // manual-reset event object
												     TRUE,   // initial state is signaled
												     NULL);  // unnamed object
	
	if (m_aHandle[iEVENT_STOPPEDLISTENING] == INVALID_HANDLE_VALUE) 
		return HRESULT_FROM_WIN32(GetLastError());

	return S_OK;

}


/***************************************************************************++

Routine Description:

    Destructor for the CListenerController class.

Arguments:

    None.

Return Value:

    None.

--***************************************************************************/

CListenerController::~CListenerController()
{
	for (ULONG i = 0; i < cmaxLISTENERCONTROLLER_EVENTS; i++) 
	{ 
		if(m_aHandle[i] != INVALID_HANDLE_VALUE)
		{
			CloseHandle(m_aHandle[i]);
			m_aHandle[i] = INVALID_HANDLE_VALUE;
		}
	}

}


/***************************************************************************++

Routine Description:

    Start the state listener.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CListenerController::Start()
{

	HRESULT hr			= S_OK;
	HANDLE	hThread		= NULL;
	DWORD	dwThreadID;

	CLock	StartStopLock(&m_seStartStop);

	LONG cStartStopRef = ++m_cStartStopRef;

	StartStopLock.UnLock();

	// Start only once i.e. when the Start/Stop refcount is one. All other 
	// times, just increment the ref count and leave.

	if(cStartStopRef == 1)
	{

		// Since the ListenerController is a singleton, there can be a case where the 
		// Start/Stop ref count goes to zero. i.e. the listener stops listening and 
		// then a new Start request comes. In this case we want to wait for the 
		// any previous Listener to completely stop listening.

		DWORD dwRes = WaitForSingleObject(m_aHandle[iEVENT_STOPPEDLISTENING],
			                              cTIMEOUT);

		if(WAIT_TIMEOUT == dwRes)
			return HRESULT_FROM_WIN32(WAIT_TIMEOUT); 
		else if(WAIT_FAILED == dwRes)
			return HRESULT_FROM_WIN32(GetLastError());

		// TODO: Should we handle WAIT_ABANDONED??

		// Start the thread

		hThread = CreateThread(NULL, 0, StartListenerThread, (LPVOID)this, 0, &dwThreadID);
		if (hThread == NULL)
			return HRESULT_FROM_WIN32(GetLastError());
		
		CloseHandle(hThread); 

		// TODO: Should we keep the thread handle around??

	}

	return hr;
	
} // CListenerController::Start


/***************************************************************************++

Routine Description:

    Stop the listener.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/

HRESULT CListenerController::Stop()
{
	CLock	StartStopLock(&m_seStartStop);

	LONG cStartStopRef = --m_cStartStopRef;

	ASSERT(m_cStartStopRef >=0 );

	if (cStartStopRef == 0)
	{
		BOOL bRes = 0;

		// Reset the event that signals that stop has finished
		// Set this before you signal the stop - else stop may
		// finish before you reset this.

		bRes = ResetEvent(m_aHandle[iEVENT_STOPPEDLISTENING]);

		if(!bRes)
			return HRESULT_FROM_WIN32(GetLastError());

		// Set an event that will stop listening

		bRes = SetEvent(m_aHandle[iEVENT_STOPLISTENING]);

		if(!bRes)
			return HRESULT_FROM_WIN32(GetLastError());

	}

	StartStopLock.UnLock();


	if (cStartStopRef == 0)
	{
		// Wait for the Listener to completely stop listening.

		DWORD dwRes = WaitForSingleObject(m_aHandle[iEVENT_STOPPEDLISTENING],
			                              cTIMEOUT);

		if(WAIT_OBJECT_0 == dwRes)
			return S_OK;
		else if(WAIT_TIMEOUT == dwRes)
			return HRESULT_FROM_WIN32(WAIT_TIMEOUT); 
		else if(WAIT_FAILED == dwRes)
			return HRESULT_FROM_WIN32(GetLastError());

		// TODO: Should we handle WAIT_ABANDONED??

	}

	return S_OK;

} // CListenerController::Stop


HANDLE * CListenerController::Event()
{
	return (HANDLE *)m_aHandle;
}

/***************************************************************************++

Routine Description:

    Start the listener thread.

Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
DWORD WINAPI StartListenerThread(LPVOID	lpParam)
{
	CListenerController*	pListenerController = (CListenerController*)lpParam;
	HRESULT					hr					= S_OK;

	// TODO: Does this owrk on Win95??
	//       Handle return values.

	CoInitializeEx (NULL, COINIT_MULTITHREADED);

	CFileListener*  pListener = NULL;
	pListener   = new CFileListener();
	if(NULL == pListener) return E_OUTOFMEMORY;

	HANDLE*	paHandle = pListenerController->Event();

	pListener->AddRef();

	hr = pListener->Init(paHandle);
	if (FAILED(hr)) goto Cleanup;

	hr = pListener->StartListening();
	if (FAILED(hr)) goto Cleanup;

Cleanup:

	ULONG cref = pListener->Release();

	// ASSERT (cref == 0);

	SetEvent(paHandle[iEVENT_STOPPEDLISTENING]);

	CoUninitialize();

	return hr;
}


/***************************************************************************++

Routine Description:

    Returns the ListenerControler object.
	This object is a singleton. // TODO: Should I add synch. here?


Arguments:

    None.

Return Value:

    HRESULT

--***************************************************************************/
DWORD GetListenerController(CListenerController**	i_ppListenerController)
{

	HRESULT hr = S_OK;

	if(NULL == g_pListenerController)
	{
		g_pListenerController = new CListenerController();
		if (g_pListenerController == 0)
		{
			return E_OUTOFMEMORY;
		}

		hr = g_pListenerController->Init();

		if(FAILED(hr))
			return hr;

	}

	*i_ppListenerController = g_pListenerController;

	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\dtwriteincptr\dtwriteincptr.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/


#ifndef __DTWRITEINCPTR_H_
#define __DTWRITEINCPTR_H_

class CDTWriteInterceptorPlugin: public IInterceptorPlugin
{
public:
	
	CDTWriteInterceptorPlugin();
	
	~CDTWriteInterceptorPlugin();

public:

	STDMETHOD (QueryInterface)		(REFIID riid, OUT void **ppv);
	
	STDMETHOD_(ULONG,AddRef)		();
	
	STDMETHOD_(ULONG,Release)		();

	STDMETHOD(Intercept)			(LPCWSTR					i_wszDatabase, 
		                             LPCWSTR					i_wszTable, 
									 ULONG						i_TableID, 
									 LPVOID						i_QueryData, 
									 LPVOID						i_QueryMeta, 
									 DWORD						i_eQueryFormat, 
									 DWORD						i_fLOS, 
									 IAdvancedTableDispenser*	i_pISTDisp, 
									 LPCWSTR					i_wszLocator, 
									 LPVOID						i_pSimpleTable, 
									 LPVOID*					o_ppvSimpleTable);

	STDMETHOD(OnPopulateCache)		(ISimpleTableWrite2*  i_pISTW2);
	
	STDMETHOD(OnUpdateStore)		(ISimpleTableWrite2*  i_pISTW2);

private:
	
	ULONG					 m_cRef;

};

#endif //__DTWRITEINCPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\filelistener\listenercontroller.h ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    ListnerController.h

Abstract:

	Class that starts and stops the Listener

Author:

    Varsha Jayasimha (varshaj)        30-Nov-1999

Revision History:

--*/


#ifndef _LISTENERCONTROLLER_H_
#define _LISTENERCONTROLLER_H_

enum eEVENTS{
	iEVENT_STOPLISTENING = 0,		// Stop should be before processnotifications, because if both happen at the same time, you want stop to win.
	iEVENT_PROCESSNOTIFICATIONS,	
	iEVENT_STOPPEDLISTENING,
	cmaxLISTENERCONTROLLER_EVENTS
};


class CListenerController 
{

public:

	CListenerController();

	~CListenerController();

private:

	DWORD							m_cStartStopRef;

	HANDLE							m_aHandle[cmaxLISTENERCONTROLLER_EVENTS];

	CSemExclusive					m_seStartStop;

public:

	HRESULT Start();				// Start the listener.

	HRESULT Stop();					// Stop the listener.

	HRESULT Init();					// Initializes the events and CriticalSection

	HANDLE* Event();				// Accessor function that returns a ptr to the event handle array
};

DWORD GetListenerController(CListenerController**	i_ppListenerController);

#endif _LISTENERCONTROLLER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\samples\configdataadapter\configdatasetcommand.cs ===
namespace Microsoft.Configuration.Samples {

using System;
using System.Collections;

using System.Data;
using System.Configuration;
using System.Configuration.Schema;

using System.Diagnostics;

public class ConfigDataSetCommand {

    public enum DirectiveEnum {
        Add = 0,
        Remove =1
    }


    // Helper method for selectors that have a string representation
    public static void Load(DataSet ds, String configType, String sel) {
		Load(ds, configType, ConfigManager.GetSelectorFromString(sel));
	}

	public static void Load(DataSet ds, String configType, Selector sel) {
		DataTable table = null;

        IConfigCollection coll = null;
        //IConfigItem item = null;

		// Make sure we have a table for this configType
        table = LoadSchema(ds, configType);

		// Read the data for the configType
        coll=(IConfigCollection) ConfigManager.Get(configType, sel);

        if (coll.Count>0) { // Did we find anything?
			// Add a row for each config item:
            // Initialize an array with one value for each property in the config items
            Object[] values= new Object[coll[0].Count];

			// Enumerate the config items
            foreach (IConfigItem item1 in (BaseConfigCollection) coll) {
                // Copy each property to the value array
				int j=0;
                foreach (Object value in (BaseConfigItem) item1) {
					values[j]=value;
                    j++;
				}
                // Add a row with all the config item values
				table.Rows.Add(values);

            }
		}
	}

    // Helper method for selectors that have a string representation
    public static void Save(DataSet ds, String sel) {
        Save(ds, ConfigManager.GetSelectorFromString(sel));
    }

    public static void Save(DataSet ds, Selector sel) {
        IConfigCollection Inserts = null;
        IConfigCollection Updates = null;
        IConfigCollection Deletes = null;
		
        // Obtain the changed rows in the DataSet
        DataSet changes = ds.GetChanges();
        if (null==changes)
        {
            return;
        }
        // enumerate all changed tables
        foreach (DataTable table in changes.Tables) {
			
            // Create an empty configuration collection to hold the changed items
            Inserts = ConfigManager.GetEmptyConfigCollection(table.TableName);
            Inserts.Selector = sel; // identify where the items are to be stored

            Updates = ConfigManager.GetEmptyConfigCollection(table.TableName);
            Updates.Selector = sel; // identify where the items are to be stored

            Deletes = ConfigManager.GetEmptyConfigCollection(table.TableName);
            Deletes.Selector = sel; // identify where the items are to be stored

            // enumerate all changed rows in this table
            foreach (DataRow row in table.Rows) {

                if (DataRowState.Deleted==row.RowState) {
                    // If the row has been deleted:

                    // Create an empty configuration item for this row
                    IConfigItem item = ConfigManager.GetEmptyConfigItem(table.TableName);

			        // Copy the original values from the row into the item
                    for (int i=0; i<item.Count; i++) {
					    item[i]=row[i, DataRowVersion.Original];
				    }

                    Deletes.Add(item);
                    Trace.WriteLine("Deleted: " + item);
                    }
                else if (DataRowState.Modified==row.RowState || DataRowState.New==row.RowState) 
                {
                    // If the row has been modified or added:

                    // Create an empty configuration item for this row
                    IConfigItem item = ConfigManager.GetEmptyConfigItem(table.TableName);

			        // Copy the values from the row into the item
                    for (int i=0; i<item.Count; i++) {
					    item[i]=row[i];
				    }

                    // Add the item to the proper collection
                    if (DataRowState.Modified==row.RowState) {
                        // If the row has been modified, add it to the Updates collection
				        Updates.Add(item);
                        Trace.WriteLine("Updated: " + item);
                    }
                    else if (DataRowState.New==row.RowState) {
                        // If the row has been created, add it to Inserts collection
				        Inserts.Add(item);
                        Trace.WriteLine("Inserted: " + item);
                    }
                    else
                    {
                        // should never get here...
                        throw(new ApplicationException("internal error"));
                    }
                }
			}

            if (Deletes.Count>0) // any deleted rows?
            {
                // Delete them from the store
                ConfigManager.Delete(Deletes);
            }
            if (Inserts.Count>0) // any inserted rows?
            {
                // Add them to the store
                ConfigManager.Put(Inserts, PutFlags.CreateOnly);
            }
            if (Updates.Count>0) // any modified rows?
            {
                // Change them in the store
                ConfigManager.Put(Updates, PutFlags.UpdateOnly);
            }

            // Get ready for the next table/config type...
            Inserts = null;
            Updates = null;
            Deletes = null;
        }
    }

    public static DataTable LoadSchema(DataSet ds, String configType) {
		DataTable table = null;
        DataTable parentTable=null;

        DataColumn column = null;

		IConfigCollection parents= null;
        IConfigItem parent = null;

		// Do we already have a table for this configType?
        if (ds.Tables.Contains(configType)) {
            // Yes: use it.
            return ds.Tables[configType];;
        }

        // Create a new table for this configType
	    table = new DataTable();
	    table.TableName=configType;

	    // Set the schema for the table
		ArrayList pk = new ArrayList();

        foreach (PropertySchema propertyschema in ConfigSchema.PropertySchemaCollection(configType)) {
            column=table.Columns.Add(propertyschema.PublicName, propertyschema.SystemType);
            if ((((int) propertyschema["MetaFlags"]) & 1)>0) {
				pk.Add(column);
            }
	    }
		
		DataColumn[] pk1 = new DataColumn[pk.Count];
		pk.CopyTo(pk1);
		table.Constraints.Add("PK", pk1, true);

        // Add the new table to the dataset
	    ds.Tables.Add(table);


        // Set schema for any parent tables

        try {
	        parents = ConfigManager.Get("RelationMeta", "", 0);
        }
        catch {
            parents = null;
        }

        for (int i=0; i<parents.Count; i++) {
            parent = parents[i];
            if (parent["ForeignTable"].Equals(ConfigSchema.ConfigTypeSchema(configType).InternalName))
            {
                parentTable = LoadSchema(ds, (String) parent["PrimaryTable"]);
                // TODO: add DataSet relation info!
            }
	    }
        return table;
    }

}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\samples\configviewer\configviewer.cs ===
namespace Microsoft.Configuration.Samples
{

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using System.Data;
using System.Diagnostics;
using Trace=System.Diagnostics.Trace;
using System.Resources;

using System.Configuration;
using System.Configuration.Schema;
using System.Configuration.Internal;
using System.Configuration.Web;
using System.Configuration.Navigation;

using Microsoft.Configuration.Samples;

using System.Security;
using System.Runtime.Remoting;
using System.Runtime.InteropServices;
using System.Text;
using System.Configuration.Assemblies;


// This class is used to handle the settings (user preferences) of the ConfigViewer sample itself
// The class plugs into the configuration system via the ItemClass declaration in the schema for the ConfigViewer config type
// (in cfgview.xsd).
// It provides strongly typed access to the properties, and also sends notifications when the configuration is changed
// fron within the application.
public class ConfigViewerSettings : System.Configuration.BaseConfigItem {
    ConfigViewerSettings () : base(6) {}
    public Boolean AdvancedUI {
        get { return (Boolean) base[1]; } 
        set { 
            if (!(base[1] is Boolean) || (Boolean) base[1]!=value) {
                base[1]=value;
                if (notify!=null) {
                    notify.UpdateAdvancedUI(value);
                }
            }
        } 
    }
    public Boolean ShowInternalTypes  { get { return (Boolean) base[2]; } set { base[2]=value; } }
    public Boolean ShowAvailableTypes { get { return (Boolean) base[3]; } set { base[3]=value; } }
    public Boolean SingleTreeView {
        get { return (Boolean) base[4]; } 
        set { 
            if (!(base[4] is Boolean) || (Boolean) base[4]!=value) {
                base[4]=value;
                if (notify!=null) {
                    notify.UpdateSingleTreeView(value);
                }
            }
        } 
    }
    public Boolean ShowSingletonAsGrid{ get { return (Boolean) base[5]; } set { base[5]=value; } }
    public ConfigViewerSample notify;
}
   


/// <summary>
///    Summary description for ConfigViewerSample.
/// </summary>
public class ConfigViewerSample : System.WinForms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    private System.ComponentModel.Container components;
	private System.WinForms.StatusBarPanel statusBarPanel2;
	private System.WinForms.StatusBarPanel statusBarPanel1;
	private System.WinForms.StatusBar statusBar1;
	private System.WinForms.MenuItem menuItem10;
	private System.WinForms.MenuItem menuItem9;
	private System.WinForms.MenuItem menuItem8;
	private System.WinForms.Splitter splitter2;
	private System.WinForms.TreeView treeView2;
	private System.WinForms.MenuItem menuItem7;
	private System.WinForms.Panel panel2;
	
	private System.WinForms.MenuItem menuItem6;
	private System.WinForms.MenuItem menuItem5;
	private System.WinForms.MenuItem menuItem4;
	private System.WinForms.MenuItem menuItem3;
	private System.WinForms.MenuItem menuItem2;
	private System.WinForms.MenuItem menuItem1;
	private System.WinForms.MainMenu mainMenu1;
	private System.WinForms.ImageList imageList1;
	
	private System.WinForms.Button btnShowAll;
	
	private System.WinForms.DataGrid dataGrid1;
	private System.WinForms.Splitter splitter1;
	private System.WinForms.TreeView treeView1;
	private System.WinForms.Panel panel1;

	private System.WinForms.Button btnAddNew;
	private System.WinForms.Button btnClear;
	private System.WinForms.Button btnDiscard;
	private System.WinForms.Button btnRelated;
	private System.WinForms.Label label2;
	private System.WinForms.Label label1;
	
	private System.WinForms.ComboBox comboConfigType;
	private System.WinForms.Button btnWrite;
	
	private System.WinForms.TextBox txtSelector;
	
	private System.WinForms.Button btnRead;
	
    private int m_marginRight;
    private int m_marginBottom;
    private int m_marginRightDG;
    private int m_marginBottomDG;

	public const String ctNodes = "NavigationNodes";
	public const String ctFileLocation = "ConfigurationFileLocations";
	public const String ctNodeTypes = "NavigationNodeTypes";
	public const String ctNodeConfigTypes = "NavigationNodeConfigTypes";
	public const String ctConfigFileHierarchy = "ConfigFileHierarchy";

    public const String strMultiple = "Multiple: ";

    private IConfigCollection m_relations;
    protected IConfigCollection AllRelations { 
        get {
            if (m_relations==null) {
                m_relations = ConfigManager.Get("RelationMeta", "");
            }
            return m_relations;
        }
    }
    public const String cfgViewConfigType = "ConfigViewer";

    //BUGBUG: this enumeration should be defined in System.Configuration or filtering should occur within config manager!
    enum CollectionMetaFlags { 
		PrimaryKey   =     0x001,
        NotPublic	 =     0x800,
	}


    // Used to capture the user preference for the config view UI
    ConfigViewerSettings m_Settings;

    // Reads or re-reads config viewer settings from the configuration file
    void UpdateSettings() {
        try {
            m_Settings=(ConfigViewerSettings) ConfigManager.GetItem(cfgViewConfigType, new AppDomainSelector(), LevelOfService.Write);
        }
        catch {
            m_Settings=null;
        }
        if (m_Settings==null) {
			// Make sure we have an m_Settings to work against, so we don't have to check for null when
			// we need to access a setting
            m_Settings=(ConfigViewerSettings) ConfigManager.GetEmptyConfigItem(cfgViewConfigType);
            m_Settings.Selector = new AppDomainSelector();
            m_Settings[0]="";
            m_Settings.AdvancedUI=false;
            m_Settings.SingleTreeView=false;
            m_Settings.ShowAvailableTypes=false;
            m_Settings.ShowInternalTypes=false;
            m_Settings.ShowSingletonAsGrid=false;
			// Write it out to the configuration file
            ConfigManager.PutItem(m_Settings, PutFlags.CreateOnly);
        }
		m_Settings.notify=this;
    }

    // Update the UI to reflect a change in the AdvancedUI user preference
    public void UpdateAdvancedUI(Boolean bAdvancedUI) {
        if (bAdvancedUI) {
            panel1.Location=new System.Drawing.Point(0, 80);
        }
        else {
            panel1.Location=new System.Drawing.Point(0, 0);
        }
        ConfigViewerSample_Resize(null, null);
    }


    // Update the UI to reflect a change in the SingleTreeView user preference
    public void UpdateSingleTreeView(Boolean bSingleTreeView) {
        treeView2.Visible=!bSingleTreeView;
        splitter2.Visible=!bSingleTreeView;
        foreach (TreeNode node in treeView1.Nodes) {
            if (node !=null) {
                node.Collapse();
                node.Nodes.Clear();
                node.Nodes.Add("");
            }
        }
        ConfigViewerSample_Resize(null, null);
    }

    public ConfigViewerSample()
    {
        Trace.WriteLine("In ConfigViewerSample constructor");

        if (!DeclareSchemaFile("ConfigViewer Schema", null)) {
			MessageBox.Show("First time initialization done. Please restart the viewer.", "ConfigViewer Sample");
			Application.Exit();
			return;
		}

        //
        // Required for Win Form Designer support
        //
        InitializeComponent();

        menuItem3.Popup += new System.EventHandler(menuItem3_OnPopup);
        menuItem6.Click += new System.EventHandler(menuItem6_OnClick);
        menuItem7.Click += new System.EventHandler(menuItem7_OnClick);
        menuItem8.Click += new System.EventHandler(menuItem8_OnClick);
        menuItem9.Click += new System.EventHandler(menuItem9_OnClick);
        menuItem10.Click += new System.EventHandler(menuItem10_OnClick);

        //BUGBUG need to use resource manager instead of individual icon files
        //ResourceSet resourceset = new ResourceSet("ConfigViewerSample.resources");
        //System.Resources.ResourceManager resources = new System.Resources.ResourceManager("ConfigViewerSample", null, resourceset);

        //System.Resources.ResourceReader resources = new System.Resources.ResourceReader("ConfigViewerSample.resources");
        //resources.
		//imageList1.ImageStream = (System.WinForms.ImageListStreamer)resources.GetObject("imageList1.ImageStream");

        //Icon icon = new Icon("c:\\winnt\\system32\\shell32.dll");
        //Icon icon = new Icon("CLSDFOLD.ICO");
        try {

            String appdir = new AppDomainSelector().Argument;
            // Trim off "\config.cfg" part
            appdir=appdir.Substring(0,appdir.LastIndexOf('\\'));
            Trace.WriteLine(appdir);

            treeView1.ImageList = imageList1;
            treeView2.ImageList = imageList1;
            Icon icon = new Icon(appdir+"\\Folder.ICO");
            imageList1.Images.Add(icon);
            icon = new Icon(appdir+"\\FolderOpen.ICO");
            imageList1.Images.Add(icon);
            icon = new Icon(appdir+"\\file.ICO");
            imageList1.Images.Add(icon);
            icon = new Icon(appdir+"\\fileopen.ICO");
            imageList1.Images.Add(icon);
        }
        catch {};


        // Info for Resize
        m_marginRight=this.ClientRectangle.Width-btnWrite.Location.X;
        m_marginBottom=this.ClientRectangle.Height-btnWrite.Location.Y;
        m_marginRightDG=this.ClientRectangle.Width-panel1.Size.Width;
        m_marginBottomDG=btnWrite.Location.Y-(panel1.Location.Y+panel1.Size.Height);

        // Read the config viewer settings from the configuration file
        UpdateSettings();

        UpdateSingleTreeView(m_Settings.SingleTreeView);

        dataGrid1.CurrentCellChange += new System.EventHandler(DataGrid1_OnCellChange);

		txtSelector.Text="file://" + new LocalMachineSelector().Argument;

        // Read the available config types into the combo box for the advanced UI
        IConfigCollection ConfigTypes = ConfigManager.Get("Collection", "", 0);
		String[] items = new String[ConfigTypes.Count];

        foreach (ConfigTypeSchema ct in ConfigTypes) {
            if (m_Settings.ShowInternalTypes || 0 == (ct.MetaFlags & (int) ConfigTypeSchemaMetaFlags.Internal)) 
            {
			    comboConfigType.Items.Add(ct.PublicName);
            }
		}

        DataSet ds = new DataSet();
        ds.Tables.CollectionChanged += new CollectionChangeEventHandler(DataSet_OnChange);
        dataGrid1.DataSource = ds;

        // Read the root navigation node(s) into the tree view
        IConfigCollection nodes = ConfigManager.Get(ctNodes, "");
        foreach (NavigationNode node in nodes) {
            NavigationTreeNode n = new NavigationTreeNode(node);
            // Add an empty child node, so that we can continue to populate the tree view when the 
            // user expands the node
            n.Nodes.Add("");

            treeView1.Nodes.Add(n);
        }
        treeView1.BeforeExpand += new TreeViewCancelEventHandler(treeView1_OnBeforeExpand);
        treeView1.BeforeSelect += new TreeViewCancelEventHandler(treeView1_OnBeforeSelect);
        treeView2.BeforeExpand += new TreeViewCancelEventHandler(treeView1_OnBeforeExpand);
        treeView2.BeforeSelect += new TreeViewCancelEventHandler(treeView1_OnBeforeSelect);
        UpdateButtonState();
    }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        components.Dispose();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.menuItem2 = new System.WinForms.MenuItem();
		this.dataGrid1 = new System.WinForms.DataGrid();
		this.treeView2 = new System.WinForms.TreeView();
		this.menuItem3 = new System.WinForms.MenuItem();
		this.menuItem6 = new System.WinForms.MenuItem();
		this.menuItem5 = new System.WinForms.MenuItem();
		this.txtSelector = new System.WinForms.TextBox();
		this.btnClear = new System.WinForms.Button();
		this.btnRelated = new System.WinForms.Button();
		this.label1 = new System.WinForms.Label();
		this.statusBar1 = new System.WinForms.StatusBar();
		this.btnWrite = new System.WinForms.Button();
		this.comboConfigType = new System.WinForms.ComboBox();
		this.menuItem7 = new System.WinForms.MenuItem();
		this.mainMenu1 = new System.WinForms.MainMenu();
		this.menuItem1 = new System.WinForms.MenuItem();
		this.label2 = new System.WinForms.Label();
		this.btnDiscard = new System.WinForms.Button();
		this.splitter1 = new System.WinForms.Splitter();
		this.panel1 = new System.WinForms.Panel();
		this.splitter2 = new System.WinForms.Splitter();
		this.imageList1 = new System.WinForms.ImageList();
		this.btnAddNew = new System.WinForms.Button();
		this.btnShowAll = new System.WinForms.Button();
		this.btnRead = new System.WinForms.Button();
		this.menuItem9 = new System.WinForms.MenuItem();
		this.menuItem4 = new System.WinForms.MenuItem();
		this.statusBarPanel2 = new System.WinForms.StatusBarPanel();
		this.treeView1 = new System.WinForms.TreeView();
		this.statusBarPanel1 = new System.WinForms.StatusBarPanel();
		this.menuItem8 = new System.WinForms.MenuItem();
		this.menuItem10 = new System.WinForms.MenuItem();
		this.panel2 = new System.WinForms.Panel();
		
		dataGrid1.BeginInit();
		
		menuItem2.Text = "&Edit";
		menuItem2.Index = 1;
		
		dataGrid1.Size = new System.Drawing.Size(288, 280);
		dataGrid1.PreferredColumnWidth = 50;
		dataGrid1.DataMember = "";
		dataGrid1.Dock = System.WinForms.DockStyle.Fill;
		dataGrid1.ForeColor = System.Drawing.SystemColors.WindowText;
		dataGrid1.SelectionBackColor = System.Drawing.SystemColors.ActiveCaption;
		dataGrid1.TabIndex = 0;
		dataGrid1.BackColor = System.Drawing.SystemColors.Window;
		dataGrid1.GridTables.All = new System.WinForms.DataGridTable[] {};
		
		treeView2.Location = new System.Drawing.Point(224, 0);
		treeView2.Text = "treeView2";
		treeView2.Size = new System.Drawing.Size(180, 280);
		treeView2.Dock = System.WinForms.DockStyle.Left;
		treeView2.TabIndex = 15;
		
		menuItem3.Text = "&View";
		menuItem3.Index = 2;
		menuItem3.MenuItems.All = new System.WinForms.MenuItem[] {menuItem6, menuItem7, menuItem8, menuItem9, menuItem10};
		
		menuItem6.Text = "&Show internal configuration types";
		menuItem6.Index = 0;
		menuItem6.Checked = true;
		
		menuItem5.Text = "&Exit";
		menuItem5.Index = 0;
		
		txtSelector.Location = new System.Drawing.Point(120, 40);
		txtSelector.Text = "";
		txtSelector.TabIndex = 1;
		txtSelector.Size = new System.Drawing.Size(480, 20);
		
		btnClear.Location = new System.Drawing.Point(400, 368);
		btnClear.Size = new System.Drawing.Size(80, 24);
		btnClear.TabIndex = 8;
		btnClear.Text = "&Clear";
		btnClear.Click += new System.EventHandler(btnClear_Click);
		
		btnRelated.Location = new System.Drawing.Point(488, 368);
		btnRelated.Size = new System.Drawing.Size(80, 24);
		btnRelated.TabIndex = 8;
		btnRelated.Text = "&Related";
		btnRelated.Click += new System.EventHandler(btnRelated_Click);

        label1.Location = new System.Drawing.Point(16, 8);
		label1.Text = "Configuration &Type:";
		label1.Size = new System.Drawing.Size(104, 16);
		label1.TabIndex = 9;
		
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.Text = "Configuration Viewer Sample";
		//@design this.TrayLargeIcon = true;
		//@design this.TrayHeight = 93;
		this.Menu = mainMenu1;
		this.ClientSize = new System.Drawing.Size(704, 415);
		this.Resize += new System.EventHandler(ConfigViewerSample_Resize);
		
		statusBar1.BackColor = System.Drawing.SystemColors.Control;
		statusBar1.Location = new System.Drawing.Point(0, 395);
		statusBar1.Size = new System.Drawing.Size(704, 20);
		statusBar1.TabIndex = 14;
		statusBar1.Text = "";
        statusBar1.ShowPanels=true;
		statusBar1.Panels.All = new System.WinForms.StatusBarPanel[] {statusBarPanel1, statusBarPanel2};
		statusBar1.Click += new System.EventHandler(statusBar1_Click);
		
		btnWrite.Location = new System.Drawing.Point(616, 368);
		btnWrite.Size = new System.Drawing.Size(80, 24);
		btnWrite.TabIndex = 5;
		btnWrite.Text = "&Write";
		btnWrite.Click += new System.EventHandler(btnWrite_Click);
		
		comboConfigType.Location = new System.Drawing.Point(120, 8);
		comboConfigType.Text = "AppDomain";
		comboConfigType.Size = new System.Drawing.Size(480, 21);
		comboConfigType.TabIndex = 0;
		
		menuItem7.Text = "&Advanced";
		menuItem7.Index = 1;
		menuItem7.Checked = true;
		
		//@design mainMenu1.SetLocation(new System.Drawing.Point(85, 7));
		mainMenu1.MenuItems.All = new System.WinForms.MenuItem[] {menuItem1, menuItem2, menuItem3, menuItem4};
		
		menuItem1.Text = "&File";
		menuItem1.Index = 0;
		menuItem1.MenuItems.All = new System.WinForms.MenuItem[] {menuItem5};
		
		label2.Location = new System.Drawing.Point(16, 40);
		label2.Text = "&Selector: ";
		label2.Size = new System.Drawing.Size(104, 16);
		label2.TabIndex = 10;
		
		btnDiscard.Location = new System.Drawing.Point(312, 368);
		btnDiscard.Size = new System.Drawing.Size(80, 24);
		btnDiscard.TabIndex = 7;
		btnDiscard.Text = "&Discard";
		btnDiscard.Click += new System.EventHandler(btnDiscard_Click);
		
		splitter1.Cursor = System.Drawing.Cursors.VSplit;
		splitter1.Location = new System.Drawing.Point(220, 0);
		splitter1.Size = new System.Drawing.Size(4, 280);
		splitter1.TabIndex = 12;
		splitter1.TabStop = false;
		splitter1.Dock = System.WinForms.DockStyle.Left;
		
		panel1.Location = new System.Drawing.Point(0, 80);
		panel1.Size = new System.Drawing.Size(696, 280);
		panel1.TabIndex = 13;
		panel1.Text = "panel1";
		
		splitter2.Cursor = System.Drawing.Cursors.VSplit;
		splitter2.Location = new System.Drawing.Point(404, 0);
		splitter2.TabIndex = 16;
		splitter2.TabStop = false;
		splitter2.Size = new System.Drawing.Size(4, 280);
		splitter2.Dock = System.WinForms.DockStyle.Left;
		
		imageList1.ImageSize = new System.Drawing.Size(16, 16);
		imageList1.ColorDepth = System.WinForms.ColorDepth.Depth8Bit;
		//@design imageList1.SetLocation(new System.Drawing.Point(7, 7));
		imageList1.TransparentColor = System.Drawing.Color.Transparent;
		
		btnAddNew.Location = new System.Drawing.Point(616, 40);
		btnAddNew.Size = new System.Drawing.Size(80, 24);
		btnAddNew.TabIndex = 3;
		btnAddNew.Text = "&Add New";
		btnAddNew.Click += new System.EventHandler(btnAddNew_Click);
		
		btnShowAll.Location = new System.Drawing.Point(216, 368);
		btnShowAll.Size = new System.Drawing.Size(80, 24);
		btnShowAll.TabIndex = 6;
		btnShowAll.Text = "Show &All";
		btnShowAll.Click += new System.EventHandler(btnShowAll_Click);
		
		btnRead.Location = new System.Drawing.Point(616, 8);
		btnRead.Size = new System.Drawing.Size(80, 24);
		btnRead.TabIndex = 2;
		btnRead.Text = "&Read";
		btnRead.Click += new System.EventHandler(btnRead_Click);
		
		menuItem9.Text = "Single Tree View";
		menuItem9.Index = 3;
		menuItem9.Checked = true;
		
		menuItem4.Text = "&Help";
		menuItem4.Index = 3;
		
		statusBarPanel2.Text = "";
		statusBarPanel2.Width = 20;
		statusBarPanel2.AutoSize = System.WinForms.StatusBarPanelAutoSize.Spring;
		
		treeView1.Text = "Location";
		treeView1.Location = new System.Drawing.Point(0, 0);
		treeView1.Size = new System.Drawing.Size(220, 280);
		treeView1.Dock = System.WinForms.DockStyle.Left;
		treeView1.TabIndex = 11;
		
		statusBarPanel1.Text = "";
		statusBarPanel1.Width = 20;
		statusBarPanel1.AutoSize = System.WinForms.StatusBarPanelAutoSize.Spring;
		
		menuItem8.Text = "Indicate available config types";
		menuItem8.Index = 2;
		menuItem8.Checked = true;

		menuItem10.Text = "Show singleton as grid";
		menuItem10.Index = 3;
		menuItem10.Checked = true;
		
		panel2.Dock = System.WinForms.DockStyle.Fill;
		panel2.Location = new System.Drawing.Point(408, 0);
		panel2.Size = new System.Drawing.Size(288, 280);
		panel2.TabIndex = 14;
		panel2.Text = "panel2";
		
		panel1.Controls.Add(treeView1);
		panel1.Controls.Add(splitter2);
		panel1.Controls.Add(treeView2);
		panel1.Controls.Add(splitter1);
		panel1.Controls.Add(panel2);
		panel2.Controls.Add(dataGrid1);
		this.Controls.Add(statusBar1);
		this.Controls.Add(panel1);
		this.Controls.Add(btnAddNew);
		this.Controls.Add(btnClear);
		this.Controls.Add(btnRelated);
		this.Controls.Add(btnDiscard);
		this.Controls.Add(label2);
		this.Controls.Add(label1);
		this.Controls.Add(btnWrite);
		this.Controls.Add(comboConfigType);
		this.Controls.Add(txtSelector);
		this.Controls.Add(btnRead);
		this.Controls.Add(btnShowAll);
		
		dataGrid1.EndInit();
	}

    private Boolean DeclareSchemaFile(String cfgschemaName, String cfgschemaPath) {

		Boolean noRestart=true;

		// BUGBUG make sure configmanager finds the Interceptor assembly
		WebHierarchyInterceptor w = new WebHierarchyInterceptor();

        SchemaFile schemafile = null;

        // ****** Declare our custom schema file in the machine configuration file

        // Compute the location of the schema file, based on our config file location 
        if (cfgschemaPath==null) {
            cfgschemaPath = new AppDomainSelector().Argument;
            cfgschemaPath = cfgschemaPath.Substring(0, cfgschemaPath.LastIndexOf("."))+".xsd";
        }

        // Get an empty item that we can insert
        schemafile=(SchemaFile) ConfigManager.GetEmptyConfigItem("SchemaFiles");

        // Indicate the target location: machine configuration file
        schemafile.Selector = new LocalMachineSelector();

        // Specify the name for our schema and the path to the schema file
        schemafile.Name=cfgschemaName;
        schemafile.Path=cfgschemaPath;

        try {
            // Create a new entry in the machine configuration file, <SchemaFiles> section
            ConfigManager.PutItem(schemafile, PutFlags.CreateOnly);
			noRestart=false;
        }
        catch {
            // If this fails, it might be that a previous entry exists: 
            // Update it to point to the current schema location, just in case our EXE has been moved
            ConfigManager.PutItem(schemafile, PutFlags.UpdateOnly);
        }

        
        // ****** Declare our custom interceptors that compute the navigation hierarchy etc.
		// Copy the information from the interceptors.xml file into machine configuration file

		// Compute location of interceptors.xml
		String interceptorfile = new AppDomainSelector().Argument;
		interceptorfile=interceptorfile.Substring(0, cfgschemaPath.LastIndexOf("\\")+1)+"interceptors.xml";

		// Read all InterceptorWiring information
		IConfigCollection interceptors = ConfigManager.Get("InterceptorWiring", interceptorfile, LevelOfService.Write);

		// Workaround: can't use InterceptorWiring class to write - need to copy to BaseConfigItems
		//interceptors.Selector = new LocalMachineSelector();
		IConfigCollection interceptors1 = ConfigManager.GetEmptyConfigCollection("InterceptorWiring");
		interceptors1.Selector = new LocalMachineSelector();
		foreach (IConfigItem interceptor in interceptors) {
			IConfigItem interceptor1 = new BaseConfigItem(interceptor.Count);
			for (int i=0; i<interceptor1.Count; i++) {
				if (i==4 || i==5) {
					interceptor1[i]= (int) interceptor[i];
				}
				else {
					interceptor1[i]=interceptor[i];
				}
			}
			interceptors1.Add(interceptor1);
		}
		// End workaround
        try { 
            // Write all interceptor entries into machine configuration file
            ConfigManager.Put(interceptors1, PutFlags.CreateOnly); 
            Trace.WriteLine("Successfully added interceptor wiring information.");
			noRestart=false;
        } catch (Exception e) {
            Trace.WriteLine("Exception while adding interceptor wiring information (create):" + e);
            // If this fails, there may already be entries in the file: make sure they are up to date:
            try {
                ConfigManager.Put(interceptors1, PutFlags.UpdateOnly); 
                Trace.WriteLine("Successfully added interceptor wiring information (update).");
            }
            catch (Exception e1) {
                Trace.WriteLine("Exception while adding interceptor wiring information (update):" + e1);
				// If this fails, one or more entries may be present or missing: try to Put them individually
				foreach (IConfigItem interceptor in interceptors1) {
					try {
						interceptor.Collection=interceptors1;
						ConfigManager.PutItem(interceptor, PutFlags.CreateOrUpdate);
						noRestart=false;
					}
					catch {};
				}
            }
        }
		return noRestart;
    }

	protected void menuItem3_OnPopup(object sender, System.EventArgs e)
	{   
        Trace.WriteLine("Popup");
        UpdateSettings();
        menuItem6.Checked=m_Settings.ShowInternalTypes;
        menuItem7.Checked=m_Settings.AdvancedUI;
        menuItem8.Checked=m_Settings.ShowAvailableTypes;
        menuItem9.Checked=m_Settings.SingleTreeView;
        menuItem10.Checked=m_Settings.ShowSingletonAsGrid;
	}
	protected void menuItem6_OnClick(object sender, System.EventArgs e)
	{   
        m_Settings.ShowInternalTypes=!((MenuItem) sender).Checked;
        ConfigManager.PutItem(m_Settings);
	}
	protected void menuItem7_OnClick(object sender, System.EventArgs e)
	{   
        m_Settings.AdvancedUI=!((MenuItem) sender).Checked;
        ConfigManager.PutItem(m_Settings);
	}
	protected void menuItem8_OnClick(object sender, System.EventArgs e)
	{   
        m_Settings.ShowAvailableTypes=!((MenuItem) sender).Checked;
        ConfigManager.PutItem(m_Settings);
	}
	protected void menuItem9_OnClick(object sender, System.EventArgs e)
	{   
        m_Settings.SingleTreeView=!((MenuItem) sender).Checked;
        ConfigManager.PutItem(m_Settings);
	}

	protected void menuItem10_OnClick(object sender, System.EventArgs e)
	{   
        m_Settings.ShowSingletonAsGrid=!((MenuItem) sender).Checked;
        ConfigManager.PutItem(m_Settings);
	}

    protected void statusBar1_Click(object sender, System.EventArgs e) {
        if (statusBarPanel2.Text!=null && statusBarPanel2.Text!="") {
            if (statusBarPanel2.Text.StartsWith(strMultiple)) {
                CfgFileDialog cfgFiles = new CfgFileDialog(txtSelector.Text, this);
                cfgFiles.ShowDialog(this);
            }
            else {
                if (Win32Native.ShellExecute(0, "edit", statusBarPanel2.Text, "", "", 5)<32) {
                    Win32Native.ShellExecute(0, null, statusBarPanel2.Text, "", "", 5);
                }
            }
        }
    }


    /*
     * The main entry point for the application.
     *
     */
    public static void Main(string[] args) 
    {
        Application.Run(new ConfigViewerSample());
    }

    public String GetSelector() {
        return txtSelector.Text;
    }

    public void SetSelector(String selector) {
        txtSelector.Text=selector;
        btnRead_Click(null, null);
    }

    private void btnRead_Click(object sender, System.EventArgs e) {
        String currentTable=comboConfigType.Text;
		String currentFile=txtSelector.Text;

        ReadDataGrid(currentTable, currentFile);
        statusBarPanel1.Text = currentFile;
        statusBarPanel2.Text = "";

	}

    private void ReadDataGrid(String configType, String selector) {
		DataSet ds = null;
        String caption = configType;
		ds=(DataSet) dataGrid1.DataSource;

        if (ds.Tables.Contains(configType)) {
            ds.Tables[configType].Clear();
        }

        ConfigDataSetCommand.Load(ds, configType, selector);

		ds.Tables[configType].AcceptChanges();

        dataGrid1.DataSource = ds;
        dataGrid1.DataMember = configType;
        dataGrid1.CaptionText=caption;

        if (m_Settings.ShowSingletonAsGrid || !IsSingleton(configType)) {

            panel2.Controls.Clear();
            panel2.Controls.Add(dataGrid1);
            UpdateButtonState();
            return;
        }
        else {
            panel2.Controls.Clear();

            PropertySchemaCollection props = ConfigSchema.PropertySchemaCollection(configType);

			DataTable table = ds.Tables[configType];
			if (table.Rows.Count==0) {
				table.Rows.Add(table.NewRow());
			}

            int yPos=0;
            int nTabIndex=1;
            int LeftColumnWidth=0;

            Label ct = new Label();
		    ct.Location = new System.Drawing.Point(0, yPos);
            ct.Text = caption;
            ct.TabIndex=nTabIndex++;
		    ct.Size = new System.Drawing.Size(80, 20);
            ct.Dock = DockStyle.Top;
            ct.BackColor = dataGrid1.CaptionBackColor;
            ct.ForeColor = dataGrid1.CaptionForeColor;
            ct.Font = dataGrid1.CaptionFont;
           
            panel2.Controls.Add(ct);
            yPos =+ 20;
            Control previousControl=null;
            foreach (PropertySchema p in props) {
                if (p.SystemType==typeof(Boolean)) {
                    CheckBox c = new CheckBox();
                    c.Location = new System.Drawing.Point(80, yPos);
                    c.Text = p.PublicName;
                    c.AutoCheck=true;
                    c.ThreeState = true;
                    c.Width=400;
                    
                    c.Bindings.Add("Checked", table, p.PublicName);
                    c.TabIndex = nTabIndex++;
                    panel2.Controls.Add(c);
                    yPos+=20;
                    previousControl=c;
                }
                // TODO need to do better things for int, enums and other types!
                //if (p.SystemType==typeof(String)) 
                else {
                    
                    if (previousControl is CheckBox) {
                        yPos+=4;
                    }
                    yPos+=4;
                    Label l = new Label();
		            l.Location = new System.Drawing.Point(0, yPos);
                    l.Text = p.PublicName+":";
                    l.TabIndex=nTabIndex++;
                    l.AutoSize = true;
                    panel2.Controls.Add(l);
                    LeftColumnWidth = System.Math.Max(LeftColumnWidth, l.Size.Width);

                    TextBox t = new TextBox();

		            t.Location = new System.Drawing.Point(l.Location.X+l.Size.Width, yPos);
                    t.Bindings.Add("Text", table, p.PublicName);
		            t.TabIndex = nTabIndex++;
		            t.Size = new System.Drawing.Size(400, 20);
                    panel2.Controls.Add(t);
                    yPos+=20;
                    previousControl=t;
                }
            }
            LeftColumnWidth+=8;
            foreach (Control c in panel2.Controls) {
                if (c is TextBox || c is CheckBox) {
                    c.Left=LeftColumnWidth;
                }
                if (c is TextBox) {
                    c.Width=panel2.Width-c.Left;
                }
            }
        }
    }

	protected void btnAddNew_Click(object sender, System.EventArgs e)
	{
        String currentTable=comboConfigType.Text;

		DataSet ds = null;

		ds=(DataSet) dataGrid1.DataSource;

        if (ds.Tables.Contains(currentTable)) {
            ds.Tables[currentTable].Clear();
        }

        ConfigDataSetCommand.LoadSchema(ds, currentTable);

		ds.Tables[currentTable].AcceptChanges();

        dataGrid1.DataSource = ds;
        dataGrid1.DataMember = currentTable;
        UpdateButtonState();
	}

    private void btnWrite_Click(object sender, System.EventArgs e) {

		DataSet ds = (DataSet) dataGrid1.DataSource;
		this.BindingManager[ds.Tables[comboConfigType.Text]].Position=-1;
		
        if (ds.HasChanges()) {
            if (MessageBox.Show("Do you really want to save all changes to "+GetChangeList(ds)+"?", "", MessageBox.YesNo) !=DialogResult.Yes) {
                return;
            }
        }

        try {
            ConfigDataSetCommand.Save(ds, txtSelector.Text);
        }

        catch (Exception ex) {
            if (!(ex is ConfigException)) {
                throw;
            }

            String PhysicalName=null;
            String LogicalName=null;
			String file = null;
			try {

				if (treeView1.SelectedNode != null) {
					if (treeView1.SelectedNode is NavigationTreeNode) {
						PhysicalName = ((NavigationTreeNode) treeView1.SelectedNode).NavNode.PhysicalName;
						LogicalName = ((NavigationTreeNode) treeView1.SelectedNode).NavNode.LogicalName;
					}
					else if (treeView1.SelectedNode is ConfigTypeTreeNode ) {
						PhysicalName = ((ConfigTypeTreeNode) treeView1.SelectedNode).navigationParent.NavNode.PhysicalName;
						LogicalName = ((ConfigTypeTreeNode) treeView1.SelectedNode).navigationParent.NavNode.LogicalName;
					}
				}
				if (LogicalName !=null && txtSelector.Text == LogicalName) {
					IConfigCollection configfiles = ConfigManager.Get(ctFileLocation, LogicalName);
					if (configfiles.Count==1) {
						file=((NavigationConfigFile) configfiles[0]).ConfigFilePath;
					}
				}
			}
			catch {
			}
			if (file!=null && file !=txtSelector.Text) {
				if (MessageBox.Show("There was an error writing to "+txtSelector.Text+":\n  "+ex.Message+"\n\nDo you want to try to write directly to the innermost configuration file?\n  File: "+file, "", MessageBox.YesNo) ==DialogResult.Yes) {
					ConfigDataSetCommand.Save(ds, file);
				}
			}
			else {
				throw ex;
			}
        }

		ds.AcceptChanges();
        UpdateButtonState();
	}	
	
	private void btnShowAll_Click(object sender, System.EventArgs e) {
		dataGrid1.DataMember = "";
	}	

    String GetChangeList(DataSet ds) {
        String configTypes = "";
        foreach (DataTable table in ds.GetChanges().Tables) {
            if (table.Rows.Count>0) {
                configTypes=configTypes+table.TableName+", ";
            }
        }
        configTypes=configTypes.Substring(0, configTypes.Length-2);
        return configTypes;
    }

	protected void btnDiscard_Click(object sender, System.EventArgs e)
	{
		DataSet ds = (DataSet) dataGrid1.DataSource;
        if (ds.HasChanges()) {
            if (MessageBox.Show("Do you really want to discard all changes to "+GetChangeList(ds)+"?", "", MessageBox.YesNo) !=DialogResult.Yes) {
                return;
            }
            ds.RejectChanges();
        }
        UpdateButtonState();
	}

	protected void btnClear_Click(object sender, System.EventArgs e)
	{
        UpdateButtonState();
        DataSet ds = (DataSet) dataGrid1.DataSource;
        if (ds.Tables.Count>0) {
            if (MessageBox.Show("Do you really want to clear all data from the grid?", "", MessageBox.YesNo) !=DialogResult.Yes) {
                return;
            }
        }
        ds.Clear();
        UpdateButtonState();
	}

	protected void btnRelated_Click(object sender, System.EventArgs e)
    {
    }

    class NavigationTreeNode : TreeNode {
        internal NavigationTreeNode(NavigationNode navNode) {
            this.NavNode=navNode;
            this.Text=navNode.RelativeName;
            this.ImageIndex=0;
            this.SelectedImageIndex=1;
        }
        internal NavigationNode      NavNode;
    }

    class ConfigTypeTreeNode : TreeNode {
        internal ConfigTypeTreeNode(ConfigTypeSchema configType, NavigationTreeNode navigationParent) {
            this.configType=configType;
            this.navigationParent=navigationParent;
            this.Text=configType.PublicName;
            this.ImageIndex=2;
            this.SelectedImageIndex=3;
        }
        internal ConfigTypeSchema configType;
        internal NavigationTreeNode navigationParent;
    }

    class ConfigFileTreeNode : TreeNode {
        internal ConfigFileTreeNode(NavigationConfigFile configFile, ConfigTypeTreeNode configTypeParent, NavigationTreeNode navigationParent) {
            this.configFile=configFile;
            this.configTypeParent=configTypeParent;
            this.navigationParent=navigationParent;
            this.ImageIndex=2;
            this.SelectedImageIndex=3;
        }
        internal NavigationTreeNode navigationParent;
        internal ConfigTypeTreeNode configTypeParent;
        internal NavigationConfigFile configFile;
    }
    Boolean CheckConfigTypeSpecified(ConfigTypeTreeNode ctnode) {

        if (!m_Settings.ShowAvailableTypes) {
            return false;
        }
        String logicalName = ctnode.navigationParent.NavNode.LogicalName;
        IConfigCollection coll = null;
        try {
            coll = ConfigManager.Get(ctnode.configType.PublicName, logicalName);
        }
        catch {
			// also indicate if an unmerged view is available
            try {
                IConfigItem loc = ConfigManager.GetItem(ctFileLocation, logicalName);
                coll = ConfigManager.Get(ctnode.configType.PublicName, (String) loc["ConfigFilePath"]);
            }
            catch{
                coll = null;
            }
        }
        if (coll!=null && coll.Count>0) {
            ctnode.NodeFont = new Font(ctnode.TreeView.Font, FontStyle.Bold);
        }
        return coll!=null;
        
    }

Boolean AddChildren(ConfigTypeTreeNode parent, Boolean testForChildExistence) {

    foreach (RelationMeta childrel in AllRelations) {
        if (   childrel.PrimaryTable==parent.configType.InternalName 
            && ((childrel.MetaFlags & (int) RelationMetaMetaFlags.UseContainment)!=0)) {
            // TODO: need to handle non-containment relations. For now we display them as top-level entries
            if (testForChildExistence) {
                return true;
            }
            // Find ConfigType/PublicName from child's internal name
            IConfigCollection configtypes = ConfigManager.Get("Collection", "");
            ConfigTypeSchema child = (ConfigTypeSchema) configtypes.FindByKey(childrel.ForeignTable);
            ConfigTypeTreeNode ctchild = new ConfigTypeTreeNode(child, parent.navigationParent);
            
            // Make sure we can expand if there are any child config types
            if (AddChildren(ctchild, true)) {
                ctchild.Nodes.Add("");
            }
            parent.Nodes.Add(ctchild);
            CheckConfigTypeSpecified(ctchild);
            // TODO: add config file nodes when more than one file exists for a node
        }
    }
    return !testForChildExistence;
}


    protected Boolean CheckFilter(NavigationNode node, ConfigTypeSchema ct, IConfigCollection ctfilter) {
        foreach (NavigationNodeConfigType f in ctfilter) {
            if (node.NodeType == f.NodeType) {
                if (f.ConfigTypeCategory!=null && f.ConfigTypeCategory!="") {
                    if (ct.Database!=f.ConfigTypeCategory) {
                        return false;
                    }
                }
                if (f.ConfigTypeName!=null && f.ConfigTypeName!="") {
                    if (ct.InternalName!=f.ConfigTypeName) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    protected Boolean IsSingleton(String ct) {
        // TODO: this needs to be driven off of schema information (Beta 2)
		// For now: use the presence of a primary key property, that is not "keyn" to indicate a non singleton config type

        PropertySchemaCollection props = ConfigSchema.PropertySchemaCollection(ct);
        Boolean result = true;

		foreach (PropertySchema prop in props) {
			if ((prop.MetaFlags & (int) CollectionMetaFlags.PrimaryKey)!=0) {
				// PrimaryKey
				if (prop.InternalName.Length!=4 || !prop.InternalName.StartsWith("key") || !Char.IsDigit(prop.InternalName[3]) ) {
					result = false;
					break;
				}
			}
		}
		return result;
    }

    protected void treeView1_OnBeforeExpand(object sender, TreeViewCancelEventArgs e) {

        if (e.node.Nodes.Count==1 && e.node.Nodes[0].Text=="") {
            e.node.Nodes.Clear();
            if (e.node is NavigationTreeNode) {
                NavigationTreeNode node = (NavigationTreeNode) e.node;
                // read in all child nodes
                ConfigQuery q = new ConfigQuery();
                q.Add(ctNodes, "Parent", QueryCellOp.Equal, node.NavNode.LogicalName);
                IConfigCollection childnodes = ConfigManager.Get(ctNodes, q);
                foreach (NavigationNode child in childnodes) {
                    NavigationTreeNode n = new NavigationTreeNode(child);
                    n.Nodes.Add("");
                    e.node.Nodes.Add(n);
                }

                // read in all config types that apply to this node
                if (m_Settings.SingleTreeView) {
                    AddConfigTypeNodes((NavigationTreeNode) e.node);
                }
            }
            else if (e.node is ConfigTypeTreeNode) {
                ConfigTypeTreeNode parent = (ConfigTypeTreeNode) e.node;

                // TODO add configfile child nodes for parent nodes!

                // Add the immediate children of this config type
                AddChildren(parent, false);
            }
            else if (e.node is ConfigFileTreeNode) {
                // no child nodes under config file for now
            }
        }
    }

    void AddConfigTypeNodes(NavigationTreeNode node){

        // TODO filter using NavigationNodeConfigTypes if available
        IConfigCollection configtypes = ConfigManager.Get("Collection", "");
        String previousNode = null;
        if (!m_Settings.SingleTreeView) {
            if (treeView2.SelectedNode != null) {
                previousNode = treeView2.SelectedNode.Text;
                treeView2.SelectedNode = null;
            }
            treeView2.Nodes.Clear();
        }
        IConfigCollection ctfilter = ConfigManager.Get(ctNodeConfigTypes, "localmachine://");

        foreach (ConfigTypeSchema ct in configtypes) {
            if (m_Settings.ShowInternalTypes || 0 == (ct.MetaFlags & (int) ConfigTypeSchemaMetaFlags.Internal) ) {
                if (0 == (ct.SchemaGeneratorFlags & (int) ConfigTypeSchemaSchemaGeneratorFlags.IsContained) ) {
                    if (CheckFilter(node.NavNode, ct, ctfilter)) {
                        // add this config type, as it doesn't have any parents
                        ConfigTypeTreeNode ctnode = new ConfigTypeTreeNode(ct, node);


                        // Add any children on next expand
                        // BUGBUG 48355 need a meta flag IsContainer to efficiently avoid this when the type is not a parent! 

                        // Any children? Make sure we add a "+" for future expansion
                        if (AddChildren(ctnode, true)) {
                            ctnode.Nodes.Add("");
                        }

                        if (m_Settings.SingleTreeView) {
                            node.Nodes.Add(ctnode);
                        }
                        else {
                            treeView2.Nodes.Add(ctnode);
                        }
                        CheckConfigTypeSpecified(ctnode);
                    }
                }
            }
        }
        if (!m_Settings.SingleTreeView && previousNode!=null) {
            foreach (TreeNode t in treeView2.Nodes) {
                if (t.Text==previousNode) {
                    treeView2.SelectedNode=t;
                    break;
                }
            }

        }
    }

    protected void treeView1_OnBeforeSelect(object sender, TreeViewCancelEventArgs e) {
        String logicalName = null;
        String physicalName = null;
        String configType = ctNodes;

        if (e.node is NavigationTreeNode) {
            NavigationTreeNode node = (NavigationTreeNode) e.node;
            logicalName = node.NavNode.LogicalName;
            if (!m_Settings.SingleTreeView) {
                // only re-add config types if the node type has changed
                if (! (node.TreeView.SelectedNode is NavigationTreeNode) 
                    || ((NavigationTreeNode) node.TreeView.SelectedNode).NavNode.NodeType!=node.NavNode.NodeType) 
                {
                    AddConfigTypeNodes(node);
                }
                if (treeView2.SelectedNode is ConfigTypeTreeNode) {
                    configType=((ConfigTypeTreeNode) treeView2.SelectedNode).configType.PublicName;
                }
            }
        }
        else if (e.node is ConfigTypeTreeNode) {
            logicalName = ((ConfigTypeTreeNode) e.node).navigationParent.NavNode.LogicalName;
            configType = ((ConfigTypeTreeNode) e.node).configType.PublicName;
        }
        else if (e.node is ConfigFileTreeNode) {
            logicalName = null;
            physicalName = ((ConfigFileTreeNode) e.node).configFile.ConfigFilePath;
            configType = ((ConfigFileTreeNode) e.node).configTypeParent.configType.PublicName;
        }
        else {
            TreeNode selector = e.node.Parent;
            while (! (selector is NavigationTreeNode) && selector.Parent!=null) {
                selector = selector.Parent;
            }
            logicalName = ((NavigationTreeNode) selector).NavNode.LogicalName;
        }
            
        if (logicalName != null) {
            try {
                // first try if there is a "smart" interceptor that gives us a merged view
                ReadDataGrid(configType, logicalName);
                comboConfigType.Text=configType;
                txtSelector.Text=logicalName;
                statusBarPanel1.Text = logicalName;
                // TODO compute file hierarchy and display it
                Selector s =null;
                try {
                    s = ConfigManager.GetSelectorFromString(logicalName);
                }
                catch {
                    s = null;
                }

                if (s !=null && s is FileSelector && logicalName==s.ToString()) {
                    statusBarPanel2.Text = ((FileSelector) s).Argument;
                }
                else {
                    statusBarPanel2.Text = strMultiple;
                    try {
                        IConfigCollection files = ConfigManager.Get(ctConfigFileHierarchy, logicalName);
                        foreach (IConfigItem file in files) {
                            statusBarPanel2.Text = statusBarPanel2.Text + (String) file["ConfigFilePath"]+" ";
                        }
                    }
                    catch (Exception ex) {
                        statusBarPanel2.Text += ex.Message;
                    }
                }
                return;
            }

            catch (Exception ex) {
                if (!(ex is ConfigException)) {
                    throw;
                }
                // no smart interceptor, read the "raw" information for the node
                String file = null;
				try {
                    IConfigCollection configfiles = ConfigManager.Get(ctFileLocation, logicalName);
                    if (configfiles.Count==1) {
                        file=((NavigationConfigFile) configfiles[0]).ConfigFilePath;
					}
				}
				catch {};
				if (file !=null && file != logicalName) {
					if (MessageBox.Show("There was an error reading from "+txtSelector.Text+":\n  "+ex.Message+"\n\nDo you want to try to read directly from the innermost configuration file?\n  File: "+file, "", MessageBox.YesNo) ==DialogResult.Yes) {
                        ReadDataGrid(configType, file);
                        comboConfigType.Text=configType;
                        txtSelector.Text=file;
                        statusBarPanel1.Text = file;
                        statusBarPanel2.Text = file;
					}
                }
                return;
            }

        }
        throw(new Exception());
    }

    private void UpdateButtonState() {
        DataSet ds = (DataSet) dataGrid1.DataSource;
        Boolean enable = false;
        if (ds.HasChanges()) {
            enable=true;
        }
       
		btnWrite.Enabled=true; // TODO
        btnDiscard.Enabled=enable;
        if (ds.Tables.Count>1) {
            btnShowAll.Enabled=true;
        }
        else {
            btnShowAll.Enabled=false;
        }
        if (ds.Tables.Count>0) {
            btnClear.Enabled=true;
        }
        else {
            btnClear.Enabled=false;
        }
        UpdateAdvancedUI(m_Settings.AdvancedUI);
    }

	private void DataGrid1_OnCellChange(object sender, System.EventArgs e) {
        UpdateButtonState();
    }
	private void DataColumn_OnChange(object sender, DataColumnChangeEventArgs e) {
        Trace.WriteLine("Column changed");
        UpdateButtonState();
    }
	private void DataColumn_OnChange(object sender, DataRowChangeEventArgs e) {
        Trace.WriteLine("Row changed");
        UpdateButtonState();
    }
	private void DataSet_OnChange(object sender, CollectionChangeEventArgs e) {
        if (e.Action==CollectionChangeAction.Add) {
            ((DataTable) (e.Element)).ColumnChanging += new DataColumnChangeEventHandler(DataColumn_OnChange);
            ((DataTable) (e.Element)).RowChanged += new DataRowChangeEventHandler(DataColumn_OnChange);

        }
        UpdateButtonState();
    }
    
	private void ConfigViewerSample_Resize(object sender, System.EventArgs e) {
        btnWrite.Location = new System.Drawing.Point(
            this.ClientRectangle.Width-m_marginRight,
            this.ClientRectangle.Height-m_marginBottom);
        btnShowAll.Location = new System.Drawing.Point(
            btnShowAll.Location.X,
            btnWrite.Location.Y);
        btnDiscard.Location = new System.Drawing.Point(
            btnDiscard.Location.X,
            btnWrite.Location.Y);
        btnClear.Location = new System.Drawing.Point(
            btnClear.Location.X,
            btnWrite.Location.Y);
		panel1.Size = new System.Drawing.Size( 
            this.ClientRectangle.Width-m_marginRightDG,
            btnWrite.Location.Y-m_marginBottomDG-panel1.Location.Y);
	}

}

    [SuppressUnmanagedCodeSecurityAttribute()]
    internal sealed class Win32Native {

        internal const String SHELL32 = "shell32";

        [dllimport(SHELL32)]
        public static extern int ShellExecute(int hwnd, String lpVerb, String lpFile, String lpParameters, String lpDirectory, int nShowCmd);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\metabaselistener\mblisten.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation
/***************************************************************************/

#define  _WCTYPE_INLINE_DEFINED  // to avoid multiple definition of iswdigit
#include "MBListen.h"
#include <iiscnfg.h>
#include <process.h>
#include "catalog.h"

STDAPI CookDownIncrementalInternal(WAS_CHANGE_OBJECT* i_aWASChngObj,
								   ULONG			  i_cWASChngObj);

// String consts
// I'm not getting these from an IIS header because
// 1. Even in the IIs code, these are defined in multiple files.
// 2. There are too many dependent header files that I don't want to carry over.
static const WCHAR g_wszLM[]		= L"LM";
static const WCHAR g_wszW3SVC[]		= L"W3SVC";
static const WCHAR g_wszAPPPOOLS[]	= L"APPPOOLS";
static const WCHAR g_wszROOT[]		= L"ROOT";
static const WCHAR g_wszFILTERS[]	= L"FILTERS";

static const WCHAR g_wszLATENCY[]	= L"/LM/W3SVC";
#define MD_WAS_COOKDOWN_LATENCY     1044

#define ANY_WAS_TABLE_MASK	(TABLEMASK(wttAPPPOOL)|TABLEMASK(wttSITE)|TABLEMASK(wttAPP)|TABLEMASK(wttGLOBALW3SVC)|TABLEMASK(wttFINAL))

// -----------------------------------------
// CMetabaseListener::IUnknown
// -----------------------------------------

// =======================================================================
STDMETHODIMP CMetabaseListener::QueryInterface(REFIID riid, void **ppv)
{
	if (NULL == ppv) 
		return E_INVALIDARG;

	*ppv = NULL;

	if (riid == IID_IMSAdminBaseSink)
	{
		*ppv = (IMSAdminBaseSink*) this;
	}
	else if (riid == IID_IUnknown)
	{
		*ppv = (IMSAdminBaseSink*) this;
	}

	if (NULL != *ppv)
	{
		AddRef ();
		return S_OK;
	}
	else
	{
		return E_NOINTERFACE;
	}
}

// =======================================================================
STDMETHODIMP_(ULONG) CMetabaseListener::AddRef()
{
	return InterlockedIncrement((LONG*) &m_cRef);
}

// =======================================================================
STDMETHODIMP_(ULONG) CMetabaseListener::Release()
{
	long cref = InterlockedDecrement((LONG*) &m_cRef);
	if (cref == 0)
	{
		delete this;
	}
	return cref;
}


// =======================================================================
HRESULT CMetabaseListener::Init()
{
	ISimpleTableDispenser2	*pISTDisp = NULL;
	UINT		dwThreadID;
	ULONG		i;
	static DWORD adwAdditionalSiteIDs[] = {MD_SERVER_BINDINGS, MD_SECURE_BINDINGS};
	static ULONG cAdditionalSiteIDs = sizeof(adwAdditionalSiteIDs)/sizeof(DWORD);
	static DWORD adwAdditionalAppIDs[] = {MD_APP_ISOLATED};
	static ULONG cAdditionalAppIDs = sizeof(adwAdditionalAppIDs)/sizeof(DWORD);
	HRESULT		hr = S_OK;

	hr = GetSimpleTableDispenser(WSZ_PRODUCT_IIS, 0, &pISTDisp);
	if (FAILED(hr))
	{
		TRACE(L"[CMetabaseListener::Init] Call to GetSimpleTableDispenser failed with hr = %08x\n", hr);
		goto Cleanup;
	}

	// Initialize the property ids of all four tables. Specify any additional 
	// property ids if necessary.
	hr = InitPropertyIDs(wttAPPPOOL, pISTDisp,	wszTABLE_APPPOOLS);
	if (FAILED(hr))
	{
		goto Cleanup;
	}

	hr = InitPropertyIDs(wttSITE, pISTDisp,	wszTABLE_SITES, adwAdditionalSiteIDs, cAdditionalSiteIDs);
	if (FAILED(hr))
	{
		goto Cleanup;
	}

	hr = InitPropertyIDs(wttAPP, pISTDisp,	wszTABLE_APPS, adwAdditionalAppIDs, cAdditionalAppIDs);
	if (FAILED(hr))
	{
		goto Cleanup;
	}

	hr = InitPropertyIDs(wttGLOBALW3SVC, pISTDisp,	wszTABLE_GlobalW3SVC);
	if (FAILED(hr))
	{
		goto Cleanup;
	}

    hr = SetFinalPropertyID();
	if (FAILED(hr))
	{
		goto Cleanup;
	}

	// See if the user has changed the latency in the metabase.
	// We don't care if this fails.
	GetCookdownLatency(&m_dwLatency);
	
	// Create the events.
	for (i = 0; i < m_eHandleCount; i++)
	{
		m_aHandles[i] = CreateEvent(NULL,	// Use default security settings.
									FALSE,	// Auto-reset.
									FALSE,	// Initially nonsignaled.
									NULL);  // With no name.
		if (m_aHandles[i] == NULL) 
		{ 
			hr = HRESULT_FROM_WIN32(GetLastError()); 
			goto Cleanup;
		}
	}

	// Start the thread responsible for incremental cookdowns.
	m_hThread = (HANDLE) _beginthreadex(NULL, 0, CookdownQueueThreadStart, (LPVOID)this, 0, &dwThreadID);
	if (m_hThread == NULL)
	{
		hr = HRESULT_FROM_WIN32(GetLastError()); 
		goto Cleanup;
	}

	// Subscribe for metabase changes.
	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, IID_IConnectionPointContainer, (void**)&m_spICPC);
	if(FAILED(hr)) 
	{	
		TRACE(L"[CMetabaseListener::Init] Call to CoCreateInstance failed with hr = %08x\n", hr);
		goto Cleanup;	
	}	

	hr = m_spICPC->FindConnectionPoint(IID_IMSAdminBaseSink, &m_spICP);
	if(FAILED(hr))	
	{	
		TRACE(L"[CMetabaseListener::Init] Call to FindConnectionPoint failed with hr = %08x\n", hr);
		goto Cleanup;	
	}

	//establish event notification with iis metabase
	hr = m_spICP->Advise((IUnknown*)this, &m_dwCookie);
	if(FAILED(hr))	
	{	
		TRACE(L"[CMetabaseListener::Init] Call to Advise failed with hr = %08x\n", hr);
		goto Cleanup;	
	}

Cleanup:
	if (pISTDisp)
	{
		pISTDisp->Release();
	}
	return hr;
}

// =======================================================================
// Do all the cleanup that shouldn't be done in the destructor here. Note 
// that the destructor may be called during shutdown via DllMainCrtStartup,
// where we should not make any more COM calls to other objects. They may 
// have been cleaned up as well.
// =======================================================================
HRESULT CMetabaseListener::Uninit()
{
	DWORD		dwWait;
	HRESULT		hr = S_OK;

    // Make sure we received the final notification from the Cooker object.
    // If we have received it we are done. If not wait for a certain 
    // amount of time (2 secs) and give up. If we gave up, we need to let the caller
    // know so that the next time WAS starts up, a full cookdown takes place.
	dwWait = WaitForSingleObject(m_aHandles[m_eReceivedFinalChange], 2000);
    if (dwWait != WAIT_OBJECT_0)
    {
        hr = S_FALSE;
    }

	// Stop listening to metabase notifications.
	if (m_dwCookie != 0)
	{
		HRESULT hrSav;

		ASSERT(m_spICP);
		hrSav = m_spICP->Unadvise(m_dwCookie);
		if (FAILED(hrSav))
		{
			TRACE(L"[CMetabaseListener::Uninit] Call to Unadvise failed with hr = %08x\n", hrSav);
		}

		m_dwCookie = 0;
	}

	// Notify the queue thread that we are done.
	if (m_aHandles[m_eDone] != NULL)
	{
		if (SetEvent(m_aHandles[m_eDone]) == FALSE)
		{
			TRACE(L"[CMetabaseListener::Uninit] Call to SetEvent failed with hr = %08x\n", HRESULT_FROM_WIN32(GetLastError()));
		}
	}

	// Wait on the queue thread to be done.
	if (m_hThread)
	{
		WaitForSingleObject(m_hThread, INFINITE);
		CloseHandle(m_hThread);
		m_hThread = NULL;
	}

	return hr;
}


// =======================================================================
// 
//	This method should be called when an inetinfo crash or shutdown has been 
//	detected. It will release the old pointers, clear the cookdown queue, and
//	re-advise to metabase changes.
//
// =======================================================================
HRESULT CMetabaseListener::RehookNotifications()
{
	ULONG		iChangeList;
	HRESULT		hr = S_OK;

	// Stop listening to metabase notifications.
	if (m_dwCookie != 0)
	{
		ASSERT(m_spICP);
		m_spICP->Unadvise(m_dwCookie);
		// Ignore the error returned by the Unadvise.

		m_dwCookie = 0;
	}

	// Release all the old pointers.
	if (m_spICP)
	{
		m_spICP->Release();
	}

	if (m_spICPC)
	{
		m_spICPC->Release();
	}

	{
		// Lock the cookdown queue.
		CLock	cLock(m_seCookdownQueueLock);

		// Clear the old cookdown queue.
		for (iChangeList = 0; iChangeList < m_aCookdownQueue.size(); iChangeList++)
		{
			ASSERT(m_aCookdownQueue[iChangeList]);
			UninitChangeList(*m_aCookdownQueue[iChangeList]);
			delete m_aCookdownQueue[iChangeList];
			m_aCookdownQueue[iChangeList] = NULL;
		}
	}

	// Resubscribe for metabase changes.
	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, IID_IConnectionPointContainer, (void**)&m_spICPC);
	if(FAILED(hr)) {	return hr;	}	

	hr = m_spICPC->FindConnectionPoint(IID_IMSAdminBaseSink, &m_spICP);
	if(FAILED(hr))	{	return hr;	}

	//establish event notification with iis metabase
	hr = m_spICP->Advise((IUnknown*)this, &m_dwCookie);
	if(FAILED(hr))	{	return hr;	}

	return S_OK;
}


// -----------------------------------------
// CMetabaseListener::IMSAdminBaseSink:
// -----------------------------------------


// =======================================================================
STDMETHODIMP CMetabaseListener::SinkNotify(
	DWORD		i_dwMDNumElements, 
	MD_CHANGE_OBJECT_W i_pcoChangeList[])
{
	ULONG		iChangeObj;
	WAS_CHANGE_OBJECT wcoChange;
	Array<WAS_CHANGE_OBJECT> *paChangeList = NULL;
	HRESULT		hr = S_OK;

	ASSERT(_CrtIsValidPointer(i_pcoChangeList, i_dwMDNumElements * sizeof(MD_CHANGE_OBJECT_W), FALSE));

	ZeroMemory(&wcoChange, sizeof(WAS_CHANGE_OBJECT));

	paChangeList = new Array<WAS_CHANGE_OBJECT>;
	if (paChangeList == NULL) {	hr = E_OUTOFMEMORY;	goto Cleanup;	}

	for (iChangeObj = 0; iChangeObj < i_dwMDNumElements; iChangeObj++)
	{
		// Figure out the table type of the change.
		hr = FilterChangeObject(&i_pcoChangeList[iChangeObj], &wcoChange);
		if (FAILED(hr))	
		{	
			goto Cleanup;	
		}

		// If the change is not relevant to WAS, skip this change.
		if (wcoChange.dwWASTableType == TABLEMASK(wttIRRELEVANT))
		{
    		ZeroMemory(&wcoChange, sizeof(WAS_CHANGE_OBJECT));
			continue;
		}
		
		// If we received the final change that the cooker set, let the
        // the thread that calls incremental cookdown know. This is an
        // indication that WAS is shutting down.
		if (wcoChange.dwWASTableType & TABLEMASK(wttFINAL))
		{
            // Let the cookdown thread know.
	        if (SetEvent(m_aHandles[m_eReceivedFinalChange]) == FALSE)
	        {
		        hr = HRESULT_FROM_WIN32(GetLastError());
                goto Cleanup;
	        }
		}
		
		// The change object is relevant, add it to the list.
		// Also make sure to add the data ids, if there are any.
		if (i_pcoChangeList[iChangeObj].dwMDNumDataIDs > 0)
		{
			wcoChange.pdwMDDataIDs = new DWORD [i_pcoChangeList[iChangeObj].dwMDNumDataIDs];
			if (NULL == wcoChange.pdwMDDataIDs)
			{
				hr = E_OUTOFMEMORY;
				goto Cleanup;
			}

			wcoChange.dwMDNumDataIDs = i_pcoChangeList[iChangeObj].dwMDNumDataIDs;
			memcpy(wcoChange.pdwMDDataIDs, i_pcoChangeList[iChangeObj].pdwMDDataIDs, sizeof(DWORD) * wcoChange.dwMDNumDataIDs);
		}

		hr = AddChangeObjectToList(&wcoChange, *paChangeList);
		if (FAILED(hr))	{	goto Cleanup;	}

		// The queue owns the memory for wszPath and pdwMDDataIDs.
		ZeroMemory(&wcoChange, sizeof(WAS_CHANGE_OBJECT));
	}

	// If there is at least one element in the change list add it to the cookdown queue. 
	// Else delete the change list.
	if (paChangeList->size() > 0)
	{
		hr = AddChangeListToCookdownQueue(paChangeList);
		if (FAILED(hr))	{	goto Cleanup;	}
	}
	else
	{
		delete paChangeList;
	}

	// If paChangeList has been added to the cookdown queue, it is the second thread's
	// responsibility to delete it.
	paChangeList = NULL;

Cleanup:
	if (FAILED(hr))
	{
		if (wcoChange.wszPath)
		{
			delete [] wcoChange.wszPath;
		}

		if (wcoChange.pdwMDDataIDs)
		{
			delete [] wcoChange.pdwMDDataIDs;
		}

		if (paChangeList)
		{
			UninitChangeList(*paChangeList);
			delete paChangeList;
		}
	}

	return hr;
}

// =======================================================================
STDMETHODIMP CMetabaseListener::ShutdownNotify()
{
	ASSERT(0 && "WAS should have already told us about the shutdown");
	return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED); 
}


// -----------------------------------------
// Internal methods:
// -----------------------------------------

// =======================================================================
// Given a change object, this method figures out 
//	- what table would be effected (WASTABLETYPE)
//	- the effected path (depending on the table type this can be one of
//		AppPoolPath, VirtualSiteKeyPath, or AppPath 
//		The metabase cooker expects to see a '/' in front of the AppPath only.
//	- Site root path 
//	- Virtual site id.
// =======================================================================
HRESULT CMetabaseListener::FilterChangeObject(
	MD_CHANGE_OBJECT_W *i_pChangeObject,
	WAS_CHANGE_OBJECT *o_pwcoChange)
{
	DWORD		iChangedDataID;
	DWORD		iMetabaseID;
	LONG		iTableType;
	WCHAR		achNode[MAX_PATH];
	ULONG		cbNext;
	LPWSTR		wszTemp;
	LPWSTR		wszSite;

	ASSERT(i_pChangeObject);
	ASSERT(i_pChangeObject->pszMDPath);
	ASSERT(o_pwcoChange);
	ASSERT(o_pwcoChange->wszPath == NULL);
	ASSERT(o_pwcoChange->iVirtualSiteID == 0);

	o_pwcoChange->dwWASTableType = TABLEMASK(wttUNKNOWN);

	// Set the change type of the out param.
	o_pwcoChange->dwMDChangeType = i_pChangeObject->dwMDChangeType;
	wszTemp = i_pChangeObject->pszMDPath;

	GetNextNode(wszTemp, achNode, &cbNext);

	if (achNode[0] == L'\0')
	{
		// This is /.
		o_pwcoChange->dwWASTableType = TABLEMASK(wttRELEVANT);
	}
	else if (_wcsicmp(achNode, g_wszLM) != NULL)
	{
		// The path doesn't start with the node "LM", has to be irrelevant.
		o_pwcoChange->dwWASTableType = TABLEMASK(wttIRRELEVANT);
	}

	if (o_pwcoChange->dwWASTableType == TABLEMASK(wttUNKNOWN))
	{
		// The path must start with "/LM...."
		wszTemp += cbNext;
		GetNextNode(wszTemp, achNode, &cbNext);

		if (achNode[0] == L'\0')
		{
			// This is on /LM.
			o_pwcoChange->dwWASTableType = TABLEMASK(wttRELEVANT);
		}
		else if (_wcsicmp(achNode, g_wszW3SVC) != NULL)
		{
			// The node following LM is not W3SVC, therefore has to be irrelevant.
			o_pwcoChange->dwWASTableType = TABLEMASK(wttIRRELEVANT);
		}
	}

	if (o_pwcoChange->dwWASTableType == TABLEMASK(wttUNKNOWN))
	{
		// The path must start with "/LM/W3SVC..."
		wszTemp += cbNext;
		GetNextNode(wszTemp, achNode, &cbNext);

		if (achNode[0] == L'\0')
		{
			// This is on /LM/W3SVC.
			o_pwcoChange->dwWASTableType = TABLEMASK(wttRELEVANT);
		}
		else
		{
			if (_wcsicmp(achNode, g_wszFILTERS) == NULL)
			{
				// Found node /LM/W3SVC/FILTERS.
				o_pwcoChange->dwWASTableType = TABLEMASK(wttGLOBALW3SVC);
			}
			else if (_wcsicmp(achNode, g_wszAPPPOOLS) == NULL)
			{
				// Found node /LM/W3SVC/APPPOOLS.
				o_pwcoChange->dwWASTableType = TABLEMASK(wttAPPPOOL);

				o_pwcoChange->wszPath = new WCHAR[wcslen(wszTemp + cbNext)+1]; 
				if (o_pwcoChange->wszPath == NULL)
				{
					return E_OUTOFMEMORY;
				}
				o_pwcoChange->wszPath = wcscpy(o_pwcoChange->wszPath, wszTemp + cbNext);
			}
			else if ((o_pwcoChange->iVirtualSiteID = _wtoi(achNode)) != 0)
			{
				ASSERT(o_pwcoChange->wszPath == NULL);
				o_pwcoChange->wszPath = new WCHAR[wcslen(wszTemp)+1]; 
				if (o_pwcoChange->wszPath == NULL)
				{
					return E_OUTOFMEMORY;
				}
				o_pwcoChange->wszPath = wcscpy(o_pwcoChange->wszPath, wszTemp);
				
				// Keep track of the beginig of the site.
				wszSite = wszTemp;

				// Found node /LM/W3SVC/<integer>..
				wszTemp += cbNext;
				GetNextNode(wszTemp, achNode, &cbNext);

				if (achNode[0] == L'\0') 
				{
					// This is on /LM/W3SVC/<integer>/ 
					o_pwcoChange->dwWASTableType = TABLEMASK(wttSITE);
				}
				else if (_wcsicmp(achNode, g_wszFILTERS) == NULL) 
				{
					// This is on /LM/W3SVC/<integer>/Filters
					// Still a site notification.
					o_pwcoChange->dwWASTableType = TABLEMASK(wttSITE);

					// But also make sure to remove the "Filters" string from the wszPath.
					o_pwcoChange->wszPath[wszTemp-wszSite] = L'\0';

					// Special case: Even an ADD_OBJECT or DELETE_OBJECT of a filter is considered
					// as an update to the Site data. (SET_DATA and DELETE_DATA).
					if (o_pwcoChange->dwMDChangeType == MD_CHANGE_TYPE_ADD_OBJECT)
					{
						o_pwcoChange->dwMDChangeType = MD_CHANGE_TYPE_SET_DATA;
					}
					else if (o_pwcoChange->dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT)
					{
						o_pwcoChange->dwMDChangeType = MD_CHANGE_TYPE_DELETE_DATA;
					}
				}
				else if (_wcsicmp(achNode, g_wszROOT) != NULL)
				{
					// The node following the SiteID is not ROOT, therefore has to be irrelevant.
					o_pwcoChange->dwWASTableType = TABLEMASK(wttIRRELEVANT);
				}
				else
				{
					o_pwcoChange->dwWASTableType = TABLEMASK(wttAPP);

					// Set the SiteRootPath.
					// (wszTemp + cbNext) - o_pwcoChange->wszPath is the siterootpath length.
					wcsncpy(o_pwcoChange->wszSiteRootPath, wszSite, (wszTemp + cbNext) - wszSite);
					o_pwcoChange->wszSiteRootPath[(wszTemp + cbNext) - wszSite] = L'\0';
				}
			}
			else 
			{
				o_pwcoChange->dwWASTableType = TABLEMASK(wttIRRELEVANT);
			}
		}
	}

	// The table type can't be unknown at this point.
	ASSERT(o_pwcoChange->dwWASTableType != TABLEMASK(wttUNKNOWN));

	if (o_pwcoChange->dwWASTableType == TABLEMASK(wttIRRELEVANT))
	{
		return S_OK;
	}

	// If type is not "App", string should not start with '/'.
	if (o_pwcoChange->dwWASTableType == TABLEMASK(wttAPPPOOL) || o_pwcoChange->dwWASTableType == TABLEMASK(wttSITE))
	{
		memmove(o_pwcoChange->wszPath, o_pwcoChange->wszPath+1, (wcslen(o_pwcoChange->wszPath+1)+1) * sizeof(WCHAR));
	}
	else if (o_pwcoChange->dwWASTableType == TABLEMASK(wttRELEVANT))
	{
		// The change can affect multiple sites, apps, or apppools. So a specific path
		// doesn't make sense.
		if (o_pwcoChange->wszPath)
		{
			delete [] o_pwcoChange->wszPath;
			o_pwcoChange->wszPath = NULL;
		}
	}

	if (i_pChangeObject->dwMDChangeType & MD_CHANGE_TYPE_ADD_OBJECT ||
		i_pChangeObject->dwMDChangeType & MD_CHANGE_TYPE_DELETE_OBJECT)
	{
		ASSERT(o_pwcoChange->dwWASTableType != TABLEMASK(wttRELEVANT));
		return S_OK;
	}

	for (iTableType = wttFINAL; iTableType < wttMAX; iTableType++)
	{
		for (iChangedDataID = 0; iChangedDataID < i_pChangeObject->dwMDNumDataIDs; iChangedDataID++)
		{
			for (iMetabaseID = 0; iMetabaseID < m_mmIDs[iTableType].cIDs; iMetabaseID++)
			{
				// If there is at least one relevant DataID, it is worth cooking down.
				if (i_pChangeObject->pdwMDDataIDs[iChangedDataID] == m_mmIDs[iTableType].pdwIDs[iMetabaseID])
				{
					if (!(o_pwcoChange->dwWASTableType & TABLEMASK(wttRELEVANT))) 
					{
						// If we knew the table type and the property is valid for the table, we are done.
						if (o_pwcoChange->dwWASTableType == (DWORD) TABLEMASK(iTableType))
							return S_OK;
					}
					else
					{
						// If we don't know what table, there can be multiple tables effected.
						o_pwcoChange->dwWASTableType |= TABLEMASK(iTableType);
					}
				}
			}
		}
	}

	// If we didn't know the table type and the above loop matched a property to some tables
	// it must be relevant.
	if ((o_pwcoChange->dwWASTableType & TABLEMASK(wttRELEVANT)) && (o_pwcoChange->dwWASTableType & ANY_WAS_TABLE_MASK))
	{
		return S_OK;
	}
	
	// Otherwise: 
	// Either, we knew the table type prior to the for loop and didn't find a matching property
	// must be irrelevant.
	// Or, we didn't know the table type and didn't find any interesting properties.
	// Therefore, the table is irrelevant.
	o_pwcoChange->dwWASTableType = TABLEMASK(wttIRRELEVANT);
	return S_OK;
}


// =======================================================================
// Note: Caller needs to clean up (Uninit) the change list.
HRESULT CMetabaseListener::AddChangeObjectToList(
	WAS_CHANGE_OBJECT *i_pwcoChange,
	Array<WAS_CHANGE_OBJECT>& i_aChangeList) 
{
	WAS_CHANGE_OBJECT *pChangeObject = NULL;
	SIZE_T		cPath = 0;
	HRESULT		hr = S_OK;
		
	// Alloc room for a new ChangeObject.
	try
	{
		i_aChangeList.setSize(i_aChangeList.size()+1);
	}
	catch(...)
	{
		return E_OUTOFMEMORY;
	}

	// Copy the change information.
	pChangeObject = &i_aChangeList[i_aChangeList.size()-1];
	memcpy(pChangeObject, i_pwcoChange, sizeof(WAS_CHANGE_OBJECT));

	if (i_pwcoChange->wszPath)
	{
		cPath = wcslen(pChangeObject->wszPath);
		// The metabase cooker doesn't expect a path that ends with a '/'
		if (i_pwcoChange->wszPath[cPath-1] == L'/')
		{
			i_pwcoChange->wszPath[cPath-1] = L'\0';
		}
	}

	return S_OK; 
}

// =======================================================================
// No need to ZeroMemory after freeing the pointers because, Uninit will be 
// followed by the destruction of the array.
void CMetabaseListener::UninitChangeList(
	Array<WAS_CHANGE_OBJECT>& i_aChangeList) 
{
	ULONG		iChangeObj;		
	HRESULT		hr = S_OK;

	for (iChangeObj = 0; iChangeObj < i_aChangeList.size(); iChangeObj++)
	{
		UninitChangeObject(&i_aChangeList[iChangeObj]);
	}
}

// =======================================================================
void CMetabaseListener::UninitChangeObject(
	WAS_CHANGE_OBJECT *i_pChangeObj) 
{
	if (i_pChangeObj->wszPath != NULL)
	{
		delete [] i_pChangeObj->wszPath;
		i_pChangeObj->wszPath = NULL;
	}

	if (i_pChangeObj->pdwMDDataIDs != NULL)
	{
		delete [] i_pChangeObj->pdwMDDataIDs;
		i_pChangeObj->pdwMDDataIDs = NULL;
	}
}

// =======================================================================
HRESULT CMetabaseListener::AddChangeListToCookdownQueue(
	Array<WAS_CHANGE_OBJECT>* i_aChangeList) 
{
	// Lock the cookdown queue.
	CLock	cLock(m_seCookdownQueueLock);

	// Alloc room for a new ChangeList.
	try
	{
		m_aCookdownQueue.setSize(m_aCookdownQueue.size()+1);
	}
	catch(...)
	{
		return E_OUTOFMEMORY;
	}

	// Copy the change list.
	m_aCookdownQueue[m_aCookdownQueue.size()-1] = i_aChangeList;

	if (SetEvent(m_aHandles[m_eMetabaseChange]) == FALSE)
	{
		return HRESULT_FROM_WIN32(GetLastError());
	}

	
	return S_OK; 
}

// =======================================================================
UINT CMetabaseListener::CookdownQueueThreadStart(LPVOID i_lpParam)
{
	CMetabaseListener *pMBListener = (CMetabaseListener*)i_lpParam;
	HRESULT		hr = S_OK;

	// This thread will make COM calls. 
	hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	if (FAILED(hr))
	{
		TRACE(L"[CMetabaseListener::CookdownQueueThreadStart] Call to CoInitializeEx failed with hr = %08x\n", hr);
		return hr;
	}

	ASSERT(pMBListener != NULL);

	hr = pMBListener->Main();
	if (FAILED(hr))
	{
		TRACE(L"[CMetabaseListener::CookdownQueueThreadStart] Call to CMetabaseListener::Main failed with hr = %08x\n", hr);
	}

	CoUninitialize();
	return hr;
}

// =======================================================================
HRESULT CMetabaseListener::Main()
{
	DWORD		dwWait;
	BOOL		fDone = FALSE;
	BOOL		fCookdownQueueEmpty = FALSE;
	Array<WAS_CHANGE_OBJECT> aChangeList;
	HRESULT		hr = S_OK;

	while (!fDone)
	{
		// Sleep until a change happens or until the consumer is done.
		dwWait = WaitForMultipleObjects(m_eMetabaseChange+1, m_aHandles, FALSE, INFINITE);
		// If all consumers are done, leave.
		if (dwWait == WAIT_OBJECT_0 + m_eDone)
		{
			fDone = TRUE;
		}
		// A change happened. 
		else if (dwWait == WAIT_OBJECT_0 + m_eMetabaseChange)
		{
			// Wait for more changes to accumulate. This is usefull because
			// 1 - If a site is in the process of being created, we don't want to 
			//		execute incremental cookdown for each property they set.
			// 2 - If we cookdown too soon, i.e., in the middle of a site being created,
			//		the site may seem to be in an inconsistent state. Cookdown would complain
			//		unnecessarily.

			Sleep(m_dwLatency);

			hr = CondenseChanges(&aChangeList);
			if (FAILED(hr))
			{
				fDone = TRUE;
				TRACE(L"[CMetabaseListener::Main] Call to CondenseChanges failed with hr = %08x\n", hr);
			}
			else if (aChangeList.size() > 0)
			{

				// Call  the incremental cookdown method.
				CookDownIncrementalInternal(&aChangeList[0], aChangeList.size());

				// Even if incremental cookdown fails, we'll continue listening to changes.
				// The failure will be logged by the Cooker.

			}

			// Clean up the change list.
			UninitChangeList(aChangeList);
			aChangeList.reset();

		}
		else
		{
			ASSERT(dwWait == WAIT_FAILED);
			hr = HRESULT_FROM_WIN32(GetLastError());
			fDone = TRUE;
		}
	}

	// The consumer is done.
	return hr;
}


// =======================================================================
//	If I have multiple changes on the same Site, App, or AppPool, combine
// them to a single change, so that incremental cookdown is called less
// frequently and the metabase is not blocked for too long.
// =======================================================================
HRESULT CMetabaseListener::CondenseChanges(
	Array<WAS_CHANGE_OBJECT> *paChangeList)
{
	WAS_CHANGE_OBJECT *pLastObj = NULL;
	WAS_CHANGE_OBJECT *pQueueObj = NULL;
	DWORD		*pdwTempDataIDs = NULL;
	DWORD		i = 0;
	DWORD		j = 0;
	HRESULT		hr = S_OK;

	// Lock the cookdown queue.
	CLock	cLock(m_seCookdownQueueLock);

	// Make sure the change list is empty.
	ASSERT(0 == paChangeList->size());

	for (i = 0; i < m_aCookdownQueue.size(); i++)
	{
		for (j = 0; j < m_aCookdownQueue[i]->size(); j++)
		{
			pQueueObj = &((*m_aCookdownQueue[i])[j]);

			// If this is not the first change we are processing,
			// there is chance to 
			if (paChangeList->size() > 0)
			{
				pLastObj = &(*paChangeList)[paChangeList->size()-1];

				// If the item we are processing has the same path, table type, 
				// change type, and siteid as the last item we added to paChangeList
				// we can optimze in two ways.

				if ((pLastObj->dwWASTableType == pQueueObj->dwWASTableType) &&
					(pLastObj->dwMDChangeType == pQueueObj->dwMDChangeType) &&
					(pLastObj->iVirtualSiteID == pQueueObj->iVirtualSiteID) &&
					(NULL != pLastObj->wszPath) &&
					(NULL != pQueueObj->wszPath) &&
					(0 == wcscmp(pLastObj->wszPath, pQueueObj->wszPath)))
				{

					// If this item has a property id list, we can merge it with the
					// last processed item.

					if (pQueueObj->dwMDNumDataIDs > 0)
					{
						ASSERT(pdwTempDataIDs == NULL);
						pdwTempDataIDs = new DWORD [pQueueObj->dwMDNumDataIDs + pLastObj->dwMDNumDataIDs];
						if (NULL == pdwTempDataIDs)
						{
							return E_OUTOFMEMORY;
						}

						// Copy both the old and new ids to the new buffer.
						memcpy(pdwTempDataIDs, pLastObj->pdwMDDataIDs, sizeof(DWORD) * pLastObj->dwMDNumDataIDs);
						memcpy(pdwTempDataIDs + pLastObj->dwMDNumDataIDs, pQueueObj->pdwMDDataIDs, sizeof(DWORD) * pQueueObj->dwMDNumDataIDs);

						// Update the pointers and counts of the updated entry.
						delete [] pLastObj->pdwMDDataIDs;
						pLastObj->pdwMDDataIDs = pdwTempDataIDs;
						pLastObj->dwMDNumDataIDs += pQueueObj->dwMDNumDataIDs;

						pdwTempDataIDs = NULL;
					}

					// else we can ignore this change object, since the previous entry will cause the necessary cookdown.

					// We have processed the change object in the queue, we won't need it anymore.
					UninitChangeObject(pQueueObj);

					continue;
				}
			}

			// If we get here, either
			// this is the first processed change object or
			// a different change object:
			// We need to add it to the list.

			hr = AddChangeObjectToList(pQueueObj, *paChangeList);
			if (FAILED(hr))
			{
				return hr;
			}
		}
	}

	// All changes in the CookdownQueue have been processed. They can be cleaned up.
	for (i = 0; i < m_aCookdownQueue.size(); i++)
	{
		delete m_aCookdownQueue[i];
		m_aCookdownQueue[i] = NULL;
	}
	m_aCookdownQueue.reset();

	return hr;
}


// =======================================================================
// A utility method that will copy the first node in the i_szSource string
// into o_szNext, and return how long the string is in o_pcbNext.
// @TODO: It would make more sense for this to be in a utility file/class.
// =======================================================================
void CMetabaseListener::GetNextNode(
	LPCWSTR		i_szSource,
	LPWSTR		o_szNext,
	ULONG		*o_pcbNext)
{
	// Caller has to make sure all pointers are valid.
	ASSERT(i_szSource);
	ASSERT(o_szNext);
	ASSERT(o_pcbNext);

	// i_szSource has to point to a forwatd slash or at the end of the string.
	ASSERT((*i_szSource == L'/') || (*i_szSource == L'\0'));

	// Init the node string length.
	*o_pcbNext = 0;

	if (*i_szSource == L'/')
	{
		// Move past the '/'.
		i_szSource++;
		++(*o_pcbNext);
		
		// Copy the node into the provided buffer.
		while (*i_szSource != L'/' && *i_szSource != NULL)
		{
			*o_szNext = *i_szSource;
			o_szNext++;
			i_szSource++;
			++(*o_pcbNext);
		}
	}

	// Terminate the new string with a NULL.
	*o_szNext = L'\0';

	ASSERT(*o_pcbNext <= MAX_PATH);
	return;
}

// ========================================================================
// This method will initialize the property lists that this object is going
// to listen to.
// Given the dispenser, it gets the property ids from the column meta table.
// It also adds any additional, hardcoded properties to the list.
// Any memory allocations made for the data members will be cleaned in the
// destructor.
// ========================================================================
HRESULT CMetabaseListener::InitPropertyIDs(
	WASTABLETYPE i_wttTable,
	ISimpleTableDispenser2	*i_pISTDisp,
	LPCWSTR		i_wszTableName,
	DWORD		*i_pdwAdditionalIDs,
	ULONG		i_cAdditionalIDs)
{
	ISimpleTableRead2 *pISTColumnMeta = NULL;
	static ULONG aiColumns[]	= {iCOLUMNMETA_ID, iCOLUMNMETA_SchemaGeneratorFlags};
	static ULONG cColumns = sizeof(aiColumns)/sizeof(aiColumns[0]);
	tCOLUMNMETARow sColumnMetaRow;
	ULONG		iID = 0;
	ULONG		iRow = 0;
	HRESULT		hr = S_OK;
	STQueryCell	qCells[] = 
	{
		{(LPVOID)i_wszTableName, eST_OP_EQUAL, iCOLUMNMETA_Table, DBTYPE_WSTR, 0}
	};
	ULONG		cCells = sizeof(qCells)/sizeof(STQueryCell);

	ASSERT(m_mmIDs[i_wttTable].cIDs == 0);
	ASSERT(m_mmIDs[i_wttTable].pdwIDs == NULL);
	ASSERT(i_pISTDisp != NULL);
	ASSERT(i_wszTableName != NULL);
	ASSERT(i_cAdditionalIDs == 0 || i_pdwAdditionalIDs != NULL); 

	// Get the ColumnMeta table to get the IDs from.
	hr = i_pISTDisp->GetTable(wszDATABASE_META, wszTABLE_COLUMNMETA, (LPVOID) &qCells, 
							 (LPVOID) &cCells, eST_QUERYFORMAT_CELLS, 0, (LPVOID*) &pISTColumnMeta);
	if (FAILED(hr)) 
	{
		TRACE(L"[CMetabaseListener::InitPropertyIDs] Call to GetTable failed with hr = %08x\n", hr);
		goto Cleanup;
	}

	// Figure out how many property ids we will get from this meta table.
	hr = pISTColumnMeta->GetTableMeta(NULL, NULL, &m_mmIDs[i_wttTable].cIDs, NULL);
	if (FAILED(hr)) 
	{
		TRACE(L"[CMetabaseListener::InitPropertyIDs] Call to GetColumnMeta failed with hr = %08x\n", hr);
		goto Cleanup;
	}

	// Add the additional properties as well.
	m_mmIDs[i_wttTable].cIDs += i_cAdditionalIDs;

	ASSERT(m_mmIDs[i_wttTable].cIDs > 0);
	// Allocate room for all property ids.
	m_mmIDs[i_wttTable].pdwIDs = new DWORD[m_mmIDs[i_wttTable].cIDs]; 
	if (m_mmIDs[i_wttTable].pdwIDs == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Cleanup;
	}

	// Add the property ids.
	// First the additional ones, if there are any.
	for (iID = 0; iID < i_cAdditionalIDs; iID++)
	{
		// Add to the property list.
		m_mmIDs[i_wttTable].pdwIDs[iID] = i_pdwAdditionalIDs[iID];
	}

	ZeroMemory(&sColumnMetaRow, sizeof(tCOLUMNMETARow));
	// Next add the ones from schema.
	while ((hr = pISTColumnMeta->GetColumnValues(iRow++, cColumns, aiColumns, NULL, (LPVOID*)&sColumnMetaRow)) == S_OK)
	{
		// Is this a property that needs to be listened to?
		if (sColumnMetaRow.pSchemaGeneratorFlags && (*sColumnMetaRow.pSchemaGeneratorFlags & fCOLUMNMETA_WAS_NOTIFICATION))
		{
			// Add to the property list.
			m_mmIDs[i_wttTable].pdwIDs[iID++] = *sColumnMetaRow.pID;
		}
		ZeroMemory(&sColumnMetaRow, sizeof(tCOLUMNMETARow));
	}

	if (E_ST_NOMOREROWS == hr)
	{
		ASSERT(iID <= m_mmIDs[i_wttTable].cIDs);
		m_mmIDs[i_wttTable].cIDs = iID; // Fix the property id count since not all properties are listened to.
		hr = S_OK;
	}
	else
	{
		TRACE(L"[CMetabaseListener::InitPropertyIDs] Call to GetColumnValues failed with hr = %08x\n", hr);
		goto Cleanup;
	}

Cleanup:

	if (pISTColumnMeta)
	{
		pISTColumnMeta->Release();
	}
	return hr;
}

// ========================================================================
// This property will indicate that WAS is shutting down.
// ========================================================================
HRESULT CMetabaseListener::SetFinalPropertyID()
{
    HRESULT     hr = S_OK;

	// Allocate room for all property ids.
	m_mmIDs[wttFINAL].pdwIDs = new DWORD[1]; 
	if (m_mmIDs[wttFINAL].pdwIDs == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Cleanup;
	}

	m_mmIDs[wttFINAL].pdwIDs[0] = 9987;
	m_mmIDs[wttFINAL].cIDs = 1;

Cleanup:
	return hr;
}

// ========================================================================
// Get the cookdown latency from the metabase to override the default. This
// value can be increased to decrease the impact of incremental cookdowns. 
// It can be decreased to increase the responsiveness of WAS to metabase
// changes.
// We don't care if this fails, therefore we won't return any failures.
// ========================================================================
void CMetabaseListener::GetCookdownLatency(
	DWORD		*o_pdwCookdownLatency)
{
	IMSAdminBase *pIMSAdminBase = NULL;
	DWORD		dwCookdownLatency = 0;
	METADATA_RECORD mdr;
	DWORD		dwRealSize = 0;
	HRESULT		hr = S_OK;

	hr = CoCreateInstance(CLSID_MSAdminBase,           // CLSID
                          NULL,                        // controlling unknown
                          CLSCTX_SERVER,               // desired context
                          IID_IMSAdminBase,            // IID
                          (void**)&pIMSAdminBase);     // returned interface
	if(FAILED(hr))
	{
		goto Cleanup;
	}

	// Get the latency from the metabase if it is there.
	mdr.dwMDIdentifier	= MD_WAS_COOKDOWN_LATENCY;
	mdr.dwMDDataLen		= sizeof(ULONG);
	mdr.pbMDData		= (BYTE *)&dwCookdownLatency;
	mdr.dwMDAttributes	= METADATA_NO_ATTRIBUTES;
	mdr.dwMDDataType	= DWORD_METADATA;

	hr = pIMSAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, g_wszLATENCY, &mdr, &dwRealSize);
	if (SUCCEEDED(hr))
	{
		*o_pdwCookdownLatency = dwCookdownLatency;
	}

Cleanup:

	if (pIMSAdminBase)
	{
		pIMSAdminBase->Release();
	}

	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\cat2mof\cat2mof.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    main.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/27/2000		Initial Release

Revision History:

--**************************************************************************/
#include "generator.h"
#include <initguid.h>

HMODULE g_hModule = 0;                  // Module handle, needed for catalog

// Debugging stuff
// {D3B7C685-16E4-4b26-9FD7-C047199C4A60}
DEFINE_GUID(Cat2MofGuid, 
0xd3b7c685, 0x16e4, 0x4b26, 0x9f, 0xd7, 0xc0, 0x47, 0x19, 0x9c, 0x4a, 0x60);
DECLARE_DEBUG_PRINTS_OBJECT();

class CDebugInit
{
public:
    CDebugInit(LPCSTR szProd, const GUID* pGuid)
    {
        CREATE_DEBUG_PRINT_OBJECT(szProd, *pGuid);
    }
    ~CDebugInit()
    {
        DELETE_DEBUG_PRINT_OBJECT();
    }
};

extern "C" 
int __cdecl wmain( int argc, wchar_t *argv[])
{
	CDebugInit dbgInit("Cat2Mof", &Cat2MofGuid);
	CMofGenerator mofGen;
	bool fSuccess = mofGen.ParseCmdLine (argc, argv);
	if (!fSuccess)
	{
		mofGen.PrintUsage ();
		return -1;
	}

	HRESULT hr = mofGen.GenerateIt ();
	if (FAILED (hr))
	{
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\samples\configviewer\cfgfiledialog.cs ===
namespace Microsoft.Configuration.Samples
{
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.WinForms;
using System.Configuration;

using Microsoft.Configuration.Samples;

/// <summary>
///    Summary description for CfgFileDialog.
/// </summary>
public class CfgFileDialog : System.WinForms.Form
{
    /// <summary> 
    ///    Required designer variable
    /// </summary>
    private System.ComponentModel.Container components;
	private System.WinForms.Button btnClose;
	private System.WinForms.Button btnEditFile;
	private System.WinForms.Button btnShow;
	private System.WinForms.Panel panel1;
	
	private System.WinForms.ListBox listBox1;
	
	private System.WinForms.Label label1;
	
    private ConfigViewerSample parent;

    public CfgFileDialog(String selector, ConfigViewerSample parent)
    {
        //
        // Required for Win Form Designer support
        //
        InitializeComponent();

        //
        // TODO: Add any constructor code after InitializeComponent call
        //
        this.parent=parent;
        label1.Text=selector;

        try {
            IConfigCollection files = ConfigManager.Get(ConfigViewerSample.ctConfigFileHierarchy, selector);
            foreach (IConfigItem file in files) {
                listBox1.Items.Add((String) file["ConfigFilePath"]);
            }
        }
        catch (Exception ex) {
            listBox1.Items.Add(ex.Message);
        }

    }

    /// <summary>
    ///    Clean up any resources being used
    /// </summary>
    public override void Dispose()
    {
        base.Dispose();
        components.Dispose();
    }

    /// <summary>
    ///    Required method for Designer support - do not modify
    ///    the contents of this method with the code editor
    /// </summary>
    private void InitializeComponent()
	{
		this.components = new System.ComponentModel.Container();
		this.listBox1 = new System.WinForms.ListBox();
		this.label1 = new System.WinForms.Label();
		this.btnClose = new System.WinForms.Button();
		this.panel1 = new System.WinForms.Panel();
		this.btnEditFile = new System.WinForms.Button();
		this.btnShow = new System.WinForms.Button();
		
		listBox1.Location = new System.Drawing.Point(10, 26);
		listBox1.Size = new System.Drawing.Size(332, 82);
		listBox1.Dock = System.WinForms.DockStyle.Fill;
		listBox1.TabIndex = 6;
		listBox1.DoubleClick += new System.EventHandler(listBox1_DoubleClick);
		
		label1.Location = new System.Drawing.Point(10, 10);
		label1.Text = "Selector";
		label1.Size = new System.Drawing.Size(332, 16);
		label1.Dock = System.WinForms.DockStyle.Top;
		label1.TabIndex = 1;
		label1.Click += new System.EventHandler(label1_Click);
		
		btnClose.Location = new System.Drawing.Point(256, 8);
		btnClose.Size = new System.Drawing.Size(75, 23);
		btnClose.TabIndex = 4;
		btnClose.Anchor = System.WinForms.AnchorStyles.BottomRight;
		btnClose.Text = "&Close";
		btnClose.Click += new System.EventHandler(btnClose_Click);
		
		panel1.Dock = System.WinForms.DockStyle.Bottom;
		panel1.Location = new System.Drawing.Point(10, 110);
		panel1.Size = new System.Drawing.Size(332, 32);
		panel1.TabIndex = 7;
		panel1.Text = "panel1";
		panel1.DockPadding.All = 10;
		
		this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
		this.Text = "Configuration File Hierarchy";
		this.MaximizeBox = false;
		//@design this.TrayLargeIcon = true;
		this.BorderStyle = System.WinForms.FormBorderStyle.SizableToolWindow;
		//@design this.TrayHeight = 0;
		this.MinimizeBox = false;
		this.ClientSize = new System.Drawing.Size(352, 152);
		this.DockPadding.All = 10;
		
		btnEditFile.Location = new System.Drawing.Point(88, 8);
		btnEditFile.Size = new System.Drawing.Size(75, 23);
		btnEditFile.TabIndex = 3;
		btnEditFile.Anchor = System.WinForms.AnchorStyles.BottomLeft;
		btnEditFile.Text = "&Edit File";
		btnEditFile.Click += new System.EventHandler(btnEditFile_Click);
		
		btnShow.Location = new System.Drawing.Point(0, 8);
		btnShow.Size = new System.Drawing.Size(75, 23);
		btnShow.TabIndex = 2;
		btnShow.Anchor = System.WinForms.AnchorStyles.BottomLeft;
		btnShow.Text = "&Show";
		btnShow.Click += new System.EventHandler(btnShow_Click);
		
		this.Controls.Add(panel1);
		this.Controls.Add(label1);
		this.Controls.Add(listBox1);
		panel1.Controls.Add(btnShow);
		panel1.Controls.Add(btnEditFile);
		panel1.Controls.Add(btnClose);
		
	}
	
	protected void listBox1_DoubleClick(object sender, System.EventArgs e)
	{
        btnShow_Click(sender, e);		
	}
	protected void btnEditFile_Click(object sender, System.EventArgs e)
	{
        if (listBox1.SelectedItem!=null) {
            if (Win32Native.ShellExecute(0, "edit", (String )listBox1.SelectedItem, "", "", 5)<32) {
                Win32Native.ShellExecute(0, null, (String) listBox1.SelectedItem, "", "", 5);
            }
        }
	}
	protected void btnClose_Click(object sender, System.EventArgs e)
	{
        this.Close();
	}
	protected void btnShow_Click(object sender, System.EventArgs e)
	{
        parent.SetSelector((String) listBox1.SelectedItem);
	}
	protected void label1_Click(object sender, System.EventArgs e)
	{
        parent.SetSelector(label1.Text);
	}
	
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\samples\mtest\mtest.cs ===
using System;
using System.Configuration;
using System.Configuration.Schema;
using System.Configuration.Interceptors;
using System.Configuration.Core;
using Microsoft.Configuration.Samples;

using System.Threading;

namespace Microsoft.Configuration {

class ManagedTest {
	public static int Main(String[] args)
	{

		System.Configuration.Web.Assembly a = null; // BUGBUG: need this so that System.Configuration.Objects.dll is found
        a=new System.Configuration.Web.Assembly(); // get rid of the warning...

		Boolean bFullPropertyMeta=false;
		Boolean bShowPropertyNames=true;

        IConfigCollection props = null;
        IConfigCollection collection = null;
        IConfigCollection propmeta = null;

		String configtype="AppDomain";
		String url ="file://" + new LocalMachineSelector().Argument;

        for (int i=0; i<args.Length; i++) {
            if (args[i].StartsWith("/") || args[i].StartsWith("-"))
            {
                String arg=args[i].Substring(1).ToLower();

                if ("?"==arg) {
                    Console.WriteLine("Usage: mtest [<configtype>] [<prefix>:<selector>] [/nometa] [/meta] [/?]");
                    Console.WriteLine("  <configtype>        - the config type for which data is to be shown. Default: AppDomain");
                    Console.WriteLine("  <prefix>:<selector> - a selector string, i.e. file://c:\\foo.cfg. Default: <machinecfgdir>\\config.cfg");
                    Console.WriteLine("  :                   - use no selector at all.");
                    Console.WriteLine("  /nometa             - don't show property names, only values");
                    Console.WriteLine("  /meta               - show all schema information for each property");
                    return 0;
                }
                if ("meta"==arg) {
			        bFullPropertyMeta=true;
                }
                if ("nometa"==arg) {
                    bShowPropertyNames=false;
                    bFullPropertyMeta=false;
                }
            }
            else if (args[i].IndexOf(':')<0) {
                configtype=args[i];
            }
            else
            {
                if (args[i].Equals(":"))
                {
                    url="";
                }
                else
                {
                    url=args[i];
                }
            }
        }

/*
    // strongly typed version...
		IISProcessModel pm = (IISProcessModel) ConfigManager.GetItem("iisprocessmodel", "file://c:\\urt\\config\\src\\test\\xsp\\config.web", 0);

		Console.WriteLine(pm.enable);
		Console.WriteLine(pm.timeout);
		Console.WriteLine(pm.idletimeout);
		Console.WriteLine(pm.shutdowntimeout);
		Console.WriteLine(pm.requestlimit);
		Console.WriteLine(pm.memorylimit);
		Console.WriteLine(pm.cpumask);
		Console.WriteLine(pm.usecpuaffinity);
*/
		
        // Read the data
        collection = ConfigManager.Get(configtype, url, 0);

        if (bShowPropertyNames) {
            // Read the schema: to be able to show the property names
		    ConfigQuery q = new ConfigQuery("select * from Property where Table="+ConfigSchema.ConfigTypeSchema(configtype).InternalName);

		    props = ConfigManager.Get("Property", q, 0);
        
            // Read the meta schema for properties: to be able to show the names of the schema information
            if (bFullPropertyMeta) {
                ConfigQuery qmetameta = new ConfigQuery("select * from Property where Table=COLUMNMETA");
		        //qmetameta.Add(0, QueryCellOp.Equal, "COLUMNMETA");
		        propmeta = ConfigManager.Get("Property", qmetameta, 0);
            }
        }

		for (int k=0; k<collection.Count; k++)
		{
			IConfigItem item = collection[k];
            if (bFullPropertyMeta) {
                // Write the type of each item
                Console.WriteLine("Type: " + item.ToString());
            }
            for (int i=0; i<item.Count; i++)
			{
                if (bShowPropertyNames) {
                    // Write the property name
                    Console.Write(props[i]["PublicName"] + ": ");
                }

                // Write the property value
                Console.WriteLine(item[i]);

				if (bFullPropertyMeta)
				{
                    // Write the schema information for the property
					Console.WriteLine("[");
					for (int j=0; j<props[i].Count; j++)
					{
                        // Write the name of the meta property
						Console.Write("    "+propmeta[j]["PublicName"]);

                        // Write the value of the meta property
						Console.Write("="+props[i][j]);
						Console.WriteLine();
					}
					Console.WriteLine("]");
				}
			}
		}

		return 0;
	}
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assocapplication.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assocapplication.h

$Header: $

Abstract:
	CAssocApplication class

Author:
    marcelv 	1/18/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __ASSOCAPPLICATION_H__
#define __ASSOCAPPLICATION_H__

#pragma once

#include "assocbase.h"
#include "associationhelper.h"
#include "cfgquery.h"

class CAssocApplication : public CAssocBase
{
public:
	CAssocApplication ();
	virtual ~CAssocApplication ();

	virtual HRESULT CreateAssocations ();
private:
	CAssocApplication (const CAssocApplication& );
	CAssocApplication& operator= (const CAssocApplication&);

	HRESULT GetAssocType ();
	HRESULT CreateApplicationToConfigAssocs ();

	bool m_fMergedView;		// merged view assocation or not
	bool m_fIsShellApp;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\samples\webhierarchyinterceptor\iisadminhelper.cs ===
namespace Microsoft.Configuration.Samples {

using System;
using System.IO;
using System.Collections;
using System.Configuration.Internal;
using System.DirectoryServices;
using System.Web;

using System.Diagnostics;

/// <summary>
///    <para>
///       This class facilitates access to the IIS Metabase
///    </para>
/// </summary>
public class IISAdminHelper {

    /// <summary>
    ///    <para>
    ///      Returns the SiteID for a URL
    ///    </para>
    /// </summary>
    public static int GetSiteIDForUrl(String Url) {
        // TODO: Look up ServerBindings to get other than the default Site
        return 1; 
    }

    private static String GetMBPathForUrl(String Url) {
        String MBPath = GetMBRootForUrl(Url);
        String relUrl= new HttpUrl(Url).Path;
        if (relUrl!="/") {
            MBPath=MBPath+relUrl;
        }
        return MBPath;
    }
    private static String GetMBRootForUrl(String Url) {
        String MBRoot = "IIS://LocalHost/W3SVC/"+GetSiteIDForUrl(Url)+"/ROOT";
        return MBRoot;
    }


    /// <summary>
    ///    <para>
    ///      Returns the physical path for a URL based on IIS metabase configuration
    ///    </para>
    /// </summary>
    public static String GetPathForUrl(String Url) {
        String relUrl= new HttpUrl(Url).Path;
        String relPath="";
        String LastVDIR = null;
        int lastPathElement = 0;

        String MBRootPath = GetMBRootForUrl(Url);

        DirectoryEntry d = new DirectoryEntry();

        while (true) {

            d.Path=MBRootPath;
            if (relUrl!="/") d.Path=d.Path+relUrl;

            LastVDIR = null;
            try {
                LastVDIR = (String) d.Properties["Path"].Value;
            }
            catch {
                LastVDIR= null;
            }

            if (LastVDIR != null) {
                if (LastVDIR.EndsWith("\\")) {
                    return LastVDIR + relPath.Substring(1);
                }
                return LastVDIR + relPath;
            }

            lastPathElement=relUrl.LastIndexOf('/');
            if (lastPathElement>=0) {
                relPath="\\"+relUrl.Substring(lastPathElement+1)+relPath;
                relUrl=relUrl.Substring(0,lastPathElement);
            }
            else
            {
                throw(new ApplicationException("No physical directory defined for Url " + Url));
            }
        } 
    }

    /// <summary>
    ///    <para>
    ///      Returns the machince configuration file, the physical paths for all parent nodes of a Url and the URL itself
    ///    </para>
    /// </summary>
    public static String[] GetParentPathsForUrl(String Url) {

        String[] parentUrls = GetParentUrlsForUrl(Url);

        String[] parentPaths = new String[parentUrls.Length];

        for (int i=0; i<parentUrls.Length; i++) {
            parentPaths[i]=GetPathForUrl(parentUrls[i]);
        }
        return parentPaths;
    }

    /// <summary>
    ///    <para>
    ///      Returns the parent URLs for a URL.
    ///    </para>
    ///    <example>
    ///      Example:
    ///        GetParentUrlsForUrl("http://foo/bar/zee"), returns an array containing "http://foo", "http://foo/bar", "http://foo/bar/zee".
    ///    </example>
    /// </summary>
    public static String[] GetParentUrlsForUrl(String Url) {
        int i=0;
        HttpUrl parsedUrl = null;
        HttpUrl nextUrl = null;
        String pathToParse=null;
        String pathEaten="";
        int firstPathElement=0;

        // TODO make this work for arbitrary URLs...
        String[] Urls = new String[100];

        parsedUrl = new HttpUrl(Url);
        pathToParse = parsedUrl.Path;

        i=0;

        //pathToParse=pathToParse.Substring(1); // skip initial "/"
        nextUrl = new HttpUrl(parsedUrl.Protocol, parsedUrl.Host, parsedUrl.Port, pathEaten, null, null);
        Urls[i]=nextUrl.ToString();
        i++;

        if (pathToParse!="/") {
            while (pathToParse!=null) {

                firstPathElement=pathToParse.IndexOf('/',1);
                Trace.WriteLine(":"+pathToParse+":"+pathEaten+":"+firstPathElement);
                if (firstPathElement>=0) {
                    pathEaten=pathEaten+pathToParse.Substring(0, firstPathElement);
                    pathToParse=pathToParse.Substring(firstPathElement);
                }
                else
                {
                    pathEaten=pathEaten+pathToParse;
                    pathToParse=null;
                }
                nextUrl = new HttpUrl(parsedUrl.Protocol, parsedUrl.Host, parsedUrl.Port, pathEaten, null, null);
                Urls[i]=nextUrl.ToString();
                i++;
            }
        }

        String[] urlresult = new String[i];
        for (int j=0; j<i; j++) {
            urlresult[j]=Urls[j];
        }
        return urlresult;
    }

    public static String[] GetChildrenForUrl(String Url) {
        String MBRootPath = GetMBPathForUrl(Url);
        String childpath = null;
        ArrayList children = new ArrayList();
   

        Directory dir = new Directory(IISAdminHelper.GetPathForUrl(Url));
        Directory[] childdirs=dir.GetDirectories();
        foreach (Directory childdir in childdirs) {
            children.Add(childdir.Name);
        }

        DirectoryEntry mb = new DirectoryEntry();

        try {
            mb.Path=MBRootPath;
            foreach (DirectoryEntry child in mb.Children) {
                childpath=child.Path;
                childpath=childpath.Substring(childpath.LastIndexOf("/")+1);
                if (!children.Contains(childpath)) {
                    children.Add(childpath);
                }
            }
        }
        catch {
            // ignore MB failures
            // BUGBUG need to ignore invalid path only!
        }
        String[] childarray = new String[children.Count];
        children.CopyTo(childarray);
        return childarray;
    }


}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\samples\webhierarchyinterceptor\webhierarchyinterceptor.cs ===
namespace Microsoft.Configuration.Samples {

using System;
using System.Configuration;
using System.Configuration.Interceptors;
using System.Configuration.Internal;
using System.DirectoryServices;
using System.Web;
using System.Diagnostics;

using Microsoft.Configuration.Samples;

/// <summary>
///    <para>
///       This class facilitates access to the IIS Metabase
///    </para>
/// </summary>
public class WebHierarchyInterceptor : IConfigTransformer {

    public RequestParams Transform(String configType, Selector selector, int los){

            HttpFileSelector urlunc = null;

            RequestParams reqparam = new RequestParams();
			reqparam.configType = configType;
			reqparam.selector   = new ListSelector();
			reqparam.los		= los;

            String url = ((HttpSelector)selector).ToString();

            String[] Urls = IISAdminHelper.GetParentUrlsForUrl(url);
            String[] UNCs = IISAdminHelper.GetParentPathsForUrl(url);
            
            // Add the machine config file location
            String machinecfg = "file://" + new LocalMachineSelector().Argument;
            // Trim off "\config\machine.cfg" part
            machinecfg=machinecfg.Substring(0,machinecfg.LastIndexOf('\\'));
            machinecfg=machinecfg.Substring(0,machinecfg.LastIndexOf('\\'));
            machinecfg=machinecfg+"\\config.web";

            urlunc = new HttpFileSelector(
                            new HttpSelector(Urls[0]), 
                            new FileSelector(machinecfg));

		    Trace.WriteLine("Adding: "+urlunc);
			((ListSelector)(reqparam.selector)).Add(urlunc);

            for (int i=0; i<Urls.Length; i++) {
                urlunc = new HttpFileSelector(new HttpSelector(Urls[i]), new FileSelector("file://"+UNCs[i]+"\\config.web"));
			    Trace.WriteLine("Adding: "+urlunc);
			    ((ListSelector)(reqparam.selector)).Add(urlunc);
            }

			return reqparam;

		} // Transform

	} // class Hierarchy Interceptor
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\cat2mof\generator.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    generator.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/27/2000		Initial Release

Revision History:

--**************************************************************************/

#include "generator.h"
#include "catmeta.h"
#include <stdlib.h>

static WCHAR g_wszNetFrameworks[] = L"NetFrameworkv1";
static WCHAR g_wszNetFrameworksProvider[] = L"NetFrameworkv1Provider";
static WCHAR g_wszSelector[]	  = L"Selector";

int __cdecl 
CompDBNames (const void * pDBMetaLHS, const void * pDBMetaRHS)
{
	const tDATABASEMETARow *pLHS = static_cast<const tDATABASEMETARow *> (pDBMetaLHS );
	const tDATABASEMETARow *pRHS = static_cast<const tDATABASEMETARow *> (pDBMetaRHS );

	return _wcsicmp (pLHS->pInternalName, pRHS->pInternalName);
}

int __cdecl 
CompTableMeta (const void * pTableMetaLHS, const void * pTableMetaRHS)
{
	const CTableMeta *pLHS = static_cast<const CTableMeta *> (pTableMetaLHS );
	const CTableMeta *pRHS = static_cast<const CTableMeta *> (pTableMetaRHS );

	return _wcsicmp (pLHS->TableMeta.pInternalName, pRHS->TableMeta.pInternalName);
}

int __cdecl 
CompTableMetaPublicName (const void * pTableMetaLHS, const void * pTableMetaRHS)
{
	const CTableMeta *pLHS = static_cast<const CTableMeta *> (pTableMetaLHS );
	const CTableMeta *pRHS = static_cast<const CTableMeta *> (pTableMetaRHS );

	return _wcsicmp (pLHS->TableMeta.pPublicName, pRHS->TableMeta.pPublicName);
}

int __cdecl 
CompTableDBName (const void * pTableMetaLHS, const void * pTableMetaRHS)
{
	const CTableMeta *pLHS = static_cast<const CTableMeta *> (pTableMetaLHS );
	const CTableMeta *pRHS = static_cast<const CTableMeta *> (pTableMetaRHS );

	return _wcsicmp (pLHS->TableMeta.pDatabase, pRHS->TableMeta.pDatabase);
}

// sorted by table name and index
int __cdecl 
CompColumnMetas (const void * pColumnMetaLHS, const void * pColumnMetaRHS)
{
	const CColumnMeta *pLHS = static_cast<const CColumnMeta *> (pColumnMetaLHS );
	const CColumnMeta *pRHS = static_cast<const CColumnMeta *> (pColumnMetaRHS );

	int iCmp = _wcsicmp (pLHS->ColumnMeta.pTable, pRHS->ColumnMeta.pTable);
	if (iCmp != 0)
	{
		return iCmp;
	}

	return (*pLHS->ColumnMeta.pIndex) - (*pRHS->ColumnMeta.pIndex);
}

// sorted by table name and index
int __cdecl 
CompTagMetas (const void * pTagMetaLHS, const void * pTagMetaRHS)
{
	const tTAGMETARow *pLHS = static_cast<const tTAGMETARow *> (pTagMetaLHS );
	const tTAGMETARow *pRHS = static_cast<const tTAGMETARow *> (pTagMetaRHS );

	int iCmp = _wcsicmp (pLHS->pTable, pRHS->pTable);
	if (iCmp != 0)
	{
		return iCmp;
	}

	int iResult = (*pLHS->pColumnIndex) - (*pRHS->pColumnIndex);
	if (iResult != 0)
	{
		return iResult;
	}

	return (*pLHS->pValue) - (*pRHS->pValue);
}

// sorted by table name and index
int __cdecl 
CompRelationMetas (const void * pRelationMetaLHS, const void * pRelationMetaRHS)
{
	const CRelationMeta *pLHS = static_cast<const CRelationMeta  *> (pRelationMetaLHS );
	const CRelationMeta *pRHS = static_cast<const CRelationMeta *> (pRelationMetaRHS );

	return _wcsicmp (pLHS->RelationMeta.pPrimaryTable, pRHS->RelationMeta.pPrimaryTable);
}

CMofGenerator::CMofGenerator ()
{
	m_wszOutFileName		= 0;
	m_wszTemplateFileName	= 0;
	m_wszAssocFileName		= 0;

	m_paDatabases	= 0;
	m_cNrDatabases	= 0;

	m_paTableMetas  = 0;
	m_cNrTables		= 0;

	m_paColumnMetas	= 0;
	m_cNrColumns	= 0;

	m_paTags		= 0;
	m_cNrTags		= 0;

	m_paRels		= 0;
	m_cNrRelations	= 0;

	m_fQuiet		= false;
}

CMofGenerator::~CMofGenerator()
{
	delete [] m_wszOutFileName;
	delete [] m_wszTemplateFileName; 
	delete [] m_wszAssocFileName;

	delete [] m_paDatabases;
	delete [] m_paTableMetas;
	delete [] m_paColumnMetas;
	delete [] m_paTags;
	delete [] m_paRels;
}

bool
CMofGenerator::ParseCmdLine (int argc, wchar_t **argv)
{
	m_argc = argc;
	m_argv = argv;

	for (int i=1; i<argc; ++i)
	{
		static wchar_t * wszOUT			= L"/out:";
		static wchar_t * wszTEMPLATE	= L"/template:";
		static wchar_t * wszASSOCFILE	= L"/assoc:";
		static wchar_t * wszQUIET		= L"/q";
		
		if (wcsncmp (argv[i], wszOUT, wcslen(wszOUT)) == 0)
		{
			if (m_wszOutFileName != 0)
			{
				// duplicate parameter
				return false;
			}
			m_wszOutFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszOUT) + 1];
			if (m_wszOutFileName == 0)
			{
				return false;
			}
			wcscpy (m_wszOutFileName, argv[i] + wcslen(wszOUT));
		}
		else if (wcsncmp (argv[i], wszTEMPLATE, wcslen (wszTEMPLATE)) == 0)
		{
			if (m_wszTemplateFileName != 0)
			{
				// duplicate parameter
				return false;
			}
			m_wszTemplateFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszTEMPLATE) + 1];
			if (m_wszTemplateFileName == 0)
			{
				return false;
			}
			wcscpy (m_wszTemplateFileName, argv[i] + wcslen(wszTEMPLATE));
		}
		else if (wcsncmp (argv[i], wszASSOCFILE, wcslen (wszASSOCFILE)) == 0)
		{
			if (m_wszAssocFileName != 0)
			{
				// duplicate parameter
				return false;
			}
			m_wszAssocFileName = new WCHAR [wcslen (argv[i]) - wcslen (wszASSOCFILE) + 1];
			if (m_wszAssocFileName == 0)
			{
				return false;
			}
			wcscpy (m_wszAssocFileName, argv[i] + wcslen(wszASSOCFILE));
		}
		else if (wcsncmp (argv[i], wszQUIET, wcslen (wszQUIET)) == 0)
		{
			m_fQuiet = true;
		}
	}

	// verify that we have the required parameters

	if (m_wszOutFileName == 0)
	{
		printf ("You need to specify an output file name\n");
		return false;
	}

	if (m_wszTemplateFileName == 0)
	{
		printf ("You need to specify a template file name\n");
		return false;
	}

	if (m_wszAssocFileName == 0)
	{
		printf ("You need to specify an assocation file name\n");
		return false;
	}

	return true;
}

void
CMofGenerator::PrintUsage ()
{
	PrintToScreen (L"Usage:\n%s /out:<filename> /template:<filename> /assoc:<filename>\n", m_argv[0]);
}

HRESULT
CMofGenerator::GenerateIt ()
{
	HRESULT hr = S_OK;

	hr = GetSimpleTableDispenser (g_wszNetFrameworks, 0, &m_spDispenser);
	if (FAILED (hr))
	{
		PrintToScreen (L"Unable to get table dispenser for %s\n", g_wszNetFrameworks);
		return hr;
	}

	hr = GetDatabases ();
	if (FAILED (hr))
	{
		return hr;
	}


	hr = GetTables ();
	if (FAILED (hr))
	{
		return hr;
	}

	
	hr = GetColumns ();
	if (FAILED (hr))
	{
		return hr;
	}

	hr = GetTags ();
	if (FAILED (hr))
	{
		return hr;
	}

	hr = GetRelations ();
	if (FAILED (hr))
	{
		return hr;
	}

	hr = BuildInternalStructures ();
	if (FAILED (hr))
	{
		return hr;
	}
	
	hr = WriteToFile ();
	if (FAILED (hr))
	{
		return hr;
	}

	// this involves a qsort of table names, so only do this at the end
	CheckForDuplicatePublicNames ();

	return hr;
}

HRESULT
CMofGenerator::GetDatabases ()
{
	HRESULT hr = S_OK;

	CComPtr<ISimpleTableRead2> spISTDBMeta;

	hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_DATABASEMETA,
								  0, 0, eST_QUERYFORMAT_CELLS, 0, (void **) &spISTDBMeta);
	if (FAILED (hr))
	{
		return hr;
	}

	hr = spISTDBMeta->GetTableMeta (0, 0, &m_cNrDatabases, 0);
	if (FAILED (hr))
	{
		return hr;
	}

	if (m_cNrDatabases == 0)
	{
		return E_FAIL;
	}

	m_paDatabases = new tDATABASEMETARow[m_cNrDatabases];
	if (m_paDatabases == 0)
	{
		return E_OUTOFMEMORY;
	}

	for (ULONG idx =0; idx < m_cNrDatabases; ++idx)
	{
		hr = spISTDBMeta->GetColumnValues (idx, sizeof (tDATABASEMETARow)/sizeof (ULONG *), 0, 0, (void **) &m_paDatabases[idx]);
		if (FAILED (hr))
		{
			return hr;
		}
	}

	qsort (m_paDatabases, m_cNrDatabases, sizeof (tDATABASEMETARow), CompDBNames);

	return hr;
}

HRESULT
CMofGenerator::GetTables ()
{
	HRESULT hr = S_OK;

	CComPtr<ISimpleTableRead2> spISTTableMeta;

	hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA,
								  0, 0, eST_QUERYFORMAT_CELLS, 0, (void **) &spISTTableMeta);
	if (FAILED (hr))
	{
		return hr;
	}

	hr = spISTTableMeta->GetTableMeta (0, 0, &m_cNrTables, 0);
	if (FAILED (hr))
	{
		return hr;
	}

	if (m_cNrTables == 0)
	{
		return S_OK;
	}

	m_paTableMetas = new CTableMeta [m_cNrTables];
	if (m_paTableMetas == 0)
	{
		return E_OUTOFMEMORY;
	}


	for (ULONG idx =0; idx < m_cNrTables; ++idx)
	{
		hr = spISTTableMeta->GetColumnValues (idx, sizeof (tTABLEMETARow)/sizeof (ULONG *), 0, 0, (void **) &m_paTableMetas[idx].TableMeta);
		if (FAILED (hr))
		{
			return hr;
		}


		// HACKHACKHACK to avoid duplicate public name classes, we above the ItemClass property / pConfigItemName
		// to work around this problem. This should only be used as a last resort !!!
		if (m_paTableMetas[idx].TableMeta.pConfigItemName != 0 &&
			wcscmp (m_paTableMetas[idx].TableMeta.pDatabase, WSZ_PRODUCT_NETFRAMEWORKV1) == 0)
		{
			m_paTableMetas[idx].TableMeta.pPublicName = m_paTableMetas[idx].TableMeta.pConfigItemName;
		}
	
		if (m_paTableMetas[idx].ColCount () > 0)
		{
			// set number of columns
			m_paTableMetas[idx].paColumns = new LPCColumnMeta[m_paTableMetas[idx].ColCount()];
			if (m_paTableMetas[idx].paColumns == 0)
			{
				return E_OUTOFMEMORY;
			}
		}
	}

	// and sort them by table name

	qsort (m_paTableMetas, m_cNrTables, sizeof (CTableMeta), CompTableMeta);
	return hr;
}

HRESULT
CMofGenerator::GetColumns ()
{
	HRESULT hr = S_OK;

	CComPtr<ISimpleTableRead2> spISTColumnMeta;

	hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA,
								  0, 0, eST_QUERYFORMAT_CELLS, 0, (void **) &spISTColumnMeta);
	if (FAILED (hr))
	{
		return hr;
	}

	hr = spISTColumnMeta->GetTableMeta (0, 0, &m_cNrColumns, 0);
	if (FAILED (hr))
	{
		return hr;
	}

	if (m_cNrColumns == 0)
	{
		return E_FAIL;
	}

	m_paColumnMetas = new CColumnMeta[m_cNrColumns];
	if (m_paColumnMetas == 0)
	{
		return E_OUTOFMEMORY;
	}

	for (ULONG idx =0; idx < m_cNrColumns; ++idx)
	{
		hr = spISTColumnMeta->GetColumnValues (idx, sizeof (tCOLUMNMETARow)/sizeof (ULONG *), 0, 0, (void **) &m_paColumnMetas[idx].ColumnMeta);
		if (FAILED (hr))
		{
			return hr;
		}

		if (_wcsicmp (m_paColumnMetas[idx].ColumnMeta.pPublicName, g_wszSelector) == 0)
		{
			PrintToScreen (L"!!!! ERROR: Cannot have column with public name %s !!!!\n", g_wszSelector);
			return E_FAIL;
		}
	}
	
	qsort (m_paColumnMetas, m_cNrColumns, sizeof (CColumnMeta), CompColumnMetas);
	
	return hr;
}

HRESULT
CMofGenerator::GetTags ()
{
	HRESULT hr = S_OK;

	CComPtr<ISimpleTableRead2> spISTTagMeta;

	hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_TAGMETA,
								  0, 0, eST_QUERYFORMAT_CELLS, 0, (void **) &spISTTagMeta);
	if (FAILED (hr))
	{
		return hr;
	}

	hr = spISTTagMeta->GetTableMeta (0, 0, &m_cNrTags, 0);
	if (FAILED (hr))
	{
		return hr;
	}

	if (m_cNrTags == 0)
	{
		return E_FAIL;
	}

	m_paTags = new tTAGMETARow[m_cNrTags];
	if (m_paTags == 0)
	{
		return E_OUTOFMEMORY;
	}

	for (ULONG idx =0; idx < m_cNrTags; ++idx)
	{
		hr = spISTTagMeta->GetColumnValues (idx, sizeof (tTAGMETARow)/sizeof (ULONG *), 0, 0, (void **) &m_paTags[idx]);
		if (FAILED (hr))
		{
			return hr;
		}
	}
	qsort (m_paTags, m_cNrTags, sizeof (tTAGMETARow), CompTagMetas);

	return hr;
}

HRESULT
CMofGenerator::GetRelations ()
{
	HRESULT hr = S_OK;

	CComPtr<ISimpleTableRead2> spISTRelationMeta;

	hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_RELATIONMETA,
								  0, 0, eST_QUERYFORMAT_CELLS, 0, (void **) &spISTRelationMeta);
	if (FAILED (hr))
	{
		return hr;
	}

	hr = spISTRelationMeta->GetTableMeta (0, 0, &m_cNrRelations, 0);
	if (FAILED (hr))
	{
		return hr;
	}

	if (m_cNrRelations == 0)
	{
		return S_OK;
	}

	m_paRels = new CRelationMeta[m_cNrRelations];
	if (m_paRels == 0)
	{
		return E_OUTOFMEMORY;
	}

	for (ULONG idx =0; idx < m_cNrRelations; ++idx)
	{
		hr = spISTRelationMeta->GetColumnValues (idx, sizeof (tRELATIONMETARow)/sizeof (ULONG *), 0, m_paRels[idx].paSizes, (void **) &m_paRels[idx].RelationMeta);
		if (FAILED (hr))
		{
			return hr;
		}
	}

	// sort by primary key table name

	qsort (m_paRels, m_cNrRelations, sizeof (CRelationMeta), CompRelationMetas);

	return hr;
}

HRESULT 
CMofGenerator::BuildInternalStructures ()
{
	HRESULT hr = S_OK;

	// attach the tags to the tables

	ULONG idx = 0;
	while (idx < m_cNrTags)
	{
		// find the correct column
		CColumnMeta dummyColumnMeta;
		dummyColumnMeta.ColumnMeta.pTable = m_paTags[idx].pTable;
		dummyColumnMeta.ColumnMeta.pIndex = m_paTags[idx].pColumnIndex;
		// get column
		CColumnMeta *pColMeta = (CColumnMeta *) bsearch (&dummyColumnMeta, m_paColumnMetas,
														m_cNrColumns,
						   sizeof (CColumnMeta), CompColumnMetas);

		ASSERT (pColMeta != 0);
		ASSERT (_wcsicmp (pColMeta->ColumnMeta.pTable, m_paTags[idx].pTable) == 0 &&
			    *pColMeta->ColumnMeta.pIndex == *m_paTags[idx].pColumnIndex);

		// get count
		ULONG iStartIdx = idx;
		pColMeta->cNrTags = 1;
		idx++; // skip over this element
		while ((idx < m_cNrTags) &&
			   (_wcsicmp (pColMeta->ColumnMeta.pTable, m_paTags[idx].pTable) == 0) &&
			   (*(pColMeta->ColumnMeta.pIndex) == *(m_paTags[idx].pColumnIndex)))
		{
			idx++;
			pColMeta->cNrTags += 1;
		}

		if (pColMeta->cNrTags > 0)
		{
			// allocate memory and copy the stuff
			ASSERT (pColMeta->paTags == 0);
			pColMeta->paTags = new LPtTAGMETA[pColMeta->cNrTags];
			if (pColMeta->paTags == 0)
			{
				return E_OUTOFMEMORY;
			}
			for (ULONG tagIdx = 0; tagIdx < pColMeta->cNrTags; ++tagIdx)
			{
				pColMeta->paTags[tagIdx] = &m_paTags[iStartIdx + tagIdx];
			}
		}
	}

	// attach the columns to the tables
	for (idx=0; idx < m_cNrColumns; ++idx)
	{
		CTableMeta dummyTableMeta;
		dummyTableMeta.TableMeta.pInternalName = m_paColumnMetas[idx].ColumnMeta.pTable;
		// find table
		CTableMeta *pTableMeta =  (CTableMeta *) bsearch (&dummyTableMeta, m_paTableMetas,
														m_cNrTables,
						   sizeof (CTableMeta), CompTableMeta);
		ASSERT (pTableMeta != 0);
		ASSERT (_wcsicmp (pTableMeta->TableMeta.pInternalName, m_paColumnMetas[idx].ColumnMeta.pTable) == 0);

		// add Column to table

		ULONG iColumnIndex = *(m_paColumnMetas[idx].ColumnMeta.pIndex);
		ASSERT (iColumnIndex >= 0 && iColumnIndex < pTableMeta->ColCount ());
		pTableMeta->paColumns[iColumnIndex] = &m_paColumnMetas[idx];
	}

	// attach the relations to the tables

	idx = 0;
	while (idx < m_cNrRelations)
	{
		CTableMeta dummyTableMeta;
		dummyTableMeta.TableMeta.pInternalName = m_paRels[idx].RelationMeta.pPrimaryTable;
		CTableMeta *pTableMeta = (CTableMeta *) bsearch (&dummyTableMeta, m_paTableMetas,
														m_cNrTables,
						   sizeof (CTableMeta), CompTableMeta);
		ASSERT (pTableMeta != 0);
		ASSERT (_wcsicmp (pTableMeta->TableMeta.pInternalName, m_paRels[idx].RelationMeta.pPrimaryTable) == 0);

		// get count
		ULONG iStartIdx = idx;
		pTableMeta->cNrRelations = 1;
		idx++; // skip over this element
		while ((idx < m_cNrRelations) &&
			   (_wcsicmp (pTableMeta->TableMeta.pInternalName, m_paRels[idx].RelationMeta.pPrimaryTable) == 0)) 
		{
			idx++;
			pTableMeta->cNrRelations += 1;
		}
	
		if (pTableMeta->cNrRelations > 0)
		{
			// allocate memory and copy the stuff
			pTableMeta->paRels = new LPCRelationMeta[pTableMeta->cNrRelations];
			if (pTableMeta->paRels == 0)
			{
				return E_OUTOFMEMORY;
			}
			for (ULONG relIdx = 0; relIdx < pTableMeta->cNrRelations; ++relIdx)
			{
				pTableMeta->paRels[relIdx] = &m_paRels[iStartIdx + relIdx];
			}
		}
	}

	// and attach the foreign tables to the relations

	for (idx=0; idx < m_cNrRelations; ++idx)
	{
		CTableMeta dummyTableMeta;
		dummyTableMeta.TableMeta.pInternalName = m_paRels[idx].RelationMeta.pForeignTable;
		m_paRels[idx].pForeignTableMeta = (CTableMeta *) bsearch (&dummyTableMeta, m_paTableMetas,
														m_cNrTables,
						   sizeof (CTableMeta), CompTableMeta);
		ASSERT (m_paRels[idx].pForeignTableMeta != 0);
		ASSERT (_wcsicmp (m_paRels[idx].pForeignTableMeta->TableMeta.pInternalName, m_paRels[idx].RelationMeta.pForeignTable) == 0);
		m_paRels[idx].pForeignTableMeta->fIsContained = true; // table is contained
	
	}

	return hr;
	// print table info
	for (idx =0; idx < m_cNrTables; ++idx)
	{
		PrintToScreen (L"[%s] %s (contained = %d)\n", 
				 m_paTableMetas[idx].TableMeta.pDatabase, 
				 m_paTableMetas[idx].TableMeta.pInternalName,
				 m_paTableMetas[idx].fIsContained);

		for (ULONG colidx=0; colidx < m_paTableMetas[idx].ColCount (); ++colidx)
		{
			CColumnMeta *pColMeta = m_paTableMetas[idx].paColumns[colidx];
			PrintToScreen (L"\t[%d, %s] [tags: %d]\n", 
					 *pColMeta->ColumnMeta.pIndex, 
				     pColMeta->ColumnMeta.pInternalName,
					 pColMeta->cNrTags );
			
			for (ULONG tagidx=0; tagidx < pColMeta->cNrTags ; ++tagidx)
			{
				tTAGMETARow *pTagMeta = pColMeta->paTags[tagidx];
				PrintToScreen (L"\t\t[%s, %d] %s %d\n", pTagMeta->pTable, *pTagMeta->pColumnIndex, 
				pTagMeta->pInternalName, *pTagMeta->pValue);
			}
		}
	}

	return hr;
}

HRESULT 
CMofGenerator::WriteToFile ()
{
	ASSERT (m_wszOutFileName != 0);
	HRESULT hr = S_OK;

	m_pFile = _wfopen (m_wszOutFileName, L"w+");
	if (m_pFile == 0)
	{
		PrintToScreen (L"Can't open output file: %s", m_wszOutFileName);
		return E_FAIL;
	}
		
	WriteInstanceProviderInfo ();

	hr = CopyHeader ();
	if (FAILED (hr))
	{
		return hr;
	}


	for (ULONG idx = 0; idx < m_cNrTables; ++idx)
	{
		WriteTable (m_paTableMetas [idx]);
	}

	WriteLocationAssociations ();
	hr = WriteWebAppAssociations ();
	if (FAILED (hr))
	{
		PrintToScreen (L"!!! ERROR while writing web applications !!!");
	}

	// we don't support shell apps for the moment
	// WriteShellAppAssociations ();

	fclose (m_pFile);
	return hr;
}

HRESULT
CMofGenerator::CopyHeader ()
{
	// no file, nothing to copy
	if (m_wszTemplateFileName == 0)
	{
		return S_OK;
	}

	FILE *pHeaderFile = _wfopen (m_wszTemplateFileName, L"r");
	if (pHeaderFile == 0)
	{
		PrintToScreen (L"Can't open template file %s", m_wszTemplateFileName);
		return E_FAIL;
	}

	WCHAR wszBuffer[512];

	while (fgetws (wszBuffer, 512, pHeaderFile) != 0)
	{
		fputws (wszBuffer, m_pFile);
	}
	fclose (pHeaderFile);

	return S_OK;
}

void 
CMofGenerator::WriteTable (const CTableMeta& tableMeta)
{
	if (!IsValidTable (tableMeta))
	{
		return;
	}

	// special case
	// we ignore codegroup and IMembershipCondition
	if ((_wcsicmp (tableMeta.TableMeta.pInternalName, L"codegroup") == 0) ||
		(_wcsicmp (tableMeta.TableMeta.pInternalName, L"IMembershipCondition") == 0))
	{
		return;
	}
	

	WCHAR *pDescription = tableMeta.TableMeta.pDescription;
	if (pDescription == 0)
	{
		pDescription = L"";
		PrintToScreen (L"Warning !!! Table %s doesn't have description.\n", tableMeta.TableMeta.pInternalName);
	}

	ULONG metaFlags = *tableMeta.TableMeta.pMetaFlags;

	bool fScopedByTableName			= false;
	WCHAR wszPublicRowName[250]		= L"";
	WCHAR wszChildElementName[250]	= L"";

	if (!(metaFlags & fTABLEMETA_NOTSCOPEDBYTABLENAME) && !(metaFlags & fTABLEMETA_HASDIRECTIVES))
	{
		fScopedByTableName = true;

		// some public row names have 'A' in front of them (connection, Aconnection). Need to filter these out
		LPWSTR wszPublicName	= (LPWSTR) tableMeta.TableMeta.pPublicName;
		LPWSTR pPublicRowName	= (LPWSTR) tableMeta.TableMeta.pPublicRowName;
		if ((_wcsicmp (wszPublicName, pPublicRowName) != 0) &&
			(_wcsicmp (wszPublicName, pPublicRowName + 1) != 0))
		{
			wsprintf (wszPublicRowName, L",XML_InstanceElementName (\"%s\")", tableMeta.TableMeta.pPublicRowName);
		}
	}

	LPWSTR pChildElementName = (LPWSTR) tableMeta.TableMeta.pChildElementName;

	if (pChildElementName != 0 && pChildElementName[0] != L'\0')
	{
		wsprintf (wszChildElementName, L",XML_ChildElementName(\"%s\")", tableMeta.TableMeta.pChildElementName);
	}

	WriteDeleteClass (tableMeta.TableMeta.pPublicName);

	fwprintf (m_pFile, L"//**************************************************************************\n");
	fwprintf (m_pFile, L"//* Class: %s\n", tableMeta.TableMeta.pPublicName);
	fwprintf (m_pFile, L"//**************************************************************************\n\n");
	fwprintf (m_pFile, L"[Dynamic: ToInstance, Provider(\"%s\"), DisplayName(\"%s\") : Amended, Locale(1033), "
		               L" Description(\"%s\") : Amended, Database(\"%s\"), InternalName(\"%s\") %s %s %s %s]\n",
					   g_wszNetFrameworksProvider, tableMeta.TableMeta.pPublicName, pDescription,
					   tableMeta.TableMeta.pDatabase, tableMeta.TableMeta.pInternalName,
					   tableMeta.fIsContained? L"": L",NonContained",
					   fScopedByTableName? L",XML_ScopedByElement": L"",
					   wszPublicRowName,
					   wszChildElementName);
	fwprintf (m_pFile, L"class %s : NetConfigurationClass\n{\n", tableMeta.TableMeta.pPublicName);
	
	for (ULONG idx=0; idx < tableMeta.ColCount(); ++idx)
	{
		WriteColumn (*tableMeta.paColumns[idx]);
	}

	// add the selector columnf
	fwprintf (m_pFile, L"[key, DisplayName(\"%s\"): Amended, Locale(1033), Description(\"Specifies configuration store\"):Amended] string Selector=\"config://localhost\";\n", g_wszSelector);

	fwprintf (m_pFile, L"};\n\n");
		
//	CCodeGenerator generator;
//	HRESULT hr = generator.GenerateCode (&tableMeta);

	// and write the associations
	WriteTableAssociations (tableMeta);
}

void 
CMofGenerator::WriteColumn (const CColumnMeta& colMeta)
{
	// skip columns that are marked as NONPERSITABLE and hidden columns (metaflagEx = schemagenflags)
	if ((*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE) ||
		(*colMeta.ColumnMeta.pSchemaGeneratorFlags & fCOLUMNMETA_HIDDEN))
	{
		return;
	}

	if (_wcsicmp (colMeta.ColumnMeta.pPublicName, L"class") == 0)
	{
		PrintToScreen (L"Error: WMI doesn't support properties with name 'class'. Table=%s\n",
			colMeta.ColumnMeta.pTable);
		exit (-1);
	}

	if (_wcsicmp (colMeta.ColumnMeta.pPublicName, L"ref") == 0)
	{
		PrintToScreen (L"Error: WMI doesn't support properties with name 'ref'. Table=%s\n",
			colMeta.ColumnMeta.pTable);
		exit (-1);
	}
	
	WCHAR *pDescription = colMeta.ColumnMeta.pDescription;
	if (pDescription == 0)
	{
		pDescription = L"";
		PrintToScreen (L"Warning !!! Column %s in Table %s doesn't have description.\n", colMeta.ColumnMeta.pInternalName, colMeta.ColumnMeta.pTable);
	}

	fwprintf(m_pFile, L"[DisplayName(\"%s\"): Amended, Description(\"%s\"):Amended, Locale(1033)",
		     colMeta.ColumnMeta.pPublicName, pDescription);

	if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_PRIMARYKEY)
	{
		if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING)
		{
			PrintToScreen (L"Error: WMI doesn't support multi-string primary key columns. Table=%s, Column=%s\n", 
				     colMeta.ColumnMeta.pTable, colMeta.ColumnMeta.pPublicName);
			exit (-1);
		}
		fwprintf (m_pFile, L",key");
	}

	if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_NOTNULLABLE)
	{
		fwprintf(m_pFile, L",Required");
	}

	if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_DIRECTIVE)
	{
		fwprintf(m_pFile, L",XML_IsDirective");
	}

	// metaflagsEx is store in schemageneratorflags
	if (*colMeta.ColumnMeta.pSchemaGeneratorFlags & fCOLUMNMETA_VALUEINCHILDELEMENT)
	{
		fwprintf(m_pFile, L",XML_ValueInChildElement");
	}


	
	// add qualifier for expandsz string
	if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_EXPANDSTRING)
	{
		fwprintf (m_pFile, L",ExpandSZ(\"true\")");
	}

	if (colMeta.cNrTags > 0)
	{
		fwprintf(m_pFile, L", ");
		WriteValueMap (colMeta);
	}
	else
	{
		fwprintf (m_pFile, L"]");

		switch (*colMeta.ColumnMeta.pType)
		{
			case DBTYPE_WSTR:
				if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING)
				{
					fwprintf (m_pFile, L"string %s[]", colMeta.ColumnMeta.pPublicName);
				}
				else if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_EXPANDSTRING)
				{
					fwprintf (m_pFile, L"string %s", colMeta.ColumnMeta.pPublicName);
				}
				else
				{
					fwprintf (m_pFile, L"string %s", colMeta.ColumnMeta.pPublicName);
				}
				break;
			
			case DBTYPE_UI4:
				if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_BOOL)
				{
					fwprintf (m_pFile, L"Boolean %s", colMeta.ColumnMeta.pPublicName);
				}
				else
				{
					fwprintf (m_pFile, L"uint32 %s", colMeta.ColumnMeta.pPublicName);
				}
				break;
			
			case DBTYPE_BYTES:
				fwprintf (m_pFile, L"uint8 %s[]", colMeta.ColumnMeta.pPublicName);
				break;
			
			case DBTYPE_DBTIMESTAMP:
				ASSERT (false);
				break;

			case DBTYPE_GUID:
				ASSERT (false);
				break;

			default:
				// need to handle this
				fwprintf (m_pFile, L"NEED TO HANDLE DEFAULT");
				ASSERT (false);
				break;
		}
	}

	if (colMeta.ColumnMeta.pDefaultValue != 0)
	{
		ULONG idx; 
		ULONG jdx;
		SIZE_T iLen;
		LPWSTR pDefaultValue;
		switch (*colMeta.ColumnMeta.pType)
		{
			case DBTYPE_WSTR:
			{
				pDefaultValue = (LPWSTR)colMeta.ColumnMeta.pDefaultValue;
				// need to replace '\' with "\\" else mofcomp complains
				WCHAR wszBuffer[1024];
				
				// count the number of characters that need to be copied. Need
				// to have separate cases for string and multistring
				iLen = 0;
				if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING)
				{
					for (LPWSTR pCurString = pDefaultValue;
						 *pCurString != L'\0'; 
						 pCurString += wcslen (pCurString) + 1)
						 {
							iLen += wcslen (pCurString) + 1;
						 }
					iLen++; // for last zero terminator
				}

				else
				{
					iLen = wcslen (pDefaultValue);
				}
					
				ASSERT (iLen*2<1024);

				// convert the single backslash to double backslash
				jdx = 0;
				for (idx=0; idx<iLen; ++idx)
				{
					wszBuffer[jdx++] = pDefaultValue[idx];
					if (pDefaultValue[idx] == L'\\')
					{
						wszBuffer[jdx++] = L'\\';
					}
				}
				wszBuffer[jdx] = L'\0';

				if (*colMeta.ColumnMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING)
				{
					// we have format string\0string\0string\0\0
					fwprintf (m_pFile, L"={");
					bool fFirst = true;
					for (LPWSTR pCurString  = wszBuffer;
					     *pCurString != L'\0';
						 pCurString += wcslen (pCurString) + 1)
						 {
							 fwprintf (m_pFile, L"%s\"%s\"", (fFirst? L"" : L","), pCurString);
							 fFirst = false;
						 }
					fwprintf (m_pFile, L"}");
				}
				else
				{
					fwprintf (m_pFile, L"=\"%s\"", wszBuffer );
				}
			}
			break;
			
			case DBTYPE_UI4:
				fwprintf (m_pFile, L"=%ld", *colMeta.ColumnMeta.pDefaultValue);
				break;
			
			case DBTYPE_BYTES:
				// need to handle this
				fwprintf (m_pFile, L"=NEED TO HANDLE BYTES");
				ASSERT (false);
				break;
			default:
				// need to handle this
				fwprintf (m_pFile, L"=NEED TO HANDLE DEFAULT");
				ASSERT (false);
				break;
		}
	}

	fwprintf (m_pFile, L";\n");
}

void 
CMofGenerator::WriteValueMap (const CColumnMeta& columnMeta)
{
	ASSERT (columnMeta.cNrTags > 0);

	fwprintf (m_pFile, L"ValueMap {");
	for (ULONG idx=0; idx < columnMeta.cNrTags; ++idx)
	{
		fwprintf (m_pFile, L"\"%ld\"", *(columnMeta.paTags[idx]->pValue));
		if (idx != columnMeta.cNrTags - 1)
		{
			fwprintf (m_pFile, L",");
		}
	}
	fwprintf (m_pFile, L"}, Values {");
	// and print the values
	for (idx=0; idx < columnMeta.cNrTags; ++idx)
	{
		fwprintf (m_pFile, L"\"%s\"", columnMeta.paTags[idx]->pPublicName);
		if (idx != columnMeta.cNrTags - 1)
		{
			fwprintf (m_pFile, L",");
		}
	} 
	fwprintf (m_pFile, L"}: Amended] sint32 %s", columnMeta.ColumnMeta.pPublicName);
}

void
CMofGenerator::WriteInstanceProviderInfo () const
{
	ASSERT (m_pFile != 0);

	fwprintf (m_pFile,
			 L"// **************************************************************************\n"
		     L"// Copyright (c) 2000 Microsoft Corporation.\n"
			 L"//\n"
			 L"// File:  netfxcfgprov.mof\n"
			 L"//\n"
			 L"// Description: .NET Framework WMI Provider\n"
			 L"//\n"
			 L"// **************************************************************************\n\n"
 			 L"#pragma classflags(\"forceupdate\")\n\n"
			 L"/////////////////////////////////////////////////////////////////////\n"
			 L"// Go to \"root\" and create a new \"NetFrameworkv1\" namespace\n\n"
			 L"#pragma namespace (\"\\\\\\\\.\\\\Root\")\n\n"
			 L"[Locale(0x409)]\n"
			 L"instance of __Namespace\n"
			 L"{\n"
			 L"  Name = \"NetFrameworkv1\";\n"
			 L"};\n\n"
			 L"#pragma namespace (\"\\\\\\\\.\\\\root\\\\NetFrameworkv1\")\n\n"
			 L"/////////////////////////////////////////////////////////////////////\n"
			 L"// Register the instance provider\n\n"
			 L"#pragma deleteclass(\"FrameworkProvider\",NOFAIL)\n\n" 
			 L"class FrameworkProvider : __Win32Provider\n"
			 L"{\n"
			 L"  string HostingModel;\n"
			 L"};\n\n"
			 L"instance of FrameworkProvider as $NetFrameworkProvider\n"
			 L"{\n"
			 L"  Name = \"%s\";\n"
			 L"  ClsId = \"{4F14DD83-C443-4c0c-9784-AA903BBF9FA6}\";\n"
			 L"  ImpersonationLevel = 1;\n"
			 L"  PerUserInitialization = TRUE;\n"
			 L"  HostingModel = \"NetworkServiceHost\";\n"
			 L"};\n"
			 L"\n\n"
			 L"instance of __InstanceProviderRegistration\n"
			 L"{\n"
			 L"  Provider = $NetFrameworkProvider;\n"
			 L"  SupportsPut = TRUE;\n"
		     L"  SupportsGet = TRUE;\n"
			 L"  SupportsDelete = TRUE;\n"
			 L"  SupportsEnumeration = TRUE;\n"
			 L"  QuerySupportLevels = {\"WQL:UnarySelect\"};\n"
			 L"};\n\n"
			 L"instance of __MethodProviderRegistration\n"
			 L"{\n"
			 L"  Provider = $NetFrameworkProvider;\n"
			 L"};\n\n",
			 g_wszNetFrameworksProvider
			 );
}

void 
CMofGenerator::WriteTableAssociations (const CTableMeta& tableMeta)
{
	if (tableMeta.cNrRelations == 0)
	{
		return;
	}

	for (ULONG idx=0; idx < tableMeta.cNrRelations; ++idx)
	{
		// ignore hidden relations
		if (*tableMeta.paRels[idx]->RelationMeta.pMetaFlags & fRELATIONMETA_HIDDEN)
		{
			continue;
		}

		WCHAR wszPKCols[1024];
		WCHAR wszFKCols[1024];
		wszPKCols[0] = L'\0';
		wszFKCols[0] = L'\0';

		GetColInfo (tableMeta, tableMeta.paRels[idx], wszPKCols, wszFKCols);

		bool fUseContainment = false;
		if (*tableMeta.paRels[idx]->RelationMeta.pMetaFlags & fRELATIONMETA_USECONTAINMENT)
		{
			fUseContainment = true;
		}

		WCHAR wszClassName[256];
		wsprintf (wszClassName, 
			      L"%sTo%sAssociation", 
			      tableMeta.TableMeta.pPublicName, 
				  tableMeta.paRels[idx]->pForeignTableMeta->TableMeta.pPublicName);

		WriteDeleteClass (wszClassName);
		fwprintf (m_pFile, L"[Association, %s Dynamic, Provider(\"%s\"), AssocType(\"%s\")]\n", 
			(fUseContainment? L"Aggregation,": L""),g_wszNetFrameworksProvider, L"catalog");
		fwprintf (m_pFile, L"class %s : %s\n", wszClassName,
			(fUseContainment? L"NetContainmentAssociation" : L"NetContainmentAssociation"));
		fwprintf (m_pFile, L"{\n");
		fwprintf (m_pFile, L"[read, key, %s PK, Cols(\"%s\")] %s ref %s;\n",
			    (fUseContainment? L"Aggregate,": L""),
				wszPKCols,
				tableMeta.TableMeta.pPublicName,
				L"Parent");
		fwprintf (m_pFile, L"[read, key, Cols(\"%s\")] %s ref %s;\n",
				wszFKCols,
				tableMeta.paRels[idx]->pForeignTableMeta->TableMeta.pPublicName,
				L"Child");
		fwprintf (m_pFile, L"};\n\n");
	}
}

void
CMofGenerator::GetColInfo (const CTableMeta& tableMeta, 
						   const CRelationMeta *pRelationMeta,
						   LPWSTR wszPKCols,
						   LPWSTR wszFKCols)
{
	ASSERT (pRelationMeta != 0);
	ASSERT (wszPKCols != 0);
	ASSERT (wszFKCols != 0);

	wszPKCols[0] = L'\0';
	wszFKCols[0] = L'\0';
	// get pk stuff

	bool bFirstCol = true;
	ULONG cNrKeys = pRelationMeta->paSizes [iRELATIONMETA_PrimaryColumns] / sizeof (ULONG);
	for (ULONG idx=0; idx<cNrKeys; ++idx)
	{
		int iPKColIdx = *(ULONG * )(pRelationMeta->RelationMeta.pPrimaryColumns + idx * sizeof (ULONG));
		int iFKColIdx = *(ULONG * )(pRelationMeta->RelationMeta.pForeignColumns + idx * sizeof (ULONG));
	
		if ((*tableMeta.paColumns[iPKColIdx]->ColumnMeta.pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE) ||
			(*pRelationMeta->pForeignTableMeta->paColumns[iFKColIdx]->ColumnMeta.pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE))
		{
			continue;
		}

		if (!bFirstCol)
		{
			wcscat (wszPKCols, L" ");
			wcscat (wszFKCols, L" ");
		}
		else
		{
			bFirstCol = false;
		}

		wcscat (wszPKCols, tableMeta.paColumns[iPKColIdx]->ColumnMeta.pPublicName);
		wcscat (wszFKCols, pRelationMeta->pForeignTableMeta->paColumns[iFKColIdx]->ColumnMeta.pPublicName);
	}
}

bool 
CMofGenerator::IsValidTable (const CTableMeta& tableMeta) const
{
	// skip internal and hidden tables
	if ((*tableMeta.TableMeta.pMetaFlags & fTABLEMETA_INTERNAL) ||
	    (*tableMeta.TableMeta.pMetaFlags & fTABLEMETA_HIDDEN))
	{
		return false;
	}

	// only consider ASP, COR and LIGHTNING databases

	if ((_wcsicmp(tableMeta.TableMeta.pDatabase, L"ASP") != 0) &&
		(_wcsicmp(tableMeta.TableMeta.pDatabase, L"COR") != 0) &&
		(_wcsicmp(tableMeta.TableMeta.pDatabase, L"LIGHTNING") != 0) &&
		(_wcsicmp(tableMeta.TableMeta.pDatabase, g_wszNetFrameworks) != 0))
	{
		return false;
	}

	return true;
}

void
CMofGenerator::WriteLocationAssociations ()
{
	for (ULONG idx = 0; idx < m_cNrTables; ++idx)
	{
		// skip IMembershipcondition, because it is a special table
		if (IsValidTable (m_paTableMetas[idx]) && 
			(wcscmp (m_paTableMetas[idx].TableMeta.pPublicName, L"location") != 0) &&
			(_wcsicmp (m_paTableMetas[idx].TableMeta.pPublicName, L"IMembershipCondition") != 0))
		{
			WriteLocationAssociation (m_paTableMetas [idx]);
		}
	}
}

void
CMofGenerator::WriteLocationAssociation (const CTableMeta& tableMeta)
{
	ASSERT (m_pFile != 0);
	ASSERT (wcscmp (tableMeta.TableMeta.pPublicName, L"location") != 0);

	static LPCWSTR wszLocation = L"location";

	WCHAR wszClassName[256];
	wsprintf (wszClassName, L"%sTo%sAssociation", wszLocation, tableMeta.TableMeta.pPublicName);

	WriteDeleteClass (wszClassName);

	fwprintf (m_pFile, L"[Association, Dynamic, Provider(\"%s\"), AssocType(\"%s\")]\n", 
		      g_wszNetFrameworksProvider, wszLocation);
	fwprintf (m_pFile, L"class %s : %s\n", wszClassName, L"LocationConfiguration");
	fwprintf (m_pFile, L"{\n");
	fwprintf (m_pFile, L"%s ref Node;\n", wszLocation); 
	fwprintf (m_pFile, L"%s ref ConfigClass;\n", tableMeta.TableMeta.pPublicName);
	fwprintf (m_pFile, L"};\n\n");
}

HRESULT
CMofGenerator::WriteWebAppAssociations () const
{
	STQueryCell queryCell;
		
	queryCell.pData		= (void *) m_wszAssocFileName;
	queryCell.eOperator	= eST_OP_EQUAL;
	queryCell.iCell		= iST_CELL_FILE;
	queryCell.dbType	= DBTYPE_WSTR;
	queryCell.cbSize	= 0;

	ULONG cTotalCells = 1;
	CComPtr<ISimpleTableRead2> spRead;

	HRESULT hr = m_spDispenser->GetTable (wszDATABASE_MOFGENERATOR, wszTABLE_ASSOC_META, 
										  (void *) &queryCell, (void *) &cTotalCells,
										  eST_QUERYFORMAT_CELLS, 0, (void **)&spRead);
	if (FAILED (hr))
	{
		PrintToScreen (L"Unable to get table (db=%s, table=%s)\n", wszDATABASE_MOFGENERATOR, wszTABLE_ASSOC_META);
		return hr;
	}


	for (ULONG iRow=0; ;++iRow)
	{
		tASSOC_METARow AssocInfo;
		hr = spRead->GetColumnValues (iRow, cASSOC_META_NumberOfColumns, 0, 0, (void **)&AssocInfo);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}
		if (FAILED (hr))
		{
			PrintToScreen (L"GetColumnValues failed\n");
			return hr;
		}

		CTableMeta dummyTableMeta;
		dummyTableMeta.TableMeta.pInternalName = AssocInfo.pTableName;
		// find table
		CTableMeta *pTableMeta =  (CTableMeta *) bsearch (&dummyTableMeta, m_paTableMetas,
														m_cNrTables,
						   sizeof (CTableMeta), CompTableMeta);

		if (pTableMeta == 0)
		{
			PrintToScreen (L"Unable to find tablemeta for table %s (internalname)", AssocInfo.pTableName);
			return E_FAIL;
		}
		ASSERT (_wcsicmp (pTableMeta->TableMeta.pInternalName, AssocInfo.pTableName) == 0);
		WriteWebAppAssociation (*pTableMeta);
	}

	return S_OK;
}

void
CMofGenerator::WriteWebAppAssociation (const CTableMeta& tableMeta) const
{
	ASSERT (m_pFile != 0);

	static LPCWSTR wszAppMerged		= L"appmerged";
	static LPCWSTR wszAppUnMerged	= L"appunmerged";
	static LPCWSTR wszWebApp		= L"WebApplication";

	WCHAR wszClassName[256];
	wsprintf (wszClassName, L"%sTo%sAssociation", wszWebApp, tableMeta.TableMeta.pPublicName);
	WriteDeleteClass (wszClassName);

	fwprintf (m_pFile, L"[Association, Dynamic, Provider(\"%s\"), AssocType(\"%s\")]\n", 
		      g_wszNetFrameworksProvider, wszAppMerged);
	fwprintf (m_pFile, L"class %s : %s\n", wszClassName, L"WebApplicationConfiguration");
	fwprintf (m_pFile, L"{\n");
	fwprintf (m_pFile, L"%s ref Node;\n", wszWebApp);
	fwprintf (m_pFile, L"%s ref ConfigClass;\n", tableMeta.TableMeta.pPublicName);
	fwprintf (m_pFile, L"};\n\n");

	wcscat (wszClassName, L"Unmerged");
	WriteDeleteClass (wszClassName);

	fwprintf (m_pFile, L"[Association, Dynamic, Provider(\"%s\"), AssocType(\"%s\")]\n", 
		      g_wszNetFrameworksProvider, wszAppUnMerged);
	fwprintf (m_pFile, L"class %s : %s\n", wszClassName, L"WebApplicationConfigurationUnmerged");
	fwprintf (m_pFile, L"{\n");
	fwprintf (m_pFile, L"%s ref Node;\n", wszWebApp);
	fwprintf (m_pFile, L"%s ref ConfigClass;\n", tableMeta.TableMeta.pPublicName);
	fwprintf (m_pFile, L"};\n\n");
}

void
CMofGenerator::WriteShellAppAssociations () const
{
	// need to modify this to read from fixed table
	for (ULONG idx = 0; idx < m_cNrTables; ++idx)
	{
		if (IsValidTable (m_paTableMetas[idx]))
		{
			WriteShellAppAssociation (m_paTableMetas [idx]);
		}
	}
}

void
CMofGenerator::WriteShellAppAssociation (const CTableMeta& tableMeta) const
{
	ASSERT (m_pFile != 0);

	static LPCWSTR wszAppMerged		= L"appmerged";
	static LPCWSTR wszAppUnMerged	= L"appunmerged";
	static LPCWSTR wszShellApp		= L"ShellApplication";

	WCHAR wszClassName[256];
	wsprintf (wszClassName, L"%sTo%sAssociation", wszShellApp, tableMeta.TableMeta.pPublicName);
	WriteDeleteClass (wszClassName);

	fwprintf (m_pFile, L"[Association, Dynamic, Provider(\"%s\"), AssocType(\"%s\")]\n", 
		      g_wszNetFrameworksProvider, wszAppMerged);
	fwprintf (m_pFile, L"class %s : %s\n", wszClassName, L"ApplicationConfiguration");
	fwprintf (m_pFile, L"{\n");
	fwprintf (m_pFile, L"%s ref Node;\n", wszShellApp);
	fwprintf (m_pFile, L"%s ref ConfigClass;\n", tableMeta.TableMeta.pPublicName);
	fwprintf (m_pFile, L"};\n\n");

	wcscat (wszClassName, L"Unmerged");
	WriteDeleteClass (wszClassName);

	fwprintf (m_pFile, L"[Association, Dynamic, Provider(\"%s\"), AssocType(\"%s\")]\n", 
		      g_wszNetFrameworksProvider, wszAppUnMerged);
	fwprintf (m_pFile, L"class %s : %s\n", wszClassName, L"ApplicationConfigurationUnmerged");
	fwprintf (m_pFile, L"{\n");
	fwprintf (m_pFile, L"%s ref Node;\n", wszShellApp);
	fwprintf (m_pFile, L"%s ref ConfigClass;\n", tableMeta.TableMeta.pPublicName);
	fwprintf (m_pFile, L"};\n\n");
}

void
CMofGenerator::WriteDeleteClass (LPCWSTR wszClassName) const
{
	ASSERT (m_pFile != 0);
	ASSERT (wszClassName != 0);

	fwprintf (m_pFile, L"#pragma deleteclass (\"%s\", NOFAIL)\n\n", wszClassName);
}

void
CMofGenerator::PrintToScreen (LPCWSTR wszMsg, ...) const
{
	if (!m_fQuiet)
	{
		va_list argp;
		va_start (argp, wszMsg);
		vwprintf (wszMsg, argp);
		va_end (argp);
	}
}

void
CMofGenerator::CheckForDuplicatePublicNames () const
{
	qsort (m_paTableMetas, m_cNrTables, sizeof (CTableMeta), CompTableMetaPublicName);

	bool fHasError = false;
	// start at one
	for (ULONG idx=1; idx < m_cNrTables; ++idx)
	{
		if (_wcsicmp ((LPWSTR)m_paTableMetas[idx-1].TableMeta.pPublicName,
					  (LPWSTR)m_paTableMetas[idx].TableMeta.pPublicName) == 0)
		{
			PrintToScreen (L"Error !!!!! Duplicate public table names found: %s\n", (LPWSTR)m_paTableMetas[idx].TableMeta.pPublicName);
			fHasError = true;
		}
	}

	if (fHasError)
	{
		exit (-1);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\cat2mof\generator.h ===
//+--------------------------------------------------------------------------
//  Microsoft Genesis 
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File: Generator.h
//
//  $Header: $
//
//  Contents:
//
//  Classes:    Name                Description
//              -----------------   ---------------------------------------------
//
//
//  Functions:  Name                Description
//              ----------------    ---------------------------------------------
//
//
//  History: marcelv 	10/27/2000		Initial Release
//
//---------------------------------------------------------------------------------
#ifndef __GENERATOR_H__
#define __GENERATOR_H__

#pragma once

#include "catalog.h"
#include "catmeta.h"
#include "catmacros.h"
#include <atlbase.h>

//forward decl
struct CTableMeta;

struct CColumnMeta
{
	CColumnMeta() {paTags = 0; cNrTags = 0;}
	~CColumnMeta() {delete [] paTags;}
	tCOLUMNMETARow ColumnMeta;
	ULONG cNrTags;
	tTAGMETARow **paTags;
	tTAGMETARow *aTags;
};

struct CRelationMeta
{
	CRelationMeta () {}
	~CRelationMeta () {}

	tRELATIONMETARow RelationMeta;
	ULONG paSizes[sizeof(tRELATIONMETARow)/sizeof(ULONG *)];
	CTableMeta *pForeignTableMeta;
};

struct CTableMeta
{
	CTableMeta () {paColumns=0; paRels=0; cNrRelations=0; fIsContained=false;}
	~CTableMeta () {delete []paColumns; delete[] paRels;}

	ULONG ColCount () const
	{
		return *(TableMeta.pCountOfColumns);
	}

	bool fIsContained;			// is the table contained in another table
	tTABLEMETARow TableMeta;
	CColumnMeta **paColumns;

	ULONG cNrRelations;
	CRelationMeta **paRels;
};



typedef tTAGMETARow * LPtTAGMETA;
typedef CRelationMeta * LPCRelationMeta;
typedef CColumnMeta * LPCColumnMeta;
	

class CMofGenerator
{
public:
	CMofGenerator ();
	~CMofGenerator ();
	HRESULT GenerateIt ();
	bool ParseCmdLine (int argc, wchar_t **argv);
	void PrintUsage ();

private:
	HRESULT GetDatabases ();
	HRESULT GetTables ();
	HRESULT GetColumns ();
	HRESULT GetTags ();
	HRESULT GetRelations ();
	HRESULT WriteToFile ();
	HRESULT CopyHeader ();
	
	void WriteInstanceProviderInfo () const;
	void WriteTable (const CTableMeta& tableMeta);
	void WriteColumn (const CColumnMeta& colMeta);
	void WriteValueMap (const CColumnMeta& columnMeta);
	void WriteTableAssociations (const CTableMeta& tableMeta);
	bool IsValidTable (const CTableMeta& tableMeta) const;
	
	void WriteLocationAssociations ();
	void WriteLocationAssociation (const CTableMeta& tableMeta);
	
	HRESULT WriteWebAppAssociations () const;
	void WriteWebAppAssociation (const CTableMeta& tableMeta) const;

	void WriteShellAppAssociations () const;
	void WriteShellAppAssociation (const CTableMeta& tableMeta) const;

	void WriteDeleteClass (LPCWSTR wszClassName) const;

	HRESULT BuildInternalStructures ();
	void GetColInfo (const CTableMeta& tablemeta, 
						   const CRelationMeta *pRelationMeta,
						   LPWSTR wszPKCols,
						   LPWSTR wszFKCols);

	void PrintToScreen (LPCWSTR wszMsg, ...) const;
	void CheckForDuplicatePublicNames () const;

	CComPtr<ISimpleTableDispenser2> m_spDispenser;
	
	LPWSTR m_wszOutFileName;
	LPWSTR m_wszTemplateFileName;
	LPWSTR m_wszAssocFileName;

	int m_argc;
	wchar_t **m_argv;

	tDATABASEMETARow *	m_paDatabases;		// all database information
	ULONG				m_cNrDatabases;

	CTableMeta	 *		m_paTableMetas;
	ULONG				m_cNrTables;

	CColumnMeta	 *		m_paColumnMetas;		    // all column information
	ULONG				m_cNrColumns;

	tTAGMETARow *		m_paTags;		    // all tag information
	ULONG				m_cNrTags;
	
	CRelationMeta *     m_paRels;
	ULONG				m_cNrRelations;

	FILE *				m_pFile;		// file pointer
	LPWSTR				m_wszFileName;
	bool				m_fQuiet;   // quiet operation?


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assocapplication.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assocapplication.cpp

$Header: $

Abstract:
	AssocApplication class. Takes care of associations between Applications and Configuration classes

Author:
    marcelv 	1/18/2001		Initial Release

Revision History:

--**************************************************************************/

#include "assocapplication.h"
#include "assoctypes.h"

//=================================================================================
// Function: CAssocApplication::CAssocApplication
//
// Synopsis: Constructor
//=================================================================================
CAssocApplication::CAssocApplication ()
{
	m_fMergedView = false;
	m_fIsShellApp = false;
}

//=================================================================================
// Function: CAssocApplication::~CAssocApplication
//
// Synopsis: Destructor
//=================================================================================
CAssocApplication::~CAssocApplication ()
{
}

//=================================================================================
// Function: CAssocApplication::CreateAssocations
//
// Synopsis: Creates the assocations. We only support assocations from application to
//           configclass. This means that we can return immediately in case we are trying
//           to deal with an assocation from configclass to assocation.
//
// Return Value: 
//=================================================================================
HRESULT
CAssocApplication::CreateAssocations ()
{
	HRESULT hr = S_OK;
	const CWQLProperty * pProp = m_pWQLParser->GetProperty (0);
	ASSERT (pProp != 0);

	if (_wcsicmp (pProp->GetName (), L"ConfigClass") != 0)
	{
		// application -> config
		hr = CreateApplicationToConfigAssocs ();
		if (FAILED (hr))
		{
			TRACE (L"Unable to create application to config associations");
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CAssocApplication::GetAssocType
//
// Synopsis: We support two assocationtypes: webmerged and unmerged. Depending on the
//           type we have to create a different selector (merged view, unmerged view) and
//           thus the behavior is slightly different.
//=================================================================================
HRESULT
CAssocApplication::GetAssocType ()
{
	CComPtr<IWbemQualifierSet> spPropQualifierSet;
	HRESULT hr = m_spClassObject->GetQualifierSet (&spPropQualifierSet);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get QualifierSet for class %s", m_pWQLParser->GetClass ());
		return hr;
	}

	_variant_t varAssocType;
	hr = spPropQualifierSet->Get (L"AssocType", 0, &varAssocType, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get AssocType qualifier for class %s", m_pWQLParser->GetClass ());
		return hr;
	}

	ASSERT (varAssocType.vt == VT_BSTR);

	LPCWSTR wszAssocType = varAssocType.bstrVal;
	if (_wcsicmp (wszAssocType, g_wszAssocTypeAppmerged) == 0)
	{
		m_fMergedView = true;
	}
	else
	{
		ASSERT (_wcsicmp (wszAssocType, g_wszAssocTypeAppUnmerged) == 0);
	}

	_bstr_t bstrNodeType;
	hr = GetConfigClass (L"Node", bstrNodeType);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get configuration class in location association");
		return hr;
	}

	if (_wcsicmp (bstrNodeType, L"shellapplication") == 0)
	{
		m_fIsShellApp = true;
	}

	return hr;
}

//=================================================================================
// Function: CAssocApplication::CreateApplicationToConfigAssocs
//
// Synopsis: Depending on the assocation type, we do merged view or unmerged view. The only
//           difference between the two is that in the merged view we use the selector from the
//           application, while in the unmerged view we use the ConfigurationFilePath from the application
//=================================================================================
HRESULT 
CAssocApplication::CreateApplicationToConfigAssocs ()
{
	ASSERT (m_fInitialized);

	HRESULT hr = GetAssocType ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get association type");
		return hr;
	}

	static LPCWSTR wszConfigPath = L"ConfigurationFilePath";
	static LPCWSTR wszPath       = L"Path";
	static LPCWSTR wszFileProtocol = L"file://";
	static SIZE_T cLenFileProtocol = wcslen (wszFileProtocol);

	CComPtr<IWbemClassObject> spWMIInstance;
	hr = m_spNamespace->GetObject (m_saObjectPath, 0, m_spCtx, &spWMIInstance, 0);
	if (FAILED (hr))
	{
		TRACE (L"GetObject for %s failed", m_saObjectPath);
		return hr;
	}

	_variant_t varPath;
	_variant_t varConfigPath;
	hr = spWMIInstance->Get (wszPath, 0, &varPath, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get %s property", wszPath);
		return hr;
	}

	hr = spWMIInstance->Get (wszConfigPath, 0, &varConfigPath, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get %s property", wszConfigPath);
		return hr;
	}


	const CWMIProperty *pSelector	= m_knownObjectParser.GetPropertyByName (WSZSELECTOR);

	// find out what selector to use
	TSmartPointerArray<WCHAR> saSelector;
	if (m_fMergedView)
	{
		// merged view, use the pSelector value
		saSelector = new WCHAR [wcslen(pSelector->GetValue()) + 1];
		if (saSelector == 0)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy (saSelector, pSelector->GetValue ());
	}
	else if (m_fIsShellApp)
	{
		LPCWSTR wszShellPath = varPath.bstrVal;
		SIZE_T iPathLen = wcslen (wszShellPath);

		if (_wcsicmp(wszShellPath + iPathLen - 4, L".exe") != 0)
		{
			TRACE (L"Path for shell app must end with .exe");
			return E_INVALIDARG;
		}
		
		// unmerged view for shell app. Use the app path file path as selector
		// -4 for removing .exe, and +7 for adding .config
		saSelector = new WCHAR [iPathLen - 4 + 7 + 1 + cLenFileProtocol];
		if (saSelector == 0)
		{
			return E_OUTOFMEMORY;
		}

		wcscpy (saSelector, wszFileProtocol);
		wcscpy (saSelector + cLenFileProtocol, wszShellPath);
		wcscpy (saSelector + cLenFileProtocol + iPathLen - 4, L".config");
	}
	else
	{
		// unmerged view. Use the configuration file path as selector
		saSelector = new WCHAR [wcslen (varConfigPath.bstrVal) + 1 + cLenFileProtocol];
		if (saSelector == 0)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy (saSelector, wszFileProtocol);
		wcscpy (saSelector + cLenFileProtocol, varConfigPath.bstrVal);
	}

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;
	_bstr_t bstrConfigClass;

	hr = GetConfigClass (L"ConfigClass", bstrConfigClass);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get configuration class in location association");
		return hr;
	}

	hr = GetClassInfoForTable ((LPCWSTR) bstrConfigClass, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get db/table information for class %s", (LPCWSTR) bstrConfigClass);
		return hr;
	}


	// issue a query for this particular table. All records that are returned are valid assocations
	CConfigQuery query;
	hr = query.Init ((LPCWSTR) bstrDBName, (LPCWSTR) bstrTableName, saSelector, m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Unable to configure config query");
		return hr;
	}

	hr = query.Execute (0, false, false);
	if (FAILED (hr))
	{
		TRACE (L"Execution of query failed");
		return hr;
	}

	for (ULONG idx=0; idx < query.GetRowCount (); ++idx)
	{
		CConfigRecord record;
		hr = query.GetColumnValues (idx, record);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get config record");
			return hr;
		}

		hr = CreateAssociationInstance (record, saSelector, L"ConfigClass");
		if (FAILED (hr))
		{
			TRACE (L"Unable to create assocation instance");
			return hr;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\samples\webhierarchyinterceptor\webhierarchynavigation.cs ===
namespace System.Configuration.Navigation {

    public class NavigationNode : System.Configuration.BaseConfigItem {
        NavigationNode() : base(5) {}
        public String LogicalName  { get { return (String) base[0]; } set { base[0]=value; } }
        public String PhysicalName { get { return (String) base[1]; } set { base[1]=value; } }
        public String Parent       { get { return (String) base[2]; } set { base[2]=value; } }
        public String RelativeName { get { return (String) base[3]; } set { base[3]=value; } }
        public String NodeType     { get { return (String) base[4]; } set { base[4]=value; } }
    }

    public class NavigationConfigFile : System.Configuration.BaseConfigItem {
        NavigationConfigFile() : base(3) {}
        public String LogicalName    { get { return (String) base[0]; } set { base[0]=value; } }
        public String ConfigFilePath { get { return (String) base[1]; } set { base[1]=value; } }
        public String Description    { get { return (String) base[2]; } set { base[2]=value; } }
    }

    public class NavigationNodeConfigType : System.Configuration.BaseConfigItem {
        NavigationNodeConfigType() : base(3) {}
        public String NodeType           { get { return (String) base[0]; } set { base[0]=value; } }
        public String ConfigTypeCategory { get { return (String) base[1]; } set { base[1]=value; } }
        public String ConfigTypeName     { get { return (String) base[2]; } set { base[2]=value; } }
    }

    public class NavigationNodeConfigFileHierarchy : System.Configuration.BaseConfigItem {
        NavigationNodeConfigFileHierarchy() : base(3) {}
        public String LogicalName    { get { return (String) base[0]; } set { base[0]=value; } }
        public String ConfigFilePath { get { return (String) base[1]; } set { base[1]=value; } }
        public String Location       { get { return (String) base[2]; } set { base[2]=value; } }
    }

}

namespace Microsoft.Configuration.Samples {

using System;
using System.Configuration;
using System.Configuration.Interceptors;
using System.Configuration.Internal;
using System.DirectoryServices;
using System.Web;

//using System.Configuration.Navigation;

using Microsoft.Configuration.Samples;

/// <summary>
///    <para>
///       Indicates the location of the web machine configuration file.
///    </para>
/// </summary>
/// <remarks>
///    <para>
///       The WebServiceSelector.Argument method retrieves the file path to the
///       web machine configuration file.
///    </para>
/// </remarks>
public class WebServiceSelector: FileSelector {

    internal static String WebServicePrefix = "webservice";

    private static String GetConfigFilePath() {
        String machinecfg = new LocalMachineSelector().Argument;
        // Trim off "\config\machine.cfg" part
        machinecfg=machinecfg.Substring(0,machinecfg.LastIndexOf('\\'));
        machinecfg=machinecfg.Substring(0,machinecfg.LastIndexOf('\\'));
        machinecfg=machinecfg+"\\config.web";
        return machinecfg;
    }
    /// <summary>
    ///    <para>
    ///       Creates a WebServiceSelector.
    ///    </para>
    /// </summary>
    public WebServiceSelector() 
        : base ( GetConfigFilePath() ) 
    {
	}

    /// <summary>
    /// </summary>
    /// <value>
    ///    <para>
    ///       Returns "webservice" as the prefix for the LocalMachineSelector.
    ///    </para>
    /// </value>
    public override String Prefix {
        get {
            return WebServicePrefix;
        }
	}

	/// <summary>
	/// </summary>
	/// <returns>
	///    <para>
	///       Returns "webservice://" as the string representation of an
	///       AppDomainSelector.
	///    </para>
	/// </returns>
	public override String ToString(){
        return Prefix + "://";
	}

}

/// <summary>
///    <para>
///       This class facilitates access to the IIS Metabase
///    </para>
/// </summary>

public class WebHierarchyLocationInterceptor : IConfigReader {
	public const String ctNodes = "NavigationNodes";
	public const String ctHierarchy = "NavigationHierarchy";
	public const String ctFileLocation = "ConfigurationFileLocations";
	public const String ctNodeTypes = "NavigationNodeTypes";
	public const String ctNodeConfigTypes = "NavigationNodeConfigTypes";
    public const String ctConfigFileHierarchy ="ConfigFileHierarchy";

    public const String nodetypeWebService ="IISWebService";
    public const String nodetypeWebServer ="IISWebServer";
    public const String nodetypeWebDirectory ="IISWebDirectory";

	public Object Read(String configType, Selector selector, int los, Object currentObject) {
		Selector url = null;
		ConfigQuery query = null;
        Object val= null;

        IConfigCollection result = null;
        IConfigItem node=null;


		if (selector is ConfigQuery && ((ConfigQuery) selector).Count>0) {
			query = (ConfigQuery) selector;
			url = query.Selector;
		}
		else
		{
            if (selector is NullSelector) {
                url = null;
            }
            else {
                url = selector;
            }
			query = null;
		}
		if (url!=null && !(url is HttpSelector) && !(url is WebServiceSelector)) {
			throw new ConfigException("Invalid Selector");
		}
		switch (configType) {
			case ctNodes :
				// LogicalName, PhysicalName, Parent, NodeType
                // Q by ParentName==NULL: "IISWebService" entry (LogicalName = ?)
                // Q by "IISWebService" LogicalName: all IIS web sites
                // Q by LogicalName: UNC from URL - site binding
                // NodeType: IIS6!
                // PhysicalName: UNC from URL (MB)

                if (query!=null) {
                    if (query.Count>1) {
                        throw new ConfigException("Can't query by more than one property");
                    }
                    val= query[0].Value;
                }

                if ((query !=null && query[0].PropertyIndex==2) || url==null) // Query by Parent?
                {
                    if (val==null || (val is String && ((String) val)==String.Empty)) {
                        // return IISWebService node
                        result = ConfigManager.GetEmptyConfigCollection(configType);
                        node = ConfigManager.GetEmptyConfigItem(configType);
                        WebServiceSelector ws = new WebServiceSelector();
                        node["LogicalName"]=ws.ToString();
                        node["PhysicalName"]=new WebServiceSelector().Argument;
                        node["Parent"]="";
                        node["RelativeName"]=".NET Web Service";
                        node["NodeType"]=nodetypeWebService;
                        result.Add(node);
                        return result;
                    }
                    if (val is String) {
                        if ((String) val==new WebServiceSelector().ToString()) {
                            // return all sites
                            result = ConfigManager.GetEmptyConfigCollection(configType);
                            node = ConfigManager.GetEmptyConfigItem(configType);
                            // BUGBUG really enumerate the metabase
                            node["LogicalName"]="http://localhost";
                            node["PhysicalName"]=IISAdminHelper.GetPathForUrl((String) node["LogicalName"]);
                            node["Parent"]=new WebServiceSelector().ToString();
                            node["RelativeName"]=node["LogicalName"];
                            node["NodeType"]=nodetypeWebServer;
                            result.Add(node);
                            return result;
                        }
                        // read children from metabase
                        String[] children = IISAdminHelper.GetChildrenForUrl((String) val);

                        result = ConfigManager.GetEmptyConfigCollection(configType);
                        foreach (String child in children) {
                            node = ConfigManager.GetEmptyConfigItem(configType);
                            // BUGBUG really enumerate the metabase
                            node["Parent"]=(String) val;
                            node["LogicalName"]=((String) val)+"/"+child;
                            node["PhysicalName"]=IISAdminHelper.GetPathForUrl((String) node["LogicalName"]);
                            node["RelativeName"]=child;
                            node["NodeType"]=nodetypeWebDirectory;
                            result.Add(node);
                        }
                        return result;
                    }
				    throw new ConfigException("Invalid query for UINavigationNodes.Parent!");
                }

                if ((query==null && url!=null) || (query!=null && query[0].PropertyIndex==0)) { // Query by LogicalName?
                    if (query==null) {
                        val=url.ToString();
                    }
                    if (!(val is String) || ((String) val)==String.Empty) {
                        throw new ConfigException("Invalid Query for UINavigationNode.LogicalName!");
                    }
                    
                    WebServiceSelector ws = new WebServiceSelector();
                    if ((String) val==ws.ToString()) {
                        // return IISWebService node
                        result = ConfigManager.GetEmptyConfigCollection(configType);
                        node = ConfigManager.GetEmptyConfigItem(configType);
                        node["LogicalName"]=ws.ToString();
                        node["PhysicalName"]=ws.Argument.Substring(0,ws.Argument.LastIndexOf('\\'));
                        node["Parent"]="";
                        node["RelativeName"]="";
                        node["NodeType"]=nodetypeWebService;
                        result.Add(node);
                        return result;
                    }
                    

                    result = ConfigManager.GetEmptyConfigCollection(configType);
                    node = ConfigManager.GetEmptyConfigItem(configType);
                    node["LogicalName"]=(String) val;
                    node["PhysicalName"]=IISAdminHelper.GetPathForUrl((String) val);
                    // BUGBUG compute only the immediate parent!
                    String[] parents = IISAdminHelper.GetParentUrlsForUrl((String) val);
                    if (parents.Length>=2) {
                        node["Parent"]=parents[parents.Length-2];
                        node["RelativeName"]=((String) val).Substring(((String) val).LastIndexOf('/'));
                    }
                    else {
                        node["Parent"]=new WebServiceSelector().ToString();
                        node["RelativeName"]=node["LogicalName"];
                    }
                    node["NodeType"]=nodetypeWebDirectory;
                    result.Add(node);
                    return result;
                    }
                throw new ConfigException("Invalid Query for UINavigationNode.LogicalName!");
				//break;

// *******************************************************************************************************
            case ctConfigFileHierarchy:
                // LogicalName, ConfigFilePath, Location
                // Q by LogicalName=all config file for this node and it's parents

                if (query==null || query.Count==0) {
                    if (url==null) {
				        throw new ConfigException("Can't enumerate all nodes!");
                    }
                }
                if (query!=null) {
                    if (query.Count>1) {
                        throw new ConfigException("Can't query by more than one property");
                    }
                    val= query[0].Value;
                }

                if ((query !=null && query[0].PropertyIndex==0) || (query==null && url!=null)) // Query by LogicalName?
                {
                    if (query==null) val=url.ToString();

                    if (val==null || (val is String && ((String) val)==String.Empty)) {
                        throw new ConfigException("Can't query for all root nodes.");
                    }
                    if (val is String) {
                        result = ConfigManager.GetEmptyConfigCollection(configType);

                        node = ConfigManager.GetItem(ctNodes, url);
                        do {
                            IConfigCollection files = ConfigManager.Get(ctFileLocation, (String) node["LogicalName"]);
                            foreach (IConfigItem file in files) {
                                IConfigItem hierarchyfile = ConfigManager.GetEmptyConfigItem(configType);

                                hierarchyfile["LogicalName"]=file["LogicalName"];
                                hierarchyfile["ConfigFilePath"]=file["ConfigFilePath"];
                                hierarchyfile["Location"]="";
                                result.Add(hierarchyfile);
                            }
                            if (node["Parent"]!="") {
                                node = ConfigManager.GetItem(ctNodes, (String) node["Parent"]);
                            }
                            else {
                                break;
                            }
                        } while (true);

                        return result;
                    }
				    throw new ConfigException("Invalid query for "+ctConfigFileHierarchy+".LogicalName!");
                }
                throw new ConfigException("Invalid Query for "+ctHierarchy+".");
				//break;
			case ctFileLocation:
                // LogicalName, ConfigFilePath, Description
                IConfigCollection nodes = (IConfigCollection) Read(ctNodes, selector, los, currentObject);
                if (nodes.Count>1) {
                    throw new ConfigException("More than one node for this URL!");
                }
                
                result = ConfigManager.GetEmptyConfigCollection(configType);
                if (nodes.Count==1) {
                    node = ConfigManager.GetEmptyConfigItem(configType);
                    node["LogicalName"]=nodes[0]["LogicalName"];
                    node["ConfigFilePath"]=((String) nodes[0]["PhysicalName"])+"\\config.web";
                    node["Description"]="";
                    result.Add(node);
                }
                return result;
			default:
				throw new ConfigException("Invalid ConfigType");
		}
	}
	

	} 
    

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assocbase.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assocbase.cpp

$Header: $

Abstract:

Author:
    marcelv 	1/12/2001		Initial Release

Revision History:

--**************************************************************************/
#include "assocbase.h"
#include "smartpointer.h"
#include "stringutil.h"
#include "localconstants.h"

CAssocBase::CAssocBase ()
{
	m_pWQLParser		= 0;
	m_lFlags			= 0;
	m_fInitialized		= false;
	m_pKnownClassName	= 0;
}

CAssocBase::~CAssocBase ()
{

}

HRESULT 
CAssocBase::Init (CWQLParser&				i_wqlQuery,
				  IWbemClassObject *        i_pClassObject,
		          long						i_lFlags,
                  IWbemContext *			i_pCtx,
                  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace,
				  ISimpleTableDispenser2 *	i_pDispenser)
{
	m_pWQLParser		= &i_wqlQuery;
	m_spClassObject		= i_pClassObject;
	m_lFlags			= i_lFlags;
	m_spCtx				= i_pCtx;
	m_spResponseHandler = i_pResponseHandler;
	m_spNamespace		= i_pNamespace;
	m_spDispenser		= i_pDispenser;

	const CWQLProperty *pProp = m_pWQLParser->GetProperty (0);
	ASSERT (pProp != 0);

	m_pKnownClassName = pProp->GetName ();

	m_saObjectPath = CWMIStringUtil::StrToObjectPath (pProp->GetValue ());
	if (m_saObjectPath == 0)
	{
		return E_OUTOFMEMORY;
	}

	HRESULT hr = m_knownObjectParser.Parse (m_saObjectPath);

	if (FAILED (hr))
	{
		TRACE (L"Object path parsing of %s failed", pProp->GetValue());
		return hr;
	}

	m_fInitialized = true;
	return hr;
}

HRESULT
CAssocBase::CreateAssociationInstance (CConfigRecord& newRecord, LPCWSTR wszSelector, LPCWSTR wszRefName)
{
	ASSERT (m_fInitialized);

	HRESULT hr = S_OK;

	const CWMIProperty *pSelector = m_knownObjectParser.GetPropertyByName (WSZSELECTOR);
	ASSERT (pSelector != 0);

	CComPtr<IWbemClassObject> spNewInst;
	hr = m_spClassObject->SpawnInstance(0, &spNewInst);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class %s", m_pWQLParser->GetClass ());
		return hr;
	}

	// we have the record that points to one WMI instance, and the object path that points
	// to another object instance. Convert both to object paths, and assign them as 
	// properties for the association

	_variant_t varValue = m_pWQLParser->GetProperty (0)->GetValue();

	hr = spNewInst->Put(m_pKnownClassName, 0, &varValue, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%s",  m_knownObjectParser.GetClass (), varValue.bstrVal);
		return hr;
	}

	// set the record path
	if (wszSelector)
	{
		hr = newRecord.AsObjectPath (wszSelector, varValue);
	}
	else
	{
		hr = newRecord.AsObjectPath (pSelector->GetValue (), varValue);
	}

	if (FAILED (hr))
	{
		TRACE (L"Unable to represent record as object path");
		return hr;
	}

	hr = spNewInst->Put(wszRefName, 0, &varValue, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%s", newRecord.GetPublicTableName (), (LPWSTR)((_bstr_t) varValue));
		return hr;
	}

	IWbemClassObject* pNewInstRaw = spNewInst;
	hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);
	if (FAILED (hr))
	{
		TRACE (L"WMI Indicate failed");
	}

	return hr;
}

//=================================================================================
// Function: CAssocBase::GetClassInfoForTable
//
// Synopsis: Gets the DB and Table qualifier for a particular table
//
// Arguments: [wszTableName] - table to get info for
//            [i_bstrDBName] - database name
//            [i_bstrTableName] - table name
//=================================================================================
HRESULT
CAssocBase::GetClassInfoForTable (LPCWSTR wszTableName,
							_bstr_t& i_bstrDBName, 
							_bstr_t& i_bstrTableName)
{
	ASSERT (m_fInitialized);
	ASSERT (wszTableName != 0);

	HRESULT hr = S_OK;
	CComPtr<IWbemClassObject> spClassObject;
	hr = m_spNamespace->GetObject((LPWSTR) wszTableName, 
											0, 
											m_spCtx, 
											&spClassObject, 
											0); 

	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", wszTableName);
		return hr;
	}

	CComPtr<IWbemQualifierSet> spQualifierSet;
	hr = spClassObject->GetQualifierSet (&spQualifierSet);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Qualifier set");
		return hr;
	}
		
	_variant_t varDBName;
	_variant_t varInternalName;

	hr = spQualifierSet->Get (WSZDATABASE, 0, &varDBName, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Database Qualifier");
		return hr;
	}

	hr = spQualifierSet->Get (WSZINTERNALNAME, 0, &varInternalName, 0);
	if (FAILED (hr))
	{
		TRACE(L"Unable to get InternalName Qualifier");
		return hr;
	}

	i_bstrDBName		= varDBName;
	i_bstrTableName		= varInternalName;

	return hr;
}

//=================================================================================
// Function: CAssocLocation::GetConfigClass
//
// Synopsis: Gets the name of the configuration class in the location association. When
//           we have a location assocation, we have a reference to a location and to a
//           class defined in the catalog. We are looking for the class in the catalog,
//           and the name of this class is returned in the parameter
//
// Arguments: [o_bstrClassName] - Name of the catalog class used in the association
//=================================================================================
HRESULT
CAssocBase::GetConfigClass (LPCWSTR i_wszPropName, _bstr_t & o_bstrClassName) const
{
	ASSERT (i_wszPropName != 0);

	static LPCWSTR wszRef = L"ref:";
	static SIZE_T	 cRefLen = wcslen (wszRef);

	o_bstrClassName = L"";

	CComPtr<IWbemQualifierSet> spPropQualifierSet;
	HRESULT hr = m_spClassObject->GetPropertyQualifierSet (i_wszPropName, &spPropQualifierSet);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get PropertyQualifierSet for %s", i_wszPropName);
		return hr;
	}

	_variant_t varType;
	hr = spPropQualifierSet->Get (L"CIMTYPE", 0, &varType, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get CIMTYPE qualifier for %s", i_wszPropName);
		return hr;
	}

	ASSERT (varType.bstrVal != 0);

	if (wcsncmp (varType.bstrVal, wszRef, cRefLen) != 0)
	{
		TRACE (L"Reference doesn't start with %s", wszRef);
		return E_INVALIDARG;
	}

	o_bstrClassName = (LPCWSTR) varType.bstrVal + cRefLen;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assocbase.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assocbase.h

$Header: $

Abstract:

Author:
    marcelv 	1/12/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __ASSOCBASE_H__
#define __ASSOCBASE_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "wmiobjectpathparser.h"
#include "wqlparser.h"
#include "smartpointer.h"
#include "cfgrecord.h"

class CAssocBase
{
public:
	CAssocBase ();
	virtual ~CAssocBase ();

	HRESULT Init (CWQLParser&				i_wqlQuery,
				  IWbemClassObject *        i_pClassObject,
		          long						i_lFlags,
                  IWbemContext *			i_pCtx,
                  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace,
				  ISimpleTableDispenser2 *	i_pDispenser);

	virtual HRESULT CreateAssocations () = 0;
	

protected:
	CAssocBase (const CAssocBase&);
	CAssocBase& operator= (CAssocBase& );

	HRESULT GetAssociationInfo(); // names of columns
	HRESULT CreateAssociationInstance (CConfigRecord& newRecord, LPCWSTR wszSelector, LPCWSTR wszRefName);
	HRESULT GetClassInfoForTable (LPCWSTR wszTableName, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName);
	HRESULT GetConfigClass (LPCWSTR i_wszPropName, _bstr_t & o_bstrClassName) const;

	CWQLParser *			    m_pWQLParser;
	long						m_lFlags;
	CComPtr<IWbemClassObject>   m_spClassObject;
	CComPtr<IWbemContext>		m_spCtx;
	CComPtr<IWbemObjectSink>	m_spResponseHandler;
	CComPtr<IWbemServices>		m_spNamespace;
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;

	CObjectPathParser			m_knownObjectParser;
	LPCWSTR						m_pKnownClassName;
	bool						m_fInitialized;
	TSmartPointerArray<WCHAR>	m_saObjectPath;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assoccatalog.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assoccatalog.h

$Header: $

Abstract:

Author:
    marcelv 	1/12/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __ASSOCCATALOG_H__
#define __ASSOCCATALOG_H__

#pragma once

#include "assocbase.h"
#include "associationhelper.h"
#include "cfgquery.h"

class CAssocCatalog : public CAssocBase
{
public:
	CAssocCatalog () {};
	virtual ~CAssocCatalog () {};

	virtual HRESULT CreateAssocations ();
private:
	CAssocCatalog (const CAssocCatalog& );
	CAssocCatalog& operator= (const CAssocCatalog&);

	HRESULT GetAssociationInfo ();
	HRESULT InitAssocRecord (CConfigRecord& record, 
							   const CObjectPathParser& objPathParser,
							   LPCWSTR wszObjectPath);
	HRESULT GetSingleFKRecord (CConfigRecord& record, LPCWSTR wszObjectPath);


	CAssociationHelper	m_assocHelper;          // association Helper
	CConfigQuery		m_cfgQuery;				// query for the class
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assocfilehierarchy.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assocfilehierarchy.h

$Header: $

Abstract:
	Create file hierarchy from selector

Author:
    marcelv 	1/18/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __ASSOCFILEHIERARCHY_H__
#define __ASSOCFILEHIERARCHY_H__

#pragma once

#include "assocbase.h"
#include "associationhelper.h"
#include "cfgquery.h"

class CAssocFileHierarchy : public CAssocBase
{
public:
	CAssocFileHierarchy ();
	virtual ~CAssocFileHierarchy ();

	virtual HRESULT CreateAssocations ();
private:
	CAssocFileHierarchy (const CAssocFileHierarchy& );
	CAssocFileHierarchy& operator= (const CAssocFileHierarchy&);

	
	HRESULT CreateApplicationToConfigFileAssocs ();
	HRESULT CreateWMIAssocForFiles ();

	STConfigStore * m_aConfigStores;	// array with configuration store information
	ULONG m_cPossibleConfigStores;		// number of possible configuration stores
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assoccatalog.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assoccatalog.cpp

$Header: $

Abstract:

Author:
    marcelv 	1/12/2001		Initial Release

Revision History:

--**************************************************************************/
#include "assoccatalog.h"
#include "localconstants.h"
#include "cfgrecord.h"
#include "smartpointer.h"
#include "stringutil.h"


HRESULT
CAssocCatalog::CreateAssocations ()
{
	HRESULT hr = GetAssociationInfo ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get association information for class %s", m_pWQLParser->GetClass ());
		return hr;
	}

	const CWMIProperty * pSelector = m_knownObjectParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		TRACE (L"Unable to retrieve selector property");
		return E_INVALIDARG;
	}


	// find out the name of the table on the other side of the association. We assume
	// that we have to retrieve the Foreign Table Name. We need to compare to ensure
	// that this is actually the other table. If not, we retrieve the primary key table
	// name instead.
	LPCWSTR wszOtherTable = m_assocHelper.GetFKTableName ();
	if (_wcsicmp (wszOtherTable, m_knownObjectParser.GetClass ()) == 0)
	{
		wszOtherTable = m_assocHelper.GetPKTableName ();
	}

	// Get Other reference information

	_bstr_t bstrDatabase;
	_bstr_t bstrTable;

	hr = GetClassInfoForTable (wszOtherTable, bstrDatabase, bstrTable);
	if (FAILED (hr))
	{
		TRACE (L"Unable to retrieve database and table information for class %s", wszOtherTable );
		return hr;
	}

	hr = m_cfgQuery.Init (bstrDatabase, bstrTable, pSelector->GetValue (), m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of cfgQuery failed");
		return hr;
	}

	hr = m_cfgQuery.Execute (0, false, false);
	if (FAILED (hr))
	{
		TRACE (L"Query Execution failed");
		return hr;
	}

	CConfigRecord record;
	hr = m_cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get empty configuration record");
		return hr;
	}

	hr = InitAssocRecord (record, m_knownObjectParser, m_saObjectPath);
	if (FAILED (hr))
	{
		TRACE (L"Unable to initialize association record");
		return hr;
	}


	// find out public wmi column name of other column. We need this to 'put' the right value for
	// WMI
	LPCWSTR wszOtherWMIColName = m_assocHelper.GetPKWMIColName ();
	if (_wcsicmp (wszOtherWMIColName, m_pWQLParser->GetProperty (0)->GetName ()) == 0)
	{
		wszOtherWMIColName = m_assocHelper.GetFKWMIColName ();
	}

	ULONG iCurRow = 0;

	for (;;)
	{
		ULONG cRow;
		hr = m_cfgQuery.GetRowBySearch (iCurRow, record, &cRow);
		if (hr == E_ST_NOMOREROWS)
		{
			hr = S_OK;
			break;
		}
		if (FAILED (hr))
		{
			TRACE (L"GetRowBySearch failed");
			return hr;
		}

		CConfigRecord newRecord;
		hr = m_cfgQuery.GetColumnValues (cRow, newRecord);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get column values");
			return hr;
		}


		hr = CreateAssociationInstance (newRecord, 0, wszOtherWMIColName);
		if (FAILED (hr))
		{
			TRACE (L"Unable to create instance of association");
			return hr;
		}

		iCurRow = cRow + 1;

		// create instance with new record
	}

	return hr;
}

HRESULT 
CAssocCatalog::GetAssociationInfo ()
{
	// loop through the columns and get information for each column
	HRESULT hr = m_spClassObject->BeginEnumeration (WBEM_FLAG_LOCAL_ONLY);
	if (FAILED(hr))
	{
		TRACE (L"BeginEnumeration failed for class %s", m_pWQLParser->GetClass ());
		return hr;
	}

	hr = 0;
	int idx=0;
	while (SUCCEEDED (hr))
	{
		_variant_t varValue;
		CComBSTR bstrName;
		hr = m_spClassObject->Next (0, &bstrName, 0, 0, 0);
		if (hr == WBEM_S_NO_MORE_DATA)
		{
			hr = S_OK;
			break;
		}

		if (FAILED (hr))
		{
			TRACE (L"IWbemClassObject::Next failed in PutInstance");
			return hr;
		}

		CComPtr<IWbemQualifierSet> spPropQualifierSet;
		hr = m_spClassObject->GetPropertyQualifierSet (bstrName, &spPropQualifierSet);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get PropertyQualifierSet for %s", (LPWSTR) bstrName);
			return hr;
		}

		_variant_t varCols;
		hr = spPropQualifierSet->Get (L"Cols", 0, &varCols, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get Cols qualifier for %s", (LPWSTR) bstrName);
			return hr;
		}
		_bstr_t bstrCols = (bstr_t) varCols;

		_variant_t varType;
		hr = spPropQualifierSet->Get (L"CIMTYPE", 0, &varType, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get CIMTYPE qualifier for %s", (LPWSTR) bstrName);
			return hr;
		}

		ASSERT (varType.bstrVal != 0);
		static LPCWSTR wszRef = L"ref:";
		static SIZE_T	 cRefLen = wcslen (wszRef);

		if (wcsncmp (varType.bstrVal, wszRef, cRefLen) != 0)
		{
			TRACE (L"Reference doesn't start with %s", wszRef);
			return E_INVALIDARG;
		}
		_bstr_t bstrType = (LPCWSTR) varType.bstrVal + cRefLen;

	
		if (idx == 0)
		{
			hr = m_assocHelper.SetPKInfo (bstrName, bstrType, bstrCols);
		}
		else
		{
			hr = m_assocHelper.SetFKInfo (bstrName, bstrType, bstrCols);
		}

		if (FAILED (hr))
		{
			TRACE (L"Unable to se PK/FK information");
			return hr;
		}

		idx++;
	}

	// release resources
	hr = m_spClassObject->EndEnumeration ();
	if (FAILED (hr))
	{
		TRACE (L"EndEnumeration failed");
		return hr;
	}

	// we got all the info .. initialize the assocHelper
	hr = m_assocHelper.Init ();
	if (FAILED (hr))
	{
		TRACE (L"Init of AssociationHelper failed");
		return hr;
	}

	return hr;
}


HRESULT
CAssocCatalog::InitAssocRecord (CConfigRecord& record, 
							   const CObjectPathParser& objPathParser,
							   LPCWSTR wszObjectPath)
{
	ASSERT (m_fInitialized);

	HRESULT hr = S_OK;

	bool fIsPrimaryKeyTable = false;
	
	if (_wcsicmp (objPathParser.GetClass (), m_assocHelper.GetPKTableName ()) == 0)
	{
		fIsPrimaryKeyTable = true;
	}

	if (fIsPrimaryKeyTable)
	{
		for (ULONG idx=0; idx < objPathParser.GetPropCount (); ++idx)
		{
			LPCWSTR wszColName;
			const CWMIProperty *pProp = objPathParser.GetProperty (idx);
			// ignore selector property
			if (_wcsicmp (pProp->GetName (), WSZSELECTOR) == 0)
			{
				continue;
			}
		
			ULONG propIdx = m_assocHelper.GetPKIndex (pProp->GetName ());
			if (propIdx == -1)
			{
				// this property is not part of the relation, so ignore it
				continue;
			}

			wszColName = m_assocHelper.GetFKColName (propIdx);
			hr = record.SetValue (wszColName, pProp->GetValue ());
			if (FAILED (hr))
			{
				TRACE (L"Unable to set record value");
				return hr;
			}
		}
	}
	else
	{
		hr = GetSingleFKRecord (record, wszObjectPath);
		if (FAILED (hr))
		{
			TRACE (L"Unable to Get object %s", wszObjectPath);
			return hr;
		}	
	}

	return hr;
}

HRESULT
CAssocCatalog::GetSingleFKRecord (CConfigRecord& record, LPCWSTR wszObjectPath)
{
	CComPtr<IWbemClassObject> spObject;
	HRESULT hr = S_OK;
	
	hr = m_spNamespace->GetObject((LPWSTR)wszObjectPath, 
											0, 
											m_spCtx, 
											&spObject, 
											0); 

	if (FAILED (hr))
	{
		TRACE (L"Unable to get object instance: %s", wszObjectPath);
		return hr;
	}

	for (ULONG idx=0; idx<m_assocHelper.ColumnCount (); ++idx)
	{
		LPCWSTR wszFKColName = m_assocHelper.GetFKColName (idx);
		LPCWSTR wszPKColName = m_assocHelper.GetPKColName (idx);
		_variant_t varValue;

		hr = spObject->Get ((_bstr_t) wszFKColName, 0, &varValue, 0, 0);
		if (FAILED (hr))
		{
			TRACE (L"Get property failed. Prop=%s", wszFKColName);
			return hr;
		}

		hr = record.SetValue (wszPKColName, varValue);
		if (FAILED (hr))
		{
			TRACE (L"Unable to set record value");
			return hr;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\associationhelper.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    associationhelper.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/14/2000		Initial Release

Revision History:

--**************************************************************************/

#include "associationhelper.h"

//=================================================================================
// Function: CAssociationHelper::CAssociationHelper
//
// Synopsis: Constructor
//=================================================================================
CAssociationHelper::CAssociationHelper ()
{
	m_cNrCols			= 0;
	m_aCols				= 0;
	m_wszPKTable		= 0;
	m_wszPKWMIColName	= 0;
	m_wszPKCols			= 0;
	m_wszFKTable		= 0;
	m_wszFKWMIColName	= 0;
	m_wszFKCols			= 0;
	m_fInitialized		= false;
}

//=================================================================================
// Function: CAssociationHelper::~CAssociationHelper
//
// Synopsis: Destructor. Releases memory
//=================================================================================
CAssociationHelper::~CAssociationHelper ()
{
	delete [] m_aCols;
	m_aCols = 0;

	delete [] m_wszPKTable;
	m_wszPKTable = 0;

	delete [] m_wszPKWMIColName;
	m_wszPKWMIColName = 0;

	delete [] m_wszPKCols;
	m_wszPKCols = 0;

	delete [] m_wszFKTable;
	m_wszFKTable = 0;

	delete [] m_wszFKWMIColName;
	m_wszFKWMIColName = 0;

	delete [] m_wszFKCols;
	m_wszFKCols = 0;
}

//=================================================================================
// Function: CAssociationHelper::SetPKInfo
//
// Synopsis: Sets the primary key information
//
// Arguments: [wszTable] - Primary Key Table
//            [wszCols] - Columns in Primary Key Table that make up primary key
//            
// Return Value: hr
//=================================================================================
HRESULT
CAssociationHelper::SetPKInfo (LPCWSTR wszWMIColName, LPCWSTR wszTable, LPCWSTR wszCols)
{
	ASSERT (wszTable != 0);
	ASSERT (wszCols != 0);
	ASSERT (m_wszPKTable == 0);
	ASSERT (m_wszPKCols == 0);

	m_wszPKTable = new WCHAR [wcslen (wszTable) + 1];
	if (m_wszPKTable == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszPKTable, wszTable);

	m_wszPKCols = new WCHAR [wcslen (wszCols) + 1];
	if (m_wszPKCols == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszPKCols, wszCols);

	m_wszPKWMIColName = new WCHAR[wcslen(wszWMIColName) + 1];
	if (m_wszPKWMIColName == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszPKWMIColName, wszWMIColName);

	return S_OK;
}

//=================================================================================
// Function: CAssociationHelper::SetFKInfo
//
// Synopsis: Set the Foreign Key Table information
//
// Arguments: [wszTable] - Foreign Key Table name
//            [wszCols] - Columns in Foreign Key Table that make up the foreign key
//=================================================================================
HRESULT
CAssociationHelper::SetFKInfo (LPCWSTR wszWMIColName, LPCWSTR wszTable, LPCWSTR wszCols)
{
	ASSERT (wszTable != 0);
	ASSERT (wszCols != 0);
	ASSERT (m_wszFKTable == 0);
	ASSERT (m_wszFKCols == 0);

	m_wszFKTable = new WCHAR [wcslen (wszTable) + 1];
	if (m_wszFKTable == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszFKTable, wszTable);

	m_wszFKCols = new WCHAR [wcslen (wszCols) + 1];
	if (m_wszFKCols == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszFKCols, wszCols);

	m_wszFKWMIColName = new WCHAR[wcslen(wszWMIColName) + 1];
	if (m_wszFKWMIColName == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszFKWMIColName, wszWMIColName);

	return S_OK;
}

//=================================================================================
// Function: CAssociationHelper::Init
//
// Synopsis: Initilaizes the association helper. Should be called after Primary Key
//           and Foreign Key information is set
//=================================================================================
HRESULT
CAssociationHelper::Init ()
{
	ASSERT (m_wszPKCols != 0);
	ASSERT (m_wszFKCols != 0);

	// columns are stored as "Col1 Col2 Col3". We parse this for both primary key
	// and foreign key, so that we can store them as arrays for easier manipulation

	m_cNrCols = 0;

	if (m_wszPKCols[0] == L'\0' || m_wszFKCols[0] == L'\0')
	{ 
		m_cNrCols = 0;
	}
	else
	{
		for (LPWSTR pFinder = m_wszPKCols;
			 pFinder != 0;
			 pFinder = wcschr (pFinder + 1, L' '))
			 {
				 ++m_cNrCols;
			 }

		ASSERT (m_cNrCols != 0);

		m_aCols = new CAssocColumn[m_cNrCols];
		if (m_aCols == 0)
		{
			return E_OUTOFMEMORY;
		}

		LPWSTR pPKFinder = m_wszPKCols;
		LPWSTR pFKFinder = m_wszFKCols;
		for (ULONG idx=0; idx < m_cNrCols; ++idx)
		{
			ASSERT (pPKFinder != 0);
			ASSERT (pFKFinder != 0);
			m_aCols[idx].wszPKColName = pPKFinder;
			m_aCols[idx].wszFKColName = pFKFinder;
			pPKFinder = wcschr (pPKFinder + 1, L' ');
			if (pPKFinder != 0)
			{
				*pPKFinder = L'\0';
				++pPKFinder;
			}

			pFKFinder = wcschr (pFKFinder + 1, L' ');
			if (pFKFinder != 0)
			{
				*pFKFinder = L'\0';
				++pFKFinder;
			}
		}
	}

	m_fInitialized = true;

	return S_OK;
}

//=================================================================================
// Function: CAssociationHelper::ColumnCount
//
// Synopsis: Returns the number of columns that are part of the primary key
//=================================================================================
ULONG 
CAssociationHelper::ColumnCount ()
{
	ASSERT (m_fInitialized);

	return m_cNrCols;
}

//=================================================================================
// Function: CAssociationHelper::GetFKColName
//
// Synopsis: Get the name of of foreign key column
//
// Arguments: [i_idx] - index of foreign key column to retrieve name for
//            
// Return Value: name of the foreign key column
//=================================================================================
LPCWSTR 
CAssociationHelper::GetFKColName (ULONG i_idx) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >= 0 && i_idx < m_cNrCols);

	return m_aCols[i_idx].wszFKColName ;
}

//=================================================================================
// Function: CAssociationHelper::GetFKWMIColName
//
// Synopsis: Gets the WMI column name of the foreign key column
//=================================================================================
LPCWSTR 
CAssociationHelper::GetFKWMIColName () const
{
	ASSERT (m_fInitialized);

	return m_wszFKWMIColName;
}

//=================================================================================
// Function: CAssociationHelper::GetFKIndex
//
// Synopsis: Get the index of a foreign key column by name
//
// Arguments: [i_wszFKColName] - name of the foreign key column
//            
// Return Value: index of foreign key column, or -1 if not found
//=================================================================================
ULONG	
CAssociationHelper::GetFKIndex (LPCWSTR i_wszFKColName) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszFKColName != 0);

	for (ULONG idx=0; idx<m_cNrCols; ++idx)
	{
		if (_wcsicmp (i_wszFKColName, m_aCols[idx].wszFKColName) == 0)
		{
			return idx;
		}
	}

	return (ULONG) -1;
}


//=================================================================================
// Function: CAssociationHelper::GetPKColName
//
// Synopsis: Get the name of a primary key column by column index
//
// Arguments: [i_idx] - index of column for which we want to retrieve the name
//            
// Return Value: name of primary key column
//=================================================================================
LPCWSTR 
CAssociationHelper::GetPKColName (ULONG i_idx) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >= 0 && i_idx < m_cNrCols);

	return m_aCols[i_idx].wszPKColName;
}


//=================================================================================
// Function: CAssociationHelper::GetPKWMIColName
//
// Synopsis: Gets the WMI column name of the primary key column
//=================================================================================
LPCWSTR 
CAssociationHelper::GetPKWMIColName () const
{
	ASSERT (m_fInitialized);

	return m_wszPKWMIColName;
}

//=================================================================================
// Function: CAssociationHelper::GetPKIndex
//
// Synopsis: Get index of primary key column by searching for the name
//
// Arguments: [i_wszPKColName] - name of primary key column
//            
// Return Value: valid index when found, -1 if not found
//=================================================================================
ULONG	
CAssociationHelper::GetPKIndex (LPCWSTR i_wszPKColName) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszPKColName != 0);

	for (ULONG idx=0; idx<m_cNrCols; ++idx)
	{
		if (_wcsicmp (i_wszPKColName, m_aCols[idx].wszPKColName) == 0)
		{
			return idx;
		}
	}

	return (ULONG) -1;
}

//=================================================================================
// Function: CAssociationHelper::GetPKTableName
//
// Synopsis: Gets the name of the primary key table
//=================================================================================
LPCWSTR
CAssociationHelper::GetPKTableName () const
{
	ASSERT (m_fInitialized);

	return m_wszPKTable;
}

//=================================================================================
// Function: CAssociationHelper::GetFKTableName
//
// Synopsis: Gets the name of the foreign table
//=================================================================================
LPCWSTR
CAssociationHelper::GetFKTableName () const
{
	ASSERT (m_fInitialized);

	return m_wszFKTable;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\associationhelper.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    associationhelper.h

$Header: $

Abstract:

Author:
    marcelv 	11/14/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __ASSOCIATIONHELPER_H__
#define __ASSOCIATIONHELPER_H__

#pragma once

#include "catmacros.h"

class CAssociationHelper
{
public:
	CAssociationHelper ();
	~CAssociationHelper ();

	HRESULT Init ();

	HRESULT SetPKInfo (LPCWSTR wszWMIColName, LPCWSTR wszTable, LPCWSTR wszCols);
	HRESULT SetFKInfo (LPCWSTR wszWMIColName, LPCWSTR wszTable, LPCWSTR wszCols);

	ULONG ColumnCount ();

	LPCWSTR GetFKTableName () const;
	LPCWSTR GetFKWMIColName () const;
	LPCWSTR GetFKColName (ULONG i_idx) const;
	ULONG	GetFKIndex (LPCWSTR i_wszFKColName) const;

	LPCWSTR GetPKTableName () const;
	LPCWSTR GetPKWMIColName () const;
	LPCWSTR GetPKColName (ULONG i_idx) const;
	ULONG	GetPKIndex (LPCWSTR i_wszPKColName) const;
private:
	struct CAssocColumn
	{
		LPCWSTR wszPKColName;	// primary key column name
		LPCWSTR wszFKColName;	// foreign key column name
	};

	ULONG			m_cNrCols;			// number of columns
	LPWSTR			m_wszPKTable;		// primary key table name
	LPWSTR			m_wszPKCols;		// primary key column information
	LPWSTR          m_wszPKWMIColName;  // WMI column name
	LPWSTR			m_wszFKTable;		// foreign key table name
	LPWSTR			m_wszFKCols;		// foreign key column information
	LPWSTR          m_wszFKWMIColName;  // WMI column name
	CAssocColumn *  m_aCols;			// column by column information
	bool			m_fInitialized;		// are we initialized?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assocfilehierarchy.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assocfilehierarchy.cpp

$Header: $

Abstract:

Author:
    marcelv 	1/18/2001		Initial Release

Revision History:

--**************************************************************************/

#include "assocfilehierarchy.h"
#include "smartpointer.h"
#include "transformerfactory.h"
#include "stringutil.h"

//=================================================================================
// Function: CAssocFileHierarchy::CAssocFileHierarchy
//
// Synopsis: Default Constructor
//=================================================================================
CAssocFileHierarchy::CAssocFileHierarchy ()
{
	m_aConfigStores = 0;
	m_cPossibleConfigStores = 0;
}

//=================================================================================
// Function: CAssocFileHierarchy::~CAssocFileHierarchy
//
// Synopsis: Default Destructor
//=================================================================================
CAssocFileHierarchy::~CAssocFileHierarchy ()
{
	// every tranformer allocates memory to store the name of the configuration store
	// in the query.pData member. The merge coordinator is responsible for deallocating
	// this memory.
	for (ULONG idx=0; idx != m_cPossibleConfigStores; ++idx)
	{
		delete [] m_aConfigStores[idx].wszLogicalPath;
		for (ULONG jdx=0; jdx < m_aConfigStores[idx].cNrQueryCells; ++jdx)
		{
			delete [] m_aConfigStores[idx].aQueryCells[jdx].pData;
		}
		delete [] m_aConfigStores[idx].aQueryCells;
	}

	delete [] m_aConfigStores;
	m_aConfigStores = 0;
}

//=================================================================================
// Function: CAssocFileHierarchy::CreateAssocations
//
// Synopsis: Creates the assocation. For each selector, it finds the files that contribute
//           and creates an assocation for each file that was found
//
// Return Value: 
//=================================================================================
HRESULT
CAssocFileHierarchy::CreateAssocations ()
{
	HRESULT hr = S_OK;
	const CWQLProperty * pProp = m_pWQLParser->GetProperty (0);
	ASSERT (pProp != 0);

	// we only support application -> files
	if (_wcsicmp (pProp->GetName (), L"ConfigNode") == 0)
	{
		hr = CreateApplicationToConfigFileAssocs ();
		if (FAILED (hr))
		{
			TRACE (L"Unable to application to config hierarchy associations");
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CAssocFileHierarchy::CreateApplicationToConfigFileAssocs
//
// Synopsis: Retrieves the transformer, get the possible files from the transformer, and
//           for each file, create a new assocation instance
//=================================================================================
HRESULT
CAssocFileHierarchy::CreateApplicationToConfigFileAssocs ()
{
	// get the selector, and find the protocol used
	const CWMIProperty *pSelector = m_knownObjectParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		TRACE (L"Unable to find selector");
		return E_INVALIDARG;
	}

	LPCWSTR wszSelector = pSelector->GetValue ();

	static LPCWSTR wszProtocolSep = L"://";
	static SIZE_T cProtocolSep = wcslen (wszProtocolSep);

	LPCWSTR pProtocolEnd = wcsstr(wszSelector, wszProtocolSep);
	if (pProtocolEnd == 0)
	{
		TRACE (L"Unable to find protocol for selector");
		return E_ST_INVALIDSELECTOR;
	}

	SIZE_T cNrChars = pProtocolEnd - wszSelector;
	TSmartPointerArray<WCHAR> wszProtocol = new WCHAR[cNrChars + 1];
	if (wszProtocol == 0)
	{
		return E_OUTOFMEMORY;
	}

	wcsncpy (wszProtocol, wszSelector, cNrChars);
	wszProtocol[cNrChars] = L'\0';

	// get the transformer, initialize it, and get the names of the possible configuration
	// stores
	CComPtr<ISimpleTableTransform> spTransformer;
	CTransformerFactory transformerFactory;

	HRESULT hr = transformerFactory.GetTransformer (m_spDispenser, 
													wszProtocol, 
													&spTransformer);
	if (FAILED (hr))
	{
		TRACE (L"GetTransformer failed in AssocFileHierarchy");
		return hr;
	}

	ULONG cRealConfigStores;
	hr = spTransformer->Initialize (m_spDispenser, 
									wszProtocol,
									pProtocolEnd + cProtocolSep,
									&cRealConfigStores,
									&m_cPossibleConfigStores);

	if (FAILED (hr))
	{
		TRACE (L"Transformer Initialize failed");
		return hr;
	}


	if (m_cPossibleConfigStores == 0)
	{
		return S_OK;
	}

	m_aConfigStores = new STConfigStore[m_cPossibleConfigStores];
	if (m_aConfigStores == 0)
	{
		return E_OUTOFMEMORY;
	}

	hr = spTransformer->GetPossibleConfigStores (m_cPossibleConfigStores, m_aConfigStores);
	if (FAILED (hr))
	{
		TRACE (L"GetPossibleConfigStores failed in FileHierarchyAssoc");
		return hr;
	}

	hr = CreateWMIAssocForFiles ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to create WMI Assocations");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CAssocFileHierarchy::CreateWMIAssocForFiles
//
// Synopsis: Create Assocations from the ConfigStore array. For each element in the array,
//           an instance of the assocation is created.
//=================================================================================
HRESULT
CAssocFileHierarchy::CreateWMIAssocForFiles ()
{
	ASSERT (m_aConfigStores != 0);
	ASSERT (m_cPossibleConfigStores > 0);

	HRESULT hr = S_OK;

	for (ULONG idx=0; idx < m_cPossibleConfigStores; ++idx)
	{
		const STConfigStore *pConfigStore = &m_aConfigStores[idx];

		LPCWSTR wszFileName = L"";
		LPCWSTR wszLocation = L"";
		// find the file components
		for (ULONG jdx=0; jdx<pConfigStore->cNrQueryCells; ++jdx)
		{
			STQueryCell *pQueryCell = &pConfigStore->aQueryCells[jdx];
			if (pQueryCell->iCell == iST_CELL_FILE)
			{
				wszFileName = (LPCWSTR) pQueryCell->pData;
			}
			else if (pQueryCell->iCell == iST_CELL_LOCATION)
			{
				wszLocation  = (LPCWSTR) pQueryCell->pData;
			}
		}

		if (wszFileName[0] == L'\0')
		{
			TRACE (L"No filename specified in selector query cells");
			return E_INVALIDARG;
		}

		// we got the filename, lets create the wmi instance
		// create a new instance of the assocation
		CComPtr<IWbemClassObject> spNewInst;
		hr = m_spClassObject->SpawnInstance(0, &spNewInst);
		if (FAILED (hr))
		{
			TRACE (L"Unable to create new instance for class %s", m_pWQLParser->GetClass ());
			return hr;
		}

		// ConfigNode is part of the query, so is easy to set
		_variant_t varValue = m_pWQLParser->GetProperty (0)->GetValue();

		hr = spNewInst->Put(L"ConfigNode", 0, &varValue, 0);
		if (FAILED (hr))
		{
			TRACE (L"WMI Put property failed. Property=%s, value=%s",  m_knownObjectParser.GetClass (), varValue.bstrVal);
			return hr;
		}

		TSmartPointerArray<WCHAR> saFileName = CWMIStringUtil::AddBackSlashes (wszFileName);
		if (saFileName == 0)
		{
			return E_OUTOFMEMORY;
		}

		TSmartPointerArray<WCHAR> saLocation = CWMIStringUtil::AddBackSlashes (wszLocation);
		if (saLocation == 0)
		{
			return E_OUTOFMEMORY;
		}

		_bstr_t bstrConfigFile = "ConfigurationFile.Selector=\"file://";
		bstrConfigFile += (LPWSTR) saFileName; // need to add double backslash
		bstrConfigFile += "\",Location=\"";
		bstrConfigFile += (LPWSTR) saLocation;
		bstrConfigFile += "\"";

		_variant_t varConfigFileName = bstrConfigFile;

		hr = spNewInst->Put(L"ConfigFile", 0, &varConfigFileName, 0);
		if (FAILED (hr))
		{
			TRACE (L"WMI Put property failed.");
			return hr;
		}

		IWbemClassObject* pNewInstRaw = spNewInst;
		hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);
		if (FAILED (hr))
		{
			TRACE (L"WMI Indicate failed");
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assoclocation.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assoclocation.h

$Header: $

Abstract:
	Location Assocations class

Author:
    marcelv 	1/12/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __ASSOCLOCATION_H__
#define __ASSOCLOCATION_H__

#pragma once

#include "assocbase.h"

class CAssocLocation : public CAssocBase
{
public:
	CAssocLocation ();
	virtual ~CAssocLocation ();
	virtual HRESULT CreateAssocations ();

private:
	CAssocLocation (const CAssocLocation& );
	CAssocLocation& operator= (CAssocLocation& );

	HRESULT CreateConfigToLocationAssocs ();
	HRESULT CreateLocationToConfigAssocs ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assoctypes.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assoctypes.h

$Header: $

Abstract:

Author:
    marcelv 	1/18/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __ASSOCTYPES_H__
#define __ASSOCTYPES_H__

#pragma once

static LPCWSTR g_wszAssocType				= L"AssocType";
static LPCWSTR g_wszAssocTypeCatalog		= L"catalog";
static LPCWSTR g_wszAssocTypeLocation		= L"location";
static LPCWSTR g_wszAssocTypeAppUnmerged	= L"appunmerged";
static LPCWSTR g_wszAssocTypeAppmerged		= L"appmerged";
static LPCWSTR g_wszAssocTypeFileHierarchy  = L"filehierarchy";
static LPCWSTR g_wszAssocTypeWebAppChild    = L"webappchild";
static LPCWSTR g_wszAssocTypeWebAppParent   = L"webappparent";

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assoclocation.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assoclocation.cpp

$Header: $

Abstract:
	Creates assocations for the location class

Author:
    marcelv 	1/12/2001		Initial Release

Revision History:

--**************************************************************************/

#include "assoclocation.h"
#include "localconstants.h"
#include "cfgQuery.h"

static LPCWSTR wszLocation	= L"location";
static LPCWSTR wszPath		= L"path";

CAssocLocation::CAssocLocation ()
{
	// nothing for the moment
}

CAssocLocation::~CAssocLocation ()
{
	// nothing for the moment
}

//=================================================================================
// Function: CAssocLocation::CreateAssocations
//
// Synopsis: We have two possible assocations:
//           1) From Location To Config Class
//           2) From Config Class To Location.
//           The function used the class defined in the object path to find out in which
//           direction the assocation should be created and calls the appropriate helper
//           function to do the dirty work
//=================================================================================
HRESULT
CAssocLocation::CreateAssocations ()
{
	HRESULT hr = S_OK;

	// selector must start with file://, else we reject the whole thing
	const CWMIProperty *pSelector = m_knownObjectParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		TRACE (L"No selector specified in CAssocLocation::CreateAssocations");
		return E_INVALIDARG;
	}

	static SIZE_T cLenFileSelector = wcslen (WSZFILESELECTOR);
	if (wcsncmp (pSelector->GetValue (), WSZFILESELECTOR, cLenFileSelector) != 0)
	{
		TRACE (L"Only file selector is valid for location");
		// we return S_OK here, because there are no valid assocations in this case
		return S_OK;
	}

	if (_wcsicmp (m_knownObjectParser.GetClass (), wszLocation) != 0)
	{
		// not location, so config -> location
		hr = CreateConfigToLocationAssocs ();
		if (FAILED (hr))
		{
			TRACE (L"Unable to create config to location associations");
			return hr;
		}
	}
	else
	{
		// location -> config
		hr = CreateLocationToConfigAssocs ();
		if (FAILED (hr))
		{
			TRACE (L"Unable to create location to config associations");
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CAssocLocation::CreateConfigToLocationAssocs
//
// Synopsis: Create the location association between a config class and a location class
//           We know that there can be at most one assocation in case the config selector
//           is of the form <selector>#<path>. If this is the case, a single assocation is
//           created. In all other cases, nothing is done.
//=================================================================================
HRESULT
CAssocLocation::CreateConfigToLocationAssocs ()
{
	ASSERT (m_fInitialized);

	const CWMIProperty *pSelector = m_knownObjectParser.GetPropertyByName (WSZSELECTOR);
	ASSERT (pSelector != 0);

	TSmartPointerArray<WCHAR> wszSelector = new WCHAR [wcslen(pSelector->GetValue()) + 1];
	if (wszSelector == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (wszSelector, pSelector->GetValue ());

	LPWSTR pHash = wcsrchr(wszSelector, L'#');
	if (pHash == 0)
	{
		// no hash, so no location association
		return S_OK;
	}

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;

	HRESULT hr = GetClassInfoForTable (wszLocation, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get db/table information for class %s", wszLocation);
		return hr;
	}

	// we need to issue a query to get an empty configuration record.
	CConfigQuery query;
	hr = query.Init ((LPCWSTR) bstrDBName, (LPCWSTR) bstrTableName, wszSelector, m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Unable to configure config query");
		return hr;
	}

	CConfigRecord record;
	hr = query.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get config record");
		return hr;
	}

	*pHash = L'\0';

	hr = record.SetValue (wszPath, pHash + 1);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set value for path property");
		return hr;
	}

	// we need to sync the record values, because createassocationinstance assumes
	// that the values inside record contain the correct information. Without this
	// the program will crash inside the CreateAssocationInstance function.
	hr = record.SyncValues ();
	if (FAILED (hr))
	{
		TRACE (L"Sync of record value failed");
		return hr;
	}

	hr = CreateAssociationInstance (record, wszSelector, L"Node");
	if (FAILED (hr))
	{
		TRACE (L"Creation of location assoc with selector %s failed", wszSelector);
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CAssocLocation::CreateLocationToConfigAssocs
//
// Synopsis: Creates the assocations from location class to any configuration class.
//           It uses the name in the assocation to query the catalog for the configuration
//           classes that are defined for this location. The selector that is used
//           in this case is constructed by using the location selector and location path
//           (<loc.selector>#<loc.path>
//=================================================================================
HRESULT
CAssocLocation::CreateLocationToConfigAssocs ()
{
	ASSERT (m_fInitialized);

	const CWMIProperty *pSelector = m_knownObjectParser.GetPropertyByName (WSZSELECTOR);
	const CWMIProperty *pPath     = m_knownObjectParser.GetPropertyByName (wszPath);
	ASSERT (pSelector != 0);
	ASSERT (pPath != 0);

	SIZE_T iTotalSize = wcslen(pSelector->GetValue ()) + wcslen(pPath->GetValue ()) + 2; // hash and end of string
	TSmartPointerArray<WCHAR> wszSelector = new WCHAR [iTotalSize];
	if (wszSelector == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	wsprintf (wszSelector, L"%s#%s", pSelector->GetValue(), pPath->GetValue ());

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;
	_bstr_t bstrConfigClass;

	HRESULT hr = GetConfigClass (L"ConfigClass", bstrConfigClass);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get configuration class in location association");
		return hr;
	}

	hr = GetClassInfoForTable ((LPCWSTR) bstrConfigClass, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get db/table information for class %s", wszLocation);
		return hr;
	}

	CConfigQuery query;
	hr = query.Init ((LPCWSTR) bstrDBName, (LPCWSTR) bstrTableName, wszSelector, m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Unable to configure config query");
		return hr;
	}

	hr = query.Execute (0, false, false);
	if (FAILED (hr))
	{
		TRACE (L"Execution of query failed");
		return hr;
	}

	for (ULONG idx=0; idx < query.GetRowCount (); ++idx)
	{
		CConfigRecord record;
		hr = query.GetColumnValues (idx, record);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get config record");
			return hr;
		}

		hr = CreateAssociationInstance (record, wszSelector, L"ConfigClass");
		if (FAILED (hr))
		{
			TRACE (L"Unable to create assocation instance");
			return hr;
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assocwebappchild.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assocwebappchild.cpp

$Header: $

Abstract:
	Creates child/parent assocation for webapplications

Author:
    marcelv 	2/9/2001		Initial Release

Revision History:

--**************************************************************************/

#include "assocwebappchild.h"
#include "assoctypes.h"

static LPCWSTR wszIISW3SVC = L"iis://localhost/W3SVC/";
static LPCWSTR wszLMW3SVC  = L"/LM/W3SVC/";
static SIZE_T  cIISW3SVC   = wcslen (wszIISW3SVC);
static SIZE_T  cLMW3SVC    = wcslen (wszLMW3SVC);


//=================================================================================
// Function: CAssocWebAppChild::CAssocWebAppChild
//
// Synopsis: Constructor
//=================================================================================
CAssocWebAppChild::CAssocWebAppChild ()
{
	m_fGetChildren = false;
}

//=================================================================================
// Function: CAssocWebAppChild::~CAssocWebAppChild
//
// Synopsis: Destructor
//=================================================================================
CAssocWebAppChild::~CAssocWebAppChild ()
{
}


//=================================================================================
// Function: CAssocWebAppChild::CreateAssocations
//
// Synopsis: Creates the assocations. Because the assocations are one-way (from web-app to 
//           children or parent), we only check for Node. If Node is not specified, we simply
//           return
//=================================================================================
HRESULT
CAssocWebAppChild::CreateAssocations ()
{
	HRESULT hr = S_OK;
	const CWQLProperty * pProp = m_pWQLParser->GetProperty (0);
	ASSERT (pProp != 0);

	if (_wcsicmp (pProp->GetName (), L"Node") == 0)
	{
		hr = GetAssocType (); // sets m_fGetChildren
		if (FAILED (hr))
		{
			TRACE (L"Unable to get association type");
			return hr;
		}
	
		if (m_fGetChildren)
		{
			hr = CreateChildAssocs ();
		}
		else
		{
			hr = CreateParentAssoc ();
		}

		if (FAILED (hr))
		{
			TRACE (L"Unable to create parent/child assocations for web-app");
			return hr;
		}
	}

	return hr;
}


//=================================================================================
// Function: CAssocWebAppChild::GetAssocType
//
// Synopsis: Gets the assocation type from the class qualifier, and sets the boolean 
//           m_fGetChildren.
//=================================================================================
HRESULT
CAssocWebAppChild::GetAssocType ()
{
	ASSERT (m_fInitialized);

	CComPtr<IWbemQualifierSet> spPropQualifierSet;
	HRESULT hr = m_spClassObject->GetQualifierSet (&spPropQualifierSet);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get QualifierSet for class %s", m_pWQLParser->GetClass ());
		return hr;
	}

	_variant_t varAssocType;
	hr = spPropQualifierSet->Get (L"AssocType", 0, &varAssocType, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get AssocType qualifier for class %s", m_pWQLParser->GetClass ());
		return hr;
	}

	ASSERT (varAssocType.vt == VT_BSTR);

	LPCWSTR wszAssocType = varAssocType.bstrVal;
	if (_wcsicmp (wszAssocType, g_wszAssocTypeWebAppChild) == 0)
	{
		m_fGetChildren = true;
	}
	else
	{
		ASSERT (_wcsicmp (wszAssocType, g_wszAssocTypeWebAppParent) == 0);
	}

	_bstr_t bstrNodeType;
	hr = GetConfigClass (L"Node", bstrNodeType);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get configuration class in webapp parent/child association");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CAssocWebAppChild::CreateChildAssocs
//
// Synopsis: Create child webapps assocations. Loop through the metabase, and find the
//           subkeys of the current webapp. For each subkey, check if it has an approot
//           property. If it has, we need to create an instance of a webapp assocation.
//=================================================================================
HRESULT
CAssocWebAppChild::CreateChildAssocs ()
{
	HRESULT hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
							  IID_IMSAdminBase, (void **) &m_spAdminBase);
	if (FAILED (hr))
	{
		TRACE (L"CoCreateInstance failed for CLSID_MSAdminBase, interface IID_IMSAdminBase");
		return hr;
	}

	// m_knownObjectParser contains information.
	const CWMIProperty * pSelector = m_knownObjectParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		return E_INVALIDARG;
	}

	LPCWSTR wszSelector = pSelector->GetValue ();

	if (_wcsnicmp (wszSelector, wszIISW3SVC, cIISW3SVC) != 0)
	{
		TRACE (L"Selector should start with iis://localhost/w3svc");
		return E_INVALIDARG;
	}

	SIZE_T cSelectorLen = wcslen (wszSelector);
	if (wszSelector[cSelectorLen - 1] == L'\\' || wszSelector[cSelectorLen - 1] == L'/')
	{
		TRACE (L"Selector for webapplication cannot end with backslash");
		return E_ST_INVALIDSELECTOR;
	}

	// Replace iis://localhost with LM (so metabase stuff works)
	TSmartPointerArray<WCHAR> wszMBSelector = new WCHAR[cSelectorLen + 1 - cIISW3SVC + cLMW3SVC + 1]; // +1 for possible backslash
	if (wszMBSelector == 0)
	{
		return E_OUTOFMEMORY;
	}
	wsprintf (wszMBSelector, L"%s%s", wszLMW3SVC, wszSelector + cIISW3SVC);

	// loop through all the subkeys
	WCHAR wszSubKey[METADATA_MAX_NAME_LEN];
	for (ULONG idx=0; ; idx++)
	{
		hr = m_spAdminBase->EnumKeys (METADATA_MASTER_ROOT_HANDLE,
						   wszMBSelector,
						   wszSubKey,
						   idx);

		if (hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
		{
			hr = S_OK;
			break;
		}

		if (FAILED (hr))
		{
			TRACE (L"EnumKeys failed for selector %s and subkey %s", wszMBSelector, wszSubKey);
			return hr;
		}

		// add subkey to selector and check if it is an approot
		TSmartPointerArray<WCHAR> wszNewPath = new WCHAR [wcslen (wszSubKey) + wcslen (wszMBSelector) + 2];
		if (wszNewPath == 0)
		{
			return E_OUTOFMEMORY;
		}
		wsprintf (wszNewPath, L"%s/%s", wszMBSelector, wszSubKey);

		hr = CreateInstanceForAppRoot (wszNewPath, L"ChildNode");
		if (FAILED (hr))
		{
			TRACE (L"CreateInstanceForAppRoot failed");
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CAssocWebAppChild::CreateParentAssoc
//
// Synopsis: Create parent webapp if it exists. Use the selector, find the last dir, chop
//           it of, and check if the resulting MB path is an approot. If so, create an assocation
//           else do nothing
//=================================================================================
HRESULT
CAssocWebAppChild::CreateParentAssoc ()
{
	HRESULT hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
							  IID_IMSAdminBase, (void **) &m_spAdminBase);
	if (FAILED (hr))
	{
		TRACE (L"CoCreateInstance failed for CLSID_MSAdminBase, interface IID_IMSAdminBase");
		return hr;
	}

	// m_knownObjectParser contains information.
	const CWMIProperty * pSelector = m_knownObjectParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		return E_INVALIDARG;
	}

	// copy and replace iis://localhost with LM
	LPCWSTR wszSelector = pSelector->GetValue ();
	TSmartPointerArray<WCHAR> saMBSelector = new WCHAR[wcslen (wszSelector) + 1 - cIISW3SVC + cLMW3SVC];
	if (saMBSelector == 0)
	{
		return E_OUTOFMEMORY;
	}
	wsprintf (saMBSelector, L"%s%s", wszLMW3SVC, wszSelector + cIISW3SVC);
	
	// remove slash at the end, and search for last slash, to chop off the last directory
	SIZE_T cMBSelLen = wcslen (saMBSelector);
	if (saMBSelector[cMBSelLen - 1] == L'/')
	{
		saMBSelector [cMBSelLen - 1] = L'\0';
	}

	LPWSTR pLastDirStart = wcsrchr (saMBSelector, L'/');
	if (pLastDirStart != 0)
	{
		*pLastDirStart = L'\0';
	}

	hr = CreateInstanceForAppRoot (saMBSelector, L"Parent");
	if (FAILED (hr))
	{
		TRACE (L"IsAppRoot failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CAssocWebAppChild::CreateInstanceForAppRoot
//
// Synopsis: Create an webappassocation instance if i_wszNewInstance is an approot. If
//           not, it simply returns without creating anything
//
// Arguments: [i_wszNewInstance] - MB path for which we want to create a new instance
//            [i_wszChildOrParent] - Do we create a child or a parent (makes it easy to use
//                                   the function for both child and parent creation
//=================================================================================
HRESULT 
CAssocWebAppChild::CreateInstanceForAppRoot (LPCWSTR i_wszNewInstance, LPCWSTR i_wszChildOrParent)
{
	ASSERT (i_wszNewInstance != 0);
	ASSERT (i_wszChildOrParent != 0);


	// are we an approot?
	WCHAR wszResult[1024];
	DWORD dwRequired;

	METADATA_RECORD resRec;
	resRec.dwMDIdentifier	= MD_APP_ROOT;
	resRec.dwMDDataLen		= sizeof (wszResult)/sizeof(WCHAR);
	resRec.pbMDData			= (BYTE *)wszResult;
	resRec.dwMDAttributes	= 0;
	resRec.dwMDDataType		= STRING_METADATA;

	HRESULT hr = m_spAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, i_wszNewInstance, 
										 &resRec, &dwRequired);
	if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND))
	{
		// APPROOT doesn't exist for this key. This is ok, simply return in this case
		return S_OK;
	}

	if (FAILED (hr))
	{
		TRACE (L"GetData failed for key %s", i_wszNewInstance);
		return hr;
	}

	// create a new instance of the assocation
	CComPtr<IWbemClassObject> spNewInst;
	hr = m_spClassObject->SpawnInstance(0, &spNewInst);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class %s", m_pWQLParser->GetClass ());
		return hr;
	}

	// Node is part of the query, so is easy to set
	_variant_t varValue = m_pWQLParser->GetProperty (0)->GetValue();

	hr = spNewInst->Put(L"Node", 0, &varValue, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%s",  m_knownObjectParser.GetClass (), varValue.bstrVal);
		return hr;
	}

	// convert /LM to iis://localhost in i_wszNewInstance and add a slash at the end
	_bstr_t bstrValue = "WebApplication.Selector=\"iis://localhost";
	bstrValue += (i_wszNewInstance + 3);
	bstrValue += L"\"";
	_variant_t varNewValue = bstrValue;

	hr = spNewInst->Put(i_wszChildOrParent, 0, &varNewValue, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed.");
		return hr;
	}

	IWbemClassObject* pNewInstRaw = spNewInst;
	hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);
	if (FAILED (hr))
	{
		TRACE (L"WMI Indicate failed");
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\cfgquery.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgquery.h

$Header: $

Abstract:
	Configuration Query Class

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CFGQUERY_H__
#define __CFGQUERY_H__

#pragma once

#include "catalog.h"
#include <atlbase.h>

class CConfigTableMeta;
class CConfigRecord;

/**************************************************************************++
Class Name:
    CConfigQuery

Class Description:
    Configuration Query Class. This is the class that interacts directly with the
	catalog, and all calls to the catalog go via this class. The class returns CConfigRecords
	which abstract the 'read-only' pointers from the catalog from the user

--*************************************************************************/
class CConfigQuery
{
public:
	CConfigQuery ();
	~CConfigQuery ();
	HRESULT   Init (LPCWSTR i_wszDatabase,
					LPCWSTR i_wszTableName,
					LPCWSTR i_wszSelector,
					ISimpleTableDispenser2 *i_pDispenser);

	HRESULT Execute (CConfigRecord *pRecord, bool i_fOnlyPKs, bool i_fWriteAccess);

	ULONG GetRowCount ();
	HRESULT GetColumnValues (ULONG i_idx, CConfigRecord& io_record);
	HRESULT GetEmptyConfigRecord (CConfigRecord& io_record);
	HRESULT GetPKRow (CConfigRecord& i_record, ULONG* o_pcRow);
	HRESULT GetRowBySearch (ULONG iStartIdx, CConfigRecord& i_record, ULONG* o_pcRow);

	HRESULT DeleteRow (ULONG i_idx);
	HRESULT UpdateRow (ULONG i_idx, CConfigRecord& i_record, long lFlags);
	HRESULT Save ();	// use for multi-row save
	HRESULT SaveSingleRow (); // use for single row save
	HRESULT GetDetailedErrorCount (ULONG *pCount);
	HRESULT GetDetailedError (ULONG idx, STErr* pErrInfo);
private:
	HRESULT GetSingleDetailedError (HRESULT * pDetailedHr);

	CComPtr<ISimpleTableDispenser2> m_spDispenser;  // table dispenser
	CComPtr<ISimpleTableWrite2> m_spWrite;			// table pointer
	bool						m_fInitialized;		// are we initialized?
	ULONG						m_cNrRows;			// number of rows in the table
	LPVOID *					m_ppvValues;		// values (perf optimization)
	CConfigTableMeta *			m_pTableMeta;		// table meta information

	LPWSTR						m_wszDatabase;
	LPWSTR						m_wszTable;
	LPWSTR						m_wszSelector;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\batchdelete.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    batchdelete.h

$Header: $

Abstract:

Author:
    marcelv 	12/4/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __BATCHDELETE_H__
#define __BATCHDELETE_H__

#pragma once

#include "catmacros.h"
#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "cfgquery.h"
#include "wmiobjectpathparser.h"
#include "smartpointer.h"

class CBatchDelete
{
public:
	CBatchDelete ();
	~CBatchDelete ();

	HRESULT Initialize (IWbemClassObject * pInParams,
						IWbemClassObject * pOutParams,
						IWbemServices	 * pNamespace, 
						IWbemContext	 * pCtx,
						ISimpleTableDispenser2 * pDispenser);		

	HRESULT DeleteAll ();
	HRESULT SetStatus ();
	bool HaveStatusError () const;

private:

	HRESULT ValidateObjects ();
	HRESULT HandleDetailedErrors (CConfigQuery& cfgQuery);
	HRESULT DeleteSingleRecord (CConfigQuery& cfgQuery, CObjectPathParser& objPath);
	void SetStatusForElement (ULONG idx, HRESULT hr);

	CObjectPathParser *				m_aObjectPaths;
	ULONG							m_cNrWMIObjects;
	SAFEARRAY *						m_pSAStatus;
	_bstr_t							m_bstrClassName;
	_bstr_t							m_bstrDBName;
	_bstr_t							m_bstrTableName;
	_bstr_t							m_bstrSelector;
	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemClassObject>		m_spClassObject;
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;			// Catalog dispenser
	CComPtr<IWbemClassObject>		m_spOutParams;			// out parameters
	bool							m_fInitialized;
	bool							m_fStatusSet;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\cfgrecord.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgrecord.h

$Header: $

Abstract:

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CFGRECORD_H__
#define __CFGRECORD_H__

#pragma once

#include "catalog.h"
#include <comdef.h>

class CConfigTableMeta;

class CConfigRecord
{
public:
	CConfigRecord ();
	~CConfigRecord ();

	HRESULT Init (const CConfigTableMeta *i_pTableInfo);

	//const _variant_t operator[] (LPCWSTR i_wszPropName) const;
	
	HRESULT GetValue (LPCWSTR i_wszPropName, _variant_t& o_varValue) const;
	HRESULT GetValue (ULONG i_idx, _variant_t& o_varValue) const;

	HRESULT SetValue (LPCWSTR i_wszPropName, LPCWSTR i_wszValue);
	HRESULT SetValue (LPCWSTR i_wszPropName, const _variant_t& i_varValue);

	HRESULT SyncValues ();
	HRESULT AsQueryCell (STQueryCell *io_aCells, ULONG* io_pcTotalCells, bool fOnlyPKs);

	LPVOID * GetValues () const;
	ULONG * GetSizes () const;

	HRESULT AsObjectPath (LPCWSTR wszSelector, _variant_t& o_varResult);

	ULONG ColumnCount () const;
	LPCWSTR GetColumnName (ULONG idx) const;
	LPCWSTR GetPublicTableName () const;
	bool IsPersistableColumn (ULONG idx) const;

private:
	HRESULT ValueToVariant (LPVOID pValue, ULONG iSize, int iType, BOOL i_fIsMultiString, _variant_t& o_varResult) const;
	HRESULT VariantToValue (_variant_t& varValue, int iType, ULONG *piSize, BOOL i_fIsMultiString, LPVOID& o_lpValue) const;

	CConfigTableMeta *	m_pTableInfo;		// table meta information
	LPVOID *			m_ppvValues;		// array with catalog values
	ULONG *				m_acbSizes;			// array with catalog sizes
	_variant_t *		m_avarValues;		// array with variant values
	bool				m_fInitialized;		// are we initialized?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\assocwebappchild.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    assocwebappchild.h

$Header: $

Abstract: AssocWebApplChild. Create child/parent associations for web apps.

Author:
    marcelv 	2/9/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __ASSOCWEBAPPCHILD_H__
#define __ASSOCWEBAPPCHILD_H__

#pragma once

#include <iadmw.h>
#include <iiscnfg.h>
#include "assocbase.h"

class CAssocWebAppChild : public CAssocBase
{
public:
	CAssocWebAppChild ();
	virtual ~CAssocWebAppChild ();
	virtual HRESULT CreateAssocations ();

private:
	CAssocWebAppChild (const CAssocWebAppChild& );
	CAssocWebAppChild& operator= (CAssocWebAppChild& );

	HRESULT GetAssocType ();
	HRESULT CreateChildAssocs ();
	HRESULT CreateParentAssoc ();
	HRESULT CreateInstanceForAppRoot (LPCWSTR i_wszNewInstance, LPCWSTR i_wszChildOrParent);
		
	CComPtr<IMSAdminBase> m_spAdminBase;		// Metabase pointer
	bool m_fGetChildren;						// get children or parent?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\cfgtablemeta.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgtablemeta.h

$Header: $

Abstract:
	Table Meta information implementation

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CFGTABLEMETA_H__
#define __CFGTABLEMETA_H__

#pragma once

#include "catalog.h"
#include "catmacros.h"
#include "catmeta.h"

class CConfigTableMeta
{
public:
	CConfigTableMeta (LPCWSTR i_wszTableName, 
					  ISimpleTableDispenser2 *i_pDispenser);
	~CConfigTableMeta ();

	HRESULT Init ();

	ULONG   GetColumnIndex (LPCWSTR i_wszColumnName) const;
	LPCWSTR GetColumnName  (ULONG i_idx) const;
	const tCOLUMNMETARow& GetColumnMeta (ULONG i_idx);
	LPCWSTR GetPublicTableName () const;

	ULONG	ColumnCount () const;
	ULONG	PKCount     () const;
	ULONG * GetPKInfo   () const;
private:
	HRESULT GetColumnInfo ();
	
	WCHAR *				m_pTableName;	// table name
	tTABLEMETARow		m_TableMeta;	// table meta information
	tCOLUMNMETARow *	m_paColumnMeta;	// column meta information
	ULONG *				m_paPKInfo;	    // primary key indexes
	ULONG				m_cNrPKs;		// number of primary keys

	CComPtr<ISimpleTableRead2>      m_spISTTableMeta; // table meta read pointer
	CComPtr<ISimpleTableRead2>      m_spISTColumnMeta; // column meta read pointer
	CComPtr<ISimpleTableDispenser2> m_spDispenser;	// table dispenser

	bool m_fInitialized;  // is the class initialized
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\batchupdate.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    batchupdate.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/27/2000		Initial Release

Revision History:

--**************************************************************************/

#include "batchupdate.h"
#include "localconstants.h"
#include "cfgquery.h"
#include "cfgrecord.h"
#include "wmihelper.h"

//=================================================================================
// Function: CBatchUpdate::CBatchUpdate
//
// Synopsis: Default Constructor
//=================================================================================
CBatchUpdate::CBatchUpdate ()
{
	m_cNrWMIObjects = 0;
	m_pSAStatus		= 0;
	m_fInitialized	= false;
	m_fStatusSet	= false;
}

//=================================================================================
// Function: CBatchUpdate::~CBatchUpdate
//
// Synopsis: Destructor
//=================================================================================
CBatchUpdate::~CBatchUpdate ()
{
}

//=================================================================================
// Function: CBatchUpdate::Initialize
//
// Synopsis: Initializes the batch update object. It goes through the input parameters,
//           validates that the input parameters are valid, and retrieves the class
//           name, database name and table name for the table that will be updated
//
// Arguments: [i_pInParams] - input parameters
//            [i_pOutParams] - output parameters
//            [i_pNamespace] - namespace
//            [i_pCtx] - context
//            [i_pDispenser] - dispenser
//=================================================================================
HRESULT
CBatchUpdate::Initialize (IWbemClassObject *i_pInParams,
						  IWbemClassObject *i_pOutParams,
						  IWbemServices	* i_pNamespace, 
						  IWbemContext	* i_pCtx,
						  ISimpleTableDispenser2 * i_pDispenser)
{
	ASSERT (i_pInParams != 0);
	ASSERT (i_pOutParams != 0);
	ASSERT (i_pNamespace != 0);
	ASSERT (i_pCtx != 0);
	ASSERT (i_pDispenser != 0);

	m_spNamespace	= i_pNamespace;
	m_spCtx			= i_pCtx;
	m_spDispenser   = i_pDispenser;
	m_spOutParams	= i_pOutParams;

	_variant_t varObjectList;
	_variant_t varFlags;

	HRESULT hr = i_pInParams->Get(L"ObjectList", 0, &varObjectList, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get ObjectList in-parameter for batch update");
		return hr;
	}

	hr = i_pInParams->Get(L"Flags", 0, &varFlags, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get flags in-parameter for batch update");
		return hr;
	}

	if (varObjectList.vt == VT_NULL || varFlags.vt == VT_NULL)
	{
		TRACE (L"Null ObjectList or Null flags argument");
		return E_INVALIDARG;
	}

	m_lFlags = varFlags;

	if (m_lFlags != 0)
	{
		TRACE (L"Flags is reserved and should be zero");
		return E_INVALIDARG;
	}

	// copy elements from variant array into local array so that we can use it
	// easily

	SAFEARRAY *pSAObjectList = varObjectList.parray;
	ASSERT (pSAObjectList != 0);
	
	m_cNrWMIObjects = pSAObjectList->rgsabound[0].cElements;

	if (m_cNrWMIObjects == 0)
	{
		TRACE (L"Number of elements is 0");
		return E_INVALIDARG;
	}

		// create the safe array for the output parameter Status
	SAFEARRAYBOUND safeArrayBounds[1];
	safeArrayBounds[0].lLbound = 0;
	safeArrayBounds[0].cElements = m_cNrWMIObjects;

	// output parameter
	m_pSAStatus = SafeArrayCreate (VT_I4, 1, safeArrayBounds);
	if (m_pSAStatus == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_aWMIObjects = new CComPtr<IWbemClassObject>[m_cNrWMIObjects];
	if (m_aWMIObjects == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	IWbemClassObject **aObjects; // array with objects
	hr = SafeArrayAccessData (pSAObjectList, (void **) &aObjects);
	if (FAILED (hr))
	{
		TRACE (L"SafeArrayAccessData failed");
		return hr;
	}

	for (ULONG idx=0; idx < m_cNrWMIObjects; ++idx)
	{
		m_aWMIObjects[idx] = aObjects[idx];
	}
	
	hr = SafeArrayUnaccessData (pSAObjectList);
	if (FAILED (hr))
	{
		TRACE (L"SafeArrayUnaccessData failed");
		return hr;
	}

	hr = ValidateObjects ();
	if (FAILED (hr))
	{
		TRACE (L"Object validation failed");
		return hr;
	}

	hr = m_spNamespace->GetObject((LPWSTR) m_bstrClassName, 
									0, 
									m_spCtx, 
									&m_spClassObject, 
									0); 
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", (LPWSTR) m_bstrClassName);
		return hr;
	}

	hr = CWMIHelper::GetClassInfo (m_spClassObject, m_bstrDBName, m_bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class information");
		return hr;
	}
	

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CBatchUpdate::SetStatus
//
// Synopsis: Sets the status for an object that gets updated
//
// Arguments: [idx] - index of element to set status for
//            [hrStatus] - status
//=================================================================================
void
CBatchUpdate::SetStatus (ULONG idx, HRESULT hrStatus)
{
	ASSERT (m_fInitialized);
	ASSERT (idx >= 0 && idx < m_cNrWMIObjects);
	ASSERT (m_pSAStatus != 0);

	SafeArrayPutElement (m_pSAStatus, (LONG *)&idx, &hrStatus);
	m_fStatusSet = true;
}

bool
CBatchUpdate::HaveStatusError () const
{
	return m_fStatusSet;
}

//=================================================================================
// Function: CBatchUpdate::ValidateObjects
//
// Synopsis: Ensure that all objects come from the same class, and that the same
//           selector is specified for all of them
//
// Return Value: E_INVALIDARG in case of problems
//=================================================================================
HRESULT
CBatchUpdate::ValidateObjects ()
{
	for (ULONG idx=0; idx < m_cNrWMIObjects; ++idx)
	{
		// check for null object, because the caller can pass bogus data in
		if (m_aWMIObjects[idx] == 0)
		{
			SetStatus (idx, E_INVALIDARG);
			return E_INVALIDARG;
		}

		_variant_t varClassName;
		HRESULT hr = m_aWMIObjects[idx]->Get(L"__class", 0, &varClassName, 0 , 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get __class property for object %ld", idx);
			SetStatus (idx, hr);
			return hr;
		}

		_variant_t varSelector;
		hr = m_aWMIObjects[idx]->Get(WSZSELECTOR, 0, &varSelector, 0 , 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get selector property for object %ld", idx);
			SetStatus (idx, hr);
			return hr;
		}

		if (idx == 0)
		{
			m_bstrClassName = (_bstr_t) varClassName;
			m_bstrSelector	= (_bstr_t) varSelector;
		}
		else
		{
			if (_wcsicmp ((LPWSTR) m_bstrClassName, (LPWSTR) varClassName.bstrVal ) != 0)
			{
				TRACE (L"Class names differ: %s and %s", (LPWSTR) m_bstrClassName, (LPWSTR)((bstr_t)varClassName));
				SetStatus (idx, E_INVALIDARG);
				return E_INVALIDARG;
			}

			if (_wcsicmp ((LPWSTR) m_bstrSelector, (LPWSTR) varSelector.bstrVal) != 0)
			{
				TRACE (L"Selectors differ: %s and %s", (LPWSTR) m_bstrSelector, (LPWSTR) ((bstr_t) varSelector));
				SetStatus (idx, E_INVALIDARG);
				return E_INVALIDARG;
			}
		}
	}

	return S_OK;
}

//=================================================================================
// Function: CBatchUpdate::UpdateAll
//
// Synopsis: Updates all elements. It creates a config query for the table and database
//           for this particular class. Next, it finds the row that needs to be updated and
//           updates that row. Only when all rows are updated, we save the information
//           to the configuration store. Either all updates succeed, or all of them fail.
//
// Return Value: 
//=================================================================================
HRESULT 
CBatchUpdate::UpdateAll (bool i_fCreateOnly)
{
	ASSERT (m_fInitialized);

	CConfigQuery cfgQuery;
	HRESULT hr = cfgQuery.Init (m_bstrDBName, m_bstrTableName, m_bstrSelector, m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of config query failed (db=%s, table=%s)", (LPWSTR) m_bstrDBName, (LPWSTR) m_bstrTableName);
		return hr;
	}

	hr = cfgQuery.Execute (0, false, true);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of config query failed (db=%s, table=%s)", (LPWSTR) m_bstrDBName, (LPWSTR) m_bstrTableName);
		return hr;
	}

	for (ULONG idx=0; idx < m_cNrWMIObjects; ++idx)
	{
		hr = UpdateSingleRecord (cfgQuery, m_aWMIObjects[idx], i_fCreateOnly);	
		if (FAILED (hr))
		{
			TRACE (L"Update Single Record failed");
			SetStatus (idx, hr); // always set the status
			return hr;
		}
	}

	hr = cfgQuery.Save ();
	if (FAILED (hr))
	{
		if (hr == E_ST_DETAILEDERRS)
		{
			HandleDetailedErrors (cfgQuery); // ignore return value (nothing we can do here)
		}
		TRACE (L"Save of update batch failed");
		return hr;
	}
	
	_variant_t varHR;
	varHR = hr;
	hr = m_spOutParams->Put (_bstr_t(L"ReturnValue"), 0, &varHR, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set returnvalue property");
		return hr;
	}

	return hr;
}

HRESULT
CBatchUpdate::UpdateSingleRecord (CConfigQuery& cfgQuery, 
								  IWbemClassObject * pWMIInstance,
								  bool i_fCreateOnly)
{
	ASSERT (pWMIInstance != 0);

	CConfigRecord record;
	HRESULT hr = cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get empty configuration record");
		return hr;
	}

	// loop through all values in the object, and save to the record
	hr = m_spClassObject->BeginEnumeration (WBEM_FLAG_NONSYSTEM_ONLY);
	if (FAILED(hr))
	{
		TRACE (L"BeginEnumeration failed for class %s", (LPWSTR) m_bstrClassName);
		return hr;
	}

	hr = 0;
	while (SUCCEEDED (hr))
	{
		_variant_t varValue;
		BSTR bstrTmpName;

		hr = m_spClassObject->Next (0, &bstrTmpName, 0, 0, 0);
		if (hr == WBEM_S_NO_MORE_DATA)
		{
			// we went over all properties
			hr = S_OK;
			break;
		}

		if (FAILED (hr))
		{
			TRACE (L"IWbemClassObject::Next failed in PutInstance");
			return hr;
		}

		_bstr_t bstrName = _bstr_t (bstrTmpName, false);
		
		hr = pWMIInstance->Get(bstrTmpName, 0, &varValue, 0, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get WMI value for %s", bstrName);
			return hr;
		}

		record.SetValue (bstrName, varValue); // ignore errors because properties might not be present
	}

	hr = m_spClassObject->EndEnumeration ();
	if (FAILED (hr))
	{
		TRACE(L"EndEnumeration failed");
		return hr;
	}

	// the record is populated. Get the PK Row, and update it.

	ULONG cReadRow;
	hr = cfgQuery.GetPKRow (record, &cReadRow);
	if (hr == E_ST_NOMOREROWS)
	{
		cReadRow = (ULONG) -1;
		hr = S_OK;
	}

	if (FAILED (hr))
	{
		TRACE (L"Unable to get primary key row");
		return hr;
	}

	// in case of create only, we change the flag to the update function
	// to createonly.
	long lFlags = WBEM_FLAG_UPDATE_ONLY;
	if (i_fCreateOnly)
	{
		lFlags = WBEM_FLAG_CREATE_ONLY;
	}

	hr = cfgQuery.UpdateRow (cReadRow, record, lFlags);
	if (FAILED (hr))
	{
		TRACE (L"UpdateRow failed");
		return hr;
	}

	return hr;

}

HRESULT
CBatchUpdate::SetStatus ()
{
	_variant_t varStatus;
	varStatus.vt = VT_I4|VT_ARRAY;
	varStatus.parray = m_pSAStatus;

	HRESULT hr = m_spOutParams->Put (L"status", 0, &varStatus, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set status property");
		return hr;
	}

	return hr;
}

HRESULT
CBatchUpdate::HandleDetailedErrors (CConfigQuery& cfgQuery)
{
	ULONG cNrErrs;
	HRESULT hr = cfgQuery.GetDetailedErrorCount (&cNrErrs);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get detailed error count");
		return hr;
	}

	for (ULONG idx=0; idx<cNrErrs; ++idx)
	{
		STErr errInfo;
		hr = cfgQuery.GetDetailedError (idx, &errInfo);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get detailed error");
			return hr;
		}

		if (errInfo.iRow >= 0 && errInfo.iRow < m_cNrWMIObjects)
		{
			SetStatus (errInfo.iRow, errInfo.hr);
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\batchupdate.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    batchupdate.h

$Header: $

Abstract:

Author:
    marcelv 	11/27/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __BATCHUPDATE_H__
#define __BATCHUPDATE_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "catmacros.h"
#include "smartpointer.h"

class CConfigQuery;

class CBatchUpdate
{
public:
	CBatchUpdate ();
	~CBatchUpdate ();

	HRESULT Initialize (IWbemClassObject * pInParams,
						IWbemClassObject * pOutParams,
						IWbemServices	* pNamespace, 
						IWbemContext	* pCtx,
						ISimpleTableDispenser2 * pDispenser);		




	HRESULT UpdateAll (bool i_fCreateOnly);
	HRESULT SetStatus ();
	bool HaveStatusError () const;
private:
	// we don't support copying and assignment
	CBatchUpdate (const CBatchUpdate&);
	CBatchUpdate& operator=(const CBatchUpdate&);

	HRESULT ValidateObjects ();
	void SetStatus (ULONG idx, HRESULT hrStatus);
	HRESULT UpdateSingleRecord (CConfigQuery& cfgQuery, IWbemClassObject * pWMIInstance,bool i_fCreateOnly);
	HRESULT HandleDetailedErrors (CConfigQuery& cfgQuery);

	TSmartPointerArray<CComPtr<IWbemClassObject> > m_aWMIObjects;
	ULONG			 m_cNrWMIObjects;
	SAFEARRAY *      m_pSAStatus;
	_bstr_t			 m_bstrClassName;
	_bstr_t			 m_bstrDBName;
	_bstr_t			 m_bstrTableName;
	_bstr_t			 m_bstrSelector;
	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemClassObject>		m_spClassObject;
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;			// Catalog dispenser
	CComPtr<IWbemClassObject>		m_spOutParams;			// out parameters
	long							m_lFlags;				// flags specified
	bool			 m_fInitialized;
	bool			 m_fStatusSet;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\classfactory.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    ClassFactory.h

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CLASSFACTORY_H__
#define __CLASSFACTORY_H__

#pragma once

#include <comdef.h>

class CClassFactory : public IClassFactory
{
public:
	static LONG m_LockCount;

    CClassFactory (int iFactoryType) ;
    ~CClassFactory () ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * );
    STDMETHODIMP LockServer ( BOOL ) ;

private:
    long m_RefCount;
	int m_iFactoryType;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\batchdelete.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    batchdelete.cpp

$Header: $

Abstract:

Author:
    marcelv 	12/4/2000		Initial Release

Revision History:

--**************************************************************************/

#include "batchdelete.h"
#include "localconstants.h"
#include "cfgrecord.h"
#include "wmihelper.h"

//=================================================================================
// Function: CBatchDelete::CBatchDelete
//
// Synopsis: Constructor
//=================================================================================
CBatchDelete::CBatchDelete ()
{
	m_aObjectPaths	= 0;
	m_cNrWMIObjects = 0;
	m_pSAStatus		= 0;
	m_fInitialized	= false;
	m_fStatusSet	= false;
}

//=================================================================================
// Function: CBatchDelete::~CBatchDelete
//
// Synopsis: Destructor
//=================================================================================
CBatchDelete::~CBatchDelete()
{
	delete [] m_aObjectPaths;
	m_aObjectPaths = 0;
}

//=================================================================================
// Function: CBatchDelete::Initialize
//
// Synopsis: Intializes the batch update object, and verifies that the input parameters
//           are specified ok. This means that they all belong to the same class, that
//           they all have the same selector, and that the paths are valid object paths
//
// Arguments: [pInParams] - input parameters
//            [pOutParams] - output parameters
//            [pNamespace] - namespace
//            [pCtx] - context
//            [pDispenser] - dispenser
//=================================================================================
HRESULT
CBatchDelete::Initialize (IWbemClassObject *pInParams,
						  IWbemClassObject *pOutParams,
						  IWbemServices *pNamespace,
						  IWbemContext *pCtx,
						  ISimpleTableDispenser2 *pDispenser)
{
	ASSERT (!m_fInitialized);
	ASSERT (pInParams != 0);
	ASSERT (pOutParams != 0);
	ASSERT (pNamespace != 0);
	ASSERT (pCtx != 0);
	ASSERT (pDispenser != 0);

	m_spOutParams	= pOutParams;
	m_spNamespace	= pNamespace;
	m_spCtx			= pCtx;
	m_spDispenser	= pDispenser;

	// get the path and flags parameters
	_variant_t varPathList;
	HRESULT hr = pInParams->Get(L"Path", 0, &varPathList, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Getting Path parameter failed");
		return hr;
	}

	_variant_t varFlags;
	hr = pInParams->Get(L"Flags", 0, &varFlags, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Getting Flags parameter failed");
		return hr;
	}

	if (varPathList.vt == VT_NULL || varFlags.vt == VT_NULL)
	{
		TRACE (L"Null path list or null flag parameter specified");
		return E_INVALIDARG;
	}

	long lFlags = varFlags;
	if (lFlags != 0)
	{
		TRACE (L"Flags is reserved and should be zero");
		return E_INVALIDARG;
	}

	SAFEARRAY *pSAPathList = varPathList.parray;
	ASSERT (pSAPathList != 0);
	
	m_cNrWMIObjects = pSAPathList->rgsabound[0].cElements;

	if (m_cNrWMIObjects == 0)
	{
		TRACE (L"Number of elements is 0");
		return E_INVALIDARG;
	}

	SAFEARRAYBOUND safeArrayBounds[1];
	safeArrayBounds[0].lLbound = 0;
	safeArrayBounds[0].cElements = m_cNrWMIObjects;

	// output parameter
	m_pSAStatus = SafeArrayCreate (VT_I4, 1, safeArrayBounds);
	if (m_pSAStatus == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_aObjectPaths = new CObjectPathParser [m_cNrWMIObjects];
	if (m_aObjectPaths == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	BSTR *aPaths; // array with object paths
	hr = SafeArrayAccessData (pSAPathList, (void **) &aPaths);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get paths from safearray");
		return hr;
	}

	for (ULONG idx=0; idx < m_cNrWMIObjects; ++idx)
	{
		if (aPaths[idx] == 0)
		{
			SafeArrayUnaccessData (pSAPathList);
			return E_INVALIDARG;
		}

		hr = m_aObjectPaths[idx].Parse (aPaths[idx]);
		if (FAILED (hr))
		{
			SafeArrayUnaccessData (pSAPathList);
			SetStatusForElement (idx, hr); // always set the status
			TRACE (L"Unable to parse object path %s for element %ld", aPaths[idx], idx);
			return hr;
		}
	}
	
	hr = SafeArrayUnaccessData (pSAPathList);
	if (FAILED (hr))
	{
		TRACE (L"SafeArrayUnaccessData failed");
		return hr;
	}


	hr = ValidateObjects ();
	if (FAILED (hr))
	{
		TRACE (L"Error while validating objects");
		return hr;
	}
	
	hr = m_spNamespace->GetObject((LPWSTR) m_bstrClassName, 
									0, 
									m_spCtx, 
									&m_spClassObject, 
									0); 
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", (LPWSTR) m_bstrClassName);
		return hr;
	}

	hr = CWMIHelper::GetClassInfo (m_spClassObject, m_bstrDBName, m_bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Error while getting classinfo");
		return hr;
	}

	m_fInitialized = true;
	return hr;
}

//=================================================================================
// Function: CBatchDelete::ValidateObjects
//
// Synopsis: Verify that the class names of all paths match, and that they all use
//           the same selector
//=================================================================================
HRESULT
CBatchDelete::ValidateObjects ()
{
	HRESULT hr = S_OK;
	for (ULONG idx=0; idx < m_cNrWMIObjects; ++idx)
	{
		if (idx==0)
		{
			m_bstrClassName = m_aObjectPaths[idx].GetClass ();
			const CWMIProperty *pSelector = m_aObjectPaths[idx].GetPropertyByName (WSZSELECTOR);
			if (pSelector == 0)
			{
				TRACE (L"First object path does not have selector specified");
				hr = E_INVALIDARG;
				SetStatusForElement (idx, hr); // always set the status
				return hr;
			}
			m_bstrSelector = pSelector->GetValue ();
		}
		else
		{
			if (_wcsicmp ((LPWSTR) m_bstrClassName, m_aObjectPaths[idx].GetClass ()) != 0)
			{
				TRACE (L"Different classnames specified: %s and %s",
					   (LPWSTR) m_bstrClassName, m_aObjectPaths[idx].GetClass ());
				hr = E_INVALIDARG;
				SetStatusForElement (idx, hr); // always set the status
				return hr;
			}

			const CWMIProperty *pSelector = m_aObjectPaths[idx].GetPropertyByName (WSZSELECTOR);
			if (pSelector == 0)
			{
				TRACE (L"Object path does not have selector specified");
				hr = E_INVALIDARG;
				SetStatusForElement(idx, hr); // always set the status
				return hr;
			}

			if (_wcsicmp ((LPWSTR) m_bstrSelector, pSelector->GetValue()) != 0)
			{
				TRACE (L"Selectors are different: %s %s",
					   (LPWSTR) m_bstrSelector, pSelector->GetValue() );
				hr = E_INVALIDARG;
				SetStatusForElement (idx, hr); // always set the status
				return hr;
			}
		}
	}

	return S_OK;
}

//=================================================================================
// Function: CBatchDelete::DeleteAll
//
// Synopsis: Loop through all elements, find the corresponding row, and delete the
//           row. When all elements are deleted, we call UpdateStore. This means that
//           either all deletes succeed or all deletes fail.
//=================================================================================
HRESULT
CBatchDelete::DeleteAll ()
{
	ASSERT (m_fInitialized);

	CConfigQuery cfgQuery;
	HRESULT hr = cfgQuery.Init (m_bstrDBName, m_bstrTableName, m_bstrSelector, m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of config query failed (db=%s, table=%s)", (LPWSTR) m_bstrDBName, (LPWSTR) m_bstrTableName);
		return hr;
	}

	hr = cfgQuery.Execute (0, false, true);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of config query failed (db=%s, table=%s)", (LPWSTR) m_bstrDBName, (LPWSTR) m_bstrTableName);
		return hr;
	}

	// now find the row for each element, and mark it as deleted

	for (ULONG idx=0; idx < m_cNrWMIObjects; ++idx)
	{
		hr = DeleteSingleRecord (cfgQuery, m_aObjectPaths[idx]);
		if (FAILED (hr))
		{
			SetStatusForElement (idx, hr);
			return hr;
		}
	}

	// everything went ok so far. Lets commit the changes

	hr = cfgQuery.Save ();

	if (FAILED (hr))
	{
		if (hr == E_ST_DETAILEDERRS)
		{
			HandleDetailedErrors (cfgQuery); // ignore return value (nothing we can do here)
		}
		TRACE (L"Save of Batch Delete failed");
		return hr;
	}

	// and populate the output parameters
	_variant_t varHR;
	varHR = hr;
	hr = m_spOutParams->Put (_bstr_t(L"ReturnValue"), 0, &varHR, 0);
	if (FAILED (hr))
	{
		return hr;
	}

	return hr;
}

HRESULT
CBatchDelete::DeleteSingleRecord (CConfigQuery& cfgQuery, CObjectPathParser& objPath)
{
	CConfigRecord record;
	HRESULT hr = cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get empty config record");
		return hr;
	}

	// populate the record

	for (ULONG propIdx=0; propIdx < objPath.GetPropCount (); ++propIdx)
	{
		const CWMIProperty * pProp = objPath.GetProperty (propIdx);
		ASSERT (pProp != 0);
		record.SetValue (pProp->GetName (), pProp->GetValue ()); // ignore errors
	}

	// get the index
	ULONG cReadRow;
	hr = cfgQuery.GetPKRow (record, &cReadRow);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get PK Row");
		return hr;
	}

	hr = cfgQuery.DeleteRow (cReadRow);
	if (FAILED (hr))
	{
		TRACE (L"Unable to delete row");
		return hr;
	}

	return hr;
}

HRESULT
CBatchDelete::SetStatus ()
{
	_variant_t varStatus;
	varStatus.vt = VT_I4|VT_ARRAY;
	varStatus.parray = m_pSAStatus;

	HRESULT hr = m_spOutParams->Put (L"status", 0, &varStatus, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set status array");
		return hr;
	}

	return hr;
}

void
CBatchDelete::SetStatusForElement (ULONG idx, HRESULT hr)
{
	ASSERT (m_pSAStatus != 0);

	SafeArrayPutElement (m_pSAStatus, (LONG *)&idx, &hr); // always set the status
	m_fStatusSet = true;
}

bool
CBatchDelete::HaveStatusError () const
{
	return m_fStatusSet;
}

HRESULT
CBatchDelete::HandleDetailedErrors (CConfigQuery& cfgQuery)
{
	ULONG cNrErrs;
	HRESULT hr = cfgQuery.GetDetailedErrorCount (&cNrErrs);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get detailed error count");
		return hr;
	}

	for (ULONG idx=0; idx<cNrErrs; ++idx)
	{
		STErr errInfo;
		hr = cfgQuery.GetDetailedError (idx, &errInfo);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get detailed error");
			return hr;
		}

		if (errInfo.iRow >= 0 && errInfo.iRow < m_cNrWMIObjects)
		{
			SetStatusForElement (errInfo.iRow, errInfo.hr);
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\impersonate.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    impersonate.h

$Header: $

Abstract:
	Helper class for CoImpersonateClient and CoRevertToSelf. These functions don't work
	on Win9X/WinME, but we need to check for them in NT. This class wraps the functionality, so
	that you can safely call them from both NT and 9X.

Author:
    marcelv 	2/22/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __IMPERSONATE_H__
#define __IMPERSONATE_H__

#pragma once

#include "catmacros.h"

class CImpersonator
{
public:
	CImpersonator ();
	~CImpersonator ();

	HRESULT ImpersonateClient () const;
private:
	CImpersonator(const CImpersonator& );
	CImpersonator& operator= (const CImpersonator&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\cfgtablemeta.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgtablemeta.cpp

$Header: $

Abstract:
	Implementation of TableMeta class. Holds meta information for table and all 
	columns in that particular table.
Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#include "cfgtablemeta.h"

//=================================================================================
// Function: CConfigTableMeta::CConfigTableMeta
//
// Synopsis: Constructor. Stores table name and dispenser information, but does not
//           initialize the object yet. You have to call Init to fully initialize the
//           object
//
// Arguments: [wszTableName] - Name of the table for which we want meta information
//            [pDispenser] - Dispenser to use
//=================================================================================
CConfigTableMeta::CConfigTableMeta (LPCWSTR i_wszTableName, 
									ISimpleTableDispenser2 *i_pDispenser)
{
	ASSERT (i_wszTableName != 0);
	ASSERT (i_pDispenser != 0);

	m_pTableName	= const_cast<LPWSTR>(i_wszTableName);
	m_spDispenser	= i_pDispenser;
	m_paColumnMeta	= 0;
	m_paPKInfo		= 0;
	m_cNrPKs		= 0;
	m_fInitialized	= false;
	memset (&m_TableMeta, 0x00, sizeof (tTABLEMETARow));
}

//=================================================================================
// Function: CConfigTableMeta::~CConfigTableMeta
//
// Synopsis: Destructor, releases memory
//=================================================================================
CConfigTableMeta::~CConfigTableMeta ()
{
	delete [] m_paColumnMeta;
	m_paColumnMeta = 0;

	delete [] m_paPKInfo;
	m_paPKInfo = 0;
}

//=================================================================================
// Function: CConfigTableMeta::Init
//
// Synopsis: Initializes the table meta information by retrieving the table meta
//           and column meta information for each column in the table. It also keeps
//           track of primary key information
//
// Return Value: S_OK, everything ok, non-S_OK else
//=================================================================================
HRESULT
CConfigTableMeta::Init ()
{
	ASSERT (!m_fInitialized);
	ASSERT (m_pTableName != 0);
	ASSERT (m_spDispenser != 0);

	// get table meta

	HRESULT hr = S_OK;
	
	STQueryCell cell;
	cell.pData		= (void *) m_pTableName;
	cell.eOperator	= eST_OP_EQUAL;
	cell.iCell		= iTABLEMETA_InternalName;
	cell.dbType		= DBTYPE_WSTR;
	cell.cbSize		= 0;
	ULONG cCell		= 1;

	hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_TABLEMETA,
								  &cell, (void *)&cCell, eST_QUERYFORMAT_CELLS, 0, (void **)&m_spISTTableMeta);
	if (FAILED (hr))
	{
		TRACE (L"Failed to retrieve meta information for table %s", m_pTableName);
		return hr;
	}

	hr = m_spISTTableMeta->GetColumnValues (0, cTABLEMETA_NumberOfColumns, 0, 0, (void **) &m_TableMeta);
	if (FAILED (hr))
	{
		TRACE (L"Failed to retrieve meta information for table %s", m_pTableName); 
		return hr;
	}
	// get column meta

	hr = GetColumnInfo ();
	if (FAILED (hr))
	{
		TRACE (L"Failed to get column meta information for table %s", m_pTableName);
		return hr;
	}
	
	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CConfigTableMeta::GetColumnInfo
//
// Synopsis: Get column meta information for each column in the table
//=================================================================================
HRESULT 
CConfigTableMeta::GetColumnInfo ()
{
	ASSERT (!m_fInitialized);
	ASSERT (m_paColumnMeta == 0);
	ASSERT (m_paPKInfo == 0);
	ASSERT (m_cNrPKs == 0);

	// bail out when we don't need column information
	ULONG iColCount = *(m_TableMeta.pCountOfColumns);
	if (iColCount == 0)
	{
		// no columns, so nothing to retrieve
		return S_OK;
	}

	m_paColumnMeta = new tCOLUMNMETARow[iColCount];
	if (m_paColumnMeta == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_paPKInfo = new ULONG [iColCount];
	if (m_paPKInfo == 0)
	{
		return E_OUTOFMEMORY;
	}

	STQueryCell cell;
	cell.pData = (void *) m_TableMeta.pInternalName;
	cell.eOperator = eST_OP_EQUAL;
	cell.iCell = iCOLUMNMETA_Table;
	cell.dbType = DBTYPE_WSTR;
	cell.cbSize = 0;
	ULONG cCell = 1;

	HRESULT hr = m_spDispenser->GetTable (wszDATABASE_META, wszTABLE_COLUMNMETA,
								  &cell, (void *)&cCell, eST_QUERYFORMAT_CELLS, 0, (void **) &m_spISTColumnMeta);
	if (FAILED (hr))
	{
		TRACE (L"Failed to get column meta for table %s", m_TableMeta.pInternalName);
		return hr;
	}

	for (ULONG idx=0; idx < iColCount; ++idx)
	{
		hr = m_spISTColumnMeta->GetColumnValues (idx, cCOLUMNMETA_NumberOfColumns, 0, 0, (void **) &m_paColumnMeta[idx]);
		if (FAILED (hr))
		{
			TRACE (L"Failed to get column meta for table %s", m_TableMeta.pInternalName);
			return hr;
		}
		ASSERT (idx == *m_paColumnMeta[idx].pIndex);

		// only count non_persistable columns
		if ((*m_paColumnMeta[idx].pMetaFlags & fCOLUMNMETA_PRIMARYKEY) &&
			!(*m_paColumnMeta[idx].pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE))
		{
			m_paPKInfo[m_cNrPKs++] = idx;
		}
	}

	return hr;
}

//=================================================================================
// Function: CConfigTableMeta::ColumnCount
//
// Synopsis: Returns the number of columns in the table
//=================================================================================
ULONG
CConfigTableMeta::ColumnCount () const
{
	ASSERT (m_fInitialized);

	return *(m_TableMeta.pCountOfColumns);
}

LPCWSTR
CConfigTableMeta::GetPublicTableName () const
{
	ASSERT (m_fInitialized);

	return m_TableMeta.pPublicName;
}

//=================================================================================
// Function: CConfigTableMeta::PKCount
//
// Synopsis: Returns the number of primary key columns in the table
//=================================================================================
ULONG
CConfigTableMeta::PKCount () const
{
	ASSERT (m_fInitialized);

	return m_cNrPKs;
}

//=================================================================================
// Function: CConfigTableMeta::GetPKInfo
//
// Synopsis: Get primary key index information. This array should be treated as read-only
//           by the caller
//
// Return Value: array with primary key index information
//=================================================================================
ULONG *
CConfigTableMeta::GetPKInfo () const
{
	ASSERT (m_fInitialized);

	return m_paPKInfo;
}

//=================================================================================
// Function: CConfigTableMeta::GetColumnIndex
//
// Synopsis: Get the index of a column by searching by public name of the column.
//           A case insensitive search is done because WMI is case intensitive.
//
// Arguments: [wszColumnName] - Name of column to get index for
//            
// Return Value: column index if found, -1 if not found
//=================================================================================
ULONG
CConfigTableMeta::GetColumnIndex (LPCWSTR i_wszColumnName) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszColumnName != 0);

	for (ULONG idx=0; idx<ColumnCount (); ++idx)
	{
		if (_wcsicmp (m_paColumnMeta[idx].pPublicName, i_wszColumnName) == 0)
		{
			return idx;
		}
	}

	return (ULONG) -1;
}


//=================================================================================
// Function: CConfigTableMeta::GetColumnName
//
// Synopsis: Get the name of a column for a particular index
//
// Arguments: [idx] - column index for which we want the column name
//            
// Return Value: public column name
//=================================================================================
LPCWSTR
CConfigTableMeta::GetColumnName (ULONG i_idx) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >=0 && i_idx < ColumnCount());

	return m_paColumnMeta[i_idx].pPublicName;
}
	
//=================================================================================
// Function: CConfigTableMeta::GetColumnMeta
//
// Synopsis: Get column meta information for a particular column
//
// Arguments: [idx] - index of the column we want meta information for
//            
// Return Value: read only reference to column meta information
//=================================================================================
const tCOLUMNMETARow& 
CConfigTableMeta::GetColumnMeta (ULONG i_idx)
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >=0 && i_idx < ColumnCount());

	return m_paColumnMeta[i_idx];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\cfgrecord.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgrecord.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#include "cfgrecord.h"
#include "cfgtablemeta.h"
#include "smartpointer.h"
#include "stringutil.h"

//=================================================================================
// Function: CConfigRecord::CConfigRecord
//
// Synopsis: Default constructor
//=================================================================================
CConfigRecord::CConfigRecord ()
{
	m_ppvValues		= 0;
	m_acbSizes		= 0;
	m_avarValues	= 0;
	m_pTableInfo	= 0;
	m_fInitialized  = false;
}

//=================================================================================
// Function: CConfigRecord::~CConfigRecord
//
// Synopsis: Destructor, releases the memory
//=================================================================================
CConfigRecord::~CConfigRecord ()
{
	delete [] m_avarValues;
	m_avarValues = 0;

	delete [] m_ppvValues;
	m_ppvValues = 0;

	delete [] m_acbSizes;
	m_acbSizes = 0;
}


//=================================================================================
// Function: CConfigRecord::Init
//
// Synopsis: Initializes a configuration record by allocating memory for column
//           values and assigning the TableMeta information
//
// Arguments: [i_pTableInfo] - table meta information
//=================================================================================
HRESULT
CConfigRecord::Init (const CConfigTableMeta * i_pTableInfo)
{
	ASSERT (i_pTableInfo != 0);
	ASSERT (i_pTableInfo->ColumnCount () > 0);

	m_ppvValues	= new LPVOID [i_pTableInfo->ColumnCount ()];
	if (m_ppvValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_acbSizes = new ULONG [i_pTableInfo->ColumnCount ()];
	if (m_acbSizes == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_avarValues = new _variant_t[i_pTableInfo->ColumnCount()];
	if (m_avarValues == 0)
	{
		return E_OUTOFMEMORY;
	}

	m_pTableInfo	= const_cast<CConfigTableMeta *>(i_pTableInfo);
	m_fInitialized	= true;

	return S_OK;
}

//=================================================================================
// Function: CConfigRecord::GetPublicTableName
//
// Synopsis: Gets the public table name from the record
//=================================================================================
LPCWSTR
CConfigRecord::GetPublicTableName () const
{
	ASSERT (m_fInitialized);

	return m_pTableInfo->GetPublicTableName ();
}


//=================================================================================
// Function: CConfigRecord::ColumnCount
//
// Synopsis: Returns the number of columns in the record
//=================================================================================
ULONG
CConfigRecord::ColumnCount () const
{
	ASSERT (m_fInitialized);

	return m_pTableInfo->ColumnCount ();
}

//=================================================================================
// Function: CConfigRecord::GetColumnName
//
// Synopsis: Returns the name of the column
//
// Arguments: [idx] - index of column to get name 
//            
// Return Value: 
//=================================================================================
LPCWSTR
CConfigRecord::GetColumnName (ULONG idx) const
{
	ASSERT (m_fInitialized);
	ASSERT (idx >=0 && idx < ColumnCount());

	return m_pTableInfo->GetColumnName (idx);
}

//=================================================================================
// Function: CConfigRecord::IsPersistableColumn
//
// Synopsis: Is the column markes as NOTPERSISTABLE or not	
//
// Arguments: [idx] - index of column for which we want to determine if persistable or not
//            
// Return Value: true, column is persistable, false, column is not persistable
//=================================================================================
bool 
CConfigRecord::IsPersistableColumn (ULONG idx) const
{
	ASSERT (m_fInitialized);
	ASSERT (idx >=0 && idx < ColumnCount ());

	if (*m_pTableInfo->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE)
	{
		return false;
	}
	else
	{
		return true;
	}
}

//=================================================================================
// Function: CConfigRecord::GetValues
//
// Synopsis: Get values in catalog format
//
// Return Value: pointer to array with columns values in catalog format. Should be
//               treated as read-only by the caller
//=================================================================================
LPVOID *
CConfigRecord::GetValues () const
{
	ASSERT (m_fInitialized);

	return m_ppvValues;
}

//=================================================================================
// Function: CConfigRecord::GetSizes
//
// Synopsis: Get sizes of values
//
// Return Value: array of sizes. Should be treated as read-only by the caller
//=================================================================================
ULONG *
CConfigRecord::GetSizes () const
{
	ASSERT (m_fInitialized);

	return m_acbSizes;
}

//=================================================================================
// Function: CConfigRecord::SyncValues
//
// Synopsis: The record contains two array's: one in catalog format (void pointers) and
//           one in variant_t format. The reason for this is to make it easy to convert
//           from WMI format (variant_t) to catalog format and vice versa. This function
//           does the conversion from WMI format to catalog format
//=================================================================================
HRESULT
CConfigRecord::SyncValues ()
{
	ASSERT (m_fInitialized);

	HRESULT hr = S_OK;
	for (ULONG idx=0; idx < m_pTableInfo->ColumnCount(); ++idx)
	{
		tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (idx);
		hr = VariantToValue (m_avarValues[idx], *ColMeta.pType, &m_acbSizes[idx], *ColMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING, m_ppvValues[idx]);
		if (FAILED (hr))
		{
			TRACE (L"VariantToValue failed");
			return hr;
		}
	}
	return hr;
}

//=================================================================================
// Function: CConfigRecord::GetValue
//
// Synopsis: Get the value for the column with name 'i_wszColumnName'
//
// Arguments: [i_wszColumnName] - name of column to get value for
//            [o_varResult] - result will be stored here
//=================================================================================
HRESULT
CConfigRecord::GetValue (LPCWSTR i_wszColumnName, _variant_t& o_varResult) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszColumnName != 0);

	ULONG idx = m_pTableInfo->GetColumnIndex (i_wszColumnName);
	ASSERT (idx != -1);

	tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (idx);

	return ValueToVariant (m_ppvValues[idx], 
		                   m_acbSizes[idx], 
						   *ColMeta.pType, 
						   *ColMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING,
						   o_varResult);
}

//=================================================================================
// Function: CConfigRecord::GetValue
//
// Synopsis: Gets the column value of column with index i_idx.
//
// Arguments: [i_idx] - index of column to search for
//            [o_varResult] - result will be stored in here
//=================================================================================
HRESULT
CConfigRecord::GetValue (ULONG i_idx, _variant_t& o_varResult) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >= 0 && i_idx < m_pTableInfo->ColumnCount ());

	tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (i_idx);

	return ValueToVariant (m_ppvValues[i_idx], 
		                   m_acbSizes[i_idx], 
						   *ColMeta.pType, 
						   *ColMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING,
						   o_varResult);
}
	
//=================================================================================
// Function: CConfigRecord::SetValue
//
// Synopsis: Set the value for a particular column/property. The value is a string
//           value, but dependent on the type, it needs to be converted.
//
// Arguments: [i_wszPropName] - Property name
//            [i_wszValue] - 
//            
// Return Value: 
//=================================================================================
HRESULT 
CConfigRecord::SetValue (LPCWSTR i_wszPropName, LPCWSTR i_wszValue)
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszPropName != 0);
	ASSERT (i_wszValue != 0);

	ULONG idx = m_pTableInfo->GetColumnIndex (i_wszPropName);
	if (idx == -1)
	{
		return E_INVALIDARG;
	}
	tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (idx);

	switch (*ColMeta.pType)
	{
	case DBTYPE_WSTR:
		m_avarValues[idx] = i_wszValue;
		break;

	case DBTYPE_UI4:

		// when we convert a boolean, we get values "0" and "false for false and "1" and "true" for true
		// we need to special case this here, because else wtol will always return 0;
		if (*ColMeta.pMetaFlags & fCOLUMNMETA_BOOL)
		{
			if ((wcscmp (L"0", i_wszValue) == 0) || (_wcsicmp(L"false", i_wszValue) == 0))
			{
				m_avarValues[idx] = 0L;
			}
			else
			{
				m_avarValues[idx] = 1L;
			}
		}
		else
		{
			m_avarValues[idx] = _wtol(i_wszValue);
		}
		break;

	case DBTYPE_BYTES:
		ASSERT (!L"NYI");
		break;

	default:
		ASSERT (false);
		break;
	}

	return S_OK;
}

HRESULT 
CConfigRecord::SetValue (LPCWSTR i_wszPropName, const _variant_t& i_varValue)
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszPropName != 0);

	ULONG idx = m_pTableInfo->GetColumnIndex (i_wszPropName);
	if (idx == -1)
	{
		return E_INVALIDARG;
	}

	m_avarValues[idx] = i_varValue;

	return S_OK;
}

//=================================================================================
// Function: CConfigRecord::AsObjectPath
//
// Synopsis: Converts a configuration record to a valid object path. It uses the PK
//           information to figure out what columns should be part of the object path,
//           and creates the object path accordingly
//
// Arguments: [wszSelector] - selector property that is part of the object path. Only
//                            add this when wszSelector != 0
//            [o_varResult] - object path will be stored here
//=================================================================================
HRESULT
CConfigRecord::AsObjectPath (LPCWSTR wszSelector, _variant_t& o_varResult)
{
	ASSERT (m_fInitialized);

	// ASSERT that the values are sync'd up

	_bstr_t bstrResult = m_pTableInfo->GetPublicTableName ();
	
	ULONG * aPKInfo = m_pTableInfo->GetPKInfo ();
	for (ULONG idx=0; idx < m_pTableInfo->PKCount (); ++idx)
	{
		if (idx == 0)
		{
			bstrResult += L".";
		}
		else
		{
			bstrResult += L",";
		}
	
		ULONG PKIdx = aPKInfo[idx];
		tCOLUMNMETARow ColMeta = m_pTableInfo->GetColumnMeta (PKIdx);

		bstrResult += ColMeta.pPublicName;
		bstrResult += L"=";

		switch (*ColMeta.pType)
		{
		case DBTYPE_WSTR:
			// we don't have multi-string PK, so assert that we don't have multi-string
			ASSERT ((*ColMeta.pMetaFlags & fCOLUMNMETA_MULTISTRING) == 0);
			bstrResult += "\"";
			bstrResult += (LPCWSTR) m_ppvValues[PKIdx];
			bstrResult += "\"";
			break;

		case DBTYPE_UI4:
			WCHAR wszNr[20];
			_snwprintf (wszNr, 20, L"%ld", *((ULONG *)m_ppvValues[PKIdx]));
			bstrResult += wszNr;
			break;

		case DBTYPE_BYTES:
			ASSERT (!L"NYI");
			break;

		default:
			ASSERT (false);
			break;
		}
	}

	// and add the selector. If we don't have any PK information yet, we need to
	// add a dot instead of comma

	if (m_pTableInfo->PKCount () == 0)
	{
		bstrResult += ".";
	}
	else
	{
		bstrResult += ",";
	}

	// add selector in case it is needed
	if (wszSelector != 0)
	{
		TSmartPointerArray<WCHAR> saSelector = CWMIStringUtil::AddBackSlashes (wszSelector);
		if (saSelector == 0)
		{
			return E_OUTOFMEMORY;
		}

		bstrResult += "Selector=\"";
		bstrResult += (LPWSTR) saSelector;
		bstrResult += "\"";
	}

	o_varResult = bstrResult;
	return S_OK;
}

//=================================================================================
// Function: CConfigRecord::ValueToVariant
//
// Synopsis: Converts a (catalog) value to a variant
//
// Arguments: [i_pValue] - value to convert
//            [i_iSize] - size of the value
//            [i_iType] - type of the value
//            [i_fIsMultiString] - is it a multistring or not
//            [o_varResult] - result of value (as variant)
//=================================================================================
HRESULT
CConfigRecord::ValueToVariant (LPVOID i_pValue, ULONG i_iSize, int i_iType, BOOL i_fIsMultiString, _variant_t& o_varResult) const
{
	static VARIANT varNull = {VT_NULL, 0};
	HRESULT hr = S_OK;

	if (i_pValue == 0)
	{
		o_varResult = varNull;
		return S_OK;
	}

	switch (i_iType)
	{
	case DBTYPE_WSTR:

		if (!i_fIsMultiString)
		{
			o_varResult = (LPWSTR) i_pValue;
		}
		else
		{
			// count number of elements

			ULONG iNrElems = 0;
			for (LPCWSTR pCur = (LPCWSTR) i_pValue; *pCur != L'\0'; pCur += wcslen (pCur) + 1)
			 {
				iNrElems++;
			 }
			// create variant array
			SAFEARRAYBOUND safeArrayBounds[1];
			safeArrayBounds[0].lLbound = 0;
			safeArrayBounds[0].cElements = iNrElems;
			SAFEARRAY *safeArray = SafeArrayCreate(VT_BSTR, 1, safeArrayBounds);
			if (safeArray == 0)
			{
				return E_OUTOFMEMORY;
			}

			// copy only first one for the moment

			LPCWSTR pCurString = (LPWSTR) i_pValue;
			for (ULONG idx=0; idx < iNrElems; ++idx)
			{
				BSTR bstrVal = SysAllocString ((LPWSTR) pCurString);
				if (bstrVal == 0)
				{
					return E_OUTOFMEMORY;
				}
				hr = SafeArrayPutElement (safeArray, (LONG *)&idx, bstrVal);
				SysFreeString (bstrVal); // free first to avoid leak
				if (FAILED (hr))
				{
					TRACE (L"SafeArrayPutElement failed in ValueToVariant");
					return hr;
				}
				pCurString += wcslen (pCurString) + 1;
			}

			o_varResult.vt = VT_BSTR | VT_ARRAY;
			o_varResult.parray = safeArray;
		}
		break;

	case DBTYPE_UI4:
		o_varResult = (long) *(ULONG *)i_pValue;
		break;

	case DBTYPE_BYTES:
		{
			SAFEARRAYBOUND safeArrayBounds[1];
			safeArrayBounds[0].lLbound = 0;
			safeArrayBounds[0].cElements = i_iSize;
			SAFEARRAY *safeArray = SafeArrayCreate(VT_UI1, 1, safeArrayBounds);
			if (safeArray == 0)
			{
				return E_OUTOFMEMORY;
			}

			for (ULONG idx=0; idx < i_iSize; ++idx)
			{
				hr = SafeArrayPutElement (safeArray, (LONG *)&idx , (LPBYTE)i_pValue + idx);
				if (FAILED (hr))
				{
					TRACE (L"SafeArrayPutElement failed in ValueToVariant");
					return hr;
				}
			}

			o_varResult.vt = VT_UI1 | VT_ARRAY;
			o_varResult.parray = safeArray;
		}
		break;

	default:
		ASSERT (false);
		o_varResult = varNull;
		break;
	}

	return hr;
}

//=================================================================================
// Function: CConfigRecord::VariantToValue
//
// Synopsis: Convert a variant to a (catalog) value
//
// Arguments: [io_varValue] - variant to convert
//            [iType] - type to convert to
//            [piSize] - size of new value
//            [i_fIsMultiString] - do we have multistring
//            [o_lpValue] - resulting value after conversion
//=================================================================================
HRESULT
CConfigRecord::VariantToValue (_variant_t& io_varValue, int iType, ULONG *piSize, BOOL i_fIsMultiString, LPVOID& o_lpValue) const
{
	ASSERT (piSize != 0);

	*piSize = 0;

	if (io_varValue.vt == VT_NULL || io_varValue.vt == VT_EMPTY)
	{
		o_lpValue = 0;
		return S_OK;
	}

	HRESULT hr = S_OK;

	switch (iType)
	{
	case DBTYPE_WSTR:
		if (i_fIsMultiString)
		{
			ASSERT (io_varValue.vt == (VT_BSTR | VT_ARRAY));
			SAFEARRAY *safeArray = io_varValue.parray;
			*piSize = safeArray->rgsabound[0].cElements ;
			if (*piSize == 0)
			{
				o_lpValue = 0;
				return S_OK;
			}

			LPWSTR *aObjects;
			
			hr = SafeArrayAccessData (safeArray, (void **) &aObjects);
			if (FAILED (hr))
			{
				TRACE (L"SafeArrayAccessData failed");
				return hr;
			}
			
			hr = SafeArrayUnaccessData (safeArray);
			if (FAILED (hr))
			{
				TRACE (L"SafeArrayUnAccessData failed");
				return hr;
			}

			SIZE_T iTotalLen = 0;
			for (ULONG idx=0; idx < *piSize; ++idx)
			{
				iTotalLen += wcslen ((LPWSTR)aObjects[idx]) + 1;
			}
			iTotalLen++;

			BSTR bstrResult = SysAllocStringByteLen (0, (ULONG) (iTotalLen * sizeof(WCHAR)));
			if (bstrResult == 0)
			{
				return E_OUTOFMEMORY;
			}

			SIZE_T iStartPos = 0;
			for (idx=0; idx < *piSize; ++idx)
			{
				SIZE_T iCurLen = wcslen ((LPWSTR) aObjects[idx]) + 1; // for null terminator
				memcpy (bstrResult + iStartPos, aObjects[idx], iCurLen * sizeof (WCHAR));
				iStartPos += iCurLen;
			}

			bstrResult[iStartPos] = L'\0';

			io_varValue.Clear ();
			io_varValue.vt		 = VT_BSTR;
			io_varValue.bstrVal = bstrResult;

			o_lpValue = io_varValue.bstrVal;
		}
		else
		{
			ASSERT (io_varValue.vt == VT_BSTR);
			o_lpValue = io_varValue.bstrVal;
		}
		break;

	case DBTYPE_UI4:
		{
			// a VT_BOOL variant only contains one byte (boolVal) to represent the boolean.
			// The catalog expect booleans to be 4 bytes. Because the three unused bytes in
			// the variant are garbage, we need to convert the variant to a UI4, so that we
			// can fill out the long variable with 0 (false) or 1 (true). This way, both the
			// catalog and the variant deal with the same number of bytes, and everything works
			// fine.
			if (io_varValue.vt == VT_BOOL)
			{
				// convert the bool to long
				
				if (io_varValue.boolVal == 0)
				{
					io_varValue.Clear ();
					io_varValue = 0L;
				}
				else
				{
					io_varValue.Clear ();
					io_varValue = 1L;
				}
			}

			ASSERT (io_varValue.vt == VT_I4);
			o_lpValue = &io_varValue.lVal;
		}
		break;

	case DBTYPE_BYTES:
		{
			ASSERT (io_varValue.vt == (VT_UI1 | VT_ARRAY));
			SAFEARRAY *safeArray = io_varValue.parray;
			*piSize = safeArray->rgsabound[0].cElements ;
			o_lpValue = safeArray->pvData;
		}

		break;

	default:
		ASSERT (false && "Unknown datatype specified");
		break;
	}

	return S_OK;
}

//=================================================================================
// Function: CConfigRecord::AsQueryCell
//
// Synopsis: Converts a config record to a query cell array. This is used to quickly
//           search by primary key values. 
//
// Arguments: [io_aCells] - array of query cells
//            [io_pcTotalCells] - total number of query cells in array
//            [i_fOnlyPKs] - only consider PKs, not any other columns
//=================================================================================
HRESULT
CConfigRecord::AsQueryCell (STQueryCell *io_aCells, ULONG *io_pcTotalCells, bool i_fOnlyPKs)
{
	ASSERT (io_aCells != 0);
	ASSERT (io_pcTotalCells != 0);

	HRESULT hr = SyncValues ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to sync values");
		return hr;
	}

	ULONG insertIdx = 0;
	for (ULONG idx=0; idx < ColumnCount(); ++idx)
	{
		// if we are interested in just the primary keys, skip all columns that are not PK
		if (i_fOnlyPKs && !(*m_pTableInfo->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_PRIMARYKEY))
		{
			continue;
		}

		if (m_ppvValues[idx] != 0)
		{
			switch (*m_pTableInfo->GetColumnMeta(idx).pType)
			{
			case DBTYPE_WSTR:
				// we don't support multistrings
				ASSERT (!(*m_pTableInfo->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_MULTISTRING));
				io_aCells[insertIdx].pData		= (void *) m_ppvValues[idx];
				io_aCells[insertIdx].eOperator	= eST_OP_EQUAL;
				io_aCells[insertIdx].iCell		= idx;
				io_aCells[insertIdx].dbType		= DBTYPE_WSTR;
				io_aCells[insertIdx].cbSize		= 0;
				insertIdx++;
				break;

			case DBTYPE_UI4:
				io_aCells[insertIdx].pData		= (void *) m_ppvValues[idx];
				io_aCells[insertIdx].eOperator	= eST_OP_EQUAL;
				io_aCells[insertIdx].iCell		= idx;
				io_aCells[insertIdx].dbType		= DBTYPE_UI4;
				io_aCells[insertIdx].cbSize		= 0;
				insertIdx++;
				break;

			case DBTYPE_BYTES:
				ASSERT (false && "NYI for bytes");
				// we don't handle bytes
				break;

			default:
				ASSERT (false && "Unknown datatype specified");
				break;
			}

		}
	}

	*io_pcTotalCells = insertIdx;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\cfgquery.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    cfgquery.cpp

$Header: $

Abstract:
	Configuration Query Class Implementation

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#include <comdef.h>
#include "wbemcli.h"
#include "cfgquery.h"
#include "cfgtablemeta.h"
#include "cfgrecord.h"
#include "smartpointer.h"

//=================================================================================
// Function: CConfigQuery::CConfigQuery
//
// Synopsis: Default Constructor
//=================================================================================
CConfigQuery::CConfigQuery ()
{
	m_cNrRows		= 0;
	m_ppvValues		= 0;
	m_pTableMeta	= 0;
	m_fInitialized  = false;
	m_wszDatabase	= 0;
	m_wszTable		= 0;
	m_wszSelector	= 0;
}

//=================================================================================
// Function: CConfigQuery::~CConfigQuery
//
// Synopsis: Destructor
//=================================================================================
CConfigQuery::~CConfigQuery ()
{
	delete [] m_ppvValues;
	m_ppvValues = 0;

	delete m_pTableMeta;
	m_pTableMeta = 0;

	delete [] m_wszDatabase;
	m_wszDatabase = 0;

	delete [] m_wszTable;
	m_wszTable = 0;

	delete [] m_wszSelector;
	m_wszSelector = 0;
}

//=================================================================================
// Function: CConfigQuery::Init
//
// Synopsis: Initializes a configuration query. It calls GetTable for the
//           specified database, table and selector. This means that the cache
//           will be populated at this point
//
// Arguments: [i_wszDatabase] - Database name
//            [i_wszTableName] - Table name
//            [i_wszSelector] - selector string
//            [i_pDispenser] - dispenser
//            
// Return Value: S_OK, no errors, non-S_OK errors
//=================================================================================
HRESULT
CConfigQuery::Init (LPCWSTR i_wszDatabase,
					LPCWSTR i_wszTableName,
					LPCWSTR i_wszSelector,
					ISimpleTableDispenser2 *i_pDispenser)
{
	ASSERT (!m_fInitialized);
	ASSERT (i_wszTableName != 0);
	ASSERT (i_pDispenser != 0);
	ASSERT (i_wszDatabase != 0);
	ASSERT (i_wszSelector != 0);

	HRESULT hr = S_OK;

	m_spDispenser = i_pDispenser;

	m_wszDatabase = new WCHAR [wcslen(i_wszDatabase) + 1];
	if (m_wszDatabase == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszDatabase, i_wszDatabase);

	m_wszTable = new WCHAR [wcslen(i_wszTableName) + 1];
	if (m_wszTable == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszTable, i_wszTableName);

	m_wszSelector = new WCHAR [wcslen(i_wszSelector) + 1];
	if (m_wszSelector == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszSelector, i_wszSelector);

	// get the table meta information
	
	m_pTableMeta = new CConfigTableMeta (m_wszTable, i_pDispenser);
	if (m_pTableMeta == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	hr = m_pTableMeta->Init ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get table meta information for table %s", i_wszTableName);
		return hr;
	}


	return hr;
}

//=================================================================================
// Function: CConfigQuery::Execute
//
// Synopsis: Executes the config query (i.e. does the GetTable). 
//
// Arguments: [pRecord] - Contains possible column values that need to be considered
//                        during GetTable execution. Note that this parameter can be null
//                        if you want to retrieve all records for a table without specifying
//                        any column values
//            [i_fOnlyPKs] - only use PK column values in the GetTable query
//            [i_fWriteAccess] - do we need write access? Default is read-only access
//=================================================================================
HRESULT 
CConfigQuery::Execute (CConfigRecord *pRecord, bool i_fOnlyPKs, bool i_fWriteAccess)
{
	HRESULT hr = S_OK;

	ULONG cNrCols = 0;
	if (pRecord != 0)
	{
		cNrCols = pRecord->ColumnCount ();
	}

	// number of column + selector
	TSmartPointerArray<STQueryCell> aCells = new STQueryCell[cNrCols + 1];
	if (aCells == 0)
	{
		return E_OUTOFMEMORY;
	}

	aCells[0].pData = (void *) m_wszSelector;
	aCells[0].eOperator = eST_OP_EQUAL;
	aCells[0].iCell = iST_CELL_SELECTOR;
	aCells[0].dbType = DBTYPE_WSTR;
	aCells[0].cbSize = 0;

	ULONG cNrCells = 1;

	if (pRecord != 0)
	{
		ULONG cTotalCells;
		hr = pRecord->AsQueryCell (aCells + 1, &cTotalCells, i_fOnlyPKs);
		if (FAILED (hr))
		{
			TRACE (L"Unable to convert record to query cell");
			return hr;
		}

		cNrCells += cTotalCells;
	}

	DWORD dwLOS = 0;
	if (i_fWriteAccess)
	{
		dwLOS = fST_LOS_READWRITE;
	}

	hr = m_spDispenser->GetTable(m_wszDatabase, 
								 m_wszTable, 
								 aCells, 
								 &cNrCells, 
								 eST_QUERYFORMAT_CELLS, 
								 dwLOS, 
								 (void **)&m_spWrite);
	if (FAILED(hr))
	{
		TRACE (L"Unable to get table. Database=%s, Table=%s, Selector=%s",
			   m_wszDatabase, m_wszTable, m_wszSelector);
		return hr;
	}
	
	// and get the numbers of rows

	hr = m_spWrite->GetTableMeta (0, 0, &m_cNrRows, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Table meta");
		return hr;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetColumnValues
//
// Synopsis: Get column value information for the row with index idx. This is
//           a simple forward to IST->GetColumnValues, but the function takes
//           care of converting the record to the correct types
//
// Arguments: [i_idx] - index of row to retrieve
//            [io_record] - information will be stored in here
//=================================================================================
HRESULT
CConfigQuery::GetColumnValues (ULONG i_idx, CConfigRecord& io_record)
{
	ASSERT (m_fInitialized );
	ASSERT (i_idx >= 0 && i_idx < m_cNrRows);
	
	HRESULT hr = io_record.Init (m_pTableMeta);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of config record failed");
		return hr;
	}

	hr = m_spWrite->GetColumnValues (i_idx, 
									 m_pTableMeta->ColumnCount (),
									 0,
									 io_record.GetSizes (),
									 io_record.GetValues ());
	if (FAILED (hr))
	{
		TRACE (L"Unable to get column values");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetRowCount
//
// Synopsis: Returns the number of rows that are return from the query
//=================================================================================
ULONG
CConfigQuery::GetRowCount ()
{
	ASSERT (m_fInitialized);
	
	return m_cNrRows;
}

//=================================================================================
// Function: CConfigQuery::GetEmptyConfigRecord
//
// Synopsis: Initializes an empty config record by attaching the correct table
//           meta information
//
// Arguments: [io_record] - record to be initialized
//=================================================================================
HRESULT
CConfigQuery::GetEmptyConfigRecord (CConfigRecord& io_record)
{
	ASSERT (m_pTableMeta != 0);

	HRESULT hr = io_record.Init (m_pTableMeta);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of configrecord failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetPKRow
//
// Synopsis: Get a single row based on Primary Key information. The record that is
//           passed in contains the values for the columns that make up the primary
//           key. We query the IST and if we find a match, we return the index of that
//           particular row in o_pcRow
//
// Arguments: [i_record] - record with PK information filled out
//            [o_pcRow] - index of row that contains PK, -1 if not found
//            
// Return Value: S_OK, no error, non-S_OK else
//=================================================================================
HRESULT 
CConfigQuery::GetPKRow (CConfigRecord& i_record, ULONG *o_pcRow)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pcRow != 0);

	HRESULT hr = i_record.SyncValues ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to sync values");
		return hr;
	}

	// special case singletons
	if (m_pTableMeta->PKCount () == 0)
	{
		if (m_cNrRows == 1)
		{
			*o_pcRow = 0;
		}
		else
		{
			hr = E_ST_NOMOREROWS;
		}
	}
	else
	{
		hr = m_spWrite->GetRowIndexBySearch (0,
											 m_pTableMeta->PKCount(), 
											 m_pTableMeta->GetPKInfo (), 
											 i_record.GetSizes (), 
											 i_record.GetValues (), 
											 o_pcRow);
		if (FAILED (hr))
		{
			// no tracing, because this is common code path
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetRowBySearch
//
// Synopsis: Returns the index of a row by searching for certain column values. The
//           columns that are needed for the search are specified as non-empty values
//           in the record that is passed into this function. The function simply forwards
//           to IST
//
// Arguments: [i_StartingRow] - Row to start searching from
//            [i_record] - record with column information that is used for the search
//            [o_pcRow] - index of found row, -1 if nothing found
//=================================================================================
HRESULT 
CConfigQuery::GetRowBySearch (ULONG i_StartingRow, CConfigRecord& i_record, ULONG *o_pcRow)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pcRow != 0);

	HRESULT hr = i_record.SyncValues ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to sync values");
		return hr;
	}

	// Build an array with indexes of columns that are relavant to the search. We skip
	// all columns that have 0 values;

	ULONG cNrRelevantCols = 0;
	TSmartPointerArray<ULONG> aColIndex = new ULONG[m_pTableMeta->ColumnCount()];
	if (aColIndex == 0)
	{
		return E_OUTOFMEMORY;
	}

	// skip over null columns
	LPVOID * aValues = i_record.GetValues ();
	for (ULONG idx=0; idx < m_pTableMeta->ColumnCount(); ++idx)
	{
		if (aValues[idx] != 0)
		{
			aColIndex[cNrRelevantCols++] = idx;
		}
	}

	// special case singleton

	if (cNrRelevantCols == 0)
	{
		if (i_StartingRow < m_cNrRows)
		{
			*o_pcRow = i_StartingRow;
		}
		else
		{
			return E_ST_NOMOREROWS;
		}
	}
	else
	{
		hr = m_spWrite->GetRowIndexBySearch (i_StartingRow,
												 cNrRelevantCols, 
												 aColIndex, 
												 i_record.GetSizes (), 
												 i_record.GetValues (), 
												 o_pcRow);
		if (FAILED (hr) && hr != E_ST_NOMOREROWS)
		{
			// no tracing, because this is common code path
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::UpdateRow
//
// Synopsis: Updates a record in the catalog. It first checks if the row exists. If the
//           row exists, it only has to update columns that are not PK values, else the
//           XML interceptor will return an error. If the row doesn't exist, an insert
//           is done instead.
//
// Arguments: [i_cReadRow] index of row to update (-1 if not exist)
//			  [i_record] - record to update/insert
//=================================================================================
HRESULT
CConfigQuery::UpdateRow (ULONG i_cReadRow, CConfigRecord& i_record, long lFlags)
{
	ASSERT (m_fInitialized);

	// does the row exist?
	HRESULT hr = S_OK;
	ULONG cWriteRow;

	if (i_cReadRow != -1)
	{
		if (lFlags == WBEM_FLAG_CREATE_ONLY)
		{
			TRACE (L"Trying to update while WBEM_FLAG_CREATE_ONLY is specified");
			return WBEM_E_ALREADY_EXISTS;
		}
		// we have to update an existing row
		// we have to separte insert and update, because we cannot overwrite primary
		// key values (the XML interceptor will return an error in this case). When we
		// do update, we take out the primary key values, so that they don't get 
		// updated.
		//ULONG cUpdateableCols = m_pTableMeta->ColumnCount () - m_pTableMeta->PKCount ();

		// figure out the number of updateable columns. This excludes the primary keys and
		// non-persistable columns
		ULONG cUpdateableCols = 0;
		for (ULONG idx=0; idx < m_pTableMeta->ColumnCount (); ++idx)
		{
			if (!(*m_pTableMeta->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_PRIMARYKEY) &&
				!(*m_pTableMeta->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE))
			{
				cUpdateableCols++;
			}
		}

		if (cUpdateableCols > 0)
		{
			// figure out which columns are not primary key columns so we can update
			// these.
			TSmartPointerArray<ULONG> spaColIdx = new ULONG [cUpdateableCols];
			if (spaColIdx == 0)
			{
				return E_OUTOFMEMORY;
			}

			ULONG updateIdx = 0;
			for (ULONG idx=0; idx < m_pTableMeta->ColumnCount (); ++idx)
			{
				if (!(*m_pTableMeta->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_PRIMARYKEY) &&
					!(*m_pTableMeta->GetColumnMeta (idx).pMetaFlags & fCOLUMNMETA_NOTPERSISTABLE))
				{
					spaColIdx[updateIdx++] = idx;
				}
			}

			ASSERT (updateIdx == cUpdateableCols);

			hr = m_spWrite->AddRowForUpdate (i_cReadRow, &cWriteRow);
			if (FAILED (hr))
			{
				TRACE (L"Unable to add row for update");
				return hr;
			}
			// BUGBUG(marcelv) HACKHACKHACKHACKHACKHACK
			// Because of a bug in the fastcache, we need to special case the code
			// in case we have to update a single column. When we want to update a single
			// column, SetWriteColumnValues expects the value to be in m_ppvValues[0], which
			// screws us in this case because we are passing in an array of values. By special
			// casing we work around the problem, however, it still needs to be fixed
			// in the fast cache to avoid problems in the future.

			if (updateIdx == 1)
			{
				ULONG cIdxUpdateCol = spaColIdx[0];
				hr = m_spWrite->SetWriteColumnValues (cWriteRow, 
													  1,
													  spaColIdx,
													  i_record.GetSizes (),
													  &i_record.GetValues ()[cIdxUpdateCol]);

			}
			else
			{
				hr = m_spWrite->SetWriteColumnValues (cWriteRow, 
													  updateIdx,
													  spaColIdx,
													  i_record.GetSizes (),
													  i_record.GetValues ());
			}
		}
	}
	else 
	{
		if (lFlags == WBEM_FLAG_UPDATE_ONLY)
		{
			TRACE (L"Trying to insert new row, while WBEM_FLAG_UPDATE_ONLY is specified");
			return WBEM_E_NOT_FOUND;
		}

		// record doesn't exist, so do insert instead
		hr = m_spWrite->AddRowForInsert (&cWriteRow);

		if (FAILED (hr))
		{
			TRACE (L"Unable to add row for insert");
			return hr;
		}

		hr = m_spWrite->SetWriteColumnValues (cWriteRow, 
									  m_pTableMeta->ColumnCount (),
									  0,
									  i_record.GetSizes (),
									  i_record.GetValues ());
	}

	if (FAILED (hr))
	{
		TRACE (L"Unable to update row");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::DeleteRow
//
// Synopsis: Delete the row with index i_idx
//
// Arguments: [i_idx] - index of row that will be deleted
//=================================================================================
HRESULT
CConfigQuery::DeleteRow (ULONG i_idx)
{
	ASSERT (m_fInitialized);
	ASSERT (i_idx >=0 && i_idx < m_cNrRows);

	HRESULT hr = m_spWrite->AddRowForDelete (i_idx);
	if (FAILED (hr))
	{
		TRACE (L"AddRowForDelete failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::Save
//
// Synopsis: Save the updates to the configuration store
//=================================================================================
HRESULT 
CConfigQuery::Save ()
{
	ASSERT (m_fInitialized);
	HRESULT hr = m_spWrite->UpdateStore ();
	if (FAILED (hr))
	{
		TRACE (L"UpdateStore failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::SaveSingleRow
//
// Synopsis: Calls updateStore for a single row in the write cache. This should be used
//           when a WMI::Put is called for a single instance, and not used for batch updates
//=================================================================================
HRESULT 
CConfigQuery::SaveSingleRow ()
{
	ASSERT (m_fInitialized);
	HRESULT hr = m_spWrite->UpdateStore ();

	if (hr == E_ST_DETAILEDERRS)
	{
		// try to get the detailed error
		HRESULT hrDetailed = 0;
		GetSingleDetailedError (&hrDetailed); // ignore errors from this function

		if (hrDetailed != 0)
		{
			hr = hrDetailed;
		}
	}
	
	if (FAILED (hr))
	{
		TRACE (L"UpdateStore failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetSingleDetailedError
//
// Synopsis: Gets the detailed error when we were updating a single row
//
// Arguments: [pDetailedHr] - hr of detailed error
//=================================================================================
HRESULT
CConfigQuery::GetSingleDetailedError (HRESULT * pDetailedHr)
{
	ASSERT (m_fInitialized);
	ASSERT (pDetailedHr != 0);
	ASSERT (*pDetailedHr == 0);

    CComPtr<ISimpleTableController> spISTController;
 
    HRESULT hr = m_spWrite->QueryInterface(IID_ISimpleTableController, (void **)&spISTController);

    if(FAILED(hr))
	{
		TRACE (L"Unable to get IID_ISimpleTableController interface");
        return hr;
	}

	ULONG cNrErrors = 0;
    hr = spISTController->GetDetailedErrorCount(&cNrErrors);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get error count");
		return hr;
	}

	ASSERT (cNrErrors == 1);

	STErr err;
	hr = spISTController->GetDetailedError(0, &err);
	if(FAILED(hr))
	{
		TRACE (L"Unable to get detailed error");
		return hr;
	}

	*pDetailedHr = err.hr;

	return S_OK;
}

HRESULT
CConfigQuery::GetDetailedErrorCount (ULONG *pCount)
{
	ASSERT (m_fInitialized);
	ASSERT (pCount != 0);
	*pCount = 0;

	CComPtr<ISimpleTableController> spISTController;
    HRESULT hr = m_spWrite->QueryInterface(IID_ISimpleTableController, (void **)&spISTController);
    if(FAILED(hr))
	{
		TRACE (L"Unable to get IID_ISimpleTableController interface");
        return hr;
	}

    hr = spISTController->GetDetailedErrorCount(pCount);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get error count");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CConfigQuery::GetDetailedError
//
// Synopsis: Get a detailed error
//
// Arguments: [idx] - index of detailed error
//            [pErrInfo] - error information will be stored here
//=================================================================================
HRESULT
CConfigQuery::GetDetailedError (ULONG idx, STErr* pErrInfo)
{
	ASSERT (m_fInitialized);
	ASSERT (pErrInfo != 0);
	
	CComPtr<ISimpleTableController> spISTController;
    HRESULT hr = m_spWrite->QueryInterface(IID_ISimpleTableController, (void **)&spISTController);
    if(FAILED(hr))
	{
		TRACE (L"Unable to get IID_ISimpleTableController interface");
        return hr;
	}

	hr = spISTController->GetDetailedError(idx, pErrInfo);
	if(FAILED(hr))
	{
		TRACE (L"Unable to get detailed error");
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\classfactory.cpp ===
//***************************************************************************
//
//  ClassFactory.cpp
//
//  Module: Unmanaged WMI Provider for COM+
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved 
//
//***************************************************************************


#pragma warning( disable : 4786 )

#include "classfactory.h"
#include "instanceprovider.h"


LONG CClassFactory :: m_LockCount = 0 ;

//***************************************************************************
//
// Constructin / Destruction
//
//***************************************************************************

CClassFactory::CClassFactory ( int iFactoryType )
{
	m_RefCount = 0 ;
	
	ASSERT(iFactoryType==2) 

	m_iFactoryType = iFactoryType;
}

CClassFactory::~CClassFactory ()
{

}

//***************************************************************************
//
// 
//
//***************************************************************************

STDMETHODIMP CClassFactory::QueryInterface ( REFIID iid , 
											LPVOID FAR *iplpv ) 
{
	HRESULT hRes;
	*iplpv = NULL ;

	try	
	{
		if ( iid == IID_IUnknown )
			*iplpv = dynamic_cast<IUnknown*> (this);
		
		else if ( iid == IID_IClassFactory )
			*iplpv = dynamic_cast<IClassFactory*> (this);		

		if ( *iplpv )
		{
			( static_cast<IUnknown*> (*iplpv) )->AddRef () ;

			hRes = S_OK;
		}
		else
		{
			hRes = E_NOINTERFACE;
		}
	}
	catch( ... )
	{
		
		hRes = E_NOINTERFACE;
	}

	return hRes;
}


STDMETHODIMP_(ULONG) CClassFactory :: AddRef ()
{
	return InterlockedIncrement ( &m_RefCount ) ;
}

STDMETHODIMP_(ULONG) CClassFactory :: Release ()
{	
	LONG ref ;

	if ( ( ref = InterlockedDecrement ( & m_RefCount ) ) == 0 )
	{
		delete this ;
	}
	return ref ;
}

//***************************************************************************
//
// CClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CClassFactory :: LockServer ( BOOL fLock )
{
	if ( fLock )
	{
		InterlockedIncrement ( & m_LockCount ) ;
	}
	else
	{
		InterlockedDecrement ( & m_LockCount ) ;
	}

	return S_OK	;
}

//***************************************************************************
//
// CClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
											 REFIID riid,
											 LPVOID FAR * ppvObject )
{
	HRESULT hRes = E_FAIL;

	if ( pUnkOuter )
	{
		return CLASS_E_NOAGGREGATION;
	}
		
	switch (m_iFactoryType)
	{
	case 2:
		{
			CInstanceProvider * pInstanceProvider = new CInstanceProvider ;
			if ( pInstanceProvider == NULL )
			{
				hRes = E_OUTOFMEMORY;
				break;
			}
			hRes = pInstanceProvider->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( hRes ) )
			{
				TRACE (L"Queryinterface failed inside CClassFactory::CreateInstance");
				delete pInstanceProvider ;
			}
		}
	break;

	default:
		ASSERT(false && "Unknown factory type specified");
	break;
	}

	return hRes ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\instancehelper.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    instancehelper.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/14/2000		Initial Release

Revision History:

--**************************************************************************/

#include "instancehelper.h"
#include "localconstants.h"
#include "stringutil.h"
#include "smartpointer.h"
#include "wmihelper.h"
#include "webapphelper.h"

#include "codegrouphelper.h"

//=================================================================================
// Function: CInstanceHelper::CInstanceHelper
//
// Synopsis: Default constructor
//=================================================================================
CInstanceHelper::CInstanceHelper ()
{
	m_fIsAssociation	= false;
	m_fHasDBQualifier	= false;
	m_fInitialized		= false;
}

//=================================================================================
// Function: CInstanceHelper::~CInstanceHelper
//
// Synopsis: Default Destructor
//=================================================================================
CInstanceHelper::~CInstanceHelper ()
{
}

//=================================================================================
// Function: CInstanceHelper::Init
//
// Synopsis: Initializes the instance helper. Needs to be called before any other
//           functions defined for the InstanceHelper class.
//
// Arguments: [i_ObjectPath] - WMI Object path
//            [i_lFlags] - Flags 
//            [i_pCtx] - WMI Context
//            [i_pResponseHandler] - WMI Response handler for async response 
//            [i_pNamespace] - WMI Namespace
//            [i_pDispenser] - Catalog dispenser
//            
// Return Value: S_OK everything ok, non-S_OK error
//=================================================================================
HRESULT
CInstanceHelper::Init (const BSTR i_ObjectPath, 
					   long i_lFlags,
					   IWbemContext *i_pCtx,
					   IWbemObjectSink * i_pResponseHandler,
					   IWbemServices * i_pNamespace,
					   ISimpleTableDispenser2 * i_pDispenser)
{
	ASSERT (!m_fInitialized);
	ASSERT (i_ObjectPath != 0);
	ASSERT (i_pCtx != 0);
	ASSERT (i_pResponseHandler != 0);
	ASSERT (i_pNamespace != 0);
	ASSERT (i_pDispenser != 0);

	m_spCtx				= i_pCtx;
	m_spResponseHandler = i_pResponseHandler;
	m_spNamespace		= i_pNamespace;
	m_spDispenser		= i_pDispenser;
	m_lFlags			= i_lFlags;
	
	HRESULT hr = m_objPathParser.Parse (i_ObjectPath);
	if (FAILED (hr))
	{
		TRACE (L"Parsing of object path %s failed", i_ObjectPath);
		return hr;
	}

	ASSERT (m_objPathParser.GetClass () != 0);

	hr = m_spNamespace->GetObject((LPWSTR) m_objPathParser.GetClass (), 
											0, 
											m_spCtx, 
											&m_spClassObject, 
											0); 
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", m_objPathParser.GetClass ());
		return hr;
	}

	CComPtr<IWbemQualifierSet> spQualifierSet;
	hr = m_spClassObject->GetQualifierSet (&spQualifierSet);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Qualifier set for class %s", m_objPathParser.GetClass ());
		return hr;
	}
		
	_variant_t varAssoc;
	hr = spQualifierSet->Get (L"Association", 0, &varAssoc, 0);
	if (SUCCEEDED (hr))
	{
		m_fIsAssociation = true;
	}
	else
	{
		hr = S_OK;
	}

	_variant_t varDB;
	hr = spQualifierSet->Get (L"Database", 0, &varAssoc, 0);
	if (SUCCEEDED (hr))
	{
		m_fHasDBQualifier = true;
	}
	else
	{
		hr = S_OK;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CInstanceHelper::CreateInstance
//
// Synopsis: Creates a single WMI Instance
//
// Arguments: [ppNewInst] - instance is returned in this parameter
//            
// Return Value: 
//=================================================================================
HRESULT
CInstanceHelper::CreateInstance (IWbemClassObject **o_ppNewInst)
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);
	ASSERT (o_ppNewInst != 0);

	*o_ppNewInst = 0;

	// getSingleRecord initilizes m_cfgQuery and gets the record from the catalog.
	// if the record does not exist, GetSingleRecord will fail.

	ULONG cRowIdx; //index of record found
	HRESULT hr = GetSingleRecord (&cRowIdx, false);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get single record from catalog");
		if (hr == E_ST_NOMOREROWS)
		{
			hr = WBEM_E_NOT_FOUND;
		}
		return hr;
	}

	// we found the record. Retrieve the actual column values, and create a WMI
	// instance of the record

	CConfigRecord record;
	hr = m_cfgQuery.GetColumnValues (cRowIdx, record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get column values for record %ld", cRowIdx);
		return hr;
	}

	//////////// SPECIAL CASE CODEGROUPS //////
	//// 

	if (_wcsicmp (m_objPathParser.GetClass (), WSZCODEGROUP) == 0)
	{
		return CreateCodeGroupInstance (record, o_ppNewInst);
	}


	hr = CreateSingleInstance (record, o_ppNewInst);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create single instance");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceHelper::CreateSingleInstance
//
// Synopsis: Create a WMI Instance from a configuration record
//
// Arguments: [record] - record to convert to WMI Instance
//            [o_ppNewInst] - new WMI Instance will be stored here
//=================================================================================
HRESULT
CInstanceHelper::CreateSingleInstance (const CConfigRecord& i_record,
									   IWbemClassObject **o_ppNewInst)
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);
	ASSERT (o_ppNewInst != 0);
	
	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, o_ppNewInst);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class %s", m_objPathParser.GetClass ());
		return hr;
	}

	// add all the individual properties
	for (ULONG idx=0; idx<i_record.ColumnCount(); ++idx)
	{
		if (i_record.IsPersistableColumn (idx))
		{
			LPCWSTR wszColName	= i_record.GetColumnName (idx);
			_variant_t varValue;
			hr = i_record.GetValue (idx, varValue);
			if (FAILED (hr))
			{
				TRACE (L"Unable to get value for column %s", wszColName);
				return hr;
			}

			hr = (*o_ppNewInst)->Put((_bstr_t)wszColName, 0, &varValue, 0);
			if (FAILED (hr))
			{
				TRACE (L"WMI Put property of %s and value %s failed",
					   wszColName, (LPWSTR)((_bstr_t) varValue));
				return hr;
			}
		}
	}

	// and add the selector
	const CWMIProperty *pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	ASSERT (pSelector != 0);

	_variant_t varSelector = pSelector->GetValue ();
	hr = (*o_ppNewInst)->Put ((_bstr_t)WSZSELECTOR, 0, &varSelector, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put Property of selector failed (value = %s)", pSelector->GetValue ());
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceHelper::DeleteInstance
//
// Synopsis: Delete a single WMI INstance from the configuration store
//=================================================================================
HRESULT
CInstanceHelper::DeleteInstance ()
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);

	// getSingleRecord initilizes m_cfgQuery. And figures out if the record does
	// actually exist in the configuration store
	
	ULONG cRowIdx; //index of record found

	HRESULT hr = GetSingleRecord (&cRowIdx, true);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get instance record from catalog");
		return hr;
	}

	hr = m_cfgQuery.DeleteRow (cRowIdx);
	if (FAILED (hr))
	{
		TRACE (L"Unable to delete row");
		return hr;
	}

	hr = m_cfgQuery.SaveSingleRow ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to save");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceHelper::PutInstance
//
// Synopsis: Creates a new record in the configuration store from a WMI instance
//
// Arguments: [i_pInst] - WMI Instance to create config record for
//=================================================================================
HRESULT
CInstanceHelper::PutInstance (IWbemClassObject * i_pInst)
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation);
	ASSERT (i_pInst != 0);

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;
	HRESULT hr = CWMIHelper::GetClassInfo (m_spClassObject, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get database name and table name for %s", m_objPathParser.GetClass ());
		return hr;
	}

	_variant_t varSelector;
	hr = i_pInst->Get(WSZSELECTOR, 0, &varSelector, 0 , 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get selector property");
		return hr;
	}

	hr = m_cfgQuery.Init (bstrDBName, bstrTableName, _bstr_t (varSelector), m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of config query failed (db=%s, table=%s)", (LPWSTR) bstrDBName, (LPWSTR) bstrTableName);
		return hr;
	}

	CConfigRecord record;
	hr = m_cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get empty configuration record");
		return hr;
	}

	//////////// SPECIAL CODE FOR CodeGroup //////////////////////
	if (_wcsicmp (m_objPathParser.GetClass (), WSZCODEGROUP) == 0)
	{
		hr = PopulateCodeGroupRecord (i_pInst, record);
		if (FAILED (hr))
		{
			TRACE (L"Unable to populate codegroup record");
			return hr;
		}
	}
	else
	{
		hr = PopulateConfigRecord (i_pInst, record);
		if (FAILED (hr))
		{
			TRACE (L"Unable to populate codegroup record");
			return hr;
		}
	}


	hr = m_cfgQuery.Execute (&record, true, true);
	if (FAILED (hr))
	{
		TRACE (L"Execution of query failed");
		return hr;
	}

	ULONG cReadRow = (ULONG) -1;
	if (m_cfgQuery.GetRowCount () != 0)
	{
		ASSERT (m_cfgQuery.GetRowCount () == 1);
		cReadRow = 0;
	}
	
	hr = m_cfgQuery.UpdateRow (cReadRow, record, m_lFlags);
	if (FAILED (hr))
	{
		TRACE (L"UpdateRow failed");
		return hr;
	}

	hr = m_cfgQuery.SaveSingleRow ();
	if (FAILED (hr))
	{
		TRACE (L"Save failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceHelper::IsAssociation
//
// Synopsis: Returns true if the instance is an association, false if not
//=================================================================================
bool
CInstanceHelper::IsAssociation () const
{
	ASSERT (m_fInitialized);

	return m_fIsAssociation;
}

//=================================================================================
// Function: CInstanceHelper::GetSingleRecord
//
// Synopsis: Get a single record from the config store. o_record contains the primary
//           key column values so that the record can be retrieved
//
// Arguments: [o_pcRow] - index of record that was found
//            
// Return Value: 
//=================================================================================
HRESULT
CInstanceHelper::GetSingleRecord (ULONG *o_pcRow, bool i_fWriteAccess)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pcRow != 0);
	ASSERT (!m_fIsAssociation);

	*o_pcRow = (ULONG) -1;

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;
	HRESULT hr = CWMIHelper::GetClassInfo (m_spClassObject, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get DBName and TableName");
		return hr;
	}

	const CWMIProperty * pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		TRACE (L"Objectpath without Selector");
		return E_INVALIDARG;
	}

	hr = m_cfgQuery.Init (bstrDBName, bstrTableName, pSelector->GetValue(), m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Query Initialization failed");
		return hr;
	}
	
	CConfigRecord record;
	
	hr  = m_cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get empty configuration record");
		return hr;
	}

	for (ULONG idx=0; idx != m_objPathParser.GetPropCount (); ++idx)
	{
		const CWMIProperty * pProp = m_objPathParser.GetProperty (idx);
		record.SetValue (pProp->GetName (), pProp->GetValue()); // ignore errors
	}

	hr = m_cfgQuery.Execute (&record, true, i_fWriteAccess);
	if (FAILED (hr))
	{
		TRACE (L"Query Execution failed");
		return hr;
	}

	// at this point, we either found a single row or nothing. So check how many rows
	// we have. If we don't have any rows, we return an error, else we return a pointer
	// to the single row

	if (m_cfgQuery.GetRowCount () != 1)
	{
		ASSERT (m_cfgQuery.GetRowCount () == 0);
		return E_ST_NOMOREROWS;
	}

	*o_pcRow = 0;


	return hr;
}

//=================================================================================
// Function: CInstanceHelper::CreateAssociation
//
// Synopsis: Creates an association. Simple copy the input information to the output
//           information.
//
// Return Value: 
//=================================================================================
HRESULT
CInstanceHelper::CreateAssociation ()
{
	ASSERT (m_fInitialized);
	
	CComPtr<IWbemClassObject> spNewInst;

	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, &spNewInst);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class %s", m_objPathParser.GetClass ());
		return hr;
	}

	// copy each property to the new instance
	for (ULONG idx=0; idx < m_objPathParser.GetPropCount (); ++idx)
	{
		const CWMIProperty * pProp = m_objPathParser.GetProperty (idx);
		_variant_t varValue = pProp->GetValue ();

		hr = spNewInst->Put(pProp->GetName (), 0, &varValue, 0);
		if (FAILED (hr))
		{
			TRACE (L"Put failed when creating WMI Assocation");
			return hr;
		}
	}

	IWbemClassObject* pNewInstRaw = spNewInst;
	hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);

	if (FAILED (hr))
	{
		TRACE (L"WMI Indicate failed");
	}

	return hr;
}

HRESULT CInstanceHelper::CreateStaticInstance ()
{
	HRESULT hr = S_OK;
	if (_wcsicmp (m_objPathParser.GetClass (), L"WebApplication") == 0)
	{
		// probably other class.
		hr = CreateWebApp ();
		if (FAILED (hr))
		{
			TRACE (L"Error while creating web app instance");
			return hr;
		}
	}
	else if (_wcsicmp (m_objPathParser.GetClass (), L"ConfigurationFile") == 0)
	{
		hr = CreateConfigurationFile ();
		if (FAILED (hr))
		{
			return hr;
		}
	}
	else
	{
		TRACE (L"Unable to create configuration class: %s", m_objPathParser.GetClass ());
	}

	return hr;
}

HRESULT
CInstanceHelper::CreateWebApp ()
{
	if (_wcsicmp (m_objPathParser.GetClass (), L"WebApplication") != 0)
	{
		return S_OK;
	}

	HRESULT hr = S_OK;
	CWebAppHelper webAppHelper;
	hr = webAppHelper.Init ((_bstr_t)L"WebApplication",0, m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		return hr;
	}

	const CWMIProperty * pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		TRACE (L"Object path doesn't have selector");
		return E_INVALIDARG;
	}

	hr = webAppHelper.CreateSingleInstance (pSelector->GetValue ());
	if (FAILED(hr))
	{
		TRACE (L"CreateSingleInstance of webAppHelper failed");
		return hr;
	}

	return hr;
}

HRESULT
CInstanceHelper::CreateConfigurationFile ()
{
	ASSERT (m_fInitialized);
	
	CComPtr<IWbemClassObject> spNewInst;

	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, &spNewInst);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class %s", m_objPathParser.GetClass ());
		return hr;
	}

	// copy each property to the new instance
	for (ULONG idx=0; idx < m_objPathParser.GetPropCount (); ++idx)
	{
		const CWMIProperty * pProp = m_objPathParser.GetProperty (idx);
		_variant_t varValue = pProp->GetValue ();

		hr = spNewInst->Put(pProp->GetName (), 0, &varValue, 0);
		if (FAILED (hr))
		{
			TRACE (L"Put failed when creating WMI Assocation");
			return hr;
		}
	}

	// and add the path property
	const CWMIProperty * pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		TRACE (L"Unable to get Selector property");
		return E_INVALIDARG;
	}

	LPCWSTR wszSelector = pSelector->GetValue ();

	// only set path if selector starts with 'file://"
	static LPCWSTR wszFileProtocol = L"file://";
	static SIZE_T cLenFileProtocol = wcslen (wszFileProtocol);

	if (wcsncmp (wszSelector, wszFileProtocol, cLenFileProtocol) == 0)
	{
		_variant_t varPath = wszSelector + cLenFileProtocol;
		hr = spNewInst->Put (L"Path", 0, &varPath, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to set 'Path' property");
			return hr;
		}
	}

	IWbemClassObject* pNewInstRaw = spNewInst;
	hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);

	if (FAILED (hr))
	{
		TRACE (L"WMI Indicate failed");
	}

	return hr;
}

HRESULT
CInstanceHelper::DeleteWebApp ()
{
	if (_wcsicmp (m_objPathParser.GetClass (), L"WebApplication") != 0)
	{
		return S_OK;
	}

	HRESULT hr = S_OK;
	CWebAppHelper webAppHelper;
	hr = webAppHelper.Init ((_bstr_t)L"WebApplication",0, m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		TRACE (L"Unable to initialize web application");
		return hr;
	}

	hr = webAppHelper.Delete (m_objPathParser);
	if (FAILED(hr))
	{
		TRACE (L"Unable to delete webapplication");
		return hr;
	}

	return hr;
}

HRESULT
CInstanceHelper::PutInstanceWebApp (IWbemClassObject *pInst)
{
	ASSERT (pInst != 0);

	// only handle WebApplication class
	_variant_t varClassName;
	HRESULT hr = pInst->Get(L"__class", 0, &varClassName, 0 , 0);
	if (_wcsicmp (varClassName.bstrVal, L"WebApplication") != 0)
	{
		return S_OK;
	}

	CWebAppHelper webAppHelper;
	hr = webAppHelper.Init ((_bstr_t)L"WebApplication",0, m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		TRACE (L"Unable to initialize web application");
		return hr;
	}

	hr = webAppHelper.PutInstance (pInst);
	if (FAILED(hr))
	{
		TRACE (L"Unable to create webapplication");
		return hr;
	}

	return hr;
}

bool 
CInstanceHelper::HasDBQualifier () const
{
	ASSERT (m_fInitialized);

	return m_fHasDBQualifier;
}

//=================================================================================
// Function: CInstanceHelper::PopulateConfigRecord
//
// Synopsis: Populate a config record from a WMI instance. Simply walk through all the
//           properties, and assign the to the properties in the config record
//
// Arguments: [i_pInst] - WMI instance to be converted
//            [record] - record that is going to contain the new information
//=================================================================================
HRESULT
CInstanceHelper::PopulateConfigRecord (IWbemClassObject * i_pInst, CConfigRecord& record)
{
	ASSERT (i_pInst != 0);

	// loop through all values in the object, and save to the record
	HRESULT hr = m_spClassObject->BeginEnumeration (WBEM_FLAG_NONSYSTEM_ONLY);
	if (FAILED(hr))
	{
		TRACE (L"BeginEnumeration failed for class %s", m_objPathParser.GetClass ());
		return hr;
	}


	hr = 0;
	while (SUCCEEDED (hr))
	{
		CComBSTR bstrName;
		hr = m_spClassObject->Next (0, &bstrName, 0, 0, 0);
		if (hr == WBEM_S_NO_MORE_DATA)
		{
			// we went over all properties
			hr = S_OK;
			break;
		}

		if (FAILED (hr))
		{
			TRACE (L"IWbemClassObject::Next failed in PutInstance");
			return hr;
		}
	
		_variant_t varValue;
		hr = i_pInst->Get(bstrName, 0, &varValue, 0, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get WMI value for %s", bstrName);
			return hr;
		}

		record.SetValue (bstrName, varValue); // ignore errors because properties might not be present
	}

	// release resources
	hr = m_spClassObject->EndEnumeration ();
	if (FAILED (hr))
	{
		TRACE (L"EndEnumeration failed");
		return hr;
	}

	return hr;
}


///////////////// SPECIAL CASE for code groups//////////////////////////////

//=================================================================================
// Function: CInstanceHelper::CreateCodeGroupInstance
//
// Synopsis: Creates an instance of class CodeGroup from a configrecord. This class needs
//           special casing because codegroup information is written as an XML BLob to the
//           xml file.
//
// Arguments: [record] - record that contains XML BLOB that needs to be converted to
//                       WMI Instance
//            [o_ppNewInst] - new instance to be created
//            
// Return Value: 
//=================================================================================
HRESULT 
CInstanceHelper::CreateCodeGroupInstance (const CConfigRecord& record, IWbemClassObject **o_ppNewInst)
{
	ASSERT (o_ppNewInst != 0);

	CCodeGroupHelper codegroupHelper;

	HRESULT hr = codegroupHelper.Init (m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		TRACE (L"Init of codegroupHelper failed");
		return hr;
	}

	const CWMIProperty *pSelector = m_objPathParser.GetPropertyByName (WSZSELECTOR);
	ASSERT (pSelector != 0);

	hr = codegroupHelper.CreateInstance (record, pSelector->GetValue (), o_ppNewInst);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create codegroup instance");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CInstanceHelper::PopulateCodeGroupRecord
//
// Synopsis: Populates a config record from a WMI Instance. Special casing for CodeGroup
//           class
//
// Arguments: [i_pInst] - instance with codegroup information
//            [record] - record to be populated
//            
// Return Value: 
//=================================================================================
HRESULT
CInstanceHelper::PopulateCodeGroupRecord (IWbemClassObject *i_pInst, CConfigRecord& record)
{
	ASSERT (i_pInst != 0);

	CCodeGroupHelper codegroupHelper;

	HRESULT hr = codegroupHelper.Init (m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		TRACE (L"Init of codegroupHelper failed");
		return hr;
	}

	hr = codegroupHelper.PutInstance (i_pInst, record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create codegroup instance");
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\codegrouphelper.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    codegrouphelper.h

$Header: $

Abstract:
	Codegroup Helper class

Author:
    marcelv 	2/16/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CODEGROUPHELPER_H__
#define __CODEGROUPHELPER_H__

#pragma once

#include <atlbase.h>
#include <comdef.h>
#include <wbemidl.h>
#include "catalog.h"
#include "xmlcfgcodegroup.h"

// forward declaration
class CConfigRecord;

class CCodeGroupHelper
{
public:
	CCodeGroupHelper ();
	~CCodeGroupHelper ();

	HRESULT Init (IWbemContext *			i_pCtx,
				  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace);

	HRESULT CreateInstance (const CConfigRecord& record, 
						    LPCWSTR i_wszSelector,
							IWbemClassObject **o_ppNewInstance);

	HRESULT PutInstance (IWbemClassObject * i_pInst, CConfigRecord& record);

private:
	HRESULT ParseXML (LPCWSTR i_wszXML);

	CCodeGroupHelper (const CCodeGroupHelper& );
	CCodeGroupHelper& operator= (const CCodeGroupHelper& );

	CXMLCfgCodeGroups m_CodeGroup;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\impersonate.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    impersonate.cpp

$Header: $

Abstract:

Author:
    marcelv 	2/22/2001		Initial Release

Revision History:

--**************************************************************************/

#include "impersonate.h"

static bool g_fOnNT		= false; // are we on NT or not
static bool g_fChecked	= false; // did we already check if we are on NT?

//=================================================================================
// Function: CImpersonator::CImpersonator
//
// Synopsis: Constructor. Do nothing
//
//=================================================================================
CImpersonator::CImpersonator ()
{
}

//=================================================================================
// Function: CImpersonator::~CImpersonator
//
// Synopsis: RevertToSelf in case we are on NT
//
//=================================================================================
CImpersonator::~CImpersonator ()
{
	if (g_fOnNT)
	{
		HRESULT hr = CoRevertToSelf ();
		if (FAILED (hr))
		{
			// we can only trace .. no point to return error message at this point
			TRACE (L"CoRevertToSelf failed");
		}
	}
}

//=================================================================================
// Function: CImpersonator::ImpersonateClient
//
// Synopsis: If we are on NT, Call CoImpersonateClient.
//
// Return Value: 
//=================================================================================
HRESULT
CImpersonator::ImpersonateClient () const
{
	HRESULT hr = S_OK;

	// check if we are on NT. We only do this once, because if we know if we are on NT, we
	// don't have to check all the time. 
	if (!g_fChecked)
	{
		OSVERSIONINFO versionInfo;
		versionInfo.dwOSVersionInfoSize = sizeof(versionInfo);

		BOOL fSuccess = GetVersionEx (&versionInfo);
		if (!fSuccess)
		{
			TRACE (L"GetVersionEx failed");
			hr = HRESULT_FROM_WIN32(GetLastError());
			return hr;
		}

		if (versionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
		{
			g_fOnNT = true;
		}

		g_fChecked = true;
	}

	if (g_fOnNT)
	{
		hr = CoImpersonateClient ();
		if (FAILED (hr))
		{
			TRACE (L"CoImpersonateClient failed");
		}
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\maindll.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    maindll.h

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __MAINDLL_H__
#define __MAINDLL_H__

#pragma once



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\codegrouphelper.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    codegrouphelper.cpp

$Header: $

Abstract:
	CodeGroup Helper class

Author:
    marcelv 	2/16/2001		Initial Release

Revision History:

--**************************************************************************/

#include "codegrouphelper.h"
#include "cfgrecord.h"

//=================================================================================
// Function: CCodeGroupHelper::CCodeGroupHelper
//
// Synopsis: Default Constructor
//=================================================================================
CCodeGroupHelper::CCodeGroupHelper ()
{
}

//=================================================================================
// Function: CCodeGroupHelper::~CCodeGroupHelper
//
// Synopsis: Destructor
//=================================================================================
CCodeGroupHelper::~CCodeGroupHelper ()
{
}

//=================================================================================
// Function: CCodeGroupHelper::Init
//
// Synopsis: Initializes the codegroup helper
//
// Arguments: [i_pCtx] - context
//            [i_pResponseHandler] - response handler
//            [i_pNamespace] - namespace
//=================================================================================
HRESULT
CCodeGroupHelper::Init (IWbemContext *		i_pCtx,
						IWbemObjectSink *	i_pResponseHandler,
						IWbemServices *		i_pNamespace)
{
	ASSERT (i_pCtx != 0);
	ASSERT (i_pResponseHandler != 0);
	ASSERT (i_pNamespace != 0);

	HRESULT hr = S_OK;

	hr = m_CodeGroup.Init (i_pCtx, i_pNamespace);
	if (FAILED (hr))
	{
		TRACE (L"Init of codegroup failed");
		return hr;
	}
	
	return hr;
}

//=================================================================================
// Function: CCodeGroupHelper::ParseXML
//
// Synopsis: Parses the XML that comes from an XML BLOB (by forwarding to the XMLCfgCodeGroup
//           and initializes the m_codeGroup datamember so that all values are the same
//           as they are in the XML
//
// Arguments: [i_wszXML] - XML String
//=================================================================================
HRESULT
CCodeGroupHelper::ParseXML (LPCWSTR i_wszXML)
{
	ASSERT (i_wszXML != 0);

	CComPtr<IXMLDOMDocument> spXMLDoc;
	HRESULT hr = CoCreateInstance (CLSID_DOMDocument, 0, CLSCTX_INPROC_SERVER, 
			  					   IID_IXMLDOMDocument, (void **) &spXMLDoc);
	if (FAILED (hr))
	{
		TRACE (L"CoCreateInstance failed for IID_IXMLDOMDocument");
		return hr;
	}

	VARIANT_BOOL fIsSuccess;
	hr = spXMLDoc->loadXML (_bstr_t(i_wszXML), &fIsSuccess);
	if (!fIsSuccess || FAILED(hr))
	{
		TRACE (L"loadXML failed in CCodeGroupHelper");
		return E_SDTXML_XML_FAILED_TO_PARSE;
	}

	CComPtr<IXMLDOMElement> spRootElement;
	hr = spXMLDoc->get_documentElement (&spRootElement);
	if (FAILED (hr))
	{
		TRACE (L"get_documentElement failed");
		return hr;
	}

	hr = m_CodeGroup.ParseXML (spRootElement);
	if (FAILED (hr))
	{
		TRACE (L"ParseXML failed for codegroup");
		return hr;
	}

	return S_OK;
}

//=================================================================================
// Function: CCodeGroupHelper::CreateInstance
//
// Synopsis: Creates a single WMI CodeGroup Instance from an XML Blob
//
// Arguments: [record] - record that contains CodeGroup info in XML Blob
//            [i_wszSelector] - selector used to get this infroamtion
//            [o_ppNewInstance] - new WMI Codegroup instance
//=================================================================================
HRESULT 
CCodeGroupHelper::CreateInstance (const CConfigRecord& i_record, 
								  LPCWSTR i_wszSelector,
								  IWbemClassObject **o_ppNewInstance)
{
	ASSERT (i_wszSelector != 0);
	ASSERT (o_ppNewInstance != 0);

	static LPCWSTR wszValue = L"value";

	HRESULT hr = S_OK;
	for (ULONG idx=0; idx < i_record.ColumnCount (); ++idx)
	{
		if (_wcsicmp (i_record.GetColumnName (idx), wszValue) == 0)
		{
			LPWSTR wszXML = (LPWSTR) i_record.GetValues ()[idx];
			hr = ParseXML (wszXML);
			if (FAILED (hr))
			{
				TRACE (L"Parsing of XML failed: %s", wszXML);
				return hr;
			}
			break;
		}
	}

	hr = m_CodeGroup.SetRecordProperties (i_record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set record properties");
		return hr;
	}

	hr = m_CodeGroup.AsWMIInstance (i_wszSelector, o_ppNewInstance);
	if (FAILED (hr))
	{
		TRACE (L"Creation of WMI Instance failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CCodeGroupHelper::PutInstance
//
// Synopsis: Put a single WMI Instance. Saves it as XML Blob to the XML file
//
// Arguments: [i_pInst] - Instance to be saved
//            [record] - Record that will contain information after it is converted from
//                       WMI, so that we can pass it back to the rest of the framewrok
//                       which will do the actual update to the catalog
//=================================================================================
HRESULT
CCodeGroupHelper::PutInstance (IWbemClassObject* i_pInst, CConfigRecord& record)
{
	HRESULT hr = m_CodeGroup.CreateFromWMI (i_pInst);
	if (FAILED (hr))
	{
		TRACE (L"CreateFromWMI failed in CCodeGroupHelper");
		return hr;
	}

	hr = m_CodeGroup.ToCfgRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"CXMLCodeGroup::ToCfgRecord failed");
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\instancehelper.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    instancehelper.h

$Header: $

Abstract:
	Instance Helper. Makes it easy to create/update/delete single class instances

Author:
    marcelv 	11/14/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __INSTANCEHELPER_H__
#define __INSTANCEHELPER_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "wmiobjectpathparser.h"
#include "cfgquery.h"
#include "cfgrecord.h"

/**************************************************************************++
Class Name:
    CInstanceHelper

Class Description:
    Helper to create/delete/update single class instances

Constraints:

--*************************************************************************/
class CInstanceHelper
{
public:
	CInstanceHelper ();
	~CInstanceHelper ();

	HRESULT Init (const BSTR				i_ObjectPath,
		          long						i_lFlags,
                  IWbemContext *			i_pCtx,
                  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace,
				  ISimpleTableDispenser2 *	i_pDispenser);

	HRESULT CreateInstance (IWbemClassObject **pNewInst);
	HRESULT DeleteInstance ();
	HRESULT PutInstance (IWbemClassObject * i_pInst);

	HRESULT CreateStaticInstance ();

	HRESULT CreateWebApp ();
	HRESULT DeleteWebApp ();
	HRESULT PutInstanceWebApp (IWbemClassObject *pInst);

	HRESULT CreateAssociation ();

	bool IsAssociation () const;
	bool HasDBQualifier () const;

private:
	HRESULT CreateSingleInstance (const CConfigRecord& i_record,
								  IWbemClassObject **ppNewInst);
	HRESULT GetSingleRecord (ULONG *o_pcRow, bool i_fWriteAccess);
	HRESULT CreateConfigurationFile ();
	HRESULT PopulateConfigRecord (IWbemClassObject * i_pInst, CConfigRecord& record);

	// SPECIAL CASE FOR SINGLE CLASS
	HRESULT CreateCodeGroupInstance (const CConfigRecord& record, IWbemClassObject **o_ppNewInst);
	HRESULT PopulateCodeGroupRecord (IWbemClassObject * i_pInst, CConfigRecord& record);

	CInstanceHelper (const CInstanceHelper& );
	CInstanceHelper& operator= (const CInstanceHelper& );

	CObjectPathParser				m_objPathParser;		// object path parser
	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemObjectSink>		m_spResponseHandler;    // response handler for async notification
	CComPtr<IWbemClassObject>		m_spClassObject;        // class we're dealing with
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;			// Catalog dispenser
	CConfigQuery					m_cfgQuery;				// query for the class
	long							m_lFlags;				// objectpath flags
	bool							m_fIsAssociation;		// are we association class?
	bool							m_fInitialized;			// are we initialized?
	bool							m_fHasDBQualifier;		// does the class has a DB Qualifer
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\instanceprovider.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    InstanceProvider.cpp

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#pragma warning(disable: 4100)  //unreferenced formal parameter

#include "InstanceProvider.h"
#include <comutil.h>
#include "wmiobjectpathparser.h"
#include "cfgquery.h"
#include "cfgrecord.h"
#include "wqlparser.h"
#include "instancehelper.h"
#include "queryhelper.h"
#include "methodhelper.h"
#include "localconstants.h"
#include "resource.h"
#include "webapphelper.h"
#include "impersonate.h"

//Define the static prop.
LONG CInstanceProvider :: m_ObjCount = 0 ;

static WCHAR g_wszProductID[]	= L"NetFrameworkv1";
static WCHAR g_wszCatalogDll[]	= L"netfxcfg.dll";
extern HINSTANCE   g_hInst;

//***************************************************************************
//
// Constructor
//
//*************************************************************************** 
CInstanceProvider::CInstanceProvider()
{
	m_RefCount = 0;
	InterlockedIncrement(&m_ObjCount);
}


//***************************************************************************
//
// Destructor
//
//*************************************************************************** 
CInstanceProvider::~CInstanceProvider()
{
	InterlockedDecrement(&m_ObjCount);
}


//***************************************************************************
//
// IUnknown methods 
//
//*************************************************************************** 
STDMETHODIMP_( ULONG ) CInstanceProvider::AddRef()
{

	ULONG nNewCount = InterlockedIncrement ( &m_RefCount ) ;
	return nNewCount;
}


//***************************************************************************
//
// 
//
//*************************************************************************** 
STDMETHODIMP_(ULONG) CInstanceProvider::Release()
{

	
	ULONG nNewCount = InterlockedDecrement((long *)&m_RefCount);
    if (0L == nNewCount)
	{
        delete this;
		// unload the dispenser DLL (catalog.dll), because we have only a single
		// provider. In case we have multiple providers in this DLL we have to
		// mode the UnloadDispenserDll function to somewhere else to avoid crashes
		// Also, the UnloadDispenserDLL need to be called after delete this (and not 
		// in the destructor, because the smartpointer for the Dispenser is deleted
		// after the code in the desctructor is executed. If UnloadDispenserDll would
		// be in the destructor, it would unload the DLL before called Release on the
		// dispenser, causing the dll to blow up.
		UnloadDispenserDll (g_wszProductID);
	}
	
	return nNewCount;
}

//***************************************************************************
//
// 
//
//*************************************************************************** 
STDMETHODIMP CInstanceProvider::QueryInterface(REFIID riid, PVOID* ppv)
{

		*ppv = NULL;

		if (IID_IUnknown == riid)
		{
			*ppv=(IWbemServices*)this;
		}
		else if (IID_IWbemProviderInit == riid)
		{
			*ppv= (IWbemProviderInit*)this;
		}
		else if (IID_IWbemServices == riid)
		{
			*ppv= (IWbemServices*)this;
		}
		else
		{
			return E_NOINTERFACE;
		}

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();	
		return NOERROR;
}
//***************************************************************************
//
// CInstanceProvider::Initialize [IInstanceProviderInit]
//
// Purpose: Performs the provider's initialization
//
//***************************************************************************  
STDMETHODIMP CInstanceProvider::Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pNamespace,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink   // For init signals
				)
{
	ASSERT (pNamespace != 0);
	ASSERT (pInitSink != 0);
	ASSERT (pCtx != 0);

	TRACE (L"Initializing Provider");

	CImpersonator impersonator;
	HRESULT hr = impersonator.ImpersonateClient ();
	if (SUCCEEDED (hr))
	{
		m_spNamespace = pNamespace;

		// namespace is of form root/<namespacename>. We need to get rid of the root part
		// to query for the correct dispenser
		LPCWSTR pszNSStart = wcsrchr (pszNamespace, L'\\');
		if (pszNSStart != 0)
		{
			pszNSStart++;
		}
		else
		{
			pszNSStart = pszNamespace;
		}

		hr = GetSimpleTableDispenser ((LPWSTR)pszNSStart, 0, &m_spDispenser);
	}

	//attempt failed ... or succeeded ?!
	if (FAILED (hr))
	{
		TRACE (L"Initialization of NET Provider failed !!! hr=0x%08x", hr);
		hr=WBEM_E_FAILED;
		//Let CIMOM know we have failed
		pInitSink->SetStatus(WBEM_E_FAILED,0);
	}
	else
	{
		//Let CIMOM know we are initialized
		pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
	}

    return hr;
}

HRESULT STDMETHODCALLTYPE CInstanceProvider::GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	HRESULT hr = S_OK;

	TRACE(L"WMI::GetObjectAsync, objpath=%s", ObjectPath);
	
	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to Impersonate");
		return hr;
	}

	try
	{
		hr = InternalGetObjectAsync(ObjectPath, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		TRACE (L"Exception thrown in GetObjectAsync: %s", err.Description ());
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	
	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
// CInstanceProvider::CreateInstanceEnumAsync [IWbemServices]
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************        
HRESULT STDMETHODCALLTYPE CInstanceProvider::CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
		HRESULT hr = S_OK;

	TRACE(L"WMI::CreateInstanceEnumAsync, class=%s", Class);
	
	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to Impersonate");
		return hr;
	}

	try
	{
		hr = InternalCreateInstanceEnumAsync(Class, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		TRACE (L"Exception thrown in GetObjectAsync: %s", err.Description ());
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	
	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}

void CInstanceProvider::SetStatus(
		/* [in] */HRESULT hAny,
		/* [in] */IWbemContext *pCtx,
        /* [in] */IWbemObjectSink *pResponseHandler )
{
	ASSERT (pCtx != 0);
	ASSERT (pResponseHandler != 0);

	HRESULT hr;
	CComPtr<IWbemClassObject> spClassObj;
	CComPtr<IWbemClassObject> spInst;
	_variant_t varValue;

	if (SUCCEEDED (hAny))
	{
		// ignore errors, because we cannot do anything anyway
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, S_OK, 0, 0);
	}
	else if (hAny >= 0x80041001 && hAny <= 0x80041089)
	{
		// WMI specific error
		pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, hAny, 0, 0);
	}
	else
	{
		TRACE (L"Setting status: Function failed. hr=0x%08x", hAny);
		// set extended status
		hr = m_spNamespace->GetObject(L"__ExtendedStatus", 0 ,pCtx, &spClassObj, NULL);

		if (SUCCEEDED(hr))
		{
			hr = spClassObj->SpawnInstance(0,&spInst);

			if (SUCCEEDED(hr))
			{
				varValue = GetDescrForHr (hAny);
				hr = spInst->Put(L"Description", 0, &varValue, 0);

				varValue = hAny;
				hr = spInst->Put(L"StatusCode", 0, &varValue, 0);

				varValue = NET_PROVIDER_LONGNAME;
				spInst->Put(L"ProviderName", 0, &varValue, 0);
				
				hr = pResponseHandler->SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_FAILED, 0, spInst);
			}
		}
	}
}

_variant_t
CInstanceProvider::GetDescrForHr (HRESULT hrLast) const
{
	_variant_t varResult = L"";

	ASSERT (g_hInst != 0);

	CComPtr<IErrorInfo> spErrorInfo;

	HRESULT hr = GetErrorInfo (0, &spErrorInfo);
	if (hr == S_OK) // GetErrorInfo returns S_FALSE when there is no error object to return
	{
		CComPtr<ISimpleTableRead2> spRead;
		hr = spErrorInfo->QueryInterface (IID_ISimpleTableRead2, (void **) &spRead);
		if (SUCCEEDED (hr))
		{
			_bstr_t bstrDescrMultiLine;
			for (ULONG iRow=0;;++iRow)
			{
				tDETAILEDERRORSRow ErrorInfo;
				hr = spRead->GetColumnValues (iRow, cASSOC_META_NumberOfColumns, 0, 0, (void **)&ErrorInfo);
				if (hr == E_ST_NOMOREROWS)
				{
					hr = S_OK;
					break;
				}
				if (FAILED (hr))
				{
					wprintf (L"GetColumnValues failed\n");
					break;
				}

				bstrDescrMultiLine += ErrorInfo.pDescription;
			}
			varResult = bstrDescrMultiLine;
		}
		else
		{
			CComBSTR bstrDescription;
			hr = spErrorInfo->GetDescription (&bstrDescription);
			if (SUCCEEDED (hr))
			{
				varResult = bstrDescription;
			}
		}
	}

	// if we don't have a description yet, and we have a catalog error, try to get the error
	// string from the catalog
	if (varResult.bstrVal[0] == L'\0' && HRESULT_FACILITY (hrLast) == FACILITY_CONFIGURATION)
	{	
		// the name of the dll is hardcoded. The catalog doesn't expose a way to get the module handle
		// automatically. For the .NET Provider, we know that the name of the dll is netfxcfg.dll, so we
		// simply thry that.
		HMODULE hModule = GetModuleHandle (g_wszCatalogDll);
		if (hModule != 0)
		{
			// messageID is the save as HRESULT_CODE bits from hr. We need to add 0xc0000000 to it to match
			// the actual messageID from the catalog
			DWORD dwMessageID = 0xC0000000 | HRESULT_CODE(hrLast);
			WCHAR wszBuf[1024];

			// every message takes 5 parameters, so fill these out with dummy values
			LPWSTR dummyVal[5];
			for (ULONG idx=0; idx<5; ++idx)
			{
				dummyVal[idx] = L"";
			}

			ULONG ret = FormatMessage (FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
									   hModule,
									   dwMessageID,
									   0,
									   wszBuf,
									   sizeof(wszBuf),
									   (va_list *)dummyVal);
			if (ret != 0)
			{
				// we found a string. Lets use it.
				varResult = wszBuf;
			}
		}
	}

	if (varResult.bstrVal[0] == L'\0')
	{
		WCHAR wszBuffer[512];
		wszBuffer[0] = L'\0';
		int iResult = LoadString(g_hInst, IDS_UNKNOWN_ERROR, wszBuffer, sizeof(wszBuffer)/sizeof(WCHAR));
		if (iResult == 0)
		{
			TRACE (L"String with ID %d does not exist in resource file", IDS_UNKNOWN_ERROR);
		}
		else
		{
			varResult = wszBuffer;
		}
	}

	return varResult;
}


//***************************************************************************
//
// CInstanceProvider::PutInstanceAsync  [IWbemServices]
//
// 
//
//*************************************************************************** 
HRESULT STDMETHODCALLTYPE CInstanceProvider::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	TRACE(L"WMI::PutInstanceAsync");
	
	HRESULT hr = S_OK;

	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to Impersonate");
		return hr;
	}

	try
	{
		hr = InternalPutInstanceAsync (pInst, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		TRACE (L"Exception thrown in PutInstanceAsync: %s", err.Description ());
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	
	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
// CInstanceProvider::DeleteInstanceAsync  [IWbemServices]
//
// 
//
//*************************************************************************** 
HRESULT STDMETHODCALLTYPE CInstanceProvider::DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	TRACE(L"WMI::DeleteInstanceAsync, objpath=%s", ObjectPath);

	HRESULT hr = S_OK;

	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to Impersonate");
		return hr;
	}

	try
	{
		hr = InternalDeleteInstanceAsync(ObjectPath, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		TRACE (L"Exception thrown in DeleteInstanceAsync: %s", err.Description ());
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );

	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}


/***************************************************************************
// CInstanceProvider::DeleteInstanceAsync  [IWbemServices]
//***************************************************************************/
HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecQueryAsync( 
            /* [in] */ const BSTR bstrQueryLanguage,
            /* [in] */ const BSTR bstrQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	TRACE(L"WMI::ExecQueryAsync, query=%s", bstrQuery);
	HRESULT hr = S_OK;
	
	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to Impersonate");
		return hr;
	}

	try
	{
		hr = InternalExecQueryAsync(bstrQueryLanguage, bstrQuery, lFlags, pCtx, pResponseHandler);
	}
	catch (_com_error& err)
	{
		TRACE (L"Exception thrown in ExecQueryAsync: %s", err.Description ());
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	
	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
}

HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	HRESULT hr = S_OK;
	
	CImpersonator impersonator;
	hr = impersonator.ImpersonateClient ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to Impersonate");
		return hr;
	}

	try
	{
		hr = InternalExecMethodAsync(ObjectPath, MethodName, lFlags, pCtx, pInParams,  pResponseHandler);
	}
	catch (_com_error& err)
	{
		TRACE (L"Exception thrown in ExecMethodAsync: %s", err.Description ());
		hr = WBEM_E_FAILED;
	}

	//Respond & return
	SetStatus( hr, pCtx, pResponseHandler );
	

	// SetStatus will set extended error information, so we don't have to do that
	// here
	return WBEM_S_NO_ERROR;
} 

HRESULT 
CInstanceProvider::InternalGetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler)
{
	ASSERT (ObjectPath != 0);
	ASSERT (pCtx != 0);
	ASSERT (pResponseHandler != 0);

	CInstanceHelper instHelper;

	HRESULT hr = instHelper.Init (ObjectPath,
		                          lFlags,
								  pCtx, 
								  pResponseHandler,
								  m_spNamespace,
								  m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of instance helper failed");
		return hr;
	}

	if (instHelper.IsAssociation ())
	{
		hr = instHelper.CreateAssociation ();
	}
	else if (instHelper.HasDBQualifier ())
	{
		CComPtr<IWbemClassObject> spNewInstance;
		hr = instHelper.CreateInstance (&spNewInstance);
		if (FAILED (hr))
		{
			TRACE (L"Instance creation failed");
			return hr;
		}

		// tell WMI that the new instance is created. We have to do this outside the
		// createinstance function, because createInstance is used by batch Retrieve
		// as well, and the first thing that you return via indicate will be the
		// result value.

		IWbemClassObject* pNewInstRaw = spNewInstance;
		hr = pResponseHandler->Indicate(1,&pNewInstRaw);
		if (FAILED (hr))
		{
			TRACE (L"WMI Indicate failed");
			return hr;
		}
	}
	else
	{
		hr = instHelper.CreateStaticInstance ();
		if (FAILED (hr))
		{
			return hr;
		}
	}
		
	hr = pResponseHandler->SetStatus (WBEM_STATUS_COMPLETE, S_OK, 0, 0);

	return WBEM_S_NO_ERROR;
}

HRESULT 
CInstanceProvider::InternalExecQueryAsync( 
            /* [in] */ const BSTR bstrQueryLanguage,
            /* [in] */ const BSTR bstrQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
{
	CQueryHelper queryHelper;
	HRESULT hr = queryHelper.Init (bstrQuery, 
								   lFlags, 
								   pCtx, 
								   pResponseHandler, 
								   m_spNamespace, 
								   m_spDispenser);

	if (FAILED (hr))
	{
		return hr;
	}



	if (queryHelper.IsAssociation ())
	{
		hr = queryHelper.CreateAssociations ();
	}
	else if (queryHelper.HasDBQualifier ())
	{
		hr = queryHelper.CreateInstances ();
	}
	else
	{
		hr = queryHelper.CreateAppInstances ();
	}

	if (FAILED (hr))
	{
		TRACE (L"InternalExecQueryAsync failed");
		return hr;
	}
	
	hr = pResponseHandler->SetStatus (WBEM_STATUS_COMPLETE, S_OK, 0, 0);
	
	return hr;
}

HRESULT 
CInstanceProvider::InternalPutInstanceAsync( 
        /* [in] */ IWbemClassObject  *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext* pCtx,
        /* [in] */ IWbemObjectSink* pResponseHandler) 
{
	ASSERT (pInst != 0);
	ASSERT (pCtx != 0);
	ASSERT (pResponseHandler != 0);

	_variant_t varClassName;
	HRESULT hr = pInst->Get(L"__class", 0, &varClassName, 0 , 0);
	if (FAILED (hr))
	{
		return hr;
	}

	TRACE (L"PutInstance for class %s", LPWSTR (varClassName.bstrVal));

	CInstanceHelper instHelper;

	hr = instHelper.Init (_bstr_t (varClassName), lFlags, pCtx, pResponseHandler, m_spNamespace, m_spDispenser);
	if (FAILED (hr))
	{
		return hr;
	}

	if (instHelper.IsAssociation ())
	{
		return WBEM_E_INVALID_OPERATION;
	}
	else if (instHelper.HasDBQualifier ())
	{
		hr = instHelper.PutInstance  (pInst);
	}
	else
	{
		hr = instHelper.PutInstanceWebApp (pInst);
	}

	if (FAILED (hr))
	{
		TRACE (L"PutInstance Failed");
		return hr;
	}

	hr = pResponseHandler->SetStatus (WBEM_STATUS_COMPLETE, S_OK, 0, 0);

	return hr;
}

HRESULT 
CInstanceProvider::InternalDeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler)
{
	CInstanceHelper instHelper;

	HRESULT hr = instHelper.Init (ObjectPath,
		                          lFlags,
								  pCtx, 
								  pResponseHandler,
								  m_spNamespace,
								  m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Initialization failed");
		return hr;
	}

	if (instHelper.IsAssociation ())
	{
		return WBEM_E_INVALID_OPERATION;
	}
	else if (instHelper.HasDBQualifier ())
	{
		hr = instHelper.DeleteInstance  ();
	}
	else
	{
		hr = instHelper.DeleteWebApp ();
	}
	
	if (FAILED (hr))
	{
		return hr;
	}

	hr = pResponseHandler->SetStatus (WBEM_STATUS_COMPLETE, S_OK, 0, 0);

	return hr;
}

//=================================================================================
// Function: CInstanceProvider::InternalExecMethodAsync
//
// Synopsis: Executes a method asynchronously. Uses the method helper to do 
//           all the work
//
// Arguments: [ObjectPath] - object path of class on which to invoke method
//            [MethodName] - method to invoke
//            [lFlags] - flags
//            [pCtx] - context to call back into WMI
//            [pInParams] - in parameters
//            [pResponseHandler] - callback interface into WMI for status
//=================================================================================
HRESULT 
CInstanceProvider::InternalExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	CMethodHelper methodHelper;
	HRESULT hr = methodHelper.Init (ObjectPath,
									MethodName,
									lFlags,
									pCtx,
									pInParams,
									pResponseHandler,
									m_spNamespace,
									m_spDispenser);
	
	if (FAILED (hr))
	{
		TRACE (L"Initialization of method helper failed");
		return hr;
	}

	hr = methodHelper.ExecMethod ();

	if (FAILED (hr))
	{
		TRACE (L"Method Execution failed");
		return hr;
	}

	return hr;
}

HRESULT STDMETHODCALLTYPE 
CInstanceProvider::InternalCreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	HRESULT hr = S_OK;
	if (_wcsicmp (Class, L"WebApplication") == 0)
	{
		CWebAppHelper webAppHelper;
		hr = webAppHelper.Init (Class, lFlags, pCtx, pResponseHandler, m_spNamespace);
		if (FAILED (hr))
		{
			TRACE (L"Unable to initialize webapphelper");
			return hr;
		}

		hr = webAppHelper.EnumInstances ();
		if (FAILED (hr))
		{
			TRACE (L"Unable to enumerate instances of webapplication");
			return hr;
		}
	}
	else
	{
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	return hr;
}
//***************************************************************************
//
// The following methods [IWbemServices] are not supported !
//
//*************************************************************************** 

HRESULT STDMETHODCALLTYPE CInstanceProvider::OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink)
{

	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler)
{

	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{

	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

        
HRESULT STDMETHODCALLTYPE CInstanceProvider::PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT STDMETHODCALLTYPE CInstanceProvider::CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

        
HRESULT STDMETHODCALLTYPE CInstanceProvider::PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

        
HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{

	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT STDMETHODCALLTYPE CInstanceProvider::ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\instanceprovider.h ===
//***************************************************************************
//
//  InstanceProvider.h
//
//  Module: Unmanaged WMI Provider for COM+
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _COMPLUS_InstanceProvider_H
#define _COMPLUS_InstanceProvider_H

#include <atlbase.h>
#include <comutil.h>
#include "catmacros.h"
#include "catalog.h"
#include <wbemidl.h>

//***************************************************************************
//
//This clas represents the Instance Provider implemented in this DLL 
//
//***************************************************************************
class CInstanceProvider : public IWbemServices, public IWbemProviderInit
{
public:
	static	LONG m_ObjCount;

private:
	CComPtr<IWbemServices>			m_spNamespace;
	CComPtr<ISimpleTableDispenser2> m_spDispenser;
	LONG m_RefCount;

public:

	CInstanceProvider();
	~CInstanceProvider(); 

	//interface methods
	//==================

	/* IUnknown methods */

    STDMETHODIMP         QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	/* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR bstrQueryLanguage,
            /* [in] */ const BSTR bstrQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

    HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

	STDMETHODIMP Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pNamespace,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink   // For init signals
			);

private:
    HRESULT InternalGetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pCtx,
            /* [in] */ IWbemObjectSink* pResponseHandler) ;

	HRESULT InternalExecQueryAsync( 
            /* [in] */ const BSTR bstrQueryLanguage,
            /* [in] */ const BSTR bstrQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemObjectSink *pResponseHandler) ;
   
	HRESULT InternalDeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler) ;
    
	HRESULT InternalPutInstanceAsync( 
            /* [in] */ IWbemClassObject  *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext  *pCtx,
            /* [in] */ IWbemObjectSink  *pResponseHandler) ;

	HRESULT InternalExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

	HRESULT STDMETHODCALLTYPE InternalCreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

	void SetStatus(
			/* [in] */ HRESULT hrReturn,
			/* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler );

	_variant_t GetDescrForHr (HRESULT hr) const;
};

#endif //_COMPLUS_InstanceProvider_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\localconstants.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    LocalConstants.h

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __LOCALCONSTANTS_H__
#define __LOCALCONSTANTS_H__

#include "catmacros.h"

#pragma once

//
#define FACTORYTYPE_CLASS		1
#define FACTORYTYPE_INSTANCE	2

#define NET_PROVIDER_LONGNAME	 L"Microsoft .NET Framework WMI Provider"
#define NET_PROVIDER			 L"WMI.NetFrameworkv1.PROVIDER"
#define NET_PROVIDER_CVER		 L"WMI.NetFrameworkv1.PROVIDER\\CurVer"
#define NET_PROVIDER_CLSID		 L"WMI.NetFrameworkv1.PROVIDER\\CLSID"
#define NET_PROVIDER_VER_CLSID	 L"WMI.NetFrameworkv1.PROVIDER.0\\CLSID"
#define NET_PROVIDER_VER		 L"WMI.NetFrameworkv1.PROVIDER.0"

#define WSZSELECTOR				 L"selector"
#define WSZINTERNALNAME			 L"InternalName"
#define WSZDATABASE				 L"Database"

#define WSZCODEGROUP			 L"CodeGroup"
#define WSZIMEMBERSHIPCONDITION  L"IMembershipCondition"

#define WSZFILESELECTOR			 L"file://"
#define WSZLOCATION				 L"location"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\methodhelper.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    methodhelper.h

$Header: $

Abstract:

Author:
    marcelv 	11/20/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __METHODHELPER_H__
#define __METHODHELPER_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "wmiobjectpathparser.h"
#include "cfgquery.h"
#include "cfgrecord.h"

class CMethodHelper
{
public:
	CMethodHelper ();
	~CMethodHelper ();

	HRESULT Init (const BSTR				i_ObjectPath,
				  const BSTR				i_MethodName,
		          long						i_lFlags,
                  IWbemContext *			i_pCtx,
				  IWbemClassObject *		i_pInParams,
                  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace,
				  ISimpleTableDispenser2 *	i_pDispenser);

	HRESULT ExecMethod ();

private:
	HRESULT BatchCreate ();
	HRESULT BatchUpdate ();
	HRESULT BatchDelete ();
	HRESULT ProcessBatch ();

	CMethodHelper (const CMethodHelper& );
	CMethodHelper& operator=(const CMethodHelper& );

	typedef HRESULT (CMethodHelper::*PMethodFunc) ();

	struct BatchMethodFunc
	{
		LPCWSTR wszMethodName;			// method name
		PMethodFunc pFunc;				// method function to execute
	};
	
	static const BatchMethodFunc m_aBatchMethods[]; // array with name/func's

	CObjectPathParser				m_objPathParser;		// object path parser
	_bstr_t							m_bstrMethodName;		// method name
	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemObjectSink>		m_spResponseHandler;    // response handler for async notification
	CComPtr<IWbemClassObject>		m_spClassObject;        // class we're dealing with
	CComPtr<IWbemClassObject>		m_spInParams;			// in parameters
	CComPtr<IWbemClassObject>		m_spOutParams;			// out parameters
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;			// Catalog dispenser
	long							m_lFlags;				// objectpath flags
	bool							m_fInitialized;			// are we initialized?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\resource.h ===
//***************************************************************************
//
//  resource.h
//
//  Module: Unmanaged WMI Provider for COM+
//
//  Purpose: 
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//#ifndef _COMPLUS_resource_H
//#define _COMPLUS_resource_H


#define IDS_STRING1					101
#define IDS_STRING2					102

//wbem
#define IDS_OPERATION_CANCELED      103
#define IDS_GETOBJECT_FAILED		104
#define IDS_GETQUALIFIERSET_FAILED  105
#define IDS_OBJECT_NOT_FOUND        106
#define IDS_SPAWNINSTANCE_FAILED    107
#define IDS_BEGINENUMERATION_FAILED 108
#define IDS_BADQUERY				109

//catalog
#define IDS_RELATION_NOT_FOUND		201
#define IDS_GETTABLEMETA_FAILED		202
#define IDS_GETTABLE_FAILED			203
#define IDS_CATALOG_THROWS_HRES		204 
#define IDS_CATALOG_THROWS			205 
#define IDS_UNABLE_TO_PROCEED		206 
#define IDS_TABLE_NOT_FOUND		    207 
#define IDS_NONCONSISTENT_RECORD    208
#define IDS_RECORD_NOT_FOUND        209
#define IDS_FORMATS_DONT_MATCH      210
#define IDS_UNKNOWN_BASIC_TYPE		211
#define IDS_TYPE_MISMATCH			212
#define IDS_ADDROWFORDELETE_FAILED  213
#define IDS_DISPENSER_NOT_SET       214
#define IDS_GETCOLUMNVALUES_FAILED  215


//common
#define IDS_OUT_OF_MEMORY			301
#define IDS_CATALOG_DETAILED_ERRORS 302
#define IDS_UNKNOWN_ERROR           303

//#endif //_COMPLUS_resource_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\netframeworkprov.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    netframeworkprov.h

$Header: $

Abstract:

Author:
    marcelv 	10/31/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __NETFRAMEWORKPROV_H__
#define __NETFRAMEWORKPROV_H__

#pragma once

#include "catmacros.h"

// {4F14DD83-C443-4c0c-9784-AA903BBF9FA6}
DEFINE_GUID(CLSID_CNetProviderFactory, 
0x4f14dd83, 0xc443, 0x4c0c, 0x97, 0x84, 0xaa, 0x90, 0x3b, 0xbf, 0x9f, 0xa6);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
//
//  Module: Unmanaged WMI Provider for COM+
//
//  Purpose: Contains the gloabal DLL functions
//
//  Copyright (c)2000 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "catmacros.h"
#include <initguid.h>
#include "netframeworkprov.h"
#include "classfactory.h"
#include "atlimpl.cpp"
#include "localconstants.h"
#include "instanceprovider.h"

// Debugging
DECLARE_DEBUG_PRINTS_OBJECT();

BOOL SetKeyAndValue( 
		/*[in]*/ const wchar_t* pszKey, 
		/*[in]*/ const wchar_t* pszSubkey, 
		/*[in]*/ const wchar_t* pszValueName, 
		/*[in]*/ const wchar_t* pszValue );

//Exports ( with "maindll.def" ) 
STDAPI DllGetClassObject ( REFCLSID rclsid , REFIID riid, void **ppv );
STDAPI DllCanUnloadNow (void);
STDAPI DllRegisterServer(void);
STDAPI DllUnregisterServer(void);

//Also Implements
BOOL APIENTRY DllMain ( HINSTANCE hInstance, ULONG ulReason , LPVOID pvReserved );

//We need this global
HINSTANCE   g_hInst = NULL;
HMODULE		g_hModule = NULL;

//Strings used during self registeration
static LPCWSTR HKEYCLASSES_STR		  =	L"SOFTWARE\\Classes\\";
static LPCWSTR REG_FORMAT2_STR        =	L"%s%s";
static LPCWSTR REG_FORMAT3_STR        =   L"%s%s\\%s";
static LPCWSTR VER_IND_STR            =   L"VersionIndependentProgID";
static LPCWSTR NOT_INTERT_STR         =   L"NotInsertable";
static LPCWSTR INPROC32_STR           =   L"InprocServer32";
static LPCWSTR PROGID_STR             =   L"ProgID";
static LPCWSTR THREADING_MODULE_STR   =   L"ThreadingModel";
static LPCWSTR APARTMENT_STR          =   L"Both";
static LPCWSTR CLSID_STR              =   L"CLSID\\";

//***************************************************************************
//
// DllMain
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (	HINSTANCE hInstance, ULONG ulReason , LPVOID /*pvReserved */)
{
	switch(ulReason) {

	case DLL_PROCESS_ATTACH:
		g_hInst=hInstance;
		DisableThreadLibraryCalls(hInstance);
		CREATE_DEBUG_PRINT_OBJECT("NetProvider", CLSID_CNetProviderFactory);
		break;
	
	case DLL_PROCESS_DETACH:
		DELETE_DEBUG_PRINT_OBJECT();
		break;
	}
	
	return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by COM when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//  The two COM classes implemented here are ClassProvider and InstanceProvider
//  They require exactly the same type of class factory. Therefore I am using
//  a single class which implements IClassFactory interface ...
//
//***************************************************************************

STDAPI DllGetClassObject ( REFCLSID rclsid, REFIID riid, void **ppv )
{
	HRESULT hRes=S_OK;
    CClassFactory *pObj=NULL;

	*ppv = 0;

	if ( rclsid == CLSID_CNetProviderFactory )
	{
		pObj=new CClassFactory( 2 );
		if (pObj == 0)
		{
			return E_OUTOFMEMORY;
		}
	}
	else
	{
	   return CLASS_E_CLASSNOTAVAILABLE;
	}

    hRes=pObj->QueryInterface(riid, ppv);

    if ( FAILED(hRes) )
        delete pObj;

    return hRes;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by COM in order to determine if the
//          DLL can be freed.
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow (void)
{	
	if (CInstanceProvider::m_ObjCount != 0 || CClassFactory::m_LockCount != 0 )
	{
		return S_FALSE;
	}

	return S_OK;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         S_OK if registration successful, error
 *                  otherwise.
 ***************************************************************************/
STDAPI DllRegisterServer(void)
{

	TCHAR szModule[MAX_PATH + 1];
	GetModuleFileName(g_hInst,(LPTSTR) szModule, MAX_PATH + 1);
	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	//register the instance provider 
	StringFromGUID2(CLSID_CNetProviderFactory,szProviderClassID, 128);
	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);
	//
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, NET_PROVIDER_LONGNAME))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, PROGID_STR, NULL, NET_PROVIDER_VER))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, VER_IND_STR, NULL, NET_PROVIDER))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INTERT_STR, NULL, NULL))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL, (wchar_t*) _bstr_t(szModule) ))
		return SELFREG_E_CLASS;
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK ;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         S_OK if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI DllUnregisterServer(void)
{
	wchar_t szTemp[512];
	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	//unregister the instance provider 
	StringFromGUID2(CLSID_CNetProviderFactory,szProviderClassID, 128);
	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);
	//
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, NET_PROVIDER_CVER);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, NET_PROVIDER_CLSID);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, NET_PROVIDER);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	//
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, NET_PROVIDER_VER_CLSID);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, NET_PROVIDER_VER);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	//
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT3_STR, HKEYCLASSES_STR, szProviderCLSIDClassID, PROGID_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT3_STR, HKEYCLASSES_STR, szProviderCLSIDClassID, VER_IND_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT3_STR, HKEYCLASSES_STR, szProviderCLSIDClassID, NOT_INTERT_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT3_STR, HKEYCLASSES_STR, szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);
	wsprintf((LPTSTR)szTemp, (LPCTSTR)REG_FORMAT2_STR, HKEYCLASSES_STR, szProviderCLSIDClassID);
	RegDeleteKey(HKEY_LOCAL_MACHINE, (LPCTSTR)szTemp);

	return S_OK ;
 }

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          the name of the key
 *  pszSubkey       the name of a subkey
 *  pszValueName	the name of the  value
 *  pszValue        the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 *
 * Remark
 *  Unicode specific ...
 *
 ***************************************************************************/

BOOL SetKeyAndValue( 
		/*[in]*/ const wchar_t* pszKey, 
		/*[in]*/ const wchar_t* pszSubkey, 
		/*[in]*/ const wchar_t* pszValueName, 
		/*[in]*/ const wchar_t* pszValue )
{

    HKEY        hKey;
    wchar_t     szKey[256];
	BOOL		bResult = TRUE;

	wcscpy(szKey, HKEYCLASSES_STR);
    wcscat(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS != RegCreateKeyEx( HKEY_LOCAL_MACHINE, 
										 (LPCTSTR) _bstr_t(szKey), 
										 0, NULL, REG_OPTION_NON_VOLATILE, 
										 KEY_ALL_ACCESS, NULL, 
										 &hKey, 
										 NULL) )
	{
        bResult = FALSE;
	}
	else
	{
		if (NULL != pszValue)
		{
			DWORD cbData;

			cbData = ( 1+ _bstr_t(pszValue).length() ) * sizeof(TCHAR);

			if ( ERROR_SUCCESS != RegSetValueEx( hKey, 
												 (LPCTSTR) _bstr_t( pszValueName ), 
												 0, 
												 REG_SZ, 
												 (BYTE *) (LPCTSTR) _bstr_t(pszValue),
												 cbData) )
			bResult = FALSE;
		}

		RegCloseKey(hKey);
	}

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\stringutil.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    stringutil.h

$Header: $

Abstract:

Author:
    marcelv 	11/10/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __STRINGUTIL_H__
#define __STRINGUTIL_H__

#pragma once

#include "catmacros.h"

class CWMIStringUtil
{
public:
	static LPWSTR Trim (LPWSTR i_wsz, WCHAR i_wcTrim);
	static LPWSTR LTrim (LPWSTR i_wsz, WCHAR i_wcTrim);
	static LPWSTR RTrim (LPWSTR i_wsz, WCHAR i_wcTrim);
	static LPWSTR StrToLower (LPCWSTR io_wszStr);
	static LPWSTR FindChar (LPWSTR i_wszString, LPCWSTR i_aChars);
	static LPWSTR FindStr (LPWSTR i_wszStr, LPCWSTR i_wszSubStr);
	static LPWSTR StrToObjectPath (LPCWSTR wszString);
	static LPWSTR AddBackSlashes (LPCWSTR i_wszStr);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\methodhelper.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    methodhelper.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/20/2000		Initial Release

Revision History:

--**************************************************************************/

#include "methodhelper.h"
#include "instancehelper.h"
#include "smartpointer.h"
#include "batchupdate.h"
#include "batchdelete.h"
#include "procbatchhelper.h"

// helper array to do easy lookup of method names. By finding the name, we
// can easily execute the method defined for that name
const CMethodHelper::BatchMethodFunc CMethodHelper::m_aBatchMethods[] = 
{
	{L"BatchCreate",	CMethodHelper::BatchCreate},
	{L"BatchUpdate",	CMethodHelper::BatchUpdate},
	{L"BatchDelete",	CMethodHelper::BatchDelete},
	{L"ProcessBatch",	CMethodHelper::ProcessBatch}
};

#define callMemberFunction(object, ptrToMember) ((object).*(ptrToMember))

//=================================================================================
// Function: CMethodHelper::CMethodHelper
//
// Synopsis: Default constructor
//=================================================================================
CMethodHelper::CMethodHelper ()
{
	m_fInitialized = false;
}

//=================================================================================
// Function: CMethodHelper::~CMethodHelper
//
// Synopsis: Destructor
//=================================================================================
CMethodHelper::~CMethodHelper ()
{
}

//=================================================================================
// Function: CMethodHelper::Init
//
// Synopsis: Initilizes the method helper. Parses the object path, creates the 
//           class instance, retrieves the output parameter information. This makes
//           it easier for the individual methods to deal with input and output
//           parameters. They only have to fill out the relavant information, and
//           don't have to worry about creating output parameters.
//
// Arguments: [i_ObjectPath] - Object path of class that implements the method
//            [i_MethodName] - name of the method to execute
//            [i_lFlags] - flags
//            [i_pCtx] - context for calling back into WMI
//            [i_pInParams] - In parameters
//            [i_pResponseHandler] - response callback interface to give info back to WMI
//            [i_pNamespace] - namespace
//            [i_pDispenser] - dispenser
//=================================================================================
HRESULT
CMethodHelper::Init (const BSTR					i_ObjectPath,
				     const BSTR					i_MethodName,
					 long						i_lFlags,
					 IWbemContext *				i_pCtx,
					 IWbemClassObject *			i_pInParams, /* can be 0 */
					 IWbemObjectSink *			i_pResponseHandler,
					 IWbemServices *			i_pNamespace,
					 ISimpleTableDispenser2 *	i_pDispenser)
{
	ASSERT (i_ObjectPath != 0);
	ASSERT (i_MethodName != 0);
	ASSERT (i_pCtx != 0);
	ASSERT (i_pResponseHandler != 0);
	ASSERT (i_pNamespace != 0);
	ASSERT (i_pDispenser != 0);
	ASSERT (!m_fInitialized);

	HRESULT hr = m_objPathParser.Parse (i_ObjectPath);
	if (FAILED (hr))
	{
		TRACE (L"Unable to parse objectpath: %s", i_ObjectPath);
		return hr;
	}

	m_bstrMethodName	= i_MethodName;
	m_spCtx				= i_pCtx;
	m_spInParams		= i_pInParams;
	m_spResponseHandler = i_pResponseHandler;
	m_spNamespace		= i_pNamespace;
	m_spDispenser		= i_pDispenser;
	m_lFlags			= i_lFlags;

	hr = m_spNamespace->GetObject ((LPWSTR) m_objPathParser.GetClass (), 0, m_spCtx, &m_spClassObject, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for %s", m_objPathParser.GetClass ());
		return hr;
	}

	CComPtr<IWbemClassObject> spOutClass;
	hr = m_spClassObject->GetMethod (m_bstrMethodName, 0, 0, &spOutClass);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get method information for %s", (LPWSTR) m_bstrMethodName);
		return hr;
	}

	// Create an instance of the output parameters. This will be returned to WMI
	// when the method is executed.
	hr = spOutClass->SpawnInstance (0, &m_spOutParams);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create output parameter instance for method %s", (LPWSTR) m_bstrMethodName);
		return hr;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CMethodHelper::ExecMethod
//
// Synopsis: Go through the array of methods and execute the correct method. After
//           the method is succesfully executed, we notify WMI of this.
//=================================================================================
HRESULT
CMethodHelper::ExecMethod ()
{
	ASSERT (m_fInitialized);

	for (ULONG idx=0; idx < sizeof (m_aBatchMethods)/sizeof(m_aBatchMethods[0]); ++idx)
	{
		if (_wcsicmp ((LPCWSTR) m_bstrMethodName, m_aBatchMethods[idx].wszMethodName) == 0)
		{
			HRESULT hr = callMemberFunction (*this, m_aBatchMethods[idx].pFunc) ();
			if (FAILED (hr))
			{
				TRACE (L"Error while calling member function %s", (LPWSTR) m_bstrMethodName);
				return hr;
			}

			// and indicate the result in case of success
			IWbemClassObject* pNewOutputRaw = m_spOutParams;
			hr = m_spResponseHandler->Indicate (1, &pNewOutputRaw);
			return hr;
		}
	}

	return WBEM_E_METHOD_NOT_IMPLEMENTED;
}

//=================================================================================
// Function: CMethodHelper::BatchCreate
//
// Synopsis: Creates a number of new instances by using batchUpdate
//=================================================================================
HRESULT
CMethodHelper::BatchCreate ()
{
	ASSERT (m_fInitialized);

	CBatchUpdate batchUpdate;
	HRESULT hr = batchUpdate.Initialize (m_spInParams, 
										 m_spOutParams,
										 m_spNamespace, 
										 m_spCtx, 
										 m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"BatchUpdate::Initialize failed");
		if (batchUpdate.HaveStatusError ())
		{
			// status array has status, so return S_OK in that case
			batchUpdate.SetStatus (); // always set the status
			hr = S_OK;
		}
		return hr;
	}

	hr = batchUpdate.UpdateAll (true);
	batchUpdate.SetStatus (); // always set the status
	if (FAILED (hr))
	{
		TRACE (L"UpdateAll in BatchCreate failed");
		if (batchUpdate.HaveStatusError ())
		{
			// status array has status, so return S_OK in that case
			hr = S_OK;
		}
	}

	return hr;
}

//=================================================================================
// Function: CMethodHelper::BatchUpdate
//
// Synopsis: Updates instances of a particular table.
//=================================================================================
HRESULT 
CMethodHelper::BatchUpdate ()
{
	ASSERT (m_fInitialized);

	CBatchUpdate batchUpdate;
	HRESULT hr = batchUpdate.Initialize (m_spInParams, 
										 m_spOutParams,
										 m_spNamespace, 
										 m_spCtx, 
										 m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"BatchUpdate::Initialize failed");
		if (batchUpdate.HaveStatusError ())
		{
			batchUpdate.SetStatus (); // always set the status
			// status array has status, so return S_OK in that case
			hr = S_OK;
		}
		return hr;
	}

	hr = batchUpdate.UpdateAll (false);
	batchUpdate.SetStatus (); // always set the status

	if (FAILED (hr))
	{
		TRACE (L"BatchUpdate failed.");
		if (batchUpdate.HaveStatusError ())
		{
			// status array has status, so return S_OK in that case
			hr = S_OK;
		}
	}

	return hr;
}

//=================================================================================
// Function: CMethodHelper::BatchDelete
//
// Synopsis: Batch deletes instances of a particular table. We only support batch
//           delete of instances in the same table
//=================================================================================
HRESULT
CMethodHelper::BatchDelete ()
{
	ASSERT (m_fInitialized);

	CBatchDelete batchDelete;
	HRESULT hr = batchDelete.Initialize (m_spInParams, 
										 m_spOutParams,
										 m_spNamespace, 
										 m_spCtx, 
										 m_spDispenser);
	
	if (FAILED (hr))
	{
		TRACE (L"Initialization of batchDelete object failed");
		if (batchDelete.HaveStatusError ())
		{
			batchDelete.SetStatus (); // always set the status, even in case of failure
			// status array has status, so return S_OK in that case
			hr = S_OK;
		}
		return hr;
	}

	hr = batchDelete.DeleteAll ();

	batchDelete.SetStatus (); // always set the status, even in case of failure
	if (FAILED (hr))
	{
		TRACE (L"Error during DeleteAll function");
		if (batchDelete.HaveStatusError ())
		{
			// status array has status, so return S_OK in that case
			hr = S_OK;
		}
	}

	return hr;
}

HRESULT 
CMethodHelper::ProcessBatch ()
{
	ASSERT (m_fInitialized);

	CProcessBatchHelper batchHelper;
	HRESULT hr = batchHelper.Initialize (m_spInParams, m_spOutParams, m_spNamespace,
		                                 m_spCtx, m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of processbatch Helper failed");
		if (batchHelper.HaveStatusError ())
		{
			hr = S_OK;
		}
		return hr;
	}

	hr = batchHelper.ProcessAll ();
	if (FAILED (hr))
	{
		TRACE (L"ProcessAll failed");
		if (batchHelper.HaveStatusError ())
		{
			hr = S_OK;
		}
		return hr;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\procbatchhelper.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    procbatchhelper.h

$Header: $

Abstract:

Author:
    marcelv 	12/14/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __PROCBATCHHELPER_H__
#define __PROCBATCHHELPER_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "catmacros.h"
#include "smartpointer.h"
#include "cfgquery.h"

struct CBatchEntry
{
	ULONG iOperator;
	CComPtr<IWbemClassObject> spInst;
	_bstr_t	bstrPath;
	HRESULT hrStatus;
	CComPtr<IWbemClassObject> pInstance;
};

class CProcessBatchHelper
{
public:
	CProcessBatchHelper();
	~CProcessBatchHelper ();

	HRESULT Initialize (IWbemClassObject * pInParams,
						IWbemClassObject * pOutParams,
						IWbemServices	* pNamespace, 
						IWbemContext	* pCtx,
						ISimpleTableDispenser2 * pDispenser);	

	HRESULT ProcessAll ();
	bool HaveStatusError () const;
private:
	CProcessBatchHelper(const CProcessBatchHelper& );
	CProcessBatchHelper& operator=(const CProcessBatchHelper& );

	HRESULT GetBatchEntry (IWbemClassObject *i_pInstance, CBatchEntry * io_pBatchEntry);
	HRESULT ValidateClassName ();

	HRESULT UpdateEntry (CBatchEntry *pEntry, bool fCreateOnly);
	HRESULT DeleteEntry (CBatchEntry *pEntry);
	HRESULT SetBatchEntryStatus (CBatchEntry *pEntry, HRESULT hrStatus);

	_variant_t varBatchEntryList;
	CBatchEntry *    m_aBatchEntries;						// Batch Entries
	ULONG			 m_cNrBatchEntries;						// number of batch entries
	_bstr_t			 m_bstrClassName;						// class name
	_bstr_t			 m_bstrDBName;							// database name
	_bstr_t			 m_bstrTableName;						// table name
	_bstr_t			 m_bstrSelector;						// selector
	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemClassObject>		m_spClassObject;		// class object
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;			// Catalog dispenser
	CComPtr<IWbemClassObject>		m_spInParams;			// in parameters
	CComPtr<IWbemClassObject>		m_spOutParams;			// out parameters
	CConfigQuery					m_cfgQuery;
	long			 m_lFlags;
	bool			 m_fInitialized;
	bool			 m_fErrorStatusSet;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\queryhelper.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    queryhelper.h

$Header: $

Abstract:

Author:
    marcelv 	11/14/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __QUERYHELPER_H__
#define __QUERYHELPER_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "wqlparser.h"
#include "cfgquery.h"
#include "cfgrecord.h"
#include "associationhelper.h"
#include "wmiobjectpathparser.h"

class CAssocBase;


class CQueryHelper
{
public:
	CQueryHelper ();
	~CQueryHelper ();

	HRESULT Init (const BSTR				i_wszQuery,
		          long						i_lFlags,
                  IWbemContext *			i_pCtx,
                  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace,
				  ISimpleTableDispenser2 *	i_pDispenser);

	bool IsAssociation () const;
	bool HasDBQualifier () const;

	HRESULT CreateInstances ();
	HRESULT CreateAppInstances ();
	HRESULT CreateAssociations ();

private:
	HRESULT CreateSingleInstance (const CConfigRecord& i_record, IWbemClassObject ** o_pInstance);
	HRESULT GetSingleRecord (CConfigRecord& o_record, ULONG *o_pcRow);
	HRESULT GetInfoForClass (const BSTR bstrClassName, _bstr_t& bstrDBName, _bstr_t& bstrTableName);
	HRESULT CreateAssocationHelper (CAssocBase **pAssocHelper);
	HRESULT CreateCodeGroupInstance (const CConfigRecord& record, IWbemClassObject ** o_pInstance);

	CQueryHelper (const CQueryHelper& );
	CQueryHelper& operator= (const CQueryHelper& );

	CWQLParser						m_wqlParser;			// wql path parser
	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemObjectSink>		m_spResponseHandler;    // response handler for async notification
	CComPtr<IWbemClassObject>		m_spClassObject;        // class we're dealing with
	CComPtr<ISimpleTableDispenser2>	m_spDispenser;			// Catalog dispenser
	CConfigQuery					m_cfgQuery;				// query for the class
	CAssociationHelper				m_assocHelper;          // association Helper
	long							m_lFlags;
	bool							m_fIsAssociation;		// are we association class?
	bool							m_fHasDBQualifier;		// do we have a database qualifier
	bool							m_fInitialized;			// are we initialized?
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\procbatchhelper.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    procbatchhelper.cpp

$Header: $

Abstract:
	ProcessBatch Helper class. Handles the ProcessBatch method for the .NET
	WMI Provider.
Author:
    marcelv 	12/14/2000		Initial Release

Revision History:

--**************************************************************************/

#include "procbatchhelper.h"
#include "localconstants.h"
#include "wmiobjectpathparser.h"
#include "wmihelper.h"
#include "cfgrecord.h"

enum BatchOp
{
	BATCHOP_CREATE		= 0,
	BATCHOP_MODIFY		= 1,
	BATCHOP_DELETE		= 2
};

//=================================================================================
// Function: CProcessBatchHelper::CProcessBatchHelper
//
// Synopsis: Constructor
//=================================================================================
CProcessBatchHelper::CProcessBatchHelper ()
{
	m_aBatchEntries		= 0;
	m_cNrBatchEntries	= 0;
	m_fInitialized		= false;
	m_fErrorStatusSet   = false;
}

//=================================================================================
// Function: CProcessBatchHelper::~CProcessBatchHelper
//
// Synopsis: Destructor
//=================================================================================
CProcessBatchHelper::~CProcessBatchHelper ()
{
	delete [] m_aBatchEntries;
	m_aBatchEntries = 0;
}

//=================================================================================
// Function: CProcessBatchHelper::Initialize
//
// Synopsis: Initializes the batch process helper. It gets all the batch entries,
//           convert them to the correct format, and verifies that all parameters are
//           specified correctly. Also, it validates that all class names are the same
//           because we only support single class batch updates
//
// Arguments: [io_pInParams] - 
//            [o_pOutParams] - 
//            [i_pNamespace] - 
//            [i_pCtx] - 
//            [i_pDispenser] - 
//            
// Return Value: 
//=================================================================================
HRESULT
CProcessBatchHelper::Initialize (IWbemClassObject		* io_pInParams,
								 IWbemClassObject		* o_pOutParams,
								 IWbemServices			* i_pNamespace,
								 IWbemContext			* i_pCtx,
								 ISimpleTableDispenser2 * i_pDispenser)
{
	ASSERT (!m_fInitialized);
	ASSERT (io_pInParams != 0);
	ASSERT (o_pOutParams != 0);
	ASSERT (i_pNamespace != 0);
	ASSERT (i_pCtx != 0);
	ASSERT (i_pDispenser != 0);

	m_spInParams	= io_pInParams;
	m_spOutParams	= o_pOutParams;
	m_spNamespace	= i_pNamespace;
	m_spCtx			= i_pCtx;
	m_spDispenser	= i_pDispenser;


	_variant_t varFlags;

	HRESULT hr = io_pInParams->Get(L"BatchList", 0, &varBatchEntryList, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get ObjectList in-parameter for batch update");
		return hr;
	}

	hr = io_pInParams->Get(L"Flags", 0, &varFlags, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get flags in-parameter for batch update");
		return hr;
	}

	// we don't support empty parameters
	if (varBatchEntryList.vt == VT_NULL || varFlags.vt == VT_NULL)
	{
		TRACE (L"Null ObjectList or Null flags argument");
		return E_INVALIDARG;
	}

	m_lFlags = varFlags;
	if (m_lFlags != 0)
	{
		TRACE (L"Flags is reserved and should be zero");
		return E_INVALIDARG;
	}

	// copy elements from variant array into local array so that we can use it
	// easily

	SAFEARRAY *pSABatchEntryList = varBatchEntryList.parray;
	ASSERT (pSABatchEntryList != 0);
	
	m_cNrBatchEntries = pSABatchEntryList->rgsabound[0].cElements;

	if (m_cNrBatchEntries == 0)
	{
		TRACE (L"Number of elements is 0");
		return E_INVALIDARG;
	}

	m_aBatchEntries = new CBatchEntry [m_cNrBatchEntries];
	if (m_aBatchEntries == 0)
	{
		return E_OUTOFMEMORY;
	}

	IWbemClassObject **aObjects;
		
	hr = SafeArrayAccessData (pSABatchEntryList, (void **) &aObjects);
	if (FAILED (hr))
	{
		TRACE (L"SafeArrayAccessData failed");
		return hr;
	}
	
	hr = SafeArrayUnaccessData (pSABatchEntryList);
	if (FAILED (hr))
	{
		TRACE (L"SafeArrayUnAccessData failed");
		return hr;
	}

	for (ULONG idx=0; idx < m_cNrBatchEntries; ++idx)
	{
		
		hr = GetBatchEntry (aObjects[idx], m_aBatchEntries + idx);
		if (FAILED (hr))
		{
			SetBatchEntryStatus (m_aBatchEntries + idx, hr);
			TRACE (L"Error while getting batch entry %d", idx);
			return hr;
		}
	}

	hr = ValidateClassName ();
	if (FAILED (hr))
	{
		TRACE (L"Error while validating class name");
		return hr;
	}

	m_fInitialized = true;
	return hr;
}

//=================================================================================
// Function: CProcessBatchHelper::ProcessAll
//
// Synopsis: Process all batch entries. We already verified that all entries have
//           the correct information and that everything comes from a single class.
//           Depending on the batch operator we do insert, update or delete
//=================================================================================
HRESULT
CProcessBatchHelper::ProcessAll ()
{
	ASSERT (m_fInitialized);
	HRESULT hr = S_OK;

	hr = m_cfgQuery.Init (m_bstrDBName, m_bstrTableName, m_bstrSelector, m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of config query failed (db=%s, table=%s)", (LPWSTR) m_bstrDBName, (LPWSTR) m_bstrTableName);
		return hr;
	}

	hr = m_cfgQuery.Execute (0, false, true);
	if (FAILED (hr))
	{
		TRACE (L"Initialization of config query failed (db=%s, table=%s)", (LPWSTR) m_bstrDBName, (LPWSTR) m_bstrTableName);
		return hr;
	}

	for (ULONG idx=0; idx< m_cNrBatchEntries; ++idx)
	{
		CBatchEntry * pBatchEntry = m_aBatchEntries + idx;
		
		switch (pBatchEntry->iOperator)
		{
		case BATCHOP_CREATE:
			hr = UpdateEntry (pBatchEntry, true);
			break;

		case BATCHOP_MODIFY:
			hr = UpdateEntry (pBatchEntry, false);
			break;

		case BATCHOP_DELETE:
			hr = DeleteEntry (pBatchEntry);
			break;

		default:
			break; // ignore everything else
		}

		SetBatchEntryStatus (pBatchEntry, hr); // always set the status
		if (FAILED (hr))
		{
			TRACE (L"Error while doing batch method for single record");
			return hr;
		}
	}
	
	if (FAILED (hr))
	{
		TRACE (L"Unable to process batchentry");
		return hr;
	}

	hr = m_cfgQuery.Save ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to save");
		return hr;
	}

	_variant_t varHR;
	varHR = hr;
	hr = m_spOutParams->Put (_bstr_t(L"ReturnValue"), 0, &varHR, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set return value");
		return hr;
	}

	hr = m_spOutParams->Put (L"BatchList", 0, &varBatchEntryList, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set batchlist value");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CProcessBatchHelper::GetBatchEntry
//
// Synopsis: Get a single batch entry that is passed in from WMI via the ProcessBatch
//           method. This method also verifies that the given information is valid.
//
// Arguments: [i_pInstance] - instance to convert to batch entry
//            [io_pBatchEntry] - the entry that will contain the result
//=================================================================================
HRESULT
CProcessBatchHelper::GetBatchEntry (IWbemClassObject *i_pInstance,
									CBatchEntry * io_pBatchEntry)
{
	ASSERT (i_pInstance != 0);
	ASSERT (io_pBatchEntry != 0);

	io_pBatchEntry->pInstance = i_pInstance;

	// get Op property
	_variant_t varOp;
	HRESULT	hr = i_pInstance->Get (_bstr_t(L"Op"), 0, &varOp, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get OP property for BatchEntry");
		return hr;
	}

	// get inst
	_variant_t varInst;
	hr = i_pInstance->Get (_bstr_t(L"Inst"), 0, &varInst, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Inst property for BatchEntry");
		return hr;
	}
	
	_variant_t varPath;
	hr = i_pInstance->Get (_bstr_t(L"Path"), 0, &varPath, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Path property for BatchEntry");
		return hr;
	}

	// do verification
	
	if (varOp.vt == VT_NULL)
	{
		TRACE (L"Operator is not specified");
		return E_INVALIDARG;
	}

	io_pBatchEntry->iOperator = (long) varOp;

	// operator needs to be either CREATE, MODIFY, DELETE
	if (io_pBatchEntry->iOperator != BATCHOP_CREATE && 
		io_pBatchEntry->iOperator != BATCHOP_MODIFY &&
		io_pBatchEntry->iOperator != BATCHOP_DELETE)
	{
		TRACE (L"Invalid operator value specified (only 0,1,2,3 are valid)");
		return E_INVALIDARG;
	}

	// we need a valid instance during CREATE or MODIFY
	if (io_pBatchEntry->iOperator == BATCHOP_CREATE ||
		io_pBatchEntry->iOperator == BATCHOP_MODIFY)
	{
		if (varInst.vt == VT_NULL)
		{
			TRACE (L"We need a valid WMI Object when doing BATCHOP_CREATE or BATCHOP_MODIFY");
			return E_INVALIDARG;
		}
	}

	// we need a valid object path during DELETE or RETRIEVE
	if (io_pBatchEntry->iOperator == BATCHOP_DELETE)
	{
		if (varPath.vt == VT_NULL)
		{
			TRACE (L"We need a valid WMI Object when doing BATCHOP_CREATE or BATCHOP_MODIFY");
			return E_INVALIDARG;
		}
	}

	io_pBatchEntry->hrStatus   = S_OK;

	if (varInst.vt != VT_NULL)
	{
		io_pBatchEntry->spInst    = (IWbemClassObject *) varInst.pdispVal;
	}

	if (varPath.vt != VT_NULL)
	{
		io_pBatchEntry->bstrPath  = varPath;
	}

	return S_OK;
}

//=================================================================================
// Function: CProcessBatchHelper::ValidateClassName
//
// Synopsis: Go through all batch entries and ensure that the class name is the
//           same for all of them. For Create/Modify, it needs to get the class name
//           from the WMI object that is passed in, while in case of delete/retrieve
//           the classname has to be extracted from the object path
// Return Value: 
//		S_OK, all class names the same, non-S_OK classnames are not the same
//=================================================================================
HRESULT
CProcessBatchHelper::ValidateClassName ()
{
	HRESULT hr = S_OK;

	for (ULONG idx=0; idx < m_cNrBatchEntries; ++idx)
	{
		_variant_t varClassName;
		_variant_t varSelector;

		CBatchEntry *pBatchEntry = m_aBatchEntries + idx;
		if (pBatchEntry->iOperator == BATCHOP_CREATE ||
		    pBatchEntry->iOperator == BATCHOP_MODIFY)
		{
			hr = pBatchEntry->spInst->Get(L"__class", 0, &varClassName, 0 , 0);
			if (FAILED (hr))
			{
				TRACE (L"Unable to get __class property for object %ld", idx);
				return hr;
			}

			hr = pBatchEntry->spInst->Get(WSZSELECTOR, 0, &varSelector, 0 , 0);
			if (FAILED (hr))
			{
				TRACE (L"Unable to get selector property for object %ld", idx);
				return hr;
			}
		}
		else
		{
			CObjectPathParser objPathParser;
			hr = objPathParser.Parse (pBatchEntry->bstrPath);
			if (FAILED (hr))
			{
				TRACE (L"Unable to parse object path %s", (LPWSTR) pBatchEntry->bstrPath);
				return hr;
			}

			varClassName = objPathParser.GetClass ();
			const CWMIProperty * pProp= objPathParser.GetPropertyByName (WSZSELECTOR);
			if (pProp == 0)
			{
				TRACE (L"Unable to find selector property in object path %s", (LPWSTR) pBatchEntry->bstrPath);
				return E_INVALIDARG;
			}
			varSelector = pProp->GetValue ();
		}

		// ensure that both selector and classnames are the same for all entries
		if (idx == 0)
		{
			m_bstrClassName = varClassName;
			m_bstrSelector  = varSelector;
		}
		else
		{
			if (_wcsicmp ((LPWSTR) m_bstrClassName, (LPWSTR) varClassName.bstrVal ) != 0)
			{
				TRACE (L"Class names differ: %s and %s", (LPWSTR) m_bstrClassName, (LPWSTR)((bstr_t)varClassName));
				return E_INVALIDARG;
			}

			if (_wcsicmp ((LPWSTR) m_bstrSelector, (LPWSTR) varSelector.bstrVal) != 0)
			{
				TRACE (L"Selectors differ: %s and %s", (LPWSTR) m_bstrSelector, (LPWSTR) ((bstr_t) varSelector));
				return E_INVALIDARG;
			}
		}
	}
	// all class names and selectors match. lets retrieve the class information

	hr = m_spNamespace->GetObject((LPWSTR) m_bstrClassName, 
	    						  0, 
								  m_spCtx, 
								  &m_spClassObject, 
								  0); 
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", (LPWSTR) m_bstrClassName);
		return hr;
	}

	hr = CWMIHelper::GetClassInfo (m_spClassObject, m_bstrDBName, m_bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class information");
		return hr;
	}
	

	return S_OK;
}

//=================================================================================
// Function: CProcessBatchHelper::UpdateEntry
//
// Synopsis: Updates/Creates a single instance
//
// Arguments: [pEntry] - batch entry with update information
//            [i_fCreateOnly] - true, create-only update semantics, false, update-only update
//=================================================================================
HRESULT
CProcessBatchHelper::UpdateEntry (CBatchEntry *pEntry, bool i_fCreateOnly)
{
	ASSERT (m_fInitialized);
	ASSERT (pEntry != 0);
	ASSERT (pEntry->iOperator == BATCHOP_CREATE ||
		    pEntry->iOperator == BATCHOP_MODIFY);

	HRESULT hr = S_OK;

	CConfigRecord record;
	hr = m_cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get empty configuration record");
		return hr;
	}

	// loop through all values in the object, and save to the record
	hr = m_spClassObject->BeginEnumeration (WBEM_FLAG_NONSYSTEM_ONLY);
	if (FAILED(hr))
	{
		TRACE (L"BeginEnumeration failed for class %s", (LPWSTR) m_bstrClassName);
		return hr;
	}

	hr = 0;
	while (SUCCEEDED (hr))
	{
		CComBSTR bstrName;
		_variant_t varValue;
		hr = m_spClassObject->Next (0, &bstrName, 0, 0, 0);
		if (hr == WBEM_S_NO_MORE_DATA)
		{
			// we went over all properties
			hr = S_OK;
			break;
		}

		if (FAILED (hr))
		{
			TRACE (L"IWbemClassObject::Next failed in PutInstance");
			return hr;
		}

		hr = pEntry->spInst->Get(bstrName, 0, &varValue, 0, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get WMI value for %s", bstrName);
			return hr;
		}

		record.SetValue (bstrName, varValue); // ignore errors because properties might not be present
	}

	hr = m_spClassObject->EndEnumeration ();
	if (FAILED (hr))
	{
		TRACE (L"EndEnumeration failed");
		return hr;
	}

	// the record is populated. Get the PK Row, and update it.

	ULONG cReadRow;
	hr = m_cfgQuery.GetPKRow (record, &cReadRow);
	if (hr == E_ST_NOMOREROWS)
	{
		cReadRow = (ULONG) -1;
		hr = S_OK;
	}

	if (FAILED (hr))
	{
		TRACE (L"Unable to get primary key row");
		return hr;
	}

	// in case of create only, we change the flag to the update function
	// to createonly.
	long lFlags = WBEM_FLAG_UPDATE_ONLY;
	if (i_fCreateOnly)
	{
		lFlags = WBEM_FLAG_CREATE_ONLY;
	}

	hr = m_cfgQuery.UpdateRow (cReadRow, record, lFlags);
	if (FAILED (hr))
	{
		TRACE (L"UpdateRow failed");
		return hr;
	}
	return hr;
}

//=================================================================================
// Function: CProcessBatchHelper::DeleteEntry
//
// Synopsis: Delete a single instance. In case the instance is not found, we silently
//           ignore the error
//
// Arguments: [pEntry] - entry to delete
//=================================================================================
HRESULT
CProcessBatchHelper::DeleteEntry (CBatchEntry *pEntry)
{
	ASSERT (pEntry != 0);
	ASSERT (m_fInitialized);
	ASSERT (pEntry->iOperator == BATCHOP_DELETE);

	HRESULT hr = S_OK;

	CObjectPathParser objPath;
	hr = objPath.Parse (pEntry->bstrPath);
	if (FAILED (hr))
	{
		TRACE (L"Parsing of object path failed: %s", (LPWSTR) pEntry->bstrPath);
		return hr;
	}

	CConfigRecord record;
	hr = m_cfgQuery.GetEmptyConfigRecord (record);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get empty config record");
		return hr;
	}

	// populate the record

	for (ULONG propIdx=0; propIdx < objPath.GetPropCount (); ++propIdx)
	{
		const CWMIProperty * pProp = objPath.GetProperty (propIdx);
		ASSERT (pProp != 0);
		record.SetValue (pProp->GetName(), pProp->GetValue ()); // ignore errors
	}

	// get the index
	ULONG cReadRow;
	hr = m_cfgQuery.GetPKRow (record, &cReadRow);

	// if row does not exist, we simple ignore it
	if (hr == E_ST_NOMOREROWS)
	{
		return S_OK;
	}

	if (FAILED (hr))
	{
		TRACE (L"Unable to get PK Row");
		return hr;
	}

	hr = m_cfgQuery.DeleteRow (cReadRow);
	if (FAILED (hr))
	{
		TRACE (L"Unable to delete row");
		return hr;
	}

	return hr;
}

HRESULT
CProcessBatchHelper::SetBatchEntryStatus (CBatchEntry *pEntry, HRESULT hrStatus)
{
	ASSERT (pEntry != 0);
	ASSERT (pEntry->pInstance != 0);

	if (FAILED (hrStatus))
	{
		m_fErrorStatusSet = true;
	}

	_variant_t varStatus = hrStatus;
	HRESULT hr = pEntry->pInstance->Put (L"Status", 0, &varStatus, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to pust status property for BatchEntry");
		return hr;
	}

	return hr;
}

bool
CProcessBatchHelper::HaveStatusError () const
{
	return m_fErrorStatusSet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\queryhelper.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    queryhelper.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/14/2000		Initial Release

Revision History:

--**************************************************************************/

#include "queryhelper.h"
#include "localconstants.h"
#include "wmiobjectpathparser.h"
#include "stringutil.h"
#include "smartpointer.h"
#include "wmihelper.h"
#include "webapphelper.h"
#include "codegrouphelper.h"

#include "assoctypes.h"
#include "assoccatalog.h"
#include "assoclocation.h"
#include "assocapplication.h"
#include "assocfilehierarchy.h"
#include "assocwebappchild.h"

//=================================================================================
// Function: CQueryHelper::CQueryHelper
//
// Synopsis: Constructor
//=================================================================================
CQueryHelper::CQueryHelper ()
{
	m_fInitialized		= false;
	m_fIsAssociation	= false;
	m_fHasDBQualifier	= false;
}

//=================================================================================
// Function: CQueryHelper::~CQueryHelper
//
// Synopsis: Destructor
//=================================================================================
CQueryHelper::~CQueryHelper ()
{
}

//=================================================================================
// Function: CQueryHelper::Init
//
// Synopsis: Initializes the query helper
//
// Arguments: [i_wszQuery] - query to execute
//            [i_lFlags] - flags for query
//            [i_pCtx] - context
//            [i_pResponseHandler] - response handler
//            [i_pNamespace] - namespace
//            [i_pDispenser] - dispenser
//=================================================================================
HRESULT
CQueryHelper::Init (const BSTR				i_wszQuery,
		          long						i_lFlags,
                  IWbemContext *			i_pCtx,
                  IWbemObjectSink *			i_pResponseHandler,
				  IWbemServices *			i_pNamespace,
				  ISimpleTableDispenser2 *	i_pDispenser)
{
	ASSERT (!m_fInitialized);
	ASSERT (i_wszQuery != 0);
	ASSERT (i_pCtx != 0);
	ASSERT (i_pResponseHandler != 0);
	ASSERT (i_pNamespace != 0);
	ASSERT (i_pDispenser != 0);

	m_spCtx				= i_pCtx;
	m_spResponseHandler = i_pResponseHandler;
	m_spNamespace		= i_pNamespace;
	m_spDispenser		= i_pDispenser;
	m_lFlags			= i_lFlags;

	HRESULT hr = m_wqlParser.Parse (i_wszQuery);
	if (FAILED (hr))
	{
		TRACE (L"Parsing of query %s failed", i_wszQuery);
		return hr;
	}

	ASSERT (m_wqlParser.GetClass () != 0);

	hr = m_spNamespace->GetObject((LPWSTR) m_wqlParser.GetClass (), 
											0, 
											m_spCtx, 
											&m_spClassObject, 
											0); 
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", m_wqlParser.GetClass ());
		return hr;
	}

	CComPtr<IWbemQualifierSet> spQualifierSet;
	hr = m_spClassObject->GetQualifierSet (&spQualifierSet);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Qualifier set for class %s", m_wqlParser.GetClass ());
		return hr;
	}

	// figure out if we are assocation, and if we do have a db qualifier
		
	_variant_t varAssoc;
	hr = spQualifierSet->Get (L"Association", 0, &varAssoc, 0);
	if (SUCCEEDED (hr))
	{
		m_fIsAssociation = true;
	}
	else
	{
		hr = S_OK;
	}

	_variant_t varDB;
	hr = spQualifierSet->Get (L"Database", 0, &varDB, 0);
	if (SUCCEEDED (hr))
	{
		m_fHasDBQualifier = true;
	}
	else
	{
		hr = S_OK;
	}

	m_fInitialized = true;

	return hr;
}



//=================================================================================
// Function: CQueryHelper::IsAssociation
//
// Synopsis: Is the class specified in the query an assocation or not?
//=================================================================================
bool
CQueryHelper::IsAssociation () const
{
	ASSERT (m_fInitialized);

	return m_fIsAssociation;
}

//=================================================================================
// Function: CQueryHelper::HasDBQualifier
//
// Synopsis: Does the class specified in the query have a DB qualifier or not?
//=================================================================================
bool
CQueryHelper::HasDBQualifier () const
{
	ASSERT (m_fInitialized);

	return m_fHasDBQualifier;
}

HRESULT
CQueryHelper::CreateInstances ()
{
	ASSERT (m_fInitialized);
	ASSERT (!m_fIsAssociation );

	_bstr_t bstrDBName;
	_bstr_t bstrTableName;

	HRESULT hr = CWMIHelper::GetClassInfo (m_spClassObject, bstrDBName, bstrTableName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get database name and table name for class %s", m_wqlParser.GetClass ());
		return hr;
	}

	const CWQLProperty * pProp = m_wqlParser.GetPropertyByName (WSZSELECTOR);
	if (pProp == 0)
	{
		// todo: better errro handling
		TRACE (L"No selector specified");
		return E_INVALIDARG;
	}

	CConfigQuery cfgQuery;

	hr = cfgQuery.Init (bstrDBName,	bstrTableName, pProp->GetValue (),	m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Unable to initialize Query");
		return hr;
	}

	hr = cfgQuery.Execute (0, false, false);
	if (FAILED (hr))
	{
		TRACE (L"Query Execution failed");
		return hr;
	}

	////////// SPECIAL CASE Codegroup ///////////////////////
	bool fIsCodeGroup = false;
	if (_wcsicmp (m_wqlParser.GetClass (), WSZCODEGROUP) == 0)
	{
		fIsCodeGroup = true;
	}

	for (ULONG idx=0; idx < cfgQuery.GetRowCount (); ++idx)
	{
		CConfigRecord record;
		hr = cfgQuery.GetColumnValues (idx, record);
		if (FAILED (hr))
		{
			TRACE (L"Unable to get column values for class %s", m_wqlParser.GetClass ());
			return hr;
		}

		CComPtr<IWbemClassObject> spNewInst;

		/////// SPECIAL CASE Codegroup //////////////
		if (fIsCodeGroup)
		{
			hr = CreateCodeGroupInstance (record, &spNewInst);
		}
		else
		{
			hr = CreateSingleInstance (record, &spNewInst);
		}

		if (FAILED (hr))
		{
			TRACE (L"Unable to create single instance for class %s", m_wqlParser.GetClass ());
			return hr;
		}

		IWbemClassObject* pNewInstRaw = spNewInst;
		hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);
		if (FAILED (hr))
		{
			TRACE (L"WMI Indicate failed");
		}
	}

	return hr;
}

HRESULT
CQueryHelper::CreateSingleInstance (const CConfigRecord& i_record, IWbemClassObject ** o_pInstance)
{
	ASSERT (m_fInitialized);
	ASSERT (o_pInstance != 0);

	
	const CWQLProperty *pSelector = m_wqlParser.GetPropertyByName (WSZSELECTOR);
	ASSERT (pSelector != 0);

	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, o_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class %s", m_wqlParser.GetClass ());
		return hr;
	}

	for (ULONG idx=0; idx<i_record.ColumnCount(); ++idx)
	{
		// only persistable columns appear as properties, so we should only update
		// these properties
		if (i_record.IsPersistableColumn (idx))
		{
			LPCWSTR wszColName = i_record.GetColumnName (idx);

			_variant_t varValue;
			hr = i_record.GetValue (idx, varValue);
			if (FAILED (hr))
			{
				TRACE (L"Unable to get value for column %s", wszColName);
				return hr;
			}
			hr = (*o_pInstance)->Put((_bstr_t)wszColName, 0, &varValue, 0);
			if (FAILED (hr))
			{
				TRACE (L"WMI Put property of %s", wszColName);
				return hr;
			}
		}
	}

	// and add the selector

	_variant_t varSelector = pSelector->GetValue ();
	hr = (*o_pInstance)->Put ((_bstr_t)WSZSELECTOR, 0, &varSelector, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put Property of selector failed (value = %s)", pSelector->GetValue ());
		return hr;
	}

	return hr;
}


//=================================================================================
// Function: CQueryHelper::CreateAssociations
//
// Synopsis: This is the class factory that creates the correct instance of an assocation
//           creator object. Every assocation has an AssocType qualifier that is used to
//           determine the assocation type. When new association types are defined, a new
//           type needs to be added, and this function will need to be updated to create an
//           instance of the new assocation type creation class. Have a look at
//           CAssocCatalog or CAssocLocation for an example of this.
//=================================================================================
HRESULT
CQueryHelper::CreateAssociations ()
{
	ASSERT (m_fInitialized);
	ASSERT (m_wqlParser.GetPropCount () == 1);

	TSmartPointer<CAssocBase> spAssocHelper;
	HRESULT hr = CreateAssocationHelper (&spAssocHelper);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get association helper");
		return hr;
	}

	hr = spAssocHelper->Init (m_wqlParser,
		                      m_spClassObject,
							  m_lFlags,
							  m_spCtx,
							  m_spResponseHandler,
							  m_spNamespace,
							  m_spDispenser);
	if (FAILED (hr))
	{
		TRACE (L"Init of assoc helper failed");
		return hr;
	}

	hr = spAssocHelper->CreateAssocations ();
	if (FAILED (hr))
	{
		TRACE (L"Assocation Creation failed");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CQueryHelper::CreateAssocationHelper
//
// Synopsis: This is the class factory for assocation creation objects. The assocation
//           type is determined from the assocation that we are dealing with, and depending
//           on the type, a certain assocation creation object is created. When you need
//           a new assocation type, modify this function accordingly.
//
// Arguments: [pAssocHelper] - Assocation Helper that gets created. This is the object
//                             that creates the individual assocations.
//=================================================================================
HRESULT
CQueryHelper::CreateAssocationHelper (CAssocBase **pAssocHelper)
{
	ASSERT (pAssocHelper != 0);
	ASSERT (m_fInitialized);

	// initialize output parameter
	*pAssocHelper = 0;

	CComPtr<IWbemQualifierSet> spPropQualifierSet;
	HRESULT hr = m_spClassObject->GetQualifierSet (&spPropQualifierSet);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get QualifierSet for class %s", m_wqlParser.GetClass ());
		return hr;
	}

	_variant_t varAssocType;
	hr = spPropQualifierSet->Get (g_wszAssocType, 0, &varAssocType, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get AssocType qualifier for class %s", m_wqlParser.GetClass ());
		return hr;
	}

	// instantiate the correct assocation helper

	LPCWSTR wszAssocType = varAssocType.bstrVal;

	if (_wcsicmp (wszAssocType, g_wszAssocTypeCatalog) == 0)
	{
		*pAssocHelper = new CAssocCatalog;
	}
	else if (_wcsicmp (wszAssocType, g_wszAssocTypeLocation) == 0)
	{
		*pAssocHelper = new CAssocLocation;
	}
	else if (_wcsicmp (wszAssocType, g_wszAssocTypeAppUnmerged) == 0)
	{
		*pAssocHelper = new CAssocApplication;
	}
	else if (_wcsicmp (wszAssocType, g_wszAssocTypeAppmerged) == 0)
	{
		*pAssocHelper = new CAssocApplication;
	}
	else if (_wcsicmp (wszAssocType, g_wszAssocTypeFileHierarchy) == 0)
	{
		*pAssocHelper = new CAssocFileHierarchy;
	}
	else  if (_wcsicmp (wszAssocType, g_wszAssocTypeWebAppChild) == 0)
	{
		*pAssocHelper = new CAssocWebAppChild;
	}
	else if (_wcsicmp (wszAssocType, g_wszAssocTypeWebAppParent) == 0)
	{
		*pAssocHelper = new CAssocWebAppChild;
	}
	else
	{
		ASSERT (false && !"Unknown assocation type");
		return E_INVALIDARG;
	}

	if (*pAssocHelper == 0)
	{
		return E_OUTOFMEMORY;
	}

	return hr;
}


HRESULT
CQueryHelper::CreateAppInstances ()
{
	if (_wcsicmp (m_wqlParser.GetClass (), L"WebApplication") != 0)
	{
		return S_OK;
	}

	HRESULT hr = S_OK;
	CWebAppHelper webAppHelper;
	hr = webAppHelper.Init ((_bstr_t)L"WebApplication",0, m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		TRACE (L"Unable to initialize webAppHelper");
		return hr;
	}

	hr = webAppHelper.EnumInstances ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to enumerate webApplications");
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CQueryHelper::CreateCodeGroupInstance
//
// Synopsis: SPECIAL CASE for CODEGROUP. Create a single instance of a codegroup.
//
// Arguments: [record] - Contains XML Blob with codegrup information
//            [o_pInstance] - WMI Instance to be created
//            
// Return Value: 
//=================================================================================
HRESULT 
CQueryHelper::CreateCodeGroupInstance (const CConfigRecord& record, IWbemClassObject ** o_ppInstance)
{
	ASSERT (o_ppInstance != 0);

	CCodeGroupHelper codegroupHelper;

	HRESULT hr = codegroupHelper.Init (m_spCtx, m_spResponseHandler, m_spNamespace);
	if (FAILED (hr))
	{
		TRACE (L"Init of codegroupHelper failed");
		return hr;
	}

	const CWQLProperty *pSelector = m_wqlParser.GetPropertyByName (WSZSELECTOR);
	if (pSelector == 0)
	{
		TRACE (L"Query doesn't contain selector");
		return E_INVALIDARG;
	}

	hr = codegroupHelper.CreateInstance (record, pSelector->GetValue (), o_ppInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create codegroup instance");
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\wmihelper.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wmihelper.h

$Header: $

Abstract:

Author:
    marcelv 	12/6/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WMIHELPER_H__
#define __WMIHELPER_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catmacros.h"

class CWMIHelper
{
public:
	static HRESULT GetClassInfo (IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\webapphelper.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    webapphelper.h

$Header: $

Abstract:

Author:
    marcelv 	12/8/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WEBAPPHELPER_H__
#define __WEBAPPHELPER_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catalog.h"
#include "catmacros.h"
#include "wmiobjectpathparser.h"

class CWebAppHelper
{
public:
	CWebAppHelper ();
	~CWebAppHelper ();

	HRESULT Init (const BSTR i_bstrclass,
				  long lFlags,
				  IWbemContext  * i_pCtx,
				  IWbemObjectSink * i_pResponseHandler,
				  IWbemServices * i_pNamespace);

	HRESULT Delete (const CObjectPathParser& i_ObjPathParser);
	HRESULT PutInstance (IWbemClassObject * i_pInstance);

	HRESULT EnumInstances ();
	HRESULT CreateSingleInstance (LPCWSTR i_wszSelector);

private:
	HRESULT IsASPPlusInstalled (bool *pfIsAspPlusInstalled);

	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemClassObject>		m_spClassObject;        // class we're dealing with
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemObjectSink>		m_spResponseHandler;    // WMI sink
	long							m_lFlags;				// flags
	bool							m_fInitialized;			// are we initialized

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\stringutil.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    stringutil.cpp

$Header: $

Abstract:
	String Helper functions for .NET WMI provider

Author:
    marcelv 	11/10/2000		Initial Release

Revision History:

--**************************************************************************/

#include "stringutil.h"

//=================================================================================
// Function: CWMIStringUtil::Trim
//
// Synopsis: Trims the character i_wcTrim from front and back of the string. The string
//           that is passed in i_wsz is changed by this !!!
//
// Arguments: [i_wsz] - string to be trimmed
//            [i_wcTrim] - character to trim from front and back
//            
// Return Value: pointer to trimmed string
//=================================================================================
LPWSTR
CWMIStringUtil::Trim (LPWSTR i_wsz, WCHAR i_wcTrim)
{
	ASSERT (i_wsz != 0);
	LPWSTR pTemp = LTrim (i_wsz, i_wcTrim);
	pTemp = RTrim (pTemp, i_wcTrim);
	return pTemp;
}

//=================================================================================
// Function: CWMIStringUtil::LTrim
//
// Synopsis: Trims characters from the beginning of the string.
//
// Arguments: [i_wsz] - string to be trimmed
//            [i_wcTrim] - character to trim from the beginning
//            
// Return Value: pointer to LTrimmed string
//=================================================================================
LPWSTR
CWMIStringUtil::LTrim (LPWSTR i_wsz, WCHAR i_wcTrim)
{	
	ASSERT (i_wsz != 0);
	LPWSTR pTemp = i_wsz;
	while (*pTemp == i_wcTrim)
	{
		pTemp++;
	}
	return pTemp;
}

//=================================================================================
// Function: CWMIStringUtil::RTrim
//
// Synopsis: Trims characters at the end of the string. The i_wsz string is changed
//           by this function
//
// Arguments: [i_wsz] - string to be RTrimmed
//            [i_wcTrim] - character to trim from the end
//            
// Return Value: pointer to RTrimmed string
//=================================================================================
LPWSTR
CWMIStringUtil::RTrim (LPWSTR i_wsz, WCHAR i_wcTrim)
{
	ASSERT (i_wsz != 0);
	SIZE_T iLen = wcslen (i_wsz);

	for (SIZE_T idx=iLen-1; idx >= 0; --idx)
	{
		if (i_wsz[idx] == i_wcTrim)
		{
			i_wsz[idx] = L'\0';
		}
		else
		{
			break;
		}
	}

	return i_wsz;
}

//=================================================================================
// Function: CWMIStringUtil::StrToLower
//
// Synopsis: Converts a string to lower case by ignoring the strings that are placed
//           inside quotes or double quotes
//
// Arguments: [i_wszStr] - String to be converted
//            
// Return Value: pointer to converted string
//=================================================================================
LPWSTR
CWMIStringUtil::StrToLower (LPCWSTR io_wszStr)
{
	ASSERT (io_wszStr != 0);

	LPWSTR wszRet = new WCHAR [wcslen(io_wszStr) + 1];
	if (wszRet == 0)
	{
		return 0;
	}

	bool fInSingleQuotes = false;
	bool fInDoubleQuotes = false;
	bool fDoubleBackSlash = false;
	ULONG iCopyIdx = 0;

	WCHAR cLastChar = 0;

	for (LPCWSTR pFinder = io_wszStr; *pFinder != L'\0'; ++pFinder)
	{
		switch (*pFinder)
		{
		case L'\"':
			if (!fInSingleQuotes && cLastChar != '\\')
			{
				fInDoubleQuotes = !fInDoubleQuotes;
			}
			break;

		case L'\'':
			if (!fInDoubleQuotes && cLastChar != '\\')
			{
				fInSingleQuotes = !fInSingleQuotes;
			}
			break;

		case L'\\':
			if (fInSingleQuotes || fInDoubleQuotes)
			{
				if (cLastChar == L'\\') 
				{
					fDoubleBackSlash = true;
				}	
			}

		default:
			// do nothing
			break;
		}

		if (!fInSingleQuotes && !fInDoubleQuotes)
		{
			wszRet[iCopyIdx] = towlower(*pFinder);
		}
		else
		{
			wszRet[iCopyIdx] = *pFinder;
		}
		iCopyIdx++;
		if (fDoubleBackSlash)
		{
			fDoubleBackSlash = false;
			cLastChar = 0;
		}
		else
		{
			cLastChar = *pFinder;
		}
	}

	wszRet[iCopyIdx] = L'\0';

	ASSERT (!fInSingleQuotes);
	ASSERT (!fInDoubleQuotes);
		
	return wszRet;
}

//=================================================================================
// Function: CWMIStringUtil::FindChar
//
// Synopsis: Find a specific character in a string. The character is skipped if it is
//           found inside a section that is embraced by ""
//
// Arguments: [wszString] - String to search in
//            [wchr] - Character to search for
//            
// Return Value: pointer to first character wchr inside wszString if found, NULL otherwise
//=================================================================================
LPWSTR
CWMIStringUtil::FindChar (LPWSTR i_wszString, LPCWSTR i_aChars)
{
	ASSERT (i_wszString != 0);
	// we don't support searching for single quote, double quote and backslash
	ASSERT (wcschr (i_aChars, L'\'') == 0);
	ASSERT (wcschr (i_aChars, L'\"') == 0);
	ASSERT (wcschr (i_aChars, L'\\') == 0);

	bool fInDoubleQuotes = false;
	bool fInSingleQuotes = false;
	for (LPWSTR pFinder = i_wszString; *pFinder != L'\0'; ++pFinder)
	{
		if (*pFinder == L'\"')
		{
			if (!fInSingleQuotes)
			{
				fInDoubleQuotes = !fInDoubleQuotes;
			}
		}
		else if (*pFinder == L'\'')
		{
			if (!fInDoubleQuotes)
			{
				fInSingleQuotes = !fInSingleQuotes;
			}
		}
		else if (*pFinder == L'\\')
		{
			// skip over next char
			pFinder++;
		}

		if (!fInDoubleQuotes && !fInSingleQuotes && wcschr(i_aChars,*pFinder) != 0)
		{
			return pFinder;
		}
	}

	return 0;
}

//=================================================================================
// Function: CWMIStringUtil::FindStr
//
// Synopsis: Finds a substring inside a string, and ignores strings that are enclosed
//           inside quotes/double quotes. This makes it easy to do WQL query searching
//           and ignoring the properties that are inside quotes
//
// Arguments: [i_wszStr] - String to search in
//            [i_wszSubStr] - String to search for
//            
// Return Value: pointer to first occurence of i_wszSubStr in i_wszStr, or NULL if not
//               found
//=================================================================================
LPWSTR
CWMIStringUtil::FindStr (LPWSTR i_wszStr, LPCWSTR i_wszSubStr)
{
	ASSERT (i_wszStr != 0);
	ASSERT (i_wszSubStr != 0);

	// we don't support strings with quotes, double quotes and backslashes
	ASSERT (wcschr (i_wszSubStr, L'\'') == 0);
	ASSERT (wcschr (i_wszSubStr, L'\"') == 0);
	ASSERT (wcschr (i_wszSubStr, L'\\') == 0);

	
	if (i_wszSubStr[0] == L'\0')
	{
		return 0;
	}

	bool fInSingleQuotes = false;
	bool fInDoubleQuotes = false;

	SIZE_T idx = 0;
	SIZE_T iSize = wcslen (i_wszSubStr);
	LPWSTR pStart = 0;

	for (LPWSTR pFinder = (LPWSTR) i_wszStr; *pFinder != L'\0'; ++pFinder)
	{
		 if (*pFinder == L'\"')
		 {
			 if (!fInSingleQuotes)
			 {
				 fInDoubleQuotes = !fInDoubleQuotes;
				 idx = 0;
			 }
		 }
		 else if (*pFinder == L'\'')
		 {
			 if (!fInDoubleQuotes)
			 {
				 fInSingleQuotes = !fInSingleQuotes;
				 idx = 0;
			 }
		 }
		 else if (*pFinder == L'\\')
		 {
				// skip over next char
				pFinder++;
		 }
		 else
		 {
			 if (!fInDoubleQuotes && !fInSingleQuotes)
			 {
				 if (*pFinder == i_wszSubStr[idx])
				 {
					 if (idx == 0)
					 {
						 pStart = pFinder;
					 }
					 else if (idx == iSize - 1)
					 {
						 return pStart;
					 }
					 ++idx;
				 }
				 else
				 {
					 idx = 0;
				 }
			 }
		 }
	 }

	 return 0;
}

LPWSTR
CWMIStringUtil::StrToObjectPath (LPCWSTR wszString)
{
	SIZE_T iLen = wcslen (wszString);

	LPWSTR wszNewValue = new WCHAR[iLen+1];
	if (wszNewValue == 0)
	{
		return 0;
	}

	wcscpy (wszNewValue, wszString);

	return wszNewValue;
}

LPWSTR
CWMIStringUtil::AddBackSlashes (LPCWSTR i_wszStr)
{
	ASSERT (i_wszStr != 0);
	SIZE_T iLen = wcslen (i_wszStr);
	LPWSTR wszResult = new WCHAR [2*iLen + 1];
	if (wszResult == 0)
	{
		return 0;
	}

	ULONG jdx = 0;
	for (ULONG idx=0; idx<iLen; ++idx)
	{
		if (i_wszStr[idx] == L'\\')
		{
			wszResult[jdx++] = L'\\';
		}
		wszResult[jdx++] = i_wszStr[idx];
	}

	wszResult[jdx] = L'\0';
	
	return wszResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\webapphelper.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    webapphelper.cpp

$Header: $

Abstract:

Author:
    marcelv 	12/8/2000		Initial Release

Revision History:

--**************************************************************************/

#include "webapphelper.h"
#include "webapplicationinfo.h"
#include "localconstants.h"
#include "smartpointer.h"

//=================================================================================
// Function: CWebAppHelper::CWebAppHelper
//
// Synopsis: Constructor
//=================================================================================
CWebAppHelper::CWebAppHelper ()
{
	m_fInitialized = false;
}

//=================================================================================
// Function: CWebAppHelper::~CWebAppHelper
//
// Synopsis: Destructor
//=================================================================================
CWebAppHelper::~CWebAppHelper ()
{
}

//=================================================================================
// Function: CWebAppHelper::Init
//
// Synopsis: Initializes the webapphelper
//
// Arguments: [i_bstrClass] - class
//            [i_lFlags] - flags
//            [i_pCtx] - context
//            [i_pResponseHandler] - WMI sink
//            [i_pNamespace] - namespace
//=================================================================================
HRESULT
CWebAppHelper::Init (const BSTR i_bstrClass,
					 long i_lFlags,
					 IWbemContext * i_pCtx,
				     IWbemObjectSink  * i_pResponseHandler,
					 IWbemServices * i_pNamespace)
{
	ASSERT (i_bstrClass != 0);
	ASSERT (i_pCtx != 0);
	ASSERT (i_pResponseHandler != 0);
	ASSERT (i_pNamespace != 0);

	HRESULT hr = S_OK;

	bool fIsASPPlusInstalled = false;
	hr = IsASPPlusInstalled (&fIsASPPlusInstalled);
	if (FAILED (hr))
	{
		TRACE (L"IsASPPlusInstalled failed");
		return hr;
	}

	if (!fIsASPPlusInstalled)
	{
		TRACE (L"ASP+ is not installed on this machine, so you cannot get webapps");
		return WBEM_E_PROVIDER_NOT_CAPABLE;
	}

	m_spCtx				= i_pCtx;
	m_spResponseHandler = i_pResponseHandler;
	m_spNamespace		= i_pNamespace;
	m_lFlags			= i_lFlags;

	hr = m_spNamespace->GetObject(i_bstrClass, 
								  0, 
								  m_spCtx, 
								  &m_spClassObject, 
								  0); 
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", (LPWSTR) i_bstrClass);
		return hr;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CWebAppHelper::EnumInstances
//
// Synopsis: Enumerates all the web application instances
//=================================================================================
HRESULT
CWebAppHelper::EnumInstances ()
{
	ASSERT (m_fInitialized);

	HRESULT hr = S_OK;

	CWebAppInfo webAppInfo;

	hr = webAppInfo.Init ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to get web application information");
		return hr;
	}

	ULONG cNrWebApps;
	hr = webAppInfo.GetInstances (&cNrWebApps);
	if (FAILED (hr))
	{
		TRACE (L"webAppInfo::GetInstances failed");
		return hr;
	}

	for (ULONG idx=0; idx < cNrWebApps; ++idx)
	{
		const CWebApplication * pWebApp = webAppInfo.GetWebApp (idx);
		ASSERT (pWebApp != 0);

		// skip the root application
		if (_wcsicmp(pWebApp->GetSelector(), L"iis://localhost/W3SVC/") == 0)
		{
			continue;
		}

		hr = CreateSingleInstance (pWebApp->GetSelector ());
		if (FAILED (hr))
		{
			TRACE (L"CreateSingleInstance failed for WebApplication");
			return hr;
		}
	}

	return hr;
}

//=================================================================================
// Function: CWebAppHelper::CreateSingleInstance
//
// Synopsis: Create a single instance of a web application by using the information
//           in the object path. Note that we don't have to hit the metabase, because
//           all the infromation is part of the object path
//
// Arguments: [i_ObjectPathParser] - object path
//=================================================================================
HRESULT
CWebAppHelper::CreateSingleInstance (LPCWSTR i_wszSelector)
{
	ASSERT (m_fInitialized);

	CWebAppInfo webAppInfo;
	HRESULT hr = webAppInfo.Init ();
	if (FAILED (hr))
	{
		TRACE (L"Init of webAppInfo failed");
		return hr;
	}

	static LPCWSTR wszIISLocalhost = L"iis://localhost";
	static LPCWSTR wszLM = L"/LM";
	static LPCWSTR wszWebConfig = L"web.config";
	static SIZE_T cIISLocalhost = wcslen (wszIISLocalhost);
	static SIZE_T cLM = wcslen (wszLM);
	static SIZE_T cWebConfig = wcslen (wszWebConfig);

	if (_wcsnicmp (i_wszSelector, wszIISLocalhost, cIISLocalhost) != 0)
	{
		TRACE (L"Selector must start with %s (currently %s)", wszIISLocalhost, i_wszSelector);
		return E_ST_INVALIDSELECTOR;
	}

	SIZE_T cLenSelector = wcslen(i_wszSelector);

	// iis selector cannot end with /	
	if (i_wszSelector[cLenSelector -1] == L'/')
	{
		TRACE (L"IIS Selector cannot end with slash: %s", i_wszSelector);
		return E_ST_INVALIDSELECTOR;
	}

	// iis selector cannot contain backslashes
	for (ULONG idx=0; idx < cLenSelector; ++idx)
	{
		if (i_wszSelector[idx] == L'\\')
		{
			TRACE (L"IIS Selector contains backslashes: %s", i_wszSelector);
			return E_ST_INVALIDSELECTOR;
		}
	}

	TSmartPointerArray<WCHAR> saSelector = new WCHAR [cLenSelector - cIISLocalhost + cLM + 2]; // +1 for possible backslash
	if (saSelector == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (saSelector, wszLM);
	wcscpy (saSelector + cLM, i_wszSelector + cIISLocalhost);

	bool fIsWebApp;
	hr = webAppInfo.IsWebApp (saSelector, &fIsWebApp);
	if (FAILED (hr))
	{
		TRACE (L"Unable to figure out if %s is webapp", (LPWSTR) saSelector);
		return hr;
	}

	if (!fIsWebApp)
	{
		TRACE (L"Application is not a webapp");
		return S_OK;
	}

	CWebApplication webApp;
	hr = webAppInfo.GetInfoForPath (saSelector, &webApp);
	if (FAILED (hr))
	{
		TRACE (L"GetInfoForPath failed");
		return hr;
	}

	CComPtr<IWbemClassObject> spNewInst;
	hr = m_spClassObject->SpawnInstance(0, &spNewInst);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class WebApplication");
		return hr;
	}

	_variant_t varSelector = i_wszSelector;
	hr = spNewInst->Put(L"Selector", 0, &varSelector, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%s", L"Selector", i_wszSelector);
		return hr;
	}

	_variant_t varValue = webApp.GetPath ();
	hr = spNewInst->Put(L"Path", 0, &varValue, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%s", L"Path", (LPWSTR)((_bstr_t) varValue));
		return hr;
	}

	_variant_t varFriendlyName = webApp.GetFriendlyName ();
	hr = spNewInst->Put(L"FriendlyName", 0, &varFriendlyName, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%s", L"FriendlyName", (LPWSTR)varFriendlyName.bstrVal);
		return hr;
	}

	_variant_t varIsRootApp = webApp.IsRootApp ();
	hr = spNewInst->Put(L"RootApplication", 0, &varIsRootApp, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%d", L"RootApplication", webApp.IsRootApp ());
		return hr;
	}

	_variant_t varServerComment = webApp.GetServerComment  ();
	hr = spNewInst->Put(L"ServerComment", 0, &varServerComment, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%s", L"ServerComment", webApp.GetServerComment ());
		return hr;
	}

	_variant_t varRelativeName = L"";
	if (!webApp.IsRootApp ())
	{
		SIZE_T cSelectorLen = wcslen (saSelector);
		SIZE_T cOrigLen = cSelectorLen;
		if (saSelector[cSelectorLen - 1] == L'/')
		{
			cSelectorLen--;
		}

		while (cSelectorLen > 0 && saSelector[cSelectorLen -1] != L'/')
		{
			cSelectorLen--;
		}
		TSmartPointerArray<WCHAR> wszRelName = new WCHAR [cOrigLen - cSelectorLen + 1];
		if (wszRelName == 0)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy (wszRelName, saSelector + cSelectorLen);
		if (wszRelName[cOrigLen - cSelectorLen -1] == L'/')
		{
			wszRelName[cOrigLen - cSelectorLen - 1] = L'\0';
		}
		varRelativeName = wszRelName;
	}
	hr = spNewInst->Put(L"RelativeName", 0, &varRelativeName, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%d", L"FriendlyName", (bool)varFriendlyName);
		return hr;
	}

	_bstr_t bstrConfigFilePath = webApp.GetPath ();
	bstrConfigFilePath += wszWebConfig;
	varValue = bstrConfigFilePath;
	hr = spNewInst->Put(L"ConfigurationFilePath", 0, &varValue, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property failed. Property=%s, value=%s", L"ConfigurationFilePath", (LPWSTR)((_bstr_t) varValue));
		return hr;
	}

	IWbemClassObject* pNewInstRaw = spNewInst;
	hr = m_spResponseHandler->Indicate(1,&pNewInstRaw);
	if (FAILED (hr))
	{
		TRACE (L"WMI Indicate failed");
	}

	return hr;
}

HRESULT 
CWebAppHelper::Delete (const CObjectPathParser& i_ObjPathParser)
{
	ASSERT (m_fInitialized);

	HRESULT hr = S_OK;

	CWebAppInfo webAppInfo;
	hr = webAppInfo.Init ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to initialize webapplication info");
		return hr;
	}

	const CWMIProperty * pSelector = i_ObjPathParser.GetPropertyByName (WSZSELECTOR);
	ASSERT (pSelector != 0);
	hr = webAppInfo.DeleteAppRoot (pSelector->GetValue ());
	if (FAILED (hr))
	{
		TRACE (L"Unable to delete instance %s", pSelector->GetValue ());
		return hr;
	}

	return hr;
}

HRESULT 
CWebAppHelper::PutInstance (IWbemClassObject * i_pInstance)
{
	ASSERT (m_fInitialized);
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;

	CWebAppInfo webAppInfo;
	hr = webAppInfo.Init ();
	if (FAILED (hr))
	{
		TRACE (L"Unable to initialize webapplication info");
		return hr;
	}

	_variant_t varSelector;
	hr = i_pInstance->Get(WSZSELECTOR, 0, &varSelector, 0 , 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get selector property");
		return hr;
	}

	_variant_t varPath;
	hr = i_pInstance->Get(L"Path", 0, &varPath, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"You have to specify path when updating");
		return WBEM_E_INVALID_PARAMETER;
	}

	if (varPath.vt == VT_NULL)
	{
		TRACE (L"Empty path specified");
		return E_INVALIDARG;
	}

	_variant_t varFriendlyName;
	hr = i_pInstance->Get(L"FriendlyName", 0, &varFriendlyName, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get FriendlyName parameter");
		return WBEM_E_INVALID_PARAMETER;
	}

	hr = webAppInfo.PutInstanceAppRoot (varSelector.bstrVal, varPath.bstrVal, varFriendlyName.bstrVal);
	if (FAILED (hr))
	{
		TRACE (L"Unable to putinstance %s", varSelector.bstrVal);
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CWebAppHelper::IsASPPlusInstalled
//
// Synopsis: ASP+ is installed if the file %windir%/system32/aspnet_perf.dll exists
//
// Arguments: [pfIsAspPlusInstalled] - 
//            
// Return Value: 
//=================================================================================
HRESULT
CWebAppHelper::IsASPPlusInstalled (bool *pfIsAspPlusInstalled)
{
	ASSERT (pfIsAspPlusInstalled != 0);

	*pfIsAspPlusInstalled = false;

	HRESULT hr = S_OK;

	WCHAR wszASPPlusFile[MAX_PATH];
	DWORD dwSuccess = ExpandEnvironmentStrings (L"%windir%\\system32\\aspnet_perf.dll", wszASPPlusFile, sizeof (wszASPPlusFile) / sizeof(WCHAR));
	if (!dwSuccess)
	{
		TRACE (L"Unable to expand %windir%\\system32\\aspnet_perf.dll");
		return E_INVALIDARG;
	}

	if (GetFileAttributes (wszASPPlusFile) != -1)
	{
		*pfIsAspPlusInstalled = true;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\tlist.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    tlist.h

$Header: $

Abstract:

Author:
    marcelv 	2/16/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __TLIST_H__
#define __TLIST_H__

#pragma once

#include "catmacros.h"

//=================================================================================
// Simple Single Linked List class that allows adding element and iterator through the
// elements of the list. Deleting in the list is not supported. The reason for this class
// is that it is very light-weight.
//=================================================================================

template <class T> 
class TList
{
private:
	struct TLink
	{
		TLink (const T& data) : m_data (data), m_pNext (0) {}
		T		m_data;		// data stored in this link
		TLink * m_pNext;	// pointer to next element in the list
	};

public:
//=================================================================================
// The Iterator class is used to navigate through the elements in the linked list. Call
// List::Begin to get an iterator pointing to the first element in the list, and call
// Next to get the next element in the list. List::End can be used if we are at the end
// of the list
//=================================================================================
	class Iterator
	{
		friend class TList<T>;
	public:
		
		//=================================================================================
		// Function: Next
		//
		// Synopsis: get iterator to next element in the list
		//=================================================================================
		void Next () { ASSERT (m_pLink != 0); m_pLink = m_pLink->m_pNext;}

		//=================================================================================
		// Function: Value
		//
		// Synopsis: Returns value of element that iterator points to
		//=================================================================================
		const T& Value () const { ASSERT (m_pLink != 0); return m_pLink->m_data;}
		
		bool operator== (const Iterator& rhs) const	{return m_pLink == rhs.m_pLink;}
		bool operator!= (const Iterator& rhs) const {return !(*this==rhs);}

	private:
		Iterator (TLink * pLink) : m_pLink (pLink) {} // only list can create these
		TLink * m_pLink;
	};

	//=================================================================================
	// Function: TList
	//
	// Synopsis: Constructor
	//
	// Return Value: 
	//=================================================================================
	TList ()
	{
		m_pHead = 0;
		m_pTail = 0;
		m_cSize = 0;
	}

	//=================================================================================
	// Function: ~TList
	//
	// Synopsis: Destructor. Deletes the elements in the list
	//
	// Return Value: 
	//=================================================================================
	~TList ()
	{
		TLink *pCur = m_pHead;
		while (pCur != 0)
		{
			TLink *pToDelete = pCur;
			pCur = pCur->m_pNext;
			delete pToDelete;
			pToDelete = 0;
		}
	}

	//=================================================================================
	// Function: Size
	//
	// Synopsis: Returns number of elements in the list
	//
	// Return Value: 
	//=================================================================================
	ULONG Size () const
	{
		return m_cSize;
	}

	//=================================================================================
	// Function: Append
	//
	// Synopsis: Appends a new element to the end of the list
	//
	// Arguments: [pData] - new data to be added to the list
	//            
	// Return Value: E_OUTOFMEMORY in case of memory failure, S_OK else
	//=================================================================================
	HRESULT Append (const T&  data)
	{
		TLink * pLink = new TLink (data);
		if (pLink == 0)
		{
			return E_OUTOFMEMORY;
		}

		if (m_pTail != 0)
		{
			ASSERT (m_pHead != 0);
			ASSERT (m_cSize != 0);
			m_pTail->m_pNext = pLink;
			m_pTail = pLink;
		}
		else
		{
			ASSERT (m_pHead == 0);
			ASSERT (m_cSize == 0);
			m_pHead = pLink;
			m_pTail = pLink;
		}

		m_cSize++;

		return S_OK;
	}

	//=================================================================================
	// Function: Begin
	//
	// Synopsis: Returns an iterator to the beginning of the list
	//=================================================================================
	const Iterator Begin () const
	{
		return Iterator (m_pHead);
	}

	//=================================================================================
	// Function: End
	//
	// Synopsis: Returns an iterator one past the end of the list (like STL does)
	//=================================================================================
	const Iterator End () const
	{
		return Iterator (0);
	}

private:
	TLink * m_pHead;	// head of list
	TLink * m_pTail;	// tail of list
	ULONG   m_cSize;    // size of list
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\wmiobjectpathparser.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wmiobjectpathparser.h

$Header: $

Abstract:
	WMI Object Path Parser

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WMIOBJECTPATHPARSER_H__
#define __WMIOBJECTPATHPARSER_H__

#pragma once

//#include <windows.h>
#include "catmacros.h"
#include "localconstants.h"


/**************************************************************************++
Struct Name:
    CWMIProperty

Structure Description:
	Helper structure to store property name and property values together
--*************************************************************************/
struct CWMIProperty
{
	CWMIProperty () 
	{ 
		pName=0; 
		pValue=0;
	}

	~CWMIProperty () 
	{ 
		delete [] pValue;
		pValue=0;
		delete [] pName;
		pName = 0;
	}

	LPWSTR GetName () const
	{
		return pName;
	}

	HRESULT SetName (LPCWSTR wszName)
	{
		ASSERT (wszName != 0);
		ASSERT (pName == 0);
		pName = new WCHAR [wcslen (wszName) + 1];
		if (pName == 0)
		{
			return E_OUTOFMEMORY;
		}
		wcscpy (pName, wszName);

		return S_OK;
	}

	LPWSTR GetValue () const
	{
		return pValue;
	}
		
	HRESULT SetValue (LPCWSTR wszValue)
	{
		ASSERT (wszValue != 0);
		ASSERT (pValue == 0);
		ASSERT (pName != 0);

		SIZE_T	 iLen = wcslen (wszValue);
		pValue = new WCHAR [iLen + 1];
		if (pValue == 0)
		{
			return E_OUTOFMEMORY;
		}

		ULONG iInsertIdx = 0;
		for (ULONG idx=0; idx <iLen; ++idx)
		{
			switch (wszValue[idx])
			{
				// skip backslashes
				case '\\':
					if (wszValue[idx+1] == L'\"' ||
						wszValue[idx+1] == L'\'')
					{
						continue;
					}

					if (wszValue[idx+1] == L'\\')
					{
						// skip on of the backslashes
						idx++;
					}
					break;

		    // ignore quotes and single quotes at beginning and end of string
			case '\"': // fallthrough
			case '\'':
				if (idx==0 || idx==iLen-1)
					continue;
				break;

				default:
					break;
			}
			pValue[iInsertIdx++] = wszValue[idx];
		}

		pValue[iInsertIdx] = L'\0';

		return S_OK;
	}



private:
	// don't allow copies
	CWMIProperty& operator=(const CWMIProperty&); 
	CWMIProperty (const CWMIProperty&);

	LPWSTR pValue;
	LPWSTR pName;
};

/**************************************************************************++
Class Name:
    CObjectPathParser

Class Description:
    Parses a WMI object path.

Constraints:
	Can only be used for single parsing. If you need multiple parsing, use multiple
	CObjectPathParser objects
--*************************************************************************/
class CObjectPathParser
{
public:
	CObjectPathParser ();
	~CObjectPathParser ();

	HRESULT Parse (LPCWSTR wszObjectPath);

	LPCWSTR GetComputer () const;
	LPCWSTR GetNamespace () const;
	LPCWSTR GetClass () const;

	ULONG GetPropCount () const;
	const CWMIProperty * GetProperty (ULONG idx) const;
	const CWMIProperty * GetPropertyByName (LPCWSTR i_wszPropName) const;

private:
	// don't allow copies
	CObjectPathParser (const CObjectPathParser& );
	CObjectPathParser& operator=(const CObjectPathParser& );

	LPWSTR m_wszObjectPath;			// full object path that needs to be parsed
	LPWSTR m_pComputer;				// pointer to computer name
	LPWSTR m_pNamespace;			// pointer to namespace
	LPWSTR m_pClass;				// pointer to classname
	CWMIProperty *m_aWMIProperties; // array of property values
	ULONG m_cNrProps;				// number of properties
	bool m_fParsed;					// Did we do parsing already?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\wqlparser.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wqlparser.h

$Header: $

Abstract:
	WQL parser and WQL Property helper classes

Author:
    marcelv 	11/10/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WQLPARSER_H__
#define __WQLPARSER_H__

#pragma once

#include "catmacros.h"

/**************************************************************************++
Class Name:
    CWQLProperty

Class Description:
    WQL Property helper class. Contains name, value and operator for a single
	WQL condition (i.e. prop1=val1)
--*************************************************************************/
class CWQLProperty
{
public:
	CWQLProperty ();
	~CWQLProperty ();

	LPCWSTR GetValue () const;
	LPCWSTR GetName () const;
	LPCWSTR GetOperator () const;

	HRESULT SetName (LPCWSTR wszName);
	HRESULT SetValue (LPCWSTR wszValue);
	HRESULT SetOperator (LPWSTR wszOperator);
	
private:
	// don't allow copies 
	CWQLProperty& operator=(const CWQLProperty&); 
	CWQLProperty (const CWQLProperty&);

	LPWSTR m_wszValue;		// value
	LPWSTR m_wszName;		// name
	LPWSTR m_wszOperator;	// operator
};

/**************************************************************************++
Class Name:
    CWQLParser

Class Description:
    WQL parser class.
--*************************************************************************/
class CWQLParser
{
public:
	CWQLParser ();
	~CWQLParser ();

	HRESULT Parse (LPCWSTR i_wszQuery);

	LPCWSTR GetClass () const;

	ULONG GetPropCount () const;
	const CWQLProperty * GetProperty (ULONG i_idx) const;
	const CWQLProperty * GetPropertyByName (LPCWSTR i_wszPropName);
private:
	CWQLParser (const CWQLParser& );
	CWQLParser& operator= (const CWQLParser& );

	HRESULT PostValidateQuery ();
	HRESULT ReformatQuery ();
	void RemoveUnwantedProperties ();

	LPWSTR m_wszQuery;				// full query that needs to be parsed
	LPWSTR m_pClass;				// pointer to classname
	CWQLProperty *m_aWQLProperties; // array of property values
	ULONG m_cNrProps;				// number of properties
	bool m_fParsed;					// Did we do parsing already?

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\wmihelper.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wmihelper.cpp

$Header: $

Abstract:
	Some helper functions that are used in several places

Author:
    marcelv 	12/6/2000		Initial Release

Revision History:

--**************************************************************************/

#include "wmihelper.h"
#include "localconstants.h"

//=================================================================================
// Function: CWMIHelper::GetClassInfo
//
// Synopsis: Retrieves database and internal name qualifiers for a particular class
//
// Arguments: [pClassObject] - pointer to valid class object
//            [i_bstrDBName] - database name will be stored in here
//            [i_bstrTableName] - table name will be stored in here
//=================================================================================
HRESULT 
CWMIHelper::GetClassInfo (IWbemClassObject *pClassObject, _bstr_t& i_bstrDBName, _bstr_t& i_bstrTableName)
{
	ASSERT (pClassObject != 0);

	CComPtr<IWbemQualifierSet> spQualifierSet;
	HRESULT hr = pClassObject->GetQualifierSet (&spQualifierSet);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Qualifier set");
		return hr;
	}
		
	_variant_t varDBName;
	_variant_t varInternalName;

	hr = spQualifierSet->Get (WSZDATABASE, 0, &varDBName, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get Database Qualifier");
		return hr;
	}

	hr = spQualifierSet->Get (WSZINTERNALNAME, 0, &varInternalName, 0);
	if (FAILED (hr))
	{
		TRACE(L"Unable to get InternalName Qualifier");
		return hr;
	}

	i_bstrDBName		= varDBName;
	i_bstrTableName		= varInternalName;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\webapplicationinfo.h ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    WebApplicationInfo.h

$Header: $

Abstract:

Author:
    marcelv 	12/8/2000		Initial Release

Revision History:

--**************************************************************************/

#ifndef __WEBAPPLICATIONINFO_H__
#define __WEBAPPLICATIONINFO_H__

#pragma once

#include <iadmw.h>
#include <iiscnfg.h>
#include <iwamreg.h>
#include <atlbase.h>
#include "catmacros.h"

class CWebApplication
{
public:
	CWebApplication ();
	~CWebApplication ();

	LPCWSTR GetSelector () const;
	LPCWSTR GetPath () const;
	LPCWSTR GetRelativeName () const;
	bool    IsRootApp () const;
	LPCWSTR GetFriendlyName () const;
	LPCWSTR GetServerComment () const;

	HRESULT SetSelector (LPCWSTR i_wszSelector);
	HRESULT SetPath (LPCWSTR i_wszPath);
	HRESULT SetFriendlyName (LPCWSTR i_wszFriendlyName);
	HRESULT SetServerComment (LPCWSTR i_wszServerComment);
	void IsRootApp (bool i_fIsRootApp);
private:
	// no copies allowed
	CWebApplication (const CWebApplication& );
	CWebApplication& operator= (const CWebApplication&);
	
	LPWSTR m_wszSelector;		// selector
	LPWSTR m_wszPath;			// virtual directory path
	bool   m_fIsRootApp;		// is the app the rootapp of a server
	LPWSTR m_wszFriendlyName;	// friendly name of application
	LPWSTR m_wszServerComment;  // server comment
};

class CWebAppInfo
{
public:
	CWebAppInfo ();
	~CWebAppInfo ();

	HRESULT Init ();
	HRESULT GetInstances (ULONG* o_pCount);

	const CWebApplication * GetWebApp (ULONG idx) const;
	HRESULT DeleteAppRoot (LPCWSTR i_wszPath);
	HRESULT PutInstanceAppRoot (LPCWSTR i_wszSelector, LPCWSTR i_wszVDIR, LPCWSTR i_wszFriendlyName);
	HRESULT GetInfoForPath (LPWSTR i_wszPath, CWebApplication *io_pWebApp);
	HRESULT IsWebApp (LPCWSTR i_wszMBPath, bool *pfIsWebApp) const;

private:
	bool IsRootApp (LPWSTR i_wszPath) const;

	HRESULT SetVDIR (LPCWSTR i_wszMBPath, LPCWSTR i_wszVDIR);
	HRESULT SetFriendlyName (LPCWSTR i_wszMBPath, LPCWSTR i_wszVDIR);


	CComPtr<IMSAdminBase> m_spAdminBase;
	CWebApplication *     m_aWebApps;
	ULONG				  m_cNrWebApps;
	bool				  m_fInitialized;
	bool				  m_fEnumeratorReady;
	

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\webapplicationinfo.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    WebApplicationInfo.cpp

$Header: $

Abstract:

Author:
    marcelv 	12/8/2000		Initial Release

Revision History:

--**************************************************************************/
#include <wbemidl.h>
#include <objbase.h>
#include <initguid.h>
#include "webapplicationinfo.h"
#include "smartpointer.h"

static LPCWSTR wszWebServerPath = L"iis://localhost/W3SVC";
static SIZE_T cWebServerPath = wcslen (wszWebServerPath);

//=================================================================================
// Function: CWebApplication::CWebApplication
//
// Synopsis: Constructor
//=================================================================================
CWebApplication::CWebApplication ()
{
	m_wszSelector		= 0;
	m_wszPath			= 0;
	m_wszFriendlyName	= 0;
	m_wszServerComment  = 0;
	m_fIsRootApp		= false;
}

//=================================================================================
// Function: CWebApplication::~CWebApplication
//
// Synopsis: Destructor
//=================================================================================
CWebApplication::~CWebApplication ()
{
	delete [] m_wszSelector;
	m_wszSelector = 0;

	delete [] m_wszPath;
	m_wszPath = 0;

	delete [] m_wszFriendlyName;
	m_wszFriendlyName = 0;

	delete [] m_wszServerComment;
	m_wszServerComment = 0;
}

//=================================================================================
// Function: CWebApplication::SetSelector
//
// Synopsis: Sets the selector property. Input is something like /LM/W3SVC/1/ROOT/...
//           We save this as iis://localhost/W3SVC/...
//
// Arguments: [wszSelector] - selector value
//=================================================================================
HRESULT
CWebApplication::SetSelector (LPCWSTR i_wszSelector)
{
	ASSERT (i_wszSelector != 0);
	ASSERT (m_wszSelector == 0);

	static LPCWSTR wszIISLocalHost = L"iis://localhost";
	static const SIZE_T cIISLocalHost = wcslen (wszIISLocalHost);

	m_wszSelector = new WCHAR [wcslen (i_wszSelector) + cIISLocalHost + 1];
	if (m_wszSelector == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszSelector, wszIISLocalHost);
	wcscpy (m_wszSelector + cIISLocalHost, i_wszSelector + 3); // skip /LM

	SIZE_T cLenSelector = wcslen (m_wszSelector);
	if (m_wszSelector[cLenSelector-1] == L'/')
	{
		m_wszSelector[cLenSelector-1] = L'\0';
	}

	return S_OK;
}

//=================================================================================
// Function: CWebApplication::SetPath
//
// Synopsis: Set the application path. Add a slash to the end in case it does not exist
//
// Arguments: [wszPath] - value to set path to
//=================================================================================
HRESULT
CWebApplication::SetPath (LPCWSTR i_wszPath)
{
	ASSERT (i_wszPath != 0);
	ASSERT (m_wszPath == 0);
	
	SIZE_T iLen = wcslen(i_wszPath);
	if ((iLen == 0) || (i_wszPath[iLen-1] != L'\\'))
	{
		iLen++;
	}

	m_wszPath = new WCHAR[iLen + 1];
	if (m_wszPath == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszPath, i_wszPath);

	if (m_wszPath[iLen -1] != L'\\')
	{
		ASSERT (m_wszPath[iLen-1] == L'\0');
		m_wszPath [iLen - 1] = L'\\';
		m_wszPath [iLen] = L'\0';
	}

	return S_OK;
}

//=================================================================================
// Function: CWebApplication::SetFriendlyName
//
// Synopsis: Sets the friendly name of the web application
//
// Arguments: [i_wszFriendlyName] - friendly name
//=================================================================================
HRESULT
CWebApplication::SetFriendlyName (LPCWSTR i_wszFriendlyName)
{
	ASSERT (i_wszFriendlyName != 0);
	ASSERT (m_wszFriendlyName == 0);

	m_wszFriendlyName = new WCHAR[wcslen(i_wszFriendlyName) + 1];
	if (m_wszFriendlyName == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszFriendlyName, i_wszFriendlyName);

	return S_OK;
}

//=================================================================================
// Function: CWebApplication::SetServerComment
//
// Synopsis: Sets the server comments
//
// Arguments: [i_wszServerComment] - server comment value
//=================================================================================
HRESULT
CWebApplication::SetServerComment (LPCWSTR i_wszServerComment)
{
	ASSERT (i_wszServerComment != 0);
	ASSERT (m_wszServerComment == 0);

	m_wszServerComment = new WCHAR [wcslen(i_wszServerComment) + 1];
	if (m_wszServerComment == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszServerComment, i_wszServerComment);
	
	return S_OK;
}

//=================================================================================
// Function: CWebApplication::IsSite
//
// Synopsis: indicate if webapp is site or not
//
// Arguments: [i_fIsRootApp] - is rootapp?
//=================================================================================
void
CWebApplication::IsRootApp  (bool i_fIsRootApp)
{
	m_fIsRootApp = i_fIsRootApp;
}

//=================================================================================
// Function: CWebApplication::GetPath
//
// Synopsis: Get's the path (vdir) for web application
//=================================================================================
LPCWSTR
CWebApplication::GetPath () const
{
	ASSERT (m_wszPath != 0);
	return m_wszPath;
}

//=================================================================================
// Function: CWebApplication::GetSelector
//
// Synopsis: Gets the selector for a web applciation
//=================================================================================
LPCWSTR
CWebApplication::GetSelector () const
{
	ASSERT (m_wszSelector != 0);
	return m_wszSelector;
}

//=================================================================================
// Function: CWebApplication::GetFriendlyName
//
// Synopsis: Gets the friendly name for a web application
//=================================================================================
LPCWSTR
CWebApplication::GetFriendlyName () const
{
	ASSERT (m_wszFriendlyName != 0);
	return m_wszFriendlyName;
}

//=================================================================================
// Function: CWebApplication::GetServerComment
//
// Synopsis: Gets the server comment for a web application
//=================================================================================
LPCWSTR
CWebApplication::GetServerComment () const
{
	ASSERT (m_wszServerComment != 0);
	return m_wszServerComment;
}

//=================================================================================
// Function: CWebApplication::IsSite
//
// Synopsis: is a webapp a site or not?
//=================================================================================
bool
CWebApplication::IsRootApp () const
{
	return m_fIsRootApp;
}

//=================================================================================
// Function: CWebAppInfo::CWebAppInfo
//
// Synopsis: Constructor. CWebAppInfo contains array of web applications
//=================================================================================
CWebAppInfo::CWebAppInfo ()
{
	m_aWebApps			= 0;
	m_fInitialized		= false;
	m_fEnumeratorReady	= false;
}

//=================================================================================
// Function: CWebAppInfo::~CWebAppInfo
//
// Synopsis: Default destructor
//=================================================================================
CWebAppInfo::~CWebAppInfo ()
{
	delete [] m_aWebApps;
	m_aWebApps = 0;
}

//=================================================================================
// Function: CWebAppInfo::Init
//
// Synopsis: Initializes thie IMSAdminBase object
//=================================================================================
HRESULT 
CWebAppInfo::Init ()
{
	HRESULT hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_ALL, 
				  IID_IMSAdminBase, (void **) &m_spAdminBase);
	if (FAILED (hr))
	{
		TRACE (L"CoCreateInstance failed for CLSID_MSAdminBase, interface IID_IMSAdminBase");
		return hr;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CWebAppInfo::GetInstances
//
// Synopsis: Retrieve all appRoot elements from the metabase. It simply recurses
//           through the metabase looking for AppRoot keys. For each key (except the
//           main root), it will ask for the VDIR
//
// Arguments: [o_pCount] - 
//            
// Return Value: 
//=================================================================================
HRESULT
CWebAppInfo::GetInstances (ULONG* o_pCount)
{
	ASSERT (o_pCount != 0);
	*o_pCount = 0;

	WCHAR wszBuffer[1024];
	LPWSTR pBuffer = wszBuffer;
	DWORD dwRequiredSize;
	TSmartPointerArray<WCHAR> pAutoDelBuffer;

	HRESULT hr = S_OK;

	hr = m_spAdminBase->GetDataPaths (METADATA_MASTER_ROOT_HANDLE,
									 L"/LM/W3SVC",
									 MD_APP_ROOT,
									 ALL_METADATA,
									 sizeof (wszBuffer)/sizeof(WCHAR),
									 wszBuffer,
									 &dwRequiredSize);
	
	if (hr == HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER))
	{
		pAutoDelBuffer = new WCHAR[dwRequiredSize + 1];
		if (pAutoDelBuffer == 0)
		{
			return E_OUTOFMEMORY;
		}
		pBuffer = pAutoDelBuffer;

		hr = m_spAdminBase->GetDataPaths (METADATA_MASTER_ROOT_HANDLE,
								 L"/LM/W3SVC",
								 MD_APP_ROOT,
								 ALL_METADATA,
								 dwRequiredSize,
								 pBuffer,
								 &dwRequiredSize);
	}
	
	if (FAILED (hr))
	{
		TRACE (L"Unable to get metabase datapaths");
		return hr;
	}

	// count number of strings that we found (we have multistring)
	m_cNrWebApps = 0;
	for (LPWSTR pTmpBuf = pBuffer; *pTmpBuf != L'\0'; pTmpBuf += wcslen (pTmpBuf) + 1)
	{
		m_cNrWebApps++;
	}

	if (m_cNrWebApps == 0)
	{
		return S_OK;
	}

	m_aWebApps = new CWebApplication[m_cNrWebApps];
	if (m_aWebApps == 0)
	{
		return E_OUTOFMEMORY;
	}

	ULONG idx = 0;
	for (pTmpBuf = pBuffer; *pTmpBuf != L'\0'; pTmpBuf += wcslen (pTmpBuf) + 1)
	{
		  // skip the root element
		 if (_wcsicmp (pTmpBuf, L"/LM/W3SVC/") != 0)
		 {
			 m_aWebApps[idx].SetSelector (pTmpBuf);
			 idx++;
		 }
		 else
		 {
			 m_cNrWebApps--;
		 }
	}

	*o_pCount = m_cNrWebApps;
	m_fEnumeratorReady = true;

	return S_OK;
}


HRESULT
CWebAppInfo::GetInfoForPath (LPWSTR i_wszPath, CWebApplication *io_pWebApp)
{
	ASSERT (i_wszPath != 0);
	ASSERT (io_pWebApp != 0);
	ASSERT (m_fInitialized);

	DWORD dwRealSize;

	// get the virtual directory
	WCHAR wszVDIR[256];
	DWORD dwVDIRSize = sizeof (wszVDIR);

	METADATA_RECORD vdirRec;
	vdirRec.dwMDIdentifier	= MD_VR_PATH;
	vdirRec.dwMDDataLen		= dwVDIRSize;
	vdirRec.pbMDData		= (BYTE *)wszVDIR;
	vdirRec.dwMDAttributes	= METADATA_INHERIT;
	vdirRec.dwMDDataType	= STRING_METADATA;

	HRESULT hr = m_spAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, i_wszPath, &vdirRec, &dwRealSize);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get VDIR for %s", i_wszPath);
		return hr;
	}

	// are we a server or not
	bool fIsRootApp = IsRootApp (i_wszPath);

	WCHAR wszFriendlyName[256];
	ULONG dwFriendlyNameSize = sizeof (wszFriendlyName);

	METADATA_RECORD commentRec;

	if (fIsRootApp)
	{
		commentRec.dwMDIdentifier	= MD_SERVER_COMMENT;
	}
	else
	{
		commentRec.dwMDIdentifier	= MD_APP_FRIENDLY_NAME;
	}

	commentRec.dwMDDataLen		= dwFriendlyNameSize;
	commentRec.pbMDData			= (BYTE *)wszFriendlyName;
	commentRec.dwMDAttributes	= METADATA_INHERIT;
	commentRec.dwMDDataType		= STRING_METADATA;

	hr = m_spAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, i_wszPath, &commentRec, &dwRealSize);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get friendly name for %s", i_wszPath);
		return hr;
	}

	WCHAR wszServerComment[256];
	ULONG dwLenServerComment = sizeof (wszServerComment);
	METADATA_RECORD serverCommentRec;
	
	serverCommentRec.dwMDIdentifier	= MD_SERVER_COMMENT;
	serverCommentRec.dwMDDataLen	= dwLenServerComment;
	serverCommentRec.pbMDData		= (BYTE *)wszServerComment;
	serverCommentRec.dwMDAttributes	= METADATA_INHERIT;
	serverCommentRec.dwMDDataType	= STRING_METADATA;

	hr = m_spAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, i_wszPath, &serverCommentRec, &dwRealSize);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get servercomment for %s", i_wszPath);
		return hr;
	}


	hr = io_pWebApp->SetPath (wszVDIR);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set VDIR for path %s", i_wszPath);
		return hr;
	}

	hr = io_pWebApp->SetFriendlyName (wszFriendlyName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set Friendly name for %s", i_wszPath);
		return hr;
	}

	hr = io_pWebApp->SetServerComment (wszServerComment);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set servercomment for %s", i_wszPath);
		return hr;
	}

	io_pWebApp->IsRootApp (fIsRootApp);
	
	return hr;
}


//=================================================================================
// Function: CWebAppInfo::GetWebApp
//
// Synopsis: Get info about web application at index idx
//
// Arguments: [idx] - idx of web application that we're interested in
//=================================================================================
const CWebApplication * 
CWebAppInfo::GetWebApp (ULONG idx) const
{
	ASSERT (idx >= 0 && idx < m_cNrWebApps);
	ASSERT (m_fInitialized);
	ASSERT (m_fEnumeratorReady);

	return m_aWebApps + idx;
}

HRESULT 
CWebAppInfo::PutInstanceAppRoot (LPCWSTR i_wszSelector, 
								 LPCWSTR i_wszVDIR,
								 LPCWSTR i_wszFriendlyName)
{
	ASSERT (i_wszSelector != 0);
	ASSERT (i_wszVDIR != 0);
	// i_wszFriendlyName can be 0

	HRESULT hr = S_OK;

	if (_wcsnicmp (i_wszSelector, wszWebServerPath, cWebServerPath) != 0)
	{
		TRACE (L"Web Server Path doesn't start with %s", wszWebServerPath);
		return E_INVALIDARG;
	}

	// i_wszVDIR must exist
	if (GetFileAttributes (i_wszVDIR) == -1)
	{
		TRACE (L"Directory %s does not exist", i_wszVDIR);
		return HRESULT_FROM_WIN32(GetLastError());
	}

	// make copy
	TSmartPointerArray<WCHAR> wszMBPath = new WCHAR [wcslen (i_wszSelector) + 1];
	if (wszMBPath == 0)
	{
		return E_OUTOFMEMORY;
	}

	wcscpy (wszMBPath, L"/LM/W3SVC");
	wcscat (wszMBPath, i_wszSelector + cWebServerPath);

	CComPtr<IWamAdmin> spAdmin;
	hr = CoCreateInstance(CLSID_WamAdmin, NULL, CLSCTX_ALL, 
						  IID_IWamAdmin, (void **) &spAdmin);
	if (FAILED (hr))
	{
		TRACE (L"CoCreateInstance failed for CLSID_WAMAdmin, interface IID_IWamAdmin");
		return hr;
	}

	hr = spAdmin->AppCreate (wszMBPath, TRUE);
	if (FAILED (hr))
	{
		TRACE (L"AppCreate failed for path %s", wszMBPath);
		return hr;
	}

	hr = SetVDIR (wszMBPath, i_wszVDIR);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set VDIR for %s", wszMBPath);
		return hr;
	}

	// set friendly name if specified
	if (i_wszFriendlyName != 0)
	{
		hr = SetFriendlyName (wszMBPath, i_wszFriendlyName);
		if (FAILED (hr))
		{
			TRACE (L"Unable to set Friendly name for %s", wszMBPath);
			return hr;
		}
	}

	return hr;
}

HRESULT
CWebAppInfo::SetVDIR (LPCWSTR i_wszMBPath, LPCWSTR i_wszVDIR)
{
	ASSERT (i_wszMBPath != 0);
	ASSERT (i_wszVDIR != 0);

	// set the VDIR property

	HRESULT hr = S_OK;

	METADATA_HANDLE hKey;
	hr = m_spAdminBase->OpenKey (METADATA_MASTER_ROOT_HANDLE, 
								 i_wszMBPath, 
								 METADATA_PERMISSION_WRITE,
								 1000,
								 &hKey);
	if (FAILED (hr))
	{
		TRACE (L"OpenKey failed for %s", i_wszMBPath);
		return hr;
	}
																	
	METADATA_RECORD vdirRec;
	vdirRec.dwMDIdentifier	= MD_VR_PATH;
	vdirRec.dwMDDataLen		= (ULONG)(wcslen(i_wszVDIR) + 1) * sizeof(WCHAR);
	vdirRec.pbMDData		= (BYTE *)i_wszVDIR;
	vdirRec.dwMDAttributes	= METADATA_INHERIT;
	vdirRec.dwMDDataType	= STRING_METADATA;

	hr = m_spAdminBase->SetData (hKey, L"", &vdirRec);

	m_spAdminBase->CloseKey (hKey);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set VDIR for %s", i_wszMBPath);
		return hr;
	}

	return hr;
}

HRESULT
CWebAppInfo::SetFriendlyName (LPCWSTR i_wszMBPath, LPCWSTR i_wszFriendlyName)
{
	ASSERT (i_wszMBPath != 0);
	ASSERT (i_wszFriendlyName != 0);
		
	HRESULT hr = S_OK;
	bool fIsRootApp = IsRootApp ((LPWSTR)i_wszMBPath);

	METADATA_HANDLE hKey;
	hr = m_spAdminBase->OpenKey (METADATA_MASTER_ROOT_HANDLE, 
								 i_wszMBPath, 
								 METADATA_PERMISSION_WRITE,
								 1000,
								 &hKey);
	if (FAILED (hr))
	{
		TRACE (L"OpenKey failed for %s", i_wszMBPath);
		return hr;
	}
																	
	METADATA_RECORD vdirRec;
	vdirRec.dwMDIdentifier	= (fIsRootApp? MD_SERVER_COMMENT:MD_APP_FRIENDLY_NAME);
	vdirRec.dwMDDataLen		= (DWORD) ((wcslen(i_wszFriendlyName) + 1) * sizeof(WCHAR));
	vdirRec.pbMDData		= (BYTE *)i_wszFriendlyName;
	vdirRec.dwMDAttributes	= METADATA_INHERIT;
	vdirRec.dwMDDataType	= STRING_METADATA;

	hr = m_spAdminBase->SetData (hKey, L"", &vdirRec);

	m_spAdminBase->CloseKey (hKey);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set FriendlyName for %s", i_wszMBPath);
		return hr;
	}

	return hr;
}

//=================================================================================
// Function: CWebAppInfo::DeleteAppRoot
//
// Synopsis: Deletes approot property for i_wszPath, but only when i_wszPath is
//           a valid MB path, and the path does not point to an IIsWebServer
//
// Arguments: [i_wszPath] - path of format iis://localhost/W3SVC/....
//=================================================================================
HRESULT 
CWebAppInfo::DeleteAppRoot (LPCWSTR i_wszPath)
{
	ASSERT (i_wszPath != 0);

	HRESULT hr = S_OK;

	if (_wcsnicmp (i_wszPath, wszWebServerPath, cWebServerPath) != 0)
	{
		TRACE (L"Web Server Path doesn't start with %s", wszWebServerPath);
		return E_INVALIDARG;
	}

	// make copy
	TSmartPointerArray<WCHAR> wszMBPath = new WCHAR [wcslen (i_wszPath) + 1];
	if (wszMBPath == 0)
	{
		return E_OUTOFMEMORY;
	}

	wcscpy (wszMBPath, L"/LM/W3SVC");
	wcscat (wszMBPath, i_wszPath + cWebServerPath);

	// change path to /LM something

	if (IsRootApp (wszMBPath))
	{
		TRACE (L"Cannot Delete AppRoot property for IIsWebServer");
		return WBEM_E_INVALID_OPERATION;
	}

	CComPtr<IWamAdmin> spAdmin;
	hr = CoCreateInstance(CLSID_WamAdmin, NULL, CLSCTX_ALL, 
						  IID_IWamAdmin, (void **) &spAdmin);
	if (FAILED (hr))
	{
		TRACE (L"CoCreateInstance failed for CLSID_WAMAdmin, interface IID_IWamAdmin");
		return hr;
	}

	hr = spAdmin->AppDelete (wszMBPath, TRUE);
	if (FAILED (hr))
	{
		TRACE (L"AppDelete failed for path %s", wszMBPath);
		return hr;
	}

	return hr;
}

bool
CWebAppInfo::IsRootApp (LPWSTR i_wszPath) const
{
	bool fIsRootApp = false;
	static LPCWSTR wszRoot = L"Root";
	static SIZE_T cLenRoot = wcslen (wszRoot);

	SIZE_T cLenPath = wcslen (i_wszPath);

	if (_wcsicmp (i_wszPath + cLenPath - cLenRoot, wszRoot) == 0)
	{
		WCHAR wszKeyType[256]= L"";
		DWORD dwKeyTypeSize = sizeof (wszKeyType);
		DWORD dwRealSize;

		i_wszPath[cLenPath - cLenRoot - 1] = L'\0';
		METADATA_RECORD siteRec;
		siteRec.dwMDIdentifier  = MD_KEY_TYPE;
		siteRec.dwMDDataLen		= dwKeyTypeSize;
		siteRec.pbMDData		= (BYTE *)wszKeyType;
		siteRec.dwMDAttributes	= METADATA_INHERIT;
		siteRec.dwMDDataType	= STRING_METADATA;

		HRESULT hr = m_spAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, i_wszPath, &siteRec, &dwRealSize);
		if (FAILED (hr))
		{
			TRACE (L"GetData failed for MD_KEY_TYPE for path %s", i_wszPath);
		}
		i_wszPath[cLenPath - cLenRoot -1] = L'/';

		if (_wcsicmp (wszKeyType, L"IIsWebServer") == 0)
		{
			fIsRootApp = true;
		}
	}

	return fIsRootApp;
}

HRESULT 
CWebAppInfo::IsWebApp (LPCWSTR i_wszMBPath, bool *pfIsWebApp) const
{
	ASSERT (m_fInitialized);
	ASSERT (i_wszMBPath != 0);
	ASSERT (pfIsWebApp != 0);

	DWORD dwRealSize;
	WCHAR wszType[256] = L"";

	*pfIsWebApp = false;

	METADATA_RECORD resRec;

	resRec.dwMDIdentifier	= MD_APP_ROOT;
	resRec.dwMDDataLen		= sizeof (wszType);
	resRec.pbMDData			= (BYTE *)wszType;
	resRec.dwMDAttributes	= METADATA_NO_ATTRIBUTES;
	resRec.dwMDDataType		= STRING_METADATA;

	HRESULT hr = m_spAdminBase->GetData (METADATA_MASTER_ROOT_HANDLE, i_wszMBPath, &resRec, &dwRealSize);
	if (SUCCEEDED (hr))
	{
		*pfIsWebApp = true;
	}
	else if (hr == HRESULT_FROM_WIN32(MD_ERROR_DATA_NOT_FOUND))
	{
		hr = S_OK;
	}
	
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\wmiobjectpathparser.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wmiobjectpathparser.cpp

$Header: $

Abstract:
	WMI Object Path Parser

Author:
    marcelv 	11/9/2000		Initial Release

Revision History:

--**************************************************************************/

#include "wmiobjectpathparser.h"
#include "stringutil.h"
#include "localconstants.h"

//=================================================================================
// Function: CObjectPathParser::CObjectPathParser
//
// Synopsis: Default constructor. Initiliazes all local variables
//=================================================================================
CObjectPathParser::CObjectPathParser ()
{
	m_pComputer			= 0;
	m_pNamespace		= 0;
	m_pClass			= 0;
	m_aWMIProperties	= 0;
	m_cNrProps			= 0;
	m_fParsed			= false;
	m_wszObjectPath		= 0;
}

//=================================================================================
// Function: CObjectPathParser::~CObjectPathParser
//
// Synopsis: Default Destructor
//=================================================================================
CObjectPathParser::~CObjectPathParser ()
{
	delete [] m_wszObjectPath;
	m_wszObjectPath = 0;

	delete [] m_aWMIProperties;
	m_aWMIProperties	= 0;
}

//=================================================================================
// Function: CObjectPathParser::Parse
//
// Synopsis: Parser a WMI Object path. The format of the path is
//           \\computer\namespace:class.prop1="val1",prop2="val2",prop3="val3"
//
// Arguments: [wszObjectPath] - Object path to be parsed
//            
// Return Value: S_OK if everything went ok, non-S_OK if error occurred.
//=================================================================================
HRESULT
CObjectPathParser::Parse (LPCWSTR wszObjectPath)
{
	ASSERT (wszObjectPath != 0);
	ASSERT (!m_fParsed)
	ASSERT (m_pComputer == 0);
	ASSERT (m_pNamespace == 0);
	ASSERT (m_pClass == 0);
	ASSERT (m_aWMIProperties == 0);

	HRESULT hr = S_OK;

	// copy to private variable so that we can change the string (i.e. replace certain characters
	// with null-terminators
	m_wszObjectPath = CWMIStringUtil::StrToLower (wszObjectPath);
	if (m_wszObjectPath == 0)
	{
		return E_OUTOFMEMORY;
	}

	// find the colon to see if we have computer/namespace information. If no colon is found, we
	// do not have computer and namespace information, and immediately know where the class name
	// starts

	WCHAR *pColon = CWMIStringUtil::FindChar(m_wszObjectPath, L":");
	if (pColon != 0)
	{
		// we have computer namespace information. See if there is a computer name by searching for
		// \\compname.
		m_pClass = pColon + 1;
		*pColon = L'\0';

		if (m_wszObjectPath[0] == '\\' && m_wszObjectPath[1] == '\\')
		{
			m_pComputer = m_wszObjectPath + 2; // skip over '\\'

			WCHAR * pNSSlash = wcschr (m_pComputer, L'\\');
			if (pNSSlash != 0)
			{
				*pNSSlash = L'\0';
				m_pNamespace = pNSSlash + 1;
			}
		}
		else
		{
			// no computer info found, so everything is the namespace
			m_pNamespace = m_wszObjectPath;
		}
	}
	else
	{
		// don't have computer and namespace
		m_pClass = m_wszObjectPath;
	}
		
	WCHAR *pDot = CWMIStringUtil::FindChar (m_pClass, L".");
	if (pDot != 0)
	{
		// we found a dot, so we have properties. Count the number of properties so that we
		// can allocate enough memory by counting the number of comma's
		*pDot = '\0';
		m_cNrProps = 1;
		WCHAR *pPropStart = pDot + 1;

		// find number of , not inclosed in Brackets
		for (LPWSTR pFinder = CWMIStringUtil::FindChar (pPropStart, L","); 
			 pFinder != 0;
			 pFinder = CWMIStringUtil::FindChar (pFinder + 1, L","))
			 {
				 m_cNrProps++;
			 }

		ASSERT (m_cNrProps > 0);
		m_aWMIProperties = new CWMIProperty[m_cNrProps];
		if (m_aWMIProperties == 0)
		{
			return E_OUTOFMEMORY;
		}

		// each property is of format name="value". So search for equals sign to find the
		// place where name ends and value starts, and find comma's to find the end of the 
		// property information
		for (ULONG iPropIdx = 0; iPropIdx < m_cNrProps; ++iPropIdx)
		{
			pFinder = CWMIStringUtil::FindChar (pPropStart, L",");
			if (pFinder != 0)
			{
				// replace comma with end of string char
				*pFinder = '\0';
			}
			
			LPWSTR pEqualStart = CWMIStringUtil::FindChar (pPropStart, L"=");
			ASSERT (pEqualStart != 0);
			*pEqualStart  = L'\0';

			hr = m_aWMIProperties[iPropIdx].SetName (pPropStart);
			if (FAILED (hr))
			{
				TRACE (L"Unable to set property name");
				return hr;
			}

			hr = m_aWMIProperties[iPropIdx].SetValue (pEqualStart+ 1);
			if (FAILED (hr))
			{
				TRACE (L"Unable to set property value");
				return hr;
			}
			pPropStart = pFinder + 1;
		}
	}

	// we need to check for the case CLASS="Value". If we have this case, we have
	// a class with a single primary key. Because SELECTOR is always part of the
	// primary key, the only key will be set as the SELECTOR property
	LPWSTR pEqualSign = CWMIStringUtil::FindChar (m_pClass, L"=");
	if (pEqualSign != 0)
	{
		*pEqualSign = L'\0';
		// we have one key property, the selector
		m_aWMIProperties = new CWMIProperty[1];
		if (m_aWMIProperties == 0)
		{
			return E_OUTOFMEMORY;
		}

		hr = m_aWMIProperties[0].SetName (WSZSELECTOR);
		if (FAILED (hr))
		{
			TRACE (L"Unable to set property name");
			return hr;
		}

		hr = m_aWMIProperties[0].SetValue (pEqualSign + 1);
		if (FAILED (hr))
		{
			TRACE (L"Unable to set property value");
			return hr;
		}
	}
	

	// we need to have valid class name here
	ASSERT (m_pClass != 0);

	m_fParsed = true;

	return hr;
}

//=================================================================================
// Function: CObjectPathParser::GetComputer
//
// Synopsis: Returns the name of the computer in the object path string, or empty string
//           if computer was not found
//=================================================================================
LPCWSTR
CObjectPathParser::GetComputer () const
{
	ASSERT (m_fParsed);

	if (m_pComputer == 0)
	{
		return L"";
	}
	else
	{
		return m_pComputer;
	}
}

//=================================================================================
// Function: CObjectPathParser::GetNamespace
//
// Synopsis: Return namespace name in the object path string of empty string if nothing found
//=================================================================================
LPCWSTR
CObjectPathParser::GetNamespace () const
{
	ASSERT (m_fParsed);

	if (m_pNamespace == 0)
	{
		return L"";
	}
	else
	{
		return m_pNamespace;
	}
}

//=================================================================================
// Function: CObjectPathParser::GetClass
//
// Synopsis: returns the name of the class in the object path string
//=================================================================================
LPCWSTR
CObjectPathParser::GetClass () const
{
	ASSERT (m_fParsed);
	ASSERT (m_pClass != 0);

	return m_pClass;
}

//=================================================================================
// Function: CObjectPathParser::GetPropCount
//
// Synopsis: returns number of properties in the object path string
//=================================================================================
ULONG
CObjectPathParser::GetPropCount () const
{
	ASSERT (m_fParsed);

	return m_cNrProps;
}

//=================================================================================
// Function: CObjectPathParser::GetProperty
//
// Synopsis: returns a property from the object path string
//
// Arguments: [idx] - index of property that we want to have information for. needs to
//                    be in between 0 and GetPropCount() -1
//=================================================================================
const CWMIProperty *
CObjectPathParser::GetProperty (ULONG idx) const
{
	ASSERT (m_fParsed);
	ASSERT (m_aWMIProperties != 0);
	ASSERT (idx >= 0 && idx < m_cNrProps);

	return &m_aWMIProperties[idx];
}

//=================================================================================
// Function: CObjectPathParser::GetPropertyByName
//
// Synopsis: Find a property by name. 
//
// Arguments: [i_wszPropName] - property name to search for
//            [io_Property] - property values will be filled out here
//            
// Return Value: true, property found, false: property not found
//=================================================================================
const CWMIProperty *
CObjectPathParser::GetPropertyByName (LPCWSTR i_wszPropName) const
{
	ASSERT (m_fParsed);
	ASSERT (i_wszPropName != 0);

	for (ULONG idx=0; idx<m_cNrProps; ++idx)
	{
		if (_wcsicmp(m_aWMIProperties[idx].GetName (), i_wszPropName) == 0)
		{
			return &m_aWMIProperties[idx];
			break;
		}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\xmlcfgcodegroup.cpp ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    codegroup.cpp

$Header: $

Abstract:

Author:
    marcelv 	2/15/2001		Initial Release

Revision History:

--**************************************************************************/

#include "XMLCfgCodegroup.h"
#include "XMLCfgIMembershipCondition.h"
#include "localconstants.h"
#include "cfgrecord.h"

#include <comdef.h>
#include <windows.h>
#include <atlbase.h>

static _bstr_t bstrAttrClass				= L"class";
static _bstr_t bstrAttrVersion				= L"version";
static _bstr_t bstrAttrPermissionSetName	= L"PermissionSetName";
static _bstr_t bstrPolicyVersion            = L"PolicyVersion";
static _bstr_t bstrAttributes				= L"Attributes";

static LPCWSTR wszChildren		= L"children";
static LPCWSTR wszMembership	= L"membership";

static LPCWSTR wszClassName     = L"className";

static LPCWSTR wszAttributesExclusive	= L"Exclusive";
static LPCWSTR wszAttributesLevelFinal	= L"LevelFinal";
static LPCWSTR wszAttributesExclLevelFinal = L"Exclusive,LevelFinal";

CXMLCfgCodeGroups::CXMLCfgCodeGroups ()
{
	m_pwszSelector = 0;
	m_fInitialized = false;
}

CXMLCfgCodeGroups::~CXMLCfgCodeGroups ()
{
	for (TList<CXMLCfgCodeGroups *>::Iterator pChildCodeGroup = m_codegroupChildren.Begin ();
		 pChildCodeGroup != m_codegroupChildren.End();
		 pChildCodeGroup.Next ())
		{
			 delete pChildCodeGroup.Value();
		}

	for (TList<CXMLCfgIMembershipCondition *>::Iterator pMemberChild = m_membershipChildren.Begin ();
		 pMemberChild != m_membershipChildren.End();
		 pMemberChild.Next ())
		{
			 delete pMemberChild.Value();
		}
}

HRESULT 
CXMLCfgCodeGroups::Init (IWbemContext *i_pCtx, IWbemServices* i_pNamespace)
{
	ASSERT (i_pCtx != 0);
	ASSERT (i_pNamespace != 0);

	m_spCtx = i_pCtx;
	m_spNamespace = i_pNamespace;

	HRESULT hr = m_spNamespace->GetObject((LPWSTR)WSZCODEGROUP, 
										0, 
										m_spCtx, 
										&m_spClassObject, 
										0); 
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", WSZCODEGROUP);
		return hr;
	}

	m_fInitialized = true;

	return S_OK;
}

HRESULT
CXMLCfgCodeGroups::GetAttributes (IXMLDOMElement *pElement)
{
	ASSERT (pElement != 0);

	HRESULT hr = pElement->getAttribute (bstrAttrClass, &m_varClass);
	if (FAILED (hr))
	{
		TRACE (L"getAttribute failed for %s of %s", (LPWSTR) bstrAttrClass, WSZCODEGROUP);
		return hr;
	}

	hr = pElement->getAttribute (bstrAttrPermissionSetName, &m_varPermissionSetName);
	if (FAILED (hr))
	{
		TRACE (L"getAttribute failed for %s of %s", (LPWSTR) bstrAttrPermissionSetName, WSZCODEGROUP);
		return hr;
	}

	hr = pElement->getAttribute (bstrAttrVersion, &m_varVersion);
	if (FAILED (hr))
	{
		TRACE (L"getAttribute failed for %s of %s", (LPWSTR) bstrAttrVersion, WSZCODEGROUP);
		return hr;
	}

	hr = pElement->getAttribute (bstrAttributes, &m_varAttributes);
	if (FAILED (hr))
	{
		TRACE (L"getAttribute failed for %s of %s", (LPWSTR) bstrAttributes, WSZCODEGROUP);
		return hr;
	}

	if (m_varAttributes.bstrVal != 0)
	{
		if (wcscmp (m_varAttributes.bstrVal, wszAttributesExclusive) == 0)
		{
			m_varAttributes = 1L;
		}
		else if (wcscmp (m_varAttributes.bstrVal, wszAttributesLevelFinal) == 0)
		{
			m_varAttributes = 2L;
		}
		else if (wcscmp (m_varAttributes.bstrVal, wszAttributesExclLevelFinal) == 0)
		{
			m_varAttributes = 3L;
		}
		else
		{
			TRACE (L"Unknown value for attributes attribute of codegroup: %s", m_varAttributes.bstrVal);
			return E_SDTXML_INVALID_ENUM_OR_FLAG;
		}
	}

	return hr;
}

HRESULT
CXMLCfgCodeGroups::GetChildren (IXMLDOMElement *pElement)
{
	ASSERT (pElement != 0);

	CComPtr<IXMLDOMNodeList> spChildren;
	HRESULT hr = pElement->get_childNodes (&spChildren);
	if (FAILED (hr))
	{
		TRACE (L"get_childNodes failed in CXMLCfgCodeGroups");
		return hr;
	}

	long cNrChildren = 0;
	hr = spChildren->get_length (&cNrChildren);
	if (FAILED (hr))
	{
		TRACE (L"get_length failed in CXMLCfgCodeGroups");
		return hr;
	}

	for (long idx=0; idx < cNrChildren; ++idx)
	{
		CComPtr<IXMLDOMNode> spNode;
		hr = spChildren->get_item (idx, &spNode);
		if (FAILED (hr))
		{
			TRACE (L"get_item failed in CXMLCfgCodeGroups");
			return hr;
		}

		DOMNodeType nodeType;
		hr = spNode->get_nodeType (&nodeType);
		if (FAILED (hr))
		{
			TRACE (L"get_nodeType failed in CXMLCfgCodeGroups");
			return hr;
		}

		if (nodeType == NODE_ELEMENT)
		{
			CComQIPtr<IXMLDOMElement, &IID_IXMLDOMElement> spElement = spNode;
			
			CComBSTR bstrTagName;
			hr = spElement->get_tagName (&bstrTagName);
			if (FAILED (hr))
			{
				TRACE (L"get_tagName failed");
				return hr;
			}

			if (wcscmp (bstrTagName, WSZCODEGROUP) == 0)
			{
				CXMLCfgCodeGroups *pCodeGroup = new CXMLCfgCodeGroups;
				if (pCodeGroup == 0)
				{
					return E_OUTOFMEMORY;
				}
				
				hr = m_codegroupChildren.Append (pCodeGroup);
				if (FAILED (hr))
				{
					delete pCodeGroup;
					TRACE(L"Append to codegroupChildren failed");
					return hr;
				}

				hr = pCodeGroup->Init (m_spCtx, m_spNamespace);
				if (FAILED (hr))
				{
					TRACE (L"Codegroup Init failed");
					return hr;
				}
				
				hr = pCodeGroup->ParseXML (spElement);
				if (FAILED (hr))
				{
					TRACE (L"Parse XML for child failed");
					return hr;
				}
			}
			else if (wcscmp (bstrTagName, WSZIMEMBERSHIPCONDITION) == 0)
			{
				CXMLCfgIMembershipCondition *pMembership = new CXMLCfgIMembershipCondition;
				if (pMembership == 0)
				{
					return E_OUTOFMEMORY;
				}
				
				hr = m_membershipChildren.Append (pMembership);
				if (FAILED (hr))
				{
					delete pMembership;
					TRACE (L"Append for memberships failed");
					return hr;
				}

				hr = pMembership->Init (m_spCtx, m_spNamespace);
				if (FAILED (hr))
				{
					TRACE (L"IMembershipCondition init failed");
					return hr;
				}
				
				hr = pMembership->ParseXML (spElement);
				if (FAILED (hr))
				{
					TRACE (L"ParseXML failed for IMembershipCondition child");
					return hr;
				}
			}
			else
			{
				TRACE (L"Unknown element %s", (LPWSTR) bstrTagName);
				return  E_SDTXML_UNEXPECTED;
			}
		}
	}

	return hr;
}


HRESULT
CXMLCfgCodeGroups::ParseXML (IXMLDOMElement *pElement)
{
	ASSERT (m_fInitialized);
	ASSERT (pElement != 0);

	CComBSTR bstrTagName;
	HRESULT hr = pElement->get_tagName (&bstrTagName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get_tagName");
		return hr;
	}
	
	if (wcscmp (bstrTagName, WSZCODEGROUP) != 0)
	{
		TRACE (L"We only can handle codegroups");
		return E_SDTXML_UNEXPECTED;
	}

	hr = GetAttributes (pElement);
	if (FAILED (hr))
	{
		TRACE (L"GetAttributes failed for CodeGroup");
		return hr;
	}

	hr = GetChildren (pElement);
	if (FAILED (hr))
	{
		TRACE (L"GetChildren failed for CodeGroup");
		return hr;
	}

	return hr;
}

HRESULT 
CXMLCfgCodeGroups::SaveAsXML (IXMLDOMDocument * pDocument, IXMLDOMElement *pParent, ULONG iIndent)
{
	ASSERT (pDocument != 0);
	// pParent can be 0

	CComPtr<IXMLDOMElement> spElement;
	HRESULT hr = pDocument->createElement ((LPWSTR) WSZCODEGROUP, &spElement);
	if (FAILED (hr))
	{
		TRACE (L"Creation of %s element failed", WSZCODEGROUP);
		return hr;
	}

	if (pParent== 0)
	{
		hr = pDocument->putref_documentElement(spElement);
		if (FAILED (hr))
		{
			TRACE (L"Unable to set documentElement");
			return hr;
		}
	}
	else
	{
		_bstr_t bstrNewLine = L"\n";

		for (ULONG idx=0; idx < iIndent; ++idx)
		{
			bstrNewLine += L"\t";
		}

		CComPtr<IXMLDOMText> spTextNode;
		hr = pDocument->createTextNode(bstrNewLine, &spTextNode);
		if (FAILED (hr))
		{
			TRACE (L"Unable to add new line text node");
			return hr;
		}

		hr = pParent->appendChild (spTextNode, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to append textnode child");
			return hr;
		}

		hr = pParent->appendChild (spElement, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to append Child to parent");
			return hr;
		}
	}

	hr = SetAttribute (bstrAttrClass, m_varClass, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrAttrClass, WSZCODEGROUP);
		return hr;
	}

	hr = SetAttribute (bstrAttrVersion, m_varVersion, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrAttrVersion, WSZCODEGROUP);
		return hr;
	}

	hr = SetAttribute (bstrAttrPermissionSetName, m_varPermissionSetName, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrAttrPermissionSetName, WSZCODEGROUP);
		return hr;
	}

	ASSERT (m_varAttributes.vt == VT_I4);
	ULONG cValAttributes = (long) m_varAttributes;

	if (cValAttributes == 0)
	{
		m_varAttributes.Clear ();
	}
	else if (cValAttributes == 1)
	{
		m_varAttributes = wszAttributesExclusive;
	}
	else if (cValAttributes == 2)
	{
		m_varAttributes = wszAttributesLevelFinal;
	}
	else if (cValAttributes == 3)
	{
		m_varAttributes = wszAttributesExclLevelFinal;
	}
	else
	{
		TRACE (L"Invalid value for attributes attribute: %d", cValAttributes);
		return E_SDTXML_INVALID_ENUM_OR_FLAG;
	}


	hr = SetAttribute (bstrAttributes, m_varAttributes, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrAttrPermissionSetName, WSZCODEGROUP);
		return hr;
	}

	for (TList<CXMLCfgCodeGroups *>::Iterator pChild = m_codegroupChildren.Begin ();
		     pChild != m_codegroupChildren.End();
			 pChild.Next ())
		 {
			 hr = pChild.Value()->SaveAsXML (pDocument, spElement, iIndent + 1);
			 if (FAILED (hr))
			 {
				 TRACE (L"Unable to save child as XML");
				 return hr;
			 }
		 }

	for (TList<CXMLCfgIMembershipCondition *>::Iterator pMember = m_membershipChildren.Begin ();
		     pMember != m_membershipChildren.End();
			 pMember.Next ())
		 {
			hr = pMember.Value()->SaveAsXML (pDocument, spElement, iIndent + 1);
			if (FAILED (hr))
			{
				TRACE (L"Unable to save membership child as XML");
				return hr;
			}			 
		 }

	if (m_codegroupChildren.Size () > 0 ||	m_membershipChildren.Size () > 0)
	{
		_bstr_t bstrNewLine = L"\n";

		for (ULONG idx=0; idx < iIndent; ++idx)
		{
			bstrNewLine += L"\t";
		}

		CComPtr<IXMLDOMText> spTextNode;
		hr = pDocument->createTextNode(bstrNewLine, &spTextNode);
		if (FAILED (hr))
		{
			TRACE (L"Unable to create newline text node");
			return hr;
		}

		hr = spElement->appendChild (spTextNode, 0);
		if (FAILED (hr))
		{
			TRACE (L"Unable to append child textnode");
			return hr;
		}
	}
	return hr;
}

HRESULT 
CXMLCfgCodeGroups::SetAttribute (_bstr_t& bstrName,
				   			     _variant_t& varValue,
								 IXMLDOMElement * pElement)
{
	HRESULT hr = S_OK;
	if (varValue.vt != VT_NULL && varValue.vt != VT_EMPTY)
	{
		hr = pElement->setAttribute (bstrName, varValue);
	}

	return hr;
}

HRESULT 
CXMLCfgCodeGroups::AsWMIInstance (LPCWSTR i_wszSelector, IWbemClassObject **o_pInstance)
{
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pInstance != 0);
	ASSERT (m_pwszSelector == 0);

	m_pwszSelector = i_wszSelector;

	HRESULT hr = m_spClassObject->SpawnInstance(0, o_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class %s", WSZCODEGROUP);
		return hr;
	}

	hr = SetWMIProperties (*o_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"SetWMIProperties failed for CXMLCfgCodeGroups");
		return hr;
	}

	hr = CodeGroupChildrenAsWMI (*o_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"CodeGroupChildrenAsWMI failed");
		return hr;
	}

	hr = IMembershipConditionsAsWMI (*o_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"IMembershipConditionsAsWMI failed");
		return hr;
	}

	return hr;
}


HRESULT 
CXMLCfgCodeGroups::SetWMIProperty (_bstr_t& bstrName, _variant_t& varValue, IWbemClassObject * pInstance)
{
	ASSERT (pInstance != 0);

	HRESULT hr = S_OK;

	if (varValue.vt != VT_NULL && varValue.vt != VT_EMPTY)
	{
		// add all the individual properties
		hr = pInstance->Put(bstrName, 0, &varValue, 0);
		if (FAILED (hr))
		{
			TRACE (L"WMI Put property of %s failed", (LPWSTR) bstrName);
			return hr;
		}
	}

	return hr;
}

HRESULT
CXMLCfgCodeGroups::SetWMIProperties (IWbemClassObject* i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;
	_bstr_t bstrClassName (wszClassName);
	hr = SetWMIProperty (bstrClassName, m_varClass, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrAttrClass, WSZCODEGROUP);
		return hr;
	}

	hr = SetWMIProperty (bstrAttrVersion, m_varVersion, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrAttrVersion, WSZCODEGROUP);
		return hr;
	}

	hr = SetWMIProperty (bstrAttrPermissionSetName, m_varPermissionSetName, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrAttrPermissionSetName, WSZCODEGROUP);
		return hr;
	}

	hr = SetWMIProperty (bstrPolicyVersion, m_varPolicyVersion, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrPolicyVersion, WSZCODEGROUP);
		return hr;
	}

	hr = SetWMIProperty (bstrAttributes, m_varAttributes, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrAttributes, WSZCODEGROUP);
		return hr;
	}

	// and set the selector

	_bstr_t bstrSelector (WSZSELECTOR);
	_variant_t varValSelector (m_pwszSelector);

	hr = SetWMIProperty (bstrSelector, varValSelector, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", WSZSELECTOR, WSZCODEGROUP);
		return hr;
	}

	return hr;
}

HRESULT
CXMLCfgCodeGroups::CodeGroupChildrenAsWMI (IWbemClassObject *i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;
	if (m_codegroupChildren.Size () > 0)
	{
		SAFEARRAYBOUND safeArrayBounds[1];
		safeArrayBounds[0].lLbound = 0;
		safeArrayBounds[0].cElements = m_codegroupChildren.Size ();
		SAFEARRAY *safeArray = SafeArrayCreate(VT_UNKNOWN, 1, safeArrayBounds);
		if (safeArray == 0)
		{
			return E_OUTOFMEMORY;
		}

		ULONG idx = 0;
		for (TList<CXMLCfgCodeGroups *>::Iterator pChild = m_codegroupChildren.Begin ();
			 pChild != m_codegroupChildren.End ();
			 pChild.Next(), ++idx)
			 {
				CComPtr<IWbemClassObject> spNewInstance;
				// children have empty selector
				hr = pChild.Value ()->AsWMIInstance (L"", &spNewInstance);
				if (FAILED (hr))
				{
					TRACE (L"AsWMIInstace for child failed");
					return hr;
				}

				hr = SafeArrayPutElement (safeArray, (LONG *)&idx , spNewInstance);
				if (FAILED (hr))
				{
					TRACE (L"SafeArrayPutElement failed in AsWMIInstance");
					return hr;
				}
			 }

		_variant_t varResult;
		varResult.vt	= VT_UNKNOWN | VT_ARRAY;
		varResult.parray = safeArray;

		_bstr_t bstrChildren (wszChildren);
		hr = SetWMIProperty (bstrChildren, varResult, i_pInstance);
		if (FAILED (hr))
		{
			TRACE (L"Setting of child codegroup array failed");
			return hr;
		}
	}

	return hr;
}

HRESULT 
CXMLCfgCodeGroups::IMembershipConditionsAsWMI (IWbemClassObject *i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;

	if (m_membershipChildren.Size () > 0)
	{
		SAFEARRAYBOUND safeArrayBounds[1];
		safeArrayBounds[0].lLbound = 0;
		safeArrayBounds[0].cElements = m_membershipChildren.Size ();
		SAFEARRAY *safeArray = SafeArrayCreate(VT_UNKNOWN, 1, safeArrayBounds);
		if (safeArray == 0)
		{
			return E_OUTOFMEMORY;
		}

		ULONG idx = 0;
		for (TList<CXMLCfgIMembershipCondition *>::Iterator pChild = m_membershipChildren.Begin ();
			 pChild != m_membershipChildren.End ();
			 pChild.Next(), ++idx)
			 {
				CComPtr<IWbemClassObject> spNewInstance;
				// children have empty selector
				hr = pChild.Value ()->AsWMIInstance (L"", &spNewInstance);
				if (FAILED (hr))
				{
					TRACE (L"AsWMIInstance for membershipcondition child failed");
					return hr;
				}

				hr = SafeArrayPutElement (safeArray, (LONG *)&idx , spNewInstance);
				if (FAILED (hr))
				{
					TRACE (L"SafeArrayPutElement failed in AsWMIInstance");
					return hr;
				}
			 }

		_variant_t varResult;
		varResult.vt	= VT_UNKNOWN | VT_ARRAY;
		varResult.parray = safeArray;

		_bstr_t bstrMemberShip (wszMembership);
		hr = SetWMIProperty (bstrMemberShip, varResult, i_pInstance);
		if (FAILED (hr))
		{
			TRACE (L"Setting of child codegroup array failed");
			return hr;
		}
	}

	return hr;
}

HRESULT 
CXMLCfgCodeGroups::CreateFromWMI (IWbemClassObject * i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = SetPropertiesFromWMI (i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set properties from WMI");
		return hr;
	}

	hr = CodeGroupChildrenFromWMI (i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create CodeGroupChildren from WMI");
		return hr;
	}

	hr = IMembershipConditionsFromWMI (i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create IMembershipConditions from WMI");
		return hr;
	}

	return hr;
}

HRESULT
CXMLCfgCodeGroups::SetPropertiesFromWMI (IWbemClassObject * i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;
	hr = i_pInstance->Get (wszClassName, 0, &m_varClass, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Failed to get propery %s of class %s", (LPWSTR) bstrAttrClass, WSZCODEGROUP);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrAttrVersion, 0, &m_varVersion, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get property %s of %s", (LPWSTR) bstrAttrVersion, WSZCODEGROUP);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrAttrPermissionSetName, 0, &m_varPermissionSetName, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrAttrPermissionSetName, WSZCODEGROUP);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrPolicyVersion, 0, &m_varPolicyVersion, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrAttrPermissionSetName, WSZCODEGROUP);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrAttributes, 0, &m_varAttributes, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrAttributes, WSZCODEGROUP);
		return hr;
	}

	return hr;
}

HRESULT 
CXMLCfgCodeGroups::CodeGroupChildrenFromWMI (IWbemClassObject *i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;
	_variant_t varChildren;
	hr = i_pInstance->Get (wszChildren, 0, &varChildren, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get children parameter from WMI");
		return hr;
	}

	if (varChildren.vt == VT_NULL || varChildren.vt == VT_EMPTY)
	{
		return S_OK;
	}

	SAFEARRAY *pChildren = varChildren.parray;
	ASSERT (pChildren != 0);
	
	long cNrChildren = pChildren->rgsabound[0].cElements;

	for (long idx=0; idx < cNrChildren; ++idx)
	{
		CXMLCfgCodeGroups * pChildCodeGroup = new CXMLCfgCodeGroups;
		if (pChildCodeGroup == 0)
		{
			return E_OUTOFMEMORY;
		}

		hr = m_codegroupChildren.Append (pChildCodeGroup);
		if (FAILED (hr))
		{
			delete pChildCodeGroup ;
			TRACE (L"List Append failed for child codegroup");
			return hr;
		}

		hr = pChildCodeGroup->Init (m_spCtx, m_spNamespace);
		if (FAILED (hr))
		{
			TRACE (L"Init failed for child codegroup");
			return hr;
		}

		CComPtr<IWbemClassObject> spChildInstance;
		hr = SafeArrayGetElement (pChildren, &idx, (void *) &spChildInstance);
		if (FAILED (hr))
		{
			TRACE (L"SafeArrayGetElement failed for child codegroup");
			return hr;
		}

		hr = pChildCodeGroup->CreateFromWMI (spChildInstance);
		if (FAILED (hr))
		{
			TRACE (L"CreateFromWMI failed for child codegroup");
			return hr;
		}
	}

	return hr;
}

HRESULT 
CXMLCfgCodeGroups::IMembershipConditionsFromWMI (IWbemClassObject *i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;
	_variant_t varMemberships;
	hr = i_pInstance->Get (wszMembership, 0, &varMemberships, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get children parameter from WMI");
		return hr;
	}

	if (varMemberships.vt == VT_NULL || varMemberships.vt == VT_EMPTY)
	{
		return S_OK;
	}

	SAFEARRAY *pMemberships = varMemberships.parray;
	ASSERT (pMemberships != 0);
	
	long cNrMemberships = pMemberships->rgsabound[0].cElements;

	for (long idx=0; idx < cNrMemberships; ++idx)
	{
		CXMLCfgIMembershipCondition * pMembershipCondition = new CXMLCfgIMembershipCondition;
		if (pMembershipCondition == 0)
		{
			return E_OUTOFMEMORY;
		}

		hr = m_membershipChildren.Append (pMembershipCondition);
		if (FAILED (hr))
		{
			delete pMembershipCondition;
			TRACE (L"List append failed for child membershipcondition");
			return hr;
		}

		hr = pMembershipCondition->Init (m_spCtx, m_spNamespace);
		if (FAILED (hr))
		{
			TRACE (L"Init failed for child membership condition");
			return hr;
		}

		CComPtr<IWbemClassObject> spMembershipInstance;
		hr = SafeArrayGetElement (pMemberships, &idx, (void *) &spMembershipInstance);
		if (FAILED (hr))
		{
			TRACE (L"SafeArrayGetElement failed for child membership condition");
			return hr;
		}

		hr = pMembershipCondition->CreateFromWMI (spMembershipInstance);
		if (FAILED (hr))
		{
			TRACE (L"CreateFromWMI failed for membershipcondition");
			return hr;
		}
	}

	return hr;
}

HRESULT
CXMLCfgCodeGroups::SetRecordProperties (const CConfigRecord& i_record)
{
	HRESULT hr = S_OK;
	hr = i_record.GetValue ((LPWSTR) bstrPolicyVersion, m_varPolicyVersion);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", (LPWSTR) bstrPolicyVersion, WSZCODEGROUP);
		return hr;
	}

	return hr;
}

HRESULT
CXMLCfgCodeGroups::ToCfgRecord (CConfigRecord& io_record)
{
	HRESULT hr = S_OK;
	CComPtr<IXMLDOMDocument> spXMLDoc;
	hr = CoCreateInstance (CLSID_DOMDocument, 0, CLSCTX_INPROC_SERVER, 
							IID_IXMLDOMDocument, (void **) &spXMLDoc);
	if (FAILED (hr))
	{
		TRACE (L"CoCreateInstance failed for IID_IXMLDOMDocument");
		return hr;
	}

	hr = SaveAsXML (spXMLDoc, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"SaveAsXML failed for CXMLCfgCodeGroup");
		return hr;
	}

	CComBSTR bstrXML;
	hr = spXMLDoc->get_xml (&bstrXML);
	if (FAILED (hr))
	{
		TRACE (L"get_xml failed");
		return hr;
	}

	_variant_t varXML = bstrXML;
	hr = io_record.SetValue (L"value", varXML);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set value column");
		return hr;
	}

	hr = io_record.SetValue ((LPWSTR) bstrPolicyVersion, m_varPolicyVersion);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set policy column");
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\xmlcfgcodegroup.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    codegroup.h

$Header: $

Abstract:

Author:
    marcelv 	2/15/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __CODEGROUP_H__
#define __CODEGROUP_H__

#pragma once

#include <atlbase.h>
#include <comdef.h>
#include <wbemidl.h>
#include "catmacros.h"
#include "Tlist.h"

class CXMLCfgIMembershipCondition; // forward declaration
class CConfigRecord;

class CXMLCfgCodeGroups
{
public:
	CXMLCfgCodeGroups ();
	~CXMLCfgCodeGroups ();

	HRESULT Init (IWbemContext *i_pCtx, IWbemServices* i_pNamespace);

	HRESULT ParseXML (IXMLDOMElement * pElement);
	HRESULT SaveAsXML (IXMLDOMDocument * pDocument, IXMLDOMElement *pParent, ULONG iIndent);

	HRESULT SetRecordProperties (const CConfigRecord& i_record);
	HRESULT ToCfgRecord (CConfigRecord& io_record);

	HRESULT AsWMIInstance (LPCWSTR i_wszSelector, IWbemClassObject **o_pInstance);
	HRESULT CreateFromWMI (IWbemClassObject * i_pInstance);

private:
	HRESULT GetAttributes (IXMLDOMElement *pElement);
	HRESULT GetChildren (IXMLDOMElement *pElement);
	HRESULT SetAttribute (_bstr_t& bstrName, _variant_t& varValue,  IXMLDOMElement * pElement);
	HRESULT SetWMIProperty (_bstr_t& bstrName, _variant_t& varValue, IWbemClassObject * pInstance);
	
	// Internal -> WMI
	HRESULT SetWMIProperties (IWbemClassObject* i_pInstance);
	HRESULT CodeGroupChildrenAsWMI (IWbemClassObject *i_pInstance);
	HRESULT IMembershipConditionsAsWMI (IWbemClassObject *i_pInstance);

	// WMI -> Internal
	HRESULT SetPropertiesFromWMI (IWbemClassObject * i_pInstance);
	HRESULT CodeGroupChildrenFromWMI (IWbemClassObject *i_pInstance);
	HRESULT IMembershipConditionsFromWMI (IWbemClassObject *i_pInstance);

	_variant_t m_varClass;
	_variant_t m_varVersion;
	_variant_t m_varPermissionSetName;
	_variant_t m_varPolicyVersion;
	_variant_t m_varAttributes;

	LPCWSTR m_pwszSelector; // we don't own this memory

	TList<CXMLCfgCodeGroups *>				m_codegroupChildren;
	TList<CXMLCfgIMembershipCondition *>	m_membershipChildren;

	CComPtr<IWbemServices>			m_spNamespace;			// WMI namespace
	CComPtr<IWbemContext>			m_spCtx;				// context
	CComPtr<IWbemClassObject>       m_spClassObject;        // class Object
	bool m_fInitialized;									// are we initialized?
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\xmlcfgimembershipcondition.cpp ===
#include "XMLCfgIMembershipCondition.h"
#include "localconstants.h"


static _bstr_t bstrclass = L"class";
static _bstr_t bstrversion = L"version";
static _bstr_t bstrSite = L"Site";
static _bstr_t bstrx509Certificate = L"x509Certificate";
static _bstr_t bstrPublicKeyBlob = L"PublicKeyBlob";
static _bstr_t bstrName = L"Name";
static _bstr_t bstrAssemblyVersion = L"AssemblyVersion";
static _bstr_t bstrUrl = L"Url";
static _bstr_t bstrZone = L"Zone";
static _bstr_t bstrHashValue = L"HashValue";
static _bstr_t bstrHashAlgorithm = L"HashAlgorithm";

static LPCWSTR wszIMemberShipCondition = WSZIMEMBERSHIPCONDITION;

static LPCWSTR wszClassName = L"className";

//=================================================================================
// Function: CXMLCfgIMembershipCondition::CXMLCfgIMembershipCondition
//
// Synopsis: Constructor
//=================================================================================
CXMLCfgIMembershipCondition::CXMLCfgIMembershipCondition ()
{
	m_pwszSelector = 0;
	m_fInitialized = false;
}

//=================================================================================
// Function: CXMLCfgIMembershipCondition::~CXMLCfgIMembershipCondition
//
// Synopsis: Destructor
//=================================================================================
CXMLCfgIMembershipCondition::~CXMLCfgIMembershipCondition ()
{

}

//=================================================================================
// Function: CXMLCfgIMembershipCondition::Init
//
// Synopsis: Initializes the object
//
// Arguments: [i_pCtx] - context
//            [i_pNamespace] - namespace
//=================================================================================
HRESULT 
CXMLCfgIMembershipCondition::Init (IWbemContext *i_pCtx, IWbemServices* i_pNamespace)
{
	ASSERT (i_pCtx != 0);
	ASSERT (i_pNamespace != 0);

	m_spCtx			= i_pCtx;
	m_spNamespace	= i_pNamespace;

	// get the WMI Object for the IMembershipCondditon class
	HRESULT hr = m_spNamespace->GetObject((LPWSTR) wszIMemberShipCondition, 
											0, 
											m_spCtx, 
											&m_spClassObject, 
											0); 
	if (FAILED (hr))
	{
		TRACE (L"Unable to get class object for class %s", wszIMemberShipCondition );
		return hr;
	}

	m_fInitialized = true;

	return hr;
}

//=================================================================================
// Function: CXMLCfgIMembershipCondition::GetAttributes
//
// Synopsis: Get all attributes of the IMembershipCondition XML element
//
// Arguments: [pElement] - element to get attributes for
//=================================================================================
HRESULT 
CXMLCfgIMembershipCondition::GetAttributes (IXMLDOMElement *pElement)
{
	ASSERT (pElement != 0);
	ASSERT (m_fInitialized);

	HRESULT hr = S_OK;

	hr = pElement->getAttribute (bstrclass, &m_varclass);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrclass, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrversion, &m_varversion);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrversion, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrSite, &m_varSite);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrSite, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrx509Certificate, &m_varx509Certificate);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrx509Certificate, wszIMemberShipCondition);
		return hr;
	}
	
	hr = pElement->getAttribute (bstrPublicKeyBlob, &m_varPublicKeyBlob);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrPublicKeyBlob, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrName, &m_varName);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrName, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrAssemblyVersion, &m_varAssemblyVersion);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrAssemblyVersion, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrUrl, &m_varUrl);
	if (FAILED (hr))
	{
	    TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrUrl, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrZone, &m_varZone);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrZone, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrHashValue, &m_varHashValue);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrHashValue, wszIMemberShipCondition);
		return hr;
	}

	hr = pElement->getAttribute (bstrHashAlgorithm, &m_varHashAlgorithm);
	if (FAILED (hr))
	{
		TRACE (L"Unable to getAttribute %s for %s\n", (LPWSTR) bstrHashAlgorithm, wszIMemberShipCondition);
		return hr;
	}

	return hr;
}

HRESULT 
CXMLCfgIMembershipCondition::ParseXML (IXMLDOMElement *pElement)
{
	ASSERT (m_fInitialized);
	ASSERT (pElement != 0);

	CComBSTR bstrTagName;
	HRESULT hr = pElement->get_tagName (&bstrTagName);	
	if (FAILED (hr))
	{
		TRACE(L"Unable to get element tag name");
		return hr;
	}

	if (_wcsicmp (bstrTagName, wszIMemberShipCondition) != 0)
	{
		TRACE (L"Unsupported tagname: %s", (LPWSTR) bstrTagName);
		return  E_SDTXML_UNEXPECTED;
	}

	hr = GetAttributes (pElement);
	if (FAILED (hr))
	{
		TRACE(L"Unable to get attributes for %s", wszIMemberShipCondition);
		return hr;
	}

	hr = GetChildren (pElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get child information");
		return hr;
	}

	return hr;
}


HRESULT
CXMLCfgIMembershipCondition::GetChildren (IXMLDOMElement *pElement)
{
	ASSERT (pElement != 0);
	// no children, so nothing to do
	return S_OK;
}

HRESULT 
CXMLCfgIMembershipCondition::SaveAsXML (IXMLDOMDocument * pDocument, IXMLDOMElement *pParent, ULONG iIndent)
{
	ASSERT (pDocument != 0);
	ASSERT (pParent != 0);

	CComPtr<IXMLDOMElement> spElement;
	HRESULT hr = pDocument->createElement ((LPWSTR)wszIMemberShipCondition, &spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create element %s", wszIMemberShipCondition);
		return hr;
	}

	_bstr_t bstrNewLine = L"\n";

	for (ULONG idx=0; idx < iIndent; ++idx)
	{
		bstrNewLine += L"\t";
	}

	CComPtr<IXMLDOMText> spTextNode;
	hr = pDocument->createTextNode(bstrNewLine, &spTextNode);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create text node");
		return hr;
	}

	hr = pParent->appendChild (spTextNode, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to append text node");
		return hr;
	}

	hr = pParent->appendChild (spElement, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to append child to parent");
		return hr;
	}

	hr = SetAttribute (bstrclass, m_varclass, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrclass, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrversion, m_varversion, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrversion, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrSite, m_varSite, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrSite, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrx509Certificate, m_varx509Certificate, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrx509Certificate, wszIMemberShipCondition);
		return hr;
	}
	
	hr = SetAttribute (bstrPublicKeyBlob, m_varPublicKeyBlob, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrPublicKeyBlob, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrName, m_varName, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrName, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrAssemblyVersion, m_varAssemblyVersion, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrAssemblyVersion, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrUrl, m_varUrl, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrUrl, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrZone, m_varZone, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrZone, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrHashValue, m_varHashValue, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrHashValue, wszIMemberShipCondition);
		return hr;
	}

	hr = SetAttribute (bstrHashAlgorithm, m_varHashAlgorithm, spElement);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set attribute %s for %s", (LPWSTR) bstrHashAlgorithm, wszIMemberShipCondition);
		return hr;
	}

	return hr;
}

HRESULT 
CXMLCfgIMembershipCondition::SetAttribute (_bstr_t& bstrAttrPermissionSetName,
										   _variant_t& varValue,
								 IXMLDOMElement * pElement)
{
	HRESULT hr = S_OK;
	if (varValue.vt != VT_NULL && varValue.vt != VT_EMPTY)
	{
		hr = pElement->setAttribute (bstrAttrPermissionSetName, varValue);
	}

	return hr;
}

HRESULT 
CXMLCfgIMembershipCondition::SetWMIProperty (_bstr_t& bstrName,
				   			       _variant_t& varValue,
								   IWbemClassObject * pInstance)
{
	ASSERT (pInstance != 0);

	if (varValue.vt == VT_NULL ||varValue.vt == VT_EMPTY)
	{
		return S_OK;
	}

	// add all the individual properties
	HRESULT hr = pInstance->Put(bstrName, 0, &varValue, 0);
	if (FAILED (hr))
	{
		TRACE (L"WMI Put property of %s and value %s failed",
			   (LPWSTR) bstrName, (LPWSTR)(varValue.bstrVal));
		return hr;
	}

	return hr;
}

HRESULT 
CXMLCfgIMembershipCondition::AsWMIInstance (LPCWSTR i_wszSelector, IWbemClassObject **o_pInstance)
{
	ASSERT (i_wszSelector != 0);
	ASSERT (o_pInstance != 0);
	ASSERT (m_pwszSelector == 0);

	m_pwszSelector = i_wszSelector;


	//Create one empty instance from the above class
	HRESULT hr = m_spClassObject->SpawnInstance(0, o_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to create new instance for class %s", L"CodeGroups");
		return hr;
	}

	hr = SetWMIProperties (*o_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"SetWMIProperties failed for %s", wszIMemberShipCondition);
		return hr;
	}

	return hr;
}

HRESULT 
CXMLCfgIMembershipCondition::SetWMIProperties (IWbemClassObject* i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;

	_bstr_t bstrClassName (wszClassName);
	hr = SetWMIProperty (bstrClassName, m_varclass, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrclass, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrversion, m_varversion, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrversion, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrSite, m_varSite, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrSite, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrx509Certificate, m_varx509Certificate, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrx509Certificate, wszIMemberShipCondition);
		return hr;
	}
	
	hr = SetWMIProperty (bstrPublicKeyBlob, m_varPublicKeyBlob, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrPublicKeyBlob, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrName, m_varName, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrName, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrAssemblyVersion, m_varAssemblyVersion, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrAssemblyVersion, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrUrl, m_varUrl, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrUrl, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrZone, m_varZone, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrZone, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrHashValue, m_varHashValue, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrHashValue, wszIMemberShipCondition);
		return hr;
	}

	hr = SetWMIProperty (bstrHashAlgorithm, m_varHashAlgorithm, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrHashAlgorithm, wszIMemberShipCondition);
		return hr;
	}

	// and set the selector

	_bstr_t bstrSelector (WSZSELECTOR);
	_variant_t varValSelector (m_pwszSelector);

	hr = SetWMIProperty (bstrSelector, varValSelector, i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set property %s of %s", WSZSELECTOR, wszIMemberShipCondition);
		return hr;
	}

	return hr;
}

HRESULT 
CXMLCfgIMembershipCondition::CreateFromWMI (IWbemClassObject * i_pInstance)
{
	ASSERT (i_pInstance != 0);
	HRESULT hr = S_OK;

	hr = SetPropertiesFromWMI (i_pInstance);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set properties from WMI");
		return hr;
	}

	return hr;
}

HRESULT
CXMLCfgIMembershipCondition::SetPropertiesFromWMI (IWbemClassObject * i_pInstance)
{
	ASSERT (i_pInstance != 0);

	HRESULT hr = S_OK;

	hr = i_pInstance->Get (wszClassName, 0, &m_varclass, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrclass, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrversion, 0, &m_varversion, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrversion, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrSite, 0, &m_varSite, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrSite, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrx509Certificate, 0, &m_varx509Certificate, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrx509Certificate, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrPublicKeyBlob, 0, &m_varPublicKeyBlob, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrPublicKeyBlob, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrName, 0, &m_varName, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrName, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrAssemblyVersion, 0, &m_varAssemblyVersion, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrAssemblyVersion, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrUrl, 0, &m_varUrl, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrUrl, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrZone, 0, &m_varZone, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrZone, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrHashValue, 0, &m_varHashValue, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to get WMI Property %s for class %s", (LPWSTR) bstrHashValue, wszIMemberShipCondition);
		return hr;
	}

	hr = i_pInstance->Get ((LPWSTR)bstrHashAlgorithm, 0, &m_varHashAlgorithm, 0, 0);
	if (FAILED (hr))
	{
		TRACE (L"Unable to set WMI Property %s for class %s", (LPWSTR) bstrHashAlgorithm, wszIMemberShipCondition);
		return hr;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\wqlparser.cpp ===
/**************************************************************************++
Copyright (c) 2000 Microsoft Corporation

Module name: 
    wqlparser.cpp

$Header: $

Abstract:

Author:
    marcelv 	11/10/2000		Initial Release

Revision History:

--**************************************************************************/

#include "wqlparser.h"
#include "stringutil.h"
#include "localconstants.h"
#include <wbemidl.h>
	
static LPCWSTR wszSelect	= L"select ";
static const SIZE_T cSelect	= wcslen (wszSelect);
static LPCWSTR wszFrom		= L" from ";
static const SIZE_T cFrom	= wcslen (wszFrom);
static LPCWSTR wszWhere		= L" where ";
static const SIZE_T cWhere	= wcslen (wszWhere);
static LPCWSTR wszAnd		= L" and ";
static const SIZE_T cAnd	= wcslen (wszAnd);
static LPCWSTR wszOr		= L" or ";
static const SIZE_T cOr		= wcslen (wszOr);
static LPCWSTR wszSelector  = L"selector";
static const SIZE_T cSelector= wcslen (wszSelector);

//=================================================================================
// Function: CWQLProperty::CWQLProperty
//
// Synopsis: Constructor
//=================================================================================
CWQLProperty::CWQLProperty () 
{ 
	m_wszName		= 0; 
	m_wszValue		= 0;
	m_wszOperator	= 0;
}

//=================================================================================
// Function: CWQLProperty::~CWQLProperty
//
// Synopsis: Destructor
//=================================================================================
CWQLProperty::~CWQLProperty () 
{
	delete [] m_wszOperator;
	m_wszOperator = 0;

	delete [] m_wszName;
	m_wszName = 0;

	delete [] m_wszValue;
	m_wszValue = 0;
}

//=================================================================================
// Function: CWQLProperty::GetValue
//
// Synopsis: Gets a property value
//=================================================================================
LPCWSTR 
CWQLProperty::GetValue () const
{
	ASSERT (m_wszValue != 0);
	return m_wszValue;
}

//=================================================================================
// Function: CWQLProperty::GetName
//
// Synopsis: Gets a property name
//=================================================================================
LPCWSTR 
CWQLProperty::GetName () const
{
	ASSERT (m_wszName != 0);
	return m_wszName;
}

//=================================================================================
// Function: CWQLProperty::GetOperator
//
// Synopsis: Get an operator (=,<,>, etc) used in a property condition
//=================================================================================
LPCWSTR 
CWQLProperty::GetOperator () const
{
	ASSERT (m_wszOperator != 0);
	return m_wszOperator;
}

//=================================================================================
// Function: CWQLProperty::SetName
//
// Synopsis: Set the name of a property. The name that is passed in contains
//           some garbage (opening,closing brackets), that will be stripped off.
//
// Arguments: [wszName] - name to set property name to
//=================================================================================
HRESULT 
CWQLProperty::SetName (LPCWSTR wszName)
{
	ASSERT (wszName != 0);

	SIZE_T iLen = wcslen (wszName);
	m_wszName = new WCHAR [iLen + 1];
	if (m_wszName == 0)
	{
		return E_OUTOFMEMORY;
	}

	ULONG iInsertIdx = 0;
	for (ULONG idx=0; idx < iLen; ++idx)
	{
		switch (wszName[idx])
		{
		case L' ':  // skip spaces
			break;
		case L'(':	// skip opening bracket
			break;
		case L')':	// skip closing bracket
			break;
		default:
			m_wszName[iInsertIdx++] = wszName[idx];
			break;
		}
	}

	m_wszName[iInsertIdx] = L'\0';

	return S_OK;
}

//=================================================================================
// Function: CWQLProperty::SetValue
//
// Synopsis: Set the value of a property. The value that is passed in contains garbage
//           like opening/closing brackets, beginning/ending double quotes that will
//           be removed
//
// Arguments: [wszValue] - value to set property value to
//=================================================================================
HRESULT 
CWQLProperty::SetValue (LPCWSTR wszValue) 
{
	ASSERT (wszValue != 0);
	ASSERT (m_wszName != 0);

	SIZE_T iLen = wcslen (wszValue);
	m_wszValue = new WCHAR [iLen + 1];
	if (m_wszValue == 0)
	{
		return E_OUTOFMEMORY;
	}

	if ((wszValue[0] == L'\"') ||(wszValue[0] == L'\''))
	{
		wcscpy (m_wszValue, wszValue +1);
		iLen--;
	}
	else
	{
		wcscpy (m_wszValue, wszValue);
	}

	// get rid of closing bracket
	if (m_wszValue[iLen-1] == L')')
	{
		m_wszValue[iLen-1] = L'\0';
		iLen--;
	}

	// get rid of ending single or double quote
	if (m_wszValue[iLen-1] == L'\"' || m_wszValue[iLen-1] == L'\'')
	{
		m_wszValue[iLen-1] = L'\0';
		iLen--;
	}

	// get rid of escape characters
	ULONG jdx = 0;
	for (ULONG idx=0; idx < iLen; ++idx)
	{
		if (m_wszValue[idx] == L'\\')
		{
			idx++;
		}
		m_wszValue[jdx++] = m_wszValue[idx];
	}
	m_wszValue[jdx] = L'\0';

	return S_OK;
}

//=================================================================================
// Function: CWQLProperty::SetOperator
//
// Synopsis: Sets the value of a property operator
//
// Arguments: [wszOperator] - value to set propety operator to
//=================================================================================
HRESULT 
CWQLProperty::SetOperator (LPWSTR wszOperator)
{
	ASSERT (wszOperator != 0);

	m_wszOperator = new WCHAR [wcslen (wszOperator) + 1];
	if (m_wszOperator == 0)
	{
		return E_OUTOFMEMORY;
	}
	wcscpy (m_wszOperator, wszOperator);

	return S_OK;
}

//=================================================================================
// Function: CWQLParser::CWQLParser
//
// Synopsis: Default Constructor
//=================================================================================
CWQLParser::CWQLParser ()
{
	m_wszQuery			= 0;
	m_pClass			= 0;
	m_aWQLProperties	= 0;
	m_cNrProps			= 0;		
	m_fParsed			= false;
}

//=================================================================================
// Function: CWQLParser::~CWQLParser
//
// Synopsis: Default Destructor
//=================================================================================
CWQLParser::~CWQLParser ()
{
	delete [] m_wszQuery;
	m_wszQuery = 0;

	delete [] m_aWQLProperties;
	m_aWQLProperties = 0;
}

//=================================================================================
// Function: CWQLParser::Parse
//
// Synopsis: Parser a WQL query. 
//			 The currently supported format is
//
//           SELECT * FROM <className>
//			 WHERE <prop1> = "<val1>"
//           AND   <prop2> = <val2>
//           AND   <prop3> = "<val3>"
//
// Arguments: [i_wszQuery] - query to parser	
//            
// Return Value: S_OK if query parsed ok, error else
//=================================================================================
HRESULT
CWQLParser::Parse (LPCWSTR i_wszQuery)
{
	ASSERT (!m_fParsed);
	ASSERT (i_wszQuery != 0);

	HRESULT hr = S_OK;

	// and convert to lower case and remove double slashes to make searching for key-words easier.
	m_wszQuery = CWMIStringUtil::StrToLower (i_wszQuery);
	if (m_wszQuery == 0)
	{
		return E_OUTOFMEMORY;
	}
	
	// we do not fully support OR queries. In case we find an OR, we are going to reformat
	// the query to remove everything in the where clause and only keep the selector property
	// there
	if (CWMIStringUtil::FindStr (m_wszQuery, wszOr) != 0)
	{
		hr = ReformatQuery ();
		if (FAILED (hr))
		{
			TRACE (L"Reformatting of query failed (OR clause found)");
			return hr;
		}
	}

	// WMI assures that we start with SELECT
	ASSERT (wcsncmp (m_wszQuery, wszSelect, cSelect) == 0);

	// find from to find out where the classname starts
	LPWSTR pFromStart = CWMIStringUtil::FindStr (m_wszQuery, wszFrom);
	ASSERT (pFromStart != 0);

	m_pClass = pFromStart + cFrom;
	LPWSTR pClassEnd = wcschr(m_pClass, L' ');
	if (pClassEnd != 0)
	{
		// we have where/and clause that we need to handle
		
		LPWSTR pWhereStart = CWMIStringUtil::FindStr (pClassEnd, wszWhere);
		*pClassEnd = L'\0'; // set to null after searching, else search will fail
		if (pWhereStart != 0)
		{
			// we have a where clause. Count the number of conditions so that we
			// can allocate enough memory
			m_cNrProps = 1;

			pWhereStart += cWhere;
			for (LPWSTR pFinder = CWMIStringUtil::FindStr (pWhereStart, wszAnd);
			     pFinder != 0;
				 pFinder = CWMIStringUtil::FindStr (pFinder + cAnd, wszAnd))
				 {
					 ++m_cNrProps;
				 }

			m_aWQLProperties = new CWQLProperty [m_cNrProps];
			if (m_aWQLProperties == 0)
			{
				return E_OUTOFMEMORY;
			}

			// Go over all the conditions and extract the property values
			LPWSTR pStart = pWhereStart;
			for (ULONG idx=0; idx < m_cNrProps; ++idx)
			{
				LPWSTR pEqual = CWMIStringUtil::FindChar (pStart, L"=<>");
				ASSERT (pEqual != 0);

				LPWSTR pEqualEnd = pEqual + 1;
				while (wcschr(L"=<>", *pEqualEnd) != 0)
				{
					++pEqualEnd;
				}

				WCHAR wcTmp = *pEqualEnd;
				*pEqualEnd = L'\0';
				m_aWQLProperties[idx].SetOperator (pEqual);
				*pEqualEnd = wcTmp;

				*pEqual = L'\0';

				LPWSTR pFindAnd = CWMIStringUtil::FindStr (pEqualEnd, wszAnd);
				if (pFindAnd != 0)
				{
					*pFindAnd = L'\0';
				}

				hr = m_aWQLProperties[idx].SetName (pStart);
				if (FAILED (hr))
				{
					TRACE (L"Unable to set property name %s", pStart);
					return hr;
				}
				
				hr = m_aWQLProperties[idx].SetValue (CWMIStringUtil::Trim (pEqualEnd, L' '));
				if (FAILED (hr))
				{
					TRACE (L"Unable to set property value %s", pEqualEnd);
					return hr;
				}

				pStart = pFindAnd + cAnd;
			}
		}
	}

	RemoveUnwantedProperties ();

	hr = PostValidateQuery ();
	if (FAILED (hr))
	{
		TRACE (L"Post validation of query failed");
		return hr;
	}

	m_fParsed = true;

	return hr;
}

//=================================================================================
// Function: CObjectPathParser::GetClass
//
// Synopsis: returns the name of the class in the object path string
//=================================================================================
LPCWSTR
CWQLParser::GetClass () const
{
	ASSERT (m_fParsed);
	ASSERT (m_pClass != 0);

	return m_pClass;
}

//=================================================================================
// Function: CWQLParser::GetPropCount
//
// Synopsis: returns number of conditions in the where clause
//=================================================================================
ULONG
CWQLParser::GetPropCount () const
{
	ASSERT (m_fParsed);

	return m_cNrProps;
}

//=================================================================================
// Function: CWQLParser::GetProperty
//
// Synopsis: returns a property from the object path string
//
// Arguments: [idx] - index of property that we want to have information for. needs to
//                    be in between 0 and GetPropCount() -1
//=================================================================================
const CWQLProperty *
CWQLParser::GetProperty (ULONG i_idx) const
{
	ASSERT (m_fParsed);
	ASSERT (m_aWQLProperties != 0);
	ASSERT (i_idx >= 0 && i_idx < m_cNrProps);

	return &m_aWQLProperties[i_idx];
}

//=================================================================================
// Function: CWQLParser::GetPropertyByName
//
// Synopsis: Find a property by name. 
//
// Arguments: [i_wszPropName] - property name to search for
//            [io_Property] - property values will be filled out here
//            
// Return Value: true, property found, false: property not found
//=================================================================================

const CWQLProperty *
CWQLParser::GetPropertyByName (LPCWSTR i_wszPropName)
{
	ASSERT (m_fParsed);
	ASSERT (i_wszPropName != 0);

	for (ULONG idx=0; idx<m_cNrProps; ++idx)
	{
		if (_wcsicmp(m_aWQLProperties[idx].GetName (), i_wszPropName) == 0)
		{
			return &m_aWQLProperties[idx];
			break;
		}
	}

	return 0;
}

//=================================================================================
// Function: CWQLParser::PostValidateQuery
//
// Synopsis: Validates that the query has at the most a single selector property. In
//           case multiple selector properties are found, an error is returned.
//=================================================================================
HRESULT
CWQLParser::PostValidateQuery ()
{
	ASSERT (m_wszQuery != 0);

	// verify that there is one and only one selector property

	bool fSelectorPropertyFound = false;
	for (ULONG idx=0; idx < m_cNrProps; ++idx)
	{
		if (_wcsicmp(m_aWQLProperties[idx].GetName (), WSZSELECTOR) == 0)
		{
			if (fSelectorPropertyFound)
			{
				TRACE (L"Multiple selector properties found in single query");
				return E_INVALIDARG;
			}
			fSelectorPropertyFound = true;
		}
	}

	return S_OK;
}

//=================================================================================
// Function: CWQLParser::RemoveUnwantedProperties
//
// Synopsis: We remove all properties that do not use '=' as operator sign. This is
//           safe to do, because WMI will filter results for us anyway. We loop through
//           all the properties, and if the operator is not '=', we will move the element
//           to the end of the array. Note that we cannot delete elements at this point
//           because elese the delete of the array will blow up. Also, we have to use
//           memcpy to avoid calling the destructor of CWQLProperty.
//=================================================================================
void
CWQLParser::RemoveUnwantedProperties ()
{
	bool fFoundLastValid = false;
	ULONG cLastValidIdx = 0;
	for (LONG idx= m_cNrProps - 1; idx >= 0; --idx)
	{
		if (wcscmp (m_aWQLProperties[idx].GetOperator (), L"=") == 0)
		{
			if (!fFoundLastValid)
			{
				fFoundLastValid = true;
				cLastValidIdx = idx;
			}
		}
		else
		{
			if (fFoundLastValid)
			{
				// swap them around

				BYTE tmpProp[sizeof(CWQLProperty)];
				memcpy (&tmpProp, m_aWQLProperties + idx, sizeof (CWQLProperty));
				memcpy (m_aWQLProperties + idx, m_aWQLProperties + cLastValidIdx, sizeof(CWQLProperty));
				memcpy (m_aWQLProperties + cLastValidIdx, &tmpProp, sizeof(CWQLProperty));
				cLastValidIdx--;
			}
			m_cNrProps--;
		}
	}
}

//=================================================================================
// Function: CWQLParser::ReformatQuery
//
// Synopsis: This function gets invoked when a query contains an OR clause. In this 
//           case all conditions except the condition that containts the SELECTOR 
//           property will be stripped from the WHERE clause.
//=================================================================================
HRESULT 
CWQLParser::ReformatQuery ()
{
	ASSERT (m_wszQuery != 0);

	HRESULT hr = S_OK;
	// find where start

	LPWSTR pWhereStart = CWMIStringUtil::FindStr (m_wszQuery, wszWhere);
	ASSERT (pWhereStart != 0); // we shouldn't be here without where

	LPWSTR pSelectorStart = CWMIStringUtil::FindStr (pWhereStart + cWhere, wszSelector);
	if (pSelectorStart == 0)
	{
		TRACE (L"Unable to find selector property");
		return E_INVALIDARG;
	}

	// see if we have two selectors. If so, we bail out, because the query is too complex
	LPWSTR pSecondSelector = CWMIStringUtil::FindStr (pSelectorStart + cSelector, wszSelector);
	if (pSecondSelector != 0)
	{
		TRACE (L"Unable to handle queries with two OR statements");
		return E_INVALIDARG;
	}

	// next we need to find the end of the selector condition. Search for both
	// AND and OR, and stop at the one that occurs first. If no AND or OR is found
	// we have to stop at the end of the string.

	LPWSTR pAndStart = CWMIStringUtil::FindStr (pSelectorStart + cSelector, wszAnd);
	LPWSTR pOrStart = CWMIStringUtil::FindStr (pSelectorStart + cSelector, wszOr);

	if (pAndStart == 0)
	{
		if (pOrStart == 0)
		{
			// no AND, no OR, wo stop at END of string (pAndStart points to this)
			SIZE_T iLen = wcslen (pSelectorStart);
			pAndStart = pSelectorStart + iLen;
		}
		else
		{
			// no AND, but found an OR
			pAndStart = pOrStart;
		}
	}
	else
	{
		// We found an AND. If we have OR, and OR is before AND, use that instead
		if ((pOrStart != 0) && (pOrStart < pAndStart))
		{
			pAndStart = pOrStart;
		}
	}
	
	ASSERT (pAndStart != 0);
	ASSERT (pAndStart > pSelectorStart);

	// and copy all characters to beginning of where clause
	
	LPWSTR pStartCopy = pWhereStart + cWhere;
	ULONG idx=0;
	for (LPWSTR pCurElem = pSelectorStart; pCurElem != pAndStart; ++pCurElem)
	{
		 pStartCopy[idx++]= *pCurElem;
	 }

    pStartCopy[idx] = L'\0';

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\config\src\urt\wmi\netprovider\xmlcfgimembershipcondition.h ===
/**************************************************************************++
Copyright (c) 2001 Microsoft Corporation

Module name: 
    codegroup.h

$Header: $

Abstract:

Author:
    marcelv 	2/15/2001		Initial Release

Revision History:

--**************************************************************************/

#ifndef __XMLCFGIMEMBERSHIPCONDITION_H__
#define __XMLCFGIMEMBERSHIPCONDITION_H__

#pragma once

#include <atlbase.h>
#include "comdef.h"
#include <wbemidl.h>
#include "catmacros.h"
#include <comdef.h>

class CXMLCfgIMembershipCondition
{
public:
	CXMLCfgIMembershipCondition ();
	~CXMLCfgIMembershipCondition ();

	HRESULT Init (IWbemContext *i_pCtx, IWbemServices* i_pNamespace);

	HRESULT ParseXML (IXMLDOMElement * pElement);
	HRESULT SaveAsXML (IXMLDOMDocument * pDocument, IXMLDOMElement *pParent, ULONG iIndent);
	
	HRESULT AsWMIInstance (LPCWSTR i_wszSelector, IWbemClassObject **o_pInstance);
	HRESULT CreateFromWMI (IWbemClassObject * i_pInstance);

private:
	HRESULT GetAttributes (IXMLDOMElement *pElement);
	HRESULT SetAttributes (IXMLDOMElement *pElement);
	HRESULT SetAttribute (_bstr_t& bstrAttrPermissionSetName,